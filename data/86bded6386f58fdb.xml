<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[Sebastian Ruder]]></title><description><![CDATA[I'm a research scientist at DeepMind. I blog about Machine Learning, Deep Learning, and Natural Language Processing.]]></description><link>http://ruder.io/</link><image><url>http://ruder.io/favicon.png</url><title>Sebastian Ruder</title><link>http://ruder.io/</link></image><generator>Ghost 2.16</generator><lastBuildDate>Mon, 04 Mar 2019 20:39:52 GMT</lastBuildDate><atom:link href="http://ruder.io/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[AAAI 2019 Highlights: Dialogue, reproducibility, and more]]></title><description><![CDATA[This post discusses highlights of AAAI 2019. It covers dialogue, reproducibility, question answering, the Oxford style debate, invited talks, and a diverse set of research papers.]]></description><link>http://ruder.io/aaai-2019-highlights/</link><guid isPermaLink="false">5c76ff7c1b9b0d18555b9ebb</guid><category><![CDATA[events]]></category><category><![CDATA[natural language processing]]></category><category><![CDATA[transfer learning]]></category><category><![CDATA[word embeddings]]></category><dc:creator><![CDATA[Sebastian Ruder]]></dc:creator><pubDate>Thu, 07 Feb 2019 17:00:00 GMT</pubDate><media:content url="http://ruder.io/content/images/2019/02/aaai_reception-1.jpg" medium="image"/><content:encoded><![CDATA[<img src="http://ruder.io/content/images/2019/02/aaai_reception-1.jpg" alt="AAAI 2019 Highlights: Dialogue, reproducibility, and more"><p>This post discusses highlights of the <a href="https://aaai.org/Conferences/AAAI-19/">Thirty-Third AAAI Conference on Artificial Intelligence (AAAI-19)</a>.</p><p>I attended <a href="https://aaai.org/Conferences/AAAI-19/">AAAI 2019</a> in Honolulu, Hawaii last week. Overall, I was particularly surprised by the interest in natural language processing at the conference. There were 15 sessions on NLP (most standing-room only) with ≈10 papers each (oral and spotlight presentations), so around 150 NLP papers (out of 1,150 accepted papers overall). I also really enjoyed the diversity of invited speakers who discussed topics from AI for social good, to adversarial learning and imperfect-information games (videos of all invited talks are available <a href="https://aaai.org/Conferences/AAAI-19/invited-speakers/">here</a>). Another cool thing was the <a href="#debate">Oxford style debate</a>, which required debaters to take controversial positions. This was a nice change of pace from panel discussions, which tend to converge to a uniform opinion.</p><p>Table of contents:</p><ul><li><a href="#dialogue">Dialogue</a></li><li><a href="#reproducibility">Reproducibility</a></li><li><a href="#question-answering">Question answering</a></li><li><a href="#ai-for-social-good">AI for social good</a></li><li><a href="#debate">Debate</a></li><li><a href="#adversarial-learning">Adversarial learning</a></li><li><a href="#imperfect-information-games">Imperfect-information games</a></li><li><a href="#inductive-biases">Inductive biases</a></li><li><a href="#transfer-learning">Transfer learning</a></li><li><a href="#word-embeddings">Word embeddings</a></li><li><a href="#miscellaneous">Miscellaneous</a></li></ul><h1 id="dialogue">Dialogue</h1><p>In his talk at the <a href="https://sites.google.com/view/deep-dial-2019/home?authuser=0">Reasoning and Learning for Human-Machine Dialogues workshop</a>, <a href="https://scholar.google.com/citations?user=V72PR9wAAAAJ&amp;hl=en">Phil Cohen</a> argued that <strong>chatbots are an attempt to avoid solving the hard problems of dialogue</strong>. They provide the <em>illusion</em> of having a dialogue but in fact do not have a clue what we are saying or meaning. What we should rather do is <strong>recognize intents via semantic parsing</strong>. We should then reason about the speech acts, infer a user's <em>plan</em>, and help them to succeed. You can find more information about his views in <a href="https://arxiv.org/abs/1812.01144">this position paper</a>.</p><p>During the panel discussion, <a href="https://www.microsoft.com/en-us/research/people/izitouni/">Imed Zitouni</a> highlighted that the limitations of current dialogue models affect user behaviour. <strong>75-80% of the time users only employ 4 skills</strong>: "play music", "set a timer", "set a reminder", and "what is the weather". Phil argued that we should not have to learn how to talk, how to make an offer, etc. all over again for each domain. We can often build simple dialogue agents for new domains <a href="http://www.aclweb.org/anthology/P18-2008">"overnight"</a>.</p><h1 id="reproducibility">Reproducibility</h1><p>At the <a href="https://www.idi.ntnu.no/~odderik/RAI-2019/">Workshop on Reproducible AI</a>, <a href="http://joelgrus.com/">Joel Grus</a> argued that <a href="https://docs.google.com/presentation/d/1ivK8AKgz8Hx-ZYzPC9gJyQK6tzuhR3UuhCEajFGJDlA/"><strong>Jupyter notebooks are bad for reproducibility</strong></a>. As an alternative, he recommended to adopt higher-level abstractions and declarative configurations. Another good resource for reproducibility is the <a href="https://www.cs.mcgill.ca/~jpineau/ReproducibilityChecklist.pdf">ML reproducibility checklist</a> by <a href="https://www.cs.mcgill.ca/~jpineau/">Joelle Pineau</a>, which provides a list of items for algorithms, theory, and empirical results to enforce reproducibility.</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://ruder.io/content/images/2019/02/unit_tests_for_ai_experiments.png" class="kg-image" alt="AAAI 2019 Highlights: Dialogue, reproducibility, and more"><figcaption>Unit tests for AI experiments recommended by Joel Grus</figcaption></figure><!--kg-card-end: image--><p>A team from Facebook <a href="https://arxiv.org/abs/1902.04522">reported on their experiments reproducing AlphaZero</a> in their <a href="https://github.com/pytorch/ELF">ELF framework</a>, training a model using 2,000 GPUs in 2 weeks. <strong>Reproducing an on-policy, distributed RL system such as AlphaZero is particularly challenging</strong> as it does not have a fixed dataset and optimization is dependent on the distributed environment. Training smaller versions and scaling up is key. For reproducibility, the random seed, the git commit number, and the logs should be stored.</p><p>During the panel discussion, <a href="https://www.ntnu.edu/employees/odderik">Odd Eric Gunderson</a> argued that reproducibility should be defined as the <em>ability of an independent research team to produce the same results using the same AI method based on the documentation by the original authors</em>. Degrees of reproducibility can be measured based on the availability of different types of documentation, such as the method description, data, and code.</p><p><a href="https://www.isye.gatech.edu/users/pascal-van-hentenryck">Pascal van Hentenryck</a> argued that reproducibility could be made part of the peer review process, such as in the <a href="http://mpc.zib.de/">Mathematical Programming Computation journal</a> where each submission requires an executable file (which does not need to be public). He also pointed out that—empirically—papers with supplementary materials are more likely to be accepted.</p><h1 id="question-answering">Question answering</h1><p>At the <a href="https://researcher.watson.ibm.com/researcher/view_group_subpage.php?id=9904">Reasoning and Complex QA Workshop</a>, <a href="https://www.mccormick.northwestern.edu/research-faculty/directory/profiles/forbus-ken.html">Ken Forbus</a> discussed an <a href="http://www.qrg.northwestern.edu/papers/Files/QRG_Dist_Files/QRG_2018/Crouse-McFate-Forbus-2018.pdf">analogical training method for QA</a> that adapts a general-purpose semantic parser to a new domain with few examples. At the end of his talk, Ken argued that the <strong>train/test method in ML is holding us back</strong>. Our learning systems should use rich relational representations, gather their own data, and evaluate progress.</p><p><a href="https://allenai.org/team/ashishs/">Ashish Sabharwal</a> discussed the <a href="https://github.com/allenai/OpenBookQA">OpenBookQA dataset</a> presented at EMNLP 2018 during his talk. The open book setting is situated between reading comprehension and open-ended QA on the textual QA spectrum (see below).</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://ruder.io/content/images/2019/02/textual_qa_spectrum.png" class="kg-image" alt="AAAI 2019 Highlights: Dialogue, reproducibility, and more"><figcaption>The textual QA spectrum</figcaption></figure><!--kg-card-end: image--><p>It is designed to probe a deeper understanding rather than memorization skills and requires applying core principles to new situations. He also argued that while entailment is recognized as a core NLP task with many applications, it is still lacking a convincing application to an end-task. This is mainly due to multi-sentence entailment being a lot harder, as irrelevant sentences often have significant textual overlap.</p><p>Furthermore, he discussed the design of leaderboards, which have to make tradeoffs along multiple competing axes with respect to the host, the submitters, and the community. <strong>A particular deficit of current leaderboards is that they make it difficult to share and build upon successful techniques. </strong>For an extensive discussion of the pros and cons of leaderboards, check out <a href="https://soundcloud.com/nlp-highlights/80-leaderboards-and-science-with-siva-reddy">this recent NLP Highlights podcast</a>.</p><p>The first part of the final panel discussion focused on important outstanding technical challenges for question answering. <a href="https://researcher.watson.ibm.com/researcher/view.php?person=us-witbrock">Michael Witbrock</a> emphasized <strong>techniques to create datasets that cannot easily be exploited by neural networks</strong>, such as the adversarial filtering in <a href="http://aclweb.org/anthology/D18-1009">SWAG</a>. Ken argued that models should come up with answers and explanations rather than performing multiple choice question answering, while Ashish noted that such explanations need to be automatically validated.</p><p><a href="https://www.cs.cmu.edu/~hovy/">Eduard Hovy</a> suggested that one way towards a system that can perform more complex QA could consist of the following steps:</p><ol><li>Build a symbolic numerical reasoner that leverages relations from an existing KB, such as <a href="http://www.cs.utexas.edu/users/ml/nldata/geoquery.html">Geobase</a>, which contains geography facts.</li><li>Look at the subset of questions in existing natural language datasets, which require reasoning that is possible with the reasoner.</li><li>Annotate these questions with semantic parses and train a semantic parsing model to convert the questions to logical forms. These can then be provided to the reasoner to produce an answer.</li><li>Augment the reasoner with another reasoning component and repeat steps 2-3.</li></ol><p>The panel members noted that such reasoners exist, but lack a common API.</p><p>Finally, here are a few papers on question answering that I enjoyed:</p><ul><li><a href="https://www.aaai.org/Papers/AAAI/2019/AAAI-RuckleA.3648.pdf"><strong>COALA: A Neural Coverage-Based Approach for Long Answer Selection with Small Data</strong></a>: An approach that ranks answers based on how many of the question aspects they cover. They incorporate syntactic information via dependency parses and find that this improves performance.</li><li><a href="https://www.aaai.org/Papers/AAAI/2019/AAAI-DengYang.4661.pdf"><strong>Multi-Task Learning with Multi-View Attention for Answer Selection and Knowledge Base Question Answering</strong></a>: Answer selection and knowledge base QA are learned jointly via multi-task learning. Attention is performed on different views of the data.</li><li><a href="https://www.aaai.org/Papers/AAAI/2019/AAAI-TafjordO.6869.pdf"><strong>QUAREL: A Dataset and Models for Answering Questions about Qualitative Relationships</strong></a>: A challenging new QA dataset of 2,771 story questions that require knowledge about qualitative relationships pertaining to 19 quantities such as smoothness, friction, speed, heat, and distance.</li></ul><h1 id="ai-for-social-good">AI for social good</h1><p>During his invited talk, <a href="http://teamcore.usc.edu/tambe/">Milind Tambe</a> looked back on 10 years of research in AI and multiagent systems for social good (video available <a href="https://vimeo.com/313940453">here</a>; slides available <a href="http://teamcore.usc.edu/lectures/AAAI_2019.pdf">here</a>). Milind discussed his research on using game theory to optimize security resources such as <a href="https://pdfs.semanticscholar.org/1a10/5181f785502be8d71e6f6f0569e6eedd60e6.pdf">patrols at airports</a>, <a href="https://research.create.usc.edu/cgi/viewcontent.cgi?referer=https://scholar.google.com/&amp;httpsredir=1&amp;article=1134&amp;context=nonpublished_reports">air marshal assignments on flights</a>, <a href="http://teamcore.usc.edu/projects/coastguard/default.htm">coast guard patrols</a>, and <a href="http://teamcore.usc.edu/people/Paws/index.html">ranger patrols in African national parks to protect against poachers</a>. Overall, his talk was a striking reminder of the positive effects AI can have if it is employed for social good.</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://ruder.io/content/images/2019/02/ml_for_predicting_poacher_behaviour.png" class="kg-image" alt="AAAI 2019 Highlights: Dialogue, reproducibility, and more"><figcaption>An overview of an ML approach for predicting poacher behaviour in an African national park</figcaption></figure><!--kg-card-end: image--><h1 id="debate">Debate</h1><p>The <a href="https://en.wikipedia.org/wiki/Debate#Oxford-style_debating">Oxford style</a> debate focused on the proposition “The AI community today should continue to focus mostly on ML methods” (video available <a href="https://vimeo.com/314378703">here</a>). It pitted <a href="https://www.cs.purdue.edu/homes/neville/">Jennifer Neville</a> and <a href="https://www.cs.utexas.edu/~pstone/">Peter Stone</a> on the 'pro' side against <a href="http://cs.brown.edu/~mlittman/">Michael Littman</a> and <a href="https://allenai.org/team/orene/">Oren Etzioni</a> on the 'against' side, with <a href="https://www.cs.ubc.ca/~kevinlb/">Kevin Leyton-Brown</a> as moderator. Overall, the debate was entertaining and engaging to watch.</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://ruder.io/content/images/2019/02/oxford_style_debate.png" class="kg-image" alt="AAAI 2019 Highlights: Dialogue, reproducibility, and more"><figcaption>The debater panel (from left to right): Peter Stone, Jennifer Neville, Kevin Leyton-Brown (moderator), Michael Littman, Oren Etzioni</figcaption></figure><!--kg-card-end: image--><p>Here are some representative remarks from each of the debaters that stuck with me:</p><blockquote><em>"The unique strength of the AI community is that we focus on the problems that need to be solved." – Jennifer Neville<br>"We are in the middle of one of the most amazing paradigm shifts in all of science, certainly computer science." – Oren Etzioni<br>"If you want to have an impact, don’t follow the bandwagon. Keep alive other areas." – Peter Stone<br>"Scientists in the natural sciences are actually very excited about ML as much of their research relies on expensive computations, which can be approximated with neural networks." – Michael Littman</em></blockquote><p>There were some important observations and ultimately a general consensus that ML alone is not enough and we need to integrate other methods with ML. Yonatan Belinkov also <a href="https://twitter.com/boknilev/status/1090451665486925825">live tweeted</a>, while I <a href="https://twitter.com/seb_ruder/status/1090454767438946304">tweeted some remarks that elicited laughs</a>.</p><h1 id="adversarial-learning">Adversarial learning</h1><p>During his invited talk (video available <a href="https://vimeo.com/313941176">here</a>), <a href="https://ai.google/research/people/105214">Ian Goodfellow</a> discussed a multiplicity of areas to which adversarial learning has been applied. Among many advances, Ian mentioned that he was impressed by the performance and flexibility of <a href="https://arxiv.org/abs/1805.08318">attention masks for GANs</a>, particularly that they are not restricted to circular masks. </p><p>He discussed adversarial examples, which are a consequence of moving away from i.i.d. data: attackers are able to confuse the model by showing unusual data from a different distribution such as <a href="https://arxiv.org/abs/1707.08945">graffiti on stop signs</a>. He also argued—contrary to the prevalent opinion—that deep models that are more robust are more interpretable than linear models. The main reason is that the latent space of a linear model is totally unintuitive, while a more robust model is more inspectable (as can be seen below).</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://ruder.io/content/images/2019/02/latent_space_vulnerable_model_vs_robust_model.png" class="kg-image" alt="AAAI 2019 Highlights: Dialogue, reproducibility, and more"><figcaption>Traversing the latent space of a linear model (left) vs. a deep, more robust model (right) between different MNIST labels starting from "9"</figcaption></figure><!--kg-card-end: image--><p>Semi-supervised learning with GANs can allow models to be more sample-efficient. What is interesting about such applications is that they focus on the discriminator (which is normally discarded) rather than the generator where the <a href="https://arxiv.org/abs/1606.03498">discriminator is extended</a> to <a href="https://arxiv.org/abs/1606.03498">classify </a><a href="https://arxiv.org/abs/1606.01583"><em>n+1</em> classes</a>. Regarding leveraging GANs for NLP, Ian conceded that we currently have not found a good way to deal with the large action space required to generate sentences with RL.</p><h1 id="imperfect-information-games">Imperfect-information games</h1><p>In his invited talk (video available <a href="https://vimeo.com/313942390">here</a>), <a href="http://www.cs.cmu.edu/~sandholm/">Tuomas Sandholm—</a>whose <a href="https://www.engadget.com/2017/02/10/libratus-ai-poker-winner/">AI Libratus was the first AI to beat top Heads-Up No-Limit Texas Hold'em professionals in January 2017—</a>discussed new results for solving imperfect-information games. He stressed that <strong>only game-theoretically sound techniques yield strategies that are robust against all opponents in imperfect-information games</strong>. Other advantages of a game-theoretic approach are a) that even if humans have access to the entire history of plays of the AI, they still can't find holes in its strategy; and b) it requires no data, just the rules of the game.</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://ruder.io/content/images/2019/02/real-world_applications_imperfect-information_games.png" class="kg-image" alt="AAAI 2019 Highlights: Dialogue, reproducibility, and more"><figcaption>Most real-world applications are imperfect-information games</figcaption></figure><!--kg-card-end: image--><p>For solving such games, the quality of the solution depends on the quality of the abstraction. Developing better abstractions is thus important, which also applies to modelling such games. In imperfect-information games, planning is important. In real-time planning, we must consider how the opponent can adapt to changes in the policy. In contrast to perfect-information games, states do not have well-defined values.</p><h1 id="inductive-biases">Inductive biases</h1><p>There were several papers that incorporated different inductive biases into existing models:</p><ul><li><a href="https://www.aaai.org/Papers/AAAI/2019/AAAI-GuptaPankaj1.4838.pdf"><strong>Document Informed Neural Autoregressive Topic Models with Distributional Prior</strong></a>: An extension of the <a href="https://papers.nips.cc/paper/4613-a-neural-autoregressive-topic-model.pdf">DocNADE</a> topic model using word embedding vectors as prior. The model is evaluated on 15 datasets.</li><li><a href="https://www.aaai.org/Papers/AAAI/2019/AAAI-XiaQ.7468.pdf"><strong>Syntax-aware Neural Semantic Role Labeling</strong></a>: The authors incorporate various syntax features into a semantic role labelling model. In contrast to common practice, which often tries to incorporate syntax via a TreeLSTM, they find that shortest dependency path and tree position features perform best. </li><li><a href="https://www.aaai.org/Papers/AAAI/2019/AAAI-LuY.5171.pdf"><strong>Relation Structure-Aware Heterogeneous Information Network Embedding</strong></a>: A network embedding model that treats different relations differently: For affiliation relations (<em>"papers are published in conferences")</em> Euclidean distance is used, while for interaction relations (<em>"authors write papers")</em> a translation-based distance is used.</li><li><a href="https://www.aaai.org/Papers/AAAI/2019/AAAI-GuoM.1484.pdf"><strong>Gaussian Transformer: a Lightweight Approach for Natural Language Inference</strong></a>: A Transformer with a Gaussian prior for the self-attention that encourages focusing on neighbouring tokens.</li><li><a href="https://www.aaai.org/Papers/AAAI/2019/AAAI-LeeJ.6432.pdf"><strong>Gradient-based Inference for Networks with Output Constraints</strong></a>: A method to incorporate output constraints, e.g. matching number of brackets for syntactic parsing, agreement with parse spans for SRL, etc. into the model via gradient-based inference at test-time. The method is extensively evaluated and also performs well on out-of-domain data.</li><li><strong><a href="https://arxiv.org/abs/1811.00146">ATOMIC: An Atlas of Machine Commonsense for If-Then Reasoning</a>: </strong>A collection of 300k textual descriptions focusing on if-then relations with variables. Multi-task models that exploit the hierarchical structure of the data perform better.</li></ul><h1 id="transfer-learning">Transfer learning</h1><p>Papers on transfer learning ranged from multi-task learning and semi-supervised learning to sequential and zero-shot transfer:</p><ul><li><a href="https://www.aaai.org/Papers/AAAI/2019/AAAI-ChenLingzhen.6418.pdf"><strong>Transfer Learning for Sequence Labeling using Source Model and Target Data</strong></a>: Extension of fine-tuning techniques for NER for the case where the target task includes labels from the source domain (as well as new labels). 1) Output layer is extended with embeddings for new labels. 2) A BiLSTM takes the features of the source model as input and feeds its output to the target model. </li><li><a href="https://www.aaai.org/Papers/AAAI/2019/AAAI-SanhV.7138.pdf"><strong>A Hierarchical Multi-task Approach for Learning Embeddings from Semantic Tasks</strong></a>: A hierarchical model that jointly learns coreference resolution, relation extraction, entity mention detection, and NER. It achieves state of the art on 3/4 tasks. (<em>Disclaimer: I'm a co-author of this paper.</em>)</li><li><a href="https://www.aaai.org/Papers/AAAI/2019/AAAI-SachanD.7236.pdf"><strong>Revisiting LSTM Networks for Semi-Supervised Text Classification via Mixed Objective Function</strong></a>: A combination of entropy minimization, adversarial and virtual adversarial training with a simple 1-layer BiLSTM achieves state-of-the-art results on multiple text classification datasets. </li><li><a href="https://www.aaai.org/Papers/AAAI/2019/AAAI-RijhwaniS.6382.pdf"><strong>Zero-shot Neural Transfer for Cross-lingual Entity Linking</strong></a>: A cross-lingual entity linking model that trains a character-based entity similarity encoder on a bilingual lexicon of entities. Conceptually similar to <a href="https://arxiv.org/abs/1706.04902">cross-lingual word embedding models</a>. For languages that do not share the same script, words are transcribed to phonemes.</li><li><strong><a href="https://arxiv.org/abs/1808.10059">Zero-Shot Adaptive Transfer for Conversational Language Understanding</a>: </strong>A model that performs zero-shot slot tagging by embedding the slot description and fine-tuning a pretrained model on the target domain.</li><li><a href="https://www.aaai.org/Papers/AAAI/2019/AAAI-SiddhantA.2024.pdf"><strong>Unsupervised Transfer learning for Spoken Language Understanding in Intelligent Agents</strong></a>: A more light-weight ELMo model that pretrains a shared BiLSTM layer for intent classification and entity tagging and fine-tunes it with ULMFiT techniques.</li><li><a href="https://www.aaai.org/Papers/AAAI/2019/AAAI-RuderS.6318.pdf"><strong>Latent Multi-task Architecture Learning</strong></a>: A multi-task learning architecture that enables more flexible parameter sharing between tasks and generalizes existing transfer and multi-task learning architectures. (<em>Disclaimer: I'm a co-author of this paper.</em>)</li><li><strong><a href="https://arxiv.org/abs/1811.11456">GIRNet: Interleaved Multi-Task Recurrent State Sequence Models</a></strong>: A multi-task learning model that leverages the output from auxiliary models based on position-dependent gates. The model is applied to sentiment analysis and POS tagging of code-switched data and target-dependent sentiment analysis.</li><li><a href="https://www.aaai.org/Papers/AAAI/2019/AAAI-ZhangLipeng.3275.pdf"><strong>A Generalized Language Model in Tensor Space</strong></a>: A higher-order language model that builds a representation based on the tensor product of word vectors. The model achieves strong results on PTB and WikiText.</li></ul><h1 id="word-embeddings">Word embeddings</h1><p>Naturally there were also a number of papers that provided new methods for learning word embeddings:</p><ul><li><a href="https://www.aaai.org/Papers/AAAI/2019/AAAI-LiuTianlin.5754.pdf"><strong>Unsupervised Post-processing of Word Vectors via Conceptor Negation</strong></a>: A post-processing method that uses conceptors (a linear transformation) to dampen directions where a word vector has high variances. Post-processed embeddings not only improve on word similarity, but also on dialogue state tracking.</li><li><a href="https://www.aaai.org/Papers/AAAI/2019/AAAI-AbdallaM.6635.pdf"><strong>Enriching Word Embeddings with a Regressor Instead of Labeled Corpora</strong></a>: A method that enriches word embeddings during training with sentiment information based on a regressor trained on valence information from a sentiment lexicon. The enriched embeddings improve performance on sentiment and non-sentiment tasks.</li><li><strong><a href="https://arxiv.org/abs/1811.03866">Learning Semantic Representations for Novel Words: Leveraging Both Form and Context</a>: </strong>A model that learns representations for novel words both from the surface form and the context—in contrast to previous models that only leverage one of the sources.</li></ul><h1 id="miscellaneous">Miscellaneous</h1><p>Finally, here are some papers that I enjoyed that do not fit into any of the above categories:</p><ul><li><a href="https://www.aaai.org/Papers/AAAI/2019/AAAI-DalviF.5894.pdf"><strong>What Is One Grain of Sand in the Desert? Analyzing Individual Neurons in Deep NLP Models</strong></a>: A supervised method to extract relevant neurons with regard to a task (by correlating neurons with the target property) and an unsupervised method to extract salient neurons with regard to the model (by correlating neurons across models). Techniques are evaluated on NMT and language modelling.</li><li><strong><a href="https://arxiv.org/abs/1811.12181">What Should I Learn First: Introducing LectureBank for NLP Education and Prerequisite Chain Learning</a></strong>: A dataset containing 1,352 NLP lecture files classified according to a taxonomy with 208 prerequisite relation topics. A model is trained to learn prerequisite relations to answer "what should one learn first".</li></ul><p><em>Cover image: AAAI-19 Opening Reception</em></p>]]></content:encoded></item><item><title><![CDATA[The 4 Biggest Open Problems in NLP]]></title><description><![CDATA[This is the second post based on the Frontiers of NLP session at the Deep Learning Indaba 2018. It discusses 4 major open problems in NLP.]]></description><link>http://ruder.io/4-biggest-open-problems-in-nlp/</link><guid isPermaLink="false">5c76ff7c1b9b0d18555b9eb0</guid><category><![CDATA[natural language processing]]></category><category><![CDATA[cross-lingual]]></category><category><![CDATA[events]]></category><dc:creator><![CDATA[Sebastian Ruder]]></dc:creator><pubDate>Tue, 15 Jan 2019 15:28:00 GMT</pubDate><media:content url="http://ruder.io/content/images/2019/01/narrativeqa_ghostbuster.png" medium="image"/><content:encoded><![CDATA[<img src="http://ruder.io/content/images/2019/01/narrativeqa_ghostbuster.png" alt="The 4 Biggest Open Problems in NLP"><p>This post discusses 4 major open problems in NLP based on an expert survey and a panel discussion at the Deep Learning Indaba.</p><p>This is the second blog post in a two-part series. The series expands on the Frontiers of Natural Language Processing session organized by <a href="https://www.kamperh.com/">Herman Kamper</a>, <a href="http://www.stephangouws.com/">Stephan Gouws</a>, and me at the <a href="http://www.deeplearningindaba.com/">Deep Learning Indaba 2018</a>. Slides of the entire session can be found <a href="https://drive.google.com/file/d/15ehMIJ7wY9A7RSmyJPNmrBMuC7se0PMP/view">here</a>. The <a href="http://ruder.io/a-review-of-the-recent-history-of-nlp/">first post</a> discussed major recent advances in NLP focusing on neural network-based methods. This post discusses major open problems in NLP. You can find a recording of the panel discussion this post is based on <a href="https://youtu.be/sGVi4gb90zk?list=PLICxY_yQeGYlcjO6ANCXworXHGC6hHXjA&amp;t=3649">here</a>.</p><p>In the weeks leading up to the Indaba, we asked NLP experts a number of simple but big questions. Based on the responses, we identified the four problems that were mentioned most often:</p><ol><li><a>Natural language understanding</a></li><li><a>NLP for low-resource scenarios</a></li><li><a>Reasoning about large or multiple documents</a></li><li><a>Datasets, problems, and evaluation</a></li></ol><p>We discussed these problems during a panel discussion. This article is mostly based on the <a href="https://docs.google.com/document/d/18NoNdArdzDLJFQGBMVMsQ-iLOowP1XXDaSVRmYN0IyM/edit">responses from our experts</a> (which are well worth reading) and thoughts of my fellow panel members <a href="https://twitter.com/alienelf?lang=en">Jade Abbott</a>, <a href="http://www.stephangouws.com/">Stephan Gouws</a>, <a href="http://omojumiller.com/">Omoju Miller</a>, and <a href="https://twitter.com/bernardt_d">Bernardt Duvenhage</a>. I will aim to provide context around some of the arguments, for anyone interested in learning more.</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="http://ruder.io/content/images/2018/12/fellow_panel_members.png" class="kg-image" alt="The 4 Biggest Open Problems in NLP"></figure><!--kg-card-end: image--><h1 id="natural-language-understanding">Natural language understanding</h1><blockquote>I think the biggest open problems are all related to natural language<br>understanding. [...] <strong>we should develop systems that read and<br>understand text the way a person does</strong>, by forming a representation of<br>the world of the text, with the agents, objects, settings, and the<br>relationships, goals, desires, and beliefs of the agents, and everything else<br>that humans create to understand a piece of text. Until we can do that, all of our progress is in improving our systems’ ability to do pattern matching.<br>– Kevin Gimpel</blockquote><p>Many experts in our survey argued that the problem of natural language understanding (NLU) is central as it is a prerequisite for many tasks such as natural language generation (NLG). The consensus was that none of our current models exhibit 'real' understanding of natural language.</p><p><strong>Innate biases vs. learning from scratch</strong>   A key question is what biases and structure should we build explicitly into our models to get closer to NLU. Similar ideas were discussed at the Generalization workshop at NAACL 2018, which Ana Marasovic <a href="https://thegradient.pub/frontiers-of-generalization-in-natural-language-processing/">reviewed for The Gradient</a> and I <a href="http://ruder.io/highlights-naacl-2018/#generalization">reviewed here</a>. Many responses in our survey mentioned that models should incorporate common sense. In addition, dialogue systems (and chat bots) were mentioned several times.</p><p>On the other hand, for reinforcement learning, David Silver argued that you would ultimately want the model to <a href="https://twitter.com/seb_ruder/status/1040241906066829313">learn everything by itself, including the algorithm, features, and predictions</a>. Many of our experts took the opposite view, arguing that you should actually build in some understanding in your model. What should be learned and what should be hard-wired into the model was also explored in the <a href="https://www.abigailsee.com/2018/02/21/deep-learning-structure-and-innate-priors.html">debate between Yann LeCun and Christopher Manning</a> in February 2018.</p><p><strong>Program synthesis</strong>   Omoju argued that incorporating understanding is difficult as long as we do not understand the mechanisms that actually underly NLU and how to evaluate them. She argued that we might want to take ideas from <a href="https://en.wikipedia.org/wiki/Program_synthesis">program synthesis</a> and automatically learn programs based on high-level specifications instead. Ideas like this are related to <a href="https://arxiv.org/abs/1511.02799">neural module networks</a> and <a href="https://arxiv.org/abs/1511.06279">neural programmer-interpreters</a>.<br><br>She also suggested we should look back to approaches and frameworks that were originally developed in the 80s and 90s, such as <a href="https://framenet.icsi.berkeley.edu/">FrameNet</a> and merge these with statistical approaches. This should help us infer common sense-properties of objects, such as whether a car is a vehicle, has handles, etc. Inferring such common sense knowledge has also been a focus of <a href="http://ruder.io/10-exciting-ideas-of-2018-in-nlp/#3-common-sense-inference-datasets">recent datasets in NLP</a>. </p><p><strong>Embodied learning</strong>   Stephan argued that we should use the information in available structured sources and knowledge bases such as <a href="https://en.wikipedia.org/wiki/Wikidata">Wikidata</a>. He noted that humans learn language through experience and interaction, by being embodied in an environment. One could argue that there exists a single learning algorithm that if used with an agent embedded in a sufficiently rich environment, with an appropriate reward structure, could learn NLU from the ground up. However, the compute for such an environment would be tremendous. For comparison, AlphaGo required a huge infrastructure to solve a well-defined board game. The creation of a general-purpose algorithm that can continue to learn is related to <a href="http://axon.cs.byu.edu/~martinez/classes/678/Presentations/Martin.pdf">lifelong learning</a> and to<a href="https://arxiv.org/abs/1802.08864"> general problem solvers</a>.</p><p>While many people think that we are headed in the direction of embodied learning, we should thus not underestimate the infrastructure and compute that would be required for a full embodied agent. In light of this, waiting for a full-fledged embodied agent to learn language seems ill-advised. However, we can take steps that will bring us closer to this extreme, such as <a href="https://arxiv.org/abs/1706.06551">grounded language learning in simulated environments</a>, <a href="https://openreview.net/forum?id=rJeXCo0cYX">incorporating interaction</a>, or <a href="http://aclweb.org/anthology/D18-1166">leveraging multimodal data</a>.</p><p><strong>Emotion</strong>   Towards the end of the session, Omoju argued that it will be very difficult to incorporate a human element relating to emotion into embodied agents. Emotion, however, is very relevant to a deeper understanding of language. On the other hand, we might not need agents that actually possess human emotions. Stephan stated that the Turing test, after all, is defined as mimicry and sociopaths—while having no emotions—can fool people into thinking they do. We should thus be able to find solutions that do not need to be embodied and do not have emotions, but understand the emotions of people and help us solve our problems. Indeed, sensor-based emotion recognition systems <a href="http://eqradio.csail.mit.edu/">have continuously improved—</a>and we have also seen improvements in <a href="https://www.aclweb.org/anthology/D17-1169">textual emotion detection systems</a>.</p><p><strong>Cognitive and neuroscience</strong>   An audience member asked how much knowledge of neuroscience and cognitive science are we leveraging and building into our models. Knowledge of neuroscience and cognitive science can be great for inspiration and used as a guideline to shape your thinking. As an example, <a href="https://papers.nips.cc/paper/6057-using-fast-weights-to-attend-to-the-recent-past.pdf">several</a> <a href="https://papers.nips.cc/paper/7120-thinking-fast-and-slow-with-deep-learning-and-tree-search.pdf">models</a> have sought to imitate humans' ability to <em>think fast and slow</em>. AI and neuroscience are complementary in many directions, as Surya Ganguli illustrates in <a href="https://hai.stanford.edu/news/the_intertwined_quest_for_understanding_biological_intelligence_and_creating_artificial_intelligence/">this post</a>.</p><p>Omoju recommended to take inspiration from theories of cognitive science, such as the cognitive development theories by <a href="https://www2.education.uiowa.edu/html/eportfolio/tep/07p075folder/Piaget_Vygotsky.htm">Piaget and Vygotsky</a>. She also urged everyone to pursue interdisciplinary work. This sentiment was echoed by other experts. For instance, Felix Hill recommended to go to cognitive science conferences.</p><h1 id="nlp-for-low-resource-scenarios">NLP for low-resource scenarios</h1><blockquote>Dealing with low-data settings (low-resource languages, dialects (including social media text "dialects"), domains, etc.).  This is not a completely "open" problem in that there are already a lot of promising ideas out there; <strong>but we still don't have a universal solution to this universal problem</strong>.<br>– Karen Livescu</blockquote><p>The second topic we explored was generalisation beyond the training data in low-resource scenarios. Given the setting of the Indaba, a natural focus was low-resource languages. The first question focused on whether it is necessary to develop specialised NLP tools for specific languages, or it is enough to work on general NLP.</p><p><strong>Universal language model</strong>   Bernardt argued that there are universal commonalities between languages that could be exploited by a universal language model. The challenge then is to obtain enough data and compute to train such a language model. This is closely related to recent efforts to train a <a href="https://github.com/google-research/bert/blob/master/multilingual.md">cross-lingual Transformer language model</a> and <a href="https://arxiv.org/abs/1812.10464">cross-lingual sentence embeddings</a>. </p><p><strong>Cross-lingual representations</strong>   Stephan remarked that not enough people are working on low-resource languages. There are <a href="https://en.wikipedia.org/wiki/Languages_of_Africa">1,250-2,100 languages in Africa</a> alone, most of which have received scarce attention from the NLP community. The question of specialized tools also depends on the NLP task that is being tackled. The main issue with current models is sample efficiency. <a href="https://arxiv.org/abs/1706.04902">Cross-lingual word embeddings</a> are sample-efficient as they only require word translation pairs or even only monolingual data. They align word embedding spaces sufficiently well to do coarse-grained tasks like topic classification, but don't allow for more fine-grained tasks such as machine translation. Recent efforts nevertheless show that these embeddings form an important building lock for <a href="http://ruder.io/10-exciting-ideas-of-2018-in-nlp/#1-unsupervised-mt">unsupervised machine translation</a>. </p><p>More complex models for higher-level tasks such as question answering on the other hand require thousands of training examples for learning. Transferring tasks that require actual natural language understanding from high-resource to low-resource languages is still very challenging. With the development of cross-lingual datasets for such tasks, such as <a href="https://arxiv.org/abs/1809.05053">XNLI</a>, the development of strong cross-lingual models for more reasoning tasks should hopefully become easier. </p><p><strong>Benefits and impact</strong>   Another question enquired—given that there is inherently only small amounts of text available for under-resourced languages—whether the benefits of NLP in such settings will also be limited. Stephan vehemently disagreed, reminding us that as ML and NLP practitioners, we typically tend to view problems in an information theoretic way, e.g. as maximizing the likelihood of our data or improving a benchmark. <strong>Taking a step back, the actual reason we work on NLP problems is to build systems that break down barriers. We want to build models that enable people to read news that was not written in their language, ask questions about their health when they don't have access to a doctor, etc.</strong></p><p>Given the potential impact, building systems for low-resource languages is in fact one of the most important areas to work on. While one low-resource language may not have a lot of data, there is a long tail of low-resource languages; most people on this planet in fact speak a language that is in the low-resource regime. We thus really need to find a way to get our systems to work in this setting.<br><br>Jade opined that it is almost ironic that as a community we have been focusing on languages with a lot of data as these are the languages that are well taught around the world. <strong>The languages we should really focus on are the low-resource languages where not much data is available.</strong> The great thing about the Indaba is that people are working and making progress on such low-resource languages. Given the scarcity of data, even simple systems such as bag-of-words will have a large real-world impact. Etienne Barnard, one of the audience members, noted that he observed a different effect in real-world speech processing: Users were often more motivated to use a system in English if it works for their dialect compared to using a system in their own language.</p><p><strong>Incentives and skills</strong>   Another audience member remarked that people are incentivized to work on highly visible benchmarks, such as English-to-German machine translation, but incentives are missing for working on low-resource languages. Stephan suggested that incentives exist in the form of unsolved problems. However, skills are not available in the right demographics to address these problems. What we should focus on is to teach skills like machine translation in order to empower people to solve these problems. Academic progress unfortunately doesn't necessarily relate to low-resource languages. However, if cross-lingual benchmarks become more pervasive, then this should also lead to more progress on low-resource languages.</p><p><strong>Data availability</strong>   Jade finally argued that a big issue is that there are no datasets available for low-resource languages, such as languages spoken in Africa. If we create datasets and make them easily available, such as hosting them on <a href="https://africaopendata.org/">openAFRICA</a>, that would incentivize people and lower the barrier to entry. It is often sufficient to make available test data in multiple languages, as this will allow us to evaluate cross-lingual models and track progress. Another data source is the <a href="https://www.sadilar.org/">South African Centre for Digital Language Resources (SADiLaR)</a>, which provides resources for many of the languages spoken in South Africa.</p><h1 id="reasoning-about-large-or-multiple-documents">Reasoning about large or multiple documents</h1><blockquote>Representing large contexts efficiently. <strong>Our current models are mostly based on recurrent neural networks, which cannot represent longer contexts well. </strong>[...] The stream of work on graph-inspired RNNs is potentially promising, though has only seen modest improvements and has not been widely adopted due to them being much less straight-forward to train than a vanilla RNN.<br>– Isabelle Augenstein</blockquote><p>Another big open problem is reasoning about large or multiple documents. The recent <a href="http://ruder.io/10-exciting-ideas-of-2018-in-nlp/#9-qa-and-reasoning-with-large-documents">NarrativeQA dataset</a> is a good example of a benchmark for this setting. Reasoning with large contexts is closely related to NLU and requires scaling up our current systems dramatically, until they can read entire books and movie scripts. A key question here—that we did not have time to discuss during the session—is whether we need better models or just train on more data.</p><p>Endeavours such as <a href="https://openai.com/five/">OpenAI Five</a> show that current models can do a lot if they are scaled up to work with a lot more data and a lot more compute. With sufficient amounts of data, our current models might similarly do better with larger contexts. The problem is that supervision with large documents is scarce and expensive to obtain. Similar to language modelling and <a href="https://papers.nips.cc/paper/5950-skip-thought-vectors.pdf">skip-thoughts</a>, we could imagine a document-level unsupervised task that requires predicting the next paragraph or chapter of a book or deciding which chapter comes next. However, this objective is likely too sample-inefficient to enable learning of useful representations.</p><p>A more useful direction thus seems to be to develop methods that can represent context more effectively and are better able to keep track of relevant information while reading a document. Multi-document summarization and <a href="https://arxiv.org/abs/1901.00603">multi-document question answering</a> are steps in this direction. Similarly, we can build on language models with improved <a href="https://arxiv.org/abs/1612.03969">memory</a> and <a href="https://arxiv.org/abs/1703.03129">lifelong learning</a> capabilities.</p><h1 id="datasets-problems-and-evaluation">Datasets, problems, and evaluation</h1><blockquote>Perhaps the biggest problem is to <strong>properly define the problems themselves.</strong> And by properly defining a problem, I mean building <strong>datasets and evaluation</strong> procedures that are appropriate to measure our progress towards concrete goals. Things would be easier if we could reduce everything to Kaggle style competitions!<br>– Mikel Artetxe </blockquote><p>We did not have much time to discuss problems with our current benchmarks and evaluation settings but you will find many relevant responses in <a href="https://docs.google.com/document/d/18NoNdArdzDLJFQGBMVMsQ-iLOowP1XXDaSVRmYN0IyM/edit">our survey</a>. The final question asked what the most important NLP problems are that should be tackled for societies in Africa. Jade replied that the most important issue is to solve the low-resource problem. Particularly being able to use translation in education to enable people to access whatever they want to know in their own language is tremendously important.</p><p>The session concluded with general advice from our experts on other questions that we had asked them, such as "<em>What, if anything, has led the field in the wrong direction?</em>" and "<em>What advice would you give a postgraduate student in NLP starting their project now?</em>" You can find responses to all questions in <a href="https://docs.google.com/document/d/18NoNdArdzDLJFQGBMVMsQ-iLOowP1XXDaSVRmYN0IyM/edit#">the survey</a>.</p><h2 id="deep-learning-indaba-2019">Deep Learning Indaba 2019</h2><p>If you are interested in working on low-resource languages, consider attending the <a href="http://www.deeplearningindaba.com/indaba-2019.html">Deep Learning Indaba 2019</a>, which takes place in Nairobi, Kenya from 25-31 August 2019.</p><p><em>Credit: Title image text is from the <a href="https://arxiv.org/abs/1712.07040">NarrativeQA dataset</a>. The image is from the <a href="https://drive.google.com/file/d/15ehMIJ7wY9A7RSmyJPNmrBMuC7se0PMP/view">slides of the NLP session</a>.</em></p>]]></content:encoded></item><item><title><![CDATA[10 Exciting Ideas of 2018 in NLP]]></title><description><![CDATA[This post gathers 10 ideas that I found exciting and impactful this year—and that we'll likely see more of in the future. For each idea, it highlights 1-2 papers that execute them well.]]></description><link>http://ruder.io/10-exciting-ideas-of-2018-in-nlp/</link><guid isPermaLink="false">5c76ff7c1b9b0d18555b9eb7</guid><category><![CDATA[transfer learning]]></category><category><![CDATA[multi-task learning]]></category><category><![CDATA[meta-learning]]></category><category><![CDATA[natural language processing]]></category><category><![CDATA[semi-supervised learning]]></category><category><![CDATA[language models]]></category><category><![CDATA[cross-lingual]]></category><dc:creator><![CDATA[Sebastian Ruder]]></dc:creator><pubDate>Wed, 19 Dec 2018 19:28:46 GMT</pubDate><media:content url="http://ruder.io/content/images/2018/12/syntactic_scaffold-1.png" medium="image"/><content:encoded><![CDATA[<img src="http://ruder.io/content/images/2018/12/syntactic_scaffold-1.png" alt="10 Exciting Ideas of 2018 in NLP"><p>This post gathers 10 ideas that I found exciting and impactful this year—and that we'll likely see more of in the future.</p><p>For each idea, I will highlight 1-2 papers that execute them well. I tried to keep the list succinct, so apologies if I did not cover all relevant work. The list is necessarily subjective and covers ideas mainly related to transfer learning and generalization. Most of these (with some exceptions) are not trends (but I suspect that some might become more 'trendy' in 2019). Finally, I would love to read about your highlights in the comments or see highlights posts about other areas.</p><h2 id="1-unsupervised-mt">1) Unsupervised MT</h2><p>There were <a href="https://arxiv.org/abs/1711.00043">two</a> <a href="https://arxiv.org/abs/1710.11041">unsupervised</a> MT papers at ICLR 2018. They were <em>surprising</em> in that they worked at all, but results were still low compared to supervised systems. At EMNLP 2018, unsupervised MT hit its stride with <a href="https://arxiv.org/abs/1804.07755">two</a> <a href="https://arxiv.org/abs/1809.01272">papers</a> from the same two groups that significantly improve upon their previous methods. My highlight:</p><ul><li><a href="https://arxiv.org/abs/1804.07755"><strong>Phrase-Based &amp; Neural Unsupervised Machine Translation</strong> (EMNLP 2018)</a>:  The paper does a nice job in distilling the three key requirements for unsupervised MT: a good initialization, language modelling, and modelling the inverse task (via back-translation). All three are also beneficial in other unsupervised scenarios, as we will see below. Modelling the inverse task enforces cyclical consistency, which has been employed in different approaches—most prominently in <a href="https://arxiv.org/abs/1703.10593">CycleGAN</a>. The paper performs extensive experiments and evaluates even on two low-resource language pairs, English-Urdu and English-Romanian. We will hopefully see more work on low-resource languages in the future.</li></ul><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://ruder.io/content/images/2018/12/phrase_based_and_neural_unsupervised_mt.png" class="kg-image" alt="10 Exciting Ideas of 2018 in NLP"><figcaption>Toy illustration of the three principles of unsupervised MT. A) Two monolingual datasets. B) Initialization. C) Language modelling. D) Back-translation <a href="https://arxiv.org/abs/1804.07755">(Lample et al., 2018)</a>.</figcaption></figure><!--kg-card-end: image--><h2 id="2-pretrained-language-models">2) Pretrained language models</h2><p>Using pretrained language models is probably the <a href="http://ruder.io/nlp-imagenet/">most significant NLP trend</a> this year, so I won't spend much time on it here. There have been a slew of memorable approaches: <a href="https://arxiv.org/abs/1802.05365">ELMo</a>, <a href="https://arxiv.org/abs/1801.06146">ULMFiT</a>, <a href="https://s3-us-west-2.amazonaws.com/openai-assets/research-covers/language-unsupervised/language_understanding_paper.pdf">OpenAI Transformer</a>, and <a href="https://arxiv.org/abs/1810.04805">BERT</a>. My highlight:</p><ul><li><a href="https://arxiv.org/abs/1802.05365"><strong>Deep contextualized word representations</strong> (NAACL-HLT 2018)</a>: The paper that introduced ELMo has been much lauded. Besides the impressive empirical results, where it shines is the careful analysis section that teases out the impact of various factors and analyses the information captured in the representations. The word sense disambiguation (WSD) analysis by itself (below on the left) is well executed. Both demonstrate that a LM on its own provides WSD and POS tagging performance close to the state-of-the-art.</li></ul><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://ruder.io/content/images/2018/12/wsd_and_pos_tagging_results.png" class="kg-image" alt="10 Exciting Ideas of 2018 in NLP"><figcaption>Word sense disambiguation (left) and POS tagging (right) results of first and second layer bidirectional language model compared to baselines <a href="https://arxiv.org/abs/1802.05365">(Peters et al., 2018)</a>.</figcaption></figure><!--kg-card-end: image--><h2 id="3-common-sense-inference-datasets">3) Common sense inference datasets</h2><p>Incorporating common sense into our models is one of the most important directions moving forward. However, creating good datasets is not easy and even popular ones <a href="http://aclweb.org/anthology/N18-2017">show</a> <a href="http://www.aclweb.org/anthology/S18-2023">large</a> biases. This year, there have been some well-executed datasets that seek to teach models some common sense such as <a href="https://arxiv.org/abs/1805.06939">Event2Mind</a> and <a href="https://arxiv.org/abs/1808.05326">SWAG</a>, both from the University of Washington. SWAG was solved <a href="https://twitter.com/seb_ruder/status/1050727451138150400">unexpectedly quickly</a>. My highlight:</p><ul><li><strong><a href="http://visualcommonsense.com/">Visual Commonsense Reasoning</a></strong><a href="http://visualcommonsense.com/"> (arXiv 2018)</a>: This is the first visual QA dataset that includes a rationale (an explantation) with each answer. In addition, questions require complex reasoning. The creators go to great lengths to address possible bias by ensuring that every answer's prior probability of being correct is 25% (every answer appears 4 times in the entire dataset, 3 times as an incorrect answer and 1 time as the correct answer); this requires solving a constrained optimization problem using models that compute relevance and similarity. Hopefully preventing possible bias will become a common component when creating datasets. Finally, just look at the gorgeous presentation of the data 👇.</li></ul><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://ruder.io/content/images/2018/12/visual_commonsense_reasoning.png" class="kg-image" alt="10 Exciting Ideas of 2018 in NLP"><figcaption>VCR: Given an image, a list of regions, and a question, a model must answer the question and provide a rationale explaining why its answer is right <a href="https://arxiv.org/abs/1811.10830">(Zellers et al., 2018)</a>.</figcaption></figure><!--kg-card-end: image--><h2 id="4-meta-learning">4) Meta-learning</h2><p>Meta-learning has seen much use in few-shot learning, reinforcement learning, and robotics—the most prominent example: <a href="https://arxiv.org/abs/1703.03400">model-agnostic meta-learning (MAML)</a>—but successful applications in NLP have been rare. Meta-learning is most useful for problems with a limited number of training examples. My highlight:</p><ul><li><a href="http://aclweb.org/anthology/D18-1398"><strong>Meta-Learning for Low-Resource Neural Machine Translation</strong> (EMNLP 2018)</a>: The authors use MAML to learn a good initialization for translation, treating each language pair as a separate meta-task. Adapting to low-resource languages is probably the most useful setting for meta-learning in NLP. In particular, combining multilingual transfer learning (such as <a href="https://github.com/google-research/bert/blob/master/multilingual.md">multilingual BERT</a>), unsupervised learning, and meta-learning is a promising direction.</li></ul><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://ruder.io/content/images/2018/12/meta-learning_vs_transfer_learning.png" class="kg-image" alt="10 Exciting Ideas of 2018 in NLP"><figcaption>The difference between transfer learning multilingual transfer learning, and meta-learning. Solid lines: learning of the initialization. Dashed lines: Path of fine-tuning <a href="http://aclweb.org/anthology/D18-1398">(Gu et al., 2018)</a>.</figcaption></figure><!--kg-card-end: image--><h2 id="5-robust-unsupervised-methods">5) Robust unsupervised methods</h2><p>This year, <a href="http://aclweb.org/anthology/P18-1072">we</a> <a href="http://aclweb.org/anthology/D18-1056">and</a> others have observed that unsupervised cross-lingual word embedding methods break down when languages are dissimilar. This is a common phenomenon in transfer learning where a discrepancy between source and target settings (e.g. domains in <a href="https://www.cs.jhu.edu/~mdredze/publications/sentiment_acl07.pdf">domain adaptation</a>, tasks in <a href="https://arxiv.org/abs/1706.08840">continual learning</a> and <a href="http://www.aclweb.org/anthology/E17-1005">multi-task learning</a>) leads to deterioration or failure of the model. Making models more robust to such changes is thus important. My highlight:</p><ul><li><a href="http://www.aclweb.org/anthology/P18-1073"><strong>A robust self-learning method for fully unsupervised cross-lingual mappings of word embeddings</strong> (ACL 2018)</a>: Instead of meta-learning an initialization, this paper uses their understanding of the problem to craft a better initialization. In particular, they pair words in both languages that have a similar distribution of words they are similar to. This is a great example of using domain expertise and insights from an analysis to make a model more robust.</li></ul><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://ruder.io/content/images/2018/12/similarity_distribution.png" class="kg-image" alt="10 Exciting Ideas of 2018 in NLP"><figcaption>The similarity distributions of three words. Equivalent translations ('two' and 'due') have more similar distributions than non-related words ('two' and 'cane'—meaning 'dog'; <a href="http://www.aclweb.org/anthology/P18-1073">Artexte et al., 2018</a>).</figcaption></figure><!--kg-card-end: image--><h2 id="6-understanding-representations">6) Understanding representations</h2><p>There have been a lot of efforts in better understanding representations. In particular, <a href="https://arxiv.org/abs/1608.04207">'diagnostic classifiers'</a> (tasks that aim to measure if learned representations can predict certain attributes) have become <a href="http://arxiv.org/abs/1805.01070">quite common</a>. My highlight:</p><ul><li><a href="http://aclweb.org/anthology/D18-1179"><strong>Dissecting Contextual Word Embeddings: Architecture and Representation</strong> (EMNLP 2018)</a>: This paper does a great job of better understanding pretrained language model representations. They extensively study learned word and span representations on carefully designed unsupervised and supervised tasks. The resulting finding: Pretrained representations learn tasks related to low-level morphological and syntactic tasks at lower layers and longer range semantics at higher layers. To me this really shows that pretrained language models indeed capture similar properties as <a href="https://thegradient.pub/nlp-imagenet/">computer vision models pretrained on ImageNet</a>.</li></ul><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://ruder.io/content/images/2018/12/bilm_transformer_information.png" class="kg-image" alt="10 Exciting Ideas of 2018 in NLP"><figcaption>Per-layer performance of BiLSTM and Transformer pretrained representations on (from left to right) POS tagging, constituency parsing, and unsupervised coreference resolution <a href="http://aclweb.org/anthology/D18-1179">(Peters et al., 2018)</a>.</figcaption></figure><!--kg-card-end: image--><h2 id="7-clever-auxiliary-tasks">7) Clever auxiliary tasks</h2><p>In many settings, we have seen an increasing usage of multi-task learning with carefully chosen auxiliary tasks. For a good auxiliary task, data must be easily accessible. One of the most prominent examples is <a href="https://arxiv.org/abs/1810.04805">BERT</a>, which uses next-sentence prediction (that has been used in <a href="https://papers.nips.cc/paper/5950-skip-thought-vectors.pdf">Skip-thoughts</a> and more recently in <a href="https://arxiv.org/pdf/1803.02893.pdf">Quick-thoughts</a>) to great effect. My highlights: </p><ul><li><a href="http://aclweb.org/anthology/D18-1412"><strong>Syntactic Scaffolds for Semantic Structures</strong> (EMNLP 2018)</a>: This paper proposes an auxiliary task that pretrains span representations by predicting for each span the corresponding syntactic constituent type. Despite being conceptually simple, the auxiliary task leads to large improvements on span-level prediction tasks such as semantic role labelling and coreference resolution. This papers shows that specialised representations learned at the level required by the target task (here: spans) are immensely beneficial.</li><li><strong><a href="https://arxiv.org/abs/1810.08854">pair2vec: Compositional Word-Pair Embeddings for Cross-Sentence Inference</a></strong><a href="https://arxiv.org/abs/1810.08854"> (arXiv 2018)</a>: In a similar vein, this paper pretrains <em>word pair representations</em> by maximizing the pointwise mutual information of pairs of words with their context. This encourages the model to learn more meaningful representations of word pairs than with more general objectives, such as language modelling. The pretrained representations are effective in tasks such as SQuAD and MultiNLI that require cross-sentence inference. We can expect to see more pretraining tasks that capture properties particularly suited to certain downstream tasks and are complementary to more general-purpose tasks like language modelling.</li></ul><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://ruder.io/content/images/2018/12/syntactic_scaffold.png" class="kg-image" alt="10 Exciting Ideas of 2018 in NLP"><figcaption>Syntactic, PropBank and coreference annotations from OntoNotes. PropBank SRL arguments and coreference mentions are annotated on top of syntactic constituents. Almost every argument is related to a syntactic constituent <a href="http://aclweb.org/anthology/D18-1412">(Swayamdipta et al., 2018)</a>.</figcaption></figure><!--kg-card-end: image--><h2 id="8-combining-semi-supervised-learning-with-transfer-learning">8) Combining semi-supervised learning with transfer learning</h2><p>With the recent advances in transfer learning, we should not forget more explicit ways of using target task-specific data. In fact, pretrained representations are complementary with many forms of semi-supervised learning. We have explored <a href="http://aclweb.org/anthology/P18-1096">self-labelling approaches</a>, a particular category of semi-supervised learning. My highlight: </p><ul><li><a href="http://aclweb.org/anthology/D18-1217"><strong>Semi-Supervised Sequence Modeling with Cross-View Training</strong> (EMNLP 2018)</a>: This paper shows that a conceptually very simple idea, making sure that the predictions on different views of the input agree with the prediction of the main model, can lead to gains on a diverse set of tasks. The idea is similar to word dropout but allows leveraging unlabelled data to make the model more robust. Compared to other self-ensembling models such as <a href="https://papers.nips.cc/paper/6719-mean-teachers-are-better-role-models-weight-averaged-consistency-targets-improve-semi-supervised-deep-learning-results.pdf">mean teacher</a>, it is specifically designed for particular NLP tasks. With much work on <em>implicit</em> semi-supervised learning, we will hopefully see more work that explicitly tries to model the target predictions going forward.</li></ul><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://ruder.io/content/images/2018/12/cross-view_training-1.png" class="kg-image" alt="10 Exciting Ideas of 2018 in NLP"><figcaption>Inputs seen by auxiliary prediction modules: Auxiliary 1: <em>They traveled to</em> __________________. Auxiliary 2: <em>They traveled to</em> <strong>Washington</strong> _______. Auxiliary 3: _____________ <strong>Washington</strong> <em>by plane</em>. Auxiliary 4: ________________________ <em>by plane</em> <a href="http://aclweb.org/anthology/D18-1217">(Clark et al., 2018)</a>.</figcaption></figure><!--kg-card-end: image--><h2 id="9-qa-and-reasoning-with-large-documents">9) QA and reasoning with large documents</h2><p>There have been a lot of developments in question answering (QA), with an <a href="https://arxiv.org/abs/1809.09600">array</a> <a href="https://stanfordnlp.github.io/coqa/">of</a> <a href="http://quac.ai/">new</a> <a href="https://arxiv.org/abs/1806.03822">QA</a> <a href="http://qangaroo.cs.ucl.ac.uk/">datasets</a>. Besides conversational QA and performing multi-step reasoning, the most challenging aspect of QA is to synthesize narratives and large bodies of information. My highlight: </p><ul><li><a href="http://aclweb.org/anthology/Q18-1023"><strong>The NarrativeQA Reading Comprehension Challenge</strong> (TACL 2018)</a>: This paper proposes a challenging new QA dataset based on answering questions about entire movie scripts and books. While this task is still out of reach for current methods, models are provided the option of using a summary (rather than the entire book) as context, of selecting the answer (rather than generate it), and of using the output from an IR model. These variants make the task more feasible and enable models to gradually scale up to the full setting. We need more datasets like this that present ambitious problems, but still manage to make them accessible.</li></ul><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://ruder.io/content/images/2018/12/narrative_qa.png" class="kg-image" alt="10 Exciting Ideas of 2018 in NLP"><figcaption>Comparison of QA datasets <a href="http://aclweb.org/anthology/Q18-1023">(Kočiský et al., 2018)</a>.&nbsp;</figcaption></figure><!--kg-card-end: image--><h2 id="10-inductive-bias">10) Inductive bias</h2><p>Inductive biases such as convolutions in a CNN, regularization, dropout, and other mechanisms are core parts of neural network models that act as a regularizer and make models more sample-efficient. However, coming up with a broadly useful inductive bias and incorporating it into a model is challenging. My highlights:</p><ul><li><a href="http://aclweb.org/anthology/K18-1030"><strong>Sequence classification with human attention</strong> (CoNLL 2018)</a>: This paper proposes to use human attention from eye-tracking corpora to regularize attention in RNNs. Given that many current models such as Transformers use attention, finding ways to train it more efficiently is an important direction. It is also great to see another example that human language learning can help improve our computational models. </li><li><a href="http://aclweb.org/anthology/D18-1548"><strong>Linguistically-Informed Self-Attention for Semantic Role Labeling</strong> (EMNLP 2018)</a>: This paper has a lot to like: a Transformer trained jointly on both syntactic and semantic tasks; the ability to inject high-quality parses at test time; and out-of-domain evaluation. It also regularizes the Transformer's multi-head attention to be more sensitive to syntax by training one attention head to attend to the syntactic parents of each token. We will likely see more examples of Transformer attention heads used as auxiliary predictors focusing on particular aspects of the input.</li></ul><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://ruder.io/content/images/2018/12/out-of-domain_srl_performance.png" class="kg-image" alt="10 Exciting Ideas of 2018 in NLP"><figcaption>10 years of PropBank semantic role labeling. Comparison of Linguistically-Informed Self-Attention (LISA) with other methods on out-of-domain data <a href="https://people.cs.umass.edu/~strubell/">(Strubell et al., 2018)</a>.</figcaption></figure><!--kg-card-end: image-->]]></content:encoded></item><item><title><![CDATA[EMNLP 2018 Highlights: Inductive bias, cross-lingual learning, and more]]></title><description><![CDATA[This post discusses highlights of EMNLP 2018. It focuses on talks and papers dealing with inductive bias, cross-lingual learning, word embeddings, latent variable models, language models, and datasets.]]></description><link>http://ruder.io/emnlp-2018-highlights/</link><guid isPermaLink="false">5c76ff7c1b9b0d18555b9eb4</guid><category><![CDATA[events]]></category><category><![CDATA[transfer learning]]></category><category><![CDATA[cross-lingual]]></category><category><![CDATA[word embeddings]]></category><category><![CDATA[language models]]></category><category><![CDATA[natural language processing]]></category><dc:creator><![CDATA[Sebastian Ruder]]></dc:creator><pubDate>Tue, 06 Nov 2018 10:12:40 GMT</pubDate><media:content url="http://ruder.io/content/images/2018/11/emnlp_conference_garden_view.jpg" medium="image"/><content:encoded><![CDATA[<img src="http://ruder.io/content/images/2018/11/emnlp_conference_garden_view.jpg" alt="EMNLP 2018 Highlights: Inductive bias, cross-lingual learning, and more"><p>The post discusses highlights of the 2018 Conference on Empirical Methods in Natural Language Processing (<a href="http://emnlp2018.org/">EMNLP 2018</a>).</p><p><em><em>This post originally appeared at the <a href="http://blog.aylien.com/emnlp-2018-highlights-inductive-bias-cross-lingual-learning-and-more/">AYLIEN blog</a>.</em></em></p><p>You can find past highlights of conferences <a href="http://ruder.io/tag/events/">here</a>. You can find all 549 accepted papers in <a href="https://aclanthology.coli.uni-saarland.de/volumes/proceedings-of-the-2018-conference-on-empirical-methods-in-natural-language-processing">the EMNLP proceedings</a>. In this review, I will focus on papers that relate to the following topics: </p><ul><li><a href="#inductive-bias">Inductive bias</a></li><li><a href="#cross-lingual-learning">Cross-lingual learning</a></li><li><a href="#word-embeddings">Word embeddings</a></li><li><a href="#latent-variable-models">Latent variable models</a></li><li><a href="#language-models">Language models</a></li><li><a href="#datasets">Datasets</a></li><li><a href="#miscellaneous">Miscellaneous</a></li></ul><h2 id="inductive-bias">Inductive bias</h2><p>The <em><a href="https://en.wikipedia.org/wiki/Inductive_bias">inductive bias</a></em> of a machine learning algorithm is the set of assumptions that the model makes in order to generalize to new inputs. For instance, the inductive bias obtained through <a href="http://ruder.io/multi-task/">multi-task learning</a> encourages the model to prefer hypotheses (sets of parameters) that explain more than one task.</p><ul><li>Inductive bias was the main theme during <a href="http://www.conll.org/keynotes-2018">Max Welling</a>'s keynote at <a href="http://www.conll.org/keynotes-2018">CoNLL 2018</a>. The two key takeaways from his talk are:</li></ul><blockquote>Lesson 1: If there is symmetry in the input space, exploit it.</blockquote><p>The most canonical example for exploiting such symmetry are convolutional neural networks, which are <em>translation invariant</em>. Invariance in general means that an object is recognized as an object even if its appearance <em>varies</em> in some way. <a href="https://arxiv.org/abs/1602.07576">Group equivariant convolutional networks</a> and <a href="https://arxiv.org/abs/1612.08498">Steerable CNNs</a> similarly are <em>rotation invariant</em> (see below). Given the success of CNNs in computer vision, it is a compelling research direction to think of <em>what types of invariance are possible in language and how these can be implemented in neural networks.</em></p><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://ruder.io/content/images/2018/11/invariances.png" class="kg-image" alt="EMNLP 2018 Highlights: Inductive bias, cross-lingual learning, and more"><figcaption>Translation and rotation invariance in computer vision (Source: <a href="https://stats.stackexchange.com/questions/208936/what-is-translation-invariance-in-computer-vision-and-convolutional-neural-netwo/208949#208949">Matt Krause</a>)</figcaption></figure><!--kg-card-end: image--><blockquote>Lesson 2: When you know the generative process, you should exploit it.</blockquote><p>For many problems the generative process is known but the inverse process of reconstructing the original input is not. Examples of such <em>inverse problems</em> are MRI, image denoising and super-resolution, but also audio-to-speech decoding and machine translation. The <a href="https://arxiv.org/abs/1706.04008">Recurrent Inference Machine (RIM)</a> uses an RNN to iteratively generate an incremental update to the input until a sufficiently good estimate of the true signal has been reached, which can be seen for MRI below. This can be seen as similar to producing text via editing, rewriting, and iterative refining.</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://ruder.io/content/images/2018/11/rim.gif" class="kg-image" alt="EMNLP 2018 Highlights: Inductive bias, cross-lingual learning, and more"><figcaption>Inference process of an RIM for MRI (left: generated image; middle: reference; right: error; Source: <a href="http://sbt.science.uva.nl/mri/2017/11/24/the-recurrent-inference-machine/">CIFAR</a>)</figcaption></figure><!--kg-card-end: image--><ul><li>A popular way to obtain certain types of invariance in current NLP approaches is via adversarial examples. To this end, <a href="http://aclweb.org/anthology/D18-1316">Alzantot et al.</a> use a black-box population-based optimization algorithm to generate semantic and syntactic adversarial examples.</li><li><a href="http://aclweb.org/anthology/K18-1007">Minervini and Riedel</a> propose to incorporate logic to generate adversarial examples. In particular, they use a combination of combinatorial optimization and a language model to generate examples that maximally violate such logic constraints for natural language inference.</li><li>Another form of inductive bias can be induced via regularization. In particular, <a href="http://aclweb.org/anthology/K18-1030">Barrett et al.</a> received the special paper award at CoNLL for showing that <em>human attention</em> provides a good inductive bias for attention in neural networks. The human attention is derived from eye-tracking corpora, which—importantly—can be disjoint from the training data.</li><li>For another beneficial inductive bias for attention, in one of the best papers of the conference, <a href="http://aclweb.org/anthology/D18-1548">Strubell et al.</a> encourage one attention head to attend to the syntactic parents for each token in multi-head attention. They additionally use multi-task learning and allow the injection of a syntactic parse at test time.</li><li>Many NLP tasks such as entailment and semantic similarity compute some sort of alignment between two sequences, but this alignment is either at the word or sentence level. <a href="http://aclweb.org/anthology/D18-1184">Liu et al.</a> propose to incorporate a structural bias by using <em>structured alignments</em>, which match spans in both sequences to each other.</li><li>Tree-based have been popular in NLP and encode the bias that knowledge of syntax is beneficial. <a href="http://aclweb.org/anthology/D18-1492">Shi et al.</a> analyze a phenomenon that runs counter to this, which is that trivial trees with no syntactic information often achieve better results than syntactic trees. Their key insight is that in well-performing trees, crucial words are closer to the final representation, which helps in mitigating RNNs' <a href="http://ruder.io/acl-2018-highlights/#analyzingtheinductivebias">sequential recency bias</a>.</li><li>For aspect-based sentiment analysis, sentence representations are typically computed separately from aspect representations. <a href="http://aclweb.org/anthology/D18-1136">Huang and Carley</a> propose a nice way to condition the sentence representation on the aspect by using the aspect representation as the <em>parameters of the filters or gates</em> in a CNN. Allowing encoded representations to directly parameterize other parts of a neural network might be useful for other applications, too.</li></ul><h2 id="cross-lingual-learning">Cross-lingual learning</h2><p>There are roughly 6,500 languages spoken around the world. Despite this, the predominant focus of research is on English. This seems to change perceptibly as more papers are investigating cross-lingual settings.</p><ul><li>In her <a href="http://www.conll.org/keynotes-2018">CoNLL keynote</a>, <a href="https://www.mpi.nl/people/majid-asifa">Asifa Majid</a> gives an insightful overview of how culture and language can shape our internal representation of concepts. A common example of this is Scottish having <a href="https://www.bbc.com/news/uk-scotland-34323967">421 terms for snow</a>. This phenomenon not only applies to our environment, but also to how we talk about ourselves and our bodies.</li></ul><blockquote>Languages vary surprisingly in the parts of the body they single out for naming. Variations in part of the lexicon can have knock-on effects for other parts.</blockquote><p>If you ask speakers of different languages to color in different body parts in a picture, the body parts that are associated with each term depend on the language. In Dutch, the hand is often considered to be part of the term 'arm', whereas in Japanese, the arm is more clearly delimited. Indonesian, lacking an everyday term that corresponds to 'hand', associates 'arm' with both the hand and the arm as can be seen below.</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://ruder.io/content/images/2018/11/hand_arm-1.jpg" class="kg-image" alt="EMNLP 2018 Highlights: Inductive bias, cross-lingual learning, and more"><figcaption>Composite images for 'arm' in Dutch, Japanese, and Indonesian <a href="https://onlinelibrary.wiley.com/doi/full/10.1111/tops.12159">(Majid &amp; van Staden, 2015)</a></figcaption></figure><!--kg-card-end: image--><p>The representations we obtain from language influence every form of perception. Hans Henning claimed that "olfactory (i.e. related to smell) abstraction is impossible". Most languages lack terms describing specific scents and odours. In contrast, the <a href="https://en.wikipedia.org/wiki/Jahai_people">Jahai</a>, a people of hunter-gatherers in Malaysia, have half a dozen terms for different qualities of smell, which allow them to identify smells much more precisely <a href="http://rstb.royalsocietypublishing.org/content/373/1752/20170139">(Majid et al., 2018)</a>.</p><p>There was a surprising amount of work on <a href="http://ruder.io/cross-lingual-embeddings/">cross-lingual word embeddings</a> at the conference. Taking insights from Asifa's talk, it will be interesting to <em>incorporate insights from psycholinguistics</em> in how we model words across languages and different cultures, as cross-lingual embeddings have mostly focused on word-to-word alignment and so far did not even consider polysemy.</p><ul><li>For cross-lingual word embeddings, <a href="http://aclweb.org/anthology/K18-1021">Kementchedjhieva et al.</a> show that mapping the languages onto a third, latent space (the mean of the monolingual embedding spaces) rather than directly onto each other, makes it easier to learn an alignment. This approach also naturally enables the integration of supporting languages in low resource scenarios. (Note: I'm a co-author on this paper.)</li><li>With a similar goal in mind, <a href="http://aclweb.org/anthology/D18-1027">Doval et al.</a> propose to move each word vector towards the mean between its current representation and the representation of the translation in a separate refinement step.</li><li>Similar to using multilingual support, <a href="http://aclweb.org/anthology/D18-1024">Chen and Cardie</a> propose to jointly learn cross-lingual embeddings between multiple languages by modeling the relations between all language pairs.</li><li><a href="http://aclweb.org/anthology/D18-1056">Hartmann et al.</a> analyze an observation of our <a href="http://aclweb.org/anthology/P18-1072">ACL 2018 paper</a>: Aligning embedding spaces induced with different algorithms <em>does not work</em>. They show, however, that a linear transformation still exists and hypothesize that the optimization problem of learning this transformation might be complicated by the algorithms' different inductive biases.</li><li>Not only word embedding spaces induced by different algorithms, but also word embedding spaces in different languages have different structures, especially for distant languages. <a href="http://aclweb.org/anthology/D18-1047">Nakashole</a> proposes to learn a transformation that is sensitive to the local neighborhood, which is particularly beneficial for distant languages.</li><li>For the same problem, <a href="http://aclweb.org/anthology/D18-1043">Hoshen and Wolf</a> propose to first align the second moment of the word distributions and then iteratively refine the alignment.</li><li><a href="http://aclweb.org/anthology/D18-1214">Alvarez-Melis and Jaakkola</a> offer a different perspective on word-to-word translation by viewing it as an optimal transport problem. They use the Gromov-Wasserstein distance to measure similarities between pairs of words across languages.</li><li><a href="http://aclweb.org/anthology/D18-1268">Xu et al.</a> instead propose to minimize the Sinkhorn distance between the source and target distributions.</li><li><a href="http://aclweb.org/anthology/D18-1023">Huang et al.</a> go beyond word alignment with their approach. They introduce multiple cluster-level alignments and additionally enforce the clusters to be consistently distributed across multiple languages.</li><li>In one of the best papers of the conference, <a href="http://aclweb.org/anthology/D18-1549">Lample et al.</a> proposes an unsupervised phrase-based machine translation model, which works particularly well for low-resource languages. On Urdu-English, it outperforms a supervised phrase-based model trained on 800,000 noisy and out-of-domain parallel sentences.</li><li><a href="http://aclweb.org/anthology/D18-1399">Artetxe et al.</a> propose a similar phrase-based approach to unsupervised machine translation.</li></ul><h2 id="word-embeddings">Word embeddings</h2><p>Besides cross-lingual word embeddings, there was naturally also work investigating and improving word embeddings, but this seemed to be a lot less pervasive than in past years.</p><ul><li><a href="http://aclweb.org/anthology/D18-1057">Zhuang et al.</a> propose to use second-order co-occurrence relations to train word embeddings via a newly designed metric.</li><li><a href="http://aclweb.org/anthology/D18-1059">Zhao et al.</a> propose to learn word embeddings for out-of-vocabulary words by viewing words as bags of character n-grams.</li><li><a href="http://aclweb.org/anthology/D18-1181">Bosc and Vincent</a> learn word embeddings by reconstructing dictionary definitions.</li><li><a href="http://aclweb.org/anthology/D18-1521">Zhao et al.</a> learn gender-neutral word embeddings rather than removing the bias from trained embeddings. Their approach allocates certain dimensions of the embedding to gender information, while it keeps the remaining dimensions gender-neutral.</li></ul><h2 id="latent-variable-models">Latent variable models</h2><p>Latent variable models are slowly emerging as a useful tool to express a structural inductive bias and to model the linguistic structure of words and sentences.</p><ul><li>Kim et al. provided an excellent tutorial of deep latent variable models. The slides can be found <a href="http://nlp.seas.harvard.edu/latent-nlp-tutorial.html">here</a>.</li><li>In his talk at the BlackBox NLP workshop, Graham Neubig highlighted latent variables as a way to model the <em>latent linguistic structure</em> of text with neural network. In particular, he discussed <a href="http://aclweb.org/anthology/P17-1029">multi-space variational encoder-decoders</a> and <a href="http://aclweb.org/anthology/P18-1070">tree-structured variational auto-encoders</a>, two semi-supervised learning models that leverage latent variables to take advantage of unlabeled data.</li><li>In <a href="http://aclweb.org/anthology/D18-1042">our paper</a>, we showed how cross-lingual embedding methods can be seen as latent variable models. We can use this insight to derive an EM algorithm and learn a better alignment between words.</li><li><a href="http://aclweb.org/anthology/D18-1062">Dou et al.</a> similarly propose a latent variable model based on a variational auto-encoder for unsupervised bilingual lexicon induction.</li><li>In the model by <a href="http://aclweb.org/anthology/D18-1088">Zhang et al.</a>, sentences are viewed as latent variables for summarization. Sentences with activated variables are extracted and directly used to infer gold summaries.</li><li>There were also papers that proposed methods for more general applications. <a href="http://aclweb.org/anthology/D18-1480">Xu and Durrett</a> propose to use a different distribution in variational auto-encoders that mitigates the common failure mode of a collapsing KL divergence.</li><li><a href="http://aclweb.org/anthology/D18-1108">Niculae et al.</a> propose a new approach to build dynamic computation graphs with latent structure through sparsity.</li></ul><h2 id="language-models">Language models</h2><p>Language models are becoming more commonplace in NLP and many papers investigated different architectures and properties of such models.</p><ul><li>In an insightful paper, <a href="http://aclweb.org/anthology/D18-1179">Peters et al.</a> show that LSTMs, CNNs, and self-attention language models all learn high-quality representations. They additionally show that the representations vary with network depth: morphological information is encoded at the word embedding layer; local syntax is captured at lower layers and longer-range semantics are encoded at the upper layers. </li><li><a href="http://aclweb.org/anthology/D18-1503">Tran et al.</a> show that LSTMs generalize hierarchical structure better than self-attention. This hints at possible limitations of the Transformer architecture and suggests that we might need different encoding architectures for different tasks.</li><li><a href="http://aclweb.org/anthology/D18-1458">Tang et al.</a> find that the Transformer and CNNs are not better than RNNs at modeling long-distance agreement. However, models relying on self-attention excel at word sense disambiguation. </li><li>Other papers looks at different properties of language models. <a href="http://aclweb.org/anthology/D18-1523">Amrami and Goldberg</a> show that language models can achieve state-of-the-art for unsupervised word sense induction. Importantly, rather than just providing the left and right context to the word, they find that appending "and" provides more natural and better results. It will be interesting to see what other clever uses we will find for LMs.</li><li><a href="http://aclweb.org/anthology/D18-1505">Krishna et al.</a> show that ELMo performs better than logic rules on sentiment analysis tasks. They also demonstrate that language models can implicitly learn logic rules.</li><li>In the best paper at the BlackBoxNLP workshop, <a href="http://aclweb.org/anthology/W18-5426">Giulianelli et al.</a> use diagnostic classifiers to keep track and improve number agreement in language models.</li><li>In another BlackBoxNLP paper, <a href="http://aclweb.org/anthology/W18-5423">Wilcox et al.</a> show that RNN language models can represent filler-gap dependencies and learn a particular subset of restrictions known as island constraints.  </li></ul><h2 id="datasets">Datasets</h2><p>Many new tasks and datasets were presented at the conference, many of which propose more challenging settings.</p><ul><li><strong>Grounded common sense inference</strong>: <a href="http://aclweb.org/anthology/D18-1009">SWAG</a> contains 113k multiple choice questions about a rich spectrum of grounded situations.</li><li><strong>Coreference resolution</strong>: <a href="http://aclweb.org/anthology/D18-1016">PreCo</a> contains 38k documents and 12.5M words, which are mostly from the vocabulary of English-speaking preschoolers.</li><li><strong>Document grounded dialogue</strong>: The dataset by <a href="http://aclweb.org/anthology/D18-1076">Zhou et al.</a> contains 4112 conversations with an average of 21.43 turns per conversation.</li><li><strong>Automatic story generation from videos</strong>: <a href="http://aclweb.org/anthology/D18-1117">VideoStory</a> contains 20k social media videos amounting to 396 hours of video with 123k sentences, temporally aligned to the video.</li><li><strong>Sequential open-domain question answering</strong>: <a href="http://aclweb.org/anthology/D18-1134">QBLink</a> contains 18k question sequences, with each sequence consisting of three naturally occurring human-authored questions.</li><li><strong>Multimodal reading comprehension</strong>: <a href="http://aclweb.org/anthology/D18-1166">RecipeQA</a> consists of 20k instructional recipes with multiple modalities such as titles, descriptions and aligned set of images and 36k automatically generated question-answer pairs.</li><li><strong>Word similarity</strong>: <a href="http://aclweb.org/anthology/D18-1169">CARD-660</a> consists of 660 manually selected rare words with manually selected paired words and expert annotations.</li><li><strong>Cloze style question answering</strong>: <a href="http://aclweb.org/anthology/D18-1257">CLOTH</a> consists of 7,131 passages and 99,433 questions used in middle-school and high-school language exams. </li><li><strong>Multi-hop question answering</strong>: <a href="http://aclweb.org/anthology/D18-1259">HotpotQA</a> contains 113k Wikipedia-based question-answer pairs.</li><li><strong>Open book question answering</strong>: <a href="http://aclweb.org/anthology/D18-1260">OpenBookQA</a> consists of 6,000 questions and 1,326 elementary level science facts.</li><li><strong>Semantic parsing and text-to-SQL</strong>: <a href="http://aclweb.org/anthology/D18-1425">Spider</a> contains 10,181 questions and 5,693 unique complex SQL queries on 200 databases with multiple tables covering 138 different domains.</li><li><strong>Few-shot relation classification</strong>: <a href="http://aclweb.org/anthology/D18-1514">FewRel</a> consists of 70k sentences on 100 relations derived from Wikipedia.</li><li><strong>Natural language inference</strong>: <a href="http://aclweb.org/anthology/D18-1187">MedNLI</a> consists of 14k sentence pairs in the clinical domain.</li><li><strong>Multilingual natural language inference</strong>: <a href="http://aclweb.org/anthology/D18-1269">XNLI</a> extends the MultiNLI dataset to 15 languages. </li><li><strong>Task-oriented dialogue modeling</strong>: <a href="http://aclweb.org/anthology/D18-1547">MultiWOZ</a>, which won the best resource paper award, is a Wizard-of-Oz style dataset consisting of 10k human-human written conversations spanning over multiple domains and topics.</li></ul><p>Papers also continued the trend of <a href="http://ruder.io/acl-2018-highlights/">ACL 2018</a> of analyzing the limitations of existing datasets and metrics.</p><ul><li><strong>Text simplification</strong>: <a href="http://aclweb.org/anthology/D18-1081">Sulem et al.</a> show that BLEU is not a good evaluation metric for sentence splitting, the most common operation in text simplification.</li><li><strong>Text-to-SQL</strong>: <a href="http://aclweb.org/anthology/D18-1197">Yavuz et al.</a> show what it takes to achieve 100% accuracy on the WikiSQL benchmark.</li><li><strong>Reading comprehension</strong>: <a href="http://aclweb.org/anthology/D18-1546">Kaushik and Lipton</a> show in the best short paper that models that only rely on the passage or the last sentence for prediction do well on many reading comprehension tasks.</li></ul><h2 id="miscellaneous">Miscellaneous </h2><p>These are papers that provide a refreshing take or tackle an unusual problem, but do not fit any of the above categories.</p><ul><li><a href="http://aclweb.org/anthology/D18-1182">Stanovsky and Hopkins</a> propose a novel way to test word representations. Their approach uses Odd-Man-Out puzzles, which consists of 5 (or more) words and require the system to choose the word that does not belong with the others. They show that such a simple setup can reveal various properties of different representations.</li><li>A similarly playful way to test the associative properties of word embeddings is proposed by <a href="http://aclweb.org/anthology/K18-1029">Shen et al.</a> They use a simplified version of the popular game <a href="https://boardgamegeek.com/boardgame/178900/codenames">Codenames</a>. In their setting, a speaker has to select an adjective to refer to two out of three nouns, which then need to be identified by the listener.</li><li>Causal understanding is important for many real-world application, but causal inference has so far not found much adoption in NLP. <a href="http://aclweb.org/anthology/D18-1488">Wood-Doughty et al.</a> demonstrate how causal analyses can be conducted for text classification and discuss opportunities and challenges and for future work.</li><li>Gender bias and equal opportunity are big issues in STEM. <a href="http://aclweb.org/anthology/D18-1301">Schluter</a> argues that a <a href="https://en.wikipedia.org/wiki/Glass_ceiling"><em>glass ceiling</em></a> exists in NLP, which prevents high achieving women and minorities from obtaining equal access to opportunities. While the field of NLP has been consistently ~33% female, Schluter analyzes 52 years of NLP publication data consisting of 15.6k gender-labeled authors and observes that the growth level of female seniority standing (indicated by last-authorship on a paper) falls significantly below that of the male population, with a gap that is widening.</li><li><a href="http://aclweb.org/anthology/D18-1533">Shillingford and Jones</a> tackle both an interesting problem and utilize a refreshing approach. They seek to recover missing characters for long vowels and glottal stops in Old Hawaiian Writing, which are important for reading comprehension and pronunciation. They propose to compose a finite-state transducer—which incorporates domain information—with a neural network. Importantly, their approach only requires modern Hawaiian texts for training.</li></ul><h2 id="other-reviews">Other reviews</h2><p>You might also find these other reviews of EMNLP 2018 helpful:</p><ul><li><a href="https://chauff.github.io/2018-11-04-emnlp/">Claudia Hauff</a> lists 28 papers that stood out to her, focusing on dataset papers or papers with a strong IR component.</li><li><a href="https://www.patricklewis.io/post/emnlp2018/">Patrick Lewis</a> provides a comprehensive overview of the conference, covering many of the tutorials and workshops as well as highlights from each session. </li><li><a href="https://supernlp.github.io/2018/11/10/emnlp-2018/">A group of PhD students and postdocs at the University of Copenhagen</a> wrote another very comprehensive overview of the conference.</li></ul>]]></content:encoded></item><item><title><![CDATA[HackerNoon Interview]]></title><description><![CDATA[This post is an interview by fast.ai fellow Sanyam Bhutani with me. It covers my background, advice on getting started with NLP, writing technical articles, and more.]]></description><link>http://ruder.io/hackernoon-interview/</link><guid isPermaLink="false">5c76ff7c1b9b0d18555b9eaf</guid><category><![CDATA[natural language processing]]></category><dc:creator><![CDATA[Sebastian Ruder]]></dc:creator><pubDate>Tue, 02 Oct 2018 10:40:18 GMT</pubDate><media:content url="http://ruder.io/content/images/2018/10/wordcloud_interview.png" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><!--kg-card-begin: markdown--><img src="http://ruder.io/content/images/2018/10/wordcloud_interview.png" alt="HackerNoon Interview"><p>This post is an interview by fast.ai fellow Sanyam Bhutani with me.</p>
<p><em>This post originally appeared at <a href="https://hackernoon.com/interview-with-deep-learning-and-nlp-researcher-sebastian-ruder-91ddaf473c4b">HackerNoon</a> with a different introduction</em>.</p>
<p>I had the honour to be interviewed by <a href="https://twitter.com/bhutanisanyam1">Sanyam Bhutani</a>, a Deep Learning and Computer Vision practitioner and <a href="http://www.fast.ai/2018/01/17/international-spring-2018/">fast.ai fellow</a> who's been doing a <a href="https://hackernoon.com/interview-with-kaggle-competitions-grandmaster-kazanova-rank-3-dr-marios-michailidis-cc515194cb67">series</a> interviewing people that inspire him. To be honest, it feels surreal to be the one being interviewed. I hope my answers may be interesting or useful to some of you.</p>
<p><strong>Sanyam</strong>: Hello Sebastian, Thank you for taking the time to do this.</p>
<p><strong>Sebastian</strong>: Thanks for having me.</p>
<p><strong>Sanyam</strong>: You’re working as a research scientist today at AYLIEN, and you’re a Ph.D. student at Insight Research Centre for Data Analytics. Could you tell the readers about how you got started? What got you interested in NLP and Deep Learning?</p>
<p><strong>Sebastian</strong>: I was really into maths and languages when I was in high school and took part in competitions. For my studies, I wanted to combine the logic of maths with the creativity of language somehow but didn’t know if such a field existed. That’s when I came across Computational Linguistics, which seemed to be a perfect fit at the intersection of computer science and linguistics. I then did my Bachelor’s in Computational Linguistics at the University of Heidelberg in Germany, one of my favourite places in Europe. During my Bachelor’s, I got most excited by machine learning, so I tried to get as much as exposure to ML as possible via internships and online courses. I only heard about word2vec as I was finishing my undergrad in 2015; as I learned more about Deep Learning at the start of my Ph.D. later that year, it seemed to be most exciting direction, so I decided to focus on it.</p>
<p><strong>Sanyam</strong>: You started your research right after graduation. What made you pick research as a career path instead of the industry?</p>
<p><strong>Sebastian</strong>: After graduating, I was planning to get some industry experience first by working in a startup. A PhD was always something I had dreamed of, but I hadn’t seriously considered it at that point. When I discussed working with the Dublin-based NLP startup Aylien, they told me about the Employment-based Postgraduate Programme, a PhD programme that is hosted jointly by a university and a company, which seemed like the perfect fit for me. Combining research and industry work can be challenging at times, but has been rewarding for me overall. Most importantly, there should be a fit with the company.</p>
<p><strong>Sanyam</strong>: You’ve been working as a researcher for 3 years now. What has been your favorite project during these years?</p>
<p><strong>Sebastian</strong>: In terms of learning, delving into a new area where I don’t know much, reading papers, and getting to collaborate with great people. In this vein, my project working on multi-task learning at the University of Copenhagen was a great and very stimulating experience. In terms of impact, being able to work with Jeremy, interacting with the fastai community, and seeing that people find our work on language models useful.</p>
<p><strong>Sanyam</strong>: Natural Language Processing has arguably lagged behind Computer Vision. What are your thoughts about the current scenario? Is it a good time to get started as an NLP Practitioner?</p>
<p><strong>Sebastian</strong>: I think now is a great time to get started with NLP. Compared to a couple of years ago, we’re at a point of maturity where you’re not limited to just using word embeddings or off-the-shelf models, but you can compose your model from a wide array of components, such as different layers, pretrained representations, auxiliary losses, etc. There also seems to be a growing feeling in the community that many of the canonical problems (POS tagging and dependency parsing on the Penn Treebank, sentiment analysis on movie reviews, etc.) are close to being solved, so we really want to make progress on more challenging problems, such as “real” natural language understanding and creating models that truly generalize. For these problems, I think we can really benefit from people with new perspectives and ideas. In addition, as we can now train models for many useful tasks such as classification or sequence labelling with good accuracy, there are a lot of opportunities for applying and adapting these models to other languages. If you’re a speaker of another language, you can make a big difference by creating datasets others can use for evaluation and training models for that language.</p>
<p><strong>Sanyam</strong>: For the readers and the beginners who are interested in working on Natural Language Processing, what would be your best advice?</p>
<p><strong>Sebastian</strong>: Find a task you’re interested in for instance by browsing the tasks on NLP-progress. If you’re interested in doing research, try to choose a particular subproblem not everyone is working on. For instance, for sentiment analysis, don’t work on movie reviews but conversations. For summarization, summarize biomedical papers rather than news articles. Read papers related to the task and try to understand what the state-of-the-art does. Prefer tasks that have open-source implementations available that you can run. Once you have a good handle of how something works, for research, reflect if you were surprised by any choices in the paper. Try to understand what kind of errors the model makes and if you can think of any information that could be used to mitigate them. Doing error and ablation analyses or using synthetic tasks that gauge if a model captures a certain kind of information are great ways to do this.</p>
<p>If you have an idea how to make the task more challenging or realistic, try to create a dataset and apply the existing model to that task. Try to recreate the dataset in your language and see if the model performs equally well.</p>
<p><strong>Sanyam</strong>: Many job boards (For DL/ML) require the applicants to be post-grads or have research experience. For the readers who want to take up Machine Learning as a Career path, do you feel having research experience is a necessity?</p>
<p><strong>Sebastian</strong>: I think research experience can be a good indicator that you’re proficient with certain models and creative, innovative to come up with new solutions. You don’t need to do a Ph.D. or a research fellowship to learn these skills, though. Being proactive, learning about and working on a problem that you’re excited about, trying to improve the model, and writing about your experience is a good way to get started and demonstrate similar skills. In most applied ML settings, you won’t be required to come up with totally new ways to solve a task. Doing ML and data science competitions can thus similarly help you demonstrate that you know how to apply ML models in practice.</p>
<p><strong>Sanyam</strong>: Given the explosive growth rates in research, How do you stay up to date with the cutting edge?</p>
<p><strong>Sebastian</strong>: I’ve been going through the arXiv daily update, adding relevant papers to my reading list, and reading them in batches. Jeff Dean recently said during a talk at the Deep Learning Indaba that he thinks it’s better to read ten abstracts than one paper in-depth as you can always go back and read one of the papers in-depth. I agree with him. I think you want to read widely about as many ideas as possible, which you can catalogue and use for inspiration later. Having a good paper management system is key. I’ve been using Mendeley. Lately, I’ve been relying more on Arxiv Sanity Preserver to surface relevant papers.</p>
<p><strong>Sanyam</strong>: You also maintain a great blog, which I’m a great fan of. Could you share some tips on effectively writing technical articles?</p>
<p><strong>Sebastian</strong>: I’ve had the best experience writing a blog when I started out writing it for myself to understand a particular topic better. If you ever find yourself having to put in a lot of work to build intuition or do a lot of research to grasp a subject, consider writing a post about it so you can accelerate everyone else’s learning in the future. In research papers, there’s usually not enough space to properly contextualize a work, highlight motivations, and intuitions, etc. Blog posts are a great way to make technical content more accessible and approachable.</p>
<p>The great thing about a blog is that it doesn’t need to be perfect. You can use it to improve your communication skills as well as obtain feedback on your ideas and things you might have missed. In terms of writing, I think the most important thing I have learned is to be biased towards clarity. Try to be as unambiguous as possible. Remove sentences that don’t add much value. Remove vague adjectives. Write only about what the data shows and if you speculate, clearly say so.<br>
Get feedback on your draft from your friends and colleagues. Don’t try to make something 100% perfect, but get it to a point where you’re happy with it. Feeling anxiety when clicking that ‘Publish’ button is totally normal and doesn’t go away. Publishing something will always be worth it in the long-term.</p>
<p><strong>Sanyam</strong>: Do you feel Machine Learning has been overhyped?</p>
<p><strong>Sebastian</strong>: No.</p>
<p><strong>Sanyam</strong>: Before we conclude, any tips for the beginners who are afraid to get started because of the idea that Deep Learning is an advanced field?</p>
<p><strong>Sebastian</strong>: Don’t let anyone tell you that you can’t do this. Do online courses to build your understanding. Once you’re comfortable with the fundamentals, read papers for inspiration when you have time. Choose something you’re excited about, choose a library, and work on it. Don’t think you need massive compute to work on meaningful problems. Particularly in NLP, there are lot of problems with a small number of labelled examples. Write about what you’re doing and learning. Reach out to people with similar interests and focus areas. Engage with the community, e.g. the fastai community is awesome. Get on Twitter. Twitter has a great ML community and you can often get replies from top experts in the field way faster than via email. Find a mentor. If you write to someone for advice, be mindful of their time. Be respectful and try to help others. Be generous with praise and cautious with criticism.</p>
<p><strong>Sanyam</strong>: Thank you so much for doing this interview.</p>
<p>The cover image for this post was generated based on the content of the post using <a href="https://www.wordclouds.com/">wordcouds</a>.</p>
<!--kg-card-end: markdown--><!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[A Review of the Neural History of Natural Language Processing]]></title><description><![CDATA[This post expands on the Frontiers of Natural Language Processing session organized at the Deep Learning Indaba 2018. It discusses major recent advances in NLP focusing on neural network-based methods.]]></description><link>http://ruder.io/a-review-of-the-recent-history-of-nlp/</link><guid isPermaLink="false">5c76ff7c1b9b0d18555b9eae</guid><category><![CDATA[language models]]></category><category><![CDATA[natural language processing]]></category><category><![CDATA[word embeddings]]></category><category><![CDATA[multi-task learning]]></category><category><![CDATA[transfer learning]]></category><dc:creator><![CDATA[Sebastian Ruder]]></dc:creator><pubDate>Mon, 01 Oct 2018 12:50:00 GMT</pubDate><media:content url="http://ruder.io/content/images/2018/10/neural_history_of_nlp_image.png" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><!--kg-card-begin: markdown--><img src="http://ruder.io/content/images/2018/10/neural_history_of_nlp_image.png" alt="A Review of the Neural History of Natural Language Processing"><p>This post discusses major recent advances in NLP focusing on neural network-based methods.</p>
<p><em>This post originally appeared at the <a href="http://blog.aylien.com/a-review-of-the-recent-history-of-natural-language-processing/">AYLIEN blog</a>.</em></p>
<p>This is the first blog post in a two-part series. The series expands on the Frontiers of Natural Language Processing session organized by <a href="http://www.kamperh.com/">Herman Kamper</a> and me at the <a href="http://www.deeplearningindaba.com/">Deep Learning Indaba 2018</a>. Slides of the entire session can be found <a href="https://www.slideshare.net/SebastianRuder/frontiers-of-natural-language-processing">here</a>. This post discusses major recent advances in NLP focusing on neural network-based methods. <a href="http://ruder.io/4-biggest-open-problems-in-nlp/">The second post</a> discusses open problems in NLP. You can find a recording of the talk this post is based on <a href="https://youtu.be/sGVi4gb90zk?list=PLICxY_yQeGYlcjO6ANCXworXHGC6hHXjA&t=177">here</a>.</p>
<p><strong>Disclaimer</strong>   This post tries to condense ~15 years' worth of work into eight milestones that are the most relevant today and thus omits many relevant and important developments. In particular, it is heavily skewed towards current neural approaches, which may give the false impression that no other methods were influential during this period. More importantly, many of the neural network models presented in this post build on non-neural milestones of the same era. In the <a href="#nonneuralmilestones">final section of this post</a>, we highlight such influential work that laid the foundations for later methods.</p>
<p>Table of contents:</p>
<ul>
<li><a href="#2001neurallanguagemodels">2001 - Neural language models</a></li>
<li><a href="#20018multitasklearning">2008 - Multi-task learning</a></li>
<li><a href="#2013wordembeddings">2013 - Word embeddings</a></li>
<li><a href="#2013neuralnetworksfornlp">2013 - Neural networks for NLP</a></li>
<li><a href="#2014sequencetosequencemodels">2014 - Sequence-to-sequence models</a></li>
<li><a href="#2015attention">2015 - Attention</a></li>
<li><a href="#2015memorybasednetworks">2015 - Memory-based networks</a></li>
<li><a href="#2018pretrainedlanguagemodels">2018 - Pretrained language models</a></li>
<li><a href="#othermilestones">Other milestones</a></li>
<li><a href="#nonneuralmilestones">Non-neural milestones</a></li>
</ul>
<h1 id="2001neurallanguagemodels">2001 - Neural language models</h1>
<p>Language modelling is the task of predicting the next word in a text given the previous words. It is probably the simplest language processing task with concrete practical applications such as <a href="https://en.wikipedia.org/wiki/SwiftKey">intelligent keyboards</a>, email response suggestion (Kannan et al., 2016)<a href="#fn2"></a>, spelling autocorrection, etc. Unsurprisingly, language modelling has a rich history. Classic approaches are based on <a href="https://en.wikipedia.org/wiki/N-gram">n-grams</a> and employ smoothing to deal with unseen n-grams (Kneser &amp; Ney, 1995)<a href="#fn1"></a>.<br>
The first neural language model, a feed-forward neural network was proposed in 2001 by Bengio et al.<a href="#fn3"></a>, shown in Figure 1 below.</p>
<figure>
    <center>
<img src="http://ruder.io/content/images/2018/09/lm_bengio_2003.png" width="450" alt="A Review of the Neural History of Natural Language Processing">
    <figcaption>Figure 1: A feed-forward neural network language model (Bengio et al., 2001; 2003)</figcaption>
    </center>
</figure>
<p>This model takes as input vector representations of the \(n\) previous words, which are looked up in a table \(C\). Nowadays, such vectors are known as word embeddings. These word embeddings are concatenated and fed into a hidden layer, whose output is then provided to a softmax layer. For more information about the model, have a look at <a href="http://ruder.io/word-embeddings-1/index.html#classicneurallanguagemodel">this post</a>.<br>
More recently, feed-forward neural networks have been replaced with recurrent neural networks (RNNs; Mikolov et al., 2010)<a href="#fn4"></a> and long short-term memory networks (LSTMs; Graves, 2013)<a href="#fn5"></a> for language modelling. Many new language models that extend the classic LSTM have been proposed in recent years (have a look at <a href="http://nlpprogress.com/language_modeling.html">this page</a> for an overview). Despite these developments, the classic LSTM remains a strong baseline (Melis et al., 2018)<a href="#fn6"></a>. Even Bengio et al.'s classic feed-forward neural network is in some settings competitive with more sophisticated models as these typically only learn to consider the most recent words (Daniluk et al., 2017)<a href="#fn7"></a>. Understanding better what information such language models capture consequently is an active research area (Kuncoro et al., 2018; Blevins et al., 2018)<a href="#fn87"></a><a href="#fn88"></a>.</p>
<p>Language modelling is typically the training ground of choice when applying RNNs and has succeeded at capturing the imagination, with many getting their first exposure via <a href="http://karpathy.github.io/2015/05/21/rnn-effectiveness/">Andrej's blog post</a>. Language modelling is a form of unsupervised learning, which Yann LeCun also calls predictive learning and cites as a prerequisite to acquiring common sense (see <a href="http://ruder.io/highlights-nips-2016/#generalartificialintelligence">here</a> for his Cake slide from NIPS 2016). Probably the most remarkable aspect about language modelling is that despite its simplicity, it is core to many of the later advances discussed in this post:</p>
<ul>
<li>Word embeddings: The objective of word2vec is a simplification of language modelling.</li>
<li>Sequence-to-sequence models: Such models generate an output sequence by predicting one word at a time.</li>
<li>Pretrained language models: These methods use representations from language models for transfer learning.</li>
</ul>
<p>This conversely means that many of the most important recent advances in NLP reduce to a form of language modelling. In order to do &quot;real&quot; natural language understanding, just learning from the raw form of text likely will not be enough and we will need new methods and models.</p>
<h1 id="2008multitasklearning">2008 - Multi-task learning</h1>
<p>Multi-task learning is a general method for sharing parameters between models that are trained on multiple tasks. In neural networks, this can be done easily by tying the weights of different layers. The idea of multi-task learning was first proposed in 1993 by Rich Caruana<a href="#fn8"></a> and was applied to road-following and pneumonia prediction (Caruana, 1998)<a href="#fn10"></a>. Intuitively, multi-task learning encourages the models to learn representations that are useful for many tasks. This is particularly useful for learning general, low-level representations, to focus a model's attention or in settings with limited amounts of training data. For a more comprehensive overview of multi-task learning, have a look at <a href="http://ruder.io/multi-task/">this post</a>.</p>
<p>Multi-task learning was first applied to neural networks for NLP in 2008 by Collobert and Weston<a href="#fn9"></a><a href="#fn11"></a>. In their model, the look-up tables (or word embedding matrices) are shared between two models trained on different tasks, as depicted in Figure 2 below.</p>
<figure>
    <center>
<img src="http://ruder.io/content/images/2018/09/collobert_icml2008.png" width="450" alt="A Review of the Neural History of Natural Language Processing">
    <figcaption>Figure 2: Sharing of word embedding matrices (Collobert & Weston, 2008; Collobert et al., 2011)</figcaption>
    </center>
</figure>
<p>Sharing the word embeddings enables the models to collaborate and share general low-level information in the word embedding matrix, which typically makes up the largest number of parameters in a model. The 2008 paper by Collobert and Weston proved influential beyond its use of multi-task learning. It spearheaded ideas such as pretraining word embeddings and using convolutional neural networks (CNNs) for text that have only been widely adopted in the last years. It won the <a href="https://research.fb.com/facebook-researchers-win-test-of-time-award-at-icml-2018/">test-of-time award at ICML 2018</a> (see the test-of-time award talk contextualizing the paper <a href="https://www.facebook.com/722677142/posts/10155393881507143/">here</a>).</p>
<p>Multi-task learning is now used across a wide range of NLP tasks and leveraging existing or &quot;artificial&quot; tasks has become a useful tool in the NLP repertoire. For an overview of different auxiliary tasks, have a look at <a href="http://ruder.io/multi-task-learning-nlp/">this post</a>. While the sharing of parameters is typically predefined, different sharing patterns can also be learned during the optimization process (Ruder et al., 2017)<a href="#fn12"></a>. As models are being increasingly evaluated on multiple tasks to gauge their generalization ability, multi-task learning is gaining in importance and dedicated benchmarks for multi-task learning have been proposed recently (Wang et al., 2018; McCann et al., 2018)<a href="#fn89"></a><a href="#fn90"></a>.</p>
<h1 id="2013wordembeddings">2013 - Word embeddings</h1>
<p>Sparse vector representations of text, the so-called <a href="https://en.wikipedia.org/wiki/Bag-of-words_model">bag-of-words model</a> have a long history in NLP. Dense vector representations of words or word embeddings have been used as early as 2001 as we have seen above. The main innovation that was proposed in 2013 by Mikolov et al.<a href="#fn14"></a><a href="#fn13"></a> was to make the training of these word embeddings more efficient by removing the hidden layer and approximating the objective. While these changes were simple in nature, they enabled---together with the efficient word2vec implementation---large-scale training of word embeddings.</p>
<p>Word2vec comes in two flavours that can be seen in Figure 3 below: continuous bag-of-words (CBOW) and skip-gram. They differ in their objective: one predicts the centre word based based on the surrounding words, while the other does the opposite.</p>
<figure>
    <center>
<img src="http://ruder.io/content/images/2018/09/cbow_skipgram_mikolov_2013.png" width="450" alt="A Review of the Neural History of Natural Language Processing">
    <figcaption>Figure 3: Continuous bag-of-words and skip-gram architectures (Mikolov et al., 2013a; 2013b)</figcaption>
    </center>
</figure>
While these embeddings are no different conceptually than the ones learned with a feed-forward neural network, training on a very large corpus enables them to approximate certain relations between words such as gender, verb tense, and country-capital relations, which can be seen in Figure 4 below.
<figure>
    <center>
<img src="http://ruder.io/content/images/2018/09/word2vec_relations.png" width="450" alt="A Review of the Neural History of Natural Language Processing">
    <figcaption>Figure 4: Relations captured by word2vec (Mikolov et al., 2013a; 2013b)</figcaption>
    </center>
</figure>
<p>These relations and the meaning behind them sparked initial interest in word embeddings and many studies have investigated the origin of these linear relationships (Arora et al., 2016; Mimno &amp; Thompson, 2017; Antoniak &amp; Mimno, 2018; Wendlandt et al., 2018)<a href="#fn15"></a><a href="#fn16"></a><a href="#fn17"></a><a href="#fn18"></a>. However, later studies showed that the learned relations are not without bias (Bolukbasi et al., 2016)<a href="#fn112"></a>. What cemented word embeddings as a mainstay in current NLP was that using pretrained embeddings as initialization was shown to improve performance across a wide range of downstream tasks<a href="#fn19"></a>.</p>
<p>While the relations word2vec captured had an intuitive and almost magical quality to them, later studies showed that there is nothing inherently special about word2vec: Word embeddings can also be learned via matrix factorization (Pennington et al, 2014; Levy &amp; Goldberg, 2014)<a href="#fn20"></a><a href="#fn21"></a> and with proper tuning, classic matrix factorization approaches like SVD and LSA achieve similar results (Levy et al., 2015)<a href="#fn22"></a>.</p>
<p>Since then, a lot of work has gone into exploring different facets of word embeddings (as indicated by the <a href="https://scholar.google.de/scholar?hl=en&as_sdt=0%2C5&q=distributed+representations+of+words+and+phrases&btnG=">staggering number of citations of the original paper</a>). Have a look at <a href="http://ruder.io/word-embeddings-2017/">this post</a> for some trends and future directions. Despite many developments, word2vec is still a popular choice and widely used today. Word2vec's reach has even extended beyond the word level: skip-gram with negative sampling, a convenient objective for learning embeddings based on local context, has been applied to learn representations for sentences (Mikolov &amp; Le, 2014; Kiros et al., 2015)<a href="#fn23"></a><a href="#fn24"></a>---and even going beyond NLP---to networks (Grover &amp; Leskovec, 2016)<a href="#fn25"></a> and biological sequences (Asgari &amp; Mofrad, 2015)<a href="#fn26"></a>, among others.</p>
<p>One particularly exciting direction is to project word embeddings of different languages into the same space to enable (zero-shot) cross-lingual transfer. It is becoming increasingly possible to learn a good projection in a completely unsupervised way (at least for similar languages) (Conneau et al., 2018; Artetxe et al., 2018; Søgaard et al., 2018)<a href="#fn27"></a><a href="#fn28"></a><a href="#fn29"></a>, which opens applications for low-resource languages and unsupervised machine translation (Lample et al., 2018; Artetxe et al., 2018)<a href="#fn91"></a><a href="#fn92"></a>. Have a look at (Ruder et al., 2018)<a href="#fn30"></a> for an overview.</p>
<h1 id="2013neuralnetworksfornlp">2013 - Neural networks for NLP</h1>
<p>2013 and 2014 marked the time when neural network models started to get adopted in NLP. Three main types of neural networks became the most widely used: recurrent neural networks, convolutional neural networks, and recursive neural networks.</p>
<p><strong>Recurrent neural networks</strong>   Recurrent neural networks (RNNs) are an obvious choice to deal with the dynamic input sequences ubiquitous in NLP. Vanilla RNNs (Elman, 1990)<a href="#fn31"></a> were quickly replaced with the classic long short-term memory networks (Hochreiter &amp; Schmidhuber, 1997)<a href="#fn32"></a>, which proved more resilient to the <a href="https://en.wikipedia.org/wiki/Vanishing_gradient_problem">vanishing and exploding gradient problem</a>. Before 2013, RNNs were still thought to be difficult to train; <a href="https://www.cs.utoronto.ca/~ilya/pubs/ilya_sutskever_phd_thesis.pdf">Ilya Sutskever's PhD thesis</a> was a key example on the way to changing this reputation. A visualization of an LSTM cell can be seen in Figure 5 below. A bidirectional LSTM (Graves et al., 2013)<a href="#fn93"></a> is typically used to deal with both left and right context.</p>
<figure>
    <center>
<img src="http://ruder.io/content/images/2018/09/lstm_colah_2015.png" width="450" alt="A Review of the Neural History of Natural Language Processing">
    <figcaption>Figure 5: An LSTM network (Source: <a href="https://colah.github.io/posts/2015-08-Understanding-LSTMs/">Chris Olah</a>)</figcaption>
    </center>
</figure>
<p><strong>Convolutional neural networks</strong>   With convolutional neural networks (CNNs) being widely used in computer vision, they also started to get applied to language (Kalchbrenner et al., 2014; Kim et al., 2014)<a href="#fn33"></a><a href="#fn34"></a>. A convolutional neural network for text only operates in two dimensions, with the filters only needing to be moved along the temporal dimension. Figure 6 below shows a typical CNN as used in NLP.</p>
<figure>
    <center>
<img src="http://ruder.io/content/images/2018/09/kim_emnlp2014.png" width="450" alt="A Review of the Neural History of Natural Language Processing">
    <figcaption>Figure 6: A convolutional neural network for text (Kim, 2014)</figcaption>
    </center>
</figure>
<p>An advantage of convolutional neural networks is that they are more parallelizable than RNNs, as the state at every timestep only depends on the local context (via the convolution operation) rather than all past states as in the RNN. CNNs can be extended with wider receptive fields using dilated convolutions to capture a wider context (Kalchbrenner et al., 2016)<a href="#fn35"></a>. CNNs and LSTMs can also be combined and stacked (Wang et al., 2016)<a href="#fn36"></a> and convolutions can be used to speed up an LSTM (Bradbury et al., 2017)<a href="#fn37"></a>.</p>
<p><strong>Recursive neural networks</strong>   RNNs and CNNs both treat the language as a sequence. From a linguistic perspective, however, language is <a href="https://en.wikipedia.org/wiki/Chomsky_hierarchy">inherently hierarchical</a>: Words are composed into higher-order phrases and clauses, which can themselves be recursively combined according to a set of production rules. The linguistically inspired idea of treating sentences as trees rather than as a sequence gives rise to recursive neural networks (Socher et al., 2013)<a href="#fn38"></a>, which can be seen in Figure 7 below.</p>
<figure>
    <center>
<img src="http://ruder.io/content/images/2018/09/socher_emnlp2013.png" width="450" alt="A Review of the Neural History of Natural Language Processing">
    <figcaption>Figure 7: A recursive neural network (Socher et al., 2013)</figcaption>
    </center>
</figure>
<p>Recursive neural networks build the representation of a sequence from the bottom up in contrast to RNNs who process the sentence left-to-right or right-to-left. At every node of the tree, a new representation is computed by composing the representations of the child nodes. As a tree can also be seen as imposing a different processing order on an RNN, LSTMs have naturally been extended to trees (Tai et al., 2015)<a href="#fn39"></a>.</p>
<p>Not only RNNs and LSTMs can be extended to work with hierarchical structures. Word embeddings can be learned based not only on local but on grammatical context (Levy &amp; Goldberg, 2014)<a href="#fn40"></a>; language models can generate words based on a syntactic stack (Dyer et al., 2016)<a href="#fn41"></a>; and graph-convolutional neural networks can operate over a tree (Bastings et al., 2017)<a href="#fn42"></a>.</p>
<h1 id="2014sequencetosequencemodels">2014 - Sequence-to-sequence models</h1>
<p>In 2014, Sutskever et al.<a href="#fn63"></a> proposed sequence-to-sequence learning, a general framework for mapping one sequence to another one using a neural network. In the framework, an encoder neural network processes a sentence symbol by symbol and compresses it into a vector representation; a decoder neural network then predicts the output symbol by symbol based on the encoder state, taking as input at every step the previously predicted symbol as can be seen in Figure 8 below.</p>
<figure>
    <center>
<img src="http://ruder.io/content/images/2018/09/sutskever_nips2014.png" width="450" alt="A Review of the Neural History of Natural Language Processing">
    <figcaption>Figure 8: A sequence-to-sequence model (Sutskever et al., 2014)</figcaption>
    </center>
</figure>
<p>Machine translation turned out to be the killer application of this framework. In 2016, Google announced that it was starting to replace its monolithic phrase-based MT models with neural MT models (Wu et al., 2016)<a href="#fn48"></a>. <a href="https://www.oreilly.com/ideas/what-machine-learning-means-for-software-development">According to Jeff Dean</a>, this meant replacing 500,000 lines of phrase-based MT code with a 500-line neural network model.</p>
<p>This framework due to its flexibility is now the go-to framework for natural language generation tasks, with different models taking on the role of the encoder and the decoder. Importantly, the decoder model can not only be conditioned on a sequence, but on arbitrary representations. This enables for instance generating a caption based on an image (Vinyals et al., 2015)<a href="#fn43"></a> (as can be seen in Figure 9 below), text based on a table (Lebret et al., 2016)<a href="#fn44"></a>, and a description based on source code changes (Loyola et al., 2017)<a href="#fn45"></a>, among many other applications.</p>
<figure>
    <center>
<img src="http://ruder.io/content/images/2018/09/vinyals_cvpr2015.png" width="450" alt="A Review of the Neural History of Natural Language Processing">
    <figcaption>Figure 9: Generating a caption based on an image (Vinyals et al., 2015)</figcaption>
    </center>
</figure>
<p>Sequence-to-sequence learning can even be applied to structured prediction tasks common in NLP where the output has a particular structure. For simplicity, the output is linearized as can be seen for constituency parsing in Figure 10 below. Neural networks have demonstrated the ability to directly learn to produce such a linearized output given sufficient amount of training data for constituency parsing (Vinyals et al, 2015)<a href="#fn46"></a>, and named entity recognition (Gillick et al., 2016)<a href="#fn47"></a>, among others.</p>
<figure>
    <center>
<img src="http://ruder.io/content/images/2018/09/vinyals_nips2015.png" width="450" alt="A Review of the Neural History of Natural Language Processing">
    <figcaption>Figure 10: Linearizing a constituency parse tree (Vinyals et al., 2015)</figcaption>
    </center>
</figure>
<p>Encoders for sequences and decoders are typically based on RNNs but other model types can be used. New architectures mainly emerge from work in MT, which acts as a Petri dish for sequence-to-sequence architectures. Recent models are deep LSTMs (Wu et al., 2016)<a href="#fn48"></a>, convolutional encoders (Kalchbrenner et al., 2016; Gehring et al., 2017)<a href="#fn35"></a><a href="#fn49"></a>, the Transformer (Vaswani et al., 2017)<a href="#fn50"></a>, which will be discussed in the next section, and a combination of an LSTM and a Transformer (Chen et al., 2018)<a href="#fn51"></a>.</p>
<h1 id="2015attention">2015 - Attention</h1>
<p>Attention (Bahdanau et al., 2015)<a href="#fn52"></a> is one of the core innovations in neural MT (NMT) and the key idea that enabled NMT models to outperform classic phrase-based MT systems. The main bottleneck of sequence-to-sequence learning is that it requires to compress the entire content of the source sequence into a fixed-size vector. Attention alleviates this by allowing the decoder to look back at the source sequence hidden states, which are then provided as a weighted average as additional input to the decoder as can be seen in Figure 11 below.</p>
<figure>
    <center>
<img src="http://ruder.io/content/images/2018/09/attention_bahdanau_iclr2015.png" width="250" alt="A Review of the Neural History of Natural Language Processing">
    <figcaption>Figure 11: Attention (Bahdanau et al., 2015)</figcaption>
    </center>
</figure>
<p>Different forms of attention are available (Luong et al., 2015)<a href="#fn53"></a>. Have a look <a href="http://ruder.io/deep-learning-nlp-best-practices/index.html#attention">here</a> for a brief overview. Attention is widely applicable and potentially useful for any task that requires making decisions based on certain parts of the input. It has been applied to consituency parsing (Vinyals et al., 2015)<a href="#fn46"></a>, reading comprehension (Hermann et al., 2015)<a href="#fn54"></a>, and one-shot learning (Vinyals et al., 2016)<a href="#fn56"></a>, among many others. The input does not even need to be a sequence, but can consist of other representations as in the case of image captioning (Xu et al., 2015)<a href="#fn55"></a>, which can be seen in Figure 12 below. A useful side-effect of attention is that it provides a rare---if only superficial---glimpse into the inner workings of the model by inspecting which parts of the input are relevant for a particular output based on the attention weights.</p>
<figure>
    <center>
<img src="http://ruder.io/content/images/2018/09/xu_icml2015.png" width="450" alt="A Review of the Neural History of Natural Language Processing">
    <figcaption>Figure 12: Visual attention in an image captioning model indicating what the model is attending to when generating the word "frisbee". (Xu et al., 2015)</figcaption>
    </center>
</figure>
<p>Attention is also not restricted to just looking at the input sequence; self-attention can be used to look at the surrounding words in a sentence or document to obtain more contextually sensitive word representations. Multiple layers of self-attention are at the core of the Transformer architecture (Vaswani et al., 2017)<a href="#fn50"></a>, the current state-of-the-art model for NMT.</p>
<h1 id="2015memorybasednetworks">2015 - Memory-based networks</h1>
<p>Attention can be seen as a form of fuzzy memory where the memory consists of the past hidden states of the model, with the model choosing what to retrieve from memory. For a more detailed overview of attention and its connection to memory, have a look at <a href="http://www.wildml.com/2016/01/attention-and-memory-in-deep-learning-and-nlp/">this post</a>. Many models with a more explicit memory have been proposed. They come in different variants such as Neural Turing Machines (Graves et al., 2014)<a href="#fn57"></a>, Memory Networks (Weston et al., 2015)<a href="#fn58"></a> and End-to-end Memory Networks (Sukhbaatar et al., 2015)<a href="#fn59"></a>, Dynamic Memory Networks (Kumar et al., 2015)<a href="#fn60"></a>, the Neural Differentiable Computer (Graves et al., 2016)<a href="#fn61"></a>, and the Recurrent Entity Network (Henaff et al., 2017)<a href="#fn62"></a>.</p>
<p>Memory is often accessed based on similarity to the current state similar to attention and can typically be written to and read from. Models differ in how they implement and leverage the memory. For instance, End-to-end Memory Networks process the input multiple times and update the memory to enable multiple steps of inference. Neural Turing Machines also have a location-based addressing, which allows them to learn simple computer programs like sorting. Memory-based models are typically applied to tasks, where retaining information over longer time spans should be useful such as language modelling and reading comprehension. The concept of a memory is very versatile: A knowledge base or table can function as a memory, while a memory can also be populated based on the entire input or particular parts of it.</p>
<h1 id="2018pretrainedlanguagemodels">2018 - Pretrained language models</h1>
<p>Pretrained word embeddings are context-agnostic and only used to initialize the first layer in our models. In recent months, a range of supervised tasks has been used to pretrain neural networks (Conneau et al., 2017; McCann et al., 2017; Subramanian et al., 2018)<a href="#fn65"></a><a href="#fn64"></a><a href="#fn66"></a>. In contrast, language models only require unlabelled text; training can thus scale to billions of tokens, new domains, and new languages. Pretrained language models were first proposed in 2015 (Dai &amp; Le, 2015)<a href="#fn67"></a>; only recently were they shown to be beneficial across a diverse range of tasks. Language model embeddings can be used as features in a target model (Peters et al., 2018)<a href="#fn68"></a> or a language model can be fine-tuned on target task data (Ramachandran et al., 2017; Howard &amp; Ruder, 2018)<a href="#fn94"></a><a href="#fn69"></a>. Adding language model embeddings gives a large improvement over the state-of-the-art across many different tasks as can be seen in Figure 13 below.</p>
<figure>
    <center>
<img src="http://ruder.io/content/images/2018/09/elmo_peters_2018.png" width="450" alt="A Review of the Neural History of Natural Language Processing">
    <figcaption>Figure 13: Improvements with language model embeddings over the state-of-the-art (Peters et al., 2018)</figcaption>
    </center>
</figure>
<p>Pretrained language models have been shown enable learning with significantly less data. As language models only require unlabelled data, they are particularly beneficial for low-resource languages where labelled data is scarce. For more information about the potential of pretrained language models, refer to <a href="https://thegradient.pub/nlp-imagenet/">this article</a>.</p>
<h1 id="othermilestones">Other milestones</h1>
<p>Some other developments are less pervasive than the ones mentioned above, but still have wide-ranging impact.</p>
<p><strong>Character-based representations</strong>   Using a CNN or an LSTM over characters to obtain a character-based word representation is now fairly common, particularly for morphologically rich languages and tasks where morphological information is important or that have many unknown words. Character-based representations were first used for part-of-speech tagging and language modeling (Ling et al., 2015)<a href="#fn109"></a> and dependency parsing (Ballesteros et al., 2015)<a href="#fn110"></a>. They later became a core component of models for sequence labeling (Lample et al., 2016; Plank et al., 2016)<a href="#fn70"></a><a href="#fn71"></a> and language modeling (Kim et al., 2016)<a href="#fn111"></a>. Character-based representations alleviate the need of having to deal with a fixed vocabulary at increased computational cost and enable applications such as fully character-based NMT (Ling et al., 2016; Lee et al., 2017)<a href="#fn72"></a><a href="#fn73"></a>.</p>
<p><strong>Adversarial learning</strong>   Adversarial methods have taken the field of ML by storm and have also been used in different forms in NLP. Adversarial examples are becoming increasingly widely used not only as a tool to probe models and understand their failure cases, but also to make them more robust (Jia &amp; Liang, 2017)<a href="#fn74"></a>. (Virtual) adversarial training, that is, worst-case perturbations (Miyato et al., 2017; Yasunaga et al., 2018)<a href="#fn75"></a><a href="#fn76"></a> and domain-adversarial losses (Ganin et al., 2016; Kim et al., 2017)<a href="#fn77"></a><a href="#fn78"></a> are useful forms of regularization that can equally make models more robust. Generative adversarial networks (GANs) are not yet too effective for natural language generation (Semeniuta et al., 2018)<a href="#fn79"></a>, but are useful for instance when matching distributions (Conneau et al., 2018)<a href="#fn27"></a>.</p>
<p><strong>Reinforcement learning</strong>   Reinforcement learning has been shown to be useful for tasks with a temporal dependency  such as selecting data during training (Fang et al., 2017; Wu et al., 2018)<a href="#fn80"></a><a href="#fn81"></a> and modelling dialogue (Liu et al., 2018)<a href="#fn86"></a>. RL is also effective for directly optimizing a non-differentiable end metric such as ROUGE or BLEU instead of optimizing a surrogate loss such as cross-entropy in summarization (Paulus et al, 2018; Celikyilmaz et al., 2018)<a href="#fn82"></a><a href="#fn83"></a> and machine translation (Ranzato et al., 2016)<a href="#fn84"></a>. Similarly, inverse reinforcement learning can be useful in settings where the reward is too complex to be specified such as visual storytelling (Wang et al., 2018)<a href="#fn85"></a>.</p>
<h1 id="nonneuralmilestones">Non-neural milestones</h1>
<p>In 1998 and over the following years, the <a href="https://framenet.icsi.berkeley.edu/fndrupal/">FrameNet</a> project was introduced (Baker et al., 1998)<a href="#fn95"></a>, which led to the task of <a href="https://en.wikipedia.org/wiki/Semantic_role_labeling">semantic role labelling</a>, a form of shallow semantic parsing that is still actively researched today. In the early 2000s, the shared tasks organized together with the Conference on Natural Language Learning (CoNLL) catalyzed research in core NLP tasks such as chunking (Tjong Kim Sang et al., 2000)<a href="#fn96"></a>, named entity recognition (Tjong Kim Sang et al., 2003)<a href="#fn97"></a>, and dependency parsing (Buchholz et al., 2006)<a href="#fn98"></a>, among others. Many of the CoNLL shared task datasets are still the standard for evaluation today.</p>
<p>In 2001, conditional random fields (CRF; Lafferty et al., 2001)<a href="#fn99"></a>, one of the most influential classes of sequence labelling methods were introduced, which won the <a href="https://www.ml.cmu.edu/news/news-archive/2011-2015/2011/june/icml-test-time-award-2011.html">Test-of-time award at ICML 2011</a>. A CRF layer is a core part of current state-of-the-art models for sequence labelling problems with label interdependencies such as named entity recognition (Lample et al., 2016)<a href="#fn70"></a>.</p>
<p>In 2002, the bilingual evaluation understudy (BLEU; Papineni et al., 2002)<a href="#fn100"></a> metric was proposed, which enabled MT systems to scale up and is still the standard metric for MT evaluation these days. In the same year, the structured preceptron (Collins, 2002)<a href="#fn101"></a> was introduced, which laid the foundation for work in structured perception. At the same conference, sentiment analysis, one of the most popular and widely studied NLP tasks, was introduced (Pang et al., 2002)<a href="#fn102"></a>. All three papers won the <a href="https://naacl2018.wordpress.com/2018/03/22/test-of-time-award-papers/">Test-of-time award at NAACL 2018</a>. In addition, the linguistic resource PropBank (Kingsbury &amp; Palmer, 2002)<a href="#fn113"></a> was introduced in the same year. PropBank is similar to FrameNet, but focuses on verbs. It is frequently used in semantic role labelling.</p>
<p>2003 saw the introduction of latent dirichlet allocation (LDA; Blei et al., 2003)<a href="#fn103"></a>, one of the most widely used techniques in machine learning, which is still the standard way to do topic modelling. In 2004, novel max-margin models were proposed that are better suited for capturing correlations in structured data than SVMs (Taskar et al., 2004a; 2004b)<a href="#fn104"></a><a href="#fn105"></a>.</p>
<p>In 2006, OntoNotes (Hovy et al., 2006)<a href="#fn106"></a>, a large multilingual corpus with multiple annotations and high interannotator agreement was introduced. OntoNotes has been used for the training and evaluation of a variety of tasks such as dependency parsing and coreference resolution. Milne and Witten (2008)<a href="#fn107"></a> described in 2008 how Wikipedia can be used to enrich machine learning methods. To this date, Wikipedia is one of the most useful resources for training ML methods, whether for entity linking and disambiguation, language modelling, as a knowledge base, or a variety of other tasks.</p>
<p>In 2009, the idea of distant supervision (Mintz et al., 2009)<a href="#fn108"></a> was proposed. Distant supervision leverages information from heuristics or existing knowledge bases to generate noisy patterns that can be used to automatically extract examples from large corpora. Distant supervision has been used extensively and is a common technique in relation extraction, information extraction, and sentiment analysis, among other tasks.</p>
<p>In 2016, Universal Dependencies v1 (Nivre et al., 2016)<a href="#fn114"></a>, a multilingual collection of treebanks, was introduced. The Universal Dependencies project is an open community effort that aims to create consistent dependency-based annotations across many languages. As of January 2019, <a href="https://universaldependencies.org/">Universal Dependencies v2</a> comprises more than 100 treebanks in over 70 languages.</p>
<h2 id="translations">Translations
<ul>
    <li><a href="https://iaml.it/blog/panoramica-storia-recente-nlp">Italian (by Luca Palmieri)</a></li>
</ul>
<p><em>Thanks to Djamé Seddah, Daniel Khashabi, Shyam Upadhyay, Chris Dyer, and Michael Roth for providing pointers (see <a href="https://twitter.com/seb_ruder/status/1046791863896887302">the Twitter thread</a>).</em></p>
<ol class="footnotes-list">
<li id="fn1" class="footnote-item">Kneser, R., & Ney, H. (1995, May). Improved backing-off for m-gram language modeling. In icassp (Vol. 1, p. 181e4).</li>
<li id="fn2" class="footnote-item">Kannan, A., Kurach, K., Ravi, S., Kaufmann, T., Tomkins, A., Miklos, B., ... & Ramavajjala, V. (2016, August). Smart reply: Automated response suggestion for email. In Proceedings of the 22nd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining (pp. 955-964). ACM.</li>
<li id="fn3" class="footnote-item">Bengio, Y., Ducharme, R., & Vincent, P. (2001). Proceedings of NIPS.</li>
<li id="fn4" class="footnote-item">Mikolov, T., Karafiát, M., Burget, L., Černocký, J., & Khudanpur, S. (2010). Recurrent neural network based language model. In Eleventh Annual Conference of the International Speech Communication Association.</li>
<li id="fn5" class="footnote-item">Graves, A. (2013). Generating sequences with recurrent neural networks. arXiv preprint arXiv:1308.0850.</li>
<li id="fn6" class="footnote-item">Melis, G., Dyer, C., & Blunsom, P. (2018). On the State of the Art of Evaluation in Neural Language Models. In Proceedings of ICLR 2018.</li>
<li id="fn7" class="footnote-item">Daniluk, M., Rocktäschel, T., Weibl, J., & Riedel, S. (2017). Frustratingly Short Attention Spans in Neural Language Modeling. In Proceedings of ICLR 2017.</li>
<li id="fn8" class="footnote-item">Caruana, R. (1993). Multitask learning: A knowledge-based source of inductive bias. In Proceedings of the Tenth International Conference on Machine Learning.</li>
<li id="fn9" class="footnote-item">Collobert, R., & Weston, J. (2008). A unified architecture for natural language processing. In Proceedings of the 25th International Conference on Machine Learning (pp. 160–167).</li>
<li id="fn10" class="footnote-item">Caruana, R. (1998). Multitask Learning. Autonomous Agents and Multi-Agent Systems, 27(1), 95–133.</li>
<li id="fn11" class="footnote-item">Collobert, R., Weston, J., Bottou, L., Karlen, M., Kavukcuoglu, K., & Kuksa, P. (2011). Natural Language Processing (almost) from Scratch. Journal of Machine Learning Research, 12(Aug), 2493–2537. Retrieved from http://arxiv.org/abs/1103.0398.</li>
<li id="fn12" class="footnote-item">Ruder, S., Bingel, J., Augenstein, I., & Søgaard, A. (2017). Learning what to share between loosely related tasks. ArXiv Preprint ArXiv:1705.08142. Retrieved from http://arxiv.org/abs/1705.08142</li>
<li id="fn13" class="footnote-item">Mikolov, T., Chen, K., Corrado, G., & Dean, J. (2013). Distributed Representations of Words and Phrases and their Compositionality. In Advances in Neural Information Processing Systems.</li>
<li id="fn14" class="footnote-item">Mikolov, T., Corrado, G., Chen, K., & Dean, J. (2013). Efficient Estimation of Word Representations in Vector Space. Proceedings of the International Conference on Learning Representations (ICLR 2013).</li>
<li id="fn15" class="footnote-item">Arora, S., Li, Y., Liang, Y., Ma, T., & Risteski, A. (2016). A Latent Variable Model Approach to PMI-based Word Embeddings. TACL, 4, 385–399.</li>
<li id="fn16" class="footnote-item">Mimno, D., & Thompson, L. (2017). The strange geometry of skip-gram with negative sampling. In Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing (pp. 2863–2868).</li>
<li id="fn17" class="footnote-item">Antoniak, M., & Mimno, D. (2018). Evaluating the Stability of Embedding-based Word Similarities. Transactions of the Association for Computational Linguistics, 6, 107–119.</li>
<li id="fn18" class="footnote-item">Wendlandt, L., Kummerfeld, J. K., & Mihalcea, R. (2018). Factors Influencing the Surprising Instability of Word Embeddings. In Proceedings of NAACL-HLT 2018.</li>
<li id="fn19" class="footnote-item">Kim, Y. (2014). Convolutional Neural Networks for Sentence Classification. Proceedings of the Conference on Empirical Methods in Natural Language Processing, 1746–1751. Retrieved from http://arxiv.org/abs/1408.5882</li>
<li id="fn20" class="footnote-item">Pennington, J., Socher, R., & Manning, C. D. (2014). Glove: Global Vectors for Word Representation. Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing, 1532–1543.</li>
<li id="fn21" class="footnote-item">Levy, O., & Goldberg, Y. (2014). Neural Word Embedding as Implicit Matrix Factorization. Advances in Neural Information Processing Systems (NIPS), 2177–2185. Retrieved from http://papers.nips.cc/paper/5477-neural-word-embedding-as-implicit-matrix-factorization</li>
<li id="fn22" class="footnote-item">Levy, O., Goldberg, Y., & Dagan, I. (2015). Improving Distributional Similarity with Lessons Learned from Word Embeddings. Transactions of the Association for Computational Linguistics, 3, 211–225. Retrieved from https://tacl2013.cs.columbia.edu/ojs/index.php/tacl/article/view/570</li>
<li id="fn23" class="footnote-item">Le, Q. V., & Mikolov, T. (2014). Distributed Representations of Sentences and Documents. International Conference on Machine Learning - ICML 2014, 32, 1188–1196. Retrieved from http://arxiv.org/abs/1405.4053</li>
<li id="fn24" class="footnote-item">Kiros, R., Zhu, Y., Salakhutdinov, R., Zemel, R. S., Torralba, A., Urtasun, R., & Fidler, S. (2015). Skip-Thought Vectors. In Proceedings of NIPS 2015. Retrieved from http://arxiv.org/abs/1506.06726</li>
<li id="fn25" class="footnote-item">Grover, A., & Leskovec, J. (2016, August). node2vec: Scalable feature learning for networks. In Proceedings of the 22nd ACM SIGKDD international conference on Knowledge discovery and data mining (pp. 855-864). ACM.</li>
<li id="fn26" class="footnote-item">Asgari, E., & Mofrad, M. R. (2015). Continuous distributed representation of biological sequences for deep proteomics and genomics. PloS one, 10(11), e0141287.</li>
<li id="fn27" class="footnote-item">Conneau, A., Lample, G., Ranzato, M., Denoyer, L., & Jégou, H. (2018). Word Translation Without Parallel Data. In Proceedings of ICLR 2018. Retrieved from http://arxiv.org/abs/1710.04087</li>
<li id="fn28" class="footnote-item">Artetxe, M., Labaka, G., & Agirre, E. (2018). A robust self-learning method for fully unsupervised cross-lingual mappings of word embeddings. In Proceedings of ACL 2018.</li>
<li id="fn29" class="footnote-item">Søgaard, A., Ruder, S., & Vulić, I. (2018). On the Limitations of Unsupervised Bilingual Dictionary Induction. In Proceedings of ACL 2018.</li>
<li id="fn30" class="footnote-item">Ruder, S., Vulić, I., & Søgaard, A. (2018). A Survey of Cross-lingual Word Embedding Models. To be published in Journal of Artificial Intelligence Research. Retrieved from http://arxiv.org/abs/1706.04902</li>
<li id="fn31" class="footnote-item">Elman, J. L. (1990). Finding structure in time. Cognitive science, 14(2), 179-211.</li>
<li id="fn32" class="footnote-item">Hochreiter, S., & Schmidhuber, J. (1997). Long short-term memory. Neural computation, 9(8), 1735-1780.</li>
<li id="fn33" class="footnote-item">Kalchbrenner, N., Grefenstette, E., & Blunsom, P. (2014). A Convolutional Neural Network for Modelling Sentences. In Proceedings of the 52nd Annual Meeting of the Association for Computational Linguistics (pp. 655–665). Retrieved from http://arxiv.org/abs/1404.2188</li>
<li id="fn34" class="footnote-item">Kim, Y. (2014). Convolutional Neural Networks for Sentence Classification. Proceedings of the Conference on Empirical Methods in Natural Language Processing, 1746–1751. Retrieved from http://arxiv.org/abs/1408.5882</li>
<li id="fn35" class="footnote-item">Kalchbrenner, N., Espeholt, L., Simonyan, K., Oord, A. van den, Graves, A., & Kavukcuoglu, K. (2016). Neural Machine Translation in Linear Time. ArXiv Preprint ArXiv: Retrieved from http://arxiv.org/abs/1610.10099</li>
<li id="fn36" class="footnote-item">Wang, J., Yu, L., Lai, K. R., & Zhang, X. (2016). Dimensional Sentiment Analysis Using a Regional CNN-LSTM Model. Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics (ACL 2016), 225–230.</li>
<li id="fn37" class="footnote-item">Bradbury, J., Merity, S., Xiong, C., & Socher, R. (2017). Quasi-Recurrent Neural Networks. In ICLR 2017. Retrieved from http://arxiv.org/abs/1611.01576</li>
<li id="fn38" class="footnote-item">Socher, R., Perelygin, A., & Wu, J. (2013). Recursive deep models for semantic compositionality over a sentiment treebank. Proceedings of the 2013 Conference on Empirical Methods in Natural Language Processing, 1631–1642.</li>
<li id="fn39" class="footnote-item">Tai, K. S., Socher, R., & Manning, C. D. (2015). Improved Semantic Representations From Tree-Structured Long Short-Term Memory Networks. Acl-2015, 1556–1566.</li>
<li id="fn40" class="footnote-item">Levy, O., & Goldberg, Y. (2014). Dependency-Based Word Embeddings. In Proceedings of the 52nd Annual Meeting of the Association for Computational Linguistics (Short Papers) (pp. 302–308). https://doi.org/10.3115/v1/P14-2050</li>
<li id="fn41" class="footnote-item">Dyer, C., Kuncoro, A., Ballesteros, M., & Smith, N. A. (2016). Recurrent Neural Network Grammars. In NAACL. Retrieved from http://arxiv.org/abs/1602.07776</li>
<li id="fn42" class="footnote-item">Bastings, J., Titov, I., Aziz, W., Marcheggiani, D., & Sima’an, K. (2017). Graph Convolutional Encoders for Syntax-aware Neural Machine Translation. In Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing.</li>
<li id="fn43" class="footnote-item">Vinyals, O., Toshev, A., Bengio, S., & Erhan, D. (2015). Show and tell: A neural image caption generator. In Proceedings of the IEEE conference on computer vision and pattern recognition (pp. 3156-3164).</li>
<li id="fn44" class="footnote-item">Lebret, R., Grangier, D., & Auli, M. (2016). Generating Text from Structured Data with Application to the Biography Domain. Proceedings of the 2016 Conference on Empirical Methods in Natural Language Processing. Retrieved from http://arxiv.org/abs/1603.07771</li>
<li id="fn45" class="footnote-item">Loyola, P., Marrese-Taylor, E., & Matsuo, Y. (2017). A Neural Architecture for Generating Natural Language Descriptions from Source Code Changes. In ACL 2017. Retrieved from http://arxiv.org/abs/1704.04856</li>
<li id="fn46" class="footnote-item">Vinyals, O., Kaiser, L., Koo, T., Petrov, S., Sutskever, I., & Hinton, G. (2015). Grammar as a Foreign Language. Advances in Neural Information Processing Systems.</li>
<li id="fn47" class="footnote-item">Gillick, D., Brunk, C., Vinyals, O., & Subramanya, A. (2016). Multilingual Language Processing From Bytes. In NAACL (pp. 1296–1306). Retrieved from http://arxiv.org/abs/1512.00103</li>
<li id="fn48" class="footnote-item">Wu, Y., Schuster, M., Chen, Z., Le, Q. V, Norouzi, M., Macherey, W., … Dean, J. (2016). Google’s Neural Machine Translation System: Bridging the Gap between Human and Machine Translation. ArXiv Preprint ArXiv:1609.08144.</li>
<li id="fn49" class="footnote-item">Gehring, J., Auli, M., Grangier, D., Yarats, D., & Dauphin, Y. N. (2017). Convolutional Sequence to Sequence Learning. ArXiv Preprint ArXiv:1705.03122. Retrieved from http://arxiv.org/abs/1705.03122</li>
<li id="fn50" class="footnote-item">Vaswani, A., Shazeer, N., Parmar, N., Uszkoreit, J., Jones, L., Gomez, A. N., … Polosukhin, I. (2017). Attention Is All You Need. In Advances in Neural Information Processing Systems.</li>
<li id="fn51" class="footnote-item">Chen, M. X., Foster, G., & Parmar, N. (2018). The Best of Both Worlds: Combining Recent Advances in Neural Machine Translation. In Proceedings of ACL 2018.</li>
<li id="fn52" class="footnote-item">Bahdanau, D., Cho, K., & Bengio, Y. (2015). Neural Machine Translation by Jointly Learning to Align and Translate. In ICLR 2015.</li>
<li id="fn53" class="footnote-item">Luong, M.-T., Pham, H., & Manning, C. D. (2015). Effective Approaches to Attention-based Neural Machine Translation. In Proceedings of EMNLP 2015. Retrieved from http://arxiv.org/abs/1508.04025</li>
<li id="fn54" class="footnote-item">Hermann, K. M., Kočiský, T., Grefenstette, E., Espeholt, L., Kay, W., Suleyman, M., & Blunsom, P. (2015). Teaching Machines to Read and Comprehend. Advances in Neural Information Processing Systems. Retrieved from http://arxiv.org/abs/1506.03340v1</li>
<li id="fn55" class="footnote-item">Xu, K., Courville, A., Zemel, R. S., & Bengio, Y. (2015). Show, Attend and Tell: Neural Image Caption Generation with Visual Attention. In Proceedings of ICML 2015.</li>
<li id="fn56" class="footnote-item">Vinyals, O., Blundell, C., Lillicrap, T., Kavukcuoglu, K., & Wierstra, D. (2016). Matching Networks for One Shot Learning. In Advances in Neural Information Processing Systems 29 (NIPS 2016). Retrieved from http://arxiv.org/abs/1606.04080</li>
<li id="fn57" class="footnote-item">Graves, A., Wayne, G., & Danihelka, I. (2014). Neural turing machines. arXiv preprint arXiv:1410.5401.</li>
<li id="fn58" class="footnote-item">Weston, J., Chopra, S., & Bordes, A. (2015). Memory Networks. In Proceedings of ICLR 2015.</li>
<li id="fn59" class="footnote-item">Sukhbaatar, S., Szlam, A., Weston, J., & Fergus, R. (2015). End-To-End Memory Networks. In Proceedings of NIPS 2015. Retrieved from http://arxiv.org/abs/1503.08895</li>
<li id="fn60" class="footnote-item">Kumar, A., Irsoy, O., Ondruska, P., Iyyer, M., Bradbury, J., Gulrajani, I., ... & Socher, R. (2016, June). Ask me anything: Dynamic memory networks for natural language processing. In International Conference on Machine Learning (pp. 1378-1387).</li>
<li id="fn61" class="footnote-item">Graves, A., Wayne, G., Reynolds, M., Harley, T., Danihelka, I., Grabska-Barwińska, A., … Hassabis, D. (2016). Hybrid computing using a neural network with dynamic external memory. Nature.</li>
<li id="fn62" class="footnote-item">Henaff, M., Weston, J., Szlam, A., Bordes, A., & LeCun, Y. (2017). Tracking the World State with Recurrent Entity Networks. In Proceedings of ICLR 2017.</li>
<li id="fn63" class="footnote-item">Sutskever, I., Vinyals, O., & Le, Q. V. (2014). Sequence to sequence learning with neural networks. In Advances in Neural Information Processing Systems.</li>
<li id="fn64" class="footnote-item">McCann, B., Bradbury, J., Xiong, C., & Socher, R. (2017). Learned in Translation: Contextualized Word Vectors. In Advances in Neural Information Processing Systems.</li>
<li id="fn65" class="footnote-item">Conneau, A., Kiela, D., Schwenk, H., Barrault, L., & Bordes, A. (2017). Supervised Learning of Universal Sentence Representations from Natural Language Inference Data. In Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing.</li>
<li id="fn66" class="footnote-item">Subramanian, S., Trischler, A., Bengio, Y., & Pal, C. J. (2018). Learning General Purpose Distributed Sentence Representations via Large Scale Multi-task Learning. In Proceedings of ICLR 2018.</li>
<li id="fn67" class="footnote-item">Dai, A. M., & Le, Q. V. (2015). Semi-supervised Sequence Learning. Advances in Neural Information Processing Systems (NIPS ’15). Retrieved from http://arxiv.org/abs/1511.01432</li>
<li id="fn68" class="footnote-item">Peters, M. E., Neumann, M., Iyyer, M., Gardner, M., Clark, C., Lee, K., & Zettlemoyer, L. (2018). Deep contextualized word representations. In Proceedings of NAACL-HLT 2018.</li>
<li id="fn69" class="footnote-item">Howard, J., & Ruder, S. (2018). Universal Language Model Fine-tuning for Text Classification. In Proceedings of ACL 2018. Retrieved from http://arxiv.org/abs/1801.06146</li>
<li id="fn70" class="footnote-item">Lample, G., Ballesteros, M., Subramanian, S., Kawakami, K., & Dyer, C. (2016). Neural Architectures for Named Entity Recognition. In NAACL-HLT 2016.</li>
<li id="fn71" class="footnote-item">Plank, B., Søgaard, A., & Goldberg, Y. (2016). Multilingual Part-of-Speech Tagging with Bidirectional Long Short-Term Memory Models and Auxiliary Loss. In Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics.</li>
<li id="fn72" class="footnote-item">Ling, W., Trancoso, I., Dyer, C., & Black, A. (2016). Character-based Neural Machine Translation. In ICLR. Retrieved from http://arxiv.org/abs/1511.04586</li>
<li id="fn73" class="footnote-item">Lee, J., Cho, K., & Bengio, Y. (2017). Fully Character-Level Neural Machine Translation without Explicit Segmentation. In Transactions of the Association for Computational Linguistics.</li>
<li id="fn74" class="footnote-item">Jia, R., & Liang, P. (2017). Adversarial Examples for Evaluating Reading Comprehension Systems. In Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing.</li>
<li id="fn75" class="footnote-item">Miyato, T., Dai, A. M., & Goodfellow, I. (2017). Adversarial Training Methods for Semi-supervised Text Classification. In Proceedings of ICLR 2017.</li>
<li id="fn76" class="footnote-item">Yasunaga, M., Kasai, J., & Radev, D. (2018). Robust Multilingual Part-of-Speech Tagging via Adversarial Training. In Proceedings of NAACL 2018. Retrieved from http://arxiv.org/abs/1711.04903</li>
<li id="fn77" class="footnote-item">Ganin, Y., Ustinova, E., Ajakan, H., Germain, P., Larochelle, H., Laviolette, F., … Lempitsky, V. (2016). Domain-Adversarial Training of Neural Networks. Journal of Machine Learning Research, 17.</li>
<li id="fn78" class="footnote-item">Kim, Y., Stratos, K., & Kim, D. (2017). Adversarial Adaptation of Synthetic or Stale Data. In Proceedings of ACL (pp. 1297–1307).</li>
<li id="fn79" class="footnote-item">Semeniuta, S., Severyn, A., & Gelly, S. (2018). On Accurate Evaluation of GANs for Language Generation. Retrieved from http://arxiv.org/abs/1806.04936</li>
<li id="fn80" class="footnote-item"><p>Fang, M., Li, Y., & Cohn, T. (2017). Learning how to Active Learn: A Deep Reinforcement Learning Approach. In Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing. Retrieved from https://arxiv.org/pdf/1708.02383v1.pdf</p>
</li>
<li id="fn81" class="footnote-item"><p>Wu, J., Li, L., & Wang, W. Y. (2018). Reinforced Co-Training. In Proceedings of NAACL-HLT 2018.</p>
</li>
<li id="fn82" class="footnote-item"><p>Paulus, R., Xiong, C., & Socher, R. (2018). A deep reinforced model for abstractive summarization. In Proceedings of ICLR 2018.</p></li>
<li id="fn83" class="footnote-item"><p>Celikyilmaz, A., Bosselut, A., He, X., & Choi, Y. (2018). Deep communicating agents for abstractive summarization. In Proceedings of NAACL-HLT 2018.</p></li>
<li id="fn84" class="footnote-item"><p>Ranzato, M. A., Chopra, S., Auli, M., & Zaremba, W. (2016). Sequence level training with recurrent neural networks. In Proceedings of ICLR 2016.</p></li>
<li id="fn85" class="footnote-item"><p>Wang, X., Chen, W., Wang, Y.-F., & Wang, W. Y. (2018). No Metrics Are Perfect: Adversarial Reward Learning for Visual Storytelling. In Proceedings of ACL 2018. Retrieved from http://arxiv.org/abs/1804.09160</p></li>
<li id="fn86" class="footnote-item">Liu, B., Tür, G., Hakkani-Tür, D., Shah, P., & Heck, L. (2018). Dialogue Learning with Human Teaching and Feedback in End-to-End Trainable Task-Oriented Dialogue Systems. In Proceedings of NAACL-HLT 2018.</li>
<li id="fn87" class="footnote-item">Kuncoro, A., Dyer, C., Hale, J., Yogatama, D., Clark, S., & Blunsom, P. (2018). LSTMs Can Learn Syntax-Sensitive Dependencies Well, But Modeling Structure Makes Them Better. In Proceedings of ACL 2018 (pp. 1–11). Retrieved from http://aclweb.org/anthology/P18-1132</li>
<li id="fn88" class="footnote-item">Blevins, T., Levy, O., & Zettlemoyer, L. (2018). Deep RNNs Encode Soft Hierarchical Syntax. In Proceedings of ACL 2018. Retrieved from http://arxiv.org/abs/1805.04218</li>
<li id="fn89" class="footnote-item">Wang, A., Singh, A., Michael, J., Hill, F., Levy, O., & Bowman, S. R. (2018). GLUE: A Multi-Task Benchmark and Analysis Platform for Natural Language Understanding.</li>
<li id="fn90" class="footnote-item">McCann, B., Keskar, N. S., Xiong, C., & Socher, R. (2018). The Natural Language Decathlon: Multitask Learning as Question Answering.</li>
<li id="fn91" class="footnote-item">Lample, G., Denoyer, L., & Ranzato, M. (2018). Unsupervised Machine Translation Using Monolingual Corpora Only. In Proceedings of ICLR 2018.</li>
<li id="fn92" class="footnote-item">Artetxe, M., Labaka, G., Agirre, E., & Cho, K. (2018). Unsupervised Neural Machine Translation. In Proceedings of ICLR 2018. Retrieved from http://arxiv.org/abs/1710.11041</li>
<li id="fn93" class="footnote-item">Graves, A., Jaitly, N., & Mohamed, A. R. (2013, December). Hybrid speech recognition with deep bidirectional LSTM. In Automatic Speech Recognition and Understanding (ASRU), 2013 IEEE Workshop on (pp. 273-278). IEEE.</li>
<li id="fn94" class="footnote-item">Ramachandran, P., Liu, P. J., & Le, Q. V. (2017). Unsupervised Pretraining for Sequence to Sequence Learning. In Proceedings of EMNLP 2017.</li>
<li id="fn95" class="footnote-item">Baker, C. F., Fillmore, C. J., & Lowe, J. B. (1998, August). The berkeley framenet project. In Proceedings of the 17th international conference on Computational linguistics-Volume 1 (pp. 86-90). Association for Computational Linguistics.</li>
<li id="fn96" class="footnote-item">Tjong Kim Sang, E. F., & Buchholz, S. (2000, September). Introduction to the CoNLL-2000 shared task: Chunking. In Proceedings of the 2nd workshop on Learning language in logic and the 4th conference on Computational natural language learning-Volume 7 (pp. 127-132). Association for Computational Linguistics.</li>
<li id="fn97" class="footnote-item">Tjong Kim Sang, E. F., & De Meulder, F. (2003, May). Introduction to the CoNLL-2003 shared task: Language-independent named entity recognition. In Proceedings of the seventh conference on Natural language learning at HLT-NAACL 2003-Volume 4 (pp. 142-147). Association for Computational Linguistics.</li>
<li id="fn98" class="footnote-item">Buchholz, S., & Marsi, E. (2006, June). CoNLL-X shared task on multilingual dependency parsing. In Proceedings of the tenth conference on computational natural language learning (pp. 149-164). Association for Computational Linguistics.</li>
<li id="fn99" class="footnote-item">Lafferty, J., McCallum, A., & Pereira, F. C. (2001). Conditional random fields: Probabilistic models for segmenting and labeling sequence data.</li>
<li id="fn100" class="footnote-item">Papineni, K., Roukos, S., Ward, T., & Zhu, W. J. (2002, July). BLEU: a method for automatic evaluation of machine translation. In Proceedings of the 40th annual meeting on association for computational linguistics (pp. 311-318). Association for Computational Linguistics.</li>
<li id="fn101" class="footnote-item">Collins, M. (2002, July). Discriminative training methods for hidden markov models: Theory and experiments with perceptron algorithms. In Proceedings of the ACL-02 conference on Empirical methods in natural language processing-Volume 10 (pp. 1-8). Association for Computational Linguistics.</li>
<li id="fn102" class="footnote-item">Pang, B., Lee, L., & Vaithyanathan, S. (2002, July). Thumbs up?: sentiment classification using machine learning techniques. In Proceedings of the ACL-02 conference on Empirical methods in natural language processing-Volume 10 (pp. 79-86). Association for Computational Linguistics.</li>
<li id="fn103" class="footnote-item">Blei, D. M., Ng, A. Y., & Jordan, M. I. (2003). Latent dirichlet allocation. Journal of machine Learning research, 3(Jan), 993-1022.</li>
<li id="fn104" class="footnote-item">Taskar, B., Guestrin, C., & Koller, D. (2004). Max-margin Markov networks. In Advances in neural information processing systems (pp. 25-32).</li>
<li id="fn105" class="footnote-item">Taskar, B., Klein, D., Collins, M., Koller, D., & Manning, C. (2004). Max-margin parsing. In Proceedings of the 2004 Conference on Empirical Methods in Natural Language Processing.</li>
<li id="fn106" class="footnote-item">Hovy, E., Marcus, M., Palmer, M., Ramshaw, L., & Weischedel, R. (2006, June). OntoNotes: the 90% solution. In Proceedings of the human language technology conference of the NAACL, Companion Volume: Short Papers (pp. 57-60). Association for Computational Linguistics.</li>
<li id="fn107" class="footnote-item">Milne, D., & Witten, I. H. (2008, October). Learning to link with wikipedia. In Proceedings of the 17th ACM conference on Information and knowledge management (pp. 509-518). ACM.</li>
<li id="fn108" class="footnote-item">Mintz, M., Bills, S., Snow, R., & Jurafsky, D. (2009, August). Distant supervision for relation extraction without labeled data. In Proceedings of the Joint Conference of the 47th Annual Meeting of the ACL and the 4th International Joint Conference on Natural Language Processing of the AFNLP: Volume 2-Volume 2 (pp. 1003-1011). Association for Computational Linguistics.</li>
<li id="fn109" class="footnote-item">Ling, W., Luis, T., Marujo, L., Astudillo, R. F., Amir, S., Dyer, C., … Trancoso, I. (2015). Finding Function in Form: Compositional Character Models for Open Vocabulary Word Representation. In Proceedings of EMNLP 2015 (pp. 1520–1530).</li>
<li id="fn110" class="footnote-item">Ballesteros, M., Dyer, C., & Smith, N. A. (2015). Improved Transition-Based Parsing by Modeling Characters instead of Words with LSTMs. In Proceedings of EMNLP 2015.</li>
<li id="fn111" class="footnote-item">Kim, Y., Jernite, Y., Sontag, D., & Rush, A. M. (2016). Character-Aware Neural Language Models. In Proceedings of AAAI 2016</li>
<li id="fn112" class="footnote-item">Bolukbasi, T., Chang, K.-W., Zou, J., Saligrama, V., & Kalai, A. (2016). Man is to Computer Programmer as Woman is to Homemaker? Debiasing Word Embeddings. In 30th Conference on Neural Information Processing Systems (NIPS 2016).</li>
<li id="fn113" class="footnote-item">Kingsbury, P., & Palmer, M. (2002, May). From TreeBank to PropBank. In LREC (pp. 1989-1993).</li>
<li id="fn114" class="footnote-item">Nivre, J., De Marneffe, M. C., Ginter, F., Goldberg, Y., Hajic, J., Manning, C. D., ... & Tsarfaty, R. (2016, May). Universal Dependencies v1: A Multilingual Treebank Collection. In LREC.</li>
</ol><!--kg-card-end: markdown--><!--kg-card-end: markdown--></h2>]]></content:encoded></item><item><title><![CDATA[ACL 2018 Highlights: Understanding Representations and Evaluation in More Challenging Settings]]></title><description><![CDATA[This post discusses highlights of the 56th Annual Meeting of the Association for Computational Linguistics (ACL 2018). It focuses on understanding representations and evaluating in more challenging scenarios.]]></description><link>http://ruder.io/acl-2018-highlights/</link><guid isPermaLink="false">5c76ff7c1b9b0d18555b9ead</guid><category><![CDATA[natural language processing]]></category><category><![CDATA[events]]></category><category><![CDATA[transfer learning]]></category><category><![CDATA[reinforcement learning]]></category><dc:creator><![CDATA[Sebastian Ruder]]></dc:creator><pubDate>Thu, 26 Jul 2018 11:00:00 GMT</pubDate><media:content url="http://ruder.io/content/images/2018/07/view_out_of_conference_venue-2.jpg" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><!--kg-card-begin: markdown--><img src="http://ruder.io/content/images/2018/07/view_out_of_conference_venue-2.jpg" alt="ACL 2018 Highlights: Understanding Representations and Evaluation in More Challenging Settings"><p>This post discusses highlights of the 56th Annual Meeting of the Association for Computational Linguistics (ACL 2018).</p>
<p><em>This post originally appeared at the <a href="http://blog.aylien.com/acl-2018-highlights-understanding-representations-and-evaluation-in-more-challenging-settings/">AYLIEN blog</a>.</em></p>
<p>I attended the <a href="https://acl2018.org/">56th Annual Meeting of the Association for Computational Linguistics (ACL 2018)</a> in Melbourne, Australia from July 15-20, 2018 and presented three papers <a href="#fn25"></a><a href="#fn38"></a><a href="#fn26"></a>. It is foolhardy to try to condense an entire conference into one topic; however, in retrospect, certain themes appear particularly pronounced. In 2015 and 2016, NLP conferences were dominated by word embeddings and some people were musing that <a href="http://ruder.io/word-embeddings-1/"><em>Embedding Methods in Natural Language Processing</em></a> was a more appropriate name for the Conference on <a href="http://emnlp2018.org/"><em>Empirical Methods in Natural Language Processing</em></a>, one of the top conferences in the field.</p>
<p><a href="https://nlp.stanford.edu/manning/talks/Simons-Institute-Manning-2017.pdf">According to Chris Manning</a>, 2017 was the year of the BiLSTM with attention. While BiLSTMs optionally with attention are still ubiquitous, the main themes of this conference for me were to <em>gain a better understanding</em> what the representations of such models capture and to expose them to <em>more challenging settings</em>. In my review, I will mainly focus on contributions that touch on these themes but will also discuss other themes that I found of interest.</p>
<h1 id="understandingrepresentations">Understanding Representations</h1>
<h2>Probing models</h2>
<p>It was very refreshing to see that rather than introducing ever shinier new models, many papers methodically investigated existing models and what they capture. This was most commonly done by automatically creating a dataset that focuses on one particular aspect of the generalization behaviour and evaluating different trained models on this dataset:</p>
<ul>
<li> Conneau et al.<a href="#fn11"></a> for instance evaluate different sentence embedding methods on ten datasets designed to capture certain linguistic features, such as predicting the length of a sentence, recovering word content, sensitivity to bigram shift, etc. They find that different encoder architectures can result in embeddings with different characteristics and that bag-of-embeddings is surprisingly good at capturing sentence-level properties, among other results.</li>
<li> Zhu et al.<a href="#fn9"></a> evaluate sentence embeddings by observing the change in similarity of generated triplets of sentences that differ in a certain semantic or syntactic aspect. They find---among other things---that SkipThought and InferSent can distinguish negation from synonymy, while InferSent is better at identifying semantic equivalence and dealing with quantifiers.</li>
<li> Pezzelle et al.<a href="#fn10"></a> focus specifically on quantifiers and test different CNN and LSTM models on their ability to predict quantifiers in single-sentence and multi-sentence contexts. They find that in single-sentence context, models outperform humans, while humans are slightly better in multi-sentence contexts.</li>
<li> Kuncoro et al.<a href="#fn12"></a> evaluate LSTMs on modeling subject-verb agreement. They find that with enough capacity, LSTMs can model subject-verb agreement, but that more syntax-sensitive models such as recurrent neural network grammars do even better.</li>
<li> Blevins et al.<a href="#fn24"></a> evaluate models pretrained on different tasks whether they capture a hierarchical notion of syntax. Specifically, they train the models to predict POS tags as well as constituent labels at different depths of a parse tree. They find that all models indeed encode a significant amount of syntax and---in particular---that language models learn some syntax.</li>
<li> Khandelwal et al.<a href="#fn42"></a> show that LSTM language models use about 200 tokens of context on average. Word order is only relevant within the most recent sentence.
</li><li> Another interesting result regarding the generalization ability of language models is due to Lau et al.<a href="#fn16"></a> who find that a language model trained on a sonnet corpus captures meter implicitly at human-level performance.</li>
<li> Language models, however, also have their limitations. Spithourakis and Riedel<a href="#fn23"></a> observe that language models are bad at modelling numerals and propose several strategies to improve them.</li>
<li> Liu et al.<a href="#fn37"></a> show that LSTMs trained on natural language data are able to recall tokens from much longer sequence than models trained on non-language data at the Repl4NLP workshop.</li>
</ul>
<p>In particular, I think better understanding what information LSTMs and language models will become more important, as they seem to be a key driver of progress in NLP going forward, as evidenced by our ACL paper on language model fine-tuning<a href="#fn38"></a> and <a href="http://ruder.io/nlp-imagenet/">related approaches</a>.</p>
<h2 id="understandingstateoftheartmodels">Understanding state-of-the-art models</h2>
<p>While the above studies try to understand a specific aspect of the generalization ability of a particular model class, several papers focus on better understanding state-of-the-art models for a particular task:</p>
<ul>
<li> Glockner et al.<a href="#fn8"></a> focused on the task of natural language inference. They created a dataset with sentences that differ by at most one word from sentences in the training data in order to probe if models can deal with simple lexical inferences. They find that current state-of-the-art models fail to capture many simple inferences.</li>
<li> Mudrakarta et al.<a href="#fn22"></a> analyse state-of-the-art QA models across different modalities and find that the models often ignore key question terms. They then perturb questions to craft adversarial examples that significantly lower models' accuracy.</li>
</ul>
I found many of the papers probing different aspects of models stimulating. I hope that the generation of such probing datasets will become a standard tool in the toolkit of every NLP researchers so that we will not only see more of such papers in the future but that such an analysis may also become part of the standard model evaluation, besides error and ablation analyses.
<h2 id="analyzingtheinductivebias">Analyzing the inductive bias</h2>
<p>Another way to gain a better understanding of a model is to analyze its inductive bias. The <a href="https://sites.google.com/view/relsnnlp">Workshop on Relevance of Linguistic Structure in Neural Architectures for NLP (RELNLP)</a> sought to explore how useful it is to incorporate linguistic structure into our models. One of the key points of Chris Dyer's talk during the workshop was whether RNNs have a useful inductive bias for NLP. In particular, he argued that there are several pieces of evidence indicating that RNNs prefer sequential recency, namely:</p>
<ol>
<li> Gradients become attenuated across time. LSTMs or GRUs may help with this, but they also forget.</li>
<li> People have used training regimes like reversing the input sequence for machine translation.</li>
<li> People have used enhancements like attention to have direct connections back in time.</li>
<li> For modeling subject-verb agreement, the error rate increases with the number of attractors<a href="#fn29"></a>.</li>
</ol>
<p>According to Chomsky, sequential recency is not the right bias for learning human language. RNNs thus don't seem to have the right bias for modeling language, which in practice can lead to statistical inefficiency and poor generalization behaviour. Recurrent neural network grammars<a href="#fn30"></a>, a class of models that generates both a tree and a sequence sequentially by compressing a sentence into its constituents, instead have a bias for syntactic (rather than sequential) recency.</p>
<p>However, it can often be hard to identify whether a model has a useful inductive bias. For identifying subject-verb agreement, Chris hypothesizes that LSTM language models learn a non-structural &quot;first noun&quot; heuristic that relies on matching the verb to the first noun in the sentence. In general, perplexity (and other aggregate metrics) are correlated with syntactic/structural competence, but are not particularly sensitive at distinguishing structurally sensitive models from models that use a simpler heuristic.</p>
<h2>Using Deep Learning to understand language</h2>
<p>In his talk at the workshop, Mark Johnson opined that while Deep Learning has revolutionized NLP, its primary benefit is economic: complex component pipelines have been replaced with end-to-end models and target accuracy can often be achieved more quickly and cheaply. Deep Learning has not changed our understanding of language. Its main contribution in this regard is to demonstrate that a neural network aka a computational model can perform certain NLP tasks, which shows that these tasks are not indicators of intelligence. While DL methods can pattern match and perform perceptual tasks really well, they struggle with tasks relying on deliberate reflection and conscious thought.</p>
<h2>Incorporating linguistic structure</h2>
<p>Jason Eisner questioned in his talk whether linguistic structures and categories actually exist or whether &quot;scientist just like to organize data into piles&quot; given that a linguistics-free approach works surprisingly well for MT. He finds that even &quot;arbitrarily defined&quot; categories such as the difference between the /b/ and /p/ phonemes can become hardened and accrue meaning. However, neural models are pretty good sponges to soak up whatever isn't modeled explicitly.</p>
<p>He outlines four common ways to introduce linguistic information into models: a) via a pipeline-based approach, where linguistic categories are used as features; b) via data augmentation, where the data is augmented with linguistic categories; c) via multi-task learning; d) via structured modeling such as using a transition-based parser, a recurrent neural network grammar, or even classes that depend on each other such as BIO notation.</p>
<p>In her talk at the workshop, Emily Bender questioned the premise of linguistics-free learning altogether: Even if you had a huge corpus in a language that you knew nothing about, without any other priors, e.g. what function words are, you would not be able to learn sentence structure or meaning. She also pointedly called out many ML papers that describe their approach as similar to how babies learn, without citing any actual developmental psychology or language acquisition literature. Babies in fact learn in situated, joint, emotional context, which carries a lot of signal and meaning.</p>
<h2>Understanding the failure modes of LSTMs</h2>
<p>Better understanding representations was also a theme at the <a href="https://sites.google.com/site/repl4nlp2018/
">Representation Learning for NLP workshop</a>. During his talk, Yoav Goldberg detailed some of the efforts of his group to better understand representations of RNNs. In particular, he discussed recent work on extracting a finite state automaton from an RNN in order to better understand what the model has learned<a href="#fn35"></a>. He also reminded the audience that LSTM representations, even though they have been trained on one task, are not task-specific. They are often predictive of unintended aspects such as demographics in the data. Even when a model has been trained using a domain-adversarial loss to produce representations that are invariant of a certain aspect, the representations will be still slightly predictive of said attribute. It can thus be a challenge to completely remove unwanted information from encoded language data and even seemingly perfect LSTM models may have hidden failure modes.</p>
<p>On the topic of failure modes of LSTMs, a statement that also fits well in this theme was uttered by this year's recipient of the ACL lifetime achievement award, Mark Steedman. He asked <em>&quot;LSTMs work in practice, but can they work in theory?&quot;</em>.</p>
<h1 id="">Evaluation in more challenging settings</h1>
<h2>Adversarial examples</h2>
<p>A theme that is closely interlinked with gaining a better understanding of the limitations of state-of-the-art models is to propose ways how they can be improved. In particular, similar to adversarial example paper mentioned above<a href="#fn22"></a>, several papers tried to make models more robust to adversarial examples:</p>
<ul>
<li> Cheng et al.
<a href="#fn21"></a> propose to make both the encoder and decoder in NMT models more robust against input perturbations.</li>
<li> Ebrahimi et al.<a href="#fn28"></a> propose white-box adversarial examples to trick a character-level neural classifier by swapping few tokens.</li>
<li> Ribeiro et al.<a href="#fn13"></a> improve upon the previous method with semantic-preserving perturbations that induce changes in the model's predictions, which they generalize to rules that induce adversaries on many instances.</li>
<li> Bose et al.<a href="#fn41"></a> incorporate adversarial examples into noise contrastive estimation using an adversarially learned sampler. The sampler finds harder negative examples, which forces the model to learn better representations.</li>
</ul>
<h2>Learning robust and fair representations</h2>
<p>Tim Baldwin discussed different ways to make models more robust to a domain shift during his talk at the <a href="https://sites.google.com/site/repl4nlp2018/
">RepL4NLP workshop</a>. The slides can be found <a href="https://drive.google.com/file/d/1JhZKKCJjIDIqZdwRL0GEUcrWxscLS87l/view">here</a>. For using a single source domain, he discussed a method to linguistically perturb training instances based on different types of syntactic and semantic noise<a href="#fn32"></a>. In the setting with multiple source domains, he proposed to train an adversarial model on the source domains<a href="#fn33"></a>. Finally, he discussed a method that allows to learn robust and privacy-preserving text representations<a href="#fn34"></a>.</p>
<p>Margaret Mitchell focused on fair and privacy-preserving representations during her talk at the workshop. In particular, she highlighted the difference between a descriptive and a normative view of the world. ML models learn representations that reflect a descriptive view of the data they're trained on. The data represents &quot;the world as people talk about it&quot;. Research in fairness conversely seeks to create representations that reflect a normative view of the world, which captures our values and seeks to instill them in the representations.</p>
<h2>Improving evaluation methodology</h2>
<p>Besides making models more robust, several papers sought to improve the way we evaluate our models:</p>
<ul>
<li> Finegan-Dollak et al.<a href="#fn18"></a> identify limitations and propose improvements to current evaluations of text-to-SQL systems. They show that the current train-test split and practice of anonymization of variables are flawed and release standardized and improved versions of seven datasets to mitigate these.</li>
<li> Dror et al.<a href="#fn14"></a> focus on a practice that should be commonplace, but is often not done or done poorly: statistical significance testing. In particular, they survey recent empirical papers in ACL and TACL 2017 finding that statistical significance testing is often ignored or misused and propose a simple protocol for statistical significance test selection for NLP tasks.</li>
<li> Chaganty et al.<a href="#fn17"></a> investigate the bias of automatic metrics such as BLEU and ROUGE and find that even an unbiased estimator only achieves a comparatively low error reduction. This highlights the need to improve both the correlation of automatic metric as well as reduce the variance of human annotation.</li>
</ul>
<h2>Strong baselines</h2>
<p>Another way to improve model evaluation is to compare new models against stronger baselines, in order to make sure that improvements are actually significant. Some papers focused on this line of research:</p>
<ul>
<li> Shen et al.<a href="#fn19"></a> systematically compare simple word embedding-based methods with pooling to more complex models such as LSTMs and CNNs. They find that for most datasets, word embedding-based methods exhibit competitive or even superior performance.</li>
<li> Ethayarajh<a href="#fn36"></a> proposes a strong baseline for sentence embedding models at the RepL4NLP workshop.</li>
<li> In a similar vein, Ruder and Plank<a href="#fn25"></a> find that classic bootstrapping algorithms such as tri-training make for strong baselines for semi-supervised learning and even outperform recent state-of-the-art methods.</li>
</ul>
In the above paper, we also emphasize the importance of evaluating in more challenging settings, such as on out-of-distribution data and on different tasks. Our findings would have been different if we had just focused on a single task or only on in-domain data. We need to test our models under such adverse conditions to get a better sense of their robustness and how well they can actually generalize.
<h2>Creating harder datasets</h2>
<p>In order to evaluate under such settings, more challenging datasets need to be created. Yejin Choi argued during the RepL4NLP panel discussion (a summary can be found <a href="https://twitter.com/seb_ruder/status/1020196710050455554">here</a>) that the community pays a lot of attention to easier tasks such as SQuAD or bAbI, which are close to solved. Yoav Goldberg even went so far as to say that &quot;SQuAD is the MNIST of NLP&quot;. Instead, we should focus on solving harder tasks and develop more datasets with increasing levels of difficulty. If a dataset is too hard, people don't work on it. In particular, the community should not work on datasets for too long as datasets are getting solved very fast these days; creating novel and more challenging datasets is thus even more important. Two datasets that seek to go beyond SQuAD for reading comprehension were presented at the conference:</p>
<ul>
<li> <a href="http://qangaroo.cs.ucl.ac.uk/">QAngaroo</a><a href="#fn39"></a> focuses on reading comprehension that requires to gather several pieces of information via multiple steps of inference.</li>
<li> <a href="https://github.com/deepmind/narrativeqa">NarrativeQA</a><a href="#fn40"></a> requires understand of an underlying narrative by asking the reader to answer questions about stories by reading entire books or movie scripts.</li>
</ul>
<p>Richard Socher also stressed the importance of training and evaluating a model across multiple tasks during <a href="https://twitter.com/RichardSocher/status/1021917140801052672">his talk</a> during the <a href="https://mrqa2018.github.io/">Machine Reading for Question Answering workshop</a>. In particular, he argues that NLP requires many types of reasoning, e.g. logical, linguistic, emotional, etc., which cannot all be satisfied by a single task.</p>
<h2>Evaluation on multiple and low-resource languages</h2>
<p>Another facet of this is to evaluate our models on multiple languages. Emily Bender surveyed 50 NAACL 2018 papers in her talk mentioned above and found that 42 papers evaluate on an unnamed mystery language (i.e. English). She emphasizes that it is important to name the language you work on as languages have different linguistic structures; not mentioning the language obfuscates this fact.</p>
<p>If our methods are designed to be cross-lingual, then we should additionally evaluate them on the more challenging setting of low-resource languages. For instance, both of the following two papers observe that current methods for unsupervised bilingual dictionary methods fail if the target language is dissimilar to language such as with Estonian or Finnish:</p>
<ul>
<li> Søgaard et al.<a href="#fn26"></a> probe the limitations of current methods further and highlight that such methods also fail when embeddings are trained on different domains or using different algorithms. They finally propose a metric to quantify the potential of such methods.</li>
<li> Artetxe et al.<a href="#fn27"></a> propose a new unsupervised self-training method that employs a better initialization to steer the optimization process and is particularly robust for dissimilar language pairs.</li>
</ul>
<p>Several other papers also evaluate their approaches on low-resource languages:</p>
<ul>
<li> Dror et al.<a href="#fn15"></a> propose to use orthographic features for bilingual lexicon induction. Though these mostly help for related languages, they also evaluate on the dissimilar language pair English-Finnish.</li>
<li> Ren et al.<a href="#fn20"></a> finally propose to leverage another rich language for translation into a resource-poor language
. They find that their model significantly improves the translation quality of rare languages.</li>
<li> Currey and Heafield<a href="#fn31"></a> propose an unsupervised tree-to-sequence model for NMT by adapting the Gumbel tree-LSTM. Their model proves particularly useful for low-resource languages.</li>
</ul>
<h1 id="">Progress in NLP</h1>
<p>Another theme during the conference for me was that the field is visibly making progress. Marti Hearst, president of the ACL, echoed this sentiment during her presidential address. She used to demonstrate what our models can and can't do using the example of Stanley Kubrick's HAL 9000 (seen below). In recent years, this has become a less useful exercise as our models have learned to perform tasks that seemed previously decades away such as recognizing and producing human speech or lipreading<a href="#fn7">[1]</a>. Naturally, we are still far away from tasks that require deep language understanding and reasoning such as having an argument; nevertheless, this progress is remarkable.</p>
<figure>
    <center>
<img src="http://ruder.io/content/images/2018/07/hal9000.png" width="150" alt="ACL 2018 Highlights: Understanding Representations and Evaluation in More Challenging Settings">
    <figcaption>Hal 9000. (Source: <a href="https://creativecommons.org/licenses/by/3.0" title="Creative Commons Attribution 3.0">CC BY 3.0</a>, <a href="https://commons.wikimedia.org/w/index.php?curid=11651154">Wikimedia</a>)</figcaption>
    </center>
</figure>
<p>Marti also paraphrased NLP and IR pioneer Karen Spärck Jones saying that research is not going around in circles, but climbing a spiral or---maybe more fittingly---different staircases that are not necessarily linked but go in the same direction. She also expressed a sentiment that seems to resonate with a lot of people: In the 1980s and 90s, with only a few papers to read, it was definitely easier to keep track of the state of the art. To make this easier, I have  recently created a document to collect the <a href="http://nlpprogress.com/">state of the art across different NLP tasks</a>.</p>
<p>With the community growing, she encouraged people to participate and volunteer and announced an ACL Distinguished Service Award for the most dedicated members. ACL 2018 also saw the launch (after EACL in 1982 and NAACL in 2000) of its third chapter, AACL, the <a href="http://aaclweb.org/">Asia-Pacific Chapter of the Association for Computational Linguistics</a>.</p>
<p>The business meeting during the conference focused on measures to address a particular challenge of the growing community: the escalating number of submissions and the need for more reviewers. We can expect to see new efforts to deal with the large number of submissions at the conferences next year.</p>
<h1 id="reinforcementlearning">Reinforcement learning</h1>
<p><a href="http://ruder.io/emnlp-2016-highlights/">Back in 2016</a>, it seemed as though reinforcement learning (RL) was finding its footing in NLP and being applied to more and more tasks. These days, it seems that the dynamic nature of RL makes it most useful for tasks that intrinsically have some temporal dependency such as selecting data during training<a href="#fn1">[1]</a><a href="#fn2">[1]</a> and modelling dialogue, while supervised learning seems to be better suited for most other tasks. Another important application of RL is to optimize the end metric such as ROUGE or BLEU directly instead of optimizing a surrogate loss such as cross-entropy. Successful applications of this are summarization<a href="#fn3">[1]</a><a href="#fn4">[1]</a> and machine translation<a href="#fn5">[1]</a>.</p>
<p>Inverse reinforcement learning can be valuable in settings where the reward is too complex to be specified. A successful application of this is visual storytelling<a href="#fn6">[1]</a>. RL is particularly promising for sequential decision making problems in NLP such as playing text-based games, navigating webpages, and completing tasks. The <a href="https://www.cs.ucsb.edu/~william/papers/ACL2018DRL4NLP.pdf">Deep Reinforcement Learning for NLP tutorial</a> provided a comprehensive overview of the space.</p>
<h1 id="">Tutorials</h1>
<p>There were other great tutorials as well. I particularly enjoyed the <a href="https://github.com/philschulz/VITutorial">Variational Inference and Deep Generative Models tutorial</a>. The tutorials on <a href="https://github.com/allenai/acl2018-semantic-parsing-tutorial">Semantic Parsing</a> and about <a href="http://faculty.washington.edu/ebender/100things-sem_prag.html">&quot;100 things you always wanted to know about semantics &amp; pragmatics&quot;</a> also seemed really worthwhile. A complete list of the tutorials can be found <a href="https://acl2018.org/tutorials/">here</a>.</p>
<p><em>Cover image: View from the conference venue.</em></p>
<p><em>Thanks to <a href="http://isabelleaugenstein.github.io/">Isabelle Augenstein</a> for some paper suggestions.</em></p>
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>Fang, M., Li, Y., & Cohn, T. (2017). Learning how to Active Learn: A Deep Reinforcement Learning Approach. In Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing. Retrieved from https://arxiv.org/pdf/1708.02383v1.pdf</p>
</li>
<li id="fn2" class="footnote-item"><p>Wu, J., Li, L., & Wang, W. Y. (2018). Reinforced Co-Training. In Proceedings of NAACL-HLT 2018.</p>
</li>
<li id="fn3" class="footnote-item"><p>Paulus, R., Xiong, C., & Socher, R. (2018). A deep reinforced model for abstractive summarization. In Proceedings of ICLR 2018.</p></li>
<li id="fn4" class="footnote-item"><p>Celikyilmaz, A., Bosselut, A., He, X., & Choi, Y. (2018). Deep communicating agents for abstractive summarization. In Proceedings of NAACL-HLT 2018.</p></li>
<li id="fn5" class="footnote-item"><p>Ranzato, M. A., Chopra, S., Auli, M., & Zaremba, W. (2016). Sequence level training with recurrent neural networks. In Proceedings of ICLR 2016.</p></li>
<li id="fn6" class="footnote-item"><p>Wang, X., Chen, W., Wang, Y.-F., & Wang, W. Y. (2018). No Metrics Are Perfect: Adversarial Reward Learning for Visual Storytelling. In Proceedings of ACL 2018. Retrieved from http://arxiv.org/abs/1804.09160</p></li>
<li id="fn7" class="footnote-item"><p>Chung, J. S., & Zisserman, A. (2016, November). Lip reading in the wild. In Asian Conference on Computer Vision (pp. 87-103). Springer, Cham.</p></li>
<li id="fn8" class="footnote-item"><p>Glockner, M., Shwartz, V., & Goldberg, Y. (2018). Breaking NLI Systems with Sentences that Require Simple Lexical Inferences. In Proceedings of ACL 2018. Retrieved from http://arxiv.org/abs/1805.02266.</p></li>
<li id="fn9" class="footnote-item"><p>Zhu, X., Li, T., & De Melo, G. (2018). Exploring Semantic Properties of Sentence Embeddings. In Proceedings of ACL 2018 (pp. 1–6). Retrieved from http://aclweb.org/anthology/P18-2100
</p></li>
<li id="fn10" class="footnote-item"><p>Pezzelle, S., Steinert-Threlkeld, S., Bernardi, R., & Szymanik, J. (2018). Some of Them Can be Guessed! Exploring the Effect of Linguistic Context in Predicting Quantifiers. In Proceedings of ACL 2018. Retrieved from http://arxiv.org/abs/1806.00354
</p></li>
<li id="fn11" class="footnote-item"><p>Conneau, A., Kruszewski, G., Lample, G., Barrault, L., & Baroni, M. (2018). What you can cram into a single vector: Probing sentence embeddings for linguistic properties. In Proceedings of ACL 2018. Retrieved from http://arxiv.org/abs/1805.01070
</p></li>
<li id="fn12" class="footnote-item"><p>Kuncoro, A., Dyer, C., Hale, J., Yogatama, D., Clark, S., & Blunsom, P. (2018). LSTMs Can Learn Syntax-Sensitive Dependencies Well, But Modeling Structure Makes Them Better. In Proceedings of ACL 2018 (pp. 1–11). Retrieved from http://aclweb.org/anthology/P18-1132
</p></li>
<li id="fn13" class="footnote-item"><p>
Ribeiro, M. T., Singh, S., & Guestrin, C. (2018). Semantically Equivalent Adversarial Rules for Debugging NLP Models. In Proceedings of ACL 2018.
</p></li>
<li id="fn14" class="footnote-item"><p>
Dror, R., Baumer, G., Shlomov, S., & Reichart, R. (2018). The Hitchhiker’s Guide to Testing Statistical Significance in Natural Language Processing. In Proceedings of ACL 2018. Retrieved from https://ie.technion.ac.il/~roiri/papers/ACL-2018-sig-cr.pdf
</p></li>
<li id="fn15" class="footnote-item"><p>
Dror, R., Baumer, G., Shlomov, S., & Reichart, R. (2018). Riley, P., & Gildea, D. (2018). Orthographic Features for Bilingual Lexicon Induction. In Proceedings of ACL 2018.
</p></li>
<li id="fn16" class="footnote-item"><p>
Lau, J. H., Cohn, T., Baldwin, T., Brooke, J., & Hammond, A. (2018). Deep-speare: A Joint Neural Model of Poetic Language, Meter and Rhyme. In Proceedings of ACL 2018. Retrieved from http://arxiv.org/abs/1807.03491
</p></li>
<li id="fn17" class="footnote-item"><p>
Chaganty, A. T., Mussman, S., & Liang, P. (2018). The price of debiasing automatic metrics in natural language evaluation. In Proceedings of ACL 2018. Retrieved from http://arxiv.org/abs/1807.02202
</p></li>
<li id="fn18" class="footnote-item"><p>
Finegan-Dollak, C., Kummerfeld, J. K., Zhang, L., Ramanathan, K., Sadasivam, S., Zhang, R., & Radev, D. (2018). Improving Text-to-SQL Evaluation Methodology. In Proceedings of ACL 2018. Retrieved from http://arxiv.org/abs/1806.09029
</p></li>
<li id="fn19" class="footnote-item"><p>
Shen, D., Wang, G., Wang, W., Min, M. R., Su, Q., Zhang, Y., … Carin, L. (2018). Baseline Needs More Love: On Simple Word-Embedding-Based Models and Associated Pooling Mechanisms. In Proceedings of ACL 2018.
</p></li>
<li id="fn20" class="footnote-item"><p>
Ren, S., Chen, W., Liu, S., Li, M., Zhou, M., & Ma, S. (2018). Triangular Architecture for Rare Language Translation. In Proceedings of ACL 2018. Retrieved from http://arxiv.org/abs/1805.04813
</p></li>
<li id="fn21" class="footnote-item"><p>
Cheng, Y., Tu, Z., Meng, F., Zhai, J., & Liu, Y. (2018). Towards Robust Neural Machine Translation. In Proceedings of ACL 2018.
</p></li>
<li id="fn22" class="footnote-item"><p>
Mudrakarta, P. K., Taly, A., Brain, G., Sundararajan, M., & Google, K. D. (2018). Did the Model Understand the Question? In Proceedings of ACL 2018. Retrieved from https://arxiv.org/pdf/1805.05492.pdf
</p></li>
<li id="fn23" class="footnote-item"><p>
Spithourakis, G. P., & Riedel, S. (2018). Numeracy for Language Models: Evaluating and Improving their Ability to Predict Numbers. In Proceedings of ACL 2018.
</p></li>
<li id="fn24" class="footnote-item"><p>
Blevins, T., Levy, O., & Zettlemoyer, L. (2018). Deep RNNs Encode Soft Hierarchical Syntax. In Proceedings of ACL 2018. Retrieved from http://arxiv.org/abs/1805.04218
</p></li>
<li id="fn25" class="footnote-item"><p>
Ruder, S., & Plank, B. (2018). Strong Baselines for Neural Semi-supervised Learning under Domain Shift. In Proceedings of ACL 2018.
</p></li>
<li id="fn26" class="footnote-item"><p>
Søgaard, A., Ruder, S., & Vulić, I. (2018). On the Limitations of Unsupervised Bilingual Dictionary Induction. In Proceedings of ACL 2018.
</p></li>
<li id="fn27" class="footnote-item"><p>
Artetxe, M., Labaka, G., & Agirre, E. (2018). A robust self-learning method for fully unsupervised cross-lingual mappings of word embeddings. In Proceedings of ACL 2018.
</p></li>
<li id="fn28" class="footnote-item"><p>
Ebrahimi, J., Rao, A., Lowd, D., & Dou, D. (2018). HotFlip: White-Box Adversarial Examples for Text Classification. In Proceedings of ACL 2018. Retrieved from http://arxiv.org/abs/1712.06751
</p></li>
<li id="fn29" class="footnote-item"><p>
Linzen, T., Dupoux, E., & Goldberg, Y. (2016). Assessing the Ability of LSTMs to Learn Syntax-Sensitive Dependencies. Proceedings of TACL 2016. Retrieved from http://arxiv.org/abs/1611.01368
</p></li>
<li id="fn30" class="footnote-item"><p>
Dyer, C., Kuncoro, A., Ballesteros, M., & Smith, N. A. (2016). Recurrent Neural Network Grammars. In NAACL. Retrieved from http://arxiv.org/abs/1602.07776
</p></li>
<li id="fn31" class="footnote-item"><p>
Currey, A., & Heafield, K. (2018). Unsupervised Source Hierarchies for Low-Resource Neural Machine Translation. In Proceedings of the Workshop on the Relevance of Linguistic Structure in Neural Architectures for NLP (pp. 1–7).
</p></li>
<li id="fn32" class="footnote-item"><p>
Li, Y., Cohn, T., & Baldwin, T. (2017). Robust Training under Linguistic Adversity. In Proceedings of the 15th Conference of the European Chapter of the Association for Computational Linguistics (Vol. 2, pp. 21–27).
</p></li>
<li id="fn33" class="footnote-item"><p>
Li, Y., Baldwin, T., & Cohn, T. (2018). Learning Domain-Robust Text Representations using Adversarial Training. In Proceedings of NAACL-HLT 2018.
</p></li>
<li id="fn34" class="footnote-item"><p>
Li, Y., Baldwin, T., & Cohn, T. (2018). Towards Robust and Privacy-preserving Text Representations. In Proceedings of ACL 2018.
</p></li>
<li id="fn35" class="footnote-item"><p>
Weiss, G., Goldberg, Y., & Yahav, E. (2018). Extracting Automata from Recurrent Neural Networks Using Queries and Counterexamples. In Proceedings of ICML 2018. Retrieved from http://arxiv.org/abs/1711.09576
</p></li>
<li id="fn36" class="footnote-item"><p>
Ethayarajh, K. (2018). Unsupervised Random Walk Sentence Embeddings: A Strong but Simple Baseline. In Proceedings of the 3rd Workshop on Representation Learning for NLP. Retrieved from http://www.aclweb.org/anthology/W18-3012
</p></li>
<li id="fn37" class="footnote-item"><p>
Liu, N. F., Levy, O., Schwartz, R., Tan, C., & Smith, N. A. (2018). LSTMs Exploit Linguistic Attributes of Data. In Proceedings of the 3rd Workshop on Representation Learning for NLP,. Retrieved from http://arxiv.org/abs/1805.11653
</p></li>
<li id="fn38" class="footnote-item"><p>
Howard, J., & Ruder, S. (2018). Universal Language Model Fine-tuning for Text Classification. In Proceedings of ACL 2018. Retrieved from http://arxiv.org/abs/1801.06146
</p></li>
<li id="fn39" class="footnote-item"><p>
Welbl, J., Stenetorp, P., & Riedel, S. (2018). Constructing Datasets for Multi-hop Reading Comprehension Across Documents. In Transactions of the Association for Computational Linguistics. Retrieved from http://arxiv.org/abs/1710.06481
</p></li>
<li id="fn40" class="footnote-item"><p>
Kočiský, T., Schwarz, J., Blunsom, P., Dyer, C., Hermann, K. M., Melis, G., & Grefenstette, E. (2018). The NarrativeQA Reading Comprehension Challenge. Transactions of the Association for Computational Linguistics. Retrieved from http://arxiv.org/abs/1712.07040
</p></li>
<li id="fn41" class="footnote-item"><p>
Bose, A., Ling, H., & Cao, Y. (2018). Adversarial Contrastive Estimation. In Proceedings of ACL 2018.
</p></li>
<li id="fn42" class="footnote-item">Khandelwal, U., He, H., Qi, P., & Jurafsky, D. (2018). Sharp Nearby, Fuzzy Far Away: How Neural Language Models Use Context. In Proceedings of ACL 2018.</li>
</ol><!--kg-card-end: markdown--><!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[NLP's ImageNet moment has arrived]]></title><description><![CDATA[Big changes are underway in the world of NLP. The long reign of word vectors as NLP's core representation technique has seen an exciting new line of challengers emerge. These approaches demonstrated that pretrained language models can achieve state-of-the-art results and herald a watershed moment.]]></description><link>http://ruder.io/nlp-imagenet/</link><guid isPermaLink="false">5c76ff7c1b9b0d18555b9eac</guid><category><![CDATA[natural language processing]]></category><category><![CDATA[transfer learning]]></category><category><![CDATA[language models]]></category><dc:creator><![CDATA[Sebastian Ruder]]></dc:creator><pubDate>Thu, 12 Jul 2018 08:27:00 GMT</pubDate><media:content url="http://ruder.io/content/images/2018/07/lm_objective.png" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><!--kg-card-begin: markdown--><img src="http://ruder.io/content/images/2018/07/lm_objective.png" alt="NLP's ImageNet moment has arrived"><p>This post discusses pretrained language models, one of the most exciting directions in contemporary NLP.</p>
<p><em>This post originally appeared at <a href="https://thegradient.pub/nlp-imagenet/">TheGradient</a> and was edited by <a href="http://www.andreykurenkov.com/">Andrey Kurenkov</a>, <a href="https://tweetdeck.twitter.com/">Eric Wang</a>, and <a href="http://acganesh.com/">Aditya Ganesh</a>.</em></p>
<p>Big changes are underway in the world of Natural Language Processing (NLP). The long reign of word vectors as NLP’s core representation technique has seen an exciting new line of challengers emerge: <a href="https://arxiv.org/abs/1802.05365">ELMo</a><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>, <a href="https://arxiv.org/abs/1801.06146">ULMFiT</a><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>, and the <a href="https://s3-us-west-2.amazonaws.com/openai-assets/research-covers/language-unsupervised/language_understanding_paper.pdf">OpenAI transformer</a><sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>. These works <a href="https://blog.openai.com/language-unsupervised/">made</a> <a href="https://techcrunch.com/2018/06/15/machines-learn-language-better-by-using-a-deep-understanding-of-words/">headlines</a> by demonstrating that pretrained language models can be used to achieve state-of-the-art results on a wide range of NLP tasks. Such methods herald a watershed moment: they may have the same wide-ranging impact on NLP as pretrained ImageNet models had on computer vision.</p>
<h2 id="fromshallowtodeeppretraining">From Shallow to Deep Pre-Training</h2>
<p>Pretrained word vectors have brought NLP a long way.  Proposed in 2013 as an approximation to language modeling, <a href="http://papers.nips.cc/paper/5021-distributed-representations-of-words-andphrases">word2vec</a><sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup> found adoption through its efficiency and ease of use in a time when hardware was a lot slower and deep learning models were not widely supported. Since then, the standard way of conducting NLP projects has largely remained unchanged: word embeddings pretrained on large amounts of unlabeled data via algorithms such as word2vec and <a href="https://nlp.stanford.edu/pubs/glove.pdf">GloVe</a><sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup> are used to initialize the first layer of a neural network, the rest of which is then trained on data of a particular task. On most tasks with limited amounts of training data, this led to a boost of <a href="http://www.aclweb.org/anthology/D14-1181">two to three percentage points</a><sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>. Though these pretrained word embeddings have been immensely influential, they have a major limitation: they only incorporate previous knowledge in the first layer of the model---the rest of the network still needs to be trained from scratch.</p>
<figure>
    <center>
<img src="http://ruder.io/content/images/2018/07/word2vec_relations.png" width="450" alt="NLP's ImageNet moment has arrived">
    <figcaption>Relations captured by word2vec. (Source: <a href="https://www.tensorflow.org/versions/master/tutorials/word2vec">TensorFlow tutorial</a>)</figcaption>
    </center>
</figure>
<p>Word2vec and related methods are <em>shallow</em> approaches that trade expressivity for efficiency. Using word embeddings is like initializing a computer vision model with pretrained representations that only encode edges: they will be helpful for many tasks, but they fail to capture higher-level information that might be even more useful. A model initialized with word embeddings needs to learn from scratch not only to disambiguate words, but also to derive meaning from a sequence of words. This is the core aspect of language understanding, and it requires modeling complex language phenomena such as compositionality, polysemy, anaphora, long-term dependencies, agreement, negation, and many more. It should thus come as no surprise that NLP models initialized with these shallow representations still require a huge number of examples to achieve good performance.</p>
<p>At the core of the recent advances of ULMFiT, ELMo, and the OpenAI transformer is one key paradigm shift: going from just initializing the first layer of our models to pretraining the entire model with hierarchical representations. If learning word vectors is like only learning edges, these approaches are like learning the full hierarchy of features, from edges to shapes to high-level semantic concepts.</p>
<p>Interestingly, pretraining entire models to learn both low and high level features has been practiced for years by the computer vision (CV) community. Most often, this is done by learning to classify images on the large ImageNet dataset. ULMFiT, ELMo, and the OpenAI transformer have now brought the NLP community close to having an &quot;<strong>ImageNet for language</strong>&quot;---that is, a task that enables models to learn higher-level nuances of language, similarly to how ImageNet has enabled training of CV models that learn general-purpose features of images. In the rest of this piece, we’ll unpack just why these approaches seem so promising by extending and building on this analogy to ImageNet.</p>
<h2 id="imagenet">ImageNet</h2>
<figure>
    <center>
<img src="http://ruder.io/content/images/2018/07/imagenet_challenge.png" width="450" alt="NLP's ImageNet moment has arrived">
    <figcaption>The ImageNet Large Scale Visual Recognition Challenge. (Source: <a href="https://www.slideshare.net/xavigiro/image-classification-on-imagenet-d1l4-2017-upc-deep-learning-for-computer-vision/">Xavier Giro-o-Nieto</a>)</figcaption>
    </center>
</figure>
<p>ImageNet’s impact on the course of machine learning research can hardly be overstated. The dataset was originally published in 2009 and quickly evolved into the ImageNet Large Scale Visual Recognition Challenge (ILSVRC). In 2012, the <a href="https://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf">deep neural network</a><sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup> submitted by Alex Krizhevsky, Ilya Sutskever, and Geoffrey Hinton performed 41% better than the next best competitor, demonstrating that deep learning was a viable strategy for machine learning and arguably <a href="https://qz.com/1034972/the-data-that-changed-the-direction-of-ai-research-and-possibly-the-world/">triggering the explosion of deep learning</a> in ML research.</p>
<p>The success of ImageNet highlighted that in the era of deep learning, data was at least as important as algorithms. Not only did the ImageNet dataset enable that very important 2012 demonstration of the power of deep learning, but it also allowed a breakthrough of similar importance in transfer learning: researchers soon realized that the weights learned in state of the art models for ImageNet could be used to initialize models for completely other datasets and improve performance significantly. This &quot;fine-tuning&quot; approach allowed achieving good performance with as little as one positive example per category <a href="https://arxiv.org/abs/1310.1531">(Donahue et al., 2014)</a><sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup>.</p>
<figure>
    <center>
<img src="http://ruder.io/content/images/2018/07/decaf_ilsvrc2012-sun397.png" width="450" alt="NLP's ImageNet moment has arrived">
    <figcaption>Features trained on ILSVRC-2012 generalize to the SUN-397 dataset. (Source: <a href="https://arxiv.org/abs/1310.1531">Donahue et al., 2014</a>)</figcaption>
    </center>
</figure>
<p>Pretrained ImageNet models have been used to achieve state-of-the-art results in tasks such as <a href="https://arxiv.org/abs/1703.06870">object detection</a><sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup>, <a href="https://arxiv.org/abs/1612.01105">semantic segmentation</a><sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup>, <a href="https://arxiv.org/abs/1701.01779">human pose estimation</a><sup class="footnote-ref"><a href="#fn11" id="fnref11">[11]</a></sup>, and <a href="https://arxiv.org/abs/1705.07750">video recognition</a><sup class="footnote-ref"><a href="#fn12" id="fnref12">[12]</a></sup>. At the same time, they have enabled the application of CV to domains where the number of training examples is small and annotation is expensive. Transfer learning via pretraining on ImageNet is in fact so effective in CV that not using it is now considered foolhardy <a href="https://arxiv.org/abs/1805.00932">(Mahajan et al., 2018)</a><sup class="footnote-ref"><a href="#fn13" id="fnref13">[13]</a></sup>.</p>
<h2 id="whatsinanimagenet">What’s in an ImageNet?</h2>
<p>In order to determine what an ImageNet for language might look like, we first have to identify what makes ImageNet good for transfer learning. <a href="https://arxiv.org/abs/1608.08614">Previous studies</a><sup class="footnote-ref"><a href="#fn14" id="fnref14">[14]</a></sup> have only shed partial light on this question: reducing the number of examples per class or the number of classes only results in a small performance drop, while fine-grained classes and more data are not always better.</p>
<p>Rather than looking at the data directly, it is more prudent to probe what the models trained on the data learn. It is common knowledge that features of deep neural networks trained on ImageNet <a href="https://arxiv.org/abs/1411.1792">transition from general to task-specific from the first to the last layer</a><sup class="footnote-ref"><a href="#fn15" id="fnref15">[15]</a></sup>: lower layers learn to model low-level features such as edges, while higher layers model higher-level concepts such as <a href="https://distill.pub/2017/feature-visualization/">patterns and entire parts or objects</a><sup class="footnote-ref"><a href="#fn16" id="fnref16">[16]</a></sup> as can be seen in the figure below. Importantly, knowledge of edges, structures, and the visual composition of objects is relevant for many CV tasks, which sheds light on why these layers are transferred. A key property of an ImageNet-like dataset is thus to encourage a model to learn features that will likely generalize to new tasks in the problem domain.</p>
<figure>
    <center>
<img src="http://ruder.io/content/images/2018/07/feature_visualization.png" width="450" alt="NLP's ImageNet moment has arrived">
    <figcaption>Visualization of the information captured by features across different layers in GoogLeNet trained on ImageNet. (Source: <a href="https://distill.pub/2017/feature-visualization/">Distill</a>)</figcaption>
    </center>
</figure>
<p>Beyond this, it is difficult to make further generalizations about why transfer from ImageNet works quite so well. For instance, another possible advantage of the ImageNet dataset is the quality of the data. ImageNet’s creators went to great lengths to ensure reliable and consistent annotations. However, work in distant supervision serves as a counterpoint, indicating that large amounts of weakly labelled data might often be sufficient. In fact, recently researchers at Facebook showed that they could pre-train a model by <a href="https://arxiv.org/abs/1805.00932">predicting hashtags on billions of social media images</a> to state-of-the-art accuracy on ImageNet.</p>
<p>Without any more concrete insights, we are left with two key desiderata:</p>
<ol>
<li>
<p>An ImageNet-like dataset should be <em>sufficiently large</em>, i.e. on the order of millions of training examples.</p>
</li>
<li>
<p>It should be <em>representative of the problem space</em> of the discipline.</p>
</li>
</ol>
<h2 id="animagenetforlanguage">An ImageNet for language</h2>
<p>In NLP, models are typically a lot shallower than their CV counterparts. Analysis of features has thus mostly focused on the first embedding layer, and little work has investigated the properties of higher layers for transfer learning. Let us consider the datasets that are large enough, fulfilling desideratum #1. Given the current state of NLP, there are several contenders<sup class="footnote-ref"><a href="#fn17" id="fnref17">[17]</a></sup>.</p>
<p><strong>Reading comprehension</strong> is the task of answering a natural language question about a paragraph. The most popular dataset for this task is the <a href="https://rajpurkar.github.io/SQuAD-explorer/">Stanford Question Answering Dataset (SQuAD)</a><sup class="footnote-ref"><a href="#fn18" id="fnref18">[18]</a></sup>, which contains more than 100,000 question-answer pairs and asks models to answer a question by highlighting a span in the paragraph as can be seen below.</p>
<figure>
    <center>
<img src="http://ruder.io/content/images/2018/07/squad_example.png" width="450" alt="NLP's ImageNet moment has arrived">
    <figcaption>Question-answer pairs for a sample passage in the SQuAD dataset (<a href="https://arxiv.org/abs/1606.05250">Rajpurkar et al., 2016</a>)</figcaption>
    </center>
</figure>
<p><strong>Natural language inference</strong> is the task of identifying the relation (entailment, contradiction, and neutral) that holds between a piece of text and a hypothesis. The most popular dataset for this task, the <a href="https://nlp.stanford.edu/projects/snli/">Stanford Natural Language Inference (SNLI) Corpus</a><sup class="footnote-ref"><a href="#fn19" id="fnref19">[19]</a></sup>, contains 570k human-written English sentence pairs. Examples of the dataset can be seen below.</p>
<figure>
    <center>
<img src="http://ruder.io/content/images/2018/07/snli_examples.png" width="450" alt="NLP's ImageNet moment has arrived">
    <figcaption>Examples from the SNLI dataset. (<a href="https://nlp.stanford.edu/pubs/snli_paper.pdf">Bowman et al., 2015</a>)</figcaption>
    </center>
</figure>
<p><strong>Machine translation</strong>, translating text in one language to text in another language, is one of the most studied tasks in NLP, and---over the years---has accumulated vast amounts of training data for popular language pairs, e.g. 40M English-French sentence pairs in WMT 2014. See below for two example translation pairs.</p>
<figure>
    <center>
<img src="http://ruder.io/content/images/2018/07/mt_examples.png" width="450" alt="NLP's ImageNet moment has arrived">
    <figcaption>French-to-English translations from newstest2014 (<a href="https://arxiv.org/abs/1710.11041">Artetxe et al., 2018</a>)</figcaption>
    </center>
</figure>
<p><strong>Constituency parsing</strong> seeks to extract the syntactic structure of a sentence in the form of a (linearized) constituency parse tree as can be seen below. In the past, <a href="https://arxiv.org/abs/1412.7449">millions of weakly labelled parses</a><sup class="footnote-ref"><a href="#fn20" id="fnref20">[20]</a></sup> have been used for training sequence-to-sequence models for this task.</p>
<figure>
    <center>
<img src="http://ruder.io/content/images/2018/07/constituency_parsing_example.png" width="450" alt="NLP's ImageNet moment has arrived">
    <figcaption>A parse tree and its linearization. (<a href="https://arxiv.org/abs/1412.7449">Vinyals et al., 2015</a>)</figcaption>
    </center>
</figure>
<p><strong>Language modeling (LM)</strong> aims to predict the next word given its previous word. Existing benchmark datasets consist of up to <a href="http://www.statmt.org/lm-benchmark/">1B words</a>, but as the task is unsupervised, any number of words can be used for training. See below for examples from the popular WikiText-2 dataset consisting of Wikipedia articles.</p>
<figure>
    <center>
<img src="http://ruder.io/content/images/2018/07/language_modeling_examples.png" width="450" alt="NLP's ImageNet moment has arrived">
    <figcaption>Examples from the WikiText-2 language modeling dataset. (Source: <a href="https://einstein.ai/research/the-wikitext-long-term-dependency-language-modeling-dataset">Salesforce</a>)</figcaption>
    </center>
</figure>
<p>All of these tasks provide---or would allow the collection of---a sufficient number of examples for training. Indeed, <a href="https://arxiv.org/abs/1705.02364">the</a><sup class="footnote-ref"><a href="#fn21" id="fnref21">[21]</a></sup> <a href="https://arxiv.org/abs/1804.00079">above</a><sup class="footnote-ref"><a href="#fn22" id="fnref22">[22]</a></sup> <a href="https://papers.nips.cc/paper/7209-learned-in-translation-contextualized-word-vectors">tasks</a><sup class="footnote-ref"><a href="#fn23" id="fnref23">[23]</a></sup> (and many others such as <a href="https://arxiv.org/abs/1708.00524">sentiment analysis</a><sup class="footnote-ref"><a href="#fn24" id="fnref24">[24]</a></sup>, <a href="https://arxiv.org/abs/1412.7449">constituency parsing</a> <sup class="footnote-ref"><a href="#fn20" id="fnref20:1">[20:1]</a></sup>, <a href="https://arxiv.org/abs/1506.06726">skip-thoughts</a><sup class="footnote-ref"><a href="#fn25" id="fnref25">[25]</a></sup>, and <a href="https://arxiv.org/abs/1511.01432">autoencoding</a><sup class="footnote-ref"><a href="#fn26" id="fnref26">[26]</a></sup>) have been used to pretrain representations in recent months.</p>
<p>While any data contains <a href="https://arxiv.org/abs/1607.06520">some bias</a><sup class="footnote-ref"><a href="#fn27" id="fnref27">[27]</a></sup>, human annotators may inadvertently introduce additional signals that a model can exploit. <a href="https://www.aclweb.org/anthology/P16-1223">Recent</a><sup class="footnote-ref"><a href="#fn28" id="fnref28">[28]</a></sup> <a href="https://arxiv.org/abs/1803.02324">studies</a><sup class="footnote-ref"><a href="#fn29" id="fnref29">[29]</a></sup> reveal that state-of-the-art models for tasks such as reading comprehension and natural language inference do not in fact exhibit deep natural language understanding but pick up on such cues to perform superficial pattern matching. For instance, <a href="https://arxiv.org/abs/1803.02324">Gururangan et al. (2018)</a><sup class="footnote-ref"><a href="#fn29" id="fnref29:1">[29:1]</a></sup> show that annotators tend to produce entailment examples simply by removing gender or number information and generate contradictions by introducing negations. A model that simply exploits these cues can correctly classify the hypothesis without looking at the premise in about 67% of the SNLI dataset.</p>
<p>The more difficult question thus is: Which task is most representative of the space of NLP problems? In other words, which task allows us to learn most of the knowledge or relations required for understanding natural language?</p>
<h2 id="thecaseforlanguagemodelling">The case for language modelling</h2>
<p>In order to predict the most probable next word in a sentence, a model is required not only to be able to express syntax (the grammatical form of the predicted word must match its modifier or verb) but also model semantics. Even more, the most accurate models must incorporate what could be considered <em>world knowledge</em> or <em>common sense</em>. Consider the incomplete sentence &quot;The service was poor, but the food was&quot;. In order to predict the succeeding word such as “yummy” or “delicious”, the model must not only memorize what attributes are used to describe food, but also be able to identify that the conjunction “but” introduces a contrast, so that the new attribute has the opposing sentiment of “poor”.</p>
<p>Language modelling, the last approach mentioned, has been shown to capture many facets of language relevant for downstream tasks, such as <a href="https://arxiv.org/abs/1611.01368">long-term dependencies</a><sup class="footnote-ref"><a href="#fn30" id="fnref30">[30]</a></sup>, <a href="https://arxiv.org/abs/1803.11138">hierarchical relations</a><sup class="footnote-ref"><a href="#fn31" id="fnref31">[31]</a></sup>, and <a href="https://arxiv.org/abs/1704.01444">sentiment</a><sup class="footnote-ref"><a href="#fn32" id="fnref32">[32]</a></sup>. Compared to related unsupervised tasks such as skip-thoughts and autoencoding, <a href="https://openreview.net/forum?id=BJeYYeaVJ7">language modelling performs better on syntactic tasks even with less training data</a>.</p>
<p>Among the biggest benefits of language modelling is that training data comes for free with any text corpus and that potentially unlimited amounts of training data are available. This is particularly significant, as NLP deals not only with the English language. More than 4,500 languages are spoken around the world by more than 1,000 speakers. Language modeling as a pretraining task opens the door to developing models for previously underserved languages. For very low-resource languages where even unlabeled data is scarce, multilingual language models may be trained on multiple related languages at once, analogous to work on <a href="https://arxiv.org/abs/1706.04902">cross-lingual embeddings</a><sup class="footnote-ref"><a href="#fn33" id="fnref33">[33]</a></sup>.</p>
<figure>
    <center>
<img src="http://ruder.io/content/images/2018/07/ulmfit.png" width="450" alt="NLP's ImageNet moment has arrived">
    <figcaption>The different stages of ULMFiT. (<a href="https://arxiv.org/abs/1801.06146">Howard and Ruder, 2018</a>)</figcaption>
    </center>
</figure>
<p>So far, our argument for language modeling as a pretraining task has been purely conceptual. Pretraining a language model was <a href="https://arxiv.org/abs/1511.01432">first proposed in 2015</a> <sup class="footnote-ref"><a href="#fn26" id="fnref26:1">[26:1]</a></sup>, but it remained unclear whether a single pretrained language model was useful for many tasks. In recent months, we finally obtained overwhelming empirical proof: <a href="https://arxiv.org/abs/1802.05365">Embeddings from Language Models (ELMo)</a>, <a href="https://arxiv.org/abs/1801.06146">Universal Language Model Fine-tuning (ULMFiT)</a>, and the <a href="https://s3-us-west-2.amazonaws.com/openai-assets/research-covers/language-unsupervised/language_understanding_paper.pdf">OpenAI Transformer</a> have empirically demonstrated how language modeling can be used for pretraining, as shown by the above figure from ULMFiT. All three methods employed pretrained language models to achieve state-of-the-art on a diverse range of tasks in Natural Language Processing, including text classification, question answering, natural language inference, coreference resolution, sequence labeling, and many others.</p>
<p>In many cases such as with ELMo in the figure below, these improvements ranged between 10-20% better than the state-of-the-art on widely studied benchmarks, all with the single core method of leveraging a pretrained language model. ELMo furthermore won the best <a href="https://naacl2018.wordpress.com/2018/04/11/outstanding-papers/">paper award at NAACL-HLT 2018</a>, one of the top conferences in the field. Finally, these models have been shown to be extremely sample-efficient, achieving good performance with only hundreds of examples and are even able to perform zero-shot learning.</p>
<figure>
    <center>
<img src="http://ruder.io/content/images/2018/07/elmo.png" width="450" alt="NLP's ImageNet moment has arrived">
    <figcaption>The improvements ELMo achieved on a wide range of NLP tasks. (Source: Matthew Peters)</figcaption>
    </center>
</figure>
<p>In light of this step change, <strong>it is very likely that in a year’s time NLP practitioners will download pretrained language models rather than pretrained word embeddings</strong> for use in their own models, similarly to how pre-trained ImageNet models are the starting point for most CV projects nowadays.</p>
<p>However, similar to word2vec, the task of language modeling naturally has its own limitations: It is only a proxy to true language understanding, and a single monolithic model is ill-equipped to capture the required information for certain downstream tasks. For instance, in order to answer questions about or follow the trajectory of characters in a story, a model needs to learn to perform <a href="https://en.wikipedia.org/wiki/Anaphora_(linguistics)">anaphora</a> or <a href="https://en.wikipedia.org/wiki/Coreference#Coreference_resolution">coreference resolution</a>. In addition, language models can only capture what they have seen. Certain types of information, such as most common sense knowledge, are <a href="https://arxiv.org/abs/1705.11168">difficult to learn from text alone</a><sup class="footnote-ref"><a href="#fn34" id="fnref34">[34]</a></sup> and require incorporating external information.</p>
<p>One outstanding question is how to transfer the information from a pre-trained language model to a downstream task. The two main paradigms for this are whether to use the pre-trained language model as a fixed feature extractor and incorporate its representation as features into a randomly initialized model as used in <a href="https://arxiv.org/abs/1802.05365">ELMo</a>, or whether to fine-tune the entire language model as done by <a href="https://arxiv.org/abs/1801.06146">ULMFiT</a>. The latter fine-tuning approach is what is typically done in CV where either the top-most or <a href="https://arxiv.org/abs/1310.1531">several of the top layers are fine-tuned</a>. While NLP models are typically more shallow and thus require different fine-tuning techniques than their vision counterparts, recent pretrained models are getting deeper. The next months will show the impact of each of the core components of transfer learning for NLP: an expressive language model encoder such as a deep BiLSTM or the <a href="https://arxiv.org/abs/1706.03762">Transformer</a>, the amount and nature of the data used for pretraining, and the method used to fine-tune the pretrained model.</p>
<h2 id="butwheresthetheory">But where’s the theory?</h2>
<p>
Our analysis thus far has been mostly conceptual and empirical, as it is still poorly understood why models trained on ImageNet---and consequently on language modeling---transfer so well. One way to think about the generalization behaviour of pretrained models more formally is under a model of <em>bias learning</em> (Baxter, 2000)<a href="#fn35" id="fnref35">[35]</a>. Assume our problem domain covers all permutations of tasks in a particular discipline, e.g. computer vision, which forms our <em>environment</em>. We are provided with a number of datasets that allow us to induce a <em>family</em> of hypothesis spaces $\mathrm{H} = {\mathcal{H}}$. Our goal in bias learning is to find a <em>bias</em>, i.e. a hypothesis space $\mathcal{H} \in \mathrm{H}$ that maximizes performance on the entire (potentially infinite) environment.
</p><p>Empirical and theoretical results in multi-task learning (Caruana, 1997; Baxter, 2000)<sup class="footnote-ref"><a href="#fn36" id="fnref36">[36]</a></sup><sup class="footnote-ref"><a href="#fn35" id="fnref35:1">[35:1]</a></sup> indicate that a bias that is learned on <em>sufficiently many</em> tasks is likely to generalize to unseen tasks drawn from the same environment. Viewed through the lens of multi-task learning, a model trained on ImageNet learns a large number of binary classification tasks (one for each class). These tasks, all drawn from the space of natural, real-world images, are likely to be representative of many other CV tasks. In the same vein, a language model---by learning a large number of classification tasks, one for each word---induces representations that are likely helpful for many other tasks in the realm of natural language. Still, much more research is necessary to gain a better theoretical understanding why language modeling seems to work so well for transfer learning.</p>
<h2 id="theimagenetmoment">The ImageNet moment</h2>
<p>The time is ripe for practical transfer learning to make inroads into NLP. In light of the impressive empirical results of <a href="https://arxiv.org/abs/1802.05365">ELMo</a>, <a href="https://arxiv.org/abs/1801.06146">ULMFiT</a>, and <a href="https://s3-us-west-2.amazonaws.com/openai-assets/research-covers/language-unsupervised/language_understanding_paper.pdf">OpenAI</a> it only seems to be a question of time until pretrained word embeddings will be dethroned and replaced by pretrained language models in the toolbox of every NLP practitioner. This will likely open many new applications for NLP in settings with limited amounts of labeled data. The king is dead, long live the king!</p>
<p><em>For further reading, check out the <a href="https://news.ycombinator.com/item?id=17489564">discussion on HackerNews</a>.</em></p>
<p><em>Cover image due to Matthew Peters.</em></p>
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>Peters, Matthew E., et al. &quot;Deep contextualized word representations.&quot; Proceedings of NAACL-HLT (2018). <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>Howard, Jeremy, and Sebastian Ruder. &quot;Fine-tuned Language Models for Text Classification.&quot; Proceedings of ACL (2018). <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>Radford, Alec, et al. &quot;Improving Language Understanding by Generative Pre-Training.&quot; <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>Mikolov, Tomas, et al. &quot;Distributed representations of words and phrases and their compositionality.&quot; Advances in neural information processing systems. 2013. <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>Pennington, Jeffrey, Richard Socher, and Christopher Manning. &quot;Glove: Global vectors for word representation.&quot; Proceedings of the 2014 conference on empirical methods in natural language processing (EMNLP). 2014. <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p>Kim, Yoon. &quot;Convolutional neural networks for sentence classification.&quot; Proceedings of EMNLP (2014). <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p>Krizhevsky, Alex, Ilya Sutskever, and Geoffrey E. Hinton. &quot;Imagenet classification with deep convolutional neural networks.&quot; Advances in neural information processing systems. 2012. <a href="#fnref7" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn8" class="footnote-item"><p>Donahue, Jeff, et al. &quot;Decaf: A deep convolutional activation feature for generic visual recognition.&quot; International conference on machine learning. 2014. <a href="#fnref8" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn9" class="footnote-item"><p>He, Kaiming, et al. &quot;Mask r-cnn.&quot; Computer Vision (ICCV), 2017 IEEE International Conference on. IEEE, 2017. <a href="#fnref9" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn10" class="footnote-item"><p>Zhao, Hengshuang, et al. &quot;Pyramid scene parsing network.&quot; IEEE Conf. on Computer Vision and Pattern Recognition (CVPR). 2017. <a href="#fnref10" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn11" class="footnote-item"><p>Papandreou, George, et al. &quot;Towards accurate multi-person pose estimation in the wild.&quot; CVPR. Vol. 3. No. 4. 2017. <a href="#fnref11" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn12" class="footnote-item"><p>Carreira, Joao, and Andrew Zisserman. &quot;Quo vadis, action recognition? a new model and the kinetics dataset.&quot; Computer Vision and Pattern Recognition (CVPR), 2017 IEEE Conference on. IEEE, 2017. <a href="#fnref12" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn13" class="footnote-item"><p>Mahajan, Dhruv, et al. &quot;Exploring the Limits of Weakly Supervised Pretraining.&quot; arXiv preprint arXiv:1805.00932 (2018). <a href="#fnref13" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn14" class="footnote-item"><p>Huh, Minyoung, Pulkit Agrawal, and Alexei A. Efros. &quot;What makes ImageNet good for transfer learning?.&quot; arXiv preprint arXiv:1608.08614 (2016). <a href="#fnref14" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn15" class="footnote-item"><p>Yosinski, Jason, et al. &quot;How transferable are features in deep neural networks?.&quot; Advances in neural information processing systems. 2014. <a href="#fnref15" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn16" class="footnote-item"><p>Olah, Chris, Alexander Mordvintsev, and Ludwig Schubert. &quot;Feature visualization.&quot; Distill 2.11 (2017): e7. <a href="#fnref16" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn17" class="footnote-item"><p>For a comprehensive overview of progress in NLP tasks, you can refer to this <a href="https://github.com/sebastianruder/NLP-progress">GitHub repository</a>. <a href="#fnref17" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn18" class="footnote-item"><p>Rajpurkar, Pranav, et al. &quot;Squad: 100,000+ questions for machine comprehension of text.&quot; Proceedings of the 2016 Conference on Empirical Methods in Natural Language Processing (EMNLP, 2016). <a href="#fnref18" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn19" class="footnote-item"><p>Bowman, Samuel R., et al. &quot;A large annotated corpus for learning natural language inference.&quot; Proceedings of the Conference on Empirical Methods in Natural Language Processing (EMNLP, 2015). <a href="#fnref19" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn20" class="footnote-item"><p>Vinyals, Oriol, et al. &quot;Grammar as a foreign language.&quot; Advances in Neural Information Processing Systems. 2015. <a href="#fnref20" class="footnote-backref">↩︎</a> <a href="#fnref20:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn21" class="footnote-item"><p>Conneau, Alexis, et al. &quot;Supervised learning of universal sentence representations from natural language inference data.&quot; Proceedings of the Conference on Empirical Methods in Natural Language Processing (EMNLP, 2017). <a href="#fnref21" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn22" class="footnote-item"><p>Subramanian, Sandeep, et al. &quot;Learning general purpose distributed sentence representations via large scale multi-task learning.&quot; Proceedings of the International Conference on Learning Representations, ICLR (2018). <a href="#fnref22" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn23" class="footnote-item"><p>McCann, Bryan, et al. &quot;Learned in translation: Contextualized word vectors.&quot; Advances in Neural Information Processing Systems. 2017. <a href="#fnref23" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn24" class="footnote-item"><p>Felbo, Bjarke, et al. &quot;Using millions of emoji occurrences to learn any-domain representations for detecting sentiment, emotion and sarcasm.&quot; Proceedings of the Conference on Empirical Methods in Natural Language Processing (EMNLP, 2017). <a href="#fnref24" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn25" class="footnote-item"><p>Kiros, Ryan, et al. &quot;Skip-thought vectors.&quot; Advances in neural information processing systems. 2015. <a href="#fnref25" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn26" class="footnote-item"><p>Dai, Andrew M., and Quoc V. Le. &quot;Semi-supervised sequence learning.&quot; Advances in neural information processing systems. 2015. <a href="#fnref26" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn27" class="footnote-item"><p>Bolukbasi, Tolga, et al. &quot;Man is to computer programmer as woman is to homemaker? debiasing word embeddings.&quot; Advances in Neural Information Processing Systems. 2016. <a href="#fnref27" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn28" class="footnote-item"><p>Chen, Danqi, Jason Bolton, and Christopher D. Manning. &quot;A thorough examination of the cnn/daily mail reading comprehension task.&quot; Proceedings of the Meeting of the Association for Computational Linguistics (2016). <a href="#fnref28" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn29" class="footnote-item"><p>Gururangan, Suchin, et al. &quot;Annotation artifacts in natural language inference data.&quot; Proceedings of NAACL-HLT (2018). <a href="#fnref29" class="footnote-backref">↩︎</a> <a href="#fnref29:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn30" class="footnote-item"><p>Linzen, T., Dupoux, E., &amp; Goldberg, Y. (2016). Assessing the Ability of LSTMs to Learn Syntax-Sensitive Dependencies. Proceedings of TACL 2016. <a href="#fnref30" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn31" class="footnote-item"><p>Gulordava, K., Bojanowski, P., Grave, E., Linzen, T., &amp; Baroni, M. (2018). Colorless green recurrent networks dream hierarchically. In Proceedings of NAACL-HLT 2018. <a href="#fnref31" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn32" class="footnote-item"><p>Radford, A., Jozefowicz, R., &amp; Sutskever, I. (2017). Learning to Generate Reviews and Discovering Sentiment. arXiv preprint arXiv:1704.01444. <a href="#fnref32" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn33" class="footnote-item"><p>Ruder, Sebastian, Ivan Vulic, and Anders Søgaard. &quot;A Survey of Cross-lingual Word Embedding Models.&quot; Journal of Artificial Intelligence Research (2018). <a href="#fnref33" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn34" class="footnote-item"><p>Lucy, Li, and Jon Gauthier. &quot;Are distributional representations ready for the real world? Evaluating word vectors for grounded perceptual meaning.&quot; Proceedings of the First Workshop on Language Grounding for Robotics (2017). <a href="#fnref34" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn35" class="footnote-item"><p>Jonathan Baxter. 2000. A Model of Inductive Bias Learning. Journal of Artificial Intelligence Research 12:149–198. <a href="#fnref35" class="footnote-backref">↩︎</a> <a href="#fnref35:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn36" class="footnote-item"><p>Rich Caruana. 1993. Multitask learning: A knowledge-based source of inductive bias. In Proceedings of the Tenth International Conference on Machine Learning. <a href="#fnref36" class="footnote-backref">↩︎</a></p>
</li>
</ol><!--kg-card-end: markdown--><!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[Tracking the Progress in Natural Language Processing]]></title><description><![CDATA[Research in ML and NLP is moving at a tremendous pace, which is an obstacle for people wanting to enter the field. To make working with new tasks easier, this post introduces a resource that tracks the progress and state-of-the-art across many tasks in NLP.]]></description><link>http://ruder.io/tracking-progress-nlp/</link><guid isPermaLink="false">5c76ff7c1b9b0d18555b9eaa</guid><category><![CDATA[natural language processing]]></category><dc:creator><![CDATA[Sebastian Ruder]]></dc:creator><pubDate>Fri, 22 Jun 2018 17:31:55 GMT</pubDate><media:content url="http://ruder.io/content/images/2018/10/squad_progress.png" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><!--kg-card-begin: markdown--><img src="http://ruder.io/content/images/2018/10/squad_progress.png" alt="Tracking the Progress in Natural Language Processing"><p>This post introduces a resource to track the progress and state-of-the-art across many tasks in NLP.</p>
<p><a href="https://nlpprogress.com">Go directly to the document tracking the progress in NLP</a>.</p>
<p>Research in Machine Learning and in Natural Language Processing (NLP) is moving so fast these days, it is hard to keep up. This is an issue for people in the field, but it is an even bigger obstacle for people wanting to get into NLP and those seeking to make the leap from tutorials to reproducing papers and conducting their own research. Without expert guidance and prior knowledge, it can be a painstaking process to identify the most common datasets and the current state-of-the-art for your task of interest.</p>
<p>A number of resources exist that could help with this process, but each has deficits: The Association of Computation Linguistics (ACL) has a <a href="https://aclweb.org/aclwiki/State_of_the_art">wiki page</a> tracking the state-of-the-art, but the page is not maintained and contributing is not straightforward. The <a href="https://www.eff.org/ai/metrics">Electronic Frontier Foundation</a> and the <a href="https://aiindex.org/">AI Index</a> try to do something similar for all of AI but only cover a few language tasks. The <a href="http://lremap.elra.info/">Language Resources and Evaluation (LRE) Map</a> collects language resources presented at LREC and other conferences, but does not allow to break them out by tasks or popularity. Similarly, the <a href="http://alt.qcri.org/semeval2018/index.php?id=tasks">International Workshop on Semantic Evaluation (SemEval)</a> hosts a small number of tasks each year, which provide new datasets that typically have not been widely studied before. There are also resources that focus on <a href="http://rodrigob.github.io/are_we_there_yet/build/">computer vision</a> and <a href="https://github.com/syhw/wer_are_we">speech recognition</a> as well as <a href="https://github.com/RedditSota/state-of-the-art-result-for-machine-learning-problems#nlp">this repo</a>, which focuses on all of ML.</p>
<p>As an alternative, I have created a <a href="https://github.com/sebastianruder/NLP-progress">GitHub repository</a> that keeps track of the datasets and the current state-of-the-art for the most common tasks in NLP. The repository is kept as simple as possible to make maintenance and contribution easy. If I missed your favourite task or dataset or your new state-of-the-art result or if I made any error, you can simply submit a pull request.</p>
<p>The aim is to have a comprehensive and up-to-date resource where everyone can see at a glance the state-of-the-art for the tasks they care about. Datasets, which already do a great job at tracking this such as <a href="https://rajpurkar.github.io/SQuAD-explorer/">SQuAD</a> or <a href="https://nlp.stanford.edu/projects/snli/">SNLI</a> using a public leaderboard will simply be referenced instead.</p>
<p>My hope is that such a resource will give a broader sense of progress in the field than results in individual papers. It might also make it easier to identify tasks or areas where progress has been lacking. Another benefit is that such a resource may encourage serendipity: chancing upon an interesting new task or method. Finally, a positive by-product of having the state-of-the-art for each task easily accessible may be that it will be harder to justify (accidentally) comparing to weak baselines. For instance, the perplexity of the best baseline on the Penn Treebank varied dramatically across 10 language modeling papers submitted to ICLR 2018 (see below).</p>
<figure>
      <img src="http://ruder.io/content/images/2018/06/ppl_language_modeling_iclr_2018.png" style="width: 70%" title="Learning rate schedules with warm restarts" alt="Tracking the Progress in Natural Language Processing">
<figcaption>Figure 1: Comparison of perplexity (PPL) of proposed model vs. PPL of best baseline across 10 language modeling papers submitted to ICLR 2018 (credit: <a href="https://twitter.com/AaronJaech/status/924678973497446400">@AaronJaech</a>)</figcaption>
</figure>
<p>Credit for the cover image is due to the <a href="https://www.eff.org/ai/metrics#Reading-Comprehension">Electronic Frontier Foundation</a>.</p>
<!--kg-card-end: markdown--><!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[Highlights of NAACL-HLT 2018: Generalization, Test-of-time, and Dialogue Systems]]></title><description><![CDATA[This post discusses highlights of the 16th Annual Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies (NAACL-HLT 2018). It focuses on Generalization, the Test-of-Time awards, and Dialogue Systems.]]></description><link>http://ruder.io/highlights-naacl-2018/</link><guid isPermaLink="false">5c76ff7c1b9b0d18555b9eab</guid><category><![CDATA[natural language processing]]></category><category><![CDATA[events]]></category><category><![CDATA[reinforcement learning]]></category><category><![CDATA[transfer learning]]></category><dc:creator><![CDATA[Sebastian Ruder]]></dc:creator><pubDate>Tue, 12 Jun 2018 13:42:00 GMT</pubDate><media:content url="http://ruder.io/content/images/2018/06/IMG_20180603_183707_conference_venue.jpg" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><!--kg-card-begin: markdown--><img src="http://ruder.io/content/images/2018/06/IMG_20180603_183707_conference_venue.jpg" alt="Highlights of NAACL-HLT 2018: Generalization, Test-of-time, and Dialogue Systems"><p>This post discusses highlights of NAACL-HLT 2018.</p>
<p><em>This post originally appeared at the <a href="http://blog.aylien.com/highlights-of-naacl-hlt-2018-generalization-test-of-time-and-dialogue-systems/">AYLIEN blog</a>.</em></p>
<p>I attended <a href="http://naacl2018.org/">NAACL-HLT 2018</a> in New Orleans last week. I didn’t manage to catch as many talks and posters this time around (there were just too many inspiring people to talk to!), so my highlights and the trends I observed mainly focus on invited talks and workshops.</p>
<p>Specifically, my highlights concentrate on three topics, which were prominent throughout the conference: Generalization, the Test-of-Time awards, and Dialogue Systems. For more information about other topics, you can check out the <a href="http://naacl2018.org/downloads/naacl_hlt_2018_handbook.pdf">conference handbook</a> and the <a href="https://aclanthology.coli.uni-saarland.de/events/naacl-2018">proceedings</a>.</p>
<p>First of all, there were four quotes from the conference that particularly resonated with me (some of them are paraphrased):</p>
<blockquote>
<p><em>People worked on MT before the BLEU score</em>. - Kevin Knight</p>
</blockquote>
<p>It’s natural to work on tasks where evaluation is easy. Instead, we should encourage more people to tackle hard problems that are not easy to evaluate. These are often the most rewarding to work on.</p>
<blockquote>
<p><em>BLEU is an understudy. It was never meant to replace human judgement and never expected to last this long</em>. - Kishore Papineni, co-creator of BLEU, the most commonly used metric for machine translation.</p>
</blockquote>
<p>No approach is perfect. Even the authors of landmark papers were aware their methods had flaws. The best we can do is provide a fair evaluation of our technique.</p>
<blockquote>
<p><em>We decided to sample an equal number of positive and negative reviews---was that a good idea?</em> - Bo Pang, first author of one of the first papers on sentiment analysis (7k+ citations).</p>
</blockquote>
<p>In addition to being aware of the flaws of our method, we should be explicit about the assumptions we make so that future work can either build upon them or discard them if they prove unhelpful or turn out to be false.</p>
<blockquote>
<p><em>I pose the following challenge to the community: we should evaluate on out-of-distribution data or on a new task</em>. - Percy Liang.</p>
</blockquote>
<p>We never know how well our model truly generalizes if we just test it on data of the same distribution. In order to develop models that can be applied to the real world, we need to evaluate on out-of-distribution data or on a new task. Percy Liang’s quote ties into one of the topics that received increasing attention at the conference: how can we train models that are less brittle and that generalize better?</p>
<h2 id="generalization">Generalization</h2>
<p>Over the last years, much of the research within the NLP community focused on improving LSTM-based models on benchmark tasks. At NAACL, it seemed that increasingly people were thinking about how to get models to generalize beyond the conditions during training, reflecting a similar sentiment in the Deep Learning community in general (a <a href="https://arxiv.org/abs/1611.03530">paper on generalization</a> won the best paper award at ICLR 2017).</p>
<p>One aspect is generalizing from few examples, which is difficult with the current generation of neural network-based methods. Charles Yang, professor of Linguistics, Computer Science and Psychology at the University of Pennsylvania put this in a cognitive science context.</p>
<p>Machine learning and NLP researchers in the neural network era frequently like to motivate their work by referencing the remarkable generalization ability of young children. One piece of information that often is eluded, however, is that generalization in young children is also not without its errors, because it requires learning a rule and accounting for exceptions. For instance, when learning to count, young children still frequently make mistakes, as they have to balance rule-based generalization (for regular numbers such as sixteen, seventeen, eighteen, etc.) with memorizing exceptions (numbers such as fifteen, twenty, thirty, etc.).</p>
<p>However, once a child can flawlessly count to 72, it <a href="https://penntoday.upenn.edu/research/penn-linguist-determines-tipping-point-for-children-learning-to-count">can generalize to any new numbers</a>. This magic number, 72, is given by the so-called tolerance principle, which prescribes that in order for a generalization rule to be productive, there can be at most N/ln(N) exceptions, where N is the total number of examples as can be seen in the Figure below. For counting, 72/ln(72) ≈ 17, which is exactly the number of exceptions until 72.</p>
<p>Hitchhiker’s Guide to the Galaxy fans, however, need not be disappointed: in Chinese, the magic number is 42. Chinese only has 11 exceptions. As 42/ln(42) ≈ 11, Chinese children typically only need to learn to count up to 42 in order to generalize, which explains why Chinese children usually learn to count faster.</p>
<figure>
      <img src="http://ruder.io/content/images/2018/06/IMG_20180602_092025_tolerance_principle.jpg" style="width: 70%" title="Tolerance principle" alt="Highlights of NAACL-HLT 2018: Generalization, Test-of-time, and Dialogue Systems">
<figcaption>Figure 1: The Tolerance Principle</figcaption>
</figure>
<p>It is also interesting to note that even though young children can count up to a certain number, they can’t tell you, for example, which number is higher than 24. Only after they’ve learned the rule can they actually apply it productively.</p>
<p>The tolerance principle implies that if the total number of examples covered by the rule is smaller, it is easier to incorporate comparatively more exceptions. While children can productively learn language from few examples, this indicates that for few-shot learning (at least in the cognitive process of language acquisition), big data may actually be harmful. Insights from cognitive science may thus help us in developing models that generalize better.</p>
<p>The choice of the best paper of the conference, <a href="https://arxiv.org/abs/1802.05365">Deep contextualized word representations</a>, also demonstrates an increasing interest in generalization. Embeddings from Language Models (ELMo) showed significant improvements over the state-of-the-art on a wide range of tasks as can be seen below. This---together with <a href="https://arxiv.org/abs/1801.06146">better ways to fine-tune pre-trained language models</a>---reveals the potential of transfer learning for NLP.</p>
<figure>
      <img src="http://ruder.io/content/images/2018/06/IMG_20180604_160920_elmo.jpg" style="width: 70%" title="ELMo improvements" alt="Highlights of NAACL-HLT 2018: Generalization, Test-of-time, and Dialogue Systems">
<figcaption>Figure 2: Improvements by ELMo on six diverse NLP tasks</figcaption>
</figure>
<p>Generalization was also the topic of the <a href="https://newgeneralization.github.io/">Workshop on New Forms of Generalization in Deep Learning and Natural Language Processing</a>, which sought to analyze the failings of brittle models and propose new ways to evaluate and new models that would enable better generalization. Throughout the workshop, the room (seen below) was packed most of the time, which is both a testament to the prestige of the speakers and the community interest in the topic.</p>
<figure>
      <img src="http://ruder.io/content/images/2018/06/IMG_20180605_110109_gendeep_room.jpg" style="width: 70%" title="Gen-Deep 2018" alt="Highlights of NAACL-HLT 2018: Generalization, Test-of-time, and Dialogue Systems">
<figcaption>Figure 3: The packed venue of the Gen-Deep Workshop</figcaption>
</figure>
<p>In the <a href="https://newgeneralization.github.io/slides/YejinChoi.pdf">first talk of the workshop</a>, Yejin Choi argued that natural language understanding (NLU) does not generalize to natural language generation (NLG): while pre-Deep Learning NLG models often started with NLU output, post-DL NLG seems less dependent on NLU. However, current neural NLG heavily depends on language models and neural NLG can be brittle; in many cases, baselines based on templates can actually work better.</p>
<p>Despite advances in NLG, generating a coherent paragraph still does not work well and models end up generating generic, contentless, bland text full of repetitions and contradictions. But if we feed our models natural language input, why do they produce unnatural language output?</p>
<p>Yejin identified two limitations of language models in this context. Language models are passive learners: in the real world, one can’t learn to write just by reading; and similarly, she argued, even RNNs need to “practice” writing. Secondly, language models are surface learners: they need “world” models and must be sensitive to the “latent process” behind language. In reality, people don’t write to maximize the probability of the next token, but rather seek to fulfill certain communicative goals.</p>
<p>To address this, Yejin and collaborators proposed in an <a href="https://arxiv.org/abs/1805.06087">upcoming ACL 2018 paper</a> to augment the generator with multiple discriminative models that grade the output along different dimensions inspired by Grice’s maxims.</p>
<p>Yejin also sought to explain why there is a significant performance gaps between different NLU tasks such as machine translation and dialogue. For Type 1 or shallow NLU tasks, there is a strong alignment between input and output and models can often match surface patterns. For Type 2 or deep NLU tasks, the alignment between input and output is weaker; in order to perform well, a model needs to be able to abstract and reason, and requires certain types of knowledge, especially common sense knowledge. In particular, commonsense knowledge has somewhat fallen out of favour; past approaches, which were mostly proposed in the 80s, did not have access to a lot of computing power and were mostly done by non-NLP people. Overall, NLU traditionally focuses on understanding only “natural” language, while NLG also requires understanding machine language, which may be unnatural.</p>
<p>Devi Parikh discussed <a href="https://newgeneralization.github.io/slides/DeviParikh.pptx">generalization “opportunities” in visual question answering</a> (VQA) and illustrated successes and failures of VQA models. In particular, VQA models are not very good at generalizing to novel instances; the distance of a test image from the k-nearest neighbours seen during training can predict the success or failure of a model with about 67% accuracy.</p>
<p>Devi also showed that in many cases, VQA models do not even consider the entire question: in 50% of cases, only half the question is read. In particular, certain prefixes demonstrate the power of language priors: if the question begins with “Is there a clock…?”, the answer is “yes” 98% of the time; if the question begins with “Is the man wearing glasses…?”, the answer is “yes” 94% of the time. In order to counteract these biases, Devi and her collaborators introduced a <a href="https://arxiv.org/abs/1612.00837">new dataset of complimentary scenes</a>, which are very similar but differ in their answers. They also proposed a <a href="https://arxiv.org/abs/1712.00377">new setting for VQA</a> where for every question type, train and test sets have different prior distributions of answers.</p>
<p>The final discussion with senior panelists (seen below) was arguably the highlight of the workshop; a summary can be found <a href="https://twitter.com/seb_ruder/status/1004110419563286529">here</a>. The main takeaways are that we need to develop models with inductive biases and that we need to do a better job of educating people on how to design experiments and identify biases in datasets.</p>
<figure>
      <img src="http://ruder.io/content/images/2018/06/IMG_20180605_161710_panel.jpg" style="width: 100%" title="Gen-Deep 2018 panel" alt="Highlights of NAACL-HLT 2018: Generalization, Test-of-time, and Dialogue Systems">
<figcaption>Figure 4: Panel discussion at the Generalization workshop (from left to right: Chris Manning, Percy Liang, Sam Bowman, Yejin Choi, Devi Parikh)</figcaption>
</figure>
<h2 id="testoftimeawards">Test-of-time awards</h2>
<p>Another highlight of the conference was the test-of-time awards session, which highlighted persons and papers that had a huge impact on the field. At the beginning of the session, Aravind Yoshi (see below), NLP pioneer and professor of Computer Science at the University of Pennsylvania, who passed away on December 31, 2017 was honored in touching epitaphs by close friends and people who knew him. The commemoration was a powerful reminder that research is about more than the papers we publish, but about the people we help and the lives we touch.</p>
<figure>
      <img src="http://ruder.io/content/images/2018/06/IMG_20180603_170850_aravind_joshi.jpg" style="width: 70%" title="Aravind Joshi" alt="Highlights of NAACL-HLT 2018: Generalization, Test-of-time, and Dialogue Systems">
<figcaption>Figure 5: Aravind Joshi</figcaption>
</figure>
<p>Afterwards, three papers (all published in 2002) were honored with <a href="https://naacl2018.wordpress.com/2018/03/22/test-of-time-award-papers/">test-of-time awards</a>. For each paper, one of the original authors presented the paper and reflected on its impact. The first paper presented was <a href="https://www.aclweb.org/anthology/P02-1040.pdf">BLEU: a Method for Automatic Evaluation of Machine Translation</a>, which introduced the original BLEU metric, now commonplace in machine translation (MT). Kishore Papineni recounted that the name was inspired by <a href="http://www.cs.cmu.edu/~aberger/mt.html">Candide</a>, an experimental MT system at IBM in the early 1990s and by IBM’s nickname, Big Blue, as all authors were at IBM at that time.</p>
<p>Before BLEU, machine translation evaluation was cumbersome, expensive, and thought to be as difficult as training an MT model. Despite its huge impact, BLEU’s creators were apprehensive before its initial publication. Once published, BLEU seemed to split the community in two camps: those who loved it, and those who hated it; the authors hadn’t expected such a strong reaction.</p>
<p>BLEU is still criticized today. It was meant as a corpus-level metric; individual sentence errors should be averaged out across the entire corpus. Kishore conceded that in hindsight, they made a few mistakes: they should have included smoothing and statistical significance testing; an initial version was also case insensitive, which caused confusion.</p>
<p>In summary, BLEU has many known limitations and inspired many colorful variants. On the whole, however, it is an understudy (as the acronym BiLingual Evaluation Understudy implies): it was never meant to replace human judgement and---notably---was never expected to last this long.</p>
<p>The second honored paper was <a href="http://www.aclweb.org/anthology/W02-1001">Discriminative Training Methods for Hidden Markov Models: Theory and Experiments with Perceptron Algorithms</a> by Michael Collins, which introduced the Structured Perceptron, one of the foundational and easiest to understand algorithms for general structured prediction.</p>
<p>Lastly, Bo Pang looked back on her paper <a href="http://www.aclweb.org/anthology/W02-1011">Thumbs up? Sentiment Classification using Machine Learning Techniques</a>, which was the first paper of her PhD and one of the first papers on sentiment analysis, now an active research area in the NLP community. Prior to the paper, people had worked on classifying the subjectivity of sentences and the semantic orientation (polarity) of adjectives; sentiment classification was thus a natural progression.</p>
<p>Over the years, the paper has accumulated more than 7,000 citations. One reason why the paper was so impactful was that the authors decided to release a dataset with it. Bo was critical of the sampling choices they made that “messed” with the natural distribution of the data: they capped the number of reviews of prolific authors, which was probably a good idea. However, they sampled an equal number of positive and negative reviews, which set the standard that many approaches later followed and is still the norm for sentiment analysis today. A better idea might have been to stay true to the natural distribution of the data.</p>
<p>I found the test-of-time award session both insightful and humbling: we can derive many insights from traditional approaches and combining traditional with more or recent approaches is often a useful direction; at the same time, even the authors of landmark papers are critical of their own work and aware of its own flaws.</p>
<h2 id="dialoguesystems">Dialogue systems</h2>
<p>Another pervasive topic at the conference was dialogue systems. On the first day, researchers from PolyAI gave an excellent <a href="https://www.poly-ai.com/naacl18">tutorial on Conversational AI</a>. On the second day, Mari Ostendorf, professor of Electrical Engineering at the University of Washington and faculty advisor to the Sounding Board team, which won the inaugural Alexa Prize competition, shared some of the secrets to their winning socialbot. A socialbot in this context is a bot with which you can have a conversation, in contrast to a personal assistant that is designed to accomplish user-specified goals.</p>
<p>A good socialbot should have the same qualities as someone you enjoy talking to at a cocktail party: it should have something interesting to say and show interest in the conversation partner. To illustrate this, an example conversation with the Sounding Board bot can be seen below.</p>
<figure>
      <img src="http://ruder.io/content/images/2018/06/IMG_20180602_141024_alexa_prize_conversation.jpg" style="width: 70%" title="Sounding Board bot conversation" alt="Highlights of NAACL-HLT 2018: Generalization, Test-of-time, and Dialogue Systems">
<figcaption>Figure 6: An example conversation with the Sounding Board bot</figcaption>
</figure>
<p>With regard to saying something interesting, the team found that users react positively to learning something new but negatively to old or unpleasant news; a challenge here is to filter what to present to people. In addition, users lose interest when they receive too much content that they do not care about.</p>
<p>Regarding expressing interest, users appreciate an acknowledgement of their reactions and requests. While some users need encouragement to express opinions, some prompts can be annoying (“The article mentioned Google. Have you heard of Google?”).</p>
<p>They furthermore found that modeling prosody is important. Prosody deals with modeling the patterns of stress and intonation in speech. Instead of sounding monotonous, a bot that incorporates prosody seems more engaging, can better articulate intent, communicate sentiment or sarcasm, express empathy or enthusiasm, or change the topic. In some cases, prosody is also essential for avoiding---often hilarious---misunderstandings: for instance, the Alexa’s default voice pattern for ‘Sounding Board’ sounds like ‘Sounding Bored’.</p>
<p>Using a knowledge graph, the bot can have deeper conversations by staying “sort of on topic without totally staying on topic”. Mari also shared four key lessons that they learned working with 10M conversations:</p>
<h3 id="lesson1asrisimperfect">Lesson #1: ASR is imperfect</h3>
<p>While automatic speech recognition (ASR) has reached lower and lower word error rates in recent years, ASR is far from being solved. In particular, ASR in dialogue agents is tuned for short commands, not conversational speech. Whereas it can accurately identify for instance many obscure music groups, it struggles with more conversational or informal input. In addition, current development platforms provide developers with an impoverished representation of speech that does not contain segmentation or prosody and often misses certain intents and affects. Problems caused by this missing information can be seen below.</p>
<figure>
      <img src="http://ruder.io/content/images/2018/06/IMG_20180602_142859_prosody.jpg" style="width: 70%" title="Problems caused by missing prosody information" alt="Highlights of NAACL-HLT 2018: Generalization, Test-of-time, and Dialogue Systems">
<figcaption>Figure 7: Problems caused by missing prosody information and missing punctuation</figcaption>
</figure>
<p>In practice, the Sounding Board team found it helpful for the socialbot to behave similarly to attendees at a cocktail party: if the intent of the entire utterance is not completely clear, the bot responds to whatever part it understood, e.g. to a somewhat unintelligible “cause does that you’re gonna state that’s cool” it might respond “I’m happy you like that.” They also found that often, asking the conversation partner to repeat an utterance will not yield a much better result; instead, it is often better just to change the topic.</p>
<h3 id="lesson2usersvary">Lesson #2: Users vary</h3>
<p>The team discovered something what might seem obvious but has wide-ranging consequences in practice: users vary a lot across different dimensions. Users have different interests, different opinions on issues, and a different sense of humor. Interaction styles, similarly, can range from terse to verbose (seen below), from polite to rude. Users can also interact with the bot in pursuit of widely different goals: they may seek information, intend to share opinions, try to get to know the bot, or seek to explore the limitations of the bot. Modeling the user involves both determining what to say as well as listening to what the user says.</p>
<figure>
      <img src="http://ruder.io/content/images/2018/06/IMG_20180602_143521_interaction_styles.jpg" style="width: 70%" title="Interaction styles of talkative and terse users" alt="Highlights of NAACL-HLT 2018: Generalization, Test-of-time, and Dialogue Systems">
<figcaption>Figure 8: Interaction styles of talkative and terse users</figcaption>
</figure>
<h3 id="lesson3itsawildworld">Lesson #3: It’s a wild world</h3>
<p>There is a lot of problematic content and many issues exist that need to be navigated. Problematic content can consist of offensive or controversial material or sensitive and depressing topics. In addition, users might act adversarially and deliberately try to get the bot to produce such content. Examples of such behaviour can be seen below. Other users (e.g. such as those suffering from a mental illness) are in turn risky to deal with. Overall, filtering content is a hard problem. As one example, Mari mentioned that early in the project, the bot made the following witty observation / joke: “You know what I realized the other day? Santa Claus is the most elaborate lie ever told”.</p>
<figure>
      <img src="http://ruder.io/content/images/2018/06/IMG_20180602_143955_adversarial_users.jpg" style="width: 70%" title="Adversarial user examples" alt="Highlights of NAACL-HLT 2018: Generalization, Test-of-time, and Dialogue Systems">
<figcaption>Figure 9: Adversarial user examples</figcaption>
</figure>
<h3 id="lesson4shallowconversations">Lesson #4: Shallow conversations</h3>
<p>As the goal of the Alexa Prize was to maintain a conversation of 20 minutes, in light of the current limited understanding and generation capabilities, the team focused on a dialog strategy of shallow conversations. Even for shallow conversations, however, switching to related topics can still be fragile due to word sense ambiguities. It is notable that among the top 3 Alexa Prize teams, <a href="https://arxiv.org/abs/1712.07558">Deep Learning was only used by one team and only for reranking</a>.</p>
<p>In total, a competition such as the Alexa Prize that brings academia and industry together is useful as it allows researchers to access data from real users at a large scale, which impacts the problems they choose to solve and the resulting solutions. It also teaches students about complete problems and real-world challenges and provides funding support for students. The team found it in particular beneficial someone from industry available to support the partnership, to provide advice on tools, and feedback on progress.</p>
<p>On the other hand, privacy-preserving access to user data, such as prosody info for spoken language and speaker/author demographics for text and speech still needs work. For spoken dialog systems, richer speech interfaces are furthermore necessary. Finally, while competitions are great kickstarters, they nevertheless require a substantial engineering effort.</p>
<p> </p>
<p>Finally, in her keynote address on dialogue models, Dilek Hakkani-Tür, Research Scientist at Google Research, argued that over the recent years, chitchat systems and task-oriented dialogue systems have been converging. However, current production systems are essentially a walled garden of domains and only allow directed dialogue and limited personalization. Models have to be learned from developers using a limited set of APIs and tools and are hard to scale. At the same time, conversation is a skill even for humans. It is thus important to learn from real users, not from developers.</p>
<p>In order to learn <i>about</i> users, we can leverage personal knowledge graphs learned from user assertions, such as “show me directions to my daughter’s school”. Semantic recall, i.e. remembering entities from previous user interactions, e.g. “Do you remember the restaurant we ordered Asian food from?” is important. Personalized natural language understanding can also leverage data from user’s device (in a privacy-preserving manner) and employ user modeling for dialogue generation.</p>
<p>For learning <i>from</i> users, actions can be learned from user demonstration and/or explanation or from experience and feedback (mostly using RL for dialogue systems). In both cases, transcription and annotation are bottlenecks. A user can’t be expected to transcribe or annotate data; on the other hand, it is easier to give feedback after the system repeats an utterance.</p>
<p>Generally, task-oriented dialogue can be treated as a game between two parties (see below): the seeker has a goal, which is fixed or flexible, while the provider has access to APIs to perform the task. The dialogue policy of the seeker decides the next seeker action. This is typically determined using “user simulators”, which are often sequence-to-sequence models. Most recently, hierarchical sequence-to-sequence models have been used with a focus on following the user goals and generating diverse responses.</p>
<figure>
      <img src="http://ruder.io/content/images/2018/06/IMG_20180604_091136_task-oriented_dialogue_game.jpg" style="width: 70%" title="Task-oriented dialogue as a game" alt="Highlights of NAACL-HLT 2018: Generalization, Test-of-time, and Dialogue Systems">
<figcaption>Figure 10: Task-oriented dialogue as a game</figcaption>
</figure>
<p>The dialogue policy of the provider similarly determines the next provider action, which is realized either via supervised or reinforcement learning (RL). For RL, reward estimation and policy shaping are important. Recent approaches jointly learn seeker and provider policies. End-to-end dialogue models with deep RL are critical for learning from user feedback, while component-wise training benefits from additional data for each component.</p>
<p>In practice, a combination of supervised and reinforcement learning is best and outperforms both purely supervised learning and supervised learning with policy-only RL as can be seen below.</p>
<figure>
      <img src="http://ruder.io/content/images/2018/06/IMG_20180604_094901_supervised-rl.jpg" style="width: 70%" title="Supervised and reinforcement learning for dialogue modeling" alt="Highlights of NAACL-HLT 2018: Generalization, Test-of-time, and Dialogue Systems">
<figcaption>Figure 11: Supervised and reinforcement learning for dialogue modeling</figcaption>
</figure>
<p>Overall, the conference was a great opportunity to see fantastic research and meet great people. See you all at ACL 2018!</p>
<!--kg-card-end: markdown--><!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[An overview of proxy-label approaches for semi-supervised learning]]></title><description><![CDATA[While unsupervised learning is still elusive, researchers have made a lot of progress in semi-supervised learning. This post focuses on a particular promising category of semi-supervised learning methods that assign proxy labels to unlabelled data, which are used as targets for learning.]]></description><link>http://ruder.io/semi-supervised/</link><guid isPermaLink="false">5c76ff7c1b9b0d18555b9ea7</guid><category><![CDATA[semi-supervised learning]]></category><category><![CDATA[transfer learning]]></category><category><![CDATA[domain adaptation]]></category><dc:creator><![CDATA[Sebastian Ruder]]></dc:creator><pubDate>Thu, 26 Apr 2018 07:00:00 GMT</pubDate><media:content url="http://ruder.io/content/images/2018/10/mttri.png" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><!--kg-card-begin: markdown--><img src="http://ruder.io/content/images/2018/10/mttri.png" alt="An overview of proxy-label approaches for semi-supervised learning"><p>This post discusses semi-supervised learning algorithms that learn from <em>proxy labels</em> assigned to unlabelled data.</p>
<p>Note: Parts of this post are based on my ACL 2018 paper <a href="https://arxiv.org/abs/1804.09530">Strong Baselines for Neural Semi-supervised Learning under Domain Shift</a> with <a href="http://www.let.rug.nl/bplank/">Barbara Plank</a>.</p>
<p>Table of contents:</p>
<ul>
<li><a href="#selftraining">Self-training</a></li>
<li><a href="#multiviewtraining">Multi-view training</a>
<ul>
<li>Co-training</li>
<li>Democratic Co-learning</li>
<li>Tri-training</li>
<li>Tri-training with disagreement</li>
<li>Asymmetric tri-training</li>
<li>Multi-task tri-training</li>
</ul>
</li>
<li><a href="#selfensembling">Self-ensembling</a>
<ul>
<li>Ladder networks</li>
<li>Virtual Adversarial Training</li>
<li>\(\Pi\) model</li>
<li>Temporal Ensembling</li>
<li>Mean Teacher</li>
</ul>
</li>
<li><a href="#relatedmethodsandareas">Related methods and areas</a>
<ul>
<li>Distillation</li>
<li>Learning from weak supervision</li>
<li>Learning with noisy labels</li>
<li>Data augmentation</li>
<li>Ensembling a single model</li>
</ul>
</li>
</ul>
<p>Unsupervised learning constitutes one of the main challenges for current machine learning models and one of the key elements that is missing for <a href="http://ruder.io/highlights-nips-2016/#generalartificialintelligence">general artificial intelligence</a>. While unsupervised learning on its own is still elusive, researchers have a made a lot of progress in <em>combining</em> unsupervised learning with supervised learning. This branch of machine learning research is called semi-supervised learning.</p>
<p>Semi-supervised learning has a long history. For a (slightly outdated) overview, refer to Zhu (2005) <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> and Chapelle et al. (2006) <sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>. Particularly recently, semi-supervised learning has seen some success, considerably reducing the error rate on important benchmarks. Semi-supervised learning also makes an appearance in <a href="https://www.sec.gov/Archives/edgar/data/1018724/000119312518121161/d456916dex991.htm">Amazon's annual letter to shareholders</a> where it is credited with reducing the amount of labelled data needed to achieve the same accuracy improvement by \(40\times\).</p>
<p>In this blog post, I will focus on a particular class of semi-supervised learning algorithms that produce <em>proxy labels</em> on unlabelled data, which are used as targets together with the labelled data. These proxy labels are produced by the model itself or variants of it without any additional supervision; they thus do not reflect the ground truth but might still provide some signal for learning. In a sense, these labels can be considered <em>noisy</em> or <em>weak</em>. I will highlight the connection to learning from noisy labels, weak supervision as well as other related topics in the end of this post.</p>
<p>This class of models is of particular interest in my opinion, as a) deep neural networks have been shown to be good at dealing with noisy labels and b) these models have achieved state-of-the-art in semi-supervised learning for computer vision. Note that many of these ideas are not new and many related methods have been developed in the past. In one half of this post, I will thus cover classic methods and discuss their relevance for current approaches; in the other half, I will discuss techniques that have recently achieved state-of-the-art performance. Some of the following approaches have been referred to as <em>self-teaching</em> or <em>bootstrapping</em> algorithms; I am not aware of a term that captures all of them, so I will simply refer to them as <em>proxy-label</em> methods.</p>
<p>I will divide these methods in three groups, which I will discuss in the following: 1) self-training, which uses a model's own predictions as proxy labels; 2) multi-view learning, which uses the predictions of models trained with different <em>views</em> of the data; and 3) self-ensembling, which ensembles variations of a model's own predictions and uses these as feedback for learning. I will show pseudo-code for the most important algorithms. You can find the LaTeX source <a href="https://github.com/sebastianruder/semi-supervised">here</a>.</p>
<p>There are many interesting and equally important directions for semi-supervised learning that I will not cover in this post, e.g. graph-convolutional neural networks <sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>.</p>
<h2 id="selftraining">Self-training</h2>
<p>Self-training (Yarowsky, 1995; McClosky et al., 2006) <sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup> <sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup> is one of the earliest and simplest approaches to semi-supervised learning and the most straightforward example of how a model's own predictions can be incorporated into training. As the name implies, self-training leverages a model's own predictions on unlabelled data in order to obtain additional information that can be used during training. Typically the most confident predictions are taken at face value, as detailed next.</p>
<p>Formally, self-training trains a model \(m\) on a labeled training set \(L\) and an unlabeled data set \(U\). At each iteration, the model provides predictions \(m(x)\) in the form of a probability distribution over the \(C\) classes for all unlabeled examples \(x\) in \(U\). If the probability assigned to the most likely class is higher than a predetermined threshold \(\tau\), \(x\) is added to the labeled examples with \(\DeclareMathOperator*{\argmax}{argmax} p(x) = \argmax m(x)\) as pseudo-label. This process is generally repeated for a fixed number of iterations or until no more predictions on unlabelled examples are confident. This instantiation is the most widely used and shown in Algorithm 1.<br>
<img src="http://ruder.io/content/images/2018/03/self-training.png" alt="An overview of proxy-label approaches for semi-supervised learning"><br>
Classic self-training has shown mixed success. In parsing it proved successful with small datasets (Reichart, and Rappoport, 2007; Huang and Harper, 2009) <sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup> <sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup> or when a generative component is used together with a reranker when more data is available (McClosky et al., 2006; Suzuki and Isozaki , 2008) <sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup>. Some success was achieved with careful task-specific data selection (Petrov and McDonald, 2012) <sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup>, while others report limited success on a variety of NLP tasks (He and Zhou, 2011; Plank, 2011; Van Asch and Daelemans, 2016; van der Goot et al., 2017) <sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup> <sup class="footnote-ref"><a href="#fn11" id="fnref11">[11]</a></sup> <sup class="footnote-ref"><a href="#fn12" id="fnref12">[12]</a></sup> <sup class="footnote-ref"><a href="#fn13" id="fnref13">[13]</a></sup>.</p>
<p>The main downside of self-training is that the model is unable to correct its own mistakes. If the model's predictions on unlabelled data are confident but wrong, the erroneous data is nevertheless incorporated into training and the model's errors are amplified. This effect is exacerbated if the domain of the unlabelled data is different from that of the labelled data; in this case, the model's confidence will be a poor predictor of its performance.</p>
<h2 id="multiviewtraining">Multi-view training</h2>
<p>Multi-view training aims to train different models with different <em>views</em> of the data. Ideally, these views complement each other and the models can collaborate in improving each other's performance. These views can differ in different ways such as in the features they use, in the architectures of the models, or in the data on which the models are trained.</p>
<p><strong>Co-training</strong>   Co-training (Blum and Mitchell, 1998) <sup class="footnote-ref"><a href="#fn14" id="fnref14">[14]</a></sup> is a classic multi-view training method, which makes comparatively strong assumptions. It requires that the data \(L\) can be represented using two conditionally independent feature sets \(L^1\) and \(L^2\) and that each feature set is sufficient to train a good model. After the initial models \(m_1\) and \(m_2\) are trained on their respective feature sets, at each iteration, only inputs that are confident (i.e. have a probability higher than a threshold \(\tau\)) according to <em>exactly one</em> of the two models are moved to the training set of <em>the other</em> model. One model thus provides the labels to the inputs on which the <em>other</em> model is uncertain. Co-training can be seen in Algorithm 2.<br>
<img src="http://ruder.io/content/images/2018/04/co-training.png" alt="An overview of proxy-label approaches for semi-supervised learning"><br>
In the original co-training paper (Blum and Mitchell, 1998), co-training is used to classify web pages using the text on the page as one view and the anchor text of hyperlinks on other pages pointing to the page as the other view. As two conditionally independent views are not always available, Chen et al. (2011) <sup class="footnote-ref"><a href="#fn15" id="fnref15">[15]</a></sup> propose pseudo-multiview regularization (Chen et al., 2011) in order to split the features into two mutually exclusive views so that co-training is effective. To this end, pseudo-multiview regularization constrains the models so that at least one of them has a zero weight for each feature. This is similar to the orthogonality constraint recently used in domain adaptation to encourage shared and private spaces (Bousmalis et al., 2016) <sup class="footnote-ref"><a href="#fn16" id="fnref16">[16]</a></sup>. A second constraint requires the models to be confident on different subsets of \(U\). Chen et al. (2011) <sup class="footnote-ref"><a href="#fn17" id="fnref17">[17]</a></sup> use pseudo-multiview regularization to adapt co-training to domain adaptation.</p>
<p><strong>Democratic Co-learning</strong> Rather than treating different feature sets as views, democratic co-learning (Zhou and Goldman, 2004) <sup class="footnote-ref"><a href="#fn18" id="fnref18">[18]</a></sup> employs models with <em>different inductive biases</em>. These can be different network architectures in the case of neural networks or completely different learning algorithms. Democratic co-learning first trains each model separately on the complete labelled data \(L\). The models then make predictions on the unlabelled data \(U\). If a majority of models confidently agree on the label of an example, the example is added to the labelled dataset. Confidence is measured in the original formulation by measuring if the sum of the mean confidence intervals \(w\) of the models, which agreed on the label is larger than the sum of the models that disagreed. This process is repeated until no more examples are added. The final prediction is made with a majority vote weighted with the confidence intervals of the models. The full algorithm can be seen below. \(M\) is the set of all models that predict the same label \(j\) for an example \(x\).<br>
<img src="http://ruder.io/content/images/2018/04/democratic_co-learning-2.png" alt="An overview of proxy-label approaches for semi-supervised learning"><br>
<strong>Tri-training</strong>   Tri-training (Zhou and Li, 2005) <sup class="footnote-ref"><a href="#fn19" id="fnref19">[19]</a></sup> is one of the best known multi-view training   methods. It can be seen as an instantiation of democratic co-learning, which leverages the agreement of three independently trained models to reduce the bias of predictions on unlabeled data. The main requirement for tri-training is that the initial models are diverse. This can be achieved using different model architectures as in democratic co-learning. The most common way to obtain diversity for tri-training, however, is to obtain different variations \(S_i\) of the original training data \(L\) using bootstrap sampling. The three models \(m_1\), \(m_2\), and \(m_3\) are then trained on these bootstrap samples, as depicted in Algorithm 4. An unlabeled data point is added to the training set of a model \(m_i\) if the other two models \(m_j\) and \(m_k\) agree on its label. Training stops when the classifiers do not change anymore.<br>
<img src="http://ruder.io/content/images/2018/04/tri-training.png" alt="An overview of proxy-label approaches for semi-supervised learning"><br>
Despite having been proposed more than 10 years ago, before the advent of Deep Learning, we found in a <a href="https://arxiv.org/abs/1804.09530">recent paper</a> (Ruder and Plank, 2018) <sup class="footnote-ref"><a href="#fn20" id="fnref20">[20]</a></sup> that classic tri-training is a strong baseline for neural semi-supervised with and without domain shift for NLP and that it outperforms even recent state-of-the-art methods.</p>
<p><strong>Tri-training with disagreement</strong>   Tri-training <em>with disagreement</em> (Søgaard, 2010) <sup class="footnote-ref"><a href="#fn21" id="fnref21">[21]</a></sup> is based on the intuition that a model should only be strengthened in its weak points and that the labeled data should not be skewed by easy data points. In order to achieve this, it adds a simple modification to the original algorithm (altering line 8 in Algorithm 2), requiring that for an unlabeled data point on which \(m_j\) and \(m_k\) <em>agree</em>, the other model \(m_i\) <em>disagrees</em> on the prediction. Tri-training with disagreement is more data-efficient than tri-training and has achieved competitive results on part-of-speech tagging (Søgaard, 2010).</p>
<p><strong>Asymmetric tri-training</strong>   Asymmetic tri-training (Saito et al., 2017) <sup class="footnote-ref"><a href="#fn22" id="fnref22">[22]</a></sup> is a recently proposed extension of tri-training that achieved state-of-the-art results for unsupervised domain adaptation in computer vision. For unsupervised domain adaptation, the test data and unlabeled data are from a different domain than the labelled examples. To adapt tri-training to this shift, asymmetric tri-training learns one of the models <em>only</em> on proxy labels and not on labelled examples (a change to line 10 in Algorithm 4) and uses only this model to classify target domain examples at test time. In addition, all three models share the same feature extractor.</p>
<p><strong>Multi-task tri-training</strong>   Tri-training typically relies on training separate models on bootstrap samples of a potentially large amount of training data, which is expensive. Multi-task tri-training (MT-Tri) (Ruder and Plank, 2018) aims to reduce both the time and space complexity of tri-training by leveraging insights from multi-task learning (MTL) (Caruana, 1993) <sup class="footnote-ref"><a href="#fn23" id="fnref23">[23]</a></sup> to share knowledge across models and accelerate training. Rather than storing and training each model separately, MT-Tri shares the parameters of the models and trains them jointly using MTL. Note that the model does only <em>pseudo</em> MTL as all three models effectively perform the same task.</p>
<p>The output softmax layers are model-specific and are only updated for the input of the respective model. As the models leverage a joint representation, diversity is even more crucial. We need to ensure that the features used for prediction in the softmax layers of the different models are as diverse as possible, so that the models can still learn from each other's predictions. In contrast, if the parameters in all output softmax layers were the same, the method would degenerate to self-training. Similar to pseudo-view regularization, we thus use an orthogonality constraint (Bousmalis et al., 2016) on two of the three softmax output layers as an additional loss term.</p>
<p>The pseudo-code can be seen below. In contrast to classic tri-training, we can train the multi-task model with its three model-specific outputs jointly and <em>without</em> bootstrap sampling on the labeled source domain data until convergence, as the orthogonality constraint enforces different representations between models \(m_1\) and \(m_2\). From this point, we can leverage the pair-wise agreement of two output layers to add pseudo-labeled examples as training data to the third model. We train the third output layer \(m_3\) only on pseudo-labeled target instances in order to make tri-training more robust to a domain shift. For the final prediction, we use majority voting of all three output layers. For more information about multi-task tri-training, self-training, other tri-training variants, you can refer to our recent <a href="https://arxiv.org/abs/1804.09530">ACL 2018 paper</a>.<br>
<img src="http://ruder.io/content/images/2018/04/multi-task_tri-training-1.png" alt="An overview of proxy-label approaches for semi-supervised learning"></p>
<h2 id="selfensembling">Self-ensembling</h2>
<p>Self-ensembling methods are very similar to multi-view learning approaches in that they combine different variants of a model. Multi-task tri-training, for instance, can also be seen as a self-ensembling method where different variations of a model are used to create a stronger ensemble prediction. In contrast to multi-view learning, diversity is not a key concern. Self-ensembling approaches mostly use a single model under different configurations in order to make the model's predictions more robust. Most of the following methods are very recent and several have achieved state-of-the-art results in computer vision.</p>
<p><strong>Ladder networks</strong>   The \(\Gamma\) (gamma) version of Ladder Networks (Rasmus et al., 2015) <sup class="footnote-ref"><a href="#fn24" id="fnref24">[24]</a></sup> aims to make a model more robust to noise. For each unlabelled example, it uses the model's prediction on the clean example as a proxy label for prediction on a perturbed version of the example. This way, the model learns to develop features that are invariant to noise and predictive of the labels on the labelled training data. Ladder networks have been mostly used in computer vision where many forms of perturbation and data augmentation are available.</p>
<p><strong>Virtual Adversarial Training</strong>   If perturbing the original sample is not possible or desired, we can instead perturb the example in feature space. Rather than randomly perturbing it by e.g. adding dropout, we can apply the <em>worst possible</em> perturbation for the model, which transforms the input into an adversarial sample. While adversarial training requires access to the labels to perform these perturbations, <em>virtual</em> adversarial training (Miyato et al., 2017) <sup class="footnote-ref"><a href="#fn25" id="fnref25">[25]</a></sup> requires no labels and is thus suitable for semi-supervised learning. Virtual adversarial training effectively seeks to make the model robust to perturbations in directions to which it is most sensitive and has achieved good results on text classification datasets.</p>
<p><strong>\(\Pi\) model</strong>   Rather than treating clean predictions as proxy labels, the \(\Pi\) (pi) model (Laine and Aila, 2017) <sup class="footnote-ref"><a href="#fn26" id="fnref26">[26]</a></sup> ensembles the predictions of the model under two different perturbations of the input data and two different dropout conditions \(z\) and \(\tilde{z}\). The full pseudo-code can be seen in Algorithm 6 below. \(g(x)\) is the stochastic input augmentation function. The first loss term encourages the predictions under the two different noise settings to be consistent, with \(\lambda\) determining the contribution, while the second loss term is the standard cross-entropy loss \(H\) with respect to the label \(y\). In contrast to the models we encountered before, we apply the unsupervised loss component to both unlabelled and labelled examples.<br>
<img src="http://ruder.io/content/images/2018/04/pi-model-3.png" alt="An overview of proxy-label approaches for semi-supervised learning"><br>
<strong>Temporal Ensembling</strong>   Instead of ensembling over the same model under different noise configurations, we can ensemble over different models. As training separate models is expensive, we can instead ensemble the predictions of a model <em>at different timesteps</em>. We can save the ensembled proxy labels \(Z\) as an exponential moving average of the model's past predictions on all examples as depicted below in order to save space. As we initialize the proxy labels as a zero vector, they are biased towards \(0\). We can correct this bias similar to Adam (Kingma and Ba, 2015) <sup class="footnote-ref"><a href="#fn27" id="fnref27">[27]</a></sup> based on the current epoch \(t\) to obtain bias-corrected target vectors \(\tilde{z}\). We then update the model similar to the \(\Pi\) model.<br>
<img src="http://ruder.io/content/images/2018/04/temporal_ensembling-3.png" alt="An overview of proxy-label approaches for semi-supervised learning"></p>
<p><strong>Mean Teacher</strong>   Finally, instead of averaging the <em>predictions</em> of our model over training time, we can average the model weights. Mean teacher (Tarvainen and Valpola, 2017) <sup class="footnote-ref"><a href="#fn28" id="fnref28">[28]</a></sup> stores an exponential moving average of the model parameters. For every example, this mean teacher model is then used to obtain proxy labels \(\tilde{z}\). The consistency loss and supervised loss are computed as in temporal ensembling.</p>
<p>Mean teacher has achieved state-of-the-art results for semi-supervised learning for computer vision. For reference, on ImageNet with 10% of the labels, it achieves an error rate of \(9.11\), compared to an error rate of \(3.79\) using <em>all</em> labels with the state-of-the-art. For more information about self-ensembling methods, have a look at <a href="https://thecuriousaicompany.com/mean-teacher/">this intuitive blog post</a> by the Curious AI company. We have run experiments with temporal ensembling for NLP tasks, but did not manage to obtain consistent results. My assumption is that the unsupervised consistency loss is more suitable for continuous inputs. Mean teacher might work better, as averaging weights aka Polyak averaging (Polyak and Juditsky, 1992) <sup class="footnote-ref"><a href="#fn29" id="fnref29">[29]</a></sup> is a tried method for accelerating optimization.</p>
<p>Very recently, Oliver et al. (2018) <sup class="footnote-ref"><a href="#fn30" id="fnref30">[30]</a></sup> raise some questions regarding the true applicability of these methods: They find that the performance difference to a properly tuned supervised baseline is smaller than typically reported, that transfer learning from a labelled dataset (e.g. ImageNet) outperforms the presented methods, and that performance degrades severely under a domain shift. In order to deal with the latter, algorithms such as asymmetric or multi-task tri-training learn different representations for the target distribution. It remains to be seen if these insights translate to other domains; a combination of transfer learning and semi-supervised adaptation to the target domain seems particularly promising.</p>
<h2 id="relatedmethodsandareas">Related methods and areas</h2>
<p><strong>Distillation</strong>   Proxy-label approaches can be seen as different forms of distillation (Hinton et al., 2015) <sup class="footnote-ref"><a href="#fn31" id="fnref31">[31]</a></sup>. Distillation was originally conceived as a method to compress the information of a large model or an ensemble in a smaller model. In the standard setup, a typically large and fully trained <em>teacher</em> model provides proxy targets for a <em>student</em> model, which is generally smaller and faster. Self-learning is akin to distillation without a teacher, where the student is left to learn by themselves and with no-one to correct its mistakes. For multi-view learning, different models work together to teach each other, alternately acting as both teachers and students. Self-ensembling, finally, has one model assuming the dual role of teacher and student: As a teacher, it generates new targets, which are then incorporated by itself as a student for learning.</p>
<p><strong>Learning from weak supervision</strong>   Learning from weak supervision, as the name implies, can be seen as a weaker form of supervised learning or alternatively as a stronger form of semi-supervised learning: While supervised learning provides us with labels that we know to be correct and semi-supervised learning only provides us with a small set of labelled examples, weak supervision allows us to obtain labels that we know to be noisy for the unlabelled data as a further signal for learning. Typically, the weak annotator is an unsupervised method that is very different from the model we use for learning the task. For sentiment analysis, this could be a simple lexicon-based method <sup class="footnote-ref"><a href="#fn32" id="fnref32">[32]</a></sup>. Many of the presented methods could be extended to the weak supervision setting by incorporating the weak labels as feedback. Self-ensembling methods, for instance, might employ another teacher model that gauges the quality of weakly annotated examples similar to Deghani et al. (2018) <sup class="footnote-ref"><a href="#fn33" id="fnref33">[33]</a></sup>. For an overview of weak supervision, have a look at <a href="https://hazyresearch.github.io/snorkel/blog/ws_blog_post.html">this blog post</a> by Stanford's Hazy Research group.</p>
<p><strong>Learning with noisy labels</strong>   Learning with noisy labels is similar to learning from weak supervision. In both cases, labels are available that cannot be completely trusted. For learning with noisy labels, labels are typically assumed to be permuted with a fixed random permutation. While proxy-label approaches supply the noisy labels themselves, when learning with noisy labels, the labels are part of the data. Similar to learning from weak supervision, we can try to model the noise to assess the quality of the labels (Sukhbaatar et al., 2015) <sup class="footnote-ref"><a href="#fn34" id="fnref34">[34]</a></sup>. Similar to self-ensembling methods, we can enforce consistency between the model's preditions and the proxy labels (Reed et al., 2015) <sup class="footnote-ref"><a href="#fn35" id="fnref35">[35]</a></sup>.</p>
<p><strong>Data augmentation</strong>   Several self-ensembling methods employ data augmentation to enforce consistency between model predictions under different noise settings. Data augmentation is mostly used in computer vision, but  noise in the form of different dropout masks can also be applied to the model parameters as in the \(\Pi\) model and has also been used in LSTMs (Zolna et al., 2018) <sup class="footnote-ref"><a href="#fn36" id="fnref36">[36]</a></sup>. While regularization in the form of dropout, batch normalization, etc. can be used when labels are available in order to make predictions more robust, a consistency loss is required in the case without labels. For supervised learning, adversarial training can be employed to obtain adversarial examples and has been used successfully e.g. for part-of-speech tagging (Yasunaga et al., 2018) <sup class="footnote-ref"><a href="#fn37" id="fnref37">[37]</a></sup>.</p>
<p><strong>Ensembling a single model</strong>   The discussed self-ensembling methods all employ ensemble predictions not just to make predictions more robust, but as feedback to improve the model itself during training in a self-reinforcing loop. In the supervised setting, this feedback might not be necessary; ensembling a single model is still useful, however, to save time compared to training multiple models. Two methods that have been proposed to ensemble a model from a single training run are checkpoint ensembles and snapshot ensembles. Checkpoint ensembles (Sennrich et al., 2016) <sup class="footnote-ref"><a href="#fn38" id="fnref38">[38]</a></sup> ensemble the last \(n\) checkpoints of a single training run and have been used to achieve state-of-the-art in machine translation. Snapshot ensembles (Huang et al., 2017) <sup class="footnote-ref"><a href="#fn39" id="fnref39">[39]</a></sup> ensemble models converged to different minima during a training run and have been used to achieve state-of-the-art in object recognition.</p>
<h2 id="conclusion">Conclusion</h2>
<p>I hope this post was able to give you an insight into a part of the semi-supervised learning landscape that seems to be particularly useful to improve the performance of current models. While learning completely without labelled data is unrealistic at this point, semi-supervised learning enables us to augment our small labelled datasets with large amounts of available unlabelled data. Most of the discussed methods are promising in that they treat the model as a black box and can thus be used with any existing supervised learning model. As always, if you have any questions or noticed any mistakes, feel free to write a comment in the comments section below.</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>Zhu, X. (2005). Semi-Supervised Learning Literature Survey. <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>Chapelle, O., Schölkopf, B., &amp; Zien, A. (2006). Semi-Supervised Learning. Interdisciplinary sciences computational life sciences (Vol. 1). <a href="http://doi.org/10.1007/s12539-009-0016-2">http://doi.org/10.1007/s12539-009-0016-2</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>Kipf, T. N., &amp; Welling, M. (2017). Semi-Supervised Classification with Graph Convolutional Networks. Proceedings of ICLR 2017. <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>Yarowsky, D. (1995). Unsupervised word sense disambiguation rivaling supervised methods. In Proceedings of the 33rd annual meeting on Association for Computational Linguistics (pp. 189-196). Association for Computational Linguistics. <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>McClosky, D., Charniak, E., &amp; Johnson, M. (2006). Effective self-training for parsing. Proceedings of the Main Conference on Human Language Technology Conference of the North American Chapter of the Association of Computational Linguistics, 152–159. <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p>Reichart, R., &amp; Rappoport, A. (2007). Self-training for enhancement and domain adaptation of statistical parsers trained on small datasets. In Proceedings of the 45th Annual Meeting of the Association of Computational Linguistics (pp. 616-623) <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p>Huang, Z., &amp; Harper, M. (2009). Self-training PCFG grammars with latent annotations across languages. In Proceedings of the 2009 Conference on Empirical Methods in Natural Language Processing: Volume 2-Volume 2 (pp. 832-841). Association for Computational Linguistics. <a href="#fnref7" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn8" class="footnote-item"><p>Suzuki, J., &amp; Isozaki, H. (2008). Semi-supervised sequential labeling and segmentation using giga-word scale unlabeled data. Proceedings of ACL-08: HLT, 665-673. <a href="#fnref8" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn9" class="footnote-item"><p>Petrov, S., &amp; McDonald, R. (2012). Overview of the 2012 shared task on parsing the web. In Notes of the first workshop on syntactic analysis of non-canonical language (sancl) (Vol. 59). <a href="#fnref9" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn10" class="footnote-item"><p>He, Y., &amp; Zhou, D. (2011). Self-training from labeled features for sentiment analysis. Information Processing &amp; Management, 47(4), 606-616. <a href="#fnref10" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn11" class="footnote-item"><p>Plank, B. (2011). Domain adaptation for parsing. University Library Groniongen][Host]. <a href="#fnref11" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn12" class="footnote-item"><p>Van Asch, V., &amp; Daelemans, W. (2016). Predicting the Effectiveness of Self-Training: Application to Sentiment Classification. arXiv preprint arXiv:1601.03288. <a href="#fnref12" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn13" class="footnote-item"><p>van der Goot, R., Plank, B., &amp; Nissim, M. (2017). To normalize, or not to normalize: The impact of normalization on part-of-speech tagging. arXiv preprint arXiv:1707.05116. <a href="#fnref13" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn14" class="footnote-item"><p>Blum, A., &amp; Mitchell, T. (1998). Combining labeled and unlabeled data with co-training. In Proceedings of the eleventh annual conference on Computational learning theory (pp. 92-100). ACM. <a href="#fnref14" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn15" class="footnote-item"><p>Chen, M., Weinberger, K. Q., &amp; Chen, Y. (2011). Automatic Feature Decomposition for Single View Co-training. Proceedings of the 28th International Conference on Machine Learning (ICML-11), 953–960. <a href="#fnref15" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn16" class="footnote-item"><p>Bousmalis, K., Trigeorgis, G., Silberman, N., Krishnan, D., &amp; Erhan, D. (2016). Domain Separation Networks. In Advances in Neural Information Processing Systems. <a href="#fnref16" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn17" class="footnote-item"><p>Chen, M., Weinberger, K. Q., &amp; Blitzer, J. C. (2011). Co-Training for Domain Adaptation. In Advances in Neural Information Processing Systems. <a href="#fnref17" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn18" class="footnote-item"><p>Zhou, Y., &amp; Goldman, S. (2004). Democratic Co-Learning. In 16th IEEE International Conference on Tools with Artificial Intelligence, ICTAI 2004. <a href="#fnref18" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn19" class="footnote-item"><p>Zhou, Z.-H., &amp; Li, M. (2005). Tri-Training: Exploiting Unlabled Data Using Three Classifiers. IEEE Trans.Data Eng., 17(11), 1529–1541. <a href="http://doi.org/10.1109/TKDE.2005.186">http://doi.org/10.1109/TKDE.2005.186</a> <a href="#fnref19" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn20" class="footnote-item"><p>Ruder, S., &amp; Plank, B. (2018). Strong Baselines for Neural Semi-supervised Learning under Domain Shift. In Proceedings of ACL 2018. <a href="#fnref20" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn21" class="footnote-item"><p>Søgaard, A. (2010). Simple semi-supervised training of part-of-speech taggers. Proceedings of the ACL 2010 Conference Short Papers. <a href="#fnref21" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn22" class="footnote-item"><p>Saito, K., Ushiku, Y., &amp; Harada, T. (2017). Asymmetric Tri-training for Unsupervised Domain Adaptation. In ICML 2017. Retrieved from <a href="http://arxiv.org/abs/1702.08400">http://arxiv.org/abs/1702.08400</a> <a href="#fnref22" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn23" class="footnote-item"><p>Caruana, R. (1993). Multitask learning: A knowledge-based source of inductive bias. In Proceedings of the Tenth International Conference on Machine Learning. <a href="#fnref23" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn24" class="footnote-item"><p>Rasmus, A., Valpola, H., Honkala, M., Berglund, M., &amp; Raiko, T. (2015). Semi-Supervised Learning with Ladder Network. arXiv Preprint arXiv:1507.02672. Retrieved from <a href="http://arxiv.org/abs/1507.02672">http://arxiv.org/abs/1507.02672</a> <a href="#fnref24" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn25" class="footnote-item"><p>Miyato, T., Dai, A. M., &amp; Goodfellow, I. (2017). Adversarial Training Methods for Semi-supervised Text Classification. In Proceedings of ICLR 2017. <a href="#fnref25" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn26" class="footnote-item"><p>Laine, S., &amp; Aila, T. (2017). Temporal Ensembling for Semi-Supervised Learning. In Proceedings of ICLR 2017. <a href="#fnref26" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn27" class="footnote-item"><p>Kingma, D. P., &amp; Ba, J. L. (2015). Adam: a Method for Stochastic Optimization. International Conference on Learning Representations. <a href="#fnref27" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn28" class="footnote-item"><p>Tarvainen, A., &amp; Valpola, H. (2017). Mean teachers are better role models: Weight-averaged consistency targets improve semi-supervised deep learning results. In Advances in Neural Information Processing Systems. Retrieved from <a href="http://arxiv.org/abs/1703.01780">http://arxiv.org/abs/1703.01780</a> <a href="#fnref28" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn29" class="footnote-item"><p>Polyak, B. T., &amp; Juditsky, A. B. (1992). Acceleration of stochastic approximation by averaging. SIAM Journal on Control and Optimization, 30(4), 838-855. <a href="#fnref29" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn30" class="footnote-item"><p>Oliver, A., Odena, A., Raffel, C., Cubuk, E. D., &amp; Goodfellow, I. J. (2018). Realistic Evaluation of Semi-Supervised Learning Algorithms. arXiv preprint arXiv:1804.09170. <a href="#fnref30" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn31" class="footnote-item"><p>Hinton, G., Vinyals, O., &amp; Dean, J. (2015). Distilling the Knowledge in a Neural Network. arXiv Preprint arXiv:1503.02531. <a href="https://doi.org/10.1063/1.4931082">https://doi.org/10.1063/1.4931082</a> <a href="#fnref31" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn32" class="footnote-item"><p>Kiritchenko, S., Zhu, X., &amp; Mohammad, S. M. (2014). Sentiment analysis of short informal texts. Journal of Artificial Intelligence Research, 50, 723-762. <a href="#fnref32" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn33" class="footnote-item"><p>Dehghani, M., Mehrjou, A., Gouws, S., Kamps, J., &amp; Schölkopf, B. (2018). Fidelity-Weighted Learning. In Proceedings of ICLR 2018. Retrieved from <a href="http://arxiv.org/abs/1711.02799">http://arxiv.org/abs/1711.02799</a> <a href="#fnref33" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn34" class="footnote-item"><p>Sukhbaatar, S., Bruna, J., Paluri, M., Bourdev, L., &amp; Fergus, R. (2015). Training Convolutional Networks with Noisy Labels. Workshop Track - ICLR 2015. Retrieved from <a href="http://arxiv.org/abs/1406.2080">http://arxiv.org/abs/1406.2080</a> <a href="#fnref34" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn35" class="footnote-item"><p>Reed, S., Lee, H., Anguelov, D., Szegedy, C., Erhan, D., &amp; Rabinovich, A. (2015). Training Deep Neural Networks on Noisy Labels with Bootstrapping. ICLR 2015 Workshop Track. Retrieved from <a href="http://arxiv.org/abs/1412.6596">http://arxiv.org/abs/1412.6596</a> <a href="#fnref35" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn36" class="footnote-item"><p>Zolna, K., Arpit, D., Suhubdy, D., &amp; Bengio, Y. (2018). Fraternal Dropout. In Proceedings of ICLR 2018. Retrieved from <a href="http://arxiv.org/abs/1711.00066">http://arxiv.org/abs/1711.00066</a> <a href="#fnref36" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn37" class="footnote-item"><p>Yasunaga, M., Kasai, J., &amp; Radev, D. (2018). Robust Multilingual Part-of-Speech Tagging via Adversarial Training. In Proceedings of NAACL 2018. Retrieved from <a href="http://arxiv.org/abs/1711.04903">http://arxiv.org/abs/1711.04903</a> <a href="#fnref37" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn38" class="footnote-item"><p>Sennrich, R., Haddow, B., &amp; Birch, A. (2016). Edinburgh neural machine translation systems for WMT 16. arXiv preprint arXiv:1606.02891. <a href="#fnref38" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn39" class="footnote-item"><p>Huang, G., Li, Y., Pleiss, G., Liu, Z., Hopcroft, J. E., &amp; Weinberger, K. Q. (2017). Snapshot Ensembles: Train 1, get M for free. In Proceedings of ICLR 2017. <a href="#fnref39" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
<!--kg-card-end: markdown--><!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[Text Classification with TensorFlow Estimators]]></title><description><![CDATA[This post is a tutorial that shows how to use Tensorflow Estimators for text classification. It covers loading data using Datasets, using pre-canned estimators as baselines, word embeddings, and building custom estimators, among others.]]></description><link>http://ruder.io/text-classification-tensorflow-estimators/</link><guid isPermaLink="false">5c76ff7c1b9b0d18555b9ea9</guid><category><![CDATA[tensorflow]]></category><category><![CDATA[natural language processing]]></category><dc:creator><![CDATA[Sebastian Ruder]]></dc:creator><pubDate>Mon, 16 Apr 2018 13:24:29 GMT</pubDate><media:content url="http://ruder.io/content/images/2018/10/estimators_loss.png" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><!--kg-card-begin: markdown--><img src="http://ruder.io/content/images/2018/10/estimators_loss.png" alt="Text Classification with TensorFlow Estimators"><p>This post is a tutorial on how to use TensorFlow Estimators for text classification.</p>
<p><em>Note: This post was written together with the awesome <a href="https://twitter.com/eisenjulian">Julian Eisenschlos</a> and was originally published on the <a href="https://medium.com/tensorflow/classifying-text-with-tensorflow-estimators-a99603033fbe">TensorFlow blog</a>.</em></p>
<p>Hello there! Throughout this post we will show you how to classify text using Estimators in TensorFlow. Here’s the outline of what we’ll cover:</p>
<ul>
<li>Loading data using Datasets.</li>
<li>Building baselines using pre-canned estimators.</li>
<li>Using word embeddings.</li>
<li>Building custom estimators with convolution and LSTM layers.</li>
<li>Loading pre-trained word vectors.</li>
<li>Evaluating and comparing models using TensorBoard.</li>
</ul>
<hr>
<p>Welcome to Part 4 of a blog series that introduces TensorFlow Datasets and Estimators. You don’t need to read all of the previous material, but take a look if you want to refresh any of the following concepts. <a href="https://developers.googleblog.com/2017/09/introducing-tensorflow-datasets.html">Part 1</a> focused on pre-made Estimators, <a href="https://developers.googleblog.com/2017/11/introducing-tensorflow-feature-columns.html">Part 2</a> discussed feature columns, and <a href="https://developers.googleblog.com/2017/12/creating-custom-estimators-in-tensorflow.html">Part 3</a> how to create custom Estimators.</p>
<p>Here in Part 4, we will build on top of all the above to tackle a different family of problems in Natural Language Processing (NLP). In particular, this article demonstrates how to solve a text classification task using custom TensorFlow estimators, embeddings, and the <a href="https://www.tensorflow.org/api_docs/python/tf/layers">tf.layers</a> module. Along the way, we’ll learn about word2vec and transfer learning as a technique to bootstrap model performance when labeled data is a scarce resource.</p>
<p>We will show you relevant code snippets. <a href="https://github.com/eisenjulian/nlp_estimator_tutorial/blob/master/nlp_estimators.ipynb">Here</a>’s the complete Jupyter Notebook  that you can run locally or on <a href="https://colab.research.google.com/drive/1oXjNYSJ3VsRvAsXN4ClmtsVEgPW_CX_c?hl=en#forceEdit=true&offline=true&sandboxMode=true">Google Colaboratory</a>. The plain <code>.py</code>  source file is also available <a href="https://github.com/eisenjulian/nlp_estimator_tutorial/blob/master/nlp_estimators.py">here</a>. Note that the code was written to demonstrate how Estimators work functionally and was not optimized for maximum performance.</p>
<h3 id="the-task">The task</h3>
<p>The dataset we will be using is the IMDB <a href="http://ai.stanford.edu/~amaas/data/sentiment/">Large Movie Review Dataset</a>, which consists of <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mn>5</mn><mo separator="true">,</mo><mn>0</mn><mn>0</mn><mn>0</mn></mrow><annotation encoding="application/x-tex">25,000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.83888em; vertical-align: -0.19444em;"></span><span class="base"><span class="mord mathrm">2</span><span class="mord mathrm">5</span><span class="mpunct">,</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span></span></span></span></span> highly polar movie reviews for training, and <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mn>5</mn><mo separator="true">,</mo><mn>0</mn><mn>0</mn><mn>0</mn></mrow><annotation encoding="application/x-tex">25,000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.83888em; vertical-align: -0.19444em;"></span><span class="base"><span class="mord mathrm">2</span><span class="mord mathrm">5</span><span class="mpunct">,</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span></span></span></span></span> for testing. We will use this dataset to train a binary classification model, able to predict whether a review is positive or negative.</p>
<p>For illustration, here’s a piece of a negative review (with <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base"><span class="mord mathrm">2</span></span></span></span></span> stars) in the dataset:</p>
<blockquote>
<p>Now, I LOVE Italian horror films. The cheesier they are, the better. However, this is not cheesy Italian. This is week-old spaghetti sauce with rotting meatballs. It is amateur hour on every level. There is no suspense, no horror, with just a few drops of blood scattered around to remind you that you are in fact watching a horror film.</p>
</blockquote>
<p><em>Keras</em> provides a convenient handler for importing the dataset which is also available as a serialized numpy array <code>.npz</code> file to download <a href="https://s3.amazonaws.com/text-datasets/imdb.npz">here</a>. For text classification, it is standard to limit the size of the vocabulary to prevent the dataset from becoming too sparse and high dimensional, causing potential overfitting. For this reason, each review consists of a series of word indexes that go from <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base"><span class="mord mathrm">4</span></span></span></span></span> (the most frequent word in the dataset <strong>the</strong>) to <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn><mn>9</mn><mn>9</mn><mn>9</mn></mrow><annotation encoding="application/x-tex">4999</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base"><span class="mord mathrm">4</span><span class="mord mathrm">9</span><span class="mord mathrm">9</span><span class="mord mathrm">9</span></span></span></span></span>, which corresponds to <strong>orange</strong>. Index <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base"><span class="mord mathrm">1</span></span></span></span></span> represents the beginning of the sentence and the index <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base"><span class="mord mathrm">2</span></span></span></span></span> is assigned to all unknown (also known as <em>out-of-vocabulary</em> or <em>OOV</em>) tokens. These indexes have been obtained by pre-processing the text data in a pipeline that cleans, normalizes and tokenizes each sentence first and then builds a dictionary indexing each of the tokens by frequency.</p>
<p>After we’ve loaded the data in memory we pad each of the sentences with $0$ so that we have two $25000 \times 200$ arrays for training and testing respectively.</p>
<pre class=" language-python"><code class="prism  language-python">vocab_size <span class="token operator">=</span> <span class="token number">5000</span>
sentence_size <span class="token operator">=</span> <span class="token number">200</span>
<span class="token punctuation">(</span>x_train_variable<span class="token punctuation">,</span> y_train<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>x_test_variable<span class="token punctuation">,</span> y_test<span class="token punctuation">)</span> <span class="token operator">=</span> imdb<span class="token punctuation">.</span>load_data<span class="token punctuation">(</span>num_words<span class="token operator">=</span>vocab_size<span class="token punctuation">)</span>
x_train <span class="token operator">=</span> sequence<span class="token punctuation">.</span>pad_sequences<span class="token punctuation">(</span>
    x_train_variable<span class="token punctuation">,</span> 
    maxlen<span class="token operator">=</span>sentence_size<span class="token punctuation">,</span> 
    padding<span class="token operator">=</span><span class="token string">'post'</span><span class="token punctuation">,</span> 
    value<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>
x_test <span class="token operator">=</span> sequence<span class="token punctuation">.</span>pad_sequences<span class="token punctuation">(</span>
    x_test_variable<span class="token punctuation">,</span>
    maxlen<span class="token operator">=</span>sentence_size<span class="token punctuation">,</span> 
    padding<span class="token operator">=</span><span class="token string">'post'</span><span class="token punctuation">,</span> 
    value<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>
</code></pre>
<h3 id="input-functions">Input Functions</h3>
<p>The Estimator framework uses <em>input functions</em> to split the data pipeline from the model itself. Several helper methods are available to create them, whether your data is in a <code>.csv</code> file, or in a <code>pandas.DataFrame</code>, whether it fits in memory or not. In our case, we can use <code>Dataset.from_tensor_slices</code> for both the train and test sets.</p>
<pre class=" language-python"><code class="prism  language-python">x_len_train <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token builtin">min</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> sentence_size<span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> x_train_variable<span class="token punctuation">]</span><span class="token punctuation">)</span>
x_len_test <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token builtin">min</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> sentence_size<span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> x_test_variable<span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">parser</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> length<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>
    features <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"x"</span><span class="token punctuation">:</span> x<span class="token punctuation">,</span> <span class="token string">"len"</span><span class="token punctuation">:</span> length<span class="token punctuation">}</span>
    <span class="token keyword">return</span> features<span class="token punctuation">,</span> y

<span class="token keyword">def</span> <span class="token function">train_input_fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    dataset <span class="token operator">=</span> tf<span class="token punctuation">.</span>data<span class="token punctuation">.</span>Dataset<span class="token punctuation">.</span>from_tensor_slices<span class="token punctuation">(</span><span class="token punctuation">(</span>x_train<span class="token punctuation">,</span> x_len_train<span class="token punctuation">,</span> y_train<span class="token punctuation">)</span><span class="token punctuation">)</span>
    dataset <span class="token operator">=</span> dataset<span class="token punctuation">.</span>shuffle<span class="token punctuation">(</span>buffer_size<span class="token operator">=</span><span class="token builtin">len</span><span class="token punctuation">(</span>x_train_variable<span class="token punctuation">)</span><span class="token punctuation">)</span>
    dataset <span class="token operator">=</span> dataset<span class="token punctuation">.</span>batch<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
    dataset <span class="token operator">=</span> dataset<span class="token punctuation">.</span><span class="token builtin">map</span><span class="token punctuation">(</span>parser<span class="token punctuation">)</span>
    dataset <span class="token operator">=</span> dataset<span class="token punctuation">.</span>repeat<span class="token punctuation">(</span><span class="token punctuation">)</span>
    iterator <span class="token operator">=</span> dataset<span class="token punctuation">.</span>make_one_shot_iterator<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> iterator<span class="token punctuation">.</span>get_next<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">eval_input_fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    dataset <span class="token operator">=</span> tf<span class="token punctuation">.</span>data<span class="token punctuation">.</span>Dataset<span class="token punctuation">.</span>from_tensor_slices<span class="token punctuation">(</span><span class="token punctuation">(</span>x_test<span class="token punctuation">,</span> x_len_test<span class="token punctuation">,</span> y_test<span class="token punctuation">)</span><span class="token punctuation">)</span>
    dataset <span class="token operator">=</span> dataset<span class="token punctuation">.</span>batch<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
    dataset <span class="token operator">=</span> dataset<span class="token punctuation">.</span><span class="token builtin">map</span><span class="token punctuation">(</span>parser<span class="token punctuation">)</span>
    iterator <span class="token operator">=</span> dataset<span class="token punctuation">.</span>make_one_shot_iterator<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> iterator<span class="token punctuation">.</span>get_next<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
<p>We shuffle the training data and do not predefine the number of epochs we want to train, while we only need one epoch of the test data for evaluation. We also add an additional <code>"len"</code> key that captures the length of the original, unpadded sequence, which we will use later.</p>
<h3 id="building-a-baseline">Building a baseline</h3>
<p>It’s good practice to start any machine learning project trying basic baselines. The simpler the better as having a simple and robust baseline is key to understanding exactly how much we are gaining in terms of performance by adding extra complexity. It may very well be the case that a simple solution is good enough for our requirements.</p>
<p>With that in mind, let us start by trying out one of the simplest models for text classification. That would be a sparse linear model that gives a weight to each token and adds up all of the results, regardless of the order. As this model does not care about the order of words in a sentence, we normally refer to it as a <em>Bag-of-Words</em> approach. Let’s see how we can implement this model using an <code>Estimator</code>.</p>
<p>We start out by defining the feature column that is used as input to our classifier. As we have seen in <a href="https://developers.googleblog.com/2017/11/introducing-tensorflow-feature-columns.html">Part 2</a>, <code>categorical_column_with_identity</code> is the right choice for this pre-processed text input. If we were feeding raw text tokens other <code>feature_columns</code> could do a lot of the pre-processing for us. We can now use the pre-made <code>LinearClassifier</code>.</p>
<pre class=" language-python"><code class="prism  language-python">column <span class="token operator">=</span> tf<span class="token punctuation">.</span>feature_column<span class="token punctuation">.</span>categorical_column_with_identity<span class="token punctuation">(</span><span class="token string">'x'</span><span class="token punctuation">,</span> vocab_size<span class="token punctuation">)</span>
classifier <span class="token operator">=</span> tf<span class="token punctuation">.</span>estimator<span class="token punctuation">.</span>LinearClassifier<span class="token punctuation">(</span>
    feature_columns<span class="token operator">=</span><span class="token punctuation">[</span>column<span class="token punctuation">]</span><span class="token punctuation">,</span> 
    model_dir<span class="token operator">=</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>model_dir<span class="token punctuation">,</span> <span class="token string">'bow_sparse'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
<p>Finally, we create a simple function that trains the classifier and additionally creates a precision-recall curve. As we do not aim to maximize performance in this blog post, we only train our models for 25,000 steps.</p>
<pre><code class="language-python">def train_and_evaluate(classifier):
    classifier.train(input_fn=train_input_fn, steps=25000)
    eval_results = classifier.evaluate(input_fn=eval_input_fn)
    predictions = np.array([p['logistic'][0] for p in classifier.predict(input_fn=eval_input_fn)])
    tf.reset_default_graph() 
    # Add a PR summary in addition to the summaries that the classifier writes
    pr = summary_lib.pr_curve('precision_recall', predictions=predictions, labels=y_test.astype(bool), num_thresholds=21)
    with tf.Session() as sess:
        writer = tf.summary.FileWriter(os.path.join(classifier.model_dir, 'eval'), sess.graph)
        writer.add_summary(sess.run(pr), global_step=0)
        writer.close()
train_and_evaluate(classifier)
</code></pre>
<p>One of the benefits of choosing a simple model is that it is much more interpretable. The more complex a model, the harder it is to inspect and the more it tends to work like a black box. In this example, we can load the weights from our model’s last checkpoint and take a look at what tokens correspond to the  biggest weights in absolute value. The results look like what we would expect.</p>
<pre class=" language-python"><code class="prism  language-python"><span class="token comment"># Load the tensor with the model weights</span>
weights <span class="token operator">=</span> classifier<span class="token punctuation">.</span>get_variable_value<span class="token punctuation">(</span><span class="token string">'linear/linear_model/x/weights'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>flatten<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment"># Find biggest weights in absolute value</span>
extremes <span class="token operator">=</span> np<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span><span class="token punctuation">(</span>sorted_indexes<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> sorted_indexes<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment"># word_inverted_index is a dictionary that maps from indexes back to tokens</span>
extreme_weights <span class="token operator">=</span> <span class="token builtin">sorted</span><span class="token punctuation">(</span>
    <span class="token punctuation">[</span><span class="token punctuation">(</span>weights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> word_inverted_index<span class="token punctuation">[</span>i <span class="token operator">-</span> index_offset<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> extremes<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token comment"># Create plot</span>
y_pos <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>extreme_weights<span class="token punctuation">)</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>bar<span class="token punctuation">(</span>y_pos<span class="token punctuation">,</span> <span class="token punctuation">[</span>pair<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">for</span> pair <span class="token keyword">in</span> extreme_weights<span class="token punctuation">]</span><span class="token punctuation">,</span> align<span class="token operator">=</span><span class="token string">'center'</span><span class="token punctuation">,</span> alpha<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>xticks<span class="token punctuation">(</span>y_pos<span class="token punctuation">,</span> <span class="token punctuation">[</span>pair<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">for</span> pair <span class="token keyword">in</span> extreme_weights<span class="token punctuation">]</span><span class="token punctuation">,</span> rotation<span class="token operator">=</span><span class="token number">45</span><span class="token punctuation">,</span> ha<span class="token operator">=</span><span class="token string">'right'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'Weight'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'Most significant tokens'</span><span class="token punctuation">)</span> 
plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
<p><img src="https://raw.githubusercontent.com/eisenjulian/nlp_estimator_tutorial/master/token_weights.png" alt="Text Classification with TensorFlow Estimators" style="width: 60%"></p>
<p>As we can see, tokens with the most positive weight such as ‘refreshing’ are clearly associated with positive sentiment, while tokens that have a large negative weight unarguably evoke negative emotions. A simple but powerful modification that one can do to improve this model is weighting the tokens by their <a href="https://en.wikipedia.org/wiki/Tf%E2%80%93idf">tf-idf</a> scores.</p>
<h3 id="embeddings">Embeddings</h3>
<p>The next step of complexity we can add are word embeddings. Embeddings are a dense low-dimensional representation of sparse high-dimensional data. This allows our model to learn a more meaningful representation of each token, rather than just an index. While an individual dimension is not meaningful, the low-dimensional space—when learned from a large enough corpus—has been shown to capture relations such as tense, plural, gender, thematic relatedness, and many more. We can add word embeddings by converting our existing feature column into an <code>embedding_column</code>. The representation seen by the model is the mean of the embeddings for each token (see the <code>combiner</code> argument in the <a href="https://www.tensorflow.org/api_docs/python/tf/feature_column/embedding_column">docs</a>). We can plug in the embedded features into a pre-canned <code>DNNClassifier</code>.</p>
<p>A note for the keen observer: an <code>embedding_column</code> is just an efficient way of applying a fully connected layer to the sparse binary feature vector of tokens, which is multiplied by a constant depending of the chosen combiner. A direct consequence of this is that it wouldn’t make sense to use an <code>embedding_column</code> directly in a <code>LinearClassifier</code> because two consecutive linear layers without non-linearities in between add no prediction power to the model, unless of course the embeddings are pre-trained.</p>
<pre class=" language-python"><code class="prism  language-python">embedding_size <span class="token operator">=</span> <span class="token number">50</span>
word_embedding_column <span class="token operator">=</span> tf<span class="token punctuation">.</span>feature_column<span class="token punctuation">.</span>embedding_column<span class="token punctuation">(</span>
    column<span class="token punctuation">,</span> dimension<span class="token operator">=</span>embedding_size<span class="token punctuation">)</span>
classifier <span class="token operator">=</span> tf<span class="token punctuation">.</span>estimator<span class="token punctuation">.</span>DNNClassifier<span class="token punctuation">(</span>
    hidden_units<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    feature_columns<span class="token operator">=</span><span class="token punctuation">[</span>word_embedding_column<span class="token punctuation">]</span><span class="token punctuation">,</span> 
    model_dir<span class="token operator">=</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>model_dir<span class="token punctuation">,</span> <span class="token string">'bow_embeddings'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
train_and_evaluate<span class="token punctuation">(</span>classifier<span class="token punctuation">)</span>
</code></pre>
<p>We can use TensorBoard to visualize our $50$ dimensional word vectors projected into $\mathbb{R}^3$ using <a href="https://en.wikipedia.org/wiki/T-distributed_stochastic_neighbor_embedding">t-SNE</a>. We expect similar words to be close to each other. This can be a useful way to inspect our model weights and find unexpected behaviours.</p>
<p><img src="https://raw.githubusercontent.com/eisenjulian/nlp_estimator_tutorial/master/embeddings.gif" alt="Text Classification with TensorFlow Estimators"></p>
<h3 id="convolutions">Convolutions</h3>
<p>At this point one possible approach would be to go deeper, further adding more fully connected layers and playing around with layer sizes and training functions. However, by doing that we would add extra complexity and ignore important structure in our sentences. Words do not live in a vacuum and meaning is compositional, formed by words and its neighbors.</p>
<p>Convolutions are one way to take advantage of this structure, similar to how we can model salient clusters of pixels for <a href="https://www.tensorflow.org/tutorials/layers">image classification</a>. The intuition is that certain sequences of words, or <em>n-grams</em>, usually have the same meaning regardless of their overall position in the sentence. Introducing a structural prior via the convolution operation allows us to model the interaction between neighboring words and consequently gives us a better way to represent such meaning.</p>
<p>The following image shows how a filter matrix $F \in \mathbb{R}^{d\times m}$ tri-gram window of tokens to build a new feature map. Afterwards a <em>pooling</em> layer is usually applied to combine adjacent results.</p>
<p><img src="https://raw.githubusercontent.com/eisenjulian/nlp_estimator_tutorial/master/conv.png" alt="Text Classification with TensorFlow Estimators" style="width: 80%"><br>
<small></small></p><p align="center"><br>
Source: <a href="https://www.semanticscholar.org/paper/Learning-to-Rank-Short-Text-Pairs-with-Convolution-Severyn-Moschitti/452f7411af7d471dd3ba84c2b06b2aaffc38cdb9">Learning to Rank Short Text Pairs with Convolutional Deep Neural Networks</a> by <strong>Severyn</strong> et al. [2015]</p>
<p>Let us look at the full model architecture. The use of dropout layers is a regularization technique that makes the model less likely to overfit.</p>
<div class="mermaid"><svg xmlns="http://www.w3.org/2000/svg" id="mermaid-svg-qmCUPkCnZ5TFF69q" height="100%" viewbox="0 0 1415.640625 112.5" style="max-width:1415.640625px;"><g><g class="output"><g class="clusters"/><g class="edgePaths"><g class="edgePath" style="opacity: 1;"><path class="path" d="M191.4375,46.25L216.4375,46.25L241.4375,46.25" marker-end="url(#arrowhead84)" style="fill:none"/><defs><marker id="arrowhead84" viewbox="0 0 10 10" refx="9" refy="5" markerunits="strokeWidth" markerwidth="8" markerheight="6" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" class="arrowheadPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"/></marker></defs></g><g class="edgePath" style="opacity: 1;"><path class="path" d="M335.515625,46.25L360.515625,46.25L385.515625,46.25" marker-end="url(#arrowhead85)" style="fill:none"/><defs><marker id="arrowhead85" viewbox="0 0 10 10" refx="9" refy="5" markerunits="strokeWidth" markerwidth="8" markerheight="6" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" class="arrowheadPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"/></marker></defs></g><g class="edgePath" style="opacity: 1;"><path class="path" d="M539.84375,46.25L564.84375,46.25L589.84375,46.25" marker-end="url(#arrowhead86)" style="fill:none"/><defs><marker id="arrowhead86" viewbox="0 0 10 10" refx="9" refy="5" markerunits="strokeWidth" markerwidth="8" markerheight="6" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" class="arrowheadPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"/></marker></defs></g><g class="edgePath" style="opacity: 1;"><path class="path" d="M796.28125,46.25L821.28125,46.25L846.28125,46.25" marker-end="url(#arrowhead87)" style="fill:none"/><defs><marker id="arrowhead87" viewbox="0 0 10 10" refx="9" refy="5" markerunits="strokeWidth" markerwidth="8" markerheight="6" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" class="arrowheadPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"/></marker></defs></g><g class="edgePath" style="opacity: 1;"><path class="path" d="M1044.65625,46.25L1069.65625,46.25L1094.65625,46.25" marker-end="url(#arrowhead88)" style="fill:none"/><defs><marker id="arrowhead88" viewbox="0 0 10 10" refx="9" refy="5" markerunits="strokeWidth" markerwidth="8" markerheight="6" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" class="arrowheadPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"/></marker></defs></g><g class="edgePath" style="opacity: 1;"><path class="path" d="M1188.734375,46.25L1213.734375,46.25L1238.734375,46.25" marker-end="url(#arrowhead89)" style="fill:none"/><defs><marker id="arrowhead89" viewbox="0 0 10 10" refx="9" refy="5" markerunits="strokeWidth" markerwidth="8" markerheight="6" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" class="arrowheadPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"/></marker></defs></g></g><g class="edgeLabels"><g class="edgeLabel" style="opacity: 1;" transform=""><g transform="translate(0,0)" class="label"><foreignobject width="0" height="0"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;"><span class="edgeLabel"/></div></foreignobject></g></g><g class="edgeLabel" style="opacity: 1;" transform=""><g transform="translate(0,0)" class="label"><foreignobject width="0" height="0"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;"><span class="edgeLabel"/></div></foreignobject></g></g><g class="edgeLabel" style="opacity: 1;" transform=""><g transform="translate(0,0)" class="label"><foreignobject width="0" height="0"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;"><span class="edgeLabel"/></div></foreignobject></g></g><g class="edgeLabel" style="opacity: 1;" transform=""><g transform="translate(0,0)" class="label"><foreignobject width="0" height="0"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;"><span class="edgeLabel"/></div></foreignobject></g></g><g class="edgeLabel" style="opacity: 1;" transform=""><g transform="translate(0,0)" class="label"><foreignobject width="0" height="0"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;"><span class="edgeLabel"/></div></foreignobject></g></g><g class="edgeLabel" style="opacity: 1;" transform=""><g transform="translate(0,0)" class="label"><foreignobject width="0" height="0"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;"><span class="edgeLabel"/></div></foreignobject></g></g></g><g class="nodes"><g class="node" style="opacity: 1;" id="id1" transform="translate(105.71875,46.25)"><rect rx="5" ry="5" x="-85.71875" y="-26.25" width="171.4375" height="52.5"/><g class="label" transform="translate(0,0)"><g transform="translate(-75.71875,-16.25)"><foreignobject width="151.4453125" height="32.5"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;">Embedding Layer</div></foreignobject></g></g></g><g class="node" style="opacity: 1;" id="id2" transform="translate(288.4765625,46.25)"><rect rx="5" ry="5" x="-47.0390625" y="-26.25" width="94.078125" height="52.5"/><g class="label" transform="translate(0,0)"><g transform="translate(-37.0390625,-16.25)"><foreignobject width="74.08203125" height="32.5"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;">Dropout</div></foreignobject></g></g></g><g class="node" style="opacity: 1;" id="id3" transform="translate(462.6796875,46.25)"><rect rx="5" ry="5" x="-77.1640625" y="-26.25" width="154.328125" height="52.5"/><g class="label" transform="translate(0,0)"><g transform="translate(-67.1640625,-16.25)"><foreignobject width="134.3359375" height="32.5"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;">Convolution1D</div></foreignobject></g></g></g><g class="node" style="opacity: 1;" id="id4" transform="translate(693.0625,46.25)"><rect rx="5" ry="5" x="-103.21875" y="-26.25" width="206.4375" height="52.5"/><g class="label" transform="translate(0,0)"><g transform="translate(-93.21875,-16.25)"><foreignobject width="186.4453125" height="32.5"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;">GlobalMaxPooling1D</div></foreignobject></g></g></g><g class="node" style="opacity: 1;" id="id5" transform="translate(945.46875,46.25)"><rect rx="5" ry="5" x="-99.1875" y="-26.25" width="198.375" height="52.5"/><g class="label" transform="translate(0,0)"><g transform="translate(-89.1875,-16.25)"><foreignobject width="178.37890625" height="32.5"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;">Hidden Dense Layer</div></foreignobject></g></g></g><g class="node" style="opacity: 1;" id="id6" transform="translate(1141.6953125,46.25)"><rect rx="5" ry="5" x="-47.0390625" y="-26.25" width="94.078125" height="52.5"/><g class="label" transform="translate(0,0)"><g transform="translate(-37.0390625,-16.25)"><foreignobject width="74.08203125" height="32.5"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;">Dropout</div></foreignobject></g></g></g><g class="node" style="opacity: 1;" id="id7" transform="translate(1307.1875,46.25)"><rect rx="5" ry="5" x="-68.453125" y="-26.25" width="136.90625" height="52.5"/><g class="label" transform="translate(0,0)"><g transform="translate(-58.453125,-16.25)"><foreignobject width="116.9140625" height="32.5"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;">Output Layer</div></foreignobject></g></g></g></g></g></g></svg></div>
<h3 id="creating-a-custom-estimator">Creating a custom estimator</h3>
<p>As seen in previous blog posts, the <code>tf.estimator</code> framework provides a high-level API for training machine learning models, defining <code>train()</code>, <code>evaluate()</code> and <code>predict()</code> operations, handling checkpointing, loading, initializing, serving, building the graph and the session out of the box. There is a small family of pre-made estimators, like the ones we used earlier, but it’s most likely that you will need to <a href="https://www.tensorflow.org/extend/estimators">build your own</a>.</p>
<p>Writing a custom estimator means writing a <code>model_fn(features, labels, mode, params)</code> that returns an <code>EstimatorSpec</code>. The first step will be mapping the features into our embedding layer:</p>
<pre class=" language-python"><code class="prism  language-python">input_layer <span class="token operator">=</span> tf<span class="token punctuation">.</span>contrib<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>embed_sequence<span class="token punctuation">(</span>
    features<span class="token punctuation">[</span><span class="token string">'x'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> 
    vocab_size<span class="token punctuation">,</span> 
    embedding_size<span class="token punctuation">,</span>
    initializer<span class="token operator">=</span>params<span class="token punctuation">[</span><span class="token string">'embedding_initializer'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre>
<p>Then we use <code>tf.layers</code> to process each output sequentially.</p>
<pre class=" language-python"><code class="prism  language-python">training <span class="token operator">=</span> <span class="token punctuation">(</span>mode <span class="token operator">==</span> tf<span class="token punctuation">.</span>estimator<span class="token punctuation">.</span>ModeKeys<span class="token punctuation">.</span>TRAIN<span class="token punctuation">)</span>
dropout_emb <span class="token operator">=</span> tf<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>dropout<span class="token punctuation">(</span>inputs<span class="token operator">=</span>input_layer<span class="token punctuation">,</span> 
                                rate<span class="token operator">=</span><span class="token number">0.2</span><span class="token punctuation">,</span> 
                                training<span class="token operator">=</span>training<span class="token punctuation">)</span>
conv <span class="token operator">=</span> tf<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>conv1d<span class="token punctuation">(</span>
    inputs<span class="token operator">=</span>dropout_emb<span class="token punctuation">,</span>
    filters<span class="token operator">=</span><span class="token number">32</span><span class="token punctuation">,</span>
    kernel_size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span>
    padding<span class="token operator">=</span><span class="token string">"same"</span><span class="token punctuation">,</span>
    activation<span class="token operator">=</span>tf<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>relu<span class="token punctuation">)</span>
pool <span class="token operator">=</span> tf<span class="token punctuation">.</span>reduce_max<span class="token punctuation">(</span>input_tensor<span class="token operator">=</span>conv<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>
hidden <span class="token operator">=</span> tf<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>dense<span class="token punctuation">(</span>inputs<span class="token operator">=</span>pool<span class="token punctuation">,</span> units<span class="token operator">=</span><span class="token number">250</span><span class="token punctuation">,</span> activation<span class="token operator">=</span>tf<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>relu<span class="token punctuation">)</span>
dropout <span class="token operator">=</span> tf<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>dropout<span class="token punctuation">(</span>inputs<span class="token operator">=</span>hidden<span class="token punctuation">,</span> rate<span class="token operator">=</span><span class="token number">0.2</span><span class="token punctuation">,</span> training<span class="token operator">=</span>training<span class="token punctuation">)</span>
logits <span class="token operator">=</span> tf<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>dense<span class="token punctuation">(</span>inputs<span class="token operator">=</span>dropout_hidden<span class="token punctuation">,</span> units<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>
</code></pre>
<p>Finally, we will use a <code>Head</code> to simplify the writing of our last part of the <code>model_fn</code>. The head already knows how to compute predictions, loss, train_op, metrics and export outputs, and can be reused across models. This is also used in the pre-made estimators and provides us with the benefit of a uniform evaluation function across all of our models. We will use <code>binary_classification_head</code>, which is a head for single label binary classification that uses <code>sigmoid_cross_entropy_with_logits</code> as the loss function under the hood.</p>
<pre class=" language-python"><code class="prism  language-python">head <span class="token operator">=</span> tf<span class="token punctuation">.</span>contrib<span class="token punctuation">.</span>estimator<span class="token punctuation">.</span>binary_classification_head<span class="token punctuation">(</span><span class="token punctuation">)</span>
optimizer <span class="token operator">=</span> tf<span class="token punctuation">.</span>train<span class="token punctuation">.</span>AdamOptimizer<span class="token punctuation">(</span><span class="token punctuation">)</span>    
<span class="token keyword">def</span> <span class="token function">_train_op_fn</span><span class="token punctuation">(</span>loss<span class="token punctuation">)</span><span class="token punctuation">:</span>
    tf<span class="token punctuation">.</span>summary<span class="token punctuation">.</span>scalar<span class="token punctuation">(</span><span class="token string">'loss'</span><span class="token punctuation">,</span> loss<span class="token punctuation">)</span>
    <span class="token keyword">return</span> optimizer<span class="token punctuation">.</span>minimize<span class="token punctuation">(</span>
        loss<span class="token operator">=</span>loss<span class="token punctuation">,</span>
        global_step<span class="token operator">=</span>tf<span class="token punctuation">.</span>train<span class="token punctuation">.</span>get_global_step<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">return</span> head<span class="token punctuation">.</span>create_estimator_spec<span class="token punctuation">(</span>
    features<span class="token operator">=</span>features<span class="token punctuation">,</span>
    labels<span class="token operator">=</span>labels<span class="token punctuation">,</span>
    mode<span class="token operator">=</span>mode<span class="token punctuation">,</span>
    logits<span class="token operator">=</span>logits<span class="token punctuation">,</span>
    train_op_fn<span class="token operator">=</span>_train_op_fn<span class="token punctuation">)</span>
</code></pre>
<p>Running this model is just as easy as before:</p>
<pre class=" language-python"><code class="prism  language-python">initializer <span class="token operator">=</span> tf<span class="token punctuation">.</span>random_uniform<span class="token punctuation">(</span><span class="token punctuation">[</span>vocab_size<span class="token punctuation">,</span> embedding_size<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
params <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'embedding_initializer'</span><span class="token punctuation">:</span> initializer<span class="token punctuation">}</span>
cnn_classifier <span class="token operator">=</span> tf<span class="token punctuation">.</span>estimator<span class="token punctuation">.</span>Estimator<span class="token punctuation">(</span>model_fn<span class="token operator">=</span>model_fn<span class="token punctuation">,</span>
                                        model_dir<span class="token operator">=</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>model_dir<span class="token punctuation">,</span> <span class="token string">'cnn'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                        params<span class="token operator">=</span>params<span class="token punctuation">)</span>
train_and_evaluate<span class="token punctuation">(</span>cnn_classifier<span class="token punctuation">)</span>
</code></pre>
<h3 id="lstm-networks">LSTM Networks</h3>
<p>Using the <code>Estimator</code> API and the same model <code>head</code>, we can also create a classifier that uses a <em>Long Short-Term Memory</em> (<em>LSTM</em>) cell instead of convolutions. Recurrent models such as this are some of the most successful building blocks for NLP applications. An LSTM processes the entire document sequentially, recursing over the sequence with its cell while storing the current state of the sequence in its memory.</p>
<p>One of the drawbacks of recurrent models compared to CNNs is that, because of the nature of recursion, models turn out deeper and more complex, which usually produces slower training time and worse convergence. LSTMs (and RNNs in general) can suffer convergence issues like vanishing or exploding gradients, that said, with sufficient tuning they can obtain state-of-the-art results for many problems. As a rule of thumb CNNs are good at feature extraction, while RNNs excel at tasks that depend on the meaning of the whole sentence, like question answering or machine translation.</p>
<p>Each cell processes one token embedding at a time updating its internal state based on a differentiable computation that depends on both the embedding vector $x_t$ and the previous state $h_{t-1}$. In order to get a better understanding of how LSTMs work, you can refer to Chris Olah’s <a href="https://colah.github.io/posts/2015-08-Understanding-LSTMs/">blog post</a>.</p>
<p><img src="https://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-chain.png" alt="Text Classification with TensorFlow Estimators"><br>
<small></small></p><p align="center"><br>
Source: <a href="https://colah.github.io/posts/2015-08-Understanding-LSTMs/">Understanding LSTM Networks</a> by <strong>Chris Olah</strong></p>
<p>The complete LSTM model can be expressed by the following simple flowchart:</p>
<p><img src="http://ruder.io/content/images/2018/10/lstm_flow_chart.png" alt="Text Classification with TensorFlow Estimators"></p>
<p>In the beginning of this post, we padded all documents up to <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mn>0</mn><mn>0</mn></mrow><annotation encoding="application/x-tex">200</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base"><span class="mord mathrm">2</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span></span></span></span></span> tokens, which is necessary to build a proper tensor. However, when a document contains fewer than <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mn>0</mn><mn>0</mn></mrow><annotation encoding="application/x-tex">200</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base"><span class="mord mathrm">2</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span></span></span></span></span> words, we don’t want the LSTM to continue processing padding tokens as it does not add information and degrades performance. For this reason, we additionally want to provide our network with the length of the original sequence before it was padded. Internally, the model then copies the last state through to the sequence’s end. We can do this by using the <code>"len"</code> feature in our input functions. We can now use the same logic as above and simply replace the convolutional, pooling, and flatten layers with our LSTM cell.</p>
<pre class=" language-python"><code class="prism  language-python">lstm_cell <span class="token operator">=</span> tf<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>rnn_cell<span class="token punctuation">.</span>BasicLSTMCell<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
_<span class="token punctuation">,</span> final_states <span class="token operator">=</span> tf<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>dynamic_rnn<span class="token punctuation">(</span>
        lstm_cell<span class="token punctuation">,</span> inputs<span class="token punctuation">,</span> sequence_length<span class="token operator">=</span>features<span class="token punctuation">[</span><span class="token string">'len'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>tf<span class="token punctuation">.</span>float32<span class="token punctuation">)</span>
logits <span class="token operator">=</span> tf<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>dense<span class="token punctuation">(</span>inputs<span class="token operator">=</span>final_states<span class="token punctuation">.</span>h<span class="token punctuation">,</span> units<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>
</code></pre>
<h3 id="pre-trained-vectors">Pre-trained vectors</h3>
<p>Most of the models that we have shown before rely on word embeddings as a first layer. So far, we have initialized this embedding layer randomly. However, <a href="https://arxiv.org/abs/1607.01759">much</a> <a href="https://arxiv.org/abs/1301.3781">previous</a> <a href="https://arxiv.org/abs/1103.0398">work</a> has shown that using embeddings pre-trained on a large unlabeled corpus as initialization is beneficial, particularly when training on only a small number of labeled examples. The most popular pre-trained embedding is <a href="https://www.tensorflow.org/tutorials/word2vec">word2vec</a>. Leveraging knowledge from unlabeled data via pre-trained embeddings is an instance of <em><a href="http://ruder.io/transfer-learning/">transfer learning</a></em>.</p>
<p>To this end, we will show you how to use them in an <code>Estimator</code>. We will use the pre-trained vectors from another popular model, <a href="https://nlp.stanford.edu/projects/glove/">GloVe</a>.</p>
<pre class=" language-python"><code class="prism  language-python">embeddings <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'glove.6B.50d.txt'</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
    <span class="token keyword">for</span> line <span class="token keyword">in</span> f<span class="token punctuation">:</span>
        values <span class="token operator">=</span> line<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>
        w <span class="token operator">=</span> values<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
        vectors <span class="token operator">=</span> np<span class="token punctuation">.</span>asarray<span class="token punctuation">(</span>values<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token string">'float32'</span><span class="token punctuation">)</span>
        embeddings<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">=</span> vectors
</code></pre>
<p>After loading the vectors into memory from a file we store them as a <code>numpy.array</code> using the same indexes as our vocabulary. The created array is of shape <code>(5000, 50)</code>. At every row index, it contains the <code>50</code>-dimensional vector representing the word at the same index in our vocabulary.</p>
<pre class=" language-python"><code class="prism  language-python">embedding_matrix <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>uniform<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token punctuation">(</span>vocab_size<span class="token punctuation">,</span> embedding_size<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> w<span class="token punctuation">,</span> i <span class="token keyword">in</span> word_index<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    v <span class="token operator">=</span> embeddings<span class="token punctuation">.</span>get<span class="token punctuation">(</span>w<span class="token punctuation">)</span>
    <span class="token keyword">if</span> v <span class="token keyword">is</span> <span class="token operator">not</span> <span class="token boolean">None</span> <span class="token operator">and</span> i <span class="token operator">&lt;</span> vocab_size<span class="token punctuation">:</span>
        embedding_matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> v
</code></pre>
<p>Finally, we can use a custom initializer function and pass it in the <code>params</code> object to our <code>cnn_model_fn</code> , without any modifications.</p>
<pre class=" language-python"><code class="prism  language-python"><span class="token keyword">def</span> <span class="token function">my_initializer</span><span class="token punctuation">(</span>shape<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>tf<span class="token punctuation">.</span>float32<span class="token punctuation">,</span> partition_info<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">assert</span> dtype <span class="token keyword">is</span> tf<span class="token punctuation">.</span>float32
    <span class="token keyword">return</span> embedding_matrix
params <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'embedding_initializer'</span><span class="token punctuation">:</span> my_initializer<span class="token punctuation">}</span>
cnn_pretrained_classifier <span class="token operator">=</span> tf<span class="token punctuation">.</span>estimator<span class="token punctuation">.</span>Estimator<span class="token punctuation">(</span>
    model_fn<span class="token operator">=</span>cnn_model_fn<span class="token punctuation">,</span>
    model_dir<span class="token operator">=</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>model_dir<span class="token punctuation">,</span> <span class="token string">'cnn_pretrained'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    params<span class="token operator">=</span>params<span class="token punctuation">)</span>
train_and_evaluate<span class="token punctuation">(</span>cnn_pretrained_classifier<span class="token punctuation">)</span>
</code></pre>
<h3 id="running-tensorboard">Running TensorBoard</h3>
<p>Now we can launch TensorBoard and see how the different models we’ve trained compare against each other in terms of training time and performance.</p>
<p>In a terminal, we run</p>
<pre class=" language-bash"><code class="prism  language-bash"><span class="token operator">&gt;</span> tensorboard --logdir<span class="token operator">=</span><span class="token punctuation">{</span>model_dir<span class="token punctuation">}</span>
</code></pre>
<p>We can visualize many metrics collected while training and testing, including the loss function values of each model at each training step, and the precision-recall curves. This is of course most useful to select which model works best for our use-case as well as how to choose classification thresholds.</p>
<p><img src="https://raw.githubusercontent.com/eisenjulian/nlp_estimator_tutorial/master/pr_curves.png" alt="Text Classification with TensorFlow Estimators"></p>
<p><img src="https://raw.githubusercontent.com/eisenjulian/nlp_estimator_tutorial/master/loss.png" alt="Text Classification with TensorFlow Estimators"></p>
<h3 id="getting-predictions">Getting Predictions</h3>
<p>To obtain predictions on new sentences we can use the <code>predict</code> method in the <code>Estimator</code> instances, which will load the latest checkpoint for each model and evaluate on the unseen examples. But before passing the data into the model we have to clean up, tokenize and map each token to the corresponding index as we see below.</p>
<pre class=" language-python"><code class="prism  language-python"><span class="token keyword">def</span> <span class="token function">text_to_index</span><span class="token punctuation">(</span>sentence<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># Remove punctuation characters except for the apostrophe</span>
    translator <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">.</span>maketrans<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> string<span class="token punctuation">.</span>punctuation<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"'"</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    tokens <span class="token operator">=</span> sentence<span class="token punctuation">.</span>translate<span class="token punctuation">(</span>translator<span class="token punctuation">)</span><span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">[</span>word_index<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">+</span> index_offset <span class="token keyword">if</span> t <span class="token keyword">in</span> word_index <span class="token keyword">else</span> <span class="token number">2</span> <span class="token keyword">for</span> t <span class="token keyword">in</span> tokens<span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">print_predictions</span><span class="token punctuation">(</span>sentences<span class="token punctuation">,</span> classifier<span class="token punctuation">)</span><span class="token punctuation">:</span>
    indexes <span class="token operator">=</span> <span class="token punctuation">[</span>text_to_index<span class="token punctuation">(</span>sentence<span class="token punctuation">)</span> <span class="token keyword">for</span> sentence <span class="token keyword">in</span> sentences<span class="token punctuation">]</span>
    x <span class="token operator">=</span> sequence<span class="token punctuation">.</span>pad_sequences<span class="token punctuation">(</span>indexes<span class="token punctuation">,</span>
                               maxlen<span class="token operator">=</span>sentence_size<span class="token punctuation">,</span> 
                               padding<span class="token operator">=</span><span class="token string">'post'</span><span class="token punctuation">,</span> 
                               value<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
    length <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token builtin">min</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> sentence_size<span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> indexes<span class="token punctuation">]</span><span class="token punctuation">)</span>
    predict_input_fn <span class="token operator">=</span> tf<span class="token punctuation">.</span>estimator<span class="token punctuation">.</span>inputs<span class="token punctuation">.</span>numpy_input_fn<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">"x"</span><span class="token punctuation">:</span> x<span class="token punctuation">,</span> <span class="token string">"len"</span><span class="token punctuation">:</span> length<span class="token punctuation">}</span><span class="token punctuation">,</span> shuffle<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>
    predictions <span class="token operator">=</span> <span class="token punctuation">[</span>p<span class="token punctuation">[</span><span class="token string">'logistic'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">for</span> p <span class="token keyword">in</span> classifier<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>input_fn<span class="token operator">=</span>predict_input_fn<span class="token punctuation">)</span><span class="token punctuation">]</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>predictions<span class="token punctuation">)</span>
</code></pre>
<p>It is worth noting that the checkpoint itself is not sufficient to make predictions; the actual code used to build the estimator is necessary as well in order to map the saved weights to the corresponding tensors. It’s a good practice to associate saved checkpoints with the branch of code with which they were created.</p>
<p>If you are interested in exporting the models to disk in a fully recoverable way, you might want to look into the <a href="https://www.tensorflow.org/programmers_guide/saved_model#using_savedmodel_with_estimators">SavedModel</a> class, which is especially useful for serving your model through an API using <a href="https://github.com/tensorflow/serving">TensorFlow Serving</a>.</p>
<h3 id="summary">Summary</h3>
<p>In this blog post, we explored how to use estimators for text classification, in particular for the IMDB Reviews Dataset. We trained and visualized our own embeddings, as well as loaded pre-trained ones. We started from a simple baseline and made our way to convolutional neural networks and LSTMs.</p>
<p>For more details, be sure to check out:</p>
<ul>
<li>A <a href="https://github.com/eisenjulian/nlp_estimator_tutorial/blob/master/nlp_estimators.ipynb">Jupyter notebook</a> that can run locally, or on Colaboratory.</li>
<li>The complete <a href="https://github.com/eisenjulian/nlp_estimator_tutorial/blob/master/nlp_estimators.py">source code</a> for this blog post.</li>
<li>The TensorFlow <a href="https://www.tensorflow.org/programmers_guide/embedding">Embedding</a> guide.</li>
<li>The TensorFlow <a href="https://www.tensorflow.org/tutorials/word2vec">Vector Representation of Words</a> tutorial.</li>
<li>The <em>NLTK</em> <a href="http://www.nltk.org/book/ch03.html">Processing Raw Text</a> chapter on how to design language pipelines.</li>
</ul>
<p><em>Thanks for reading!</em></p>
<!--kg-card-end: markdown--><!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[Requests for Research]]></title><description><![CDATA[It can be hard to find compelling topics to work on and know what questions to ask when you are just starting as a researcher. This post aims to provide inspiration and ideas for research directions to junior researchers and those trying to get into research.]]></description><link>http://ruder.io/requests-for-research/</link><guid isPermaLink="false">5c76ff7c1b9b0d18555b9ea8</guid><category><![CDATA[transfer learning]]></category><category><![CDATA[multi-task learning]]></category><category><![CDATA[cross-lingual]]></category><category><![CDATA[meta-learning]]></category><category><![CDATA[domain adaptation]]></category><dc:creator><![CDATA[Sebastian Ruder]]></dc:creator><pubDate>Sun, 04 Mar 2018 15:00:00 GMT</pubDate><media:content url="http://ruder.io/content/images/2018/10/domain_randomization.png" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><!--kg-card-begin: markdown--><img src="http://ruder.io/content/images/2018/10/domain_randomization.png" alt="Requests for Research"><p>This post aims to provide inspiration and ideas for research directions to junior researchers and those trying to get into research.</p>
<p>Table of contents:</p>
<ul>
<li><a href="#taskindependentdataaugmentationfornlp">Task-independent data augmentation for NLP</a></li>
<li><a href="#fewshotlearningfornlp">Few-shot learning for NLP</a></li>
<li><a href="#transferlearningfornlp">Transfer learning for NLP</a></li>
<li><a href="#multitasklearning">Multi-task learning</a></li>
<li><a href="#crosslinguallearning">Cross-lingual learning</a></li>
<li><a href="#taskindependentarchitectureimprovements">Task-independent architecture improvements</a></li>
</ul>
<p>It can be hard to find compelling topics to work on and know what questions are interesting to ask when you are just starting as a researcher in a new field. Machine learning research in particular moves so fast these days that it is difficult to find an opening.</p>
<p>This post aims to provide inspiration and ideas for research directions to junior researchers and those trying to get into research. It gathers a collection of research topics that are interesting to me, with a focus on NLP and transfer learning. As such, they might obviously not be of interest to everyone. If you are interested in Reinforcement Learning, OpenAI provides a <a href="https://blog.openai.com/requests-for-research-2/">selection of interesting RL-focused research topics</a>. In case you'd like to collaborate with others or are interested in a broader range of topics, have a look at the <a href="https://ai-on.org/">Artificial Intelligence Open Network</a>.</p>
<p>Most of these topics are not thoroughly thought out yet; in many cases, the general description is quite vague and subjective and many directions are possible. In addition, most of these are <em>not</em> low-hanging fruit, so serious effort is necessary to come up with a solution. I am happy to provide feedback with regard to any of these, but will not have time to provide more detailed guidance unless you have a working proof-of-concept. I will update this post periodically with new research directions and advances in already listed ones. Note that this collection does not attempt to review the extensive literature but only aims to give a glimpse of a topic; consequently, the references won't be comprehensive.</p>
<p>I hope that this collection will pique your interest and serve as inspiration for your own research agenda.</p>
<h2 id="taskindependentdataaugmentationfornlp">Task-independent data augmentation for NLP</h2>
<p>Data augmentation aims to create additional training data by producing variations of existing training examples through transformations, which can mirror those encountered in the real world. In Computer Vision (CV), common augmentation techniques are <a href="https://www.coursera.org/learn/convolutional-neural-networks/lecture/AYzbX/data-augmentation">mirroring, random cropping, shearing, etc</a>. Data augmentation is super useful in CV. For instance, it has been used to great effect in AlexNet (Krizhevsky et al., 2012) <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> to combat overfitting and in most state-of-the-art models since. In addition, data augmentation makes intuitive sense as it makes the training data more diverse and should thus increase a model's generalization ability.</p>
<p>However, in NLP, data augmentation is not widely used. In my mind, this is for two reasons:</p>
<ol>
<li>Data in NLP is discrete. This prevents us from applying simple transformations directly to the input data. Most recently proposed augmentation methods in CV focus on such transformations, e.g. domain randomization (Tobin et al., 2017) <sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>.</li>
<li>Small perturbations may change the meaning. Deleting a negation may change a sentence's sentiment, while modifying a word in a paragraph might inadvertently change the answer to a question about that paragraph. This is not the case in CV where perturbing individual pixels does not change whether an image is a cat or dog and even stark changes such as interpolation of different images can be useful (Zhang et al., 2017) <sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>.</li>
</ol>
<p>Existing approaches that I am aware of are either rule-based (Li et al., 2017) <sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup> or task-specific, e.g. for parsing (Wang and Eisner, 2016) <sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup> or zero-pronoun resolution (Liu et al., 2017) <sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>. Xie et al. (2017) <sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup> replace words with samples from different distributions for language modelling and Machine Translation. Recent work focuses on creating adversarial examples either by replacing words or characters (Samanta and Mehta, 2017; Ebrahimi et al., 2017) <sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup> <sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup>, concatenation (Jia and Liang, 2017) <sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup>, or adding adversarial perturbations (Yasunaga et al., 2017) <sup class="footnote-ref"><a href="#fn11" id="fnref11">[11]</a></sup>. An adversarial setup is also used by Li et al. (2017) <sup class="footnote-ref"><a href="#fn12" id="fnref12">[12]</a></sup> who train a system to produce sequences that are indistinguishable from human-generated dialogue utterances.</p>
<p>Back-translation (Sennrich et al., 2015; Sennrich et al., 2016) <sup class="footnote-ref"><a href="#fn13" id="fnref13">[13]</a></sup> <sup class="footnote-ref"><a href="#fn14" id="fnref14">[14]</a></sup> is a common data augmentation method in Machine Translation (MT) that allows us to incorporate monolingual training data. For instance, when training a EN\(\rightarrow\)FR system, monolingual French text is translated to English using an FR\(\rightarrow\)EN system; the synthetic parallel data can then be used for training. Back-translation can also be used for paraphrasing (Mallinson et al., 2017) <sup class="footnote-ref"><a href="#fn15" id="fnref15">[15]</a></sup>. Paraphrasing has been used for data augmentation for QA (Dong et al., 2017) <sup class="footnote-ref"><a href="#fn16" id="fnref16">[16]</a></sup>, but I am not aware of its use for other tasks.</p>
<p>Another method that is close to paraphrasing is generating sentences from a continuous space using a variational autoencoder (Bowman et al., 2016; Guu et al., 2017) <sup class="footnote-ref"><a href="#fn17" id="fnref17">[17]</a></sup> <sup class="footnote-ref"><a href="#fn18" id="fnref18">[18]</a></sup>. If the representations are disentangled as in (Hu et al., 2017) <sup class="footnote-ref"><a href="#fn19" id="fnref19">[19]</a></sup>, then we are also not too far from style transfer (Shen et al., 2017) <sup class="footnote-ref"><a href="#fn20" id="fnref20">[20]</a></sup>.</p>
<p>There are a few research directions that would be interesting to pursue:</p>
<ol>
<li><strong>Evaluation study:</strong> Evaluate a range of existing data augmentation methods as well as techniques that have not been widely used for augmentation such as paraphrasing and style transfer on a diverse range of tasks including text classification and sequence labelling. Identify what types of data augmentation are robust across task and which are task-specific. This could be packaged as a software library to make future benchmarking easier (think <a href="https://github.com/tensorflow/cleverhans">CleverHans</a> for NLP).</li>
<li><strong>Data augmentation with style transfer:</strong> Investigate if style transfer can be used to modify various attributes of training examples for more robust learning.</li>
<li><strong>Learn the augmentation:</strong> Similar to Dong et al. (2017) we could learn either to paraphrase or to generate transformations for a particular task.</li>
<li><strong>Learn a word embedding space for data augmentation:</strong> A typical word embedding space clusters synonyms and antonyms together; using nearest neighbours in this space for replacement is thus infeasible. Inspired by recent work (Mrkšić et al., 2017) <sup class="footnote-ref"><a href="#fn21" id="fnref21">[21]</a></sup>, we could specialize the word embedding space to make it more suitable for data augmentation.</li>
<li><strong>Adversarial data augmentation:</strong> Related to recent work in interpretability (Ribeiro et al., 2016) <sup class="footnote-ref"><a href="#fn22" id="fnref22">[22]</a></sup>, we could change the most salient words in an example, i.e. those that a model depends on for a prediction. This still requires a semantics-preserving replacement method, however.</li>
</ol>
<h2 id="fewshotlearningfornlp">Few-shot learning for NLP</h2>
<p>Zero-shot, one-shot and few-shot learning are one of the most interesting recent research directions IMO. Following the key insight from Vinyals et al. (2016) <sup class="footnote-ref"><a href="#fn23" id="fnref23">[23]</a></sup> that a few-shot learning model should be explicitly trained to perform few-shot learning, we have seen several recent advances (Ravi and Larochelle, 2017; Snell et al., 2017) <sup class="footnote-ref"><a href="#fn24" id="fnref24">[24]</a></sup> <sup class="footnote-ref"><a href="#fn25" id="fnref25">[25]</a></sup>.</p>
<p>Learning from few labeled samples is one of the hardest problems IMO and one of the core capabilities that separates the current generation of ML models from more generally applicable systems. Zero-shot learning has only been investigated in the context of <a href="http://ruder.io/word-embeddings-2017/index.html#oovhandling">learning word embeddings for unknown words</a> AFAIK. Dataless classification (Song and Roth, 2014; Song et al., 2016) <sup class="footnote-ref"><a href="#fn26" id="fnref26">[26]</a></sup> <sup class="footnote-ref"><a href="#fn27" id="fnref27">[27]</a></sup> is an interesting related direction that embeds labels and documents in a joint space, but requires interpretable labels with good descriptions.</p>
<p>Potential research directions are the following:</p>
<ol>
<li><strong>Standardized benchmarks:</strong> Create standardized benchmarks for few-shot learning for NLP. Vinyals et al. (2016) introduce a one-shot language modelling task for the Penn Treebank. The task, while useful, is dwarfed by the extensive evaluation on CV benchmarks and has not seen much use AFAIK. A few-shot learning benchmark for NLP should contain a large number of classes and provide a standardized split for reproducibility. Good candidate tasks would be topic classification or fine-grained entity recognition.</li>
<li><strong>Evaluation study</strong>: After creating such a benchmark, the next step would be to evaluate how well existing few-shot learning models from CV perform for NLP.</li>
<li><strong>Novel methods for NLP</strong>: Given a dataset for benchmarking and an empirical evaluation study, we could then start developing novel methods that can perform few-shot learning for NLP.</li>
</ol>
<h2 id="transferlearningfornlp">Transfer learning for NLP</h2>
<p>Transfer learning has had a large impact on computer vision (CV) and has greatly lowered the entry threshold for people wanting to apply CV algorithms to their own problems. CV practicioners are no longer required to perform extensive feature-engineering for every new task, but can simply fine-tune a model pretrained on a large dataset with a small number of examples.</p>
<p>In NLP, however, we have so far only been pretraining the first layer of our models via pretrained embeddings. Recent approaches (Peters et al., 2017, 2018) <sup class="footnote-ref"><a href="#fn28" id="fnref28">[28]</a></sup> <sup class="footnote-ref"><a href="#fn29" id="fnref29">[29]</a></sup> add pretrained language model embedddings, but these still require custom architectures for every task. In my opinion, in order to unlock the true potential of transfer learning for NLP, we need to pretrain the entire model and fine-tune it on the target task, akin to fine-tuning ImageNet models. Language modelling, for instance, is a great task for pretraining and could be to NLP what ImageNet classification is to CV (Howard and Ruder, 2018) <sup class="footnote-ref"><a href="#fn30" id="fnref30">[30]</a></sup>.</p>
<p>Here are some potential research directions in this context:</p>
<ol>
<li><strong>Identify useful pretraining tasks:</strong> The choice of the pretraining task is very important as even fine-tuning a model on a related task might only provide limited success (Mou et al., 2016) <sup class="footnote-ref"><a href="#fn31" id="fnref31">[31]</a></sup>. Other tasks such as those explored in recent work on learning general-purpose sentence embeddings (Conneau et al., 2017; Subramanian et al., 2018; Nie et al., 2017) <sup class="footnote-ref"><a href="#fn32" id="fnref32">[32]</a></sup> <sup class="footnote-ref"><a href="#fn33" id="fnref33">[33]</a></sup> <sup class="footnote-ref"><a href="#fn34" id="fnref34">[34]</a></sup> might be complementary to language model pretraining or suitable for other target tasks.</li>
<li><strong>Fine-tuning of complex architectures:</strong> Pretraining is most useful when a model can be applied to many target tasks. However, it is still unclear how to pretrain more complex architectures, such as those used for pairwise classification tasks (Augenstein et al., 2018) or reasoning tasks such as QA or reading comprehension.</li>
</ol>
<h2 id="multitasklearning">Multi-task learning</h2>
<p>Multi-task learning (MTL) has become more commonly used in NLP. See <a href="http://ruder.io/multi-task/">here</a> for a general overview of multi-task learning and <a href="http://ruder.io/multi-task-learning-nlp/">here</a> for MTL objectives for NLP. However, there is still much we don't understand about multi-task learning in general.</p>
<p>The main questions regarding MTL give rise to many interesting research directions:</p>
<ol>
<li><strong>Identify effective auxiliary tasks:</strong> One of the main questions is which tasks are useful for multi-task learning. Label entropy has been shown to be a predictor of MTL success (Alonso and Plank, 2017) <sup class="footnote-ref"><a href="#fn35" id="fnref35">[35]</a></sup>, but this does not tell the whole story. In recent work (Augenstein et al., 2018) <sup class="footnote-ref"><a href="#fn36" id="fnref36">[36]</a></sup>, we have found that auxiliary tasks with more data and more fine-grained labels are more useful. It would be useful if future MTL papers would not only propose a new model or auxiliary task, but also try to understand why a certain auxiliary task might be better than another closely related one.</li>
<li><strong>Alternatives to hard parameter sharing:</strong> Hard parameter sharing is still the default modus operandi for MTL, but places a strong constraint on the model to compress knowledge pertaining to different tasks with the same parameters, which often makes learning difficult. We need better ways of doing MTL that are easy to use and work reliably across many tasks. Recently proposed methods such as cross-stitch units (Misra et al., 2017; Ruder et al., 2017) <sup class="footnote-ref"><a href="#fn37" id="fnref37">[37]</a></sup> <sup class="footnote-ref"><a href="#fn38" id="fnref38">[38]</a></sup> and a label embedding layer (Augenstein et al., 2018) are promising steps in this direction.</li>
<li><strong>Artificial auxiliary tasks:</strong> The best auxiliary tasks are those, which are tailored to the target task and do not require any additional data. I have outlined a list of potential <em>artificial</em> auxiliary tasks <a href="http://ruder.io/multi-task-learning-nlp/">here</a>. However, it is not clear which of these work reliably across a number of diverse tasks or what variations or task-specific modifications are useful.</li>
</ol>
<h2 id="crosslinguallearning">Cross-lingual learning</h2>
<p>Creating models that perform well across languages and that can transfer knowledge from resource-rich to resource-poor languages is one of the most important research directions IMO. There has been much progress in learning cross-lingual representations that project different languages into a shared embedding space. Refer to Ruder et al. (2017) <sup class="footnote-ref"><a href="#fn39" id="fnref39">[39]</a></sup> for a survey.</p>
<p>Cross-lingual representations are commonly evaluated either intrinsically on similarity benchmarks or extrinsically on downstream tasks, such as text classification. While recent methods have advanced the state-of-the-art for many of these settings, we do not have a good understanding of the tasks or languages for which these methods fail and how to mitigate these failures in a task-independent manner, e.g. by injecting task-specific constraints (Mrkšić et al., 2017).</p>
<h2 id="taskindependentarchitectureimprovements">Task-independent architecture improvements</h2>
<p>Novel architectures that outperform the current state-of-the-art and are tailored to specific tasks are regularly introduced, superseding the previous architecture. I have outlined <a href="http://ruder.io/deep-learning-nlp-best-practices/">best practices for different NLP tasks</a> before, but without comparing such architectures on different tasks, it is often hard to gain insights from specialized architectures and tell which components would also be useful in other settings.</p>
<p>A particularly promising recent model is the Transformer (Vaswani et al., 2017) <sup class="footnote-ref"><a href="#fn40" id="fnref40">[40]</a></sup>. While the complete model might not be appropriate for every task, components such as multi-head attention or position-based encoding could be building blocks that are generally useful for many NLP tasks.</p>
<h2 id="conclusion">Conclusion</h2>
<p>I hope you've found this collection of research directions useful. If you have suggestions on how to tackle some of these problems or ideas for related research topics, feel free to comment below.</p>
<p>Cover image is from Tobin et al. (2017).</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>Krizhevsky, A., Sutskever, I., &amp; Hinton, G. E. (2012). Imagenet classification with deep convolutional neural networks. In Advances in neural information processing systems (pp. 1097-1105). <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>Tobin, J., Fong, R., Ray, A., Schneider, J., Zaremba, W., &amp; Abbeel, P. (2017). Domain Randomization for Transferring Deep Neural Networks from Simulation to the Real World. arXiv Preprint arXiv:1703.06907. Retrieved from <a href="http://arxiv.org/abs/1703.06907">http://arxiv.org/abs/1703.06907</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>Zhang, H., Cisse, M., Dauphin, Y. N., &amp; Lopez-Paz, D. (2017). mixup: Beyond Empirical Risk Minimization, 1–11. Retrieved from <a href="http://arxiv.org/abs/1710.09412">http://arxiv.org/abs/1710.09412</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>Li, Y., Cohn, T., &amp; Baldwin, T. (2017). Robust Training under Linguistic Adversity. In Proceedings of the 15th Conference of the European Chapter of the Association for Computational Linguistics (Vol. 2, pp. 21–27). <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>Wang, D., &amp; Eisner, J. (2016). The Galactic Dependencies Treebanks: Getting More Data by Synthesizing New Languages. Tacl, 4, 491–505. Retrieved from <a href="https://www.transacl.org/ojs/index.php/tacl/article/viewFile/917/212%0Ahttps://transacl.org/ojs/index.php/tacl/article/view/917">https://www.transacl.org/ojs/index.php/tacl/article/viewFile/917/212
https://transacl.org/ojs/index.php/tacl/article/view/917</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p>Liu, T., Cui, Y., Yin, Q., Zhang, W., Wang, S., &amp; Hu, G. (2017). Generating and Exploiting Large-scale Pseudo Training Data for Zero Pronoun Resolution. In Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics (pp. 102–111). <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p>Xie, Z., Wang, S. I., Li, J., Levy, D., Nie, A., Jurafsky, D., &amp; Ng, A. Y. (2017). Data Noising as Smoothing in Neural Network Language Models. In Proceedings of ICLR 2017. <a href="#fnref7" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn8" class="footnote-item"><p>Samanta, S., &amp; Mehta, S. (2017). Towards Crafting Text Adversarial Samples. arXiv preprint arXiv:1707.02812. <a href="#fnref8" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn9" class="footnote-item"><p>Ebrahimi, J., Rao, A., Lowd, D., &amp; Dou, D. (2017). HotFlip: White-Box Adversarial Examples for NLP. Retrieved from <a href="http://arxiv.org/abs/1712.06751">http://arxiv.org/abs/1712.06751</a> <a href="#fnref9" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn10" class="footnote-item"><p>Jia, R., &amp; Liang, P. (2017). Adversarial Examples for Evaluating Reading Comprehension Systems. In Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing. <a href="#fnref10" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn11" class="footnote-item"><p>Yasunaga, M., Kasai, J., &amp; Radev, D. (2017). Robust Multilingual Part-of-Speech Tagging via Adversarial Training. In Proceedings of NAACL 2018. Retrieved from <a href="http://arxiv.org/abs/1711.04903">http://arxiv.org/abs/1711.04903</a> <a href="#fnref11" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn12" class="footnote-item"><p>Li, J., Monroe, W., Shi, T., Ritter, A., &amp; Jurafsky, D. (2017). Adversarial Learning for Neural Dialogue Generation. In Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing. Retrieved from <a href="http://arxiv.org/abs/1701.06547">http://arxiv.org/abs/1701.06547</a> <a href="#fnref12" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn13" class="footnote-item"><p>Sennrich, R., Haddow, B., &amp; Birch, A. (2015). Improving neural machine translation models with monolingual data. arXiv preprint arXiv:1511.06709. <a href="#fnref13" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn14" class="footnote-item"><p>Sennrich, R., Haddow, B., &amp; Birch, A. (2016). Edinburgh neural machine translation systems for wmt 16. arXiv preprint arXiv:1606.02891. <a href="#fnref14" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn15" class="footnote-item"><p>Mallinson, J., Sennrich, R., &amp; Lapata, M. (2017). Paraphrasing revisited with neural machine translation. In Proceedings of the 15th Conference of the European Chapter of the Association for Computational Linguistics: Volume 1, Long Papers (Vol. 1, pp. 881-893). <a href="#fnref15" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn16" class="footnote-item"><p>Dong, L., Mallinson, J., Reddy, S., &amp; Lapata, M. (2017). Learning to Paraphrase for Question Answering. In Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing. <a href="#fnref16" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn17" class="footnote-item"><p>Bowman, S. R., Vilnis, L., Vinyals, O., Dai, A. M., Jozefowicz, R., &amp; Bengio, S. (2016). Generating Sentences from a Continuous Space. In Proceedings of the 20th SIGNLL Conference on Computational Natural Language Learning (CoNLL). Retrieved from <a href="http://arxiv.org/abs/1511.06349">http://arxiv.org/abs/1511.06349</a> <a href="#fnref17" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn18" class="footnote-item"><p>Guu, K., Hashimoto, T. B., Oren, Y., &amp; Liang, P. (2017). Generating Sentences by Editing Prototypes. <a href="#fnref18" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn19" class="footnote-item"><p>Hu, Z., Yang, Z., Liang, X., Salakhutdinov, R., &amp; Xing, E. P. (2017). Toward Controlled Generation of Text. In Proceedings of the 34th International Conference on Machine Learning. <a href="#fnref19" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn20" class="footnote-item"><p>Shen, T., Lei, T., Barzilay, R., &amp; Jaakkola, T. (2017). Style Transfer from Non-Parallel Text by Cross-Alignment. In Advances in Neural Information Processing Systems. Retrieved from <a href="http://arxiv.org/abs/1705.09655">http://arxiv.org/abs/1705.09655</a> <a href="#fnref20" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn21" class="footnote-item"><p>Mrkšić, N., Vulić, I., Séaghdha, D. Ó., Leviant, I., Reichart, R., Gašić, M., … Young, S. (2017). Semantic Specialisation of Distributional Word Vector Spaces using Monolingual and Cross-Lingual Constraints. TACL. Retrieved from <a href="http://arxiv.org/abs/1706.00374">http://arxiv.org/abs/1706.00374</a> <a href="#fnref21" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn22" class="footnote-item"><p>Ribeiro, M. T., Singh, S., &amp; Guestrin, C. (2016, August). Why should i trust you?: Explaining the predictions of any classifier. In Proceedings of the 22nd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining (pp. 1135-1144). ACM. <a href="#fnref22" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn23" class="footnote-item"><p>Vinyals, O., Blundell, C., Lillicrap, T., Kavukcuoglu, K., &amp; Wierstra, D. (2016). Matching Networks for One Shot Learning. NIPS 2016. Retrieved from <a href="http://arxiv.org/abs/1606.04080">http://arxiv.org/abs/1606.04080</a> <a href="#fnref23" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn24" class="footnote-item"><p>Ravi, S., &amp; Larochelle, H. (2017). Optimization as a Model for Few-Shot Learning. In ICLR 2017. <a href="#fnref24" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn25" class="footnote-item"><p>Snell, J., Swersky, K., &amp; Zemel, R. S. (2017). Prototypical Networks for Few-shot Learning. In Advances in Neural Information Processing Systems. <a href="#fnref25" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn26" class="footnote-item"><p>Song, Y., &amp; Roth, D. (2014). On dataless hierarchical text classification. Proceedings of AAAI, 1579–1585. Retrieved from <a href="http://cogcomp.cs.illinois.edu/papers/SongSoRo14.pdf">http://cogcomp.cs.illinois.edu/papers/SongSoRo14.pdf</a> <a href="#fnref26" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn27" class="footnote-item"><p>Song, Y., Upadhyay, S., Peng, H., &amp; Roth, D. (2016). Cross-Lingual Dataless Classification for Many Languages. Ijcai, 2901–2907. <a href="#fnref27" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn28" class="footnote-item"><p>Peters, M. E., Ammar, W., Bhagavatula, C., &amp; Power, R. (2017). Semi-supervised sequence tagging with bidirectional language models. In Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics (ACL 2017). <a href="#fnref28" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn29" class="footnote-item"><p>Peters, M. E., Neumann, M., Iyyer, M., Gardner, M., Clark, C., Lee, K., &amp; Zettlemoyer, L. (2018). Deep contextualized word representations. Proceedings of NAACL. <a href="#fnref29" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn30" class="footnote-item"><p>Howard, J., &amp; Ruder, S. (2018). Fine-tuned Language Models for Text Classification. arXiv preprint arXiv:1801.06146. <a href="#fnref30" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn31" class="footnote-item"><p>Mou, L., Meng, Z., Yan, R., Li, G., Xu, Y., Zhang, L., &amp; Jin, Z. (2016). How Transferable are Neural Networks in NLP Applications? Proceedings of 2016 Conference on Empirical Methods in Natural Language Processing. <a href="#fnref31" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn32" class="footnote-item"><p>Conneau, A., Kiela, D., Schwenk, H., Barrault, L., &amp; Bordes, A. (2017). Supervised Learning of Universal Sentence Representations from Natural Language Inference Data. In Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing. <a href="#fnref32" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn33" class="footnote-item"><p>Subramanian, S., Trischler, A., Bengio, Y., &amp; Pal, C. J. (2018). Learning General Purpose Distributed Sentence Representations via Large Scale Multi-task Learning. In Proceedings of ICLR 2018. <a href="#fnref33" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn34" class="footnote-item"><p>Nie, A., Bennett, E. D., &amp; Goodman, N. D. (2017). DisSent: Sentence Representation Learning from Explicit Discourse Relations. arXiv Preprint arXiv:1710.04334. Retrieved from <a href="http://arxiv.org/abs/1710.04334">http://arxiv.org/abs/1710.04334</a> <a href="#fnref34" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn35" class="footnote-item"><p>Alonso, H. M., &amp; Plank, B. (2017). When is multitask learning effective? Multitask learning for semantic sequence prediction under varying data conditions. In EACL. Retrieved from <a href="http://arxiv.org/abs/1612.02251">http://arxiv.org/abs/1612.02251</a> <a href="#fnref35" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn36" class="footnote-item"><p>Augenstein, I., Ruder, S., &amp; Søgaard, A. (2018). Multi-task Learning of Pairwise Sequence Classification Tasks Over Disparate Label Spaces. In Proceedings of NAACL 2018. <a href="#fnref36" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn37" class="footnote-item"><p>Misra, I., Shrivastava, A., Gupta, A., &amp; Hebert, M. (2016). Cross-stitch Networks for Multi-task Learning. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. <a href="http://doi.org/10.1109/CVPR.2016.433">http://doi.org/10.1109/CVPR.2016.433</a> <a href="#fnref37" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn38" class="footnote-item"><p>Ruder, S., Bingel, J., Augenstein, I., &amp; Søgaard, A. (2017). Sluice networks: Learning what to share between loosely related tasks. arXiv preprint arXiv:1705.08142. <a href="#fnref38" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn39" class="footnote-item"><p>Ruder, S., Vulić, I., &amp; Søgaard, A. (2017). A Survey of Cross-lingual Word Embedding Models. arXiv Preprint arXiv:1706.04902. Retrieved from <a href="http://arxiv.org/abs/1706.04902">http://arxiv.org/abs/1706.04902</a> <a href="#fnref39" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn40" class="footnote-item"><p>Vaswani, A., Shazeer, N., Parmar, N., Uszkoreit, J., Jones, L., Gomez, A. N., … Polosukhin, I. (2017). Attention Is All You Need. In Advances in Neural Information Processing Systems. <a href="#fnref40" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
<!--kg-card-end: markdown--><!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[Optimization for Deep Learning Highlights in 2017]]></title><description><![CDATA[Different gradient descent optimization algorithms have been proposed in recent years but Adam is still most commonly used. This post discusses the most exciting highlights and most promising recent approaches that may shape the way we will optimize our models in the future.]]></description><link>http://ruder.io/deep-learning-optimization-2017/</link><guid isPermaLink="false">5c76ff7c1b9b0d18555b9e9f</guid><category><![CDATA[optimization]]></category><dc:creator><![CDATA[Sebastian Ruder]]></dc:creator><pubDate>Sun, 03 Dec 2017 15:36:00 GMT</pubDate><media:content url="http://ruder.io/content/images/2017/12/snapshot_ensembles.png" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><!--kg-card-begin: markdown--><img src="http://ruder.io/content/images/2017/12/snapshot_ensembles.png" alt="Optimization for Deep Learning Highlights in 2017"><p>This post discusses the most exciting highlights and most promising directions in optimization for Deep Learning.</p>
<p>Table of contents:</p>
<ul>
<li><a href="#improvingadam">Improving Adam</a></li>
<li><a href="#decouplingweightdecay">Decoupling weight decay</a></li>
<li><a href="#fixingtheexponentialmovingaverage">Fixing the exponential moving average</a></li>
<li><a href="#tuningthelearningrate">Tuning the learning rate</a></li>
<li><a href="#warmrestarts">Warm restarts</a></li>
<li><a href="#sgdwithrestarts">SGD with restarts</a></li>
<li><a href="#snapshotensembles">Snapshot ensembles</a></li>
<li><a href="#adamwithrestarts">Adam with restarts</a></li>
<li><a href="#learningtooptimize">Learning to optimize</a></li>
<li><a href="#understandinggeneralization">Understanding generalization</a></li>
</ul>
<p>Deep Learning ultimately is about finding a minimum that generalizes well -- with bonus points for finding one fast and reliably. Our workhorse, stochastic gradient descent (SGD), is a 60-year old algorithm (Robbins and Monro, 1951) <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>, that is as essential to the current generation of Deep Learning algorithms as back-propagation.</p>
<p>Different optimization algorithms have been proposed in recent years, which use different equations to update a model's parameters. Adam (Kingma and Ba, 2015) <sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup> was introduced in 2015 and is arguably today still the most commonly used one of these algorithms. This indicates that from the Machine Learning practitioner's perspective, best practices for optimization for Deep Learning have largely remained the same.</p>
<p>New ideas, however, have been developed over the course of this year, which may shape the way we will optimize our models in the future. In this blog post, I will touch on the most exciting highlights and most promising directions in optimization for Deep Learning in my opinion. Note that this blog post assumes a familiarity with SGD and with adaptive learning rate methods such as Adam. To get up to speed, refer to <a href="http://ruder.io/optimizing-gradient-descent/index.html">this blog post</a> for an overview of existing gradient descent optimization algorithms.</p>
<h2 id="improvingadam">Improving Adam</h2>
<p>Despite the apparent supremacy of adaptive learning rate methods such as Adam, state-of-the-art results for many tasks in computer vision and NLP such as object recognition (Huang et al., 2017) <sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup> or machine translation (Wu et al., 2016) <sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup> have still been achieved by plain old SGD with momentum. Recent theory (Wilson et al., 2017) <sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup> provides some justification for this, suggesting that adaptive learning rate methods converge to different (and less optimal) minima than SGD with momentum. It is empirically shown that the minima found by adaptive learning rate methods perform generally worse compared to those found by SGD with momentum on object recognition, character-level language modeling, and constituency parsing. This seems counter-intuitive given that Adam comes with nice convergence guarantees and that its adaptive learning rate should give it an edge over the regular SGD. However, Adam and other adaptive learning rate methods are not without their own flaws.</p>
<h3 id="decouplingweightdecay">Decoupling weight decay</h3>
<p>One factor that partially accounts for Adam's poor generalization ability compared with SGD with momentum on some datasets is weight decay. Weight decay is most commonly used in image classification problems and decays the weights \(\theta_t\) after every parameter update by multiplying them by a decay rate \(w_t\) that is slightly less than \(1\):</p>
<p>\(\theta_{t+1} = w_t : \theta_t \)</p>
<p>This prevents the weights from growing too large. As such, weight decay can also be understood as an \(\ell_2\) regularization term that depends on the weight decay rate \(w_t\) added to the loss:</p>
<p>\(\mathcal{L}_\text{reg} = \dfrac{w_t}{2} |\theta_t |^2_2 \)</p>
<p>Weight decay is commonly implemented in many neural network libraries either as the above regularization term or directly to modify the gradient. As the gradient is modified in both the momentum and Adam update equations (via multiplication with other decay terms), weight decay no longer equals \(\ell_2\) regularization. Loshchilov and Hutter (2017) <sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup> thus propose to decouple weight decay from the gradient update by adding it after the parameter update as in the original definition.<br>
The SGD with momentum and weight decay (SGDW) update then looks like the following:</p>
<p>\(<br>
\begin{align}<br>
\begin{split}<br>
v_t &amp;= \gamma v_{t-1} + \eta g_t \\<br>
\theta_{t+1} &amp;= \theta_t - v_t - \eta w_t \theta_t<br>
\end{split}<br>
\end{align}<br>
\)</p>
<p>where \(\eta\) is the learning rate and the third term in the second equation is the decoupled weight decay. Similarly, for Adam with weight decay (AdamW) we obtain:</p>
<p>\(<br>
\begin{align}<br>
\begin{split}<br>
m_t &amp;= \beta_1 m_{t-1} + (1 - \beta_1) g_t \\<br>
v_t &amp;= \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\<br>
\hat{m}_t &amp;= \dfrac{m_t}{1 - \beta^t_1} \\<br>
\hat{v}_t &amp;= \dfrac{v_t}{1 - \beta^t_2} \\<br>
\theta_{t+1} &amp;= \theta_{t} - \dfrac{\eta}{\sqrt{\hat{v}_t} + \epsilon} \hat{m}_t - \eta w_t \theta_t<br>
\end{split}<br>
\end{align}<br>
\)</p>
<p>where \(m_t\) and \(\hat{m}_t\) and \(v_t\) and \(\hat{v}_t\) are the biased and bias-corrected estimates of the first and second moments respectively and \(\beta_1\) and \(\beta_2\) are their decay rates, with the same weight decay term added to it. The authors show that this substantially improves Adam’s generalization performance and allows it to compete with SGD with momentum on image classification datasets.</p>
<p>In addition, it decouples the choice of the learning rate from the choice of the weight decay, which enables better hyperparameter optimization as the hyperparameters no longer depend on each other. It also separates the implementation of the optimizer from the implementation of the weight decay, which contributes to cleaner and more reusable code (see e.g. the <a href="https://github.com/fastai/fastai/pull/46/files">fast.ai AdamW/SGDW implementation</a>).</p>
<h3 id="fixingtheexponentialmovingaverage">Fixing the exponential moving average</h3>
<p>Several recent papers (Dozat and Manning, 2017; Laine and Aila, 2017) <sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup>,<sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup> empirically find that a lower \(\beta_2\) value, which controls the contribution of the exponential moving average of past squared gradients in Adam, e.g. \(0.99\) or \(0.9\) vs. the default \(0.999\) worked better in their respective applications, indicating that there might be an issue with the exponential moving average.</p>
<p>An <a href="https://openreview.net/forum?id=ryQu7f-RZ">ICLR 2018 submission</a> formalizes this issue and pinpoints the exponential moving average of past squared gradients as another reason for the poor generalization behaviour of adaptive learning rate methods. Updating the parameters via an exponential moving average of past squared gradients is at the heart of adaptive learning rate methods such as Adadelta, RMSprop, and Adam. The contribution of the exponential average is well-motivated: It should prevent the learning rates to become infinitesimally small as training progresses, the key flaw of the Adagrad algorithm. However, this short-term memory of the gradients becomes an obstacle in other scenarios.</p>
<p>In settings where Adam converges to a suboptimal solution, it has been observed that some minibatches provide large and informative gradients, but as these minibatches only occur rarely, exponential averaging diminishes their influence, which leads to poor convergence. The authors provide an example for a simple convex optimization problem where the same behaviour can be observed for Adam.</p>
<p>To fix this behaviour, the authors propose a new algorithm, AMSGrad that uses the maximum of past squared gradients rather than the exponential average to update the parameters. The full AMSGrad update without bias-corrected estimates can be seen below:</p>
<p>\(<br>
\begin{align}<br>
\begin{split}<br>
m_t &amp;= \beta_1 m_{t-1} + (1 - \beta_1) g_t \\<br>
v_t &amp;= \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\<br>
\hat{v}_t &amp;= \text{max}(\hat{v}_{t-1}, v_t) \\<br>
\theta_{t+1} &amp;= \theta_{t} - \dfrac{\eta}{\sqrt{\hat{v}_t} + \epsilon} m_t<br>
\end{split}<br>
\end{align}<br>
\)</p>
<p>The authors observe improved performance compared to Adam on small datasets and on CIFAR-10.</p>
<h2 id="tuningthelearningrate">Tuning the learning rate</h2>
<p>In many cases, it is not our models that require improvement and tuning, but our hyperparameters. Recent examples for language modelling demonstrate that tuning LSTM parameters (Melis et al., 2017) <sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup> and regularization parameters (Merity et al., 2017) <sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup> can yield state-of-the-art results compared to more complex models.</p>
<p>An important hyperparameter for optimization in Deep Learning is the learning rate \(\eta\). In fact, SGD has been shown to require a learning rate annealing schedule to converge to a good minimum in the first place. It is often thought that adaptive learning rate methods such as Adam are more robust to different learning rates, as they update the learning rate themselves. Even for these methods, however, there can be a large difference between a good and the optimal learning rate (psst... it's <a href="https://twitter.com/karpathy/status/801621764144971776">\(3e-4\)</a>).</p>
<p>Zhang et al. (2017) <sup class="footnote-ref"><a href="#fn11" id="fnref11">[11]</a></sup> show that SGD with a tuned learning rate annealing schedule and momentum parameter is not only competitive with Adam, but also converges faster. On the other hand, while we might think that the adaptivity of Adam's learning rates might mimic learning rate annealing, an explicit annealing schedule can still be beneficial: If we add SGD-style learning rate annealing to Adam, it converges faster and outperforms SGD on Machine Translation (Denkowski and Neubig, 2017) <sup class="footnote-ref"><a href="#fn12" id="fnref12">[12]</a></sup>.</p>
<p>In fact, learning rate annealing schedule engineering seems to be the new feature engineering as we can often find highly-tuned learning rate annealing schedules that improve the final convergence behaviour of our model. An interesting example of this is Vaswani et al. (2017) <sup class="footnote-ref"><a href="#fn13" id="fnref13">[13]</a></sup>. While it is usual to see a model's hyperparameters being subjected to large-scale hyperparameter optimization, it is interesting to see a learning rate annealing schedule as the focus of the same attention to detail: The authors use Adam with \(\beta_1=0.9\), a non-default \(\beta_2=0.98\), \(\epsilon = 10^{-9}\), and arguably one of the most elaborate annealing schedules for the learning rate \(\eta\):</p>
<p>\(\eta  = d_\text{model}^{-0.5} \cdot \min(step\text{_}num^{-0.5}, step\text{_}num \cdot warmup\text{_}steps^{-1.5}) \)</p>
<p>where \(d_\text{model}\) is the number of parameters of the model and \(warmup\text{_}steps = 4000\).</p>
<p>Another recent paper by Smith et al. (2017) <sup class="footnote-ref"><a href="#fn14" id="fnref14">[14]</a></sup> demonstrates an interesting connection between the learning rate and the batch size, two hyperparameters that are typically thought to be independent of each other: They show that decaying the learning rate is equivalent to increasing the batch size, while the latter allows for increased parallelism. Conversely, we can reduce the number of model updates and thus speed up training by increasing the learning rate and scaling the batch size. This has ramifications for large-scale Deep Learning, which can now repurpose existing training schedules with no hyperparameter tuning.</p>
<h2 id="warmrestarts">Warm restarts</h2>
<h3 id="sgdwithrestarts">SGD with restarts</h3>
<p>Another effective recent development is SGDR (Loshchilov and Hutter, 2017) <sup class="footnote-ref"><a href="#fn15" id="fnref15">[15]</a></sup>, an SGD alternative that uses warm restarts instead of learning rate annealing. In each restart, the learning rate is initialized to some value and is scheduled to decrease. Importantly, the restart is warm as the optimization does not start from scratch but from the parameters to which the model converged during the last step. The key factor is that the learning rate is decreased with an aggressive cosine annealing schedule, which rapidly lowers the learning rate and looks like the following:</p>
<p>\(\eta_t = \eta_{min}^i + \dfrac{1}{2}(\eta_{max}^i - \eta_{min}^i)(1 + \text{cos}(\dfrac{T_{cur}}{T_i}\pi)) \)</p>
<p>where \(\eta_{min}^i\) and \(\eta_{max}^i\) are ranges for the learning rate during the \(i\)-th run, \(T_{cur}\) indicates how many epochs passed since the last restart, and \(T_i\) specifies the epoch of the next restart. The warm restart schedules for \(T_i=50\), \(T_i=100\), and \(T_i=200\) compared with regular learning rate annealing are shown in Figure 1.</p>
<figure>
      <img src="http://ruder.io/content/images/2017/11/warm_restarts.png" style="width: 100%" title="Learning rate schedules with warm restarts" alt="Optimization for Deep Learning Highlights in 2017">
<figcaption>Figure 1: Learning rate schedules with warm restarts (Loshchilov and Hutter,
 2017)</figcaption>
</figure>
<p>The high initial learning rate after a restart is used to essentially catapult the parameters out of the minimum to which they previously converged and to a different area of the loss surface. The aggressive annealing then enables the model to rapidly converge to a new and better solution. The authors empirically find that SGD with warm restarts requires 2 to 4 times fewer epochs than learning rate annealing and achieves comparable or better performance.</p>
<p>Learning rate annealing with warm restarts is also known as cyclical learning rates and has been originally proposed by Smith (2017) <sup class="footnote-ref"><a href="#fn16" id="fnref16">[16]</a></sup>. Two more articles by students of <a href="http://www.fast.ai/">fast.ai</a> (which has recently started to teach this method) that discuss warm restarts and cyclical learning rates can be found <a href="https://medium.com/@bushaev/improving-the-way-we-work-with-learning-rate-5e99554f163b">here</a> and <a href="http://teleported.in/posts/cyclic-learning-rate/">here</a>.</p>
<h3 id="snapshotensembles">Snapshot ensembles</h3>
<p>Snapshot ensembles (Huang et al., 2017) <sup class="footnote-ref"><a href="#fn17" id="fnref17">[17]</a></sup> are a clever, recent technique that uses warm restarts to assemble an ensemble essentially for free when training a single model. The method trains a single model until convergence with the cosine annealing schedule that we have seen above. It then saves the model parameters, performs a warm restart, and then repeats these steps \(M\) times. In the end, all saved model snapshots are ensembled. The common SGD optimization behaviour on an error surface compared to the behaviour of snapshot ensembling can be seen in Figure 2.</p>
<figure>
      <img src="http://ruder.io/content/images/2017/11/snapshot_ensembles.png" style="width: 100%" title="Learning rate schedules with warm restarts" alt="Optimization for Deep Learning Highlights in 2017">
<figcaption>Figure 2: SGD vs. snapshot ensemble (Huang et al., 2017)</figcaption>
</figure>
<p>The success of ensembling in general relies on the diversity of the individual models in the ensemble. Snapshot ensembling thus relies on the cosine annealing schedule's ability to enable the model to converge to a different local optimum after every restart. The authors demonstrate that this holds in practice, achieving state-of-the-art results on CIFAR-10, CIFAR-100, and SVHN.</p>
<h3 id="adamwithrestarts">Adam with restarts</h3>
<p>Warm restarts did not work originally with Adam due to its dysfunctional weight decay, which we have seen before. After fixing weight decay, Loshchilov and Hutter (2017) similarly extend Adam to work with warm restarts. They set \(\eta_{min}^i=0\) and \(\eta_{max}^i=1\), which yields:</p>
<p>\(\eta_t = 0.5 + 0.5 : \text{cos}(\dfrac{T_{cur}}{T_i}\pi))\)</p>
<p>They recommend to start with an initially small \(T_i\) (between \(1%\) and \(10%\) of the total number of epochs) and multiply it by a factor of \(T_{mult}\) (e.g. \(T_{mult}=2\)) at every restart.</p>
<h2 id="learningtooptimize">Learning to optimize</h2>
<p>One of the most interesting papers of last year (and <a href="https://www.reddit.com/r/MachineLearning/comments/5n53k7/d_results_from_the_best_paper_awards/">reddit's &quot;Best paper name of 2016&quot; winner</a>) was a paper by Andrychowicz et al. (2016) <sup class="footnote-ref"><a href="#fn18" id="fnref18">[18]</a></sup> where they train an LSTM optimizer to provide the updates to the main model during training. Unfortunately, learning a separate LSTM optimizer or even using a pre-trained LSTM optimizer for optimization greatly increases the complexity of model training.</p>
<p>Another very influential learning-to-learn paper from this year uses an LSTM to generate model architectures in a domain-specific language (Zoph and Quoc, 2017) <sup class="footnote-ref"><a href="#fn19" id="fnref19">[19]</a></sup>. While the search process requires vast amounts of resources, the discovered architectures can be used as-is to replace their existing counterparts. This search process has proved effective and found architectures that achieve state-of-the-art results on language modeling and results competitive with the state-of-the-art on CIFAR-10.</p>
<p>The same search principle can be applied to any other domain where key processes have been previously defined by hand. One such domain are optimization algorithms for Deep Learning. As we have seen before, optimization algorithms are more similar than they seem: All of them use a combination of an exponential moving average of past gradients (as in momentum) and of an exponential moving average of past squared gradients (as in Adadelta, RMSprop, and Adam) (Ruder, 2016) <sup class="footnote-ref"><a href="#fn20" id="fnref20">[20]</a></sup>.</p>
<p>Bello et al. (2017) <sup class="footnote-ref"><a href="#fn21" id="fnref21">[21]</a></sup> define a domain-specific language that consists of primitives useful for optimization such as these exponential moving averages. They then sample an update rule from the space of possible update rules, use this update rule to train a model, and update the RNN controller based on the performance of the trained model on the test set. The full procedure can be seen in Figure 3.</p>
<figure>
      <img src="http://ruder.io/content/images/2017/11/neural_optimizer_search.png" style="width: 100%" title="Neural Optimizer Search" alt="Optimization for Deep Learning Highlights in 2017">
<figcaption>Figure 3: Neural Optimizer Search (Bello et al., 2017)</figcaption>
</figure>
<p>In particular, they discover two update equations, PowerSign and AddSign. The update equation for PowerSign is the following:</p>
<p>\( \theta_{t+1} = \theta_{t} - \alpha^{f(t)*<br>
\text{sign}(g_t)*\text{sign}(m_t)}*g_t \)</p>
<p>where \(\alpha\) is a hyperparameter that is often set to \(e\) or \(2\), \(f(t)\) is either \(1\) or a decay function that performs linear, cyclical or decay with restarts based on time step \(t\), and \(m_t\) is the moving average of past gradients. The common configuration uses \(\alpha=e\) and no decay.  We can observe that the update scales the gradient by \(\alpha^{f(t)}\) or \(1/\alpha^{f(t)}\) depending on whether the direction of the gradient and its moving average agree. This indicates that this momentum-like agreement between past gradients and the current one is a key piece of information for optimizing Deep Learning models.</p>
<p>AddSign in turn is defined as follows:</p>
<p>\( \theta_{t+1} = \theta_{t} - \alpha + f(t) * \text{sign}(g_t) * \text{sign}(m_t)) * g_t\)</p>
<p>with \(\alpha\) often set to \(1\) or \(2\). Similar to the above, this time the update scales \(\alpha + f(t)\) or \(\alpha - f(t)\) again depending on the agreement of the direction of the gradients. The authors show that PowerSign and AddSign outperform Adam, RMSprop, and SGD with momentum on CIFAR-10 and transfer well to other tasks such as ImageNet classification and machine translation.</p>
<h2 id="understandinggeneralization">Understanding generalization</h2>
<p>Optimization is closely tied to generalization as the minimum to which a model converges defines how well the model generalizes. Advances in optimization are thus closely correlated with theoretical advances in understanding the generalization behaviour of such minima and more generally of gaining a deeper understanding of generalization in Deep Learning.</p>
<p>However, our understanding of the generalization behaviour of deep neural networks is still very shallow. Recent work showed that the number of possible local minima grows exponentially with the number of parameters (Kawaguchi, 2016) <sup class="footnote-ref"><a href="#fn22" id="fnref22">[22]</a></sup>. Given the huge number of parameters of current Deep Learning architectures, it still seems almost magical that such models converge to solutions that generalize well, in particular given that they can completely memorize random inputs (Zhang et al., 2017) <sup class="footnote-ref"><a href="#fn23" id="fnref23">[23]</a></sup>.</p>
<p>Keskar et al. (2017) <sup class="footnote-ref"><a href="#fn24" id="fnref24">[24]</a></sup> identify the sharpness of a minimum as a source for poor generalization: In particular, they show that sharp minima found by batch gradient descent have high generalization error. This makes intuitive sense, as we generally would like our functions to be smooth and a sharp minima indicates a high irregularity in the corresponding error surface. However, more recent work suggests that sharpness may not be such a good indicator after all by showing that local minima that generalize well can be made arbitrarily sharp (Dinh et al., 2017) <sup class="footnote-ref"><a href="#fn25" id="fnref25">[25]</a></sup>. A <a href="https://www.quora.com/Why-is-the-paper-%E2%80%9CUnderstanding-Deep-Learning-Requires-Rethinking-Generalization%E2%80%9D-important/answer/Eric-Jang?srid=dWc3">Quora answer by Eric Jang</a> also discusses these articles.</p>
<p>An <a href="https://openreview.net/forum?id=r1iuQjxCZ">ICLR 2018 submission</a> demonstrates through a series of ablation analyses that a model's reliance on single directions in activation space, i.e. the activation of single units or feature maps is a good predictor of its generalization performance. They show that this holds across models trained on different datasets and for different degrees of label corruption. They find that dropout does not help to resolve this, while batch normalization discourages single direction reliance.</p>
<p>While these findings indicate that there is still much we do not know in terms of Optimization for Deep Learning, it is important to remember that convergence guarantees and a large body of work exists for convex optimization and that existing ideas and insights can also be applied to non-convex optimization to some extent. The large-scale optimization tutorial at NIPS 2016 provides an excellent overview of more theoretical work in this area (see the <a href="https://www.di.ens.fr/~fbach/fbach_tutorial_vr_nips_2016.pdf">slides part 1</a>, <a href="http://suvrit.de/talks/vr_nips16_sra.pdf">part 2</a>, and the <a href="https://channel9.msdn.com/Events/Neural-Information-Processing-Systems-Conference/Neural-Information-Processing-Systems-Conference-NIPS-2016/Large-Scale-Optimization-Beyond-Stochastic-Gradient-Descent-and-Convexity">video</a>).</p>
<h2 id="conclusion">Conclusion</h2>
<p>I hope that I was able to provide an impression of some of the compelling developments in optimization for Deep Learning over the past year. I've undoubtedly failed to mention many other approaches that are equally important and noteworthy. Please let me know in the comments below what I missed, where I made a mistake or misrepresented a method, or which aspect of optimization for Deep Learning you find particularly exciting or underexplored.</p>
<h2 id="hackernews">Hacker News</h2>
<p>You can find the discussion of this post on HN <a href="https://news.ycombinator.com/item?id=15839564">here</a>.</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>Robbins, H., &amp; Monro, S. (1951). A stochastic approximation method. The annals of mathematical statistics, 400-407. <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>Kingma, D. P., &amp; Ba, J. L. (2015). Adam: a Method for Stochastic Optimization. International Conference on Learning Representations. <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>Huang, G., Liu, Z., Weinberger, K. Q., &amp; van der Maaten, L. (2017). Densely Connected Convolutional Networks. In Proceedings of CVPR 2017. <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>Wu, Y., Schuster, M., Chen, Z., Le, Q. V, Norouzi, M., Macherey, W., … Dean, J. (2016). Google’s Neural Machine Translation System: Bridging the Gap between Human and Machine Translation. arXiv Preprint arXiv:1609.08144. <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>Wilson, A. C., Roelofs, R., Stern, M., Srebro, N., &amp; Recht, B. (2017). The Marginal Value of Adaptive Gradient Methods in Machine Learning. arXiv Preprint arXiv:1705.08292. Retrieved from <a href="http://arxiv.org/abs/1705.08292">http://arxiv.org/abs/1705.08292</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p>Loshchilov, I., &amp; Hutter, F. (2017). Fixing Weight Decay Regularization in Adam. arXiv Preprint arXi1711.05101. Retrieved from <a href="http://arxiv.org/abs/1711.05101">http://arxiv.org/abs/1711.05101</a> <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p>Dozat, T., &amp; Manning, C. D. (2017). Deep Biaffine Attention for Neural Dependency Parsing. In ICLR 2017. Retrieved from <a href="http://arxiv.org/abs/1611.01734">http://arxiv.org/abs/1611.01734</a> <a href="#fnref7" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn8" class="footnote-item"><p>Laine, S., &amp; Aila, T. (2017). Temporal Ensembling for Semi-Supervised Learning. In Proceedings of ICLR 2017. <a href="#fnref8" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn9" class="footnote-item"><p>Melis, G., Dyer, C., &amp; Blunsom, P. (2017). On the State of the Art of Evaluation in Neural Language Models. In arXiv preprint arXiv:1707.05589. <a href="#fnref9" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn10" class="footnote-item"><p>Merity, S., Shirish Keskar, N., &amp; Socher, R. (2017). Regularizing and Optimizing LSTM Language Models. arXiv Preprint arXiv:1708.02182. Retrieved from <a href="https://arxiv.org/pdf/1708.02182.pdf">https://arxiv.org/pdf/1708.02182.pdf</a> <a href="#fnref10" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn11" class="footnote-item"><p>Zhang, J., Mitliagkas, I., &amp; Ré, C. (2017). YellowFin and the Art of Momentum Tuning. In arXiv preprint arXiv:1706.03471. <a href="#fnref11" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn12" class="footnote-item"><p>Denkowski, M., &amp; Neubig, G. (2017). Stronger Baselines for Trustable Results in Neural Machine Translation. In Workshop on Neural Machine Translation (WNMT). Retrieved from <a href="https://arxiv.org/abs/1706.09733">https://arxiv.org/abs/1706.09733</a> <a href="#fnref12" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn13" class="footnote-item"><p>Vaswani, A., Shazeer, N., Parmar, N., Uszkoreit, J., Jones, L., Gomez, A. N., … Polosukhin, I. (2017). Attention Is All You Need. In Advances in Neural Information Processing Systems. <a href="#fnref13" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn14" class="footnote-item"><p>Smith, S. L., Kindermans, P.-J., &amp; Le, Q. V. (2017). Don’t Decay the Learning Rate, Increase the Batch Size. In arXiv preprint arXiv:1711.00489. Retrieved from <a href="http://arxiv.org/abs/1711.00489">http://arxiv.org/abs/1711.00489</a> <a href="#fnref14" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn15" class="footnote-item"><p>Loshchilov, I., &amp; Hutter, F. (2017). SGDR: Stochastic Gradient Descent with Warm Restarts. In Proceedings of ICLR 2017. <a href="https://doi.org/10.1002/fut">https://doi.org/10.1002/fut</a> <a href="#fnref15" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn16" class="footnote-item"><p>Smith, Leslie N. &quot;Cyclical learning rates for training neural networks.&quot; In Applications of Computer Vision (WACV), 2017 IEEE Winter Conference on, pp. 464-472. IEEE, 2017. <a href="#fnref16" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn17" class="footnote-item"><p>Huang, G., Li, Y., Pleiss, G., Liu, Z., Hopcroft, J. E., &amp; Weinberger, K. Q. (2017). Snapshot Ensembles: Train 1, get M for free. In Proceedings of ICLR 2017. <a href="#fnref17" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn18" class="footnote-item"><p>Andrychowicz, M., Denil, M., Gomez, S., Hoffman, M. W., Pfau, D., Schaul, T., &amp; de Freitas, N. (2016). Learning to learn by gradient descent by gradient descent. In Advances in Neural Information Processing Systems. Retrieved from <a href="http://arxiv.org/abs/1606.04474">http://arxiv.org/abs/1606.04474</a> <a href="#fnref18" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn19" class="footnote-item"><p>Zoph, B., &amp; Le, Q. V. (2017). Neural Architecture Search with Reinforcement Learning. In ICLR 2017. <a href="#fnref19" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn20" class="footnote-item"><p>Ruder, S. (2016). An overview of gradient descent optimization algorithms. arXiv Preprint arXiv:1609.04747. <a href="#fnref20" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn21" class="footnote-item"><p>Bello, I., Zoph, B., Vasudevan, V., &amp; Le, Q. V. (2017). Neural Optimizer Search with Reinforcement Learning. In Proceedings of the 34th International Conference on Machine Learning. <a href="#fnref21" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn22" class="footnote-item"><p>Kawaguchi, K. (2016). Deep Learning without Poor Local Minima. In Advances in Neural Information Processing Systems 29 (NIPS 2016). Retrieved from <a href="http://arxiv.org/abs/1605.07110">http://arxiv.org/abs/1605.07110</a> <a href="#fnref22" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn23" class="footnote-item"><p>Zhang, C., Bengio, S., Hardt, M., Recht, B., &amp; Vinyals, O. (2017). Understanding deep learning requires rethinking generalization. In Proceedings of ICLR 2017. <a href="#fnref23" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn24" class="footnote-item"><p>Keskar, N. S., Mudigere, D., Nocedal, J., Smelyanskiy, M., &amp; Tang, P. T. P. (2017). On Large-Batch Training for Deep Learning: Generalization Gap and Sharp Minima. In Proceedings of ICLR 2017. Retrieved from <a href="http://arxiv.org/abs/1609.04836">http://arxiv.org/abs/1609.04836</a> <a href="#fnref24" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn25" class="footnote-item"><p>Dinh, L., Pascanu, R., Bengio, S., &amp; Bengio, Y. (2017). Sharp Minima Can Generalize For Deep Nets. In Proceedings of the 34th International Conference on Machine Learning. <a href="#fnref25" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
<!--kg-card-end: markdown--><!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[Word embeddings in 2017: Trends and future directions]]></title><description><![CDATA[Word embeddings are an integral part of current NLP models, but approaches  that supersede the original word2vec have not been proposed. This post focuses on the deficiencies of word embeddings and how recent approaches have tried to resolve them.]]></description><link>http://ruder.io/word-embeddings-2017/</link><guid isPermaLink="false">5c76ff7c1b9b0d18555b9ea3</guid><category><![CDATA[word embeddings]]></category><category><![CDATA[natural language processing]]></category><category><![CDATA[cross-lingual]]></category><dc:creator><![CDATA[Sebastian Ruder]]></dc:creator><pubDate>Sat, 21 Oct 2017 09:00:00 GMT</pubDate><media:content url="http://ruder.io/content/images/2017/10/semantic_change.png" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><!--kg-card-begin: markdown--><img src="http://ruder.io/content/images/2017/10/semantic_change.png" alt="Word embeddings in 2017: Trends and future directions"><p>This post discusses the deficiencies of word embeddings and how recent approaches have tried to resolve them.</p>
<p>Table of contents:</p>
<ul>
<li><a href="#subwordlevelembeddings">Subword-level embeddings</a></li>
<li><a href="#oovhandling">OOV handling</a></li>
<li><a href="#evaluation">Evaluation</a></li>
<li><a href="#multisenseembeddings">Multi-sense embeddings</a></li>
<li><a href="#beyondwordsaspoints">Beyond words as points</a></li>
<li><a href="#phrasesandmultiwordexpressions">Phrases and multi-word expressions</a></li>
<li><a href="#bias">Bias</a></li>
<li><a href="#temporaldimension">Temporal dimension</a></li>
<li><a href="#lackoftheoreticalunderstanding">Lack of theoretical understanding</a></li>
<li><a href="#taskanddomainspecificembeddings">Task and domain-specific embeddings</a></li>
<li><a href="#transferlearning">Transfer learning</a></li>
<li><a href="#embeddingsformultiplelanguages">Embeddings for multiple languages</a></li>
<li><a href="#embeddingsbasedonothercontexts">Embeddings based on other contexts</a></li>
</ul>
<p>The word2vec method based on skip-gram with negative sampling (Mikolov et al., 2013) <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> was published in 2013 and had a large impact on the field, mainly through its accompanying software package, which enabled efficient training of dense word representations and a straightforward integration into downstream models. In some respects, we have come far since then: Word embeddings have established themselves as an integral part of Natural Language Processing (NLP) models. In other aspects, we might as well be in 2013 as we have not found ways to pre-train word embeddings that have managed to supersede the original word2vec.</p>
<p>This post will focus on the deficiencies of word embeddings and how recent approaches have tried to resolve them. If not otherwise stated, this post discusses <em>pre-trained</em> word embeddings, i.e. word representations that have been learned on a large corpus using word2vec and its variants. Pre-trained word embeddings are most effective if not millions of training examples are available (and thus transferring knowledge from a large unlabelled corpus is useful), which is true for most tasks in NLP. For an introduction to word embeddings, refer to <a href="http://ruder.io/word-embeddings-1/">this blog post</a>.</p>
<h2 id="subwordlevelembeddings">Subword-level embeddings</h2>
<p>Word embeddings have been augmented with subword-level information for many applications such as named entity recognition (Lample et al., 2016) <sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>, part-of-speech tagging (Plank et al., 2016) <sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>, dependency parsing (Ballesteros et al., 2015; Yu &amp; Vu, 2017) <sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>, <sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>, and language modelling (Kim et al., 2016) <sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>. Most of these models employ a CNN or a BiLSTM that takes as input the characters of a word and outputs a <em>character-based</em> word representation.</p>
<p>For incorporating character information into pre-trained embeddings, however, character n-grams features have been shown to be more powerful than composition functions over individual characters (Wieting et al., 2016; Bojanowski et al., 2017) <sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup>, <sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup>. Character n-grams -- by far not a novel feature for text categorization (Cavnar et al., 1994) <sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup> -- are particularly efficient and also form the basis of Facebook's fastText classifier (Joulin et al., 2016) <sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup>. Embeddings learned using fastText are <a href="https://github.com/facebookresearch/fastText/blob/master/pretrained-vectors.md">available in 294 languages</a>.</p>
<p>Subword units based on byte-pair encoding have been found to be particularly useful for machine translation (Sennrich et al., 2016) <sup class="footnote-ref"><a href="#fn11" id="fnref11">[11]</a></sup> where they have replaced words as the standard input units. They are also useful for tasks with many unknown words such as entity typing (Heinzerling &amp; Strube, 2017) <sup class="footnote-ref"><a href="#fn12" id="fnref12">[12]</a></sup>, but have not been shown to be helpful yet for standard NLP tasks, where this is not a major concern. While they can be learned easily, it is difficult to see their advantage over character-based representations for most tasks (Vania &amp; Lopez, 2017) <sup class="footnote-ref"><a href="#fn13" id="fnref13">[13]</a></sup>.</p>
<p>Another choice for using pre-trained embeddings that integrate character information is to leverage a state-of-the-art language model (Jozefowicz et al., 2016) <sup class="footnote-ref"><a href="#fn14" id="fnref14">[14]</a></sup> trained on a large in-domain corpus, e.g. the 1 Billion Word Benchmark (a pre-trained Tensorflow model can be found <a href="https://github.com/tensorflow/models/tree/master/research/lm_1b">here</a>). While language modelling has been found to be useful for different tasks as auxiliary objective (Rei, 2017) <sup class="footnote-ref"><a href="#fn15" id="fnref15">[15]</a></sup>, pre-trained language model embeddings have also been used to augment word embeddings (Peters et al., 2017) <sup class="footnote-ref"><a href="#fn16" id="fnref16">[16]</a></sup>. As we start to better understand how to pre-train and initialize our models, pre-trained language model embeddings are poised to become more effective. They might even supersede word2vec as the go-to choice for initializing word embeddings by virtue of having become more expressive and easier to train due to better frameworks and more computational resources over the last years.</p>
<h2 id="oovhandling">OOV handling</h2>
<p>One of the main problems of using pre-trained word embeddings is that they are unable to deal with out-of-vocabulary (OOV) words, i.e. words that have not been seen during training. Typically, such words are set to the UNK token and are assigned the same vector, which is an ineffective choice if the number of OOV words is large. Subword-level embeddings as discussed in the last section are one way to mitigate this issue. Another way, which is effective for reading comprehension (Dhingra et al., 2017) <sup class="footnote-ref"><a href="#fn17" id="fnref17">[17]</a></sup> is to assign OOV words their pre-trained word embedding, if one is available.</p>
<p>Recently, different approaches have been proposed for generating embeddings for OOV words on-the-fly. Herbelot and Baroni (2017) <sup class="footnote-ref"><a href="#fn18" id="fnref18">[18]</a></sup> initialize the embedding of OOV words as the sum of their context words and then rapidly refine only the OOV embedding with a high learning rate. Their approach is successful for a dataset that explicitly requires to model nonce words, but it is unclear if it can be scaled up to work reliably for more typical NLP tasks. Another interesting approach for generating OOV word embeddings is to train a character-based model to explicitly re-create pre-trained embeddings (Pinter et al., 2017) <sup class="footnote-ref"><a href="#fn19" id="fnref19">[19]</a></sup>. This is particularly useful in low-resource scenarios, where a large corpus is inaccessible and only pre-trained embeddings are available.</p>
<h2 id="evaluation">Evaluation</h2>
<p>Evaluation of pre-trained embeddings has been a contentious issue since their inception as the commonly used evaluation via word similarity or analogy datasets has been shown to only correlate weakly with downstream performance (Tsvetkov et al., 2015) <sup class="footnote-ref"><a href="#fn20" id="fnref20">[20]</a></sup>. The <a href="https://sites.google.com/site/repevalacl16/">RepEval Workshop at ACL 2016</a> exclusively focused on better ways to evaluate pre-trained embeddings. As it stands, the consensus seems to be that -- while pre-trained embeddings can be evaluated on intrinsic tasks such as word similarity for comparison against previous approaches -- the best way to evaluate them is extrinsic evaluation on downstream tasks.</p>
<h2 id="multisenseembeddings">Multi-sense embeddings</h2>
<p>A commonly cited criticism of word embeddings is that they are unable to capture polysemy. <a href="http://wwwusers.di.uniroma1.it/~collados/Slides_ACL16Tutorial_SemanticRepresentation.pdf">A tutorial at ACL 2016</a> outlined the work in recent years that focused on learning separate embeddings for multiple senses of a word (Neelakantan et al., 2014; Iacobacci et al., 2015; Pilehvar &amp; Collier, 2016) <sup class="footnote-ref"><a href="#fn21" id="fnref21">[21]</a></sup>, <sup class="footnote-ref"><a href="#fn22" id="fnref22">[22]</a></sup>, <sup class="footnote-ref"><a href="#fn23" id="fnref23">[23]</a></sup>. However, most existing approaches for learning multi-sense embeddings solely evaluate on word similarity. Pilehvar et al. (2017) <sup class="footnote-ref"><a href="#fn24" id="fnref24">[24]</a></sup> are one of the first to show results on topic categorization as a downstream task; while multi-sense embeddings outperform randomly initialized word embeddings in their experiments, they are outperformed by pre-trained word embeddings.</p>
<p>Given the stellar results Neural Machine Translation systems using word embeddings have achieved in recent years (Johnson et al., 2016) <sup class="footnote-ref"><a href="#fn25" id="fnref25">[25]</a></sup>, it seems that the current generation of models is expressive enough to contextualize and disambiguate words in context without having to rely on a dedicated disambiguation pipeline or multi-sense embeddings. However, we still need better ways to understand whether our models are actually able to sufficiently disambiguate words and how to improve this disambiguation behaviour if necessary.</p>
<h2 id="beyondwordsaspoints">Beyond words as points</h2>
<p>While we might not need separate embeddings for every sense of each word for good downstream performance, reducing each word to a point in a vector space is unarguably overly simplistic and causes us to miss out on nuances that might be useful for downstream tasks. An interesting direction is thus to employ other representations that are better able to capture these facets. Vilnis &amp; McCallum (2015) <sup class="footnote-ref"><a href="#fn26" id="fnref26">[26]</a></sup> propose to model each word as a probability distribution rather than a point vector, which allows us to represent probability mass and uncertainty across certain dimensions. Athiwaratkun &amp; Wilson (2017) <sup class="footnote-ref"><a href="#fn27" id="fnref27">[27]</a></sup> extend this approach to a multimodal distribution that allows to deal with polysemy, entailment, uncertainty, and enhances interpretability.</p>
<p>Rather than altering the representation, the embedding space can also be changed to better represent certain features. Nickel and Kiela (2017) <sup class="footnote-ref"><a href="#fn28" id="fnref28">[28]</a></sup>, for instance, embed words in a hyperbolic space, to learn hierarchical representations. Finding other ways to represent words that incorporate linguistic assumptions or better deal with the characteristics of downstream tasks is a compelling research direction.</p>
<h2 id="phrasesandmultiwordexpressions">Phrases and multi-word expressions</h2>
<p>In addition to not being able to capture multiple senses of words, word embeddings also fail to capture the meanings of phrases and multi-word expressions, which can be a function of the meaning of their constituent words, or have an entirely new meaning. Phrase embeddings have been proposed already in the original word2vec paper (Mikolov et al., 2013) <sup class="footnote-ref"><a href="#fn29" id="fnref29">[29]</a></sup> and there has been consistent work on learning better compositional and non-compositional phrase embeddings (Yu &amp; Dredze, 2015; Hashimoto &amp; Tsuruoka, 2016) <sup class="footnote-ref"><a href="#fn30" id="fnref30">[30]</a></sup>, <sup class="footnote-ref"><a href="#fn31" id="fnref31">[31]</a></sup>. However, similar to multi-sense embeddings, explicitly modelling phrases has so far not shown significant improvements on downstream tasks that would justify the additional complexity. Analogously, a better understanding of how phrases are modelled in neural networks would pave the way to methods that augment the capabilities of our models to capture compositionality and non-compositionality of expressions.</p>
<h2 id="bias">Bias</h2>
<p>Bias in our models is becoming a larger issue and we are only starting to understand its implications for training and evaluating our models. Even word embeddings trained on Google News articles exhibit female/male gender stereotypes to a disturbing extent (Bolukbasi et al., 2016) <sup class="footnote-ref"><a href="#fn32" id="fnref32">[32]</a></sup>. Understanding what other biases word embeddings capture and finding better ways to remove theses biases will be key to developing fair algorithms for natural language processing.</p>
<h2 id="temporaldimension">Temporal dimension</h2>
<p>Words are a mirror of the zeitgeist and their meanings are subject to continuous change; current representations of words might differ substantially from the way these words where used in the past and will be used in the future. An interesting direction is thus to take into account the temporal dimension and the diachronic nature of words. This can allows us to reveal laws of semantic change (Hamilton et al., 2016; Bamler &amp; Mandt, 2017; Dubossarsky et al., 2017) <sup class="footnote-ref"><a href="#fn33" id="fnref33">[33]</a></sup>, <sup class="footnote-ref"><a href="#fn34" id="fnref34">[34]</a></sup>, <sup class="footnote-ref"><a href="#fn35" id="fnref35">[35]</a></sup>, to model temporal word analogy or relatedness (Szymanski, 2017; Rosin et al., 2017) <sup class="footnote-ref"><a href="#fn36" id="fnref36">[36]</a></sup>, <sup class="footnote-ref"><a href="#fn37" id="fnref37">[37]</a></sup>, or to capture the dynamics of semantic relations (Kutuzov et al., 2017) <sup class="footnote-ref"><a href="#fn37" id="fnref37:1">[37:1]</a></sup>.</p>
<h2 id="lackoftheoreticalunderstanding">Lack of theoretical understanding</h2>
<p>Besides the insight that word2vec with skip-gram negative sampling implicitly factorizes a PMI matrix (Levy &amp; Goldberg, 2014) <sup class="footnote-ref"><a href="#fn38" id="fnref38">[38]</a></sup>, there has been comparatively little work on gaining a better theoretical understanding of the word embedding space and its properties, e.g. that summation captures analogy relations. Arora et al. (2016) <sup class="footnote-ref"><a href="#fn39" id="fnref39">[39]</a></sup> propose a new generative model for word embeddings, which treats corpus generation as a random walk of a discourse vector and establishes some theoretical motivations regarding the analogy behaviour. Gittens et al. (2017) <sup class="footnote-ref"><a href="#fn40" id="fnref40">[40]</a></sup> provide a more thorough theoretical justification of additive compositionality and show that skip-gram word vectors are optimal in an information-theoretic sense. Mimno &amp; Thompson (2017) <sup class="footnote-ref"><a href="#fn41" id="fnref41">[41]</a></sup> furthermore reveal an interesting relation between word embeddings and the embeddings of context words, i.e. that they are not evenly dispersed across the vector space, but occupy a narrow cone that is diametrically opposite to the context word embeddings. Despite these additional insights, our understanding regarding the location and properties of word embeddings is still lacking and more theoretical work is necessary.</p>
<h2 id="taskanddomainspecificembeddings">Task and domain-specific embeddings</h2>
<p>One of the major downsides of using pre-trained embeddings is that the news data used for training them is often very different from the data on which we would like to use them. In most cases, however, we do not have access to millions of unlabelled documents in our target domain that would allow for pre-training good embeddings from scratch. We would thus like to be able to adapt embeddings pre-trained on large news corpora, so that they capture the characteristics of our target domain, but still retain all relevant existing knowledge. Lu &amp; Zheng (2017) <sup class="footnote-ref"><a href="#fn42" id="fnref42">[42]</a></sup> proposed a regularized skip-gram model for learning such cross-domain embeddings. In the future, we will need even better ways to adapt pre-trained embeddings to new domains or to incorporate the knowledge from multiple relevant domains.</p>
<p>Rather than adapting to a new domain, we can also use existing knowledge encoded in semantic lexicons to augment pre-trained embeddings with information that is relevant for our task. An effective way to inject such relations into the embedding space is retro-fitting (Faruqui et al., 2015) <sup class="footnote-ref"><a href="#fn43" id="fnref43">[43]</a></sup>, which has been expanded to other resources such as ConceptNet (Speer et al., 2017) <sup class="footnote-ref"><a href="#fn44" id="fnref44">[44]</a></sup> and extended with an intelligent selection of positive and negative examples (Mrkšić et al., 2017) <sup class="footnote-ref"><a href="#fn45" id="fnref45">[45]</a></sup>. Injecting additional prior knowledge into word embeddings such as monotonicity (You et al., 2017) <sup class="footnote-ref"><a href="#fn46" id="fnref46">[46]</a></sup>, word similarity (Niebler et al., 2017) <sup class="footnote-ref"><a href="#fn47" id="fnref47">[47]</a></sup>, task-related grading or intensity, or logical relations is an important research direction that will allow to make our models more robust.</p>
<p>Word embeddings are useful for a wide variety of applications beyond NLP such as information retrieval, recommendation, and link prediction in knowledge bases, which all have their own task-specific approaches. Wu et al. (2017) <sup class="footnote-ref"><a href="#fn48" id="fnref48">[48]</a></sup> propose a general-purpose model that is compatible with many of these applications and can serve as a strong baseline.</p>
<h2 id="transferlearning">Transfer learning</h2>
<p>Rather than adapting word embeddings to any particular task, recent work has sought to create <em>contextualized</em> word vectors by augmenting word embeddings with embeddings based on the hidden states of models pre-trained for certain tasks, such as machine translation (McCann et al., 2017) <sup class="footnote-ref"><a href="#fn49" id="fnref49">[49]</a></sup> or language modelling (Peters et al., 2018) <sup class="footnote-ref"><a href="#fn50" id="fnref50">[50]</a></sup>. Together with fine-tuning pre-trained models (Howard and Ruder, 2018) <sup class="footnote-ref"><a href="#fn51" id="fnref51">[51]</a></sup>, this is one of the most promising research directions.</p>
<h2 id="embeddingsformultiplelanguages">Embeddings for multiple languages</h2>
<p>As NLP models are being increasingly employed and evaluated on multiple languages, creating multilingual word embeddings is becoming a more important issue and has received increased interest over recent years. A promising direction is to develop methods that learn cross-lingual representations with as few parallel data as possible, so that they can be easily applied to learn representations even for low-resource languages. For a recent survey in this area, refer to Ruder et al. (2017) <sup class="footnote-ref"><a href="#fn52" id="fnref52">[52]</a></sup>.</p>
<h2 id="embeddingsbasedonothercontexts">Embeddings based on other contexts</h2>
<p>Word embeddings are typically learned only based on the window of surrounding context words. Levy &amp; Goldberg (2014) <sup class="footnote-ref"><a href="#fn53" id="fnref53">[53]</a></sup> have shown that dependency structures can be used as context to capture more syntactic word relations; Köhn (2015) <sup class="footnote-ref"><a href="#fn54" id="fnref54">[54]</a></sup> finds that such dependency-based embeddings perform best for a particular multilingual evaluation method that clusters embeddings along different syntactic features.</p>
<p>Melamud et al. (2016) <sup class="footnote-ref"><a href="#fn55" id="fnref55">[55]</a></sup> observe that different context types work well for different downstream tasks and that simple concatenation of word embeddings learned with different context types can yield further performance gains. Given the recent success of incorporating graph structures into neural models for different tasks as -- for instance -- exhibited by graph-convolutional neural networks (Bastings et al., 2017; Marcheggiani &amp; Titov, 2017) <sup class="footnote-ref"><a href="#fn56" id="fnref56">[56]</a></sup> <sup class="footnote-ref"><a href="#fn57" id="fnref57">[57]</a></sup>, we can conjecture that incorporating such structures for learning embeddings for downstream tasks may also be beneficial.</p>
<p>Besides selecting context words differently, additional context may also be used in other ways: Tissier et al. (2017) <sup class="footnote-ref"><a href="#fn58" id="fnref58">[58]</a></sup> incorporate co-occurrence information from dictionary definitions into the negative sampling process to move related works closer together and prevent them from being used as negative samples. We can think of topical or relatedness information derived from other contexts such as article headlines or Wikipedia intro paragraphs that could similarly be used to make the representations more applicable to a particular downstream task.</p>
<h2 id="conclusion">Conclusion</h2>
<p>It is nice to see that as a community we are progressing from applying word embeddings to every possible problem to gaining a more principled, nuanced, and practical understanding of them. This post was meant to highlight some of the current trends and future directions for learning word embeddings that I found most compelling. I've undoubtedly failed to mention many other areas that are equally important and noteworthy. Please let me know in the comments below what I missed, where I made a mistake or misrepresented a method, or just which aspect of word embeddings you find particularly exciting or unexplored.</p>
<h1 id="hackernews">Hacker News</h1>
<p>Refer to the <a href="https://news.ycombinator.com/item?id=15521957">discussion on Hacker News</a> for some more insights on word embeddings.</p>
<h2 id="otherblogpostsonwordembeddings">Other blog posts on word embeddings</h2>
<p>If you want to learn more about word embeddings, these other blog posts on word embeddings are also available:</p>
<ul>
<li><a href="http://ruder.io/word-embeddings-1/index.html">On word embeddings - Part 1</a></li>
<li><a href="http://ruder.io/word-embeddings-softmax/index.html">On word embeddings - Part 2: Approximating the softmax</a></li>
<li><a href="http://ruder.io/secret-word2vec/index.html">On word embeddings - Part 3: The secret ingredients of word2vec</a></li>
<li><a href="http://ruder.io/cross-lingual-embeddings/index.html">Unofficial Part 4: A survey of cross-lingual embedding models</a></li>
</ul>
<h2 id="references">References</h2>
<p>Cover image credit: Hamilton et al. (2016)</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>Mikolov, T., Corrado, G., Chen, K., &amp; Dean, J. (2013). Efficient Estimation of Word Representations in Vector Space. Proceedings of the International Conference on Learning Representations (ICLR 2013), 1–12. <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>Lample, G., Ballesteros, M., Subramanian, S., Kawakami, K., &amp; Dyer, C. (2016). Neural Architectures for Named Entity Recognition. In NAACL-HLT 2016. <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>Plank, B., Søgaard, A., &amp; Goldberg, Y. (2016). Multilingual Part-of-Speech Tagging with Bidirectional Long Short-Term Memory Models and Auxiliary Loss. In Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics. <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>Ballesteros, M., Dyer, C., &amp; Smith, N. A. (2015). Improved Transition-Based Parsing by Modeling Characters instead of Words with LSTMs. In Proceedings of EMNLP 2015. <a href="https://doi.org/10.18653/v1/D15-1041">https://doi.org/10.18653/v1/D15-1041</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>Yu, X., &amp; Vu, N. T. (2017). Character Composition Model with Convolutional Neural Networks for Dependency Parsing on Morphologically Rich Languages. In Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics (pp. 672–678). <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p>Kim, Y., Jernite, Y., Sontag, D., &amp; Rush, A. M. (2016). Character-Aware Neural Language Models. AAAI. Retrieved from <a href="http://arxiv.org/abs/1508.06615">http://arxiv.org/abs/1508.06615</a> <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p>Wieting, J., Bansal, M., Gimpel, K., &amp; Livescu, K. (2016). Charagram: Embedding Words and Sentences via Character n-grams. Retrieved from <a href="http://arxiv.org/abs/1607.02789">http://arxiv.org/abs/1607.02789</a> <a href="#fnref7" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn8" class="footnote-item"><p>Bojanowski, P., Grave, E., Joulin, A., &amp; Mikolov, T. (2017). Enriching Word Vectors with Subword Information. Transactions of the Association for Computational Linguistics. Retrieved from <a href="http://arxiv.org/abs/1607.04606">http://arxiv.org/abs/1607.04606</a> <a href="#fnref8" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn9" class="footnote-item"><p>Cavnar, W. B., Trenkle, J. M., &amp; Mi, A. A. (1994). N-Gram-Based Text Categorization. Ann Arbor MI 48113.2, 161–175. <a href="https://doi.org/10.1.1.53.9367">https://doi.org/10.1.1.53.9367</a> <a href="#fnref9" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn10" class="footnote-item"><p>Joulin, A., Grave, E., Bojanowski, P., &amp; Mikolov, T. (2016). Bag of Tricks for Efficient Text Classification. arXiv Preprint arXiv:1607.01759. Retrieved from <a href="http://arxiv.org/abs/1607.01759">http://arxiv.org/abs/1607.01759</a> <a href="#fnref10" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn11" class="footnote-item"><p>Sennrich, R., Haddow, B., &amp; Birch, A. (2016). Neural Machine Translation of Rare Words with Subword Units. In Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics (ACL 2016). Retrieved from <a href="http://arxiv.org/abs/1508.07909">http://arxiv.org/abs/1508.07909</a> <a href="#fnref11" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn12" class="footnote-item"><p>Heinzerling, B., &amp; Strube, M. (2017). BPEmb: Tokenization-free Pre-trained Subword Embeddings in 275 Languages. Retrieved from <a href="http://arxiv.org/abs/1710.02187">http://arxiv.org/abs/1710.02187</a> <a href="#fnref12" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn13" class="footnote-item"><p>Vania, C., &amp; Lopez, A. (2017). From Characters to Words to in Between: Do We Capture Morphology? In Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics (pp. 2016–2027). <a href="#fnref13" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn14" class="footnote-item"><p>Jozefowicz, R., Vinyals, O., Schuster, M., Shazeer, N., &amp; Wu, Y. (2016). Exploring the Limits of Language Modeling. arXiv Preprint arXiv:1602.02410. Retrieved from <a href="http://arxiv.org/abs/1602.02410">http://arxiv.org/abs/1602.02410</a> <a href="#fnref14" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn15" class="footnote-item"><p>Rei, M. (2017). Semi-supervised Multitask Learning for Sequence Labeling. In Proceedings of ACL 2017. <a href="#fnref15" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn16" class="footnote-item"><p>Peters, M. E., Ammar, W., Bhagavatula, C., &amp; Power, R. (2017). Semi-supervised sequence tagging with bidirectional language models. In Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics (pp. 1756–1765). <a href="#fnref16" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn17" class="footnote-item"><p>Dhingra, B., Liu, H., Salakhutdinov, R., &amp; Cohen, W. W. (2017). A Comparative Study of Word Embeddings for Reading Comprehension. arXiv preprint arXiv:1703.00993. <a href="#fnref17" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn18" class="footnote-item"><p>Herbelot, A., &amp; Baroni, M. (2017). High-risk learning: acquiring new word vectors from tiny data. In Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing. <a href="#fnref18" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn19" class="footnote-item"><p>Pinter, Y., Guthrie, R., &amp; Eisenstein, J. (2017). Mimicking Word Embeddings using Subword RNNs. In Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing. Retrieved from <a href="http://arxiv.org/abs/1707.06961">http://arxiv.org/abs/1707.06961</a> <a href="#fnref19" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn20" class="footnote-item"><p>Tsvetkov, Y., Faruqui, M., Ling, W., Lample, G., &amp; Dyer, C. (2015). Evaluation of Word Vector Representations by Subspace Alignment. Proceedings of the 2015 Conference on Empirical Methods in Natural Language Processing, Lisbon, Portugal, 17-21 September 2015, 2049–2054. <a href="#fnref20" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn21" class="footnote-item"><p>Neelakantan, A., Shankar, J., Passos, A., &amp; Mccallum, A. (2014). Efficient Non-parametric Estimation of Multiple Embeddings per Word in Vector Space. In Proceedings fo (pp. 1059–1069). <a href="#fnref21" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn22" class="footnote-item"><p>Iacobacci, I., Pilehvar, M. T., &amp; Navigli, R. (2015). SensEmbed: Learning Sense Embeddings for Word and Relational Similarity. In Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing (pp. 95–105). <a href="#fnref22" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn23" class="footnote-item"><p>Pilehvar, M. T., &amp; Collier, N. (2016). De-Conflated Semantic Representations. In Proceedings of EMNLP. <a href="#fnref23" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn24" class="footnote-item"><p>Pilehvar, M. T., Camacho-Collados, J., Navigli, R., &amp; Collier, N. (2017). Towards a Seamless Integration of Word Senses into Downstream NLP Applications. In Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers) (pp. 1857–1869). <a href="https://doi.org/10.18653/v1/P17-1170">https://doi.org/10.18653/v1/P17-1170</a> <a href="#fnref24" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn25" class="footnote-item"><p>Johnson, M., Schuster, M., Le, Q. V, Krikun, M., Wu, Y., Chen, Z., … Dean, J. (2016). Google’s Multilingual Neural Machine Translation System: Enabling Zero-Shot Translation. arXiv Preprint arXiv:1611.0455. <a href="#fnref25" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn26" class="footnote-item"><p>Vilnis, L., &amp; McCallum, A. (2015). Word Representations via Gaussian Embedding. ICLR. Retrieved from <a href="http://arxiv.org/abs/1412.6623">http://arxiv.org/abs/1412.6623</a> <a href="#fnref26" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn27" class="footnote-item"><p>Athiwaratkun, B., &amp; Wilson, A. G. (2017). Multimodal Word Distributions. In Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics (ACL 2017). <a href="#fnref27" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn28" class="footnote-item"><p>Nickel, M., &amp; Kiela, D. (2017). Poincaré Embeddings for Learning Hierarchical Representations. arXiv Preprint arXiv:1705.08039. Retrieved from <a href="http://arxiv.org/abs/1705.08039">http://arxiv.org/abs/1705.08039</a> <a href="#fnref28" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn29" class="footnote-item"><p>Mikolov, T., Chen, K., Corrado, G., &amp; Dean, J. (2013). Distributed Representations of Words and Phrases and their Compositionality. NIPS. <a href="#fnref29" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn30" class="footnote-item"><p>Yu, M., &amp; Dredze, M. (2015). Learning Composition Models for Phrase Embeddings. Transactions of the ACL, 3, 227–242. <a href="#fnref30" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn31" class="footnote-item"><p>Hashimoto, K., &amp; Tsuruoka, Y. (2016). Adaptive Joint Learning of Compositional and Non-Compositional Phrase Embeddings. ACL, 205–215. Retrieved from <a href="http://arxiv.org/abs/1603.06067">http://arxiv.org/abs/1603.06067</a> <a href="#fnref31" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn32" class="footnote-item"><p>Bolukbasi, T., Chang, K.-W., Zou, J., Saligrama, V., &amp; Kalai, A. (2016). Man is to Computer Programmer as Woman is to Homemaker? Debiasing Word Embeddings. In 30th Conference on Neural Information Processing Systems (NIPS 2016). Retrieved from <a href="http://arxiv.org/abs/1607.06520">http://arxiv.org/abs/1607.06520</a> <a href="#fnref32" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn33" class="footnote-item"><p>Hamilton, W. L., Leskovec, J., &amp; Jurafsky, D. (2016). Diachronic Word Embeddings Reveal Statistical Laws of Semantic Change. In Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics (pp. 1489–1501). <a href="#fnref33" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn34" class="footnote-item"><p>Bamler, R., &amp; Mandt, S. (2017). Dynamic Word Embeddings via Skip-Gram Filtering. In Proceedings of ICML 2017. Retrieved from <a href="http://arxiv.org/abs/1702.08359">http://arxiv.org/abs/1702.08359</a> <a href="#fnref34" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn35" class="footnote-item"><p>Dubossarsky, H., Grossman, E., &amp; Weinshall, D. (2017). Outta Control: Laws of Semantic Change and Inherent Biases in Word Representation Models. In Conference on Empirical Methods in Natural Language Processing (pp. 1147–1156). Retrieved from <a href="http://aclweb.org/anthology/D17-1119">http://aclweb.org/anthology/D17-1119</a> <a href="#fnref35" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn36" class="footnote-item"><p>Szymanski, T. (2017). Temporal Word Analogies : Identifying Lexical Replacement with Diachronic Word Embeddings. In Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics (pp. 448–453). <a href="#fnref36" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn37" class="footnote-item"><p>Rosin, G., Radinsky, K., &amp; Adar, E. (2017). Learning Word Relatedness over Time. In Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing. Retrieved from <a href="https://arxiv.org/pdf/1707.08081.pdf">https://arxiv.org/pdf/1707.08081.pdf</a> <a href="#fnref37" class="footnote-backref">↩︎</a> <a href="#fnref37:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn38" class="footnote-item"><p>Levy, O., &amp; Goldberg, Y. (2014). Neural Word Embedding as Implicit Matrix Factorization. Advances in Neural Information Processing Systems (NIPS), 2177–2185. Retrieved from <a href="http://papers.nips.cc/paper/5477-neural-word-embedding-as-implicit-matrix-factorization">http://papers.nips.cc/paper/5477-neural-word-embedding-as-implicit-matrix-factorization</a> <a href="#fnref38" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn39" class="footnote-item"><p>Arora, S., Li, Y., Liang, Y., Ma, T., &amp; Risteski, A. (2016). A Latent Variable Model Approach to PMI-based Word Embeddings. TACL, 4, 385–399. Retrieved from <a href="https://transacl.org/ojs/index.php/tacl/article/viewFile/742/204">https://transacl.org/ojs/index.php/tacl/article/viewFile/742/204</a> <a href="#fnref39" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn40" class="footnote-item"><p>Gittens, A., Achlioptas, D., &amp; Mahoney, M. W. (2017). Skip-Gram – Zipf + Uniform = Vector Additivity. In Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics (pp. 69–76). <a href="https://doi.org/10.18653/v1/P17-1007">https://doi.org/10.18653/v1/P17-1007</a> <a href="#fnref40" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn41" class="footnote-item"><p>Mimno, D., &amp; Thompson, L. (2017). The strange geometry of skip-gram with negative sampling. In Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing (pp. 2863–2868). <a href="#fnref41" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn42" class="footnote-item"><p>Lu, W., &amp; Zheng, V. W. (2017). A Simple Regularization-based Algorithm for Learning Cross-Domain Word Embeddings. In Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing (pp. 2888–2894). <a href="#fnref42" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn43" class="footnote-item"><p>Faruqui, M., Dodge, J., Jauhar, S. K., Dyer, C., Hovy, E., &amp; Smith, N. A. (2015). Retrofitting Word Vectors to Semantic Lexicons. In NAACL 2015. <a href="#fnref43" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn44" class="footnote-item"><p>Speer, R., Chin, J., &amp; Havasi, C. (2017). ConceptNet 5.5: An Open Multilingual Graph of General Knowledge. In AAAI 31 (pp. 4444–4451). Retrieved from <a href="http://arxiv.org/abs/1612.03975">http://arxiv.org/abs/1612.03975</a> <a href="#fnref44" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn45" class="footnote-item"><p>Mrkšić, N., Vulić, I., Séaghdha, D. Ó., Leviant, I., Reichart, R., Gašić, M., … Young, S. (2017). Semantic Specialisation of Distributional Word Vector Spaces using Monolingual and Cross-Lingual Constraints. TACL. Retrieved from <a href="http://arxiv.org/abs/1706.00374">http://arxiv.org/abs/1706.00374</a> <a href="#fnref45" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn46" class="footnote-item"><p>You, S., Ding, D., Canini, K., Pfeifer, J., &amp; Gupta, M. (2017). Deep Lattice Networks and Partial Monotonic Functions. In 31st Conference on Neural Information Processing Systems (NIPS 2017). Retrieved from <a href="http://arxiv.org/abs/1709.06680">http://arxiv.org/abs/1709.06680</a> <a href="#fnref46" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn47" class="footnote-item"><p>Niebler, T., Becker, M., Pölitz, C., &amp; Hotho, A. (2017). Learning Semantic Relatedness From Human Feedback Using Metric Learning. In Proceedings of ISWC 2017. Retrieved from <a href="http://arxiv.org/abs/1705.07425">http://arxiv.org/abs/1705.07425</a> <a href="#fnref47" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn48" class="footnote-item"><p>Wu, L., Fisch, A., Chopra, S., Adams, K., Bordes, A., &amp; Weston, J. (2017). StarSpace: Embed All The Things! arXiv preprint arXiv:1709.03856. <a href="#fnref48" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn49" class="footnote-item"><p>Mccann, B., Bradbury, J., Xiong, C., &amp; Socher, R. (2017). Learned in Translation: Contextualized Word Vectors. In Advances in Neural Information Processing Systems. <a href="#fnref49" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn50" class="footnote-item"><p>Peters, M. E., Neumann, M., Iyyer, M., Gardner, M., Clark, C., Lee, K., &amp; Zettlemoyer, L. (2018). Deep contextualized word representations. Proceedings of NAACL-HLT 2018. <a href="#fnref50" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn51" class="footnote-item"><p>Howard, J., &amp; Ruder, S. (2018). Universal Language Model Fine-tuning for Text Classification. In Proceedings of ACL 2018. Retrieved from <a href="http://arxiv.org/abs/1801.06146">http://arxiv.org/abs/1801.06146</a> <a href="#fnref51" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn52" class="footnote-item"><p>Ruder, S., Vulić, I., &amp; Søgaard, A. (2017). A Survey of Cross-lingual Word Embedding Models Sebastian. arXiv preprint arXiv:1706.04902. Retrieved from <a href="http://arxiv.org/abs/1706.04902">http://arxiv.org/abs/1706.04902</a> <a href="#fnref52" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn53" class="footnote-item"><p>Levy, O., &amp; Goldberg, Y. (2014). Dependency-Based Word Embeddings. Proceedings of the 52nd Annual Meeting of the Association for Computational Linguistics (Short Papers), 302–308. <a href="https://doi.org/10.3115/v1/P14-2050">https://doi.org/10.3115/v1/P14-2050</a> <a href="#fnref53" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn54" class="footnote-item"><p>Köhn, A. (2015). What’s in an Embedding? Analyzing Word Embeddings through Multilingual Evaluation. Proceedings of the 2015 Conference on Empirical Methods in Natural Language Processing, Lisbon, Portugal, 17-21 September 2015, (2014), 2067–2073. <a href="#fnref54" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn55" class="footnote-item"><p>Melamud, O., McClosky, D., Patwardhan, S., &amp; Bansal, M. (2016). The Role of Context Types and Dimensionality in Learning Word Embeddings. In Proceedings of NAACL-HLT 2016 (pp. 1030–1040). Retrieved from <a href="http://arxiv.org/abs/1601.00893">http://arxiv.org/abs/1601.00893</a> <a href="#fnref55" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn56" class="footnote-item"><p>Bastings, J., Titov, I., Aziz, W., Marcheggiani, D., &amp; Sima’an, K. (2017). Graph Convolutional Encoders for Syntax-aware Neural Machine Translation. In Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing. <a href="#fnref56" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn57" class="footnote-item"><p>Marcheggiani, D., &amp; Titov, I. (2017). Encoding Sentences with Graph Convolutional Networks for Semantic Role Labeling. In Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing. <a href="#fnref57" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn58" class="footnote-item"><p>Tissier, J., Gravier, C., &amp; Habrard, A. (2017). Dict2Vec : Learning Word Embeddings using Lexical Dictionaries. In Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing. Retrieved from <a href="http://aclweb.org/anthology/D17-1024">http://aclweb.org/anthology/D17-1024</a> <a href="#fnref58" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
<!--kg-card-end: markdown--><!--kg-card-end: markdown-->]]></content:encoded></item></channel></rss>
