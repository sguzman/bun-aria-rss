{
  "title": "Multilevel Splitting",
  "link": "",
  "published": "2015-07-10T22:50:00+01:00",
  "updated": "2015-07-10T22:50:00+01:00",
  "author": {
    "name": "Sebastian Nowozin"
  },
  "id": "tag:www.nowozin.net,2015-07-10:/sebastian/blog/multilevel-splitting.html",
  "summary": "<p>This article is about <em>multilevel splitting</em>, a method for estimating the\nprobability of rare events.</p>\n<p>Estimating the probability of <em>rare events</em> is important in many fields.\nOne vivid example is in the study of reliability of systems; imagine for\nexample â€¦</p>",
  "content": "<p>This article is about <em>multilevel splitting</em>, a method for estimating the\nprobability of rare events.</p>\n<p>Estimating the probability of <em>rare events</em> is important in many fields.\nOne vivid example is in the study of reliability of systems; imagine for\nexample, that we are responsible for building a mechanical structure such as a\nbridge and we aim to design it to last one hundred years.\nTo provide any kind of guarantee we need to have a model of what could happen\nin these 100 years, for example how the bridge will be used during that time,\nwhat weight it will have to bear, how strong winds and floods may be, how\ncorrosion and other processes deteriorate the structure, etc.\nConsidering all these factors may only be possible approximately via a\n<em>simulation</em> of the structure under different effects.</p>\n<p>For concreteness let's say we denote by <span class=\"math\">\\(X\\)</span> the random variable that represents the\nmaximum force that is applied to the bridge during the 100 years lifetime.\nEach simulation allows us to obtain a sample <span class=\"math\">\\(X_i \\sim P\\)</span> of this force, where\n<span class=\"math\">\\(P\\)</span> is a probabilistic model of everything that can happen during the 100\nyears.\nGiven that we designed the bridge to widthstand a certain force, the question\nis now to make statements of the form\n</p>\n<div class=\"math\">$$P(X \\geq \\delta) \\leq \\epsilon.$$</div>\n<p>\nOften we want the probability of something bad happening (the event <span class=\"math\">\\(X \\geq\n\\delta\\)</span>) to be exceptionally small, say <span class=\"math\">\\(\\epsilon = 10^{-9}\\)</span>.</p>\n<p>Another common example is the <a href=\"http://www.nowozin.net/sebastian/blog/bayesian-p-values.html\">computation of P-values</a>,\nwhere we observe a sample <span class=\"math\">\\(x\\)</span> and compute a <em>test statistic</em> <span class=\"math\">\\(t=T(x)\\)</span>.  Given\na <em>null model</em> in the form of a distribution <span class=\"math\">\\(P(X)\\)</span> we are interested in the\n<em>P-value</em>, that is, the probability of the event <span class=\"math\">\\(P(T(X) \\geq t)\\)</span>.  This\nnumber is the probability under the null of observing a test statistic at\nleast as extreme as the one actually observed.\nUsing the multilevel splitting idea we can hope to accurately compute the\nP-value as long as we can run an MCMC chain on the null model.\nAlso, more general P-values for composite null models, such as the <a href=\"http://www.nowozin.net/sebastian/blog/bayesian-p-values.html\"><em>posterior\npredictive P-value</em></a> are computable.\nSo if this sounds good, how does multilevel splitting work and why is it\nneeded in the first place?</p>\n<p>In the absence of an analytic form for <span class=\"math\">\\(P\\)</span>, a naive simulation approach is to\nrepeatedly draw samples <span class=\"math\">\\(X_i \\sim P\\)</span> and to count how often the bad event\nhappens.  For rare events as the one above this does not work very well and if\nwe would exactly meet the guarantee of the above example, <span class=\"math\">\\(\\epsilon =\n10^{-9}\\)</span>, then we would on average have to draw around <span class=\"math\">\\(1/\\epsilon = 10^9\\)</span>\nsamples just to see a single bad event.\nBut because we would like to estimate the rare event probability we need even\nmore samples.</p>\n<p>There are a number of custom methods for accurate estimation of rare event\nprobabilities.  The remainder of the article discusses <em>multilevel splitting</em>,\nbut at this point I would like to mention that another popular set of methods\nfor rare events is based on adaptive importance sampling which is described in\ndetail in <a href=\"http://eu.wiley.com/WileyCDA/WileyTitle/productCd-0470177942.html\">Rubinstein and Kroese's\nbook on Monte Carlo\nmethods</a>.</p>\n<h1>Multilevel Splitting</h1>\n<p><a href=\"http://en.wikipedia.org/wiki/John_von_Neumann\">John von Neumann</a> had an idea\nbetter than naive simulation on how to address the problem of estimating rare\nevent probabilities.  He named his solution <em>multilevel splitting</em>.  The first\npublished description of multilevel splitting is due to <a href=\"https://dornsifecms.usc.edu/assets/sites/520/docs/kahnharris.pdf\">Kahn and Harris in\n1951</a> (who\nattribute it to John von Neumann).</p>\n<p>The basic idea of multilevel splitting is to steer an iterative simulation\nprocess towards the rare event region by removing samples far away from the\nrare event and <em>splitting</em> samples closer to the rare event.</p>\n<p>The application considered in the 1951 paper is interesting in this regard in\nthat it clearly relates to nuclear weapon research:</p>\n<blockquote>\n<p>\"We wish to estimate the probability that a particle is transmitted through a\nshield, when this probability is of the order of <span class=\"math\">\\(10^{-6}\\)</span> to <span class=\"math\">\\(10^{-10}\\)</span>, and\nwe wish to do this by sampling about a thousand life histories.\"\n...\n\"In one method of applying this, one defines regions of importance in the\nspace being studied, and, when the sampled particle goes from a less\nimportant to a more important region, it is split into two independent\nparticles, each one-half the weight of the original.\"</p>\n</blockquote>\n<p>Back in 1951 the algorithm was somewhat adhoc but effective.\nIn a recent 2011 <a href=\"http://perso.univ-rennes2.fr/system/files/users/guyader_a/ghm2.pdf\">paper by Guyader, Hengartner, and\nMatzner-Lober</a>\nthe authors propose a more practical variant of the same idea and provide\ntheoretical results.</p>\n<h2>Setup</h2>\n<p>The general setup is as follows.  We have a distribution <span class=\"math\">\\(P\\)</span> defining our system.\nWe have <span class=\"math\">\\(X \\in \\mathcal{X}\\)</span> for the realizations <span class=\"math\">\\(X \\sim P\\)</span>.\nA continuous map <span class=\"math\">\\(\\phi: \\mathcal{X} \\to \\mathbb{R}\\)</span> defines the quantity of interest.\nWe are interested in computing the probability <span class=\"math\">\\(P(\\phi(X) \\geq q)\\)</span>.\nTo this end we assume we can approximately simulate from <span class=\"math\">\\(P\\)</span> using a <a href=\"http://en.wikipedia.org/wiki/Markov_chain_Monte_Carlo\">Markov\nchain</a>, which is\ntypically possible even in complex models.</p>\n<p>The basic idea of the original 1951 algorithm is to fix a set of levels\n<span class=\"math\">\\(-\\infty = L_0 &lt; L_1 &lt; L_2 &lt; \\dots &lt; L_k = q\\)</span>.  Then we can formally write\n</p>\n<div class=\"math\">$$P(\\phi(X) \\geq q) = \\prod_{i=1}^k P(\\phi(X) \\geq L_i \\:|\\: \\phi(X) \\geq L_{i-1}).$$</div>\n<p>The above product can be estimated term-by-term as follows: we use a set of\n<span class=\"math\">\\(N\\)</span> particles <span class=\"math\">\\((X_1,\\dots,X_N)\\)</span> and simulate these according to <span class=\"math\">\\(X_i \\sim P(X)\\)</span>.\nThen we estimate the fraction\n</p>\n<div class=\"math\">$$P(\\phi(X) \\geq L_1 \\:|\\: \\phi(X) \\geq L_0) = P(\\phi(X) \\geq L_1)\n    \\approx \\frac{\\sum_{i=1}^N 1_{\\{\\phi(X_i) \\geq L_1\\}}}{N}.$$</div>\n<p>\nAfterwards we discard all particles with <span class=\"math\">\\(\\phi(X_i) &lt; L_1\\)</span> and use the remaining\nparticles to resample a set of <span class=\"math\">\\(N\\)</span> particles (the <em>splitting</em>).\nFinally, we update all particles using a number of steps of our MCMC kernel,\nbut this time restricted to <span class=\"math\">\\(\\phi(X_i) \\geq L_1\\)</span>, that is, we reject all\nproposals that would violate this condition.\nThis is one level, and for the multilevel scheme we repeat the above procedure\nwith the next level.  Eventually, when we reach the final level <span class=\"math\">\\(L_k\\)</span>, we take\nthe product of the estimated probabilities as the estimate of the rare event\nprobability.  Upon reaching the final level the surviving particles are\nproperly distributed conditional on the restriction <span class=\"math\">\\(\\phi(X) \\geq q\\)</span>.</p>\n<p>The above algorithm is effective but has the major drawback of having to fix a\nladder of levels apriori.  It would be more practical to instead have an\nautomatic method to create these levels or to get rid of them entirely.  The\nalgorithm of <em>Guyader et al.</em> achieves this automatic selection by keeping the\nparticles sorted according to <span class=\"math\">\\(\\phi\\)</span>, with the lowest particle defining the\ncurrent level, at the cost of having a random runtime of the algorithm.</p>\n<p>The 2011 paper is quite rich in that it also contains an approximate\nconfidence interval for the true probability as well as an analysis of the\nrandom runtime and an interesting application of estimating the false positive\nrate of watermark detection schemes (which ideally should be very small).\nAlso, a variant of their method can solve for the <em>quantile</em>, that is, given\n<span class=\"math\">\\(p\\)</span> in <span class=\"math\">\\(p = P(\\phi(X) \\geq q)\\)</span>, solve for <span class=\"math\">\\(q\\)</span>.\n(Unfortunately, in the paper, as is often the case with many statistics and\napplied math papers, the algorithm (in Section 3.2) is not presented very\nclearly compared to a typical CS or ML paper.)</p>\n<h2>Example</h2>\n<p>The following is an implementation in the <a href=\"http://julialang.org/\">Julia\nlanguage</a> that estimates <span class=\"math\">\\(P(X \\geq 16.5)\\)</span> where <span class=\"math\">\\(X \\sim\n\\mathcal{N}(0,1)\\)</span> is a standard Normal random variable.</p>\n<div class=\"highlight\"><pre><span></span><code><span class=\"k\">using</span> <span class=\"n\">Distributions</span>\n\n<span class=\"n\">N</span><span class=\"o\">=</span><span class=\"mi\">2000</span>  <span class=\"c\"># number of particles</span>\n<span class=\"n\">T</span><span class=\"o\">=</span><span class=\"mi\">10</span>   <span class=\"c\"># number of MCMC steps</span>\n<span class=\"n\">q</span><span class=\"o\">=</span><span class=\"mf\">16.5</span> <span class=\"c\"># quantile</span>\n<span class=\"n\">target</span><span class=\"o\">=</span><span class=\"n\">Normal</span><span class=\"p\">(</span><span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">1.0</span><span class=\"p\">)</span>\n<span class=\"n\">K</span><span class=\"o\">=</span><span class=\"n\">Normal</span><span class=\"p\">(</span><span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">0.2</span><span class=\"p\">)</span>  <span class=\"c\"># Markov kernel</span>\n\n<span class=\"n\">m</span><span class=\"o\">=</span><span class=\"mi\">1</span>\n<span class=\"n\">X</span><span class=\"o\">=</span><span class=\"n\">sort</span><span class=\"p\">(</span><span class=\"n\">rand</span><span class=\"p\">(</span><span class=\"n\">target</span><span class=\"p\">,</span> <span class=\"n\">N</span><span class=\"p\">))</span>\n<span class=\"n\">L</span><span class=\"o\">=</span><span class=\"n\">X</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n\n<span class=\"k\">while</span> <span class=\"n\">L</span> <span class=\"o\">&lt;</span> <span class=\"n\">q</span>   <span class=\"c\"># as long as there are particles below q</span>\n    <span class=\"n\">X</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">X</span><span class=\"p\">[</span><span class=\"n\">rand</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">:</span><span class=\"n\">N</span><span class=\"p\">)]</span>\n\n    <span class=\"c\"># Run a Markov chain on the lowermost sample</span>\n    <span class=\"k\">for</span> <span class=\"n\">t</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">T</span>\n        <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">X</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">rand</span><span class=\"p\">(</span><span class=\"n\">K</span><span class=\"p\">)</span>\n        <span class=\"n\">log_alpha</span> <span class=\"o\">=</span> <span class=\"n\">logpdf</span><span class=\"p\">(</span><span class=\"n\">target</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"n\">logpdf</span><span class=\"p\">(</span><span class=\"n\">target</span><span class=\"p\">,</span> <span class=\"n\">X</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">])</span>\n        <span class=\"k\">if</span> <span class=\"n\">log</span><span class=\"p\">(</span><span class=\"n\">rand</span><span class=\"p\">())</span> <span class=\"o\">&lt;=</span> <span class=\"n\">log_alpha</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">y</span> <span class=\"o\">&gt;</span> <span class=\"n\">L</span>\n            <span class=\"n\">X</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">y</span>\n        <span class=\"k\">end</span>\n    <span class=\"k\">end</span>\n    <span class=\"n\">X</span> <span class=\"o\">=</span> <span class=\"n\">sort</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">)</span>\n    <span class=\"n\">L</span> <span class=\"o\">=</span> <span class=\"n\">X</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n    <span class=\"n\">m</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n<span class=\"k\">end</span>\n<span class=\"n\">phat</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mf\">1.0</span><span class=\"o\">-</span><span class=\"mf\">1.0</span><span class=\"o\">/</span><span class=\"n\">N</span><span class=\"p\">)</span><span class=\"o\">^</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"c\"># Estimate, Truth</span>\n<span class=\"n\">phat</span><span class=\"p\">,</span> <span class=\"n\">ccdf</span><span class=\"p\">(</span><span class=\"n\">target</span><span class=\"p\">,</span> <span class=\"n\">q</span><span class=\"p\">)</span>\n</code></pre></div>\n\n<p>Giving the output</p>\n<div class=\"highlight\"><pre><span></span><code><span class=\"err\">(1.4581487078794118e-61,1.8344630031647276e-61)</span>\n</code></pre></div>\n\n<p>where the first number is the estimate and the second number is the ground\ntruth, known in this case analytically.\nThe relative estimation accuracy in this case is remarkably, given that this\nevent occurs on average only once every <span class=\"math\">\\(10^{61}\\)</span> samples.  For this\nsimulation a total of <span class=\"math\">\\(m=280,092\\)</span> sample updates have been performed until the\nalgorithm stopped.</p>\n<h2>Conclusion</h2>\n<p>Multilevel splitting is a useful algorithm for estimating the probability of\nrare events and the recent algorithm of Guyader et al. is practical in that it\ncan be implemented on top of an arbitrary MCMC sampler.</p>\n<p>There are caveats, however.  In the above example, the problem structure is\nalmost ideal for the application of multilevel splitting: a slowly varying\ncontinuous function <span class=\"math\">\\(\\phi\\)</span> whose level sets are topologically connected.  This\nmeans that the MCMC sampler can mix easily in the restricted subsets and the\nresulting rare event probabilities can be accurately estimated.\nIf these assumptions are not satisfied the algorithm may fail to work, and\ncurrent research addresses these more general situations, see, for example\n<a href=\"http://arxiv.org/abs/1507.00919\">this recent paper by Walter</a>.</p>\n<p>In summary, although some care is required for the application of multilevel\nsplitting to real problems it is likely to be orders of magnitude more\nefficient than naive approaches.</p>\n<script type=\"text/javascript\">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {\n    var align = \"center\",\n        indent = \"0em\",\n        linebreak = \"false\";\n\n    if (false) {\n        align = (screen.width < 768) ? \"left\" : align;\n        indent = (screen.width < 768) ? \"0em\" : indent;\n        linebreak = (screen.width < 768) ? 'true' : linebreak;\n    }\n\n    var mathjaxscript = document.createElement('script');\n    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';\n    mathjaxscript.type = 'text/javascript';\n    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';\n\n    var configscript = document.createElement('script');\n    configscript.type = 'text/x-mathjax-config';\n    configscript[(window.opera ? \"innerHTML\" : \"text\")] =\n        \"MathJax.Hub.Config({\" +\n        \"    config: ['MMLorHTML.js'],\" +\n        \"    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } },\" +\n        \"    jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" +\n        \"    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" +\n        \"    displayAlign: '\"+ align +\"',\" +\n        \"    displayIndent: '\"+ indent +\"',\" +\n        \"    showMathMenu: true,\" +\n        \"    messageStyle: 'normal',\" +\n        \"    tex2jax: { \" +\n        \"        inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" +\n        \"        displayMath: [ ['$$','$$'] ],\" +\n        \"        processEscapes: true,\" +\n        \"        preview: 'TeX',\" +\n        \"    }, \" +\n        \"    'HTML-CSS': { \" +\n        \"        availableFonts: ['STIX', 'TeX'],\" +\n        \"        preferredFont: 'STIX',\" +\n        \"        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" +\n        \"        linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" +\n        \"    }, \" +\n        \"}); \" +\n        \"if ('default' !== 'default') {\" +\n            \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" +\n                \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" +\n                \"VARIANT['normal'].fonts.unshift('MathJax_default');\" +\n                \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" +\n                \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" +\n                \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" +\n            \"});\" +\n            \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" +\n                \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" +\n                \"VARIANT['normal'].fonts.unshift('MathJax_default');\" +\n                \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" +\n                \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" +\n                \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" +\n            \"});\" +\n        \"}\";\n\n    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);\n    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);\n}\n</script>",
  "category": ""
}