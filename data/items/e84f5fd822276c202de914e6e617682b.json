{
  "title": "Matrix Computations in SymPy",
  "link": "",
  "updated": "2012-10-29T00:00:00+00:00",
  "id": "https://mrocklin.github.io/blog/work/2012/10/29/Matrix-Computations",
  "content": "<p>I want to translate matrix expressions like this</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\">    <span class=\"p\">(</span><span class=\"n\">alpha</span><span class=\"o\">*</span><span class=\"n\">A</span><span class=\"o\">*</span><span class=\"n\">B</span><span class=\"p\">).</span><span class=\"n\">I</span> <span class=\"o\">*</span> <span class=\"n\">x</span></code></pre>\n</figure>\n\n<p>Into Fortran code that call BLAS and LAPACK code like this</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-fortran\" data-lang=\"fortran\"><span class=\"w\">    </span><span class=\"k\">subroutine</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">alpha</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">)</span><span class=\"w\">\n\n    </span><span class=\"kt\">real</span><span class=\"o\">*</span><span class=\"mi\">8</span><span class=\"p\">,</span><span class=\"w\">  </span><span class=\"k\">intent</span><span class=\"p\">(</span><span class=\"k\">in</span><span class=\"p\">)</span><span class=\"w\">     </span><span class=\"p\">::</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">)</span><span class=\"w\">\n    </span><span class=\"kt\">real</span><span class=\"o\">*</span><span class=\"mi\">8</span><span class=\"p\">,</span><span class=\"w\">  </span><span class=\"k\">intent</span><span class=\"p\">(</span><span class=\"k\">inout</span><span class=\"p\">)</span><span class=\"w\">  </span><span class=\"p\">::</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">)</span><span class=\"w\">\n    </span><span class=\"kt\">real</span><span class=\"o\">*</span><span class=\"mi\">8</span><span class=\"p\">,</span><span class=\"w\">  </span><span class=\"k\">intent</span><span class=\"p\">(</span><span class=\"k\">in</span><span class=\"p\">)</span><span class=\"w\">     </span><span class=\"p\">::</span><span class=\"w\"> </span><span class=\"n\">alpha</span><span class=\"w\">\n    </span><span class=\"kt\">integer</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">intent</span><span class=\"p\">(</span><span class=\"k\">in</span><span class=\"p\">)</span><span class=\"w\">     </span><span class=\"p\">::</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\">\n    </span><span class=\"kt\">real</span><span class=\"o\">*</span><span class=\"mi\">8</span><span class=\"p\">,</span><span class=\"w\">  </span><span class=\"k\">intent</span><span class=\"p\">(</span><span class=\"k\">inout</span><span class=\"p\">)</span><span class=\"w\">  </span><span class=\"p\">::</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"w\">\n\n    </span><span class=\"k\">call</span><span class=\"w\"> </span><span class=\"n\">dgemm</span><span class=\"p\">(</span><span class=\"s1\">'N'</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s1\">'N'</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">alpha</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">)</span><span class=\"w\">\n    </span><span class=\"k\">call</span><span class=\"w\"> </span><span class=\"n\">dtrsv</span><span class=\"p\">(</span><span class=\"s1\">'L'</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s1\">'N'</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s1\">'N'</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"w\">\n\n    </span><span class=\"k\">RETURN</span><span class=\"w\">\n    </span><span class=\"k\">END</span></code></pre>\n</figure>\n\n<p>And then call it in Python like this</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\">    <span class=\"n\">nA</span><span class=\"p\">,</span> <span class=\"n\">nB</span><span class=\"p\">,</span> <span class=\"n\">nx</span> <span class=\"o\">=</span> <span class=\"p\">....</span> <span class=\"c1\"># Get numpy arrays\n</span>    <span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">nalpha</span><span class=\"p\">,</span> <span class=\"n\">nA</span><span class=\"p\">,</span> <span class=\"n\">nB</span><span class=\"p\">.</span><span class=\"n\">T</span><span class=\"p\">,</span> <span class=\"n\">nx</span><span class=\"p\">.</span><span class=\"n\">T</span><span class=\"p\">))</span></code></pre>\n</figure>\n\n<h2 id=\"what-is-blas\">What is BLAS?</h2>\n\n<p><a href=\"http://en.wikipedia.org/wiki/BLAS\">BLAS</a> stands for Basic Linear Algebra Subroutines. It is a library of Fortran functions for dense linear algebra first published in 1979.</p>\n\n<p>The most famous BLAS routine is <a href=\"http://www.netlib.org/blas/dgemm.f\">DGEMM</a> a routine for <strong>D</strong>ouble precision <strong>GE</strong>nerally structured <strong>M</strong>atrix <strong>M</strong>ultiplication. <code class=\"language-plaintext highlighter-rouge\">DGEMM</code> is very well implemented. <code class=\"language-plaintext highlighter-rouge\">DGEMM</code> traditionally handles blocking for fewer cache misses, autotuning for each individual architecture, and even assembly level code optimization. You should never code up your own matrix multiply, you should always use <code class=\"language-plaintext highlighter-rouge\">DGEMM</code>. Unfortunately, you may not know Fortran, and, even if you did, you might find the function header to be daunting.</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>SUBROUTINE DGEMM(TRANSA,TRANSB,M,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC)\n</code></pre></div></div>\n\n<p>Even if you’re capable of working at this low-level most scientific users are not. <code class=\"language-plaintext highlighter-rouge\">DGEMM</code> is fast but inaccessible. To solve this problem we usually build layers on top of <code class=\"language-plaintext highlighter-rouge\">BLAS</code>. For example <code class=\"language-plaintext highlighter-rouge\">numpy.dot</code> calls <code class=\"language-plaintext highlighter-rouge\">DGEMM</code> if the BLAS library is available on your system.</p>\n\n<h2 id=\"why-not-just-use-numpy\">Why not just use NumPy?</h2>\n\n<p>If you’re reading this then you’re probably comfortable with NumPy and you’re very happy that it gives you access to highly optimized low-level code like <code class=\"language-plaintext highlighter-rouge\">DGEMM</code>. What else could we desire? NumPy has two flaws</p>\n\n<ol>\n  <li>Each operation occurs at the Python level. This causes sub-optimal operation ordering and lots of unnecessary copies. For example the following code is executed as follows</li>\n</ol>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"n\">D</span> <span class=\"o\">=</span> <span class=\"n\">A</span><span class=\"o\">*</span><span class=\"n\">B</span><span class=\"o\">*</span><span class=\"n\">C</span> <span class=\"c1\"># store A*B  -&gt; _1\n</span>    <span class=\"n\">D</span> <span class=\"o\">=</span> <span class=\"n\">_1</span><span class=\"o\">*</span><span class=\"n\">C</span>  <span class=\"c1\"># store _1*C -&gt; _2\n</span>    <span class=\"n\">D</span> <span class=\"o\">=</span> <span class=\"n\">_2</span>    <span class=\"c1\"># store _2   -&gt;  D\n</span>    </code></pre>\n</figure>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>It might have been cleaner to multiply `A*B*C` as `(A*B)*C` or `A*(B*C)` depending on the shapes of the matrices. Additionally the temporary matrices `_1`, and `_2` did not need to be created. If we're allowed to *reason about the computation* before execution then we can make some substantial optimizaitons.\n</code></pre></div></div>\n\n<ol>\n  <li>BLAS contains many special functions for special cases. For example you can use <code class=\"language-plaintext highlighter-rouge\">DSYMM</code> when one of your matrices is <strong>SY</strong>metric or <code class=\"language-plaintext highlighter-rouge\">DTRMM</code> when one of your matrices is <strong>TR</strong>iangular. These allow for faster execution time if we are able to reason about our matrices.</li>\n</ol>\n\n<h2 id=\"previous-work\">Previous Work</h2>\n\n<p>In the cases above we argue that we can make substantial gains if we are allowed to reason about the computation before it is executed. This is the job of a compiler. Computation usually happens as follows:</p>\n\n<ol>\n  <li>Write down code</li>\n  <li>Reason about and transform code</li>\n  <li>Execute code</li>\n</ol>\n\n<p>Step (2) is often removed in scripting languages for programmer simplicity. There has been a lot of activity recently in putting it back in for array computations. The following projects compile array expressions prior to execution</p>\n\n<ol>\n  <li>NumExpr</li>\n  <li>Theano</li>\n  <li>Numba</li>\n  <li>… I’m undoubtedly forgetting many excellent projects. Here is <a href=\"https://github.com/Theano/Theano/wiki/Lazy-Matrix-Algebra-Ecosystem\">a more complete list</a></li>\n</ol>\n\n<h2 id=\"where-does-sympy-fit-in\">Where does SymPy fit in?</h2>\n\n<p>The projects above are all numerical in nature. They are generally good at solving problems of the first kind (operation ordering, inplace operations, …) but none of them think very clearly about the <em>mathematical</em> properties of the matrices. This is where SymPy can be useful. Using the assumptions logical programming framework SymPy is able to reason about the properties of matrix expressions. Consider the following situation</p>\n\n<p>We know that <code class=\"language-plaintext highlighter-rouge\">A</code> is symmetric and positive definite. We know that <code class=\"language-plaintext highlighter-rouge\">B</code> is orthogonal.</p>\n\n<p>Question: is <code class=\"language-plaintext highlighter-rouge\">BAB'</code> symmetric and positive definite?</p>\n\n<p>Lets see how we can pose this question in SymPy.</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\">    <span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">A</span> <span class=\"o\">=</span> <span class=\"n\">MatrixSymbol</span><span class=\"p\">(</span><span class=\"s\">'A'</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">)</span>\n    <span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">B</span> <span class=\"o\">=</span> <span class=\"n\">MatrixSymbol</span><span class=\"p\">(</span><span class=\"s\">'B'</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">)</span>\n    <span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">context</span> <span class=\"o\">=</span> <span class=\"n\">Q</span><span class=\"p\">.</span><span class=\"n\">symmetric</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">)</span> <span class=\"o\">&amp;</span> <span class=\"n\">Q</span><span class=\"p\">.</span><span class=\"n\">positive_definite</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">)</span> <span class=\"o\">&amp;</span> <span class=\"n\">Q</span><span class=\"p\">.</span><span class=\"n\">orthogonal</span><span class=\"p\">(</span><span class=\"n\">B</span><span class=\"p\">)</span>\n    <span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">ask</span><span class=\"p\">(</span><span class=\"n\">Q</span><span class=\"p\">.</span><span class=\"n\">symmetric</span><span class=\"p\">(</span><span class=\"n\">B</span><span class=\"o\">*</span><span class=\"n\">A</span><span class=\"o\">*</span><span class=\"n\">B</span><span class=\"p\">.</span><span class=\"n\">T</span><span class=\"p\">)</span> <span class=\"o\">&amp;</span> <span class=\"n\">Q</span><span class=\"p\">.</span><span class=\"n\">positive_definite</span><span class=\"p\">(</span><span class=\"n\">B</span><span class=\"o\">*</span><span class=\"n\">A</span><span class=\"o\">*</span><span class=\"n\">B</span><span class=\"p\">.</span><span class=\"n\">T</span><span class=\"p\">),</span> <span class=\"n\">context</span><span class=\"p\">)</span>\n    <span class=\"bp\">True</span></code></pre>\n</figure>\n\n<p>Positive-Definiteness is a very important property of matrix expressions. It strongly influences our choice of numerical algorithm. For example the fast <a href=\"http://en.wikipedia.org/wiki/Cholesky\">Cholesky algorithm</a> for LU decomposition may only be used if a matrix is symmetric and positive definite. Expert numerical analysts know this but most scientific programmers do not. NumPy does not know this but SymPy does.</p>\n\n<h2 id=\"describing-blas\">Describing BLAS</h2>\n\n<p>We describe a new matrix operation in SymPy with code like the following:</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\">    <span class=\"n\">S</span> <span class=\"o\">=</span> <span class=\"n\">MatrixSymbol</span><span class=\"p\">(</span><span class=\"s\">'S'</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">)</span>\n    <span class=\"k\">class</span> <span class=\"nc\">LU</span><span class=\"p\">(</span><span class=\"n\">BLAS</span><span class=\"p\">):</span>\n        <span class=\"s\">\"\"\" LU Decomposition \"\"\"</span>\n        <span class=\"n\">_inputs</span>   <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">S</span><span class=\"p\">,)</span>\n        <span class=\"n\">_outputs</span>  <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">Lof</span><span class=\"p\">(</span><span class=\"n\">S</span><span class=\"p\">),</span> <span class=\"n\">Uof</span><span class=\"p\">(</span><span class=\"n\">S</span><span class=\"p\">))</span>\n        <span class=\"n\">view_map</span>  <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"mi\">0</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">}</span> <span class=\"c1\"># Both outputs are stored in first input\n</span>        <span class=\"n\">condition</span> <span class=\"o\">=</span> <span class=\"bp\">True</span>         <span class=\"c1\"># Always valid\n</span>\n    <span class=\"k\">class</span> <span class=\"nc\">Cholesky</span><span class=\"p\">(</span><span class=\"n\">LU</span><span class=\"p\">):</span>\n        <span class=\"s\">\"\"\" Cholesky LU Decomposition \"\"\"</span>\n        <span class=\"n\">condition</span> <span class=\"o\">=</span> <span class=\"n\">Q</span><span class=\"p\">.</span><span class=\"n\">symmetric</span><span class=\"p\">(</span><span class=\"n\">S</span><span class=\"p\">)</span> <span class=\"o\">&amp;</span> <span class=\"n\">Q</span><span class=\"p\">.</span><span class=\"n\">positive_definite</span><span class=\"p\">(</span><span class=\"n\">S</span><span class=\"p\">)</span></code></pre>\n</figure>\n\n<p>This description allows us to consisely describe the expert knowledge used by numerical analysts. It allows us to describe the mathematical properties of linear algebraic operations.</p>\n\n<h2 id=\"matrix-computation-graphs\">Matrix Computation Graphs</h2>\n\n<p>We usually write code in a linear top-down text file. This representation does not allow the full generality of a program. Instead we need to use a graph.</p>\n\n<p>A computation can be described as a directed acyclic graph (DAG) where each node in the graph is an atomic computation (a function call like <code class=\"language-plaintext highlighter-rouge\">DGEMM</code> or <code class=\"language-plaintext highlighter-rouge\">Cholesky</code>) and each directed edge represents a data dependency between function calls (an edge from <code class=\"language-plaintext highlighter-rouge\">DGEMM</code> to <code class=\"language-plaintext highlighter-rouge\">Cholesky</code> implies that the <code class=\"language-plaintext highlighter-rouge\">Cholesky</code> requires an output of the <code class=\"language-plaintext highlighter-rouge\">DGEMM</code> call in order to run). This graph may not contain cycles - they would imply that some set of jobs all depend on each other; they could never start.</p>\n\n<p>Graphs must be eventually linearized and turned into code. Before that happens we can think about optimal ordering and, if we feel adventurous, parallel scheduling onto different machines.</p>\n\n<p>SymPy contains a very simple Computation graph object. Here we localize all of the logic about inplace operations, ordering, and (eventually) parallel scheduling.</p>\n\n<h2 id=\"translating-matrix-expressions-into-matrix-computations\">Translating Matrix Expressions into Matrix Computations</h2>\n\n<p>So how can we transform a matrix expression like</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\">    <span class=\"p\">(</span><span class=\"n\">alpha</span><span class=\"o\">*</span><span class=\"n\">A</span><span class=\"o\">*</span><span class=\"n\">B</span><span class=\"p\">).</span><span class=\"n\">I</span> <span class=\"o\">*</span> <span class=\"n\">x</span></code></pre>\n</figure>\n\n<p>And a set of predicates like</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\">    <span class=\"n\">Q</span><span class=\"p\">.</span><span class=\"n\">lower_triangular</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">)</span> <span class=\"o\">&amp;</span> <span class=\"n\">Q</span><span class=\"p\">.</span><span class=\"n\">lower_triangular</span><span class=\"p\">(</span><span class=\"n\">B</span><span class=\"p\">)</span> <span class=\"o\">&amp;</span> <span class=\"n\">Q</span><span class=\"p\">.</span><span class=\"n\">invertible</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"o\">*</span><span class=\"n\">B</span><span class=\"p\">)</span></code></pre>\n</figure>\n\n<p>Into a graph of <code class=\"language-plaintext highlighter-rouge\">BLAS</code> calls like one of the following?</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\">    <span class=\"n\">DGEMM</span><span class=\"p\">(</span><span class=\"n\">alpha</span><span class=\"p\">,</span> <span class=\"n\">A</span><span class=\"p\">,</span> <span class=\"n\">B</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">B</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">DTRSV</span><span class=\"p\">(</span><span class=\"n\">alpha</span><span class=\"o\">*</span><span class=\"n\">A</span><span class=\"o\">*</span><span class=\"n\">B</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">)</span>\n    <span class=\"n\">DTRMM</span><span class=\"p\">(</span><span class=\"n\">alpha</span><span class=\"p\">,</span> <span class=\"n\">A</span><span class=\"p\">,</span> <span class=\"n\">B</span><span class=\"p\">)</span>       <span class=\"o\">-&gt;</span> <span class=\"n\">DTRSV</span><span class=\"p\">(</span><span class=\"n\">alpha</span><span class=\"o\">*</span><span class=\"n\">A</span><span class=\"o\">*</span><span class=\"n\">B</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">)</span></code></pre>\n</figure>\n\n<p>And, once we have this set of valid computations how do we choose the right one? This is the question that this project faces right now. These are both challenging problems.</p>\n\n<h2 id=\"references\">References</h2>\n\n<ul>\n  <li><a href=\"http://www.netlib.org/blas/\">BLAS</a> and <a href=\"http://www.netlib.org/lapack/\">LAPACK</a></li>\n  <li>J. Bergstra, O. Breuleux, F. Bastien, P. Lamblin, R. Pascanu, G. Desjardins, J. Turian, D. Warde-Farley and Y. Bengio. <a href=\"http://www.iro.umontreal.ca/~lisa/pointeurs/theano_scipy2010.pdf\"><em>Theano: A CPU and GPU Math Expression Compiler</em></a>. Proceedings of the Python for Scientific Computing Conference (SciPy) 2010. June 30 - July 3, Austin, TX]</li>\n  <li><a href=\"http://www.continuum.io/\">Numba at Continuum</a></li>\n  <li><a href=\"http://code.google.com/p/numexpr/\">NumExpr</a></li>\n  <li><a href=\"https://github.com/Theano/Theano/wiki/Lazy-Matrix-Algebra-Ecosystem\">A list of matrix projects in Python</a></li>\n  <li><a href=\"http://matthewrocklin.com/pub/ordering/partial-orders.pdf\">M. Rocklin, <em>Partial Ordering in Theano</em></a></li>\n</ul>"
}