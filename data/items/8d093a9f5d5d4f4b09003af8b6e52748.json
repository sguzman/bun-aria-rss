{
  "title": "Generalized Dollar Cost Averaging",
  "link": "",
  "published": "2021-03-20T00:00:00-07:00",
  "updated": "2021-03-20T00:00:00-07:00",
  "author": {
    "name": "Jonathan Landy"
  },
  "id": "tag:efavdb.com,2021-03-20:/generalized_dollar_cost_averaging",
  "summary": "<p>In this note, I consider a generalization of Dollar Cost Averaging &#8212; a popular\ninvesting strategy that involves gradually building up one&#8217;s holding in a stock\nover a pre-specified period of time.  The generalization I consider can\nguarantee better prices paid per share &#8212; relative to the standard approach &#8212;\nbut its …</p>",
  "content": "<p>In this note, I consider a generalization of Dollar Cost Averaging &#8212; a popular\ninvesting strategy that involves gradually building up one&#8217;s holding in a stock\nover a pre-specified period of time.  The generalization I consider can\nguarantee better prices paid per share &#8212; relative to the standard approach &#8212;\nbut its use comes at the cost of requiring one to have a flexible budget. The\nidea essentially boils down to leaning in more heavily on low price&nbsp;periods.</p>\n<h3>Model system and&nbsp;results</h3>\n<p>In this post, we will assume a scenario where one wants to enter into a stock\nover a set of <span class=\"math\">\\(K\\)</span> equally spaced periods.  These periods could be separated by\nminutes, hours, or days, etc.  The price of the stock at period <span class=\"math\">\\(i\\)</span> will be\nwritten as <span class=\"math\">\\(p_i\\)</span> and the number of shares purchased then will&nbsp;be\n</p>\n<div class=\"math\">\\begin{eqnarray}\nN_i = A \\frac{1}{p_i^{\\gamma}}, \\tag{1} \\label{1}\n\\end{eqnarray}</div>\n<p> \nwhere <span class=\"math\">\\(A\\)</span> and <span class=\"math\">\\(\\gamma\\)</span> are constants that are set before beginning.  The total\nnumber of shares purchased, total money spent, and price per share realized are\nthen given&nbsp;by,\n</p>\n<div class=\"math\">\\begin{eqnarray}\\tag{2} \\label{2}\nN_{total} &amp;=&amp; \\sum_{i=1}^K N_i \\\\\n\\tag{3} \\label{3}\n\\text{total money spent} &amp;=&amp; \\sum_{i=1}^K p_i N_i \\\\\n\\tag{4} \\label{4}\n\\text{price per share} &amp;=&amp; \\frac{\\sum_{i=1}^K p_i N_i}{\\sum_{i=1}^K N_i},\n\\end{eqnarray}</div>\n<p>\nrespectively.</p>\n<p>The green curve in the figure below records the price paid per share under our\nstrategy as a function of <span class=\"math\">\\(\\gamma\\)</span> for the example price series shown in black\n(this has a hidden, separate x-axis).\n<p align=\"center\">\n<img src=\"images/price_per_share.png\" alt=\"price paid\" style=\"width:100%\">\n</p>\nThis figure illustrates a number of general points about our&nbsp;strategy:</p>\n<ul>\n<li>\n<p>If <span class=\"math\">\\(\\gamma = 0\\)</span>, we purchase a fixed number of shares each day, <span class=\"math\">\\(A\\)</span>.  The\n  resulting price paid per share (\\ref{4}) is then the arithmetic mean of the\nperiod&nbsp;prices.</p>\n</li>\n<li>\n<p>If <span class=\"math\">\\(\\gamma =1\\)</span>, we spend an equal amount of money each day.  This is the\n  standard dollar cost averaging method.  Plugging this choice into (\\ref{4}),\none finds that the price paid per share in this case is the harmonic mean of\nthe prices over the&nbsp;series.</p>\n</li>\n<li>\n<p>The arithmetic-harmonic means inequality implies that the <span class=\"math\">\\(\\gamma=1\\)</span>\n  necessarily beats the <span class=\"math\">\\(\\gamma=0\\)</span> approach when it comes to price per share\npaid.  This can be understood as follows:  The <span class=\"math\">\\(\\gamma=1\\)</span> method results in\nrelatively more shares being purchased on low price periods, which  causes\nthese periods to be more heavily weighted in the relevant&nbsp;average.</p>\n</li>\n<li>\n<p>More generally, we prove in an appendix below that increasing <span class=\"math\">\\(\\gamma\\)</span> always\n  causes the price per share to go down.  This holds for all possible price\nseries &#8212; including that shown in our figure above, where we see the green\ncurve is monotonically decreasing.  This result holds because increasing\n<span class=\"math\">\\(\\gamma\\)</span> causes one lean in even harder on low price&nbsp;periods. </p>\n</li>\n<li>\n<p>As <span class=\"math\">\\(\\gamma \\to \\infty\\)</span>, our purchase strategy is dominated by the lowest\nprice period, and this is the price we end up paying per share on&nbsp;average.</p>\n</li>\n<li>\n<p>As <span class=\"math\">\\(\\gamma \\to -\\infty\\)</span>, our strategy is dominated by the highest price\n  period, and this is the price we pay.  This limit is attractive when we want\nto exit / sell a&nbsp;holding.</p>\n</li>\n<li>\n<p>The downside of our strategy &#8212; relative to the standard dollar cost\n  averaging method &#8212; is that it requires a flexible budget.  However, for\n<span class=\"math\">\\(\\gamma\\)</span> not too large, we can often get a meaningful reduction in price per\nshare without dramatically increasing the variance in amount spent: e.g., a one\npercent drop in price per share might be possible if one is willing to have a\nten percent flexibility in one&#8217;s budget.  We give numerical examples in the\nnext&nbsp;section.</p>\n</li>\n<li>\n<p>If the stock is drifting over the <span class=\"math\">\\(K\\)</span> periods in question, all dollar cost\n  averaging methods may give a higher price than simply purchasing everything\non the first period.  For this reason &#8212; when a cheaper price per share is the\nobjective &#8212; I suggest using these strategies over short time frames only &#8212;\nsay, over a day or week.  That&#8217;s because stock price variance typically\ndominates drift over short&nbsp;periods.</p>\n</li>\n</ul>\n<p>We now turn to a quick numerical study, and then conclude with our appendix\ncovering the proof of&nbsp;monotonicity.</p>\n<h3>Numerical&nbsp;study</h3>\n<p>In this section, we provide some helper python code that allows one to simulate\nprice series and check the results of running our strategy (\\ref{1}) on top\nof them.  The following two code blocks (1) generate log normal random walk\nprice series, and (2) carry out our&nbsp;strategy.</p>\n<div class=\"highlight\"><pre><span></span><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">simulated_price_series</span><span class=\"p\">(</span><span class=\"n\">initial_price</span><span class=\"p\">,</span> <span class=\"n\">drift</span><span class=\"p\">,</span> <span class=\"n\">std</span><span class=\"p\">,</span> <span class=\"n\">steps</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Returns a simulated price series asserting the log of the</span>\n<span class=\"sd\">    price takes a random walk with drift and variance, as</span>\n<span class=\"sd\">    passed. </span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"n\">drifts</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"n\">steps</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"n\">drift</span>\n    <span class=\"n\">random_factors</span> <span class=\"o\">=</span> <span class=\"n\">std</span> <span class=\"o\">*</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">randn</span><span class=\"p\">(</span><span class=\"n\">steps</span><span class=\"p\">)</span>\n    <span class=\"n\">random_factors</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n\n    <span class=\"n\">returns</span> <span class=\"o\">=</span> <span class=\"n\">drifts</span> <span class=\"o\">+</span> <span class=\"n\">random_factors</span>\n    <span class=\"k\">return</span> <span class=\"n\">initial_price</span> <span class=\"o\">*</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">exp</span><span class=\"p\">(</span><span class=\"n\">returns</span><span class=\"p\">)</span> \n\n<span class=\"k\">def</span> <span class=\"nf\">simulated_series_and_purchases</span><span class=\"p\">(</span>\n        <span class=\"n\">gamma</span><span class=\"p\">,</span>\n        <span class=\"n\">initial_price</span><span class=\"p\">,</span>\n        <span class=\"n\">drift</span><span class=\"p\">,</span>\n        <span class=\"n\">std</span><span class=\"p\">,</span>\n        <span class=\"n\">steps</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Simulate price trajectory of length steps and then apply the</span>\n<span class=\"sd\">    generalized dollar cost averaging method -- this entails buying</span>\n<span class=\"sd\">    N_i shares at step i, with N_i ~ 1 / p_i ^ gamma.</span>\n\n<span class=\"sd\">    Return the total money spent, shares purchased, and average price</span>\n<span class=\"sd\">    per share.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"n\">price_series</span> <span class=\"o\">=</span> <span class=\"n\">simulated_price_series</span><span class=\"p\">(</span><span class=\"n\">initial_price</span><span class=\"p\">,</span> <span class=\"n\">drift</span><span class=\"p\">,</span> <span class=\"n\">std</span><span class=\"p\">,</span> <span class=\"n\">steps</span><span class=\"p\">)</span>\n    <span class=\"n\">shares_series</span> <span class=\"o\">=</span> <span class=\"mi\">100</span> <span class=\"o\">/</span> <span class=\"p\">((</span><span class=\"n\">price_series</span><span class=\"o\">/</span><span class=\"n\">price_series</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span> <span class=\"o\">**</span> <span class=\"n\">gamma</span><span class=\"p\">)</span>\n    <span class=\"n\">money_spent_series</span> <span class=\"o\">=</span> <span class=\"n\">price_series</span> <span class=\"o\">*</span> <span class=\"n\">shares_series</span>\n\n    <span class=\"c1\"># summary stats</span>\n    <span class=\"n\">shares</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sum</span><span class=\"p\">(</span><span class=\"n\">shares_series</span><span class=\"p\">)</span>\n    <span class=\"n\">money_spent</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sum</span><span class=\"p\">(</span><span class=\"n\">money_spent_series</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">shares</span><span class=\"p\">,</span> <span class=\"n\">money_spent</span><span class=\"p\">,</span> <span class=\"n\">money_spent</span> <span class=\"o\">/</span> <span class=\"n\">shares</span>\n</pre></div>\n\n\n<p>With these in place, I ran 40k simulation with the following parameters for\nthe price&nbsp;series:</p>\n<div class=\"highlight\"><pre><span></span><span class=\"n\">initial_price</span> <span class=\"o\">=</span> <span class=\"mf\">10.0</span>\n<span class=\"n\">steps</span> <span class=\"o\">=</span> <span class=\"mi\">10</span>\n<span class=\"n\">drift</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>\n<span class=\"n\">std</span> <span class=\"o\">=</span> <span class=\"mf\">0.05</span>\n</pre></div>\n\n\n<p>In the simulations, I considered <span class=\"math\">\\(\\gamma=5\\)</span>, <span class=\"math\">\\(10\\)</span>, and <span class=\"math\">\\(1\\)</span> &#8212; the last being\nthe standard dollar cost averaging method.  Histograms of the resulting spends\nare shown below for each case.  The titles give the mean and standard deviation\nof the amount spent over the traces, and the legends give the mean prices per\nshare, averaging over traces.  We can see that we can get a fairly significant\nimprovement in mean price as we lift <span class=\"math\">\\(\\gamma\\)</span>, but doing this requires that\nwe occassionally spend a lot more&nbsp;money.</p>\n<p>One can mitigate the very large spend events by capping the amount spent per\nday.  For example, if one caps the daily spend at fifty percent above that on\nthe first day, the <span class=\"math\">\\(\\gamma=10\\)</span> case here gives a spend distribution of <span class=\"math\">\\(10194\n\\pm 2069\\)</span>, and a mean price per share of <span class=\"math\">\\(9.86\\)</span>.</p>\n<p align=\"center\">\n<img src=\"images/spend_distributions.png\" alt=\"price paid\" style=\"width:100%\">\n</p>\n\n<h3>Appendix: Average price per share&nbsp;monotonicity</h3>\n<p>In this appendix, we give a proof that increasing <span class=\"math\">\\(\\gamma\\)</span> in (\\ref{1}), always\nresults in a decreasing average price per share (more precisely, it can&#8217;t\nresult in an&nbsp;increase).</p>\n<p>To begin, we recall our definitions:  The number of shares purchased at <span class=\"math\">\\(p_i\\)</span>\nis assumed to&nbsp;be\n</p>\n<div class=\"math\">\\begin{eqnarray} \\tag{A1}\nN_i = A p_i^{-\\gamma}.\n\\end{eqnarray}</div>\n<p>\nThe total number of shares purchased is then obtained by summing&nbsp;this\n</p>\n<div class=\"math\">\\begin{eqnarray} \\tag{A2}\nN_{total} = \\sum_{i=1}^k N_i\n\\end{eqnarray}</div>\n<p>\nThe average price per share is&nbsp;then\n</p>\n<div class=\"math\">\\begin{eqnarray} \\tag{A3} \\label{A3}\n\\overline{p} = \\sum_{i=1}^k w_i p_i\n\\end{eqnarray}</div>\n<p>\nwhere\n</p>\n<div class=\"math\">\\begin{eqnarray}\nw_j &amp;\\equiv &amp; \\frac{N_j}{N_{total}} \\\\\n&amp;=&amp; \\frac{p_j^{-\\gamma}}{\\sum_{i=1}^k p_i^{-\\gamma}} \\tag{A4}\n\\end{eqnarray}</div>\n<p>\nis the normalized weight applied to price <span class=\"math\">\\(p_j\\)</span>.  Plugging this last line into\n(\\ref{A3}), we get a simple expression for the average price per&nbsp;share\n</p>\n<div class=\"math\">\\begin{eqnarray}\\label{A5}\\tag{A5}\n\\overline{p} = \\frac{\\langle p_i^{-\\gamma + 1} \\rangle}{\\langle p_i^{-\\gamma}\n\\rangle} \n\\end{eqnarray}</div>\n<p>\nHere, we use brackets for equal weight averages over the price series.  This\nformula shows that the mean paid price per share is related to the ratio of two\nadjacent moments of the price series.  We will now argue that this is monotic\nin <span class=\"math\">\\(\\gamma\\)</span> [Aside:  It looks like one might be able to provide an alternative\nproof of our result from the ratio of moments expression above, combining that\nwith one of the Chebychev inequalities.  However, I haven&#8217;t been able to get\nthat to work just&nbsp;yet].</p>\n<p>To show that (\\ref{A3}) is monotonic in <span class=\"math\">\\(\\gamma\\)</span>, we first note that the\nrelative weight applied to any two prices is given&nbsp;by\n</p>\n<div class=\"math\">\\begin{eqnarray}\\label{A6}\\tag{A6}\n\\frac{w_i}{w_j} = \\left(\\frac{p_i}{p_j}\\right)^{-\\gamma}\n\\end{eqnarray}</div>\n<p>\nIf <span class=\"math\">\\(p_i\\)</span> is the minimum price in the series this is necessarily an increasing\nfunction of <span class=\"math\">\\(\\gamma\\)</span> for any other <span class=\"math\">\\(p_j\\)</span>.  In order for the weights to continue\nto be normalized to one, this implies that the weight applied to the smallest\nprice must always increase as we increase <span class=\"math\">\\(\\gamma\\)</span>.</p>\n<p>Next, we note that with the above observation, our result is trivially true\nwhen <span class=\"math\">\\(k=1\\)</span> and <span class=\"math\">\\(k=2\\)</span>.  Suppose then that the result holds up to <span class=\"math\">\\(k-1\\)</span> periods\nand the consider the case at <span class=\"math\">\\(k\\)</span>.  If we order the <span class=\"math\">\\(p_i\\)</span> values from largest to\nsmallest, we then&nbsp;have\n</p>\n<div class=\"math\">\\begin{eqnarray}\\label{A7} \\tag{A7}\n\\overline{p} = \\left ( 1 - w_k \\right) \\sum_{i=1}^{k-1} \\tilde{w}_i p_i+ w_k\np_k\n\\end{eqnarray}</div>\n<p>\nThe sum above is the weighted average we&#8217;d realize if we only invested on the\nfirst <span class=\"math\">\\(k-1\\)</span> ordered prices, and the <span class=\"math\">\\(\\tilde{w}_i\\)</span> are the effective weights\nwe&#8217;d apply in that case. By assumption, this inner sum is necessarily\nnon-increasing with <span class=\"math\">\\(\\gamma\\)</span>.   Therefore, if we let <span class=\"math\">\\(w^{\\prime}\\)</span> be the weight\napplied at some <span class=\"math\">\\(\\gamma^{\\prime} &gt; \\gamma\\)</span>, we&nbsp;have\n</p>\n<div class=\"math\">\\begin{eqnarray}\n\\overline{p}^{\\prime} &amp;=&amp; \\left ( 1 - w_k^{\\prime} \\right) \\sum_{i=1}^{k-1}\n\\tilde{w}_i^{\\prime} p_i + w_k^{\\prime} p_k \\\\\n&amp;\\leq &amp;  \\left ( 1 - w_k^{\\prime} \\right) \\sum_{i=1}^{k-1} \\tilde{w}_i p_i +\nw_k^{\\prime} p_k \\label{A8} \\tag{A8}\n\\end{eqnarray}</div>\n<p>\nBut this last line is just like the <span class=\"math\">\\(k=2\\)</span> case: We move from one weighted\naverage of two values (namely, <span class=\"math\">\\(p_k\\)</span> and the weighted sum of the first <span class=\"math\">\\(k-1\\)</span>\nprices with weights fixed as at <span class=\"math\">\\(\\gamma\\)</span> &#8212; which is necessarily not smaller\nthan <span class=\"math\">\\(p_k\\)</span>) to another that applies more weight to the smaller of the two\nvalues &#8212; ultimately giving a smaller result.  Continuing with the last line,\nthen, we&nbsp;have\n</p>\n<div class=\"math\">\\begin{eqnarray}\n\\overline{p}^{\\prime} &amp;\\leq&amp; \\left ( 1 - w_k^{\\prime} \\right) \\sum_{i=1}^{k-1}\n\\tilde{w}_i p_i + w_k^{\\prime} p_k \\\\\n&amp;\\leq&amp; \\left ( 1 - w_k \\right) \\sum_{i=1}^{k-1} \\tilde{w}_i p_i + w_k p_k \\\\\n&amp;\\equiv&amp; \\overline{p}. \\label{A9} \\tag{A9}\n\\end{eqnarray}</div>\n<p> \nThis completes our&nbsp;proof.</p>\n<script type=\"text/javascript\">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {\n    var align = \"center\",\n        indent = \"0em\",\n        linebreak = \"false\";\n\n    if (false) {\n        align = (screen.width < 768) ? \"left\" : align;\n        indent = (screen.width < 768) ? \"0em\" : indent;\n        linebreak = (screen.width < 768) ? 'true' : linebreak;\n    }\n\n    var mathjaxscript = document.createElement('script');\n    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';\n    mathjaxscript.type = 'text/javascript';\n    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';\n\n    var configscript = document.createElement('script');\n    configscript.type = 'text/x-mathjax-config';\n    configscript[(window.opera ? \"innerHTML\" : \"text\")] =\n        \"MathJax.Hub.Config({\" +\n        \"    config: ['MMLorHTML.js'],\" +\n        \"    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } },\" +\n        \"    jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" +\n        \"    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" +\n        \"    displayAlign: '\"+ align +\"',\" +\n        \"    displayIndent: '\"+ indent +\"',\" +\n        \"    showMathMenu: true,\" +\n        \"    messageStyle: 'normal',\" +\n        \"    tex2jax: { \" +\n        \"        inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" +\n        \"        displayMath: [ ['$$','$$'] ],\" +\n        \"        processEscapes: true,\" +\n        \"        preview: 'TeX',\" +\n        \"    }, \" +\n        \"    'HTML-CSS': { \" +\n        \"        availableFonts: ['STIX', 'TeX'],\" +\n        \"        preferredFont: 'STIX',\" +\n        \"        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" +\n        \"        linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" +\n        \"    }, \" +\n        \"}); \" +\n        \"if ('default' !== 'default') {\" +\n            \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" +\n                \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" +\n                \"VARIANT['normal'].fonts.unshift('MathJax_default');\" +\n                \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" +\n                \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" +\n                \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" +\n            \"});\" +\n            \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" +\n                \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" +\n                \"VARIANT['normal'].fonts.unshift('MathJax_default');\" +\n                \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" +\n                \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" +\n                \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" +\n            \"});\" +\n        \"}\";\n\n    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);\n    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);\n}\n</script>",
  "category": [
    "",
    "",
    ""
  ]
}