{
  "title": "Write tests",
  "link": "",
  "updated": "2016-02-08T00:00:00+00:00",
  "id": "https://mrocklin.github.io/blog/work/2016/02/08/tests",
  "content": "<p>Tests are important for community driven open source software.\nThis post contains brief reasons why you should test your code, particularly if\nyou submit changes to existing open source projects.</p>\n\n<h2 id=\"why-we-dont-test\">Why we don’t test.</h2>\n\n<p>A test is an extra piece of code to verify the correctness of the code we\nactually care about.</p>\n\n<p>If we know that our function works then the test code is extraneous.  Because\nmany developers today verify code correctness through interactive sessions,\nadding tests after-the-fact seems like a chore that can be skipped if time\npressure is on.  Testing feels like flossing your teeth; only theoretically\nimportant.</p>\n\n<p>This is a valid point of view. There are several ways to verify code\ncorrectness and interactive sessions may be sufficient in some cases,\nespecially if your job is to write one-off scripts or notebooks for quick\nanalysis.</p>\n\n<p>However, if you want to contribute to long term software that involves many\npeople collaborating over long periods of time then your tests become more\nimportant.  Your tests will likely outlive your source-code several times over.</p>\n\n<h2 id=\"why-we-test\">Why we test</h2>\n\n<p>Usually we motivate testing by emphasizing the importance of verifying\npresent-day correctness, similar to <a href=\"https://en.wikipedia.org/wiki/Double-entry_bookkeeping_system\">double entry\nbookkeeping</a>.\nVerifying correctness <em>is</em> valuable, but there are several other reasons that\nare just as valuable.</p>\n\n<h3 id=\"establish-interfaces\">Establish interfaces</h3>\n\n<p>Write basic interface tests before you write code.  This formally establishes\nand enforces the goals of your work and forces you to think at a high-level\nbefore you dive into low-level details.</p>\n\n<p>It’s hard to abstain from diving into the guts of a new problem right away.\nThis requires mental discipline.</p>\n\n<h3 id=\"communicate-with-colleagues\">Communicate with colleagues</h3>\n\n<p>You can share these high-level tests with colleagues to make sure everyone is\non the same page before writing a solution.  It’s far easier to understand a\nfunction from its tests than from its source code.  Providing clean tests is a\ngreat courtesy to your reviewers and co-workers.  This sharing process can\nhappen before you invest time in writing source code.</p>\n\n<h3 id=\"reduce-maintenance-burden\">Reduce maintenance burden</h3>\n\n<p>If you spend ten hours developing a contribution to a project, the project\nmaintainers will likely spend forty hours maintaining that contribution in the\nfuture, especially if it is a new feature that expands the project scope rather\nthan a bug fix.  Tests dramatically help to reduce maintenance burden.  We\nemphasize this in the following two points.</p>\n\n<h3 id=\"guard-against-future-developers\">Guard against future developers</h3>\n\n<p>Future developers will change your code.  They will not perfectly understand\nyour original intention and so will introduce bugs.  Your tests guard against\nthese well-meaning but imperfectly informed future developers.</p>\n\n<h3 id=\"guard-against-complex-interactions\">Guard against complex interactions</h3>\n\n<p>In a complex project your function likely depends on hundreds of other\nfunctions and interfaces throughout the project.  These change all the time.\nTests raise a red flag whenever a proposed change would alter your\ncontribution.</p>\n\n<h3 id=\"enable-refactoring\">Enable refactoring</h3>\n\n<p>Software projects occasionally undergo significant internal changes.  This\noften requires a small number of developers to drastically change all parts of\nthe code at once.  This is really only feasible if all relevant parts of the\ncode have decent code coverage.</p>\n\n<p>Here is a <a href=\"https://twitter.com/minrk/status/505111560394530816\">twitter quote</a>\nfrom a primary Jupyter developer:</p>\n\n<p><em>I never appreciate tests or dread their absence more than during a refactor.</em></p>\n\n<p><em>–@minrk</em></p>\n\n<h3 id=\"ensure-current-correctness\">Ensure current correctness</h3>\n\n<p>Tests ensure that the code you’ve just written is correct today for the use\ncases you’ve thought about.  When you write nice tests you always find flaws in\nyour existing solution that you wouldn’t have found otherwise.</p>\n\n<p>This is the common argument usually presented in defense of testing.</p>\n\n<h3 id=\"think-adversarially\">Think adversarially</h3>\n\n<p>Writing tests is a good time to think adversarially about your problem.  What\nhappens if I give a very large input here?  How about a negative number?  Oh,\nwhat happens if the user enters a value of the wrong type; do they get a\nsensible error message?  We rarely think about these issues when solving our\ninitial problem but they are important, especially if our code reaches\nend-users.</p>\n\n<h3 id=\"force-good-design\">Force good design</h3>\n\n<p>Easy-to-test code separates application logic from hard-to-test components like\ndatabases or network connections.  The burden of testing encourages us to\nseparate complex code from complex infrastructure so that we can test each\ncomponent in isolation.  This separation promotes future code health as well as\nimproved testing.</p>\n\n<h3 id=\"testing-is-easy\">Testing is easy</h3>\n\n<p>A single test that exercises the common case just once probably catches 70% of\nthe failures.  This probably isn’t sufficient for most open-source projects but\nit’s comforting to know that your first few steps into testing are always the\nmost productive.</p>\n\n<h3 id=\"testing-is-hard\">Testing is hard</h3>\n\n<p>Good test suites take time and thought but they’re very important.  Defining\nthe correct behavior for a complex system is just as worthwhile as designing\nits implementation.</p>\n\n<h3 id=\"interactive-feedback\">Interactive feedback</h3>\n\n<p>Verifying correctness by interactive sessions can take a long time for complex\nfunctions.  We restart our interpreter and reenter the same setup code\nrepeatedly.  A quick test automates this process, often providing feedback in\nless than a second.  Subsecond tests, combined with tools like\n<a href=\"https://pypi.python.org/pypi/conttest\">conttest</a> provide continuous feedback\nas we write and save code.  Continuous feedback during coding is incredibly\nproductive.</p>\n\n<h3 id=\"social-pressure\">Social pressure</h3>\n\n<p>Finally, there is social pressure.  Few mature open source software projects\nwill accept untested contributions and it is generally considered a faux pas to\nsubmit a contribution without tests.  If you have to write tests then you might\nas well write them first so that they can help you during development.</p>\n\n<p>Professional tip: if you interview for a job and have to do a programming\nexercise, start with a few simple tests.  This helps you and the interviewer\nagree on the statement of the problem, gives you rapid interactive feedback in\na stressful situation, and gives you an air of professionalism.</p>\n\n<h3 id=\"acknowledgments\">Acknowledgments</h3>\n\n<p>This post is thanks in part to discussions with\n<a href=\"https://github.com/martindurant\">Martin Durant</a>.</p>"
}