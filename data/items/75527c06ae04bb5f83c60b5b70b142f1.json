{
  "guid": "tag:blogger.com,1999:blog-6300367579216018061.post-8483148551697005371",
  "pubDate": "Mon, 07 Jul 2014 21:13:00 +0000",
  "atom:updated": "2014-11-27T20:00:53.489-08:00",
  "category": [
    "algorithms",
    "graph database",
    "neo4j",
    "pattern recognition",
    "ubigraph",
    "visualization"
  ],
  "title": "Using 3D Visualization to Debug a Graph-based Algorithm",
  "description": "Recently I have been working on an idea for an algorithm that discovers patterns in raw streams of data. This pattern recognition algorithm uses <a href=\"http://en.wikipedia.org/wiki/Deep_learning\" target=\"_blank\">deep learning</a>&nbsp;to classify certain combinatorial features that uniquely identify an input stream.<br /><br />I'm going to first talk a bit about the algorithm so it makes sense as to why visualization is such an important step in iterating and tweaking code that most efficiently implements the algorithm.<br /><br /><h3>The Algorithm</h3><div><br /></div><div>In a <a href=\"http://www.kennybastani.com/2014/06/hierchical-pattern-recognition.html\" target=\"_blank\">previous post</a> I introduce the idea for the algorithm and how a graph-based approach might work.</div><div><br /></div><div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"http://1.bp.blogspot.com/-e_PVtiJrBRg/U5_Vn3r_aUI/AAAAAAAAA5g/qYkZouyPG6c/s1600/neo4j-pattern-recognition-engine.png\" imageanchor=\"1\" style=\"margin-left: 1em; margin-right: 1em;\"><img border=\"0\" src=\"http://1.bp.blogspot.com/-e_PVtiJrBRg/U5_Vn3r_aUI/AAAAAAAAA5g/qYkZouyPG6c/s1600/neo4j-pattern-recognition-engine.png\" height=\"312\" width=\"640\" /></a></div><a name='more'></a><div><br /></div><div><br /></div><div>The image above illustrates the idea as a graph. A tree is built by training on data and recognizing prevalent features in that data.</div><div><br /></div><div>This works in two phases, training and recognition. In this blog post I'll go over training.</div><div><br /></div><h3>Training</h3><div><br /></div><div>In the training phase the algorithm should produce a hierarchy of nodes that grows using genetic inheritance.</div><div><br /></div><div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"http://3.bp.blogspot.com/-f38-EUPUxNQ/U7rn9N366hI/AAAAAAAAA6A/vY4Qe51MrTs/s1600/graph-recognition-algorithm-1.png\" imageanchor=\"1\" style=\"margin-left: 1em; margin-right: 1em;\"><img border=\"0\" src=\"http://3.bp.blogspot.com/-f38-EUPUxNQ/U7rn9N366hI/AAAAAAAAA6A/vY4Qe51MrTs/s1600/graph-recognition-algorithm-1.png\" height=\"254\" width=\"640\" /></a></div><div><br /></div><div>In the image above I've illustrated the root of the graph with two descendants. The regular expressions act as a predicate and also as the template for each child node. The RegEx of the parent is inherited by descendants as a base genetic code but with a mutation that expands the RegEx either left or right of the base code. This abstraction enables for a probabilistic expansion of the pattern matching algorithm.</div><div><br /></div><div>But how does training generate child nodes?</div><div><br /></div><div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"http://3.bp.blogspot.com/-b2ZAUz2vo_4/U7rpBFL3JnI/AAAAAAAAA6I/vk2LIdTmKQU/s1600/graph-recognition-algorithm-2.png\" imageanchor=\"1\" style=\"margin-left: 1em; margin-right: 1em;\"><img border=\"0\" src=\"http://3.bp.blogspot.com/-b2ZAUz2vo_4/U7rpBFL3JnI/AAAAAAAAA6I/vk2LIdTmKQU/s1600/graph-recognition-algorithm-2.png\" height=\"327\" width=\"640\" /></a></div><div>The genetic inheritance is done by setting a threshold and counting on the number of matches. Using <a href=\"http://www.neo4j.com/\" target=\"_blank\">Neo4j</a> I am able to attach matches to source data at each match.</div><div><br /></div><div>For example, if each input is a binary string of an arbitrary length, each node represents some mutating binary operation with a method signature matchInput(Node input, Node current).<br /><br />As the input node represented as the \"input\" parameter is positively matched on the RegEx of the \"current\" parameter, the property named \"matches\" on the \"current\" node is incremented by 1. When the match count on the \"current\" node equals the \"threshold\" parameter, two leaf nodes are created using a statistical measure on previous matches.<br /><br />The image below illustrates the genetic algorithm that sums on the statistical distribution of matches against bits and producing a new RegEx inherited from the parent.<br /><br /><table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"><tbody><tr><td style=\"text-align: center;\"><a href=\"http://3.bp.blogspot.com/-wTJNG683gK8/U7sGgVOEjzI/AAAAAAAAA6Y/r_hLR9IItHM/s1600/graph-recognition-algorithm-3.png\" imageanchor=\"1\" style=\"margin-left: auto; margin-right: auto;\"><img border=\"0\" src=\"http://3.bp.blogspot.com/-wTJNG683gK8/U7sGgVOEjzI/AAAAAAAAA6Y/r_hLR9IItHM/s1600/graph-recognition-algorithm-3.png\" height=\"566\" width=\"640\" /></a></td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\">Click to enlarge</td></tr></tbody></table><br />In the diagram we see that the current node is ∆101∆ which has the RegEx match string of <i>([01])101([01])</i>. The result of the matches should produce two leaf nodes, one that expands left and one that expands right.<br /><br />Because I have stored the pointers in Neo4j for the previous 3 matches, an aggregation can be made on references to that input data, as illustrated in the graph diagram. The aggregation produces a left node that expands on the RegEx <i><b>([01])</b>101([01])</i> in the first group. The result of the sum of the bit's counts for the left group results in 5 for 0-bit and 1 for 1-bit. Since 5 &gt; 1, the new RegEx will replace the first group of the parent node with a 0-bit, producing the new template ([01])<b><i>0</i></b>101([01]) or more easily read as ∆0101∆ where ∆ means 0 or 1.<br /><br /><h3>3D Graph Visualization</h3></div><div><br /></div><div>I started out by visualizing the results of the graph-based algorithm through the <a href=\"http://vimeo.com/97204829\" target=\"_blank\">Neo4j browser</a>. Translating the algorithm into code was easy enough, except the results were not as expected. I wanted something that could give me some visual feedback so I could iterate on the code to make it faster.<br /><br /><table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"><tbody><tr><td style=\"text-align: center;\"><a href=\"http://4.bp.blogspot.com/-8iI_AwVvmWk/U7sQXS4IXGI/AAAAAAAAA6o/k815PehYukM/s1600/graph-recognition-algorithm-browser.png\" imageanchor=\"1\" style=\"margin-left: auto; margin-right: auto;\"><img border=\"0\" src=\"http://4.bp.blogspot.com/-8iI_AwVvmWk/U7sQXS4IXGI/AAAAAAAAA6o/k815PehYukM/s1600/graph-recognition-algorithm-browser.png\" height=\"546\" width=\"640\" /></a></td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\">2D Graph Visualization in Neo4j Browser</td></tr></tbody></table>Since the branching factor for this graph is 2, the total depth can get rather large. While Neo4j's browser-based visualization is great for small to medium-sized graphs, I wanted to see things in three dimensions.<br /><br />Using a blog post by my colleague Michael Hunger, located <a href=\"http://jexp.de/blog/2014/06/rendering-a-neo4j-database-in-ubigraph/\" target=\"_blank\">here</a>, I had a way to see how my algorithm was growing over time and apply tweaks and heuristics to make it perform better in training phase.</div><div><br /><blockquote class=\"twitter-tweet\" lang=\"en\">3D graph visualization of a pattern recognition algorithm training into a massive binary decision tree. <a href=\"https://twitter.com/hashtag/Neo4j?src=hash\">#Neo4j</a> <a href=\"http://t.co/Llh0olPH1p\">http://t.co/Llh0olPH1p</a><br />— Kenny Bastani (@kennybastani) <a href=\"https://twitter.com/kennybastani/statuses/484450100920320000\">July 2, 2014</a></blockquote><script async=\"\" charset=\"utf-8\" src=\"//platform.twitter.com/widgets.js\"></script></div><div><br /></div><div><div>I recorded my most recent iteration of the algorithm, which I wrote in Java, and created a GIF out of it. If you play the GIF in the tweet you can see how my algorithm expands over time.<br /><br />I also uploaded a video that was a screen recording of the training phase of the algorithm at a slower speed.<br /><br /><iframe allowfullscreen=\"\" frameborder=\"0\" height=\"315\" src=\"//www.youtube.com/embed/bIBYSAepmUk\" width=\"420\"></iframe></div><div><br />Creating these kinds of visualizations were both fun and helpful to understand how the algorithm was evolving over time. I could understand better the computational performance and feasibilities of my various approaches and choose the best approach based on feedback from the visualizations.<br /><br />In an upcoming blog post I will take this algorithm further to create a Neo4j plugin that performs image recognition and classification. The killer use case for this being an open-source deep learning plugin for&nbsp;<a href=\"http://docs.neo4j.org/chunked/milestone/server-plugins.html\" target=\"_blank\">Neo4j</a>&nbsp;that can be used for face and object recognition in image data.<br /><br />References:<br /><br />Ubigraph:&nbsp;<a href=\"http://ubietylab.net/ubigraph/\">http://ubietylab.net/ubigraph/</a><br />Neo4j: <a href=\"http://www.neo4j.com/\">http://www.neo4j.com/</a><br /><br /></div></div></br><a href=\"https://news.ycombinator.com/submit\" class=\"hn-button\" data-title=\"Using 3D Visualization to Debug a Graph-based Algorithm\" data-url=\"http://www.kennybastani.com/2014/07/using-3d-visualization-to-debug-graph.html\" data-count=\"horizontal\">Vote on Hacker News</a><script type=\"text/javascript\">var HN=[];HN.factory=function(e){return function(){HN.push([e].concat(Array.prototype.slice.call(arguments,0)))};},HN.on=HN.factory(\"on\"),HN.once=HN.factory(\"once\"),HN.off=HN.factory(\"off\"),HN.emit=HN.factory(\"emit\"),HN.load=function(){var e=\"hn-button.js\";if(document.getElementById(e))return;var t=document.createElement(\"script\");t.id=e,t.src=\"//hn-button.herokuapp.com/hn-button.js\";var n=document.getElementsByTagName(\"script\")[0];n.parentNode.insertBefore(t,n)},HN.load();</script>",
  "link": "https://www.kennybastani.com/2014/07/using-3d-visualization-to-debug-graph.html",
  "author": "noreply@blogger.com (Kenny Bastani)",
  "media:thumbnail": "",
  "thr:total": 0
}