{
  "id": "tag:blogger.com,1999:blog-8474926331452026626.post-5097682856425549750",
  "published": "2022-09-27T10:32:00.002-07:00",
  "updated": "2022-10-22T19:53:27.922-07:00",
  "category": [
    "",
    ""
  ],
  "title": "Quantization for Fast and Environmentally Sustainable Reinforcement Learning",
  "content": "<span class=\"byline-author\">Posted by Srivatsan Krishnan, Student Researcher, and Aleksandra Faust, Senior Staff Research Scientist, Google Research, Brain Team </span>  <p>Deep <a href=\"https://en.wikipedia.org/wiki/Q-learning\">reinforcement learning</a> (RL) continues to make great strides in solving real-world sequential decision-making problems such as <a href=\"https://ai.googleblog.com/2022/02/the-balloon-learning-environment.html\">balloon navigation</a>, <a href=\"https://www.deepmind.com/blog/accelerating-fusion-science-through-learned-plasma-control\">nuclear physics</a>, <a href=\"https://ai.googleblog.com/2018/06/scalable-deep-reinforcement-learning.html\">robotics</a>, and <a href=\"https://ai.googleblog.com/2019/06/introducing-google-research-football.html\">games</a>. Despite its promise, one of its limiting factors is long training times. While the current approach to <a href=\"https://ai.googleblog.com/2020/03/massively-scaling-reinforcement.html\">speed up RL training</a> on complex and difficult tasks leverages <a href=\"https://github.com/deepmind/acme\">distributed training</a> scaling up to hundreds or even thousands of computing nodes, it still requires the use of significant hardware resources which makes RL training expensive, while increasing its environmental impact. However, recent work [<a href=\"https://blog.google/technology/ai/minimizing-carbon-footprint/\">1</a>, <a href=\"https://proceedings.mlsys.org/paper/2022/file/ed3d2c21991e3bef5e069713af9fa6ca-Paper.pdf\">2</a>] indicates that performance optimizations on existing hardware can reduce the <a href=\"https://en.wikipedia.org/wiki/Carbon_footprint\">carbon footprint</a> (i.e., total <a href=\"https://en.wikipedia.org/wiki/Greenhouse_gas_emissions\">greenhouse gas</a> emissions) of training and inference.  </p><a name='more'></a>  <p>RL can also benefit from similar system optimization techniques that can reduce training time, improve hardware utilization and reduce carbon dioxide (CO<sub>2</sub>) emissions. One such technique is quantization, a process that converts full-precision floating point (<a href=\"https://en.wikipedia.org/wiki/Single-precision_floating-point_format\">FP32</a>) numbers to lower precision (<a href=\"https://www.gnu.org/software/libc/manual/html_node/Integers.html\">int8</a>) numbers and then performs computation using the lower precision numbers. Quantization can save memory storage cost and bandwidth for faster and more energy-efficient computation. Quantization has been successfully applied to supervised learning to <a href=\"https://blog.tensorflow.org/2021/06/how-tensorflow-helps-edge-impulse-make-ml-accessible.html\">enable edge deployments</a> of machine learning (ML) models and achieve <a href=\"https://developer.nvidia.com/blog/mixed-precision-training-deep-neural-networks/\">faster training</a>. However, there remains an opportunity to apply quantization to RL training.  </p>  <p>To that end, we present “<a href=\"https://openreview.net/pdf?id=xwWsiFmUEs\">QuaRL: Quantization for Fast and Environmentally Sustainable</a><a href=\"https://openreview.net/pdf?id=xwWsiFmUEs\">Reinforcement Learning</a>”, published in the <i><a href=\"https://jmlr.org/tmlr/\">Transactions of Machine Learning Research</a></i> journal, which introduces<i> </i>a new paradigm called <i>ActorQ </i>that applies quantization to speed up RL training by 1.5-5.4x while maintaining performance. Additionally, we demonstrate that compared to training in full-precision, the carbon footprint is also significantly reduced by a factor of 1.9-3.8x. </p>  <div style=\"line-height:40%;\">    <br></div><h2>Applying Quantization to RL Training</h2><p>In traditional RL training, a <i>learner </i>policy is applied to an <i>actor</i>, which uses the policy to explore the environment and collect data samples. The samples collected by the <i>actor</i> are then used by the <i>learner</i> to continuously refine the initial policy. Periodically, the policy trained on the learner side is used to update the <i>actor's</i> policy. To apply quantization to RL training, we develop the ActorQ paradigm. ActorQ performs the same sequence described above, with one key difference being that the policy update from learner to actors is quantized, and the actor explores the environment using the int8 quantized policy to collect samples. </p> <p>Applying quantization to RL training in this fashion has two key benefits. First, it reduces the <a href=\"https://en.wikipedia.org/wiki/Memory_footprint\">memory footprint</a> of the policy. For the same peak bandwidth, less data is transferred between learners and actors, which reduces the communication cost for policy updates from learners to actors. Second, the actors perform inference on the quantized policy to generate actions for a given environment state. The quantized inference process is much faster when compared to performing inference in full precision.  </p>  <table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto;\"><tbody><tr><td style=\"text-align: center;\"><a href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgF_4o81i0gPf7bU-_E8Fqhy_Ih-AdGI6s_CNhcfVv6wirCsGJlMdwX7DQamF3VYTUbNNJn1E2omMJ3tziscCnTxrxMslApGiPfrg67-3H7WpKCcxXJg5ihqaSrKlOLClmgTIxy8yDKMIFZIQzZL1tNamHlGGvtXZW6zWDAHHlN8kRCZAjYGcuFuDaOYw/s1600/image4.gif\" style=\"margin-left: auto; margin-right: auto;\"><img border=\"0\" data-original-height=\"322\" data-original-width=\"1600\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgF_4o81i0gPf7bU-_E8Fqhy_Ih-AdGI6s_CNhcfVv6wirCsGJlMdwX7DQamF3VYTUbNNJn1E2omMJ3tziscCnTxrxMslApGiPfrg67-3H7WpKCcxXJg5ihqaSrKlOLClmgTIxy8yDKMIFZIQzZL1tNamHlGGvtXZW6zWDAHHlN8kRCZAjYGcuFuDaOYw/s16000/image4.gif\" /></a></td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\">An overview of traditional RL training (<b>left</b>) and ActorQ RL training (<b>right</b>).</td></tr></tbody></table> <p>In ActorQ, we use the <a href=\"https://github.com/deepmind/acme\">ACME</a> distributed RL framework. The quantizer block performs uniform quantization that converts the FP32 policy to int8. The actor performs inference using optimized int8 computations. Though we use uniform quantization when designing the quantizer block, we believe that other <a href=\"https://arxiv.org/abs/1806.08342\">quantization techniques</a> can replace uniform quantization and produce similar results. The samples collected by the actors are used by the learner to train a neural network policy. Periodically the learned policy is quantized by the quantizer block and broadcasted to the actors. </p> <div style=\"line-height:40%;\">    <br></div><h2>Quantization Improves RL Training Time and Performance</h2><p>We evaluate ActorQ in a range of environments, including the <a href=\"https://www.deepmind.com/open-source/deepmind-control-suite\">Deepmind Control Suite</a> and the <a href=\"https://openai.com/blog/openai-gym-beta/\">OpenAI Gym</a>. We demonstrate the speed-up and improved performance of <a href=\"https://arxiv.org/abs/1804.08617\">D4PG</a> and <a href=\"https://www.cs.toronto.edu/~vmnih/docs/dqn.pdf\">DQN</a>. We chose D4PG as it was the best learning algorithm in <a href=\"https://arxiv.org/abs/2006.00979\">ACME</a> for Deepmind Control Suite tasks, and DQN is a widely used and standard RL algorithm.  </p> <p>We observe a significant speedup (between 1.5x and 5.41x) in training RL policies. More importantly, performance is maintained even when actors perform int8 quantized inference. The figures below demonstrate this for the D4PG and DQN agents for Deepmind Control Suite and OpenAI Gym tasks. </p>  <table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto;\"><tbody><tr><td style=\"text-align: center;\"><a href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi_9JtTGkLC_0r_leaxnELxfZ8ZxbKDwaMi-wunwlbllT4SihT7gyDrGnk2rXC3eO5N9UshGSAUqyYge5DfU_at-hxyN8h1nnaNhMu4BArs_KxXarLdHmskQ5QqZHxjWVvxoTKJXzFQJIORP78gdXcAXgI_zod1Ef9RK683LQcWTNVn6DGj3rI-2ty-0g/s957/image2.png\" style=\"margin-left: auto; margin-right: auto;\"><img border=\"0\" data-original-height=\"957\" data-original-width=\"566\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi_9JtTGkLC_0r_leaxnELxfZ8ZxbKDwaMi-wunwlbllT4SihT7gyDrGnk2rXC3eO5N9UshGSAUqyYge5DfU_at-hxyN8h1nnaNhMu4BArs_KxXarLdHmskQ5QqZHxjWVvxoTKJXzFQJIORP78gdXcAXgI_zod1Ef9RK683LQcWTNVn6DGj3rI-2ty-0g/s16000/image2.png\" /></a></td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\">A comparison of RL training using the FP32 policy (q=32) and the quantized int8 policy (q=8) for D4PG agents on various Deepmind Control Suite tasks. Quantization achieves speed-ups of 1.5x to 3.06x.</td></tr></tbody></table>  <table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto;\"><tbody><tr><td style=\"text-align: center;\"><a href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhyF643UhZYXbEb90Ue5asz0D5SL_OKcn_qY-fYvTsmUh7k5Yf5Jfua_LSMmEEHu_nTRU1TITAlH7Dwxmgmz9HnSmBlItTd6o24aFXv9V-i2m9940IdCpPl2uAcBcAme4GuBJ5O1AD88LK4np_KRwWCmraqPnxxT7ryhu3qsPnMgK8QkomODbUTnGA7CA/s1244/image5.png\" style=\"margin-left: auto; margin-right: auto;\"><img border=\"0\" data-original-height=\"904\" data-original-width=\"1244\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhyF643UhZYXbEb90Ue5asz0D5SL_OKcn_qY-fYvTsmUh7k5Yf5Jfua_LSMmEEHu_nTRU1TITAlH7Dwxmgmz9HnSmBlItTd6o24aFXv9V-i2m9940IdCpPl2uAcBcAme4GuBJ5O1AD88LK4np_KRwWCmraqPnxxT7ryhu3qsPnMgK8QkomODbUTnGA7CA/s16000/image5.png\" /></a></td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\">A comparison of RL training using the FP32 policy (q=32) and the quantized int8 policy (q=8) for DQN agents in the OpenAI Gym environment. Quantization achieves a speed-up of 2.2x to 5.41x.</td></tr></tbody></table> <h2>Quantization Reduces Carbon Emission</h2><p>Applying quantization in RL using ActorQ improves training time without affecting performance. The direct consequence of using the hardware more efficiently is a smaller carbon footprint. We measure the carbon footprint improvement by taking the ratio of carbon emission when using the FP32 policy during training over the carbon emission when using the int8 policy during training. </p> <p>In order to measure the carbon emission for the RL training experiment, we use the <a href=\"https://github.com/Breakend/experiment-impact-tracker\">experiment-impact-tracker</a> proposed in <a href=\"https://jmlr.org/papers/volume21/20-312/20-312.pdf\">prior work</a>. We instrument the ActorQ system with carbon monitor APIs to measure the energy and carbon emissions for each training experiment. </p> <p>Compared to the carbon emission when running in full precision (FP32), we observe that the quantization of policies reduces the carbon emissions anywhere from 1.9x to 3.76x, depending on the task. As RL systems are scaled to run on thousands of distributed hardware cores and accelerators, we believe that the absolute carbon reduction (measured in kilograms of CO<sub>2</sub>) can be quite significant. </p>  <table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto;\"><tbody><tr><td style=\"text-align: center;\"><a href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiGC7inzPO6k_D-ZacfPL32YNfnSXt4AheMAFeRuGJisa8uTKac1kwOhepphdeXqx7KnrMFqV1ldHkxvmg2hzEBIGbhgdceEaNnxwWUwCXtHZ61TfjwQi0Ujdwqi-GcRNxZCYLFUXE2_oNr0ZdHG1mMyHv1xB0l5Nj0y31ebzv5QhNvYadQlGg1eZnetw/s1999/image8.png\" imageanchor=\"1\" style=\"margin-left: auto; margin-right: auto;\"><img border=\"0\" data-original-height=\"939\" data-original-width=\"1999\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiGC7inzPO6k_D-ZacfPL32YNfnSXt4AheMAFeRuGJisa8uTKac1kwOhepphdeXqx7KnrMFqV1ldHkxvmg2hzEBIGbhgdceEaNnxwWUwCXtHZ61TfjwQi0Ujdwqi-GcRNxZCYLFUXE2_oNr0ZdHG1mMyHv1xB0l5Nj0y31ebzv5QhNvYadQlGg1eZnetw/s16000/image8.png\" /></a></td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\">Carbon emission comparison between training using a FP32 policy and an int8 policy. The X-axis scale is normalized to the carbon emissions of the FP32 policy. Shown by the red bars greater than 1, ActorQ reduces carbon emissions.</td></tr></tbody></table> <h2>Conclusion and Future Directions</h2><p>We introduce ActorQ, a novel paradigm that applies quantization to RL training and achieves speed-up improvements of 1.5-5.4x while maintaining performance. Additionally, we demonstrate that ActorQ can reduce RL training’s carbon footprint by a factor of 1.9-3.8x compared to training in full-precision without quantization. </p> <p>ActorQ demonstrates that quantization can be effectively applied to many aspects of RL, from obtaining high-quality and efficient quantized policies to reducing training times and carbon emissions. As RL continues to make great strides in solving real-world problems, we believe that making RL training sustainable will be critical for adoption. As we scale RL training to thousands of cores and GPUs, even a 50% improvement (as we have experimentally demonstrated) will generate significant savings in absolute dollar cost, energy, and carbon emissions. Our work is the first step toward applying quantization to RL training to achieve efficient and environmentally sustainable training.  </p> <p>While our design of the quantizer in ActorQ relied on simple uniform quantization, we believe that other forms of quantization, compression and sparsity can be applied (e.g., distillation, sparsification, etc.). We hope that future work will consider applying more aggressive quantization and compression methods, which may yield additional benefits to the performance and accuracy tradeoff obtained by the trained RL policies. </p> <div style=\"line-height:40%;\">    <br></div><h2>Acknowledgments</h2><p><i>We would like to thank our co-authors Max Lam, Sharad Chitlangia, Zishen Wan, and Vijay Janapa Reddi (Harvard University), and Gabriel Barth-Maron (DeepMind), for their contribution to this work. We also thank the Google Cloud team for providing research credits to seed this work.</i></p>",
  "link": [
    "",
    "",
    "",
    "",
    ""
  ],
  "author": {
    "name": "Google AI",
    "uri": "http://www.blogger.com/profile/12098626514775266161",
    "email": "noreply@blogger.com",
    "gd:image": ""
  },
  "media:thumbnail": "",
  "thr:total": 0
}