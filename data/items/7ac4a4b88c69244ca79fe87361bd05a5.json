{
  "title": "The pandas escaped the zoo: Python's pandas vs. R's zoo benchmarks",
  "link": "",
  "published": "2011-09-30T00:00:00-07:00",
  "updated": "2011-09-30T00:00:00-07:00",
  "author": {
    "name": "Wes McKinney"
  },
  "id": "tag:wesmckinney.com,2011-09-30:/blog/the-pandas-escaped-the-zoo-pythons-pandas-vs-rs-zoo-benchmarks/",
  "summary": "<blockquote>\n<p>WM in 2015: Woefully out of date, but I preserve this post for posterity.</p>\n</blockquote>\n<blockquote class=\"twitter-tweet\" lang=\"en\"><p lang=\"en\" dir=\"ltr\">generic pandas data alignment is about 10-15x faster than the <a href=\"https://twitter.com/hashtag/rstats?src=hash\">#rstats</a> zoo package in initial tests. interesting <a href=\"https://twitter.com/hashtag/python?src=hash\">#python</a></p>&mdash; Wes McKinney (@wesmckinn) <a href=\"https://twitter.com/wesmckinn/status/119272815168978945\">September 29, 2011</a></blockquote>\n<script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\n<p>I tweeted that yesterday and figured it would be prudent to justify â€¦</p>",
  "content": "<blockquote>\n<p>WM in 2015: Woefully out of date, but I preserve this post for posterity.</p>\n</blockquote>\n<blockquote class=\"twitter-tweet\" lang=\"en\"><p lang=\"en\" dir=\"ltr\">generic pandas data alignment is about 10-15x faster than the <a href=\"https://twitter.com/hashtag/rstats?src=hash\">#rstats</a> zoo package in initial tests. interesting <a href=\"https://twitter.com/hashtag/python?src=hash\">#python</a></p>&mdash; Wes McKinney (@wesmckinn) <a href=\"https://twitter.com/wesmckinn/status/119272815168978945\">September 29, 2011</a></blockquote>\n<script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\n<p>I tweeted that yesterday and figured it would be prudent to justify that with some code and real benchmarks. I'm really proud of pandas's performance after investing years of development building a tool that is both <strong>easy-to-use</strong> and <strong>fast</strong>. So here we go.</p>\n<h3>The test case</h3>\n<p>The basic set-up is: you have two labeled vectors of different lengths and you add them together. The algorithm matches the labels and adds together the corresponding values. Simple, right?</p>\n<h3>R/zoo benchmarks</h3>\n<p>Here's the R code:</p>\n<div class=\"github\"><pre><span></span><code><span class=\"nf\">library</span><span class=\"p\">(</span><span class=\"n\">zoo</span><span class=\"p\">)</span>\n\n<span class=\"n\">indices</span> <span class=\"o\">=</span> <span class=\"nf\">rep</span><span class=\"p\">(</span><span class=\"kc\">NA</span><span class=\"p\">,</span> <span class=\"m\">100000</span><span class=\"p\">)</span>\n<span class=\"nf\">for </span><span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"n\">in</span> <span class=\"m\">1</span><span class=\"o\">:</span><span class=\"m\">100000</span><span class=\"p\">)</span>\n  <span class=\"n\">indices</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">&lt;-</span> <span class=\"nf\">paste</span><span class=\"p\">(</span><span class=\"nf\">sample</span><span class=\"p\">(</span><span class=\"kc\">letters</span><span class=\"p\">,</span> <span class=\"m\">10</span><span class=\"p\">),</span> <span class=\"n\">collapse</span><span class=\"o\">=</span><span class=\"s\">&quot;&quot;</span><span class=\"p\">)</span>\n\n<span class=\"n\">timings</span> <span class=\"o\">&lt;-</span> <span class=\"nf\">numeric</span><span class=\"p\">()</span>\n\n<span class=\"n\">x</span> <span class=\"o\">&lt;-</span> <span class=\"nf\">zoo</span><span class=\"p\">(</span><span class=\"nf\">rnorm</span><span class=\"p\">(</span><span class=\"m\">100000</span><span class=\"p\">),</span> <span class=\"n\">indices</span><span class=\"p\">)</span>\n<span class=\"n\">y</span> <span class=\"o\">&lt;-</span> <span class=\"nf\">zoo</span><span class=\"p\">(</span><span class=\"nf\">rnorm</span><span class=\"p\">(</span><span class=\"m\">90000</span><span class=\"p\">),</span> <span class=\"n\">indices</span><span class=\"p\">[</span><span class=\"nf\">sample</span><span class=\"p\">(</span><span class=\"m\">1</span><span class=\"o\">:</span><span class=\"m\">100000</span><span class=\"p\">,</span> <span class=\"m\">90000</span><span class=\"p\">)])</span>\n\n<span class=\"nf\">for </span><span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"n\">in</span> <span class=\"m\">1</span><span class=\"o\">:</span><span class=\"m\">10</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"nf\">gc</span><span class=\"p\">()</span>\n  <span class=\"n\">timings</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nf\">system.time</span><span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">y</span><span class=\"p\">)[</span><span class=\"m\">3</span><span class=\"p\">]</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n\n<p>In this benchmark, I get a timing of:</p>\n<div class=\"github\"><pre><span></span><code><span class=\"o\">&gt;</span> <span class=\"nf\">mean</span><span class=\"p\">(</span><span class=\"n\">timings</span><span class=\"p\">)</span>\n<span class=\"p\">[</span><span class=\"m\">1</span><span class=\"p\">]</span> <span class=\"m\">1.1518</span>\n</code></pre></div>\n\n<p>So, 1.15 seconds per iteration. There are a couple things to note here:</p>\n<ul>\n<li>The zoo package <strong>pre-sorts</strong> the objects by the index/label. As you will see below this makes a <strong>big</strong> performance difference as you can write a faster algorithm for ordered data.</li>\n<li>zoo returns an object whose index is the <strong>intersection</strong> of the indexes. I disagree with this design choice as I feel that it is discarding information. pandas returns the union (the \"outer join\", if you will) by default.</li>\n</ul>\n<h3>Python benchmark</h3>\n<p>Here's the code doing basically the same thing, except using objects that are <strong>not</strong> pre-sorted by label:</p>\n<div class=\"github\"><pre><span></span><code><span class=\"kn\">from</span> <span class=\"nn\">pandas</span> <span class=\"kn\">import</span> <span class=\"o\">*</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pandas.util.testing</span> <span class=\"kn\">import</span> <span class=\"n\">rands</span>\n\n<span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"mi\">100000</span>\n<span class=\"n\">indices</span> <span class=\"o\">=</span> <span class=\"n\">Index</span><span class=\"p\">([</span><span class=\"n\">rands</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">_</span> <span class=\"ow\">in</span> <span class=\"n\">xrange</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)])</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">sample</span><span class=\"p\">(</span><span class=\"n\">values</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">):</span>\n    <span class=\"kn\">from</span> <span class=\"nn\">random</span> <span class=\"kn\">import</span> <span class=\"n\">shuffle</span>\n    <span class=\"n\">sampler</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">values</span><span class=\"p\">))</span>\n    <span class=\"n\">shuffle</span><span class=\"p\">(</span><span class=\"n\">sampler</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">values</span><span class=\"o\">.</span><span class=\"n\">take</span><span class=\"p\">(</span><span class=\"n\">sampler</span><span class=\"p\">[:</span><span class=\"n\">k</span><span class=\"p\">])</span>\n\n<span class=\"n\">subsample_size</span> <span class=\"o\">=</span> <span class=\"mi\">90000</span>\n\n<span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">Series</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">randn</span><span class=\"p\">(</span><span class=\"mi\">100000</span><span class=\"p\">),</span> <span class=\"n\">indices</span><span class=\"p\">)</span>\n<span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">Series</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">randn</span><span class=\"p\">(</span><span class=\"n\">subsample_size</span><span class=\"p\">),</span>\n           <span class=\"n\">index</span><span class=\"o\">=</span><span class=\"n\">sample</span><span class=\"p\">(</span><span class=\"n\">indices</span><span class=\"p\">,</span> <span class=\"n\">subsample_size</span><span class=\"p\">))</span>\n</code></pre></div>\n\n<p>And the timing:</p>\n<div class=\"github\"><pre><span></span><code><span class=\"nv\">In</span> [<span class=\"mi\">11</span>]: <span class=\"nv\">timeit</span> <span class=\"nv\">x</span> <span class=\"o\">+</span> <span class=\"nv\">y</span>\n<span class=\"mi\">10</span> <span class=\"nv\">loops</span>, <span class=\"nv\">best</span> <span class=\"nv\">of</span> <span class=\"mi\">3</span>: <span class=\"mi\">110</span> <span class=\"nv\">ms</span> <span class=\"nv\">per</span> <span class=\"k\">loop</span>\n</code></pre></div>\n\n<p>Now, if I first sort the objects by index, a more specialized algorithm will be used:</p>\n<div class=\"github\"><pre><span></span><code><span class=\"nv\">In</span> [<span class=\"mi\">12</span>]: <span class=\"nv\">xs</span> <span class=\"o\">=</span> <span class=\"nv\">x</span>.<span class=\"nv\">sort_index</span><span class=\"ss\">()</span>\n\n<span class=\"nv\">In</span> [<span class=\"mi\">13</span>]: <span class=\"nv\">ys</span> <span class=\"o\">=</span> <span class=\"nv\">y</span>.<span class=\"nv\">sort_index</span><span class=\"ss\">()</span>\n\n<span class=\"nv\">In</span> [<span class=\"mi\">14</span>]: <span class=\"nv\">timeit</span> <span class=\"nv\">xs</span> <span class=\"o\">+</span> <span class=\"nv\">ys</span>\n<span class=\"mi\">10</span> <span class=\"nv\">loops</span>, <span class=\"nv\">best</span> <span class=\"nv\">of</span> <span class=\"mi\">3</span>: <span class=\"mi\">44</span>.<span class=\"mi\">1</span> <span class=\"nv\">ms</span> <span class=\"nv\">per</span> <span class=\"k\">loop</span>\n</code></pre></div>\n\n<p>Note that I'm also the fastest (that I know of) among Python libraries. Here's the above example using the <a href=\"http://pypi.python.org/pypi/la\" title=\"labeled array\">labeled array</a> package:</p>\n<div class=\"github\"><pre><span></span><code><span class=\"n\">In</span> <span class=\"p\">[</span><span class=\"mi\">12</span><span class=\"p\">]:</span> <span class=\"kn\">import</span> <span class=\"nn\">la</span>\n\n<span class=\"n\">In</span> <span class=\"p\">[</span><span class=\"mi\">13</span><span class=\"p\">]:</span> <span class=\"n\">lx</span> <span class=\"o\">=</span> <span class=\"n\">la</span><span class=\"o\">.</span><span class=\"n\">larry</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">values</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">index</span><span class=\"p\">)])</span>\n\n<span class=\"n\">In</span> <span class=\"p\">[</span><span class=\"mi\">14</span><span class=\"p\">]:</span> <span class=\"n\">ly</span> <span class=\"o\">=</span> <span class=\"n\">la</span><span class=\"o\">.</span><span class=\"n\">larry</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"o\">.</span><span class=\"n\">values</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"o\">.</span><span class=\"n\">index</span><span class=\"p\">)])</span>\n\n<span class=\"n\">In</span> <span class=\"p\">[</span><span class=\"mi\">15</span><span class=\"p\">]:</span> <span class=\"n\">timeit</span> <span class=\"n\">la</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">lx</span><span class=\"p\">,</span> <span class=\"n\">ly</span><span class=\"p\">,</span> <span class=\"n\">join</span><span class=\"o\">=</span><span class=\"s2\">&quot;outer&quot;</span><span class=\"p\">)</span>\n<span class=\"mi\">1</span> <span class=\"n\">loops</span><span class=\"p\">,</span> <span class=\"n\">best</span> <span class=\"n\">of</span> <span class=\"mi\">3</span><span class=\"p\">:</span> <span class=\"mi\">214</span> <span class=\"n\">ms</span> <span class=\"n\">per</span> <span class=\"n\">loop</span>\n\n<span class=\"n\">In</span> <span class=\"p\">[</span><span class=\"mi\">16</span><span class=\"p\">]:</span> <span class=\"n\">timeit</span> <span class=\"n\">la</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">lx</span><span class=\"p\">,</span> <span class=\"n\">ly</span><span class=\"p\">,</span> <span class=\"n\">join</span><span class=\"o\">=</span><span class=\"s2\">&quot;inner&quot;</span><span class=\"p\">)</span>\n<span class=\"mi\">10</span> <span class=\"n\">loops</span><span class=\"p\">,</span> <span class=\"n\">best</span> <span class=\"n\">of</span> <span class=\"mi\">3</span><span class=\"p\">:</span> <span class=\"mi\">176</span> <span class=\"n\">ms</span> <span class=\"n\">per</span> <span class=\"n\">loop</span>\n</code></pre></div>\n\n<h3>The verdict</h3>\n<p>So in a apples-to-apples comparison, in this benchmark pandas is <strong>26x</strong> faster than zoo. Even in the completely unordered case (which is not apples-to-apples), it's 10x faster. I actually have a few tricks up my sleeve (as soon as I can find the time to implement them) to make the above operations even faster still =)</p>"
}