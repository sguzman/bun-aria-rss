{
  "title": "Wordcounting and Verbosity",
  "link": "",
  "updated": "2013-11-15T00:00:00+00:00",
  "id": "https://mrocklin.github.io/blog/work/2013/11/15/Functional-Wordcount",
  "content": "<p>In a\n<a href=\"http://matthewrocklin.com/blog/work/2013/10/17/Introducing-PyToolz/\">blogpost</a>\nlast month I announced <a href=\"http://toolz.readthedocs.org/\">PyToolz</a> a Python\nimplementation of the functional standard library.  Today I want to discuss the\nwordcounting example in more depth, highlighting differences between\nsimple/verbose and complex/concise code.</p>\n\n<p><strong>tl;dr:</strong> Library code reduces code-length at the cost of universal\ncomprehension.  Libraries simplify code for a subset of programmers while\nalienating others.  This is behind the common complaint that functional\nprogramming is hard to read.  We use word-counting as a case study.</p>\n\n<h3 id=\"verbose-solution-with-simple-terms\">Verbose solution with simple terms</h3>\n\n<p>My standard wordcounting function looks like the following:</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"k\">def</span> <span class=\"nf\">stem</span><span class=\"p\">(</span><span class=\"n\">word</span><span class=\"p\">):</span>\n    <span class=\"s\">\"\"\" Stem word to primitive form\n\n    &gt;&gt;&gt; stem(\"Hello!\")\n    'hello'\n    \"\"\"</span>\n    <span class=\"k\">return</span> <span class=\"n\">word</span><span class=\"p\">.</span><span class=\"n\">lower</span><span class=\"p\">().</span><span class=\"n\">rstrip</span><span class=\"p\">(</span><span class=\"s\">\",.!)-*_?:;$'-</span><span class=\"se\">\\\"</span><span class=\"s\">\"</span><span class=\"p\">).</span><span class=\"n\">lstrip</span><span class=\"p\">(</span><span class=\"s\">\"-*'</span><span class=\"se\">\\\"</span><span class=\"s\">(_$'\"</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">wordcount</span><span class=\"p\">(</span><span class=\"n\">string</span><span class=\"p\">):</span>\n    <span class=\"s\">\"\"\" Count the number of occurences of each word in a string\n\n    &gt;&gt;&gt; sentence = \"This cat jumped over this other cat!\"\n    &gt;&gt;&gt; wordcount(sentence)\n    {'cat': 2, 'jumped': 1, 'other': 1, 'over': 1, 'this': 2}\n    \"\"\"</span>\n    <span class=\"n\">words</span> <span class=\"o\">=</span> <span class=\"n\">string</span><span class=\"p\">.</span><span class=\"n\">split</span><span class=\"p\">()</span>\n\n    <span class=\"n\">stemmed_words</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n    <span class=\"k\">for</span> <span class=\"n\">word</span> <span class=\"ow\">in</span> <span class=\"n\">words</span><span class=\"p\">:</span>\n        <span class=\"n\">stemmed_words</span><span class=\"p\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">stem</span><span class=\"p\">(</span><span class=\"n\">word</span><span class=\"p\">))</span>\n\n    <span class=\"n\">counts</span> <span class=\"o\">=</span> <span class=\"nb\">dict</span><span class=\"p\">()</span>\n    <span class=\"k\">for</span> <span class=\"n\">word</span> <span class=\"ow\">in</span> <span class=\"n\">stemmed_words</span><span class=\"p\">:</span>\n        <span class=\"k\">if</span> <span class=\"n\">word</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"n\">counts</span><span class=\"p\">:</span>\n            <span class=\"n\">counts</span><span class=\"p\">[</span><span class=\"n\">word</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"n\">counts</span><span class=\"p\">[</span><span class=\"n\">word</span><span class=\"p\">]</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">counts</span></code></pre>\n</figure>\n\n<p>While long/verbose, this solution is straightforward and comprehensible to all\nmoderately experienced Python programmers.</p>\n\n<h3 id=\"concise-solution-with-complex-terms\">Concise solution with complex terms</h3>\n\n<p>Using the definition for <code class=\"language-plaintext highlighter-rouge\">stem</code> above and the <code class=\"language-plaintext highlighter-rouge\">frequencies</code> function from\n<code class=\"language-plaintext highlighter-rouge\">toolz</code> we can condense <code class=\"language-plaintext highlighter-rouge\">wordcount</code> into the following single line.</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">toolz</span> <span class=\"kn\">import</span> <span class=\"n\">frequencies</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">frequencies</span><span class=\"p\">(</span><span class=\"nb\">map</span><span class=\"p\">(</span><span class=\"n\">stem</span><span class=\"p\">,</span> <span class=\"n\">sentence</span><span class=\"p\">.</span><span class=\"n\">split</span><span class=\"p\">()))</span>\n<span class=\"p\">{</span><span class=\"s\">'cat'</span><span class=\"p\">:</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"s\">'jumped'</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"s\">'other'</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"s\">'over'</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"s\">'this'</span><span class=\"p\">:</span> <span class=\"mi\">2</span><span class=\"p\">}</span></code></pre>\n</figure>\n\n<p>While dense, this solution solves the problem concisely using\npre-existing functionality.</p>\n\n<h3 id=\"increasing-readability-with-pipe\">Increasing readability with <code class=\"language-plaintext highlighter-rouge\">pipe</code></h3>\n\n<p>The functional solution above with <code class=\"language-plaintext highlighter-rouge\">frequencies(map(stem, sentence.split()))</code> is\nconcise but difficult for many human readers to parse.  The reader needs to\ntraverse a tree of parentheses to find the innermost element (<code class=\"language-plaintext highlighter-rouge\">sentence</code>) and\nthen work outwards to discover the flow of computation.  We improve the readability of\nthis solution with the <code class=\"language-plaintext highlighter-rouge\">pipe</code> function from <code class=\"language-plaintext highlighter-rouge\">toolz</code>.</p>\n\n<p>To introduce <code class=\"language-plaintext highlighter-rouge\">pipe</code> we consider the abstract process of doing laundry:</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">wet_clothes</span> <span class=\"o\">=</span> <span class=\"n\">wash</span><span class=\"p\">(</span><span class=\"n\">clothes</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">dry_clothes</span> <span class=\"o\">=</span> <span class=\"n\">dry</span><span class=\"p\">(</span><span class=\"n\">wet_clothes</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">fold</span><span class=\"p\">(</span><span class=\"n\">dry_clothes</span><span class=\"p\">)</span></code></pre>\n</figure>\n\n<p>This pushes the data, <code class=\"language-plaintext highlighter-rouge\">clothes</code> through a pipeline of functions, <code class=\"language-plaintext highlighter-rouge\">wash</code>, <code class=\"language-plaintext highlighter-rouge\">dry</code>,\nand <code class=\"language-plaintext highlighter-rouge\">fold</code>.  This pushing of data through a pipeline of functions is a common\npattern.  We encode this pattern into <code class=\"language-plaintext highlighter-rouge\">toolz.pipe</code>.</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">toolz</span> <span class=\"kn\">import</span> <span class=\"n\">pipe</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">pipe</span><span class=\"p\">(</span><span class=\"n\">clothes</span><span class=\"p\">,</span> <span class=\"n\">wash</span><span class=\"p\">,</span> <span class=\"n\">dry</span><span class=\"p\">,</span> <span class=\"n\">fold</span><span class=\"p\">)</span></code></pre>\n</figure>\n\n<p>Pipe pushes data (first argument) through a sequence of functions (rest of the\narguments) from left to right.  Here is another example.</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"kn\">from</span> <span class=\"nn\">toolz</span> <span class=\"kn\">import</span> <span class=\"n\">pipe</span>\n\n<span class=\"c1\"># Simple example\n</span><span class=\"k\">def</span> <span class=\"nf\">double</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">x</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">pipe</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"n\">double</span><span class=\"p\">,</span> <span class=\"n\">double</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">)</span>\n<span class=\"s\">'12'</span></code></pre>\n</figure>\n\n<p>Using <code class=\"language-plaintext highlighter-rouge\">pipe</code> we can rearrange our functional wordcounting solution to the\nfollowing form</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">toolz.curried</span> <span class=\"kn\">import</span> <span class=\"nb\">map</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># frequencies(map(stem, sentence.split()))\n</span><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">pipe</span><span class=\"p\">(</span><span class=\"n\">sentence</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">.</span><span class=\"n\">split</span><span class=\"p\">,</span> <span class=\"nb\">map</span><span class=\"p\">(</span><span class=\"n\">stem</span><span class=\"p\">),</span> <span class=\"n\">frequencies</span><span class=\"p\">)</span>\n<span class=\"p\">{</span><span class=\"s\">'cat'</span><span class=\"p\">:</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"s\">'jumped'</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"s\">'other'</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"s\">'over'</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"s\">'this'</span><span class=\"p\">:</span> <span class=\"mi\">2</span><span class=\"p\">}</span></code></pre>\n</figure>\n\n<p>This code reads like a story from left to right.  We take a sentence,\nsplit it into words, stem each word, and then count frequencies.  This is\nsufficiently simple so that I am confident in the correctness of the result\nafter a brief review of the code.  There is little room for error.</p>\n\n<p><em>note: here we used a curried version of <code class=\"language-plaintext highlighter-rouge\">map</code>.  See the <a href=\"http://toolz.readthedocs.org/en/latest/curry.html\">toolz\ndocs</a> for more info.</em></p>\n\n<h3 id=\"discussion\">Discussion</h3>\n\n<p>The first solution uses lots of simple words.  The second solution uses a few\ncomplex words.  Just as in natural language there are benefits and\ndrawbacks to a rich vocabulary.  The choice of suitable vocabulary largely\ndepends on the audience.</p>\n\n<p>Long solutions of simple words are universally understandable but require\nreader effort to construct meaning.  Most Python programmers can understand the\nfirst solution without additional training but will need to expend effort to\ndeduce its meaning.  This is like the approach taken by <a href=\"http://simple.wikipedia.org/wiki/Main_Page\">Simple English\nWikipedia</a>.</p>\n\n<p>Concise solutions of complex words are not universally understandable but\ndo convey meaning more quickly if the terms are already known by the reader.\nAdditionally if the terms themselves are well tested then these solutions are\nless prone to error.</p>\n\n<p>A good vocabulary can concisely express most relevant problems with a small\nnumber of terms.  The functional standard library (e.g. <code class=\"language-plaintext highlighter-rouge\">map</code>, <code class=\"language-plaintext highlighter-rouge\">groupby</code>,\n<code class=\"language-plaintext highlighter-rouge\">frequencies</code>, …) is such a set.  Understanding a relatively few number of\nterms (around 10-20) enables the concise expression of most common programming\ntasks.  This set was developed and refined across decades of language\nevolution.</p>"
}