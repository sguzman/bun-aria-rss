{
  "title": "What Nested R-hat teaches us about the classical R-hat",
  "link": "https://statmodeling.stat.columbia.edu/2022/10/05/what-nested-r-hat-teaches-us-about-the-classical-r-hat/",
  "comments": "https://statmodeling.stat.columbia.edu/2022/10/05/what-nested-r-hat-teaches-us-about-the-classical-r-hat/#comments",
  "dc:creator": "Charles Margossian",
  "pubDate": "Wed, 05 Oct 2022 19:00:00 +0000",
  "category": [
    "Bayesian Statistics",
    "Statistical computing"
  ],
  "guid": "https://statmodeling.stat.columbia.edu/?p=48054",
  "description": "(this post is by Charles) My colleagues Matt Hoffman, Pavel Sountsov, Lionel Riou-Durand, Aki Vehtari, Andrew Gelman, and I released a preprint titled “Nested R-hat: assessing the convergence of Markov chain Monte Carlo when running many short chains”. This is &#8230; <a href=\"https://statmodeling.stat.columbia.edu/2022/10/05/what-nested-r-hat-teaches-us-about-the-classical-r-hat/\">Continue reading <span class=\"meta-nav\">&#8594;</span></a>",
  "content:encoded": "<p class=\"p1\"><span class=\"s1\">(this post is by Charles)</span></p>\n<p class=\"p1\" style=\"text-align: left;\"><span class=\"s1\">My colleagues Matt Hoffman, Pavel Sountsov, Lionel Riou-Durand, Aki Vehtari, Andrew Gelman, and I released a <a href=\"https://arxiv.org/abs/2110.13017\">preprint</a> titled “Nested R-hat: assessing the convergence of Markov chain Monte Carlo when running many short chains”. This is a revision of an earlier preprint. Here’s the abstract:</span></p>\n<blockquote>\n<p class=\"p3\"><span class=\"s1\">The growing availability of hardware accelerators such as GPUs has generated interest in Markov chains Monte Carlo (MCMC) workflows which run a large number of chains in parallel. Each chain still needs to forget its initial state but the subsequent sampling phase can be almost arbitrarily short. To determine if the resulting short chains are reliable, we need to assess how close the Markov chains are to convergence to their stationary distribution. The R-hat statistic is a battle-tested convergence diagnostic but unfortunately can require long chains to work well. We present a nested design to overcome this challenge, and introduce tuning parameters to control the reliability, bias, and variance of convergence diagnostics.</span></p>\n</blockquote>\n<p class=\"p3\"><span class=\"s1\">The paper is motivated by the possibility of running many Markov chains in parallel on modern hardware, such as GPU. Increasing the number of chains allows you to reduce the variance of your Monte Carlo estimator, which is what the sampling phase is for, but not the bias, which is what the warmup phase is for (that&#8217;s the short story).<span class=\"Apple-converted-space\">  </span>So you can trade length of the sampling phase for number of chains but you still need to achieve approximate convergence.</span></p>\n<p class=\"p3\"><span class=\"s1\">There’s more to be said about the many-short-chains regime but what I want to focus on is what we’ve learned about <a href=\"https://arxiv.org/abs/1903.08008\">the more classic R-hat</a>. The first step is to rewrite the condition, R-hat < 1.01, as a tolerance on the variance of the <i>per chain </i>Monte Carlo estimator. Intuitively, we’re running a stochastic algorithm to estimate an expectation value, which is a non-random quantity. Hence, different chains should, despite their different initialization and seed, still come to an “agreement”. This agreement is measured by the variance of the estimator produced by each chain.</span></p>\n<p class=\"p3\"><span class=\"s1\">Now here’s the paradox. The expected squared error of a <i>per chain </i>Monte Carlo estimator decomposes into a squared bias and a variance. When diagnosing convergence, we’re really interested in making sure the bias has decayed sufficiently (a common phrase is “has become negligible”, but I find it useful to think of MCMC as a biased algorithm). But, with R-hat, we’re really monitoring the variance, not the bias! So how can this be a useful diagnostic?</span></p>\n<p class=\"p3\"><span class=\"s1\">This paradox occurred to us when we rewrote R-hat to monitor the variance of Monte Carlo estimators constructed using groups of chains or <i>superchains</i>, rather than a single chain. The resulting nested R-hat decays to 1 provided we have enough chains, even if the individual chains are short (think a single iteration). But here’s the issue: regardless of wether the chains are close to convergence or not, R-hat can be made arbitrarily close to 1 by increasing the size of each superchain and thence decreasing the variance of their Monte Carlo estimator. Which goes back to my earlier point: you cannot monitor bias simply by looking at variance.</span></p>\n<p class=\"p3\"><span class=\"s1\">Or can you?</span></p>\n<p class=\"p3\"><span class=\"s1\">Here’s the twist: we now force all the chains within a superchain to start at the same point. I had this idea initially to deal with multimodal distributions. The chains within a group are no longer independent, though eventually they (hopefully) will forget about each other. In the mean time we have artificially increased the variance. Doing a standard variance decomposition:</span></p>\n<p class=\"p3\"><span class=\"s1\">total variance = variance of conditional expectation + expected conditional variance</span></p>\n<p class=\"p3\"><span class=\"s1\">Here we’re conditioning on the initial point. If the expected value of each chain no longer depends on the initialization, then the first term — variance of the conditional expectation — goes to 0. This is a measurement of “how well the chains forget their starting point”, and we call it the <i>violation of stationarity</i>. It is indifferent to the number of chains. The second term, on the other hand, persists even if your chains are stationary but it decays to 0 as you increase the number of chains. More generally, this <i>persistent variance</i> can be linked to the Effective Sample Size.</span></p>\n<p><a href=\"https://statmodeling.stat.columbia.edu/wp-content/uploads/2022/10/nested-rhat_monitor_large-1.png\"><img loading=\"lazy\" class=\"wp-image-48059  aligncenter\" src=\"https://statmodeling.stat.columbia.edu/wp-content/uploads/2022/10/nested-rhat_monitor_large-1.png\" alt=\"\" width=\"520\" height=\"184\" /></a></p>\n<p class=\"p3\"><span class=\"s1\">We argue that nested R-hat is a (scaled) measure of the <i>violation of stationarity</i>, biased by the <i>persistent variance</i>. How does this link to the squared bias? Well, both bias and violation decay as we warm up our chains, so one can be used as a “proxy clock” of the other. I don’t have a fully general theory for this but if you consider a Gaussian target and are willing to solve an SDE, you can show that the violation and the squared bias decay at the same rate. This is also gives us insight about how over-dispersed initializations should be (or not be) for nested R-hat to be reliable.</span></p>\n<p class=\"p3\"><span class=\"s1\">Now nested R-hat is a generalization of R-hat, meaning our analysis carries over! We moreover have a theory of what R-hat measures which does not assume stationarity. Part of the conceptual leap is to do an asymptotic analysis which considers an infinite number of finite (non-stationary) chains, rather than a single infinitely long (and hence stationary) chain.</span></p>\n<p class=\"p3\"><span class=\"s1\">Moving forward, I hope this idea of a proxy clock will help us identify cases where R-hat and its nested version are reliable, and how we might revise our MCMC processes to get more reliable diagnostics. Two examples discussed in the preprint: choice of initial variance and how to split a fixed total number of chains into superchains.</span></p>\n",
  "wfw:commentRss": "https://statmodeling.stat.columbia.edu/2022/10/05/what-nested-r-hat-teaches-us-about-the-classical-r-hat/feed/",
  "slash:comments": 7
}