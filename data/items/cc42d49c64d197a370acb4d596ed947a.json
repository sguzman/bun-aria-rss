{
  "title": "Dask, Pandas, and GPUs: first steps",
  "link": "",
  "updated": "2019-01-13T00:00:00+00:00",
  "id": "https://mrocklin.github.io/blog/2019/01/13/dask-cudf-first-steps",
  "content": "<h2 id=\"summary\">Summary</h2>\n\n<p>We’re building a distributed GPU Pandas dataframe out of\n<a href=\"https://github.com/rapidsai/cudf\">cuDF</a> and\n<a href=\"https://docs.dask.org/en/latest/dataframe.html\">Dask Dataframe</a>.\nThis effort is young.</p>\n\n<p>This post describes the current situation,\nour general approach,\nand gives examples of what does and doesn’t work today.\nWe end with some notes on scaling performance.</p>\n\n<p>You can also view the experiment in this post as\n<a href=\"https://gist.github.com/mrocklin/4b1b80d1ae07ec73f75b2a19c8e90e2e\">a notebook</a>.</p>\n\n<p>And here is a table of results:</p>\n\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n  <tr>\n    <th>Architecture</th>\n    <th>Time</th>\n    <th>Bandwidth</th>\n  </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th> Single CPU Core </th>\n      <td> 3min 14s </td>\n      <td> 50 MB/s </td>\n    </tr>\n    <tr>\n      <th> Eight CPU Cores </th>\n      <td> 58s </td>\n      <td> 170 MB/s </td>\n    </tr>\n    <tr>\n      <th> Forty CPU Cores </th>\n      <td> 35s </td>\n      <td> 285 MB/s </td>\n    </tr>\n    <tr>\n      <th> One GPU </th>\n      <td> 11s </td>\n      <td> 900 MB/s </td>\n    </tr>\n    <tr>\n      <th> Eight GPUs </th>\n      <td> 5s </td>\n      <td> 2000 MB/s </td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"building-blocks-cudf-and-dask\">Building Blocks: cuDF and Dask</h2>\n\n<p>Building a distributed GPU-backed dataframe is a large endeavor.\nFortunately we’re starting on a good foundation and\ncan assemble much of this system from existing components:</p>\n\n<ol>\n  <li>\n    <p>The <a href=\"https://github.com/rapidsai/cudf\">cuDF</a> library aims to implement the\nPandas API on the GPU.  It gets good speedups on standard operations like\nreading CSV files, filtering and aggregating columns, joins, and so on.</p>\n\n    <div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">import</span> <span class=\"nn\">cudf</span>  <span class=\"c1\"># looks and feels like Pandas, but runs on the GPU\n</span>\n<span class=\"n\">df</span> <span class=\"o\">=</span> <span class=\"n\">cudf</span><span class=\"p\">.</span><span class=\"n\">read_csv</span><span class=\"p\">(</span><span class=\"s\">'myfile.csv'</span><span class=\"p\">)</span>\n<span class=\"n\">df</span> <span class=\"o\">=</span> <span class=\"n\">df</span><span class=\"p\">[</span><span class=\"n\">df</span><span class=\"p\">.</span><span class=\"n\">name</span> <span class=\"o\">==</span> <span class=\"s\">'Alice'</span><span class=\"p\">]</span>\n<span class=\"n\">df</span><span class=\"p\">.</span><span class=\"n\">groupby</span><span class=\"p\">(</span><span class=\"s\">'id'</span><span class=\"p\">).</span><span class=\"n\">value</span><span class=\"p\">.</span><span class=\"n\">mean</span><span class=\"p\">()</span>\n</code></pre></div>    </div>\n\n    <p>cuDF is part of the growing <a href=\"https://rapids.ai\">RAPIDS initiative</a>.</p>\n  </li>\n  <li>\n    <p>The <a href=\"https://docs.dask.org/en/latest/dataframe.html\">Dask Dataframe</a>\nlibrary provides parallel algorithms around the Pandas API.  It composes\nlarge operations like distributed groupbys or distributed joins from a task\ngraph of many smaller single-node groupbys or joins accordingly (and many\n<a href=\"https://docs.dask.org/en/latest/dataframe-api.html\">other operations</a>).</p>\n\n    <div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">import</span> <span class=\"nn\">dask.dataframe</span> <span class=\"k\">as</span> <span class=\"n\">dd</span>  <span class=\"c1\"># looks and feels like Pandas, but runs in parallel\n</span>\n<span class=\"n\">df</span> <span class=\"o\">=</span> <span class=\"n\">dd</span><span class=\"p\">.</span><span class=\"n\">read_csv</span><span class=\"p\">(</span><span class=\"s\">'myfile.*.csv'</span><span class=\"p\">)</span>\n<span class=\"n\">df</span> <span class=\"o\">=</span> <span class=\"n\">df</span><span class=\"p\">[</span><span class=\"n\">df</span><span class=\"p\">.</span><span class=\"n\">name</span> <span class=\"o\">==</span> <span class=\"s\">'Alice'</span><span class=\"p\">]</span>\n<span class=\"n\">df</span><span class=\"p\">.</span><span class=\"n\">groupby</span><span class=\"p\">(</span><span class=\"s\">'id'</span><span class=\"p\">).</span><span class=\"n\">value</span><span class=\"p\">.</span><span class=\"n\">mean</span><span class=\"p\">().</span><span class=\"n\">compute</span><span class=\"p\">()</span>\n</code></pre></div>    </div>\n  </li>\n  <li>\n    <p>The <a href=\"https://distributed.dask.org\">Dask distributed task scheduler</a>\nprovides general-purpose parallel execution given complex task graphs.\nIt’s good for adding multi-node computing into an existing codebase.</p>\n  </li>\n</ol>\n\n<p>Given these building blocks,\nour approach is to make the cuDF API close enough to Pandas that\nwe can reuse the Dask Dataframe algorithms.</p>\n\n<h2 id=\"benefits-and-challenges-to-this-approach\">Benefits and Challenges to this approach</h2>\n\n<p>This approach has a few benefits:</p>\n\n<ol>\n  <li>\n    <p>We get to reuse the parallel algorithms found in Dask Dataframe originally designed for Pandas.</p>\n  </li>\n  <li>\n    <p>It consolidates the development effort within a single codebase so that\nfuture effort spent on CPU Dataframes benefits GPU Dataframes and vice\nversa.  Maintenance costs are shared.</p>\n  </li>\n  <li>\n    <p>By building code that works equally with two DataFrame implementations\n(CPU and GPU) we establish conventions and protocols that will\nmake it easier for other projects to do the same, either with these two\nPandas-like libraries, or with future Pandas-like libraries.</p>\n\n    <p>This approach also aims to demonstrate that the ecosystem should support Pandas-like\nlibraries, rather than just Pandas.  For example, if\n(when?) the Arrow library develops a computational system then we’ll be in\na better place to roll that in as well.</p>\n  </li>\n  <li>\n    <p>When doing any refactor we tend to clean up existing code.</p>\n\n    <p>For example, to make dask dataframe ready for a new GPU Parquet reader\nwe end up <a href=\"https://github.com/dask/dask/pull/4336\">refactoring and simplifying our Parquet I/O logic</a>.</p>\n  </li>\n</ol>\n\n<p>The approach also has some drawbacks. Namely, it places API pressure on cuDF to match Pandas so:</p>\n\n<ol>\n  <li>\n    <p>Slight differences in API now cause larger problems, such as these:</p>\n\n    <ul>\n      <li><a href=\"https://github.com/rapidsai/cudf/issues/251\">Join column ordering differs rapidsai/cudf #251</a></li>\n      <li><a href=\"https://github.com/rapidsai/cudf/issues/483#issuecomment-453218151\">Groupby aggregation column ordering differs rapidsai/cudf #483</a></li>\n    </ul>\n  </li>\n  <li>\n    <p>cuDF has some pressure on it to repeat what some believe to be mistakes in\nthe Pandas API.</p>\n\n    <p>For example, cuDF today supports missing values arguably more sensibly than\nPandas.  Should cuDF have to revert to the old way of doing things\njust to match Pandas semantics?  Dask Dataframe will probably need\nto be more flexible in order to handle evolution and small differences\nin semantics.</p>\n  </li>\n</ol>\n\n<h2 id=\"alternatives\">Alternatives</h2>\n\n<p>We could also write a new dask-dataframe-style project around cuDF that deviates\nfrom the Pandas/Dask Dataframe API.  Until recently this\nhas actually been the approach, and the\n<a href=\"https://github.com/rapidsai/dask-cudf\">dask-cudf</a> project did exactly this.\nThis was probably a good choice early on to get started and prototype things.\nThe project was able to implement a wide range of functionality including\ngroupby-aggregations, joins, and so on using\n<a href=\"https://docs.dask.org/en/latest/delayed.html\">dask delayed</a>.</p>\n\n<p>We’re redoing this now on top of dask dataframe though, which means that we’re\nlosing some functionality that dask-cudf already had, but hopefully the\nfunctionality that we add now will be more stable and established on a firmer\nbase.</p>\n\n<h2 id=\"status-today\">Status Today</h2>\n\n<p>Today very little works, but what does is decently smooth.</p>\n\n<p>Here is a simple example that reads some data from many CSV files,\npicks out a column,\nand does some aggregations.</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">from</span> <span class=\"nn\">dask_cuda</span> <span class=\"kn\">import</span> <span class=\"n\">LocalCUDACluster</span>\n<span class=\"kn\">import</span> <span class=\"nn\">dask_cudf</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dask.distributed</span> <span class=\"kn\">import</span> <span class=\"n\">Client</span>\n\n<span class=\"n\">cluster</span> <span class=\"o\">=</span> <span class=\"n\">LocalCUDACluster</span><span class=\"p\">()</span>  <span class=\"c1\"># runs on eight local GPUs\n</span><span class=\"n\">client</span> <span class=\"o\">=</span> <span class=\"n\">Client</span><span class=\"p\">(</span><span class=\"n\">cluster</span><span class=\"p\">)</span>\n\n<span class=\"n\">gdf</span> <span class=\"o\">=</span> <span class=\"n\">dask_cudf</span><span class=\"p\">.</span><span class=\"n\">read_csv</span><span class=\"p\">(</span><span class=\"s\">'data/nyc/many/*.csv'</span><span class=\"p\">)</span>  <span class=\"c1\"># wrap around many CSV files\n</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">gdf</span><span class=\"p\">.</span><span class=\"n\">passenger_count</span><span class=\"p\">.</span><span class=\"nb\">sum</span><span class=\"p\">().</span><span class=\"n\">compute</span><span class=\"p\">()</span>\n<span class=\"mi\">184464740</span>\n</code></pre></div></div>\n\n<p><em>Also note, NYC Taxi ridership is significantly less than it was a few years ago</em></p>\n\n<h2 id=\"what-im-excited-about-in-the-example-above\">What I’m excited about in the example above</h2>\n\n<ul>\n  <li>\n    <p>All of the infrastructure surrounding the cuDF code, like the cluster setup,\ndiagnostics, JupyterLab environment, and so on, came for free, like any\nother new Dask project.</p>\n\n    <p>Here is an image of my JupyterLab setup</p>\n\n    <p><a href=\"https://matthewrocklin.com/blog/images/dask-cudf-environment.png\">\n  <img src=\"https://matthewrocklin.com/blog/images/dask-cudf-environment.png\" alt=\"Dask + CUDA + cuDF JupyterLab environment\" width=\"70%\" />\n</a></p>\n  </li>\n  <li>\n    <p>Our <code class=\"language-plaintext highlighter-rouge\">df</code> object is actually just a normal Dask Dataframe.  We didn’t have to\nwrite new <code class=\"language-plaintext highlighter-rouge\">__repr__</code>, <code class=\"language-plaintext highlighter-rouge\">__add__</code>, or <code class=\"language-plaintext highlighter-rouge\">.sum()</code> implementations, and probably\nmany functions we didn’t think about work well today (though also many\ndon’t).</p>\n  </li>\n  <li>\n    <p>We’re tightly integrated and more connected to other systems. For example, if\nwe wanted to convert our dask-cudf-dataframe to a dask-pandas-dataframe then\nwe would just use the cuDF <code class=\"language-plaintext highlighter-rouge\">to_pandas</code> function:</p>\n\n    <div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">df</span> <span class=\"o\">=</span> <span class=\"n\">df</span><span class=\"p\">.</span><span class=\"n\">map_partitions</span><span class=\"p\">(</span><span class=\"n\">cudf</span><span class=\"p\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">.</span><span class=\"n\">to_pandas</span><span class=\"p\">)</span>\n</code></pre></div>    </div>\n\n    <p>We don’t have to write anything special like a separate <code class=\"language-plaintext highlighter-rouge\">.to_dask_dataframe</code>\nmethod or handle other special cases.</p>\n\n    <p>Dask parallelism is orthogonal to the choice of CPU or GPU.</p>\n  </li>\n  <li>\n    <p>It’s easy to switch hardware.  By avoiding separate <code class=\"language-plaintext highlighter-rouge\">dask-cudf</code> code paths\nit’s easier to add cuDF to an existing Dask+Pandas codebase to run on GPUs,\nor to remove cuDF and use Pandas if we want our code to be runnable without GPUs.</p>\n\n    <p>There are more examples of this in the scaling section below.</p>\n  </li>\n</ul>\n\n<h2 id=\"whats-wrong-with-the-example-above\">What’s wrong with the example above</h2>\n\n<p>In general the answer is <strong>many small things</strong>.</p>\n\n<ol>\n  <li>\n    <p>The <code class=\"language-plaintext highlighter-rouge\">cudf.read_csv</code> function doesn’t yet support reading chunks from a\nsingle CSV file, and so doesn’t work well with very large CSV files.  We\nhad to split our large CSV files into many smaller CSV files first with\nnormal Dask+Pandas:</p>\n\n    <div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">import</span> <span class=\"nn\">dask.dataframe</span> <span class=\"k\">as</span> <span class=\"n\">dd</span>\n<span class=\"n\">df</span> <span class=\"o\">=</span> <span class=\"n\">dd</span><span class=\"p\">.</span><span class=\"n\">read_csv</span><span class=\"p\">(</span><span class=\"s\">'few-large/*.csv'</span><span class=\"p\">)</span>\n       <span class=\"p\">.</span><span class=\"n\">repartition</span><span class=\"p\">(</span><span class=\"n\">npartitions</span><span class=\"o\">=</span><span class=\"mi\">100</span><span class=\"p\">)</span>\n       <span class=\"p\">.</span><span class=\"n\">to_csv</span><span class=\"p\">(</span><span class=\"s\">'many-small/*.csv'</span><span class=\"p\">,</span> <span class=\"n\">index</span><span class=\"o\">=</span><span class=\"bp\">False</span><span class=\"p\">)</span>\n</code></pre></div>    </div>\n\n    <p>(See <a href=\"https://github.com/rapidsai/cudf/issues/568\">rapidsai/cudf #568</a>)</p>\n  </li>\n  <li>\n    <p>Many operations that used to work in dask-cudf like groupby-aggregations\nand joins no longer work.  We’re going to need to slightly modify many cuDF\nAPIs over the next couple of months to more closely match their Pandas\nequivalents.</p>\n  </li>\n  <li>\n    <p>I ran the timing cell twice because it currently takes a few seconds to\n<code class=\"language-plaintext highlighter-rouge\">import cudf</code> today.\n<a href=\"https://github.com/rapidsai/cudf/issues/627\">rapidsai/cudf #627</a></p>\n  </li>\n  <li>\n    <p>We had to make Dask Dataframe a bit more flexible and assume less about its\nconstituent dataframes being exactly Pandas dataframes.  (see\n<a href=\"https://github.com/dask/dask/pull/4359\">dask/dask #4359</a> and\n<a href=\"https://github.com/dask/dask/pull/4375\">dask/dask #4375</a> for examples).\nI suspect that there will by many more small changes like\nthese necessary in the future.</p>\n  </li>\n</ol>\n\n<p>These problems are representative of dozens more similar issues.  They are\nall fixable and indeed, many are actively being fixed today by the <a href=\"https://github.com/rapidsai/cudf/graphs/contributors\">good folks\nworking on RAPIDS</a>.</p>\n\n<h2 id=\"near-term-schedule\">Near Term Schedule</h2>\n\n<p>The RAPIDS group is currently busy working to release 0.5, which includes some\nof the fixes necessary to run the example above, and also many unrelated\nstability improvements.  This will probably keep them busy for a week or two\nduring which I don’t expect to see much Dask + cuDF work going on other than\nplanning.</p>\n\n<p>After that, Dask parallelism support will be a top priority, so\nI look forward to seeing some rapid progress here.</p>\n\n<h2 id=\"scaling-results\">Scaling Results</h2>\n\n<p>In <a href=\"../../../2019/01/03/dask-array-gpus-first-steps\">my last post about combining Dask Array with CuPy</a>,\na GPU-accelerated Numpy,\nwe saw impressive speedups from using many GPUs on a simple problem that\nmanipulated some simple random data.</p>\n\n<h4 id=\"dask-array--cupy-on-random-data\">Dask Array + CuPy on Random Data</h4>\n\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n  <tr>\n    <th>Architecture</th>\n    <th>Time</th>\n  </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th> Single CPU Core </th>\n      <td> 2hr 39min </td>\n    </tr>\n    <tr>\n      <th> Forty CPU Cores </th>\n      <td> 11min 30s </td>\n    </tr>\n    <tr>\n      <th> One GPU </th>\n      <td> 1 min 37s </td>\n    </tr>\n    <tr>\n      <th> Eight GPUs </th>\n      <td> 19s </td>\n    </tr>\n  </tbody>\n</table>\n\n<p>That exercise was easy to scale because it was almost entirely bound by the\ncomputation of creating random data.</p>\n\n<h4 id=\"dask-dataframe--cudf-on-csv-data\">Dask DataFrame + cuDF on CSV data</h4>\n\n<p>We did a similar study on the <code class=\"language-plaintext highlighter-rouge\">read_csv</code> example above, which is bound mostly\nby reading CSV data from disk and then parsing it.  You can see a notebook\navailable\n<a href=\"https://gist.github.com/mrocklin/4b1b80d1ae07ec73f75b2a19c8e90e2e\">here</a>.  We\nhave similar (though less impressive) numbers to present.</p>\n\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n  <tr>\n    <th>Architecture</th>\n    <th>Time</th>\n    <th>Bandwidth</th>\n  </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th> Single CPU Core </th>\n      <td> 3min 14s </td>\n      <td> 50 MB/s </td>\n    </tr>\n    <tr>\n      <th> Eight CPU Cores </th>\n      <td> 58s </td>\n      <td> 170 MB/s </td>\n    </tr>\n    <tr>\n      <th> Forty CPU Cores </th>\n      <td> 35s </td>\n      <td> 285 MB/s </td>\n    </tr>\n    <tr>\n      <th> One GPU </th>\n      <td> 11s </td>\n      <td> 900 MB/s </td>\n    </tr>\n    <tr>\n      <th> Eight GPUs </th>\n      <td> 5s </td>\n      <td> 2000 MB/s </td>\n    </tr>\n  </tbody>\n</table>\n\n<p><em>The bandwidth numbers were computed by noting that the data was around 10 GB on disk</em></p>\n\n<h2 id=\"analysis\">Analysis</h2>\n\n<p>First, I want to emphasize again that it’s easy to test a wide variety of\narchitectures using this setup because of the Pandas API compatibility between\nall of the different projects.  We’re seeing a wide range of performance (40x\nspan) across a variety of different hardware with a wide range of cost points.</p>\n\n<p>Second, note that this problem scales less well than our\n<a href=\"../../../2019/01/03/dask-array-gpus-first-steps\">previous example with CuPy</a>,\nboth on CPU and GPU.\nI suspect that this is because this example is also bound by I/O and not just\nnumber-crunching.  While the jump from single-CPU to single-GPU is large, the\njump from single-CPU to many-CPU or single-GPU to many-GPU is not as large as\nwe would have liked.  For GPUs for example we got around a 2x speedup when we\nadded 8x as many GPUs.</p>\n\n<p>At first one might think that this is because we’re saturating disk read speeds.\nHowever two pieces of evidence go against that guess:</p>\n\n<ul>\n  <li>NVIDIA folks familiar with my current hardware inform me that they’re able to get\nmuch higher I/O throughput when they’re careful</li>\n  <li>The CPU scaling is similarly poor, despite the fact that it’s obviously not\nreaching full I/O bandwidth</li>\n</ul>\n\n<p>Instead, it’s likely that we’re just not treating our disks and IO pipelines\ncarefully.</p>\n\n<p>We might consider working to think more carefully about data locality within a\nsingle machine.  Alternatively, we might just choose to use a smaller machine,\nor many smaller machines.  My team has been asking me to start playing with\nsome cheaper systems than a DGX, I may experiment with those soon.  It may be\nthat for data-loading and pre-processing workloads the previous wisdom of “pack\nas much computation as you can into a single box” no longer holds\n(without us doing more work that is).</p>\n\n<h3 id=\"come-help\">Come help!</h3>\n\n<p>If the work above sounds interesting to you then come help!\nThere is a lot of low-hanging and high impact work to do.</p>\n\n<p>If you’re interested in being paid to focus more on these topics, then consider\napplying for a job.  NVIDIA’s RAPIDS team is looking to hire engineers for Dask\ndevelopment with GPUs and other data analytics library development projects.</p>\n\n<ul>\n  <li><a href=\"https://nvidia.wd5.myworkdayjobs.com/en-US/NVIDIAExternalCareerSite/job/US-TX-Austin/Senior-Library-Software-Engineer---RAPIDS_JR1919608-1\">Senior Library Software Engineer - RAPIDS</a></li>\n</ul>"
}