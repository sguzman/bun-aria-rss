{
  "title": "Multiarmed bandits in the context of reinforcement learning",
  "link": "",
  "published": "2020-02-25T12:00:00-08:00",
  "updated": "2020-02-25T12:00:00-08:00",
  "author": {
    "name": "Cathy Yeh"
  },
  "id": "tag:efavdb.com,2020-02-25:/multiarmed-bandits",
  "summary": "<p><a href=\"http://incompleteideas.net/book/RLbook2018.pdf\">Reinforcement Learning: An Introduction</a> by Sutton and Barto[1] is a book that is universally recommended to beginners in their <span class=\"caps\">RL</span> studies.  The first chapter is an extended text-heavy introduction. The second chapter deals with multiarmed bandits, i.e. slot machines with multiple arms, and is the subject of today …</p>",
  "content": "<p><a href=\"http://incompleteideas.net/book/RLbook2018.pdf\">Reinforcement Learning: An Introduction</a> by Sutton and Barto[1] is a book that is universally recommended to beginners in their <span class=\"caps\">RL</span> studies.  The first chapter is an extended text-heavy introduction. The second chapter deals with multiarmed bandits, i.e. slot machines with multiple arms, and is the subject of today&#8217;s&nbsp;post.</p>\n<p>Before getting into the <em>what</em> and <em>how</em> of bandits, I&#8217;d like to address the <strong>why</strong>, since the &#8220;why&#8221; can guard against getting lost in the details / not seeing the forest for the&nbsp;trees.</p>\n<h1>Why discuss multiarmed&nbsp;bandits?</h1>\n<p><span class=\"caps\">RL</span> treats the problem of trying to achieve a goal in an environment where an agent is <em>not</em> instructed about which actions to take to achieve that goal, in contrast to supervised learning problems.  Learning the best actions to take is a complicated problem, since the best actions depend on what state an agent is in, e.g. an agent trying to get to a goalpost east of its current location as quickly as possible may find that moving east is a generally good policy, but not if there is a fire-breathing dragon in the way, in which case, it might make sense to move up or down to navigate around the&nbsp;obstacle.</p>\n<p>Multiarmed bandits are simpler problem: a single state system.  No matter which action an agent takes, i.e. which slot machine arm the agent pulls, the agent ends up back in the same state; the distribution of rewards as a consequence of the agent&#8217;s action remains the same, assuming a stationary distribution of rewards, and actions have no effect on subsequent states or rewards.  This simple case study is useful for building intuition and introducing <span class=\"caps\">RL</span> concepts that will be expanded on in later chapters of&nbsp;[1].</p>\n<h1>Key <span class=\"caps\">RL</span> concepts introduced by the multiarmed bandit&nbsp;problem</h1>\n<h2>The nature of the&nbsp;problem</h2>\n<p><strong>Agent has a goal</strong>: In <span class=\"caps\">RL</span> and multiarmed bandit problems, we want to figure out the strategy, or &#8220;policy&#8221; in <span class=\"caps\">RL</span> lingo, that will maximize our rewards.  For the simple bandit problem, this goal is equivalent to maximizing the reward &#8212; literally, money! &#8212; for each arm&nbsp;pull.</p>\n<p><strong>Unlike supervised learning, no ground truth is supplied</strong>: Each slot has a different distribution of rewards, but the agent playing the machine does not know that distribution.  Instead, the agent has to try different actions and evaluate how good the actions are.  The goodness of an action is straightforwardly determined by its immediate reward in the bandit&nbsp;case.</p>\n<p><strong>Exploration vs. exploitation</strong>:  Based on a few trials, one arm may appear to yield the highest rewards, but the agent may decide to try others occasionally to improve its estimates of the rewards, an example of balancing exploration and exploitation.  The various algorithms handle exploration vs. exploitation differently, but this example introduces one method that is simple but widely-used in practice: the epsilon-greedy algorithm, which takes greedy actions most of the time (exploits) but takes random actions (explores) a fraction epsilon of the&nbsp;time.</p>\n<h3>Different approaches to learning a&nbsp;policy</h3>\n<p><strong>model-free</strong>:  All the strategies discussed in [1] for solving the bandit problem are &#8220;model-free&#8221; strategies.  In real world applications, a model of the world is rarely available, and the agent has to figure out how to act based on sampled experience, and the same applies to the bandit case; even though bandits are a simpler single state system (we don&#8217;t have to model transitions from state to state), an agent still does not know the model that generates the probability of a reward <span class=\"math\">\\(r\\)</span> given an action <span class=\"math\">\\(a\\)</span>, <span class=\"math\">\\(P(r|a)\\)</span> and has to figure that out from trial and&nbsp;error.</p>\n<p>There <em>are</em> model-based algorithms that attempt to model the environment&#8217;s transition dynamics from data, but many popular algorithms today are model-free because of the difficulty of modeling those&nbsp;dynamics.</p>\n<h4>Learning&nbsp;action-values</h4>\n<p>The bandit problem introduces the idea of estimating the expected value associated with each action, namely the <em>action-value function</em> in <span class=\"caps\">RL</span> terms.  The concept is very intuitive &#8212; as an agent pulls on different bandit arms, it will accumulate rewards associated with each arm.  A simple way to estimate the expected value per arm is just to average the rewards generated by pulling on each slot.  The policy that follows is then implicit, namely, take the action / pull on the arm with the highest estimated&nbsp;action-value!</p>\n<p>Historically, <span class=\"caps\">RL</span> formalism has dealt with estimating value functions and using them to figure out a policy, which includes the Q-Learning (&#8220;Q&#8221; stands for action-value!) approach we mentioned in our earlier <a href=\"https://efavdb.com/openai-scholars-intro\">post</a>.</p>\n<h4>Learning policies&nbsp;directly</h4>\n<p>[1] also use the bandit problem to introduce a type of algorithm that approaches the problem, not indirectly by learning a value function and deriving the policy from those value functions, but by parameterizing the policy directly and learning the parameters that optimize the rewards.  This class of algorithm is a &#8220;policy gradient method&#8221; and is very popular today for its nice convergence properties.  After the foreshadowing in the bandit problem, policy gradients only reappear very late in [1] &#8212; chapter&nbsp;13!</p>\n<p>We now provide code for&nbsp;concreteness.</p>\n<h1>Ground truth is hidden in our multiarmed&nbsp;bandit</h1>\n<p>The <code>Bandit</code> class initializes a multiarmed bandit. The distribution of rewards per arm follows a Gaussian distribution with some mean dollar&nbsp;amount.</p>\n<div class=\"highlight\"><pre><span></span><span class=\"k\">class</span> <span class=\"nc\">Bandit</span><span class=\"p\">:</span>\n    <span class=\"sd\">&quot;&quot;&quot;N-armed bandit with stationary distribution of rewards per arm.</span>\n<span class=\"sd\">    Each arm (action) is identified by an integer.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">n_arms</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">mu</span><span class=\"p\">:</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">sigma</span><span class=\"p\">:</span> <span class=\"nb\">float</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">n_arms</span> <span class=\"o\">=</span> <span class=\"n\">n_arms</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">std</span> <span class=\"o\">=</span> <span class=\"n\">sigma</span>\n        <span class=\"c1\"># a dict of the mean action_value per arm, w/ each action_value sampled from a Gaussian</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">action_values</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"n\">k</span><span class=\"p\">:</span> <span class=\"n\">s</span> <span class=\"k\">for</span> <span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"n\">s</span> <span class=\"ow\">in</span> <span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">normal</span><span class=\"p\">(</span><span class=\"n\">mu</span><span class=\"p\">,</span> <span class=\"n\">sigma</span><span class=\"p\">,</span> <span class=\"n\">n_arms</span><span class=\"p\">))}</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">actions</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">action_values</span><span class=\"o\">.</span><span class=\"n\">keys</span><span class=\"p\">())</span>  <span class=\"c1\"># arms of the bandit</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__call__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">action</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">float</span><span class=\"p\">:</span>\n        <span class=\"sd\">&quot;&quot;&quot;Get reward from bandit for action&quot;&quot;&quot;</span>\n        <span class=\"k\">return</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">normal</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">action_values</span><span class=\"p\">[</span><span class=\"n\">action</span><span class=\"p\">],</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">std</span><span class=\"p\">)</span>\n</pre></div>\n\n\n<p>Implementation detail: the means per arm, stored in <code>self.action_values</code>, are drawn from a Gaussian distribution upon&nbsp;initialization).</p>\n<p>The agent doesn&#8217;t know the true mean rewards per arm &#8212; it only sees a sample reward when he takes the action of pulling on a particular bandit arm (<code>__call__</code>).</p>\n<h1>Action, reward, update&nbsp;strategy</h1>\n<p>For every action the agent takes, it gets a reward.  With each additional interaction with the bandit, the agent has a new data point it can use to update its strategy (whether indirectly, via an updated action-value estimate, or directly in the policy&nbsp;gradient).</p>\n<div class=\"highlight\"><pre><span></span><span class=\"k\">class</span> <span class=\"nc\">BaseBanditAlgo</span><span class=\"p\">(</span><span class=\"n\">ABC</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Base class for algorithms to maximize the rewards </span>\n<span class=\"sd\">    for the multiarmed bandit problem&quot;&quot;&quot;</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">bandit</span><span class=\"p\">:</span> <span class=\"n\">Bandit</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">bandit</span> <span class=\"o\">=</span> <span class=\"n\">bandit</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">timestep</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">rewards</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">_select_action</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">int</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">_update_for_action_and_reward</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">action</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">reward</span><span class=\"p\">:</span> <span class=\"nb\">float</span><span class=\"p\">):</span>\n         <span class=\"k\">pass</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">run</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">float</span><span class=\"p\">:</span>\n        <span class=\"n\">action</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_select_action</span><span class=\"p\">()</span>\n        <span class=\"n\">reward</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">bandit</span><span class=\"p\">(</span><span class=\"n\">action</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_update_for_action_and_reward</span><span class=\"p\">(</span><span class=\"n\">action</span><span class=\"p\">,</span> <span class=\"n\">reward</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">reward</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__call__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">n_timesteps</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">):</span>\n        <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">n_timesteps</span><span class=\"p\">):</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">timestep</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">rewards</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">())</span>\n</pre></div>\n\n\n<h2>Two types of strategies: value based and policy&nbsp;based</h2>\n<ol>\n<li>value based - agents try to directly estimate the value of\n   each action (and whose policies, i.e. probability of selecting an\n   action, are therefore implicit, since the agent will want to choose\n   the action that has the highest&nbsp;value)</li>\n<li>policy based - agents don&#8217;t try to directly estimate the value\n   of an action and instead directly store the policy, i.e. the\n   probability of taking each&nbsp;action.</li>\n</ol>\n<p>An example of a <strong>value based</strong> strategy / action-value method for the\nbandit problem is the <code>EpsilonGreedy</code> approach, which selects the\naction associated with the highest estimated action-value with probability <span class=\"math\">\\(1-\\epsilon\\)</span>, but chooses a random arm\na fraction <span class=\"math\">\\(\\epsilon\\)</span> of the time as part of its exploration&nbsp;strategy.</p>\n<div class=\"highlight\"><pre><span></span><span class=\"k\">class</span> <span class=\"nc\">EpsilonGreedy</span><span class=\"p\">(</span><span class=\"n\">BaseEstimateActionValueAlgo</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Greedy algorithm that explores/samples from the non-greedy action some fraction, </span>\n<span class=\"sd\">    epsilon, of the time.</span>\n\n<span class=\"sd\">    - For a basic greedy algorithm, set epsilon = 0.</span>\n<span class=\"sd\">    - For optimistic intialization, set q_init &gt; mu, the mean of the Gaussian from</span>\n<span class=\"sd\">      which the real values per bandit arm are sampled (default is 0).</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">bandit</span><span class=\"p\">:</span> <span class=\"n\">Bandit</span><span class=\"p\">,</span> <span class=\"n\">epsilon</span><span class=\"p\">:</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n        <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"n\">bandit</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">epsilon</span> <span class=\"o\">=</span> <span class=\"n\">epsilon</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">_select_action</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">int</span><span class=\"p\">:</span>\n        <span class=\"k\">if</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">sample</span><span class=\"p\">()</span> <span class=\"o\">&lt;</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">epsilon</span><span class=\"p\">:</span>\n            <span class=\"c1\"># take random action</span>\n            <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">choice</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">bandit</span><span class=\"o\">.</span><span class=\"n\">actions</span><span class=\"p\">)</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"c1\"># take greedy action</span>\n            <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">est_action_values</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"o\">=</span><span class=\"k\">lambda</span> <span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">est_action_values</span><span class=\"p\">[</span><span class=\"n\">key</span><span class=\"p\">])</span>\n        <span class=\"k\">return</span> <span class=\"n\">a</span>\n</pre></div>\n\n\n<p>(See end of post for additional action-value&nbsp;methods.)</p>\n<p>An example of a <strong>policy based</strong> strategy is the <code>GradientBandit</code>\nmethod, which stores its policy, the probability per action in\n<code>self.preferences</code>.  It learns these preferences by doing stochastic\ngradient ascent along the preferences in the gradient of the expected\nreward in <code>_update_for_action_and_reward</code> (see [1] for&nbsp;derivation).</p>\n<div class=\"highlight\"><pre><span></span><span class=\"k\">class</span> <span class=\"nc\">GradientBandit</span><span class=\"p\">(</span><span class=\"n\">BaseBanditAlgo</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Algorithm that does not try to estimate action values directly and, instead, tries to learn</span>\n<span class=\"sd\">    a preference for each action (equivalent to stochastic gradient ascent along gradient in expected</span>\n<span class=\"sd\">    reward over preferences).</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">bandit</span><span class=\"p\">:</span> <span class=\"n\">Bandit</span><span class=\"p\">,</span> <span class=\"n\">alpha</span><span class=\"p\">:</span> <span class=\"nb\">float</span><span class=\"p\">):</span>\n        <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"n\">bandit</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">alpha</span> <span class=\"o\">=</span> <span class=\"n\">alpha</span>  <span class=\"c1\"># step-size</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">reward_baseline_avg</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">preferences</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"n\">action</span><span class=\"p\">:</span> <span class=\"mi\">0</span> <span class=\"k\">for</span> <span class=\"n\">action</span> <span class=\"ow\">in</span> <span class=\"n\">bandit</span><span class=\"o\">.</span><span class=\"n\">actions</span><span class=\"p\">}</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_calc_probs_from_preferences</span><span class=\"p\">()</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">_calc_probs_from_preferences</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"sd\">&quot;&quot;&quot;Probabilities per action follow a Boltzmann distribution over the preferences &quot;&quot;&quot;</span>\n        <span class=\"n\">exp_preferences_for_action</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"n\">action</span><span class=\"p\">:</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">exp</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">action</span><span class=\"p\">,</span> <span class=\"n\">v</span> <span class=\"ow\">in</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">preferences</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">()}</span>\n        <span class=\"n\">partition_fxn</span> <span class=\"o\">=</span> <span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"n\">exp_preferences_for_action</span><span class=\"o\">.</span><span class=\"n\">values</span><span class=\"p\">())</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">probabilities_for_action</span> <span class=\"o\">=</span> <span class=\"n\">OrderedDict</span><span class=\"p\">({</span><span class=\"n\">action</span><span class=\"p\">:</span> <span class=\"n\">v</span> <span class=\"o\">/</span> <span class=\"n\">partition_fxn</span> <span class=\"k\">for</span> <span class=\"n\">action</span><span class=\"p\">,</span> <span class=\"n\">v</span> <span class=\"ow\">in</span> \n                                                     <span class=\"n\">exp_preferences_for_action</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">()})</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">_select_action</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">int</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">choice</span><span class=\"p\">(</span><span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">probabilities_for_action</span><span class=\"o\">.</span><span class=\"n\">keys</span><span class=\"p\">()),</span> \n                                <span class=\"n\">p</span><span class=\"o\">=</span><span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">probabilities_for_action</span><span class=\"o\">.</span><span class=\"n\">values</span><span class=\"p\">()))</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">_update_for_action_and_reward</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">action</span><span class=\"p\">,</span> <span class=\"n\">reward</span><span class=\"p\">):</span>\n        <span class=\"sd\">&quot;&quot;&quot;Update preferences&quot;&quot;&quot;</span>\n        <span class=\"n\">reward_diff</span> <span class=\"o\">=</span> <span class=\"n\">reward</span> <span class=\"o\">-</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">reward_baseline_avg</span>\n\n        <span class=\"c1\"># can we combine these updates into single expression using kronecker delta?</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">preferences</span><span class=\"p\">[</span><span class=\"n\">action</span><span class=\"p\">]</span> <span class=\"o\">+=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">alpha</span> <span class=\"o\">*</span> <span class=\"n\">reward_diff</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">-</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">probabilities_for_action</span><span class=\"p\">[</span><span class=\"n\">action</span><span class=\"p\">])</span>\n        <span class=\"k\">for</span> <span class=\"n\">a</span> <span class=\"ow\">in</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">bandit</span><span class=\"o\">.</span><span class=\"n\">actions</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"n\">a</span> <span class=\"o\">==</span> <span class=\"n\">action</span><span class=\"p\">:</span>\n                <span class=\"k\">continue</span>\n            <span class=\"k\">else</span><span class=\"p\">:</span>\n                <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">preferences</span><span class=\"p\">[</span><span class=\"n\">a</span><span class=\"p\">]</span> <span class=\"o\">-=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">alpha</span> <span class=\"o\">*</span> <span class=\"n\">reward_diff</span> <span class=\"o\">*</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">probabilities_for_action</span><span class=\"p\">[</span><span class=\"n\">a</span><span class=\"p\">]</span>\n\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">reward_baseline_avg</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span><span class=\"o\">/</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">timestep</span> <span class=\"o\">*</span> <span class=\"n\">reward_diff</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_calc_probs_from_preferences</span><span class=\"p\">()</span>\n</pre></div>\n\n\n<h1>Extra: Total rewards for different bandit&nbsp;algorithms</h1>\n<p>We have discussed a bunch of different bandit algorithms, but haven&#8217;t seen what rewards they yield in&nbsp;practice!</p>\n<p>In this\n<a href=\"https://github.com/frangipane/reinforcement-learning/blob/master/00-Introduction/multiarmed_bandits.ipynb\">Jupyter notebook</a>,\nwe run the algorithms through a range of values for their parameters\nto compare their cumulative rewards across 1000 timesteps (also\naveraged across many trials of different bandits to smooth things\nout).  In the end, we arrive at a plot of the parameter study, that\nreproduces Figure 2.6 in&nbsp;[1].</p>\n<p><img alt=\"![parameter study]({static}/images/reproduce_multiarmed_bandit_parameter_study.png)\" src=\"https://efavdb.com/images/reproduce_multiarmed_bandit_parameter_study.png\"></p>\n<h1>References</h1>\n<p>[1] Sutton and Barto - <a href=\"http://incompleteideas.net/book/RLbook2018.pdf\">Reinforcement Learning: An Introduction (2nd&nbsp;Edition)</a></p>\n<script type=\"text/javascript\">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {\n    var align = \"center\",\n        indent = \"0em\",\n        linebreak = \"false\";\n\n    if (false) {\n        align = (screen.width < 768) ? \"left\" : align;\n        indent = (screen.width < 768) ? \"0em\" : indent;\n        linebreak = (screen.width < 768) ? 'true' : linebreak;\n    }\n\n    var mathjaxscript = document.createElement('script');\n    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';\n    mathjaxscript.type = 'text/javascript';\n    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';\n\n    var configscript = document.createElement('script');\n    configscript.type = 'text/x-mathjax-config';\n    configscript[(window.opera ? \"innerHTML\" : \"text\")] =\n        \"MathJax.Hub.Config({\" +\n        \"    config: ['MMLorHTML.js'],\" +\n        \"    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } },\" +\n        \"    jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" +\n        \"    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" +\n        \"    displayAlign: '\"+ align +\"',\" +\n        \"    displayIndent: '\"+ indent +\"',\" +\n        \"    showMathMenu: true,\" +\n        \"    messageStyle: 'normal',\" +\n        \"    tex2jax: { \" +\n        \"        inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" +\n        \"        displayMath: [ ['$$','$$'] ],\" +\n        \"        processEscapes: true,\" +\n        \"        preview: 'TeX',\" +\n        \"    }, \" +\n        \"    'HTML-CSS': { \" +\n        \"        availableFonts: ['STIX', 'TeX'],\" +\n        \"        preferredFont: 'STIX',\" +\n        \"        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" +\n        \"        linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" +\n        \"    }, \" +\n        \"}); \" +\n        \"if ('default' !== 'default') {\" +\n            \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" +\n                \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" +\n                \"VARIANT['normal'].fonts.unshift('MathJax_default');\" +\n                \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" +\n                \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" +\n                \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" +\n            \"});\" +\n            \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" +\n                \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" +\n                \"VARIANT['normal'].fonts.unshift('MathJax_default');\" +\n                \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" +\n                \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" +\n                \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" +\n            \"});\" +\n        \"}\";\n\n    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);\n    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);\n}\n</script>",
  "category": [
    "",
    "",
    ""
  ]
}