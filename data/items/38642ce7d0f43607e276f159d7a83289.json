{
  "title": "Integration method to map model scores to conversion rates from example data",
  "link": "",
  "published": "2018-03-03T17:53:00-08:00",
  "updated": "2018-03-03T17:53:00-08:00",
  "author": {
    "name": "Jonathan Landy"
  },
  "id": "tag:efavdb.com,2018-03-03:/integration-method-to-map-model-scores-to-conversion-rates-from-example-data",
  "summary": "<p>This note addresses the typical applied problem of estimating from data how a target &#8220;conversion rate&#8221; function varies with some available scalar score function &#8212; e.g., estimating conversion rates from some marketing campaign as a function of a targeting model score. The idea centers around estimating the integral of the …</p>",
  "content": "<p>This note addresses the typical applied problem of estimating from data how a target &#8220;conversion rate&#8221; function varies with some available scalar score function &#8212; e.g., estimating conversion rates from some marketing campaign as a function of a targeting model score. The idea centers around estimating the integral of the rate function; differentiating this gives the rate function. The method is a variation on a standard technique for estimating pdfs via fits to empirical&nbsp;cdfs.</p>\n<h3>Problem definition and naive binning&nbsp;solution</h3>\n<p>Here, we are interested in estimating a rate function, <span class=\"math\">\\(p \\equiv p(x)\\)</span>, representing the probability of some &#8220;conversion&#8221; event as a function of <span class=\"math\">\\(x\\)</span>, some scalar model score. To do this, we assume we have access to a finite set of score-outcome data of the form <span class=\"math\">\\(\\{(x_i, n_i), i= 1, \\ldots ,k\\}\\)</span>. Here, <span class=\"math\">\\(x_i\\)</span> is the score for example <span class=\"math\">\\(i\\)</span> and <span class=\"math\">\\(n_i \\in \\{0,1\\}\\)</span> is its conversion&nbsp;indicator.</p>\n<p>There are a number of standard methods for estimating rate functions. For example, if the score <span class=\"math\">\\(x\\)</span> is a prior estimate for the conversion rate, a trivial mapping <span class=\"math\">\\(p(x) = x\\)</span> may work. This won&#8217;t work if the score function in question is not an estimate for <span class=\"math\">\\(p\\)</span>. A more general approach is to bin together example data points that have similar scores: The observed conversion rate within each bin can then be used as an estimate for the true conversion rate in the bin&#8217;s score range. An example output of this approach is shown in Fig. 1. Another option is to create a moving average, analogous to the binned&nbsp;solution.</p>\n<p>The simple binning approach introduces two inefficiencies: (1) Binning coarsens a data set, resulting in a loss of information. (2) The data in one bin does not affect the data in the other bins, precluding exploitation of any global smoothness constraints that could be placed on <span class=\"math\">\\(p\\)</span> as a function of <span class=\"math\">\\(x\\)</span>. The running average approach is also subject to these issues. The method we discuss below alleviates both&nbsp;inefficiencies.</p>\n<p><a href=\"https://efavdb.com/wp-content/uploads/2018/03/image17.png\"><img alt=\"\" src=\"https://efavdb.com/wp-content/uploads/2018/03/image17.png\"></a><br>\nFig. 1. Binned probability estimate approach: All data with scores in a given range are grouped together, and the outcomes from those data points are used to estimate the conversion rate in each bin. Here, the x-axis represents score range, data was grouped into six bins, and mean and standard deviation of the outcome probabilities were estimated from the observed outcomes within each&nbsp;bin.</p>\n<h3>Efficient estimates by&nbsp;integration</h3>\n<p>It can be difficult to directly fit a rate function p(x) using score-outcome data because data of this type does not lie on a continuous curve (the y-values alternate between 0 and 1, depending on the outcome for each example). However, if we consider the empirical integral of the available data, we obtain a smooth, increasing function that is much easier to&nbsp;fit.</p>\n<p>To evaluate the empirical integral, we assume the samples are first sorted by <span class=\"math\">\\(x\\)</span> and define<br>\n</p>\n<div class=\"math\">$$ \\tag{1} \\label{1}  \n\\delta x_i \\equiv x_i - x_{i-1}.  \n$$</div>\n<p><br>\nNext, the empirical integral is taken as<br>\n</p>\n<div class=\"math\">$$ \\tag{2} \\label{2}  \n\\hat{J}(x_j) \\equiv \\sum_{i=0}^{j} n_i \\delta x_i,  \n$$</div>\n<p><br>\nwhich approximates the integral<br>\n</p>\n<div class=\"math\">$$\\tag{3} \\label{3}  \nJ(x) \\equiv \\int_{x_0}^{x_j} p(x) dx.  \n$$</div>\n<p><br>\nWe can think of (\\ref{3}) as the number of expected conversions given density-<span class=\"math\">\\(1\\)</span> sampling over the <span class=\"math\">\\(x\\)</span> range noted. Taking a fit to the <span class=\"math\">\\(\\{(x_i, \\hat{J}(x_i))\\}\\)</span> values gives a smooth estimate for (\\ref{3}). Differentiating with respect to <span class=\"math\">\\(x\\)</span> the gives an estimate for <span class=\"math\">\\(p(x)\\)</span>. Fig. 2 illustrates the approach. Here, I fit the available data to a quadratic, capturing the growth in <span class=\"math\">\\(p\\)</span> with <span class=\"math\">\\(x\\)</span>.</p>\n<p>The example in Fig. 2 has no error bar shown. One way to obtain error bars would be to work with a particular fit form. The uncertainty in the fit coefficients could then be used to estimate uncertainties in the values at each&nbsp;point.</p>\n<p><a href=\"https://efavdb.com/wp-content/uploads/2018/03/image16-1.png\"><img alt=\"image16\" src=\"https://efavdb.com/wp-content/uploads/2018/03/image16-1.png\"></a></p>\n<p>Fig. 2. (Left) A plot of the empirical integral of the data used to generate Fig. 1 is in blue. A quadratic fit is shown in red. (Right) The derivative of the red fit function at left is shown, an estimate for the rate function in question, <span class=\"math\">\\(p\\equiv p(x)\\)</span>.</p>\n<h3>Example python&nbsp;code</h3>\n<p>The code snippet below carries out the procedure described above on a simple example. One example output is shown in Fig. 3 at the bottom of the section. Running the code multiple times gives one a sense of the error that is present in the predictions. In practical applications, this can&#8217;t be done so carrying out the error analysis procedure suggested above should be done to get a better sense of the error&nbsp;involved.</p>\n<div class=\"highlight\"><pre><span></span><span class=\"o\">%</span><span class=\"n\">pylab</span> <span class=\"n\">inline</span>  \n<span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>  \n<span class=\"kn\">from</span> <span class=\"nn\">scipy.optimize</span> <span class=\"kn\">import</span> <span class=\"n\">curve_fit</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">p_given_x</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span>  \n    <span class=\"k\">return</span> <span class=\"n\">x</span> <span class=\"o\">**</span> <span class=\"mi\">2</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">outcome_given_p</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">):</span>  \n    <span class=\"k\">return</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">binomial</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Generate some random data  </span>\n<span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sort</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">rand</span><span class=\"p\">(</span><span class=\"mi\">200</span><span class=\"p\">))</span>  \n<span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">p_given_x</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>  \n<span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">outcome_given_p</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Calculate delta x, get weighted outcomes  </span>\n<span class=\"n\">delta_x</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">:]</span> <span class=\"o\">-</span> <span class=\"n\">x</span><span class=\"p\">[:</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span>  \n<span class=\"n\">weighted_y</span> <span class=\"o\">=</span> <span class=\"n\">y</span><span class=\"p\">[:</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"n\">delta_x</span>\n\n<span class=\"c1\"># Integrate and fit  </span>\n<span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">cumsum</span><span class=\"p\">(</span><span class=\"n\">weighted_y</span><span class=\"p\">)</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">fit_func</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">,</span> <span class=\"n\">d</span><span class=\"p\">):</span>  \n    <span class=\"k\">return</span> <span class=\"n\">a</span> <span class=\"o\">*</span> <span class=\"n\">x</span> <span class=\"o\">**</span> <span class=\"mi\">3</span> <span class=\"o\">+</span> <span class=\"n\">b</span> <span class=\"o\">*</span> <span class=\"n\">x</span> <span class=\"o\">**</span> <span class=\"mi\">2</span>\n\n<span class=\"n\">popt</span><span class=\"p\">,</span> <span class=\"n\">pcov</span> <span class=\"o\">=</span> <span class=\"n\">curve_fit</span><span class=\"p\">(</span><span class=\"n\">fit_func</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">[:</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">j</span><span class=\"p\">)</span>  \n<span class=\"n\">j_fit</span> <span class=\"o\">=</span> <span class=\"n\">fit_func</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">[:</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"o\">*</span><span class=\"n\">popt</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Finally, differentiate and compare to actual p  </span>\n<span class=\"n\">p_fit</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">j_fit</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">:]</span> <span class=\"o\">-</span> <span class=\"n\">j_fit</span><span class=\"p\">[:</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">])</span> <span class=\"o\">/</span> <span class=\"n\">delta_x</span><span class=\"p\">[:</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n\n<span class=\"c1\"># Plots  </span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">figure</span><span class=\"p\">(</span><span class=\"n\">figsize</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">))</span>  \n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">subplot</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>  \n<span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">[:</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">j</span><span class=\"p\">,</span><span class=\"s1\">&#39;*&#39;</span><span class=\"p\">,</span> <span class=\"n\">label</span><span class=\"o\">=</span><span class=\"s1\">&#39;empirical integral&#39;</span><span class=\"p\">)</span>  \n<span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">[:</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">j_fit</span><span class=\"p\">,</span> <span class=\"s1\">&#39;r&#39;</span><span class=\"p\">,</span> <span class=\"n\">label</span><span class=\"o\">=</span><span class=\"s1\">&#39;fit to integral&#39;</span><span class=\"p\">)</span>  \n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">legend</span><span class=\"p\">()</span>\n\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">subplot</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)</span>  \n<span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">[:</span><span class=\"o\">-</span><span class=\"mi\">2</span><span class=\"p\">],</span> <span class=\"n\">p_fit</span><span class=\"p\">,</span> <span class=\"s1\">&#39;g&#39;</span><span class=\"p\">,</span> <span class=\"n\">label</span><span class=\"o\">=</span><span class=\"s1\">&#39;fit to p versus x&#39;</span><span class=\"p\">)</span>  \n<span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"s1\">&#39;k--&#39;</span><span class=\"p\">,</span> <span class=\"n\">label</span><span class=\"o\">=</span><span class=\"s1\">&#39;actual p versus x&#39;</span><span class=\"p\">)</span>  \n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">legend</span><span class=\"p\">()</span>  \n</pre></div>\n\n\n<p><a href=\"https://efavdb.com/wp-content/uploads/2018/03/example_fit.png\"><img alt=\"example_fit\" src=\"https://efavdb.com/wp-content/uploads/2018/03/example_fit.png\"></a></p>\n<p>Fig. 3. The result of one run of the algorithm on a data set where <span class=\"math\">\\(p(x) \\equiv x^2\\)</span>, given 200 random samples of <span class=\"math\">\\(x \\in (0, 1)\\)</span>.</p>\n<script type=\"text/javascript\">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {\n    var align = \"center\",\n        indent = \"0em\",\n        linebreak = \"false\";\n\n    if (false) {\n        align = (screen.width < 768) ? \"left\" : align;\n        indent = (screen.width < 768) ? \"0em\" : indent;\n        linebreak = (screen.width < 768) ? 'true' : linebreak;\n    }\n\n    var mathjaxscript = document.createElement('script');\n    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';\n    mathjaxscript.type = 'text/javascript';\n    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';\n\n    var configscript = document.createElement('script');\n    configscript.type = 'text/x-mathjax-config';\n    configscript[(window.opera ? \"innerHTML\" : \"text\")] =\n        \"MathJax.Hub.Config({\" +\n        \"    config: ['MMLorHTML.js'],\" +\n        \"    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } },\" +\n        \"    jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" +\n        \"    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" +\n        \"    displayAlign: '\"+ align +\"',\" +\n        \"    displayIndent: '\"+ indent +\"',\" +\n        \"    showMathMenu: true,\" +\n        \"    messageStyle: 'normal',\" +\n        \"    tex2jax: { \" +\n        \"        inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" +\n        \"        displayMath: [ ['$$','$$'] ],\" +\n        \"        processEscapes: true,\" +\n        \"        preview: 'TeX',\" +\n        \"    }, \" +\n        \"    'HTML-CSS': { \" +\n        \"        availableFonts: ['STIX', 'TeX'],\" +\n        \"        preferredFont: 'STIX',\" +\n        \"        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" +\n        \"        linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" +\n        \"    }, \" +\n        \"}); \" +\n        \"if ('default' !== 'default') {\" +\n            \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" +\n                \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" +\n                \"VARIANT['normal'].fonts.unshift('MathJax_default');\" +\n                \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" +\n                \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" +\n                \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" +\n            \"});\" +\n            \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" +\n                \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" +\n                \"VARIANT['normal'].fonts.unshift('MathJax_default');\" +\n                \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" +\n                \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" +\n                \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" +\n            \"});\" +\n        \"}\";\n\n    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);\n    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);\n}\n</script>",
  "category": ""
}