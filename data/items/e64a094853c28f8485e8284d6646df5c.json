{
  "title": "Beware the bandwidth gap - speeding up optimization",
  "description": "<p>Disks are slow and RAM is fast. Everyone knows that. But many optimization algorithms don&rsquo;t take advantage of this. More to the point, disks currently stream at about 100-200 MB/s, solid state drives stream at over 500 MB/s with 1000x lower latency than disks, and main memory reigns supreme at about <a href=\"http://www.techspot.com/review/679-intel-haswell-core-i7-4770k/page7.html\">10-100 GB/s bandwidth</a> (depending on how many memory banks you have). This means that it is 100 times more expensive to retrieve instances from disk rather than recycling them once they&rsquo;re already in memory. CPU caches are faster yet with 100-1000 GB/s of bandwidth. Everyone knows this. If not, read <a href=\"http://static.googleusercontent.com/media/research.google.com/en/us/people/jeff/stanford-295-talk.pdf\" title=\"Jeff Dean's slides\" target=\"_blank\">Jeff Dean&rsquo;s slides</a>. Page 13 is pure gold.</p>\n<p>Ok, so what does this mean for machine learning? If you can keep things in memory, you can do things way faster. This is the main idea behind <a href=\"http://spark.apache.org/\">Spark</a>. It&rsquo;s a wonderful alternative to Hadoop. In other words, if your data fits into memory, you&rsquo;re safe and you can process data way faster. A lot of datasets that are considered big in <em>academia</em> fit this bill. But what about <em>real</em> big data? Essentially you have two options - have the systems designer do the hard work or change your algorithm. This post is about the latter. And yes, there&rsquo;s a good case to be made about who should do the work: the machine learners or the folks designing the computational infrastructure (I think it&rsquo;s both).</p>\n<p>So here&rsquo;s the problem: Many online algorithms load data from disk, stream it through memory as efficiently as possible and <em>discard</em> it after seeing it once, only to pick it up later for another pass through the data. That is, these algorithms are <strong>disk bound</strong> rather than CPU bound. Several solvers try to address this by making the disk representation more efficient, e.g. <a href=\"http://www.csie.ntu.edu.tw/~cjlin/liblinear/\">Liblinear</a> or <a href=\"http://hunch.net/~vw/\">VowpalWabbit</a>, both of which user their own internal representation for efficiency. While this still makes for quite efficient code that can process up to 3TB of data per hour in any given pass, main memory is still much faster. This has led to the misconception that many machine learning algorithms are disk bound. But, they aren&rsquo;t &hellip;</p>\n<p>What if we could re-use data that&rsquo;s in memory? For instance, use a ringbuffer where the disk writes into it (much more slowly) and the CPU reads from it (100 times more rapidly). The problem is what to do with an observation that we&rsquo;ve already processed. A naive strategy would be to pretend that it is a new instance, i.e. we could simply update on it more than once. But this is very messy since we need to keep track of how many times we&rsquo;ve seen the instance before, and it creates nonstationarity in the training set. </p>\n<p>A much cleaner strategy is to switch to dual variables, similar to the updates in the Dualon of <a href=\"http://ttic.uchicago.edu/~shai/papers/ShalevSi06_dualon.pdf\">Shalev-Shwartz and Singer</a>. This is what Shin Matsushima did in our <a href=\"http://www.r.dl.itc.u-tokyo.ac.jp/~masin/Appendix.pdf\">dual cached loops</a> paper. Have a look at <a href=\"http://www.r.dl.itc.u-tokyo.ac.jp/~masin/streamsvm.html\">StreamSVM</a> here. Essentially, it keeps data in memory in a ringbuffer and updates the dual variables. This way, we&rsquo;re guaranteed to make progress at each step, even if we&rsquo;re revisiting the same observation more than once. To see what happens have a look at the graph below:</p>\n<p><figure class=\"tmblr-full\" data-orig-height=\"375\" data-orig-width=\"500\" data-orig-src=\"https://64.media.tumblr.com/cd836818f63461ae9ca5c6a45db40de4/tumblr_inline_n45cuvT4Me1qasu5b.png\"><img src=\"https://64.media.tumblr.com/07a6f9904f4c200cd500729c5ad89619/tumblr_inline_parls8xRLn1qasu5b_540.png\" data-orig-height=\"375\" data-orig-width=\"500\" data-orig-src=\"https://64.media.tumblr.com/cd836818f63461ae9ca5c6a45db40de4/tumblr_inline_n45cuvT4Me1qasu5b.png\"/></figure></p>\n\n<p>It&rsquo;s just as fast as LibLinear provided that it&rsquo;s all in memory. Algorithmically, what happens in the SVM case is that one updates the Lagrange multipliers \\(\\alpha_i\\), while simultaneously keeping an estimate of the parameter vector \\(w\\) available.</p>\n<p>That said, this strategy is more general: reuse data several times for optimization while it is in memory. If possible, perform successive updates by changing variables of an optimization that is well-defined regardless of the order in which (and how frequently) data is seen.</p>",
  "link": "https://blog.smola.org/post/82937674537",
  "guid": "https://blog.smola.org/post/82937674537",
  "pubDate": "Wed, 16 Apr 2014 16:22:58 -0700"
}