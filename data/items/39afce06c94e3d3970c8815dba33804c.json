{
  "title": "Implementing a toy version of TLS 1.3",
  "link": "",
  "updated": "2022-03-23T12:25:30+00:00",
  "id": "https://jvns.ca/blog/2022/03/23/a-toy-version-of-tls/",
  "content": "\n\n<p>Hello! Recently I&rsquo;ve been thinking about how I find it fun to learn computer\nnetworking by implementing working versions of real network protocols.</p>\n\n<p>And it made me wonder &ndash; I&rsquo;ve implemented toy versions of\n<a href=\"https://jvns.ca/blog/2013/10/31/day-20-scapy-and-traceroute/\">traceroute</a>, <a href=\"https://jvns.ca/blog/2014/08/12/what-happens-if-you-write-a-tcp-stack-in-python/\">TCP</a> and <a href=\"https://jvns.ca/blog/2022/02/01/a-dns-resolver-in-80-lines-of-go/\">DNS</a>.\nWhat about TLS? Could I implement a toy version of that to learn more about how it works?</p>\n\n<p>I asked on Twitter if this would be hard, got <a href=\"https://twitter.com/Lukasaoz/status/1505593360521777157\">some encouragement and pointers for where to start</a>, so I decided to go for it.</p>\n\n<p>This was really fun and I learned a little more about how involved real\ncryptography is &ndash; thanks to <a href=\"https://cryptopals.com/\">cryptopals</a>, I already 100% believed that I should not invent my own\ncrypto implementations, and seeing how the crypto in TLS 1.3 works gave me even more of\nan appreciation for why I shouldn&rsquo;t :)</p>\n\n<p>As a warning: I am really not a cryptography person, I will probably say some\nincorrect things about cryptography in this post and I absolutely do not know\nthe history of past TLS vulnerabilities that informed TLS 1.3&rsquo;s design.</p>\n\n<p>All of that said, let&rsquo;s go implement some cryptography! All of my hacky code is <a href=\"https://github.com/jvns/tiny-tls/\">on github</a>. I decided to use Go because I heard that Go has good crypto libraries.</p>\n\n<h3 id=\"the-simplifications\">the simplifications</h3>\n\n<p>I only wanted to work on this for a few days at most, so I needed to make some\npretty dramatic simplifications to make it possible to get it done quickly.</p>\n\n<p>I decided my goal was going to be to download this blog&rsquo;s homepage with TLS. So I\ndon&rsquo;t need to implement a fully general TLS implementation, I just need to\nsuccessfully connect to one website.</p>\n\n<p>Specifically, this means that:</p>\n\n<ul>\n<li>I only support one cipher suite</li>\n<li>I don&rsquo;t verify the server&rsquo;s certificate at all, I just ignore it</li>\n<li>my parsing and message formatting can be extremely janky and fragile because I only need to be able to talk to one specific TLS implementation (and believe me, they are)</li>\n</ul>\n\n<h3 id=\"an-amazing-tls-resource-tls13-ulfheim-net\">an amazing TLS resource: tls13.ulfheim.net</h3>\n\n<p>Luckily, before starting this I remembered vaguely that I&rsquo;d seen a website that\nexplained every single byte in a TLS 1.3 connection, with detailed code examples to\nreproduce every part. Some googling revealed that it was <a href=\"https://tls13.ulfheim.net\">The New Illustrated TLS Connection</a>.</p>\n\n<p>I can&rsquo;t stress enough how helpful this was, I looked at probably more than a\nhundred times and I only looked at the TLS 1.3 RFC for a few small things.</p>\n\n<h3 id=\"some-cryptography-basics\">some cryptography basics</h3>\n\n<p>Before I started working on this, my understanding of TLS was:</p>\n\n<ol>\n<li>at the beginning there&rsquo;s some sort of Diffie-Hellman key exchange</li>\n<li>you use the key exchange to somehow (how???) get an AES symmetric key and encrypt the rest of the connection with AES</li>\n</ol>\n\n<p>This was sort of right, but it turns out it&rsquo;s more complicated than that.</p>\n\n<p>Okay, let&rsquo;s get into my hacky toy TLS implementation. It hopefully goes without saying that you should absolutely not use this code for anything.</p>\n\n<h3 id=\"step-1-say-hello\">step 1: say hello</h3>\n\n<p>First we need to send a &ldquo;Client Hello&rdquo; message. For my purposes this has just 4 pieces of information in it:</p>\n\n<ol>\n<li>A randomly generated public key</li>\n<li>32 bytes of random data (the &ldquo;Client Random&rdquo;)</li>\n<li>The domain name I want to connect to (<code>jvns.ca</code>)</li>\n<li>The cipher suites/signature algorithms we want to use (which I just copied\nfrom tls.ulfheim.net). This negotiation process is pretty important in\ngeneral but I&rsquo;m ignoring it because I only support one signature algorithm /\ncipher suite.</li>\n</ol>\n\n<p>The most interesting part of this to me was part 1 &ndash; how do I generate the public key?</p>\n\n<p>I was confused about this for a while but it ended up being just 2 lines of code.</p>\n\n<pre><code>privateKey := random(32)\npublicKey, err := curve25519.X25519(privateKey, curve25519.Basepoint)\n</code></pre>\n\n<p>You can see the rest of the code to generate the <a href=\"https://github.com/jvns/tiny-tls/blob/cb5a3665c3487ad1f1d5f917ad069c93dd44967e/format.go#L41\">client hello message here</a>\nbut it&rsquo;s very boring, it&rsquo;s just a lot of bit fiddling.</p>\n\n<h3 id=\"elliptic-curve-cryptography-is-cool\">elliptic curve cryptography is cool</h3>\n\n<p>I am not going to give an explanation of elliptic curve cryptography here,  but I just want to say how point out how cool it is that you can:</p>\n\n<ul>\n<li>generate a random 32-byte string as a private key</li>\n<li>&ldquo;multiply&rdquo; the private key by the curve&rsquo;s base point to get the public key (this is elliptic curve &ldquo;multiplication&rdquo;, where <code>n * P</code> means &ldquo;add P to itself n times&rdquo;)</li>\n<li>that&rsquo;s it!!</li>\n</ul>\n\n<p>I wrote &ldquo;multiply&rdquo; in scare quotes because this &ldquo;multiplication&rdquo; doesn&rsquo;t let you\nmultiply points on the elliptic curve by <em>each other</em>. You can only multiply a\npoint by an integer.</p>\n\n<p>Here&rsquo;s the function signature  of the <code>X25519</code> function we use to do the\n&ldquo;multiplication&rdquo;. You can see one of the arguments is called <code>scalar</code> and one\nis called <code>point</code>. And the order of the arguments matters! If you switch them it\nwon&rsquo;t do the right thing.</p>\n\n<pre><code>func X25519(scalar, point []byte) ([]byte, error)\n</code></pre>\n\n<p>I am not going to say more about elliptic curve cryptography here but I love how\nsimple this is to use &ndash; it seems a lot straightforward than RSA where your\nprivate keys have to be prime numbers.</p>\n\n<p>I don&rsquo;t know if &ldquo;you can use any 32-byte string as a private key&rdquo; is true\nfor all elliptic curves or just for this specific elliptic curve (<a href=\"https://en.wikipedia.org/wiki/Curve25519\">Curve25519</a>).</p>\n\n<h3 id=\"step-2-parse-the-server-hello\">step 2: parse the server hello</h3>\n\n<p>Next the server says hello. This is very boring, basically we just need to\nparse it to get the server&rsquo;s public key which is 32 bytes. <a href=\"https://github.com/jvns/tiny-tls/blob/cb5a3665c3487ad1f1d5f917ad069c93dd44967e/format.go#L98-L131\">Here&rsquo;s the code though</a>.</p>\n\n<h3 id=\"step-3-calculate-the-keys-to-encrypt-the-handshake\">step 3: calculate the keys to encrypt the handshake</h3>\n\n<p>Now that we have the server&rsquo;s public key and we&rsquo;ve sent the server our public\nkey, we can start to calculate the keys we&rsquo;re going to use to actually encrypt\ndata.</p>\n\n<p>I was surprised to learn that there are at least 4 different symmetric keys involved in TLS:</p>\n\n<ul>\n<li>client handshake key/iv (for the data the client sends in the handshake)</li>\n<li>server handshake key/iv (for the data the server sends in the handshaek)</li>\n<li>client application key/iv (for the rest of the data the client sends)</li>\n<li>server application key/iv (for the rest of the data the server sends)</li>\n<li>I think also another key for session resumption, but I didn&rsquo;t implement that</li>\n</ul>\n\n<p>We start out by combining the server&rsquo;s public key and our private key to get a\nshared secret. This is called &ldquo;elliptic curve diffie hellman&rdquo; or ECDH and it&rsquo;s\npretty simple: &ldquo;multiply&rdquo; the server&rsquo;s private key by our public key:</p>\n\n<pre><code>sharedSecret, err := curve25519.X25519(session.Keys.Private, session.ServerHello.PublicKey)\n</code></pre>\n\n<p>This gives us a 32-byte secret key that both the client and the server has. Yay!</p>\n\n<p>But we need 96 bytes (16 + 12) * 4 of keys in total. That&rsquo;s more than 32 bytes!</p>\n\n<h3 id=\"time-for-key-derivation\">time for key derivation</h3>\n\n<p>Apparently the way you turn a small key into more keys is called &ldquo;key\nderivation&rdquo;, and TLS 1.3 uses an algorithm called &ldquo;HKDF&rdquo; to do this. I honestly do not\nunderstand this but here is what my code to do it looks like.</p>\n\n<p>It seems to involve alternately calling <code>hkdf.Expand</code> and <code>hkdf.Extract</code> over and\nover again a bunch of times.</p>\n\n<pre><code>func (session *Session) MakeHandshakeKeys() {\n\tzeros := make([]byte, 32)\n\tpsk := make([]byte, 32)\n\t// ok so far\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tearlySecret := hkdf.Extract(sha256.New, psk, zeros) // TODO: psk might be wrong\n\tderivedSecret := deriveSecret(earlySecret, \"derived\", []byte{})\n\tsession.Keys.HandshakeSecret = hkdf.Extract(sha256.New, sharedSecret, derivedSecret)\n\thandshakeMessages := concatenate(session.Messages.ClientHello.Contents(), session.Messages.ServerHello.Contents())\n\n\tcHsSecret := deriveSecret(session.Keys.HandshakeSecret, \"c hs traffic\", handshakeMessages)\n\tsession.Keys.ClientHandshakeSecret = cHsSecret\n\tsession.Keys.ClientHandshakeKey = hkdfExpandLabel(cHsSecret, \"key\", []byte{}, 16)\n\tsession.Keys.ClientHandshakeIV = hkdfExpandLabel(cHsSecret, \"iv\", []byte{}, 12)\n\n\tsHsSecret := deriveSecret(session.Keys.HandshakeSecret, \"s hs traffic\", handshakeMessages)\n\tsession.Keys.ServerHandshakeKey = hkdfExpandLabel(sHsSecret, \"key\", []byte{}, 16)\n\tsession.Keys.ServerHandshakeIV = hkdfExpandLabel(sHsSecret, \"iv\", []byte{}, 12)\n}\n</code></pre>\n\n<p>This was pretty annoying to get working because I kept passing the wrong\narguments to things. The only reason I managed it was because\n<a href=\"https://tls13.ulfheim.net\">https://tls13.ulfheim.net</a> provided a bunch of example inputs and outputs and\nexample code so I was able to write some unit tests and check my code against\nthe site&rsquo;s example implementation.</p>\n\n<p>Anyway, eventually I got all my keys calculated and it was time to start decrypting!</p>\n\n<h3 id=\"an-aside-on-ivs\">an aside on IVs</h3>\n\n<p>For each key there&rsquo;s also an &ldquo;IV&rdquo; which stands for &ldquo;initialization vector&rdquo;. The\nidea seems to be to use a different initialization vector for every message we\nencrypt/decrypt, for More Security &trade;.</p>\n\n<p>In this implementation the way we get a different IV for each message is by\nxoring the IV with the number of messages sent/received so far.</p>\n\n<h3 id=\"step-4-write-some-decryption-code\">step 4: write some decryption code</h3>\n\n<p>Now that we have all these keys and IVs, we can write a <code>decrypt</code> function.</p>\n\n<p>I thought that TLS just used AES, but apparently it uses something called\n&ldquo;authentication encryption&rdquo; on top of AES that I hadn&rsquo;t heard of before.</p>\n\n<p>The wikipedia article explanation of authenticated encryption is actually pretty clear:</p>\n\n<blockquote>\n<p>&hellip; authenticated encryption can provide security against <strong>chosen ciphertext</strong> attack. In these attacks, an adversary attempts to gain an advantage against a cryptosystem (e.g., information about the secret decryption key) by submitting carefully chosen ciphertexts to some &ldquo;decryption oracle&rdquo; and analyzing the decrypted results. Authenticated encryption schemes can recognize improperly-constructed ciphertexts and refuse to decrypt them. This, in turn, prevents the attacker from requesting the decryption of any ciphertext unless it was generated correctly using the encryption algorithm</p>\n</blockquote>\n\n<p>This makes sense to me because I did some of the cryptopals challenges and there&rsquo;s an attack a bit like this in <a href=\"https://cryptopals.com/sets/2/challenges/14\">cryptopals set 2</a> (I don&rsquo;t know if it&rsquo;s the exact same thing).</p>\n\n<p>Anyway, here&rsquo;s some code that uses authenticated encryption the way the TLS 1.3\nspec says it should. I think GCM is an authenticated encryption algorithm.</p>\n\n<pre><code>func decrypt(key, iv, wrapper []byte) []byte {\n\n\tblock, err := aes.NewCipher(key)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\n\taesgcm, err := cipher.NewGCM(block)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\n\tadditional := wrapper[:5]\n\tciphertext := wrapper[5:]\n\n\tplaintext, err := aesgcm.Open(nil, iv, ciphertext, additional)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn plaintext\n}\n</code></pre>\n\n<h3 id=\"step-5-decrypt-the-server-handshake\">step 5: decrypt the server handshake</h3>\n\n<p>Next the server sends some more handshake data. This contains the certificate\nand some other stuff.</p>\n\n<p>Here&rsquo;s my code for decrypting the handshake. Basically it just reads the\nencrypted data from the network, decrypts it, and saves it.</p>\n\n<pre><code>record := readRecord(session.Conn)\nif record.Type() != 0x17 {\n    panic(\"expected wrapper\")\n}\nsession.Messages.ServerHandshake = decrypt(session.Keys.ServerHandshakeKey, session.Keys.ServerHandshakeIV, record)\n</code></pre>\n\n<p>You might notice that we don&rsquo;t actually <em>parse</em> this data at all &ndash; that&rsquo;s\nbecause we don&rsquo;t need the contents, since we&rsquo;re not verifying the server&rsquo;s\ncertificate.</p>\n\n<p>I was surprised that you don&rsquo;t technically need to look at the server&rsquo;s\ncertificate at all to make a TLS connection (though obviously you should verify it!). I thought you would need to at least parse it to get a\nkey out of it or something.</p>\n\n<p>We do need to be able to hash the handshake for the next step though, so we\nhave to store it.</p>\n\n<h3 id=\"step-6-derive-more-keys\">step 6: derive more keys</h3>\n\n<p>We use a hash of the SHA256 handshake data we just got from the server to\ngenerate even more symmetric keys. This is almost the last step!</p>\n\n<p>This is almost exactly the same as the key derivation code from before, but I&rsquo;m\nincluding it because I was surprised by how much work needed to be done to generate all these keys.</p>\n\n<pre><code>func (session *Session) MakeApplicationKeys() {\n    handshakeMessages := concatenate(\n        session.Messages.ClientHello.Contents(),\n        session.Messages.ServerHello.Contents(),\n        session.Messages.ServerHandshake.Contents())\n\n    zeros := make([]byte, 32)\n    derivedSecret := deriveSecret(session.Keys.HandshakeSecret, \"derived\", []byte{})\n    masterSecret := hkdf.Extract(sha256.New, zeros, derivedSecret)\n\n    cApSecret := deriveSecret(masterSecret, \"c ap traffic\", handshakeMessages)\n    session.Keys.ClientApplicationKey = hkdfExpandLabel(cApSecret, \"key\", []byte{}, 16)\n    session.Keys.ClientApplicationIV = hkdfExpandLabel(cApSecret, \"iv\", []byte{}, 12)\n\n    sApSecret := deriveSecret(masterSecret, \"s ap traffic\", handshakeMessages)\n    session.Keys.ServerApplicationKey = hkdfExpandLabel(sApSecret, \"key\", []byte{}, 16)\n    session.Keys.ServerApplicationIV = hkdfExpandLabel(sApSecret, \"iv\", []byte{}, 12)\n}\n</code></pre>\n\n<h3 id=\"step-7-finish-the-handshake\">step 7: finish the handshake</h3>\n\n<p>Next we need to send a &ldquo;handshake finished&rdquo; message to the server to verify that everything is done. That code is <a href=\"https://github.com/jvns/tiny-tls/blob/cb5a3665c3487ad1f1d5f917ad069c93dd44967e/crypto.go#L177-L183\">here</a>.</p>\n\n<p>And now we&rsquo;re done the handshake! That was the hard part, sending and receiving\nthe data is relatively easy.</p>\n\n<h3 id=\"step-8-make-a-http-request\">step 8: make a HTTP request</h3>\n\n<p>I wrote a <code>SendData</code> function that encrypts and sends data using our keys. This time we&rsquo;re using the &ldquo;application&rdquo; keys and not the handshake keys. This made making a HTTP request pretty simple:</p>\n\n<pre><code>req := fmt.Sprintf(\"GET / HTTP/1.1\\r\\nHost: %s\\r\\n\\r\\n\", domain)\nsession.SendData([]byte(req))\n</code></pre>\n\n<h3 id=\"step-9-we-can-actually-decrypt-the-response\">step 9: we can actually decrypt the response!!!</h3>\n\n<p>Now comes the moment I&rsquo;d been waiting for &mdash; actually decrypting the response\nfrom the server!!! But here I needed to learn something else about TLS.</p>\n\n<h3 id=\"tls-data-comes-in-blocks\">TLS data comes in blocks</h3>\n\n<p>I previously thought that once you established the connection, encrypted TLS\ndata was just a stream. But that&rsquo;s not how it works &ndash; instead, it&rsquo;s\ntransmitted in blocks. Like, you&rsquo;ll get a chunk of ~1400 bytes to decrypt, and\nthen another chunk, and then another chunk.</p>\n\n<p>I&rsquo;m not sure why the blocks have the size they do (maybe it&rsquo;s so that each one will fit inside a TCP\npacket ???), but in theory I think they could be up to 65535 bytes, since their\nsize field is 2 bytes. The blocks I got were all 1386 bytes each.</p>\n\n<p>Every time we get a block, we have to:</p>\n\n<ul>\n<li>calculate a new IV as <code>old_iv xor num_records_received</code></li>\n<li>decrypt it using the key and the new IV</li>\n<li>increment the count of records received</li>\n</ul>\n\n<p>Here&rsquo;s what the <code>ReceiveData()</code> function I wrote looks like.</p>\n\n<p>The most interesting part of this is the <code>iv[11] ^= session.RecordsReceived</code> &ndash;\nthat&rsquo;s the part that adjusts the IV for each block.</p>\n\n<pre><code>func (session *Session) ReceiveData() []byte {\n\trecord := readRecord(session.Conn)\n\tiv := make([]byte, 12)\n\tcopy(iv, session.Keys.ServerApplicationIV)\n\tiv[11] ^= session.RecordsReceived\n\tplaintext := decrypt(session.Keys.ServerApplicationKey, iv, record)\n\tsession.RecordsReceived += 1\n\treturn plaintext\n}\n</code></pre>\n\n<p>This <code>iv[11]</code> thing assumes that there are less than 255 blocks which obviously\nis not true in general in TLS, but I was lazy and to download my blog&rsquo;s\nhomepage I only needed 82 blocks.</p>\n\n<p>We actually have to do this when we send data too, but I didn&rsquo;t implement it\nbecause we only sent 1 packet.</p>\n\n<h3 id=\"problem-getting-the-whole-block-of-tls-data\">problem: getting the whole block of tLS data</h3>\n\n<p>I ran into one problem with TCP where sometimes I&rsquo;d try to read a block of TLS\ndata (~1386 bytes), but I wouldn&rsquo;t get the whole thing. I guess the TLS blocks\ncan be split up across multiple TCP packets.</p>\n\n<p>I fixed this in a really dumb way, by just polling the TCP connection in a loop\nuntil it gave me the data I wanted. Here&rsquo;s my code to do that:</p>\n\n<pre><code>func read(length int, reader io.Reader) []byte {\n\tvar buf []byte\n\tfor len(buf) != length {\n\t\tbuf = append(buf, readUpto(length-len(buf), reader)...)\n\t}\n\treturn buf\n}\n</code></pre>\n\n<p>I assume a real TLS implementation would use a thread pool or coroutines or\nsomething to manage this.</p>\n\n<h3 id=\"step-10-knowing-when-we-re-done\">step 10: knowing when we&rsquo;re done</h3>\n\n<p>When the HTTP response is done, we get these bytes: <code>[]byte{48, 13, 10, 13, 10, 23}</code>.\nThis seems to be because my HTTP server is using chunked transfer encoding, so\nthere&rsquo;s no <code>Content-Length</code> header and I need to watch for those bytes at the\nend instead.</p>\n\n<p>So here&rsquo;s the code to receive the HTTP response. Basically we just loop until\nwe see those bytes, then we stop.</p>\n\n<pre><code>func (session *Session) ReceiveHTTPResponse() []byte {\n\tvar response []byte\n\tfor {\n\t\tpt := session.ReceiveData()\n\t\tif string(pt) == string([]byte{48, 13, 10, 13, 10, 23}) {\n\t\t\tbreak\n\t\t}\n\t\tresponse = append(response, pt...)\n\t}\n\treturn response\n}\n</code></pre>\n\n<h3 id=\"that-s-it\">that&rsquo;s it!</h3>\n\n<p>Finally, I ran the program and I downloaded my blog&rsquo;s homepage! It worked! Here&rsquo;s what the results look like:</p>\n\n<pre><code>$ go build; ./tiny-tls\nHTTP/1.1 200 OK\nDate: Wed, 23 Mar 2022 19:37:47 GMT\nContent-Type: text/html\nTransfer-Encoding: chunked\nConnection: keep-alive\n... lots more headers and HTML follow...\n</code></pre>\n\n<p>Okay, the results are kind of anticlimactic, it&rsquo;s just the same as what you&rsquo;d\nsee if you ran <code>curl -i https://jvns.ca</code> except with no formatting. But I was\nextremely excited when I saw it.</p>\n\n<h3 id=\"unit-tests-are-great\">unit tests are great</h3>\n\n<p>Every time I write networking code like this, I forget that unit testing is\ngood, and I thrash around with a bunch of parsing / formatting code that does\nnot work and just getting NOPE messages back from the server on the other end.</p>\n\n<p>And then I remember unit tests. In this case, I copied a bunch of the data from\nthe <a href=\"https://tls13.ulfheim.net\">https://tls13.ulfheim.net</a> example and put it into my unit tests so that I\ncould quickly make sure that my parsing and crypto were working correctly.\nIt made everything about 10 times easier and faster.</p>\n\n<h3 id=\"some-things-i-learned\">some things I learned</h3>\n\n<p>This was really fun! I learned that</p>\n\n<ul>\n<li>elliptic curve diffie-hellman is very cool, and at least with Curve25519 you can use literally any 32-byte string as a private key</li>\n<li>there are a LOT of different symmetric keys involved in TLS and the key derivation process is pretty complicated</li>\n<li>TLS uses AES with some extra &ldquo;authenticated encryption&rdquo; algorithms on top</li>\n<li>TLS data is sent/received as a bunch of blocks, not as a stream</li>\n</ul>\n\n<p>My code truly is terrible, it can connect to my site (<code>jvns.ca</code>) and I think literally no other sites.</p>\n\n<p>I won&rsquo;t pretend to understand all the reasons TLS is designed this way, but it\nwas a fun way to spend a couple of days, I feel a little more informed, and I\nthink it&rsquo;ll be easier for me to understand things I read about TLS in the\nfuture.</p>\n\n<h3 id=\"a-plug-for-cryptopals\">a plug for cryptopals</h3>\n\n<p>If you want to learn about cryptography and you haven&rsquo;t tried the\n<a href=\"https://cryptopals.com/\">cryptopals</a> challenges, I really recommend them &ndash; you\nget to implement a lot of attacks on crypto systems and it&rsquo;s very fun.</p>\n"
}