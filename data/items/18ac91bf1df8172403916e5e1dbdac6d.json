{
  "guid": "tag:blogger.com,1999:blog-6300367579216018061.post-5042612268447921974",
  "pubDate": "Wed, 01 Feb 2017 01:59:00 +0000",
  "atom:updated": "2017-01-31T18:03:08.187-08:00",
  "category": [
    "cloud native java",
    "cqrs",
    "event sourcing",
    "event-driven microservices",
    "microservices",
    "serverless",
    "spring boot",
    "spring cloud"
  ],
  "title": "Building Event-driven Microservices Using CQRS and Serverless",
  "description": "<link rel=\"stylesheet\" href=\"https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans:400,700\"><style>.hljs-title, .hljs-id, .scss .hljs-preprocessor {    font-weight: 400 !important; } .hljs-class .hljs-title, .hljs-type, .vhdl .hljs-literal, .tex .hljs-command {    font-weight: 400 !important; } .hljs-keyword, .css .rule .hljs-keyword, .hljs-winutils, .nginx .hljs-title, .hljs-subst, .hljs-request, .hljs-status {    font-weight: 400 !important; } .sect1{padding-bottom:0!important} .sect1+.sect1{border:0!important} .conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:\"Open Sans\",\"DejaVu Sans\",sans-serif;font-style:normal;font-weight:bold} .conum[data-value] *{color:#fff!important} .conum[data-value]+b{display:none} .conum[data-value]:after{content:attr(data-value)} .fa-caret-up {     color: green;     text-shadow: 1px 1px 1px #ccc;     font-size: 1.75em !important; }  .fa-caret-down {     color: red;     text-shadow: 1px 1px 1px #ccc;     font-size: 1.75em !important; }  .fa-minus {     color: #999;     text-shadow: 1px 1px 1px #ccc;     font-size: 1em !important; }  .fa-plus {     font-size: 1em !important;     color: green;     text-shadow: 1px 1px 1px #ccc; }   @media screen and (min-width: 768px) { .table-responsive { font-size: 0.8em; max-width: 50em; } }  @media screen and (max-width: 768px) {     .table-responsive {     font-size: 0.65em; } }  .table-responsive th, .table-responsive tr, .table-responsive td { padding: 4px 4px 4px 4px !important; } p {     margin-bottom: 1.25em !important; line-height: 1.4; } li p { line-height: 1.4 !important; margin: 0 !important; } .blog-post-asciidoc .content img {  max-height: none;  width: 100% !important; } .admonitionblock > table {     background: rgba(0, 0, 0, 0) none repeat scroll 0 0;     border: 0 none;     border-collapse: separate;     width: 100%; } table {     background: #fff none repeat scroll 0 0;     border: 1px solid #dedede;     margin-bottom: 1.25em; } pre .conum[data-value]{position:relative;top:-.125em} b.conum *{color:inherit!important} .conum:not([data-value]):empty{display:none} .hdlist>table,.colist>table{border:0;background:none} .hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none} td.hdlist1{padding-right:.75em;font-weight:bold} td.hdlist1,td.hdlist2{vertical-align:top} .literalblock+.colist,.listingblock+.colist{margin-top:-.5em} .colist>table tr>td:first-of-type{padding:0 .75em;line-height:1} .colist>table tr>td:last-of-type{padding:.25em 0} h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h3,h4,h6{font-family:\"Open Sans\",sans-serif;font-style:normal;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;} .blog-post-asciidoc p{margin-bottom:1.25rem} @media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}.sect1+.sect1{border-top:1px solid #efefed} pre, pre > code {     -moz-osx-font-smoothing: auto;     color: rgba(0, 0, 0, 0.9);     font-family: monospace,monospace;     font-weight: 400;     line-height: 1.45;     text-rendering: optimizelegibility; } .blog-post-asciidoc code,kbd,pre,samp{font-size:.9em;font-weight:400;} .blog-post-asciidoc .admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%} .blog-post-asciidoc .admonitionblock>table td.icon{text-align:center;width:80px} .blog-post-asciidoc .admonitionblock>table td.icon img{max-width:none} .blog-post-asciidoc .admonitionblock>table td.icon .title{font-weight:bold;font-family:\"Open Sans\",\"DejaVu Sans\",sans-serif;text-transform:uppercase} .blog-post-asciidoc .admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)} .blog-post-asciidoc .admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0} .blog-post-asciidoc .admonitionblock td.icon [class^=\"fa icon-\"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default} .blog-post-asciidoc .admonitionblock td.icon .icon-note:before{content:\"\\f05a\";color:#19407c} .blog-post-asciidoc .admonitionblock td.icon .icon-tip:before{content:\"\\f0eb\";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111} .blog-post-asciidoc .admonitionblock td.icon .icon-warning:before{content:\"\\f071\";color:#bf6900} .blog-post-asciidoc .admonitionblock td.icon .icon-caution:before{content:\"\\f06d\";color:#bf3400} .blog-post-asciidoc .admonitionblock td.icon .icon-important:before{content:\"\\f06a\";color:#bf0000} #personDataTable td {     vertical-align: middle; } .rank-col {     text-align: center; } #personDataTable img {     max-width: 35px;     padding: 0; } .table-responsive {     font-weight: 400; } .table > thead > tr > th {     border-bottom: 2px solid #ddd;     font-weight: 400;     padding: 8px !important;     vertical-align: bottom; } .table-responsive {     font-family: Helvetica,sans-serif; } .exampleblock pre {     margin-top: auto; } .exampleblock .content {     margin-top: auto; } blockquote {     border-left: 5px solid #eee;     color: #666;     font-size: 16px;     margin: 0;     padding: 10px 20px; } .attribution {     font-size: small;     text-align: right; } .table-responsive p { margin: 0 !important; } p.tableblock {   font-size: 14px;   margin: 0 !important; } table.tableblock { max-width: 100%; border-collapse: separate; } table.tableblock td > .paragraph:last-child p > p:last-child, table.tableblock th > p:last-child, table.tableblock td > p:last-child { margin-bottom: 0; }  table.tableblock, th.tableblock, td.tableblock { border: 0 solid #dddddd; }  table.grid-all th.tableblock, table.grid-all td.tableblock { border-width: 0 1px 1px 0; }  table.grid-all tfoot > tr > th.tableblock, table.grid-all tfoot > tr > td.tableblock { border-width: 1px 1px 0 0; }  table.grid-cols th.tableblock, table.grid-cols td.tableblock { border-width: 0 1px 0 0; }  table.grid-all * > tr > .tableblock:last-child, table.grid-cols * > tr > .tableblock:last-child { border-right-width: 0; }  table.grid-rows th.tableblock, table.grid-rows td.tableblock { border-width: 0 0 1px 0; }  table.grid-all tbody > tr:last-child > th.tableblock, table.grid-all tbody > tr:last-child > td.tableblock, table.grid-all thead:last-child > tr > th.tableblock, table.grid-rows tbody > tr:last-child > th.tableblock, table.grid-rows tbody > tr:last-child > td.tableblock, table.grid-rows thead:last-child > tr > th.tableblock { border-bottom-width: 0; }  table.grid-rows tfoot > tr > th.tableblock, table.grid-rows tfoot > tr > td.tableblock { border-width: 1px 0 0 0; }  table.frame-all { border-width: 1px; }  table.frame-sides { border-width: 0 1px; }  table.frame-topbot { border-width: 1px 0; }  th.halign-left, td.halign-left { text-align: left; }  th.halign-right, td.halign-right { text-align: right; }  th.halign-center, td.halign-center { text-align: center; }  th.valign-top, td.valign-top { vertical-align: top; }  th.valign-bottom, td.valign-bottom { vertical-align: bottom; }  th.valign-middle, td.valign-middle { vertical-align: middle; }  table thead th, table tfoot th { font-weight: bold; }  tbody tr th { display: table-cell; line-height: 1.4; background: whitesmoke; }  tbody tr th, tbody tr th p, tfoot tr th, tfoot tr th p { color: #222222; font-weight: bold; }  p.tableblock > code:only-child { background: none; padding: 0; }  table tr.even, table tr.alt, table tr:nth-of-type(2n) {     background: #f9f9f9 none repeat scroll 0 0; } div.table-responsive {  border: 0; }  .sql p {  font-family: courier; } </style><link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.2.0/css/font-awesome.min.css\"><div id=\"content\" class=\"blog-post-asciidoc\">         <div class=\"article\">          <div id=\"preamble\"><div class=\"sectionbody\"><div class=\"paragraph\"><p>This blog series will introduce you to building event-driven microservices as cloud-native applications.</p></div><div class=\"paragraph\"><p>In this first post, we’ll explore how to implement the <a href=\"https://martinfowler.com/bliki/CQRS.html\" target=\"_blank\">CQRS</a> pattern in microservices. We’ll also dive into why <a href=\"https://martinfowler.com/articles/serverless.html\" target=\"_blank\">serverless</a> is a natural fit for these kinds of systems. Later in the series we’ll explore a reference application that uses <a href=\"https://cloud.spring.io/spring-cloud-stream/\" target=\"_blank\">Spring Cloud Stream</a> to implement CQRS.</p></div></div></div><div class=\"sect1\"><h2 id=\"_what_is_an_event_driven_architecture\">What is an event-driven architecture?</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p><a href=\"https://en.wikipedia.org/wiki/Event-driven_architecture\" target=\"_blank\">Event-driven architectures</a> treat domain events as first-class citizens. This approach is as old as software itself.</p></div><div class=\"paragraph\"><p>One example we use every day is in front-end applications. In every web browser in use today, events are handled as a way to capture inputs of a user form. Events connected to page elements are handled by an explicitly mapped function, sometimes referred to as an <em>action</em> or <em>command</em>, which will apply state changes to a user interface when triggered.</p></div><div style=\"display: none;\" class=\"imageblock\"><div style=\"text-align: left; margin: auto;\" class=\"content\"><img style=\"margin: auto !important; max-width: 32em;\" src=\"http://imgur.com/kr0O5QZ.png\" alt=\"CQRS microservice architecture\" width=\"100%\"></div></div><div class=\"paragraph\"><p>Now, more recently, with the widespread adoption of <a href=\"https://martinfowler.com/articles/microservices.html\" target=\"_blank\">microservices</a>, there is renewed interest in how to take advantage of event-driven techniques in distributed back-end systems.</p></div></div></div><div class=\"sect1\"><h2 id=\"_cqrs\">CQRS</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p>One of the most popular practices in event-driven architectures today is called CQRS, which is short for <em>Command Query Responsibility Segregation</em>. CQRS is a style of architecture that allows you to use different models to update and read domain data.</p></div><div style=\"display: block;\" class=\"imageblock\"><div style=\"text-align: left; margin: auto;\" class=\"content\"><img style=\"margin: auto !important;  max-width: 28em;\" src=\"http://imgur.com/zdCYjAL.png\" alt=\"CQRS model\" width=\"70%\"></div></div><div class=\"paragraph\"><p>The basic idea of CQRS is that it’s perfectly natural to need to separate the models you’re using to update and read data. The diagram above shows this basic idea.</p></div><a name='more'></a><div class=\"paragraph\"><p>CQRS is popular for event-driven architectures because <a href=\"https://martinfowler.com/eaaDev/DomainEvent.html\" target=\"_blank\">domain events</a> — as inputs — are structurally different than the <a href=\"https://martinfowler.com/eaaCatalog/domainModel.html\" target=\"_blank\">domain model</a> they are subject to. Take for example the following domain model object representing an account.</p></div><div class=\"exampleblock\"><div class=\"title\">Example 1. Account aggregate</div><div class=\"content\"><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlight\"><code class=\"language-json hljs\" data-lang=\"json\">{<br />  <span class=\"hljs-attr\">\"createdAt\"</span>: <span class=\"hljs-number\">1481351048967</span>,<br />  <span class=\"hljs-attr\">\"lastModified\"</span>: <span class=\"hljs-number\">1481351049385</span>,<br />  <span class=\"hljs-attr\">\"userId\"</span>: <span class=\"hljs-number\">1</span>,<br />  <span class=\"hljs-attr\">\"accountNumber\"</span>: <span class=\"hljs-string\">\"123456\"</span>,<br />  <span class=\"hljs-attr\">\"defaultAccount\"</span>: <span class=\"hljs-literal\">true</span>,<br />  <span class=\"hljs-attr\">\"status\"</span>: <span class=\"hljs-string\">\"ACCOUNT_ACTIVE\"</span><br />}</code></pre></div></div></div></div><div class=\"paragraph\"><p>When a service wants to query for an account, this is the model it will expect. Now, what if we wanted to update the status to <code>ACCOUNT_SUSPENDED</code>? Normally this would be a simple update to the domain object for the status field. Now, what if we wanted to use a domain event to update the status instead? Since a domain object is structurally different from an event, we will need an API that accepts a different model as a command.</p></div><div class=\"paragraph\"><p>The following snippet is a domain event that transitions the state of the account from <code>ACCOUNT_ACTIVE</code> to <code>ACCOUNT_SUSPENDED</code>.</p></div><div class=\"exampleblock\"><div class=\"title\">Example 2. Account event</div><div class=\"content\"><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlight\"><code class=\"language-json hljs\" data-lang=\"json\">{<br />  <span class=\"hljs-attr\">\"createdAt\"</span>: <span class=\"hljs-number\">1481353397395</span>,<br />  <span class=\"hljs-attr\">\"lastModified\"</span>: <span class=\"hljs-number\">1481353397395</span>,<br />  <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"ACCOUNT_SUSPENDED\"</span>,<br />  <span class=\"hljs-attr\">\"accountNumber\"</span>: <span class=\"hljs-string\">\"123456\"</span><br />}</code></pre></div></div></div></div><div class=\"paragraph\"><p>To process this domain event and apply the update to the query model, we must have an API to accept the command. The command will contain the model of the domain event and use it to process the update to the account’s query model.</p></div><div style=\"display: block;\" class=\"imageblock\"><div style=\"text-align: left; margin: auto;\" class=\"content\"><img style=\"margin: auto !important;  max-width: 28em;\" src=\"http://imgur.com/QxLXnqe.png\" alt=\"CQRS suspend account\" width=\"70%\"></div></div><div class=\"paragraph\"><p>This is the simplest explanation of CQRS — to separate the command model from the query model. The complexity we often see today is more to do with the flavor of implementation. This is especially true when applying the pattern to microservices.</p></div><div class=\"sect2\"><h3 id=\"_cqrs_and_microservices\">CQRS and Microservices</h3><div class=\"paragraph\"><p>When CQRS combines with microservices, things get a bit complex — to say the least. Let’s take a look at what a \"simple\" microservice resembles that implements CQRS using <a href=\"https://projects.spring.io/spring-boot/\" target=\"_blank\">Spring Boot</a>.</p></div><div style=\"display: block;\" class=\"imageblock\"><div style=\"text-align: left; margin: auto;\" class=\"content\"><img style=\"margin: auto !important; max-width: 32em;\" src=\"http://imgur.com/kr0O5QZ.png\" alt=\"CQRS microservice architecture\" width=\"100%\"></div></div><div class=\"paragraph\"><p>The diagram above is a rough sketch of an implementation of the CQRS pattern.</p></div><div class=\"paragraph\"><p>Here we’ve split up a single microservice into a <em>command-side</em>, <em>query-side</em>, and <em>event processor</em>—all of which can be deployed independently of one another.</p></div></div><div class=\"sect2\"><h3 id=\"_command_side\">Command-side</h3><div class=\"paragraph\"><p>The command-side in this example exposes a REST API that accepts requests over HTTP. Requests take the form of <em>commands</em> that drive state changes to domain data owned by the microservice. To put it simply, any <em>writes</em> on domain data will flow from an API request as a command — which handles an action that results in changes to the database.</p></div><div style=\"display: block;\" class=\"imageblock\"><div style=\"text-align: left; margin: auto;\" class=\"content\"><img style=\"margin: auto !important; max-width: 10em;\" src=\"http://imgur.com/eClf191.png\" alt=\"Command-side CQRS\" width=\"60%\"></div></div><div class=\"paragraph\"><p>Commands trigger actions and actions trigger domain events. The domain events persist to an <a href=\"https://en.wikipedia.org/wiki/Event_store\" target=\"_blank\"><em>event store</em></a>—a fancy way to say \"<em>a system that combines a database together with a message broker</em>.\"</p></div><div class=\"admonitionblock tip\"><table><tbody><tr><td class=\"icon\"><i class=\"fa icon-tip\" title=\"Tip\"></i></td><td class=\"content\">An excellent event store to get started with is called <a href=\"http://eventuate.io/\" target=\"_blank\">Eventuate</a>, which was founded by <a href=\"https://twitter.com/crichardson\" target=\"_blank\">Chris Richardson</a> as a project to help apply CQRS and Event Sourcing to microservices. </td></tr></tbody></table></div><div class=\"paragraph\"><p>Domain events store as a series of time-ordered events appended to a log. Since every command generates an event, we’re able to rebuild the total state of the current system from a history of collected events. I cover this topic in more detail in a previous blog post on <a href=\"http://www.kennybastani.com/2016/04/event-sourcing-microservices-spring-cloud.html\" target=\"_blank\">event sourcing in microservices</a>.</p></div></div><div class=\"sect2\"><h3 id=\"_event_processor\">Event Processor</h3><div class=\"paragraph\"><p>The next component we’ll examine is the <em>Event Processor</em>. This CQRS component takes the form of a worker application that is responsible for ingesting domain events. The event processor is stateless and listens for messages from the <em>event store</em>, applying an action for incoming event messages.</p></div><div style=\"display: block;\" class=\"imageblock\"><div style=\"text-align: left; margin: auto;\" class=\"content\"><img style=\"margin: auto !important; max-width: 22em;\" src=\"http://imgur.com/9dqHdEJ.png\" alt=\"Event processor CQRS\" width=\"60%\"></div></div><div class=\"paragraph\"><p>The event processor can respond to a new domain event in many useful ways. One domain event can spawn more events that can be sent to other microservices. This is why most developers of microservices are attracted to CQRS—as a way to publish and subscribe to domain events originating from applications outside of a bounded context.</p></div><div class=\"paragraph\"><p>This approach provides us with a mechanism to ensure referential integrity of domain data. Messages from other microservices can be used to handle domain events that allow maintenance of pesky foreign key relationships relating domain data from other records in the distributed system.</p></div></div><div class=\"sect2\"><h3 id=\"_query_side\">Query-side</h3><div class=\"paragraph\"><p>The event processor is first and foremost responsible for applying a domain event that changes the state of a <a href=\"https://martinfowler.com/bliki/DDD_Aggregate.html\" target=\"_blank\">domain aggregate</a>.</p></div><div class=\"paragraph\"><p>Each domain event can be used to update a database record that results in an incremental materialized view for describing an aggregate. In turn, the query-side will expose a REST API that allows HTTP clients to <em>read</em> the resulting <a href=\"https://en.wikipedia.org/wiki/Materialized_view\" target=\"_blank\">materialized views</a> that were generated from the processed events.</p></div><div style=\"display: block;\" class=\"imageblock\"><div style=\"text-align: left; margin: auto;\" class=\"content\"><img style=\"margin: auto !important; max-width: 32em;\" src=\"http://i.imgur.com/PztebDr.png\" alt=\"Query-side CQRS\" width=\"60%\"></div></div><div class=\"paragraph\"><p>The constraint in the query-side component is that domain data is <em>read-only</em>. All state changes in this system will flow in from the command-side and result in materialized views that can be read on the query-side.</p></div></div><div class=\"sect2\"><h3 id=\"_distributed_monolith_or_microservice\">Distributed Monolith or Microservice?</h3><div class=\"paragraph\"><p>Now if you’re like me, you might be thinking \"Hold up! That’s no moon…​ it’s a space station.\"</p></div><div class=\"paragraph\"><p>When most people think of a single microservice today, they think of an independent service component. In most cases, a microservice is built as an application that focuses on doing one thing well. Most importantly, the service can be upgraded and deployed independently of other services.</p></div><div class=\"paragraph\"><p>Now when it comes to the conventional CQRS implementation, because of the separate components, there seems to be a slight concern for calling it a microservice. So it’s worth asking: is this CQRS application considered a microservice? Or rather, could it be what some developers have started to refer to as a <a href=\"https://www.infoq.com/news/2016/02/services-distributed-monolith?utm_source=infoq&amp;utm_medium=popular_widget&amp;utm_campaign=popular_content_list&amp;utm_content=homepage\" target=\"_blank\"><em>distributed monolith</em></a>?</p></div><div class=\"paragraph\"><p>The answer is tricky, and it depends on who you’re asking. I find that a microservice is all about empowering small independent teams to continuously deliver features as a part of a larger ecosystem of other microservices.</p></div><div class=\"paragraph\"><p>CQRS deployments are complex when compared to most microservice deployments. For a microservices team, the goal is to be able to continuously deliver features into production. Since the separated components of CQRS can still be independently deployed, then we can say that each unit of deployment still satisfies the minimum requirements for independently delivering features into production. One feature of a microservice should always require—at most—one deployable unit.</p></div><div class=\"paragraph\"><p><em>A distributed monolith happens when a feature is delivered that requires a coordinated deployment of multiple separate components at the same time.</em></p></div></div></div></div><div class=\"sect1\"><h2 id=\"_serverless\">Serverless</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p>Event-driven architectures need not apply only to microservices.</p></div><div class=\"paragraph\"><p>Serverless—which is also referred to as FaaS (Function-as-a-Service)—allows you to deploy code as functions without needing to setup or manage application servers or containers. Serverless is a popular architectural style that is rapidly gaining traction when building and operating cloud-native applications. One notable benefit of using serverless functions is that the concept of events is treated as a first-class citizen.</p></div><div class=\"sect2\"><h3 id=\"_microservices_and_serverless\">Microservices and Serverless</h3><div class=\"paragraph\"><p>A popular misconception of cloud-native applications is that microservices and serverless are largely incompatible, incongruent, or orthogonal styles of architectures.</p></div><div class=\"paragraph\"><p>Let’s consider the CQRS system that we reviewed earlier. The rule of thumb still holds for applications built as serverless functions.</p></div><div class=\"quoteblock\"><blockquote>A distributed monolith happens when a feature is delivered that requires a coordinated deployment of multiple separate components. </blockquote></div><div class=\"paragraph\"><p>The inverse of this rule would imply that a microservice can also be built from a composition of serverless functions. In this scenario, where would one microservice begin and another end?</p></div><div style=\"display: block;\" class=\"imageblock\"><div style=\"text-align: left; margin: auto;\" class=\"content\"><img style=\"margin: auto !important; max-width: 36em;\" src=\"http://imgur.com/feWJqtX.png\" alt=\"Serverless microservice\" width=\"100%\"></div></div><div class=\"paragraph\"><p>One way to look at it is to consider the <em>boundary of the microservice to be the boundary of the team</em>. As long as a team can both independently and continuously deploy features as a function, then the boundary of the microservice is just the subset of functions (or application components) responsible for powering the features owned by the team.</p></div></div></div></div><div class=\"sect1\"><h2 id=\"_trade_offs\">Trade-offs</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p>To understand why you would want to take this approach requires a close examination of the trade-offs.</p></div><div class=\"sect2\"><h3 id=\"_velocity\">Velocity</h3><div class=\"paragraph\"><p>For microservices, the goal is velocity. We can measure velocity by answering the following two questions.</p></div><div class=\"ulist\"><ul><li><p>How fast can a developer make a single line of code change and safely deploy it into production?</p></li><li><p>How fast can a new developer ramp up and safely make changes to a code base?</p></li></ul></div><div class=\"paragraph\"><p>A microservice team measures their velocity by answering the two questions. The lower the average time, the higher the velocity a team will have when delivering features.</p></div><div class=\"paragraph\"><p>Serverless comes with a learning curve, but lends well to increasing velocity in microservices. It does so by moving much of the workflow management out of the core components and into small composable functions that can be independently upgraded and deployed. This minimizes the time it takes for a developer to understand how a single function works and how to safely change it.</p></div><div class=\"paragraph\"><p>Serverless functions are also simple to upgrade and deploy, but may add complexity in understanding the whole picture. Managing hundreds of serverless functions as one team does not sound like much fun.</p></div></div><div class=\"sect2\"><h3 id=\"_complexity\">Complexity</h3><div class=\"paragraph\"><p>Complexity is unavoidable in software. Complexity grows over time as a code base ages. Monolithic applications become unwieldy and hard to change when complexity grows, or when frameworks or languages become out of date or obsolete. Microservices split up this complexity into a distributed system, where each deployable unit is both easy to understand and easy to change by a small agile group of developers.</p></div></div></div></div><div class=\"sect1\"><h2 id=\"_cloud_native_cqrs\">Cloud-native CQRS</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p>This blog post is the first in a series that will introduce you to a <a href=\"https://github.com/kbastani/event-stream-processing-microservices\" target=\"_blank\">reference application</a> for building a cloud-native CQRS application as a collection of event-driven microservices and serverless functions.</p></div><div style=\"display: block;\" class=\"imageblock\"><div style=\"text-align: center; margin: auto;\" class=\"content\"><img style=\"margin: auto !important;  max-width: 100%;\" src=\"https://camo.githubusercontent.com/77e3bbcf38c92533e831c155190901541d56a7ac/687474703a2f2f692e696d6775722e636f6d2f575a5452346c512e706e67\" alt=\"Cloud-native CQRS with serverless\"></div></div><div class=\"paragraph\"><p>In the next blog post, we will dive into an open source sample application that has a similar structure to the diagram shown above. We’ll explore how to implement a variant of CQRS that is composed of multiple independently deployable cloud-native components.</p></div><div class=\"paragraph\"><p>The sample will demonstrate how to build an end-to-end microservice application that is flexible to change and more easily decomposed. We’ll explore using Spring Boot together with <a href=\"https://aws.amazon.com/lambda/\" target=\"_blank\">AWS Lambda</a> to apply the CQRS pattern to a cloud-native application.</p></div></div></div>        </div>               </div>",
  "enclosure": "",
  "link": "https://www.kennybastani.com/2017/01/building-event-driven-microservices.html",
  "author": "noreply@blogger.com (Kenny Bastani)",
  "thr:total": 0
}