{
  "title": "Distributing Data in a Parameterserver",
  "description": "<p>One of the key features of a parameter server is that it, well, serves parameters. In particular, it serves more parameters than a single machine can typically hold and provides more bandwidth than what a single machine offers. </p>\n<p><figure class=\"tmblr-full\" data-orig-height=\"236\" data-orig-width=\"500\" data-orig-src=\"https://64.media.tumblr.com/1e67c6f5a665d5b9a8b2b13f5a7fc9fc/tumblr_inline_n5utdsd7mH1qasu5b.png\"><img alt=\"image\" src=\"https://64.media.tumblr.com/877d7a5676667e313a466eaabe529b23/tumblr_inline_parlsjMHnq1qasu5b_540.png\" data-orig-height=\"236\" data-orig-width=\"500\" data-orig-src=\"https://64.media.tumblr.com/1e67c6f5a665d5b9a8b2b13f5a7fc9fc/tumblr_inline_n5utdsd7mH1qasu5b.png\"/></figure></p>\n\n<p>A sensible strategy to increase both aspects is to arrange data in the form of a bipartite graph with clients on one side and the server machines on the other. This way bandwidth and storage increase linearly with the number of machines involved. This is well understood. For instance, distributed (key,value) stores such as <a href=\"http://memcached.org\">memcached</a> or <a href=\"http://basho.com/riak/\">Basho Riak</a> use it. It dates back to the ideas put forward e.g. in the STOC 1997 paper by <a href=\"http://people.csail.mit.edu/karger/\">David Karger</a> et al. on <a href=\"http://dl.acm.org/citation.cfm?id=258660\">Consistent Hashing and Random Trees</a>. </p>\n<p>A key problem is that we can obviously not store a mapping table from the keys to the machines. This would require a database that is of the same size as the set of keys and that would need to be maintained and updated on each client. One way around this is to use the argmin hash mapping. That is, given a machine pool \\(M\\), we assign a given (key,value) pair to the machine that has the smallest hash, i.e.</p>\n<p>$$m(k, M) = \\mathrm{argmin}_{m \\in M} h(m,k)$$</p>\n<p>The advantage of this scheme is that it allows for really good load balancing and repair. First off, the load is almost uniformly distributed, short of a small number of heavy hitters. Secondly, if a machine is removed or added to the machine pool, rebalancing affects all other machines uniformly. To see this, notice that the choice of machine with the smallest and second-smallest hash value is uniform. </p>\n<p>Unfortunately, this is a stupid way of distributing (key,value) pairs for machine learning. And this is what we did in our <a href=\"http://www.vldbarc.org/pvldb/vldb2010/papers/R63.pdf\">2010 VLDB</a> and <a href=\"http://dx.doi.org/10.1145/2124295.2124312\">2012 WSDM</a> papers. To our excuse, we didn&rsquo;t know any better. And others copied that approach &hellip; after all, how you can you improve on such nice rebalancing aspects.</p>\n<p>This begs the question why it is a bad idea. It all comes down to the issue of synchronization. Basically, whenever a client attempts to synchronize its keys, it needs to traverse the list of the keys it owns and communicate with the appropriate servers. In the above scheme, it means that we need to communicate to a new random server for each key. This is amazingly costly. Probably the best comparison would be a P2P network where each byte is owned by a different machine. Downloads would take forever.</p>\n<p>We &lsquo;fixed&rsquo; this problem by cleverly reordering the access and then performing a few other steps of randomization. There&rsquo;s even a nice load balancing lemma in the <a href=\"http://dx.doi.org/10.1145/2124295.2124312\">2012 WSDM</a> paper. However, a much better solution is to prevent the problem from happening and to borrow from key distribution algorithms such as <a href=\"http://en.wikipedia.org/wiki/Chord_(peer-to-peer)\">Chord</a>. In it, servers are inserted into a ring via a hash function. So are keys. This means that each server now owns a <strong>contiguous segment of keys</strong>. As a result, we can easily determine which keys go to which server, simply by knowing where in the ring the server sits.</p>\n<p><figure class=\"tmblr-full\" data-orig-height=\"500\" data-orig-width=\"500\" data-orig-src=\"https://64.media.tumblr.com/2741f4e10d3e42bd0312de6496042368/tumblr_inline_n5uuxoVsIy1qasu5b.png\"><img alt=\"image\" src=\"https://64.media.tumblr.com/66246840141a5c9ab9a77137128a495c/tumblr_inline_parlsjuGYo1qasu5b_540.png\" data-orig-height=\"500\" data-orig-width=\"500\" data-orig-src=\"https://64.media.tumblr.com/2741f4e10d3e42bd0312de6496042368/tumblr_inline_n5uuxoVsIy1qasu5b.png\"/></figure></p>\n<p>In the picture above, keys are represented by little red stars. They are randomly assigned using a hash function via \\(h(k)\\) to the segments 'owned&rsquo; by servers \\(s\\) that are inserted in the same way, i.e. via \\(h(s)\\). In the picture above, each server 'owns&rsquo; the segment to its left. Also have a look at the <a href=\"http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf\">Amazon Dynamo paper</a> for a related description.</p>\n<p>Obviously, such a load-balancing isn&rsquo;t quite as ideal as the argmin hash. For instance, if a machine fails, the next machine inherits the entire segment. However, by inserting each server \\(\\log n\\) times we can ensure that a good load balance is achieved and also that when machines are removed, there are several other machines that pick up the work. Moreover, it is now also very easy to replicate things (more on this later). If you&rsquo;re curious on how to do this, have a look at <a href=\"http://research.microsoft.com/en-us/um/people/amar/\">Amar Phanishayee</a>&rsquo;s excellent <a href=\"http://reports-archive.adm.cs.cmu.edu/anon/2012/CMU-CS-12-139.pdf\">thesis</a>. In a nutshell, the machines to the left hold the replicas. More details in the next post.</p>",
  "link": "https://blog.smola.org/post/86282060381",
  "guid": "https://blog.smola.org/post/86282060381",
  "pubDate": "Mon, 19 May 2014 21:31:00 -0700"
}