{
  "title": "How to send raw network packets in Python with tun/tap",
  "link": "",
  "updated": "2022-09-06T11:43:14+00:00",
  "id": "https://jvns.ca/blog/2022/09/06/send-network-packets-python-tun-tap/",
  "content": "\n\n<p>Hello!</p>\n\n<p>Recently I&rsquo;ve been working on a project where I implement a bunch of tiny toy\nworking versions of computer networking protocols in Python without using any\nlibraries, as a way to explain how computer networking works.</p>\n\n<p>I&rsquo;m still working on writing up that project, but today I wanted to talk about\nhow to do the very first step: sending network packets in Python.</p>\n\n<p>In this post we&rsquo;re going to send a SYN packet (the first packet in a TCP\nconnection) from a tiny Python program, and get a reply from <code>example.com</code>. All the code from this post is in <a href=\"https://gist.github.com/jvns/552e6d5e6fec6c3ddf2fcd4ccdab45d5\">this gist</a>.</p>\n\n<h3 id=\"what-s-a-network-packet\">what&rsquo;s a network packet?</h3>\n\n<p>A network packet is a byte string. For example, here&rsquo;s the first packet in a TCP connection:</p>\n\n<pre><code>b'E\\x00\\x00,\\x00\\x01\\x00\\x00@\\x06\\x00\\xc4\\xc0\\x00\\x02\\x02\"\\xc2\\x95Cx\\x0c\\x00P\\xf4p\\x98\\x8b\\x00\\x00\\x00\\x00`\\x02\\xff\\xff\\x18\\xc6\\x00\\x00\\x02\\x04\\x05\\xb4'\n</code></pre>\n\n<p>I&rsquo;m not going to talk about the structure of this byte string in this post\n(though I&rsquo;ll say that this particular byte string has two parts: the first 20\nbytes are the IP address part and the rest is the TCP part)</p>\n\n<p>The point is that to send network packets, we need to be able to send and\nreceive strings of bytes.</p>\n\n<h3 id=\"why-tun-tap\">why tun/tap?</h3>\n\n<p>The problem with writing your own TCP implementation on Linux (or any operating\nsystem) is &ndash; the Linux kernel already has a TCP implementation!</p>\n\n<p>So if you send out a SYN packet on your normal network interface to a host like\nexample.com, here&rsquo;s what will happen:</p>\n\n<ol>\n<li>you send a SYN packet to example.com</li>\n<li>example.com replies with a SYN ACK (so far so good!)</li>\n<li>the Linux kernel on your machine gets the SYN ACK, thinks &ldquo;wtf?? I didn&rsquo;t make this connection??&rdquo;, and closes the connection</li>\n<li>you&rsquo;re sad. no TCP connection for you.</li>\n</ol>\n\n<p>I was talking to a friend about this problem a few years ago and he said &ldquo;you\nshould use tun/tap!&ldquo;. It took quite a few hours to figure out how to do that\nthough, which is why I&rsquo;m writing this blog post :)</p>\n\n<h3 id=\"tun-tap-gives-you-a-virtual-network-device\">tun/tap gives you a &ldquo;virtual network device&rdquo;</h3>\n\n<p>The way I like to think of <code>tun/tap</code> is &ndash; imagine I have a tiny computer in my\nnetwork which is sending and receiving network packets. But instead of it being\na real computer, it&rsquo;s just a Python program I wrote.</p>\n\n<p>That explanation is honestly worse than I would like. I wish I understood\nexactly how tun/tap devices interfaced with the real Linux network stack but\nunfortunately I do not, so &ldquo;virtual network device&rdquo; is what you&rsquo;re getting.\nHopefully the code examples below will make all it a bit more clear.</p>\n\n<h3 id=\"tun-vs-tap\">tun vs tap</h3>\n\n<p>The system called &ldquo;tun/tap&rdquo; lets you create two kinds of network interfaces:</p>\n\n<ul>\n<li>&ldquo;tun&rdquo;, which lets you set IP-layer packets</li>\n<li>&ldquo;tap&rdquo;, which lets you set Ethernet-layer packets</li>\n</ul>\n\n<p>We&rsquo;re going to be using <strong>tun</strong>, because that&rsquo;s what I could figure out how to\nget to work. It&rsquo;s possible that tap would work too.</p>\n\n<h3 id=\"how-to-create-a-tun-interface\">how to create a tun interface</h3>\n\n<p>Here&rsquo;s how I created a tun interface with IP address 192.0.2.2.</p>\n\n<pre><code>sudo ip tuntap add name tun0 mode tun user $USER\nsudo ip link set tun0 up\nsudo ip addr add 192.0.2.1 peer 192.0.2.2 dev tun0\n\nsudo iptables -t nat -A POSTROUTING -s 192.0.2.2 -j MASQUERADE\nsudo iptables -A FORWARD -i tun0 -s 192.0.2.2 -j ACCEPT\nsudo iptables -A FORWARD -o tun0 -d 192.0.2.2 -j ACCEPT\n</code></pre>\n\n<p>These commands do two things:</p>\n\n<ol>\n<li>Create the <code>tun</code> device with the IP <code>192.0.2.2</code> (and give your user access to write to it)</li>\n<li>set up <code>iptables</code> to proxy packets from that tun device to the internet using NAT</li>\n</ol>\n\n<p>The iptables part is very important because otherwise the packets would only\nexist inside my computer and wouldn&rsquo;t be sent to the internet, and what fun\nwould that be?</p>\n\n<p>I&rsquo;m not going to explain this <code>ip addr add</code> command because I don&rsquo;t understand\nit, I find <code>ip</code> to be very inscrutable and for now I&rsquo;m resigned to just copying\nand pasting <code>ip</code> commands without fully understanding them. It does work\nthough.</p>\n\n<h3 id=\"how-to-connect-to-the-tun-interface-in-python\">how to connect to the tun interface in Python</h3>\n\n<p>Here&rsquo;s a function to open a tun interface, you call it like <code>openTun('tun0')</code>.\nI figured out how to write it by searching through the\n<a href=\"https://scapy.net/\">scapy</a> source code for &ldquo;tun&rdquo;.</p>\n\n<pre><code>import struct\nfrom fcntl import ioctl\n\ndef openTun(tunName):\n    tun = open(\"/dev/net/tun\", \"r+b\", buffering=0)\n    LINUX_IFF_TUN = 0x0001\n    LINUX_IFF_NO_PI = 0x1000\n    LINUX_TUNSETIFF = 0x400454CA\n    flags = LINUX_IFF_TUN | LINUX_IFF_NO_PI\n    ifs = struct.pack(\"16sH22s\", tunName, flags, b\"\")\n    ioctl(tun, LINUX_TUNSETIFF, ifs)\n    return tun\n</code></pre>\n\n<p>All this is doing is</p>\n\n<ol>\n<li>opening <code>/dev/net/tun</code> in binary mode</li>\n<li>calling an <code>ioctl</code> to tell Linux that we want a <code>tun</code> device, and that the one we want is called <code>tun0</code> (or whatever <code>tunName</code> we&rsquo;ve passed to the function).</li>\n</ol>\n\n<p>Once it&rsquo;s open, we can <code>read</code> from and <code>write</code> to it like any other file in Python.</p>\n\n<h3 id=\"let-s-send-a-syn-packet\">let&rsquo;s send a SYN packet!</h3>\n\n<p>Now that we have the <code>openTun</code> function, we can send a SYN packet!</p>\n\n<p>Here&rsquo;s what the Python code looks like, using the <code>openTun</code> function.</p>\n\n<pre><code>syn = b'E\\x00\\x00,\\x00\\x01\\x00\\x00@\\x06\\x00\\xc4\\xc0\\x00\\x02\\x02\"\\xc2\\x95Cx\\x0c\\x00P\\xf4p\\x98\\x8b\\x00\\x00\\x00\\x00`\\x02\\xff\\xff\\x18\\xc6\\x00\\x00\\x02\\x04\\x05\\xb4'\ntun = openTun(b\"tun0\")\ntun.write(syn)\nreply = tun.read(1024)\nprint(repr(reply))\n</code></pre>\n\n<p>If I run this as <code>sudo python3 syn.py</code>, it prints out the reply from <code>example.com</code>:</p>\n\n<pre><code>b'E\\x00\\x00,\\x00\\x00@\\x00&\\x06\\xda\\xc4\"\\xc2\\x95C\\xc0\\x00\\x02\\x02\\x00Px\\x0cyvL\\x84\\xf4p\\x98\\x8c`\\x12\\xfb\\xe0W\\xb5\\x00\\x00\\x02\\x04\\x04\\xd8'\n</code></pre>\n\n<p>Obviously this is a pretty silly way to send a SYN packet &ndash; a real\nimplementation would have actual code to generate that byte string instead of\nhardcoding it, and we would parse the reply instead of just printing out the\nraw byte string. But I didn&rsquo;t want to go into the structure of TCP in this post\nso that&rsquo;s what we&rsquo;re doing.</p>\n\n<h3 id=\"looking-at-these-packets-with-tcpdump\">looking at these packets with tcpdump</h3>\n\n<p>If we run tcpdump on the <code>tun0</code> interface, we can see the packet we sent and the answer from <code>example.com</code>:</p>\n\n<pre><code>$ sudo tcpdump -ni tun0\n12:51:01.905933 IP 192.0.2.2.30732 > 34.194.149.67.80: Flags [S], seq 4101019787, win 65535, options [mss 1460], length 0\n12:51:01.932178 IP 34.194.149.67.80 > 192.0.2.2.30732: Flags [S.], seq 3300937416, ack 4101019788, win 64480, options [mss 1240], length 0\n</code></pre>\n\n<p><code>Flags [S]</code> is the SYN we sent, and <code>Flags [S.]</code> is the SYN ACK packet in\nresponse! We successfully communicated! And the Linux network stack didn&rsquo;t\ninterfere at all!</p>\n\n<h3 id=\"tcpdump-also-shows-us-how-nat-is-working\">tcpdump also shows us how NAT is working</h3>\n\n<p>We can also run <code>tcpdump</code> on my real network interface (<code>wlp3so</code>, my wireless card), to see the packets being sent and received. We&rsquo;ll pass <code>-i wlp3s0</code> instead of <code>-i tun0</code>.</p>\n\n<pre><code>$ sudo tcpdump -ni wlp3s0 host 34.194.149.67\ntcpdump: verbose output suppressed, use -v[v]... for full protocol decode\nlistening on wlp3s0, link-type EN10MB (Ethernet), snapshot length 262144 bytes\n12:56:01.204382 IP 192.168.1.181.30732 > 34.194.149.67.80: Flags [S], seq 4101019787, win 65535, options [mss 1460], length 0\n12:56:01.228239 IP 34.194.149.67.80 > 192.168.1.181.30732: Flags [S.], seq 144769955, ack 4101019788, win 64480, options [mss 1240], length 0\n12:56:05.334427 IP 34.194.149.67.80 > 192.168.1.181.30732: Flags [S.], seq 144769955, ack 4101019788, win 64480, options [mss 1240], length 0\n12:56:13.524973 IP 34.194.149.67.80 > 192.168.1.181.30732: Flags [S.], seq 144769955, ack 4101019788, win 64480, options [mss 1240], length 0\n12:56:29.705007 IP 34.194.149.67.80 > 192.168.1.181.30732: Flags [S.], seq 144769955, ack 4101019788, win 64480, options [mss 1240], length 0\n</code></pre>\n\n<p>A couple of things to notice here:</p>\n\n<ul>\n<li>The IP addresses are different &ndash; that IPtables rule from above has rewritten them from <code>192.0.2.2</code> to <code>192.168.1.181</code>. This rewriting is called &ldquo;network address translation&rdquo;, or &ldquo;NAT&rdquo;.</li>\n<li>We&rsquo;re getting a bunch of replies from <code>example.com</code> &ndash; it&rsquo;s doing an\nexponential backoff where it retries after 4 seconds, then 8 seconds, then 16\nseconds. This is because we didn&rsquo;t finish the TCP handshake &ndash; we just sent a\nSYN and left it hanging! There&rsquo;s actually a type of DDOS attack like this\ncalled SYN flooding, but just sending one or two SYN packets isn&rsquo;t a big\ndeal.</li>\n<li>I had to add <code>host 34.194.149.67</code> because there are a lot of TCP packets being sent on my real wifi connection so I needed to ignore those</li>\n</ul>\n\n<p>I&rsquo;m not totally sure why we see more SYN replies on <code>wlp3s0</code> than on <code>tun0</code>, my\nguess is that it&rsquo;s because we only read 1 reply in our Python program.</p>\n\n<h3 id=\"this-is-pretty-easy-and-really-reliable\">this is pretty easy and really reliable</h3>\n\n<p>The last time I tried to implement TCP in Python I did it with something called\n&ldquo;ARP spoofing&rdquo;. I won&rsquo;t talk about that here (there are some posts about it on\nthis blog back in 2013), but this way is a lot more reliable.</p>\n\n<p>And ARP spoofing is kind of a sketchy thing to do on a network you don&rsquo;t own.</p>\n\n<h3 id=\"here-s-the-code\">here&rsquo;s the code</h3>\n\n<p>I put all the code from this blog post in <a href=\"https://gist.github.com/jvns/552e6d5e6fec6c3ddf2fcd4ccdab45d5\">this gist</a>, if you want to try it yourself, you can run</p>\n\n<pre><code>bash setup.sh # needs to run as root, has lots of `sudo` commands\npython3 syn.py # runs as a regular user\n</code></pre>\n\n<p>It only works on Linux, but I think there&rsquo;s a way to set up tun/tap on Mac too.</p>\n\n<h3 id=\"a-plug-for-scapy\">a plug for scapy</h3>\n\n<p>I&rsquo;ll close with a plug for <a href=\"https://scapy.net/\">scapy</a> here: it&rsquo;s a really\ngreat Python networking library for doing this kind of experimentation without\nwriting all the code yourself.</p>\n\n<p>This post is about writing all the code yourself though so I won&rsquo;t say more\nabout it than that.</p>\n"
}