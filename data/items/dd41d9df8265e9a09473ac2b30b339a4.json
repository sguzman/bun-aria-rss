{
  "id": "tag:blogger.com,1999:blog-1176949257541686127.post-7341553905426522930",
  "published": "2022-04-12T12:00:00.002-04:00",
  "updated": "2022-04-13T12:30:56.491-04:00",
  "title": "How to SLSA Part 1 - The Basics",
  "content": "<span class=\"byline-author\">Posted by Tom Hennen, Software Engineer, BCID &amp; GOSST&nbsp;</span><div><br /></div>One of the great benefits of SLSA (<a href=\"http://slsa.dev\">Supply-chain Levels for Software Artifacts</a>) is its flexibility. As an open source framework designed to improve the integrity of software packages and infrastructure, it is as applicable to small open source projects as to enterprise organizations. But with this flexibility can come a bewildering array of options for beginners—much like salsa dancing, someone just starting out might be left on the dance floor wondering how and where to jump in.<br /><br />Though it’s tempting to try to establish a single standard for how to use SLSA, it’s not possible: SLSA is not a line dance where everyone does the same moves, at the same time, to the same song. It’s a varied system with different styles, moves, and flourishes. The open source community, organizations, and consumers may all implement SLSA differently, but they can still work with each other.<br /><br /><br />In this three-part series, we’ll explore how three fictional organizations would apply SLSA to meet their different needs. In doing so, we will answer some of the main questions that newcomers to SLSA have:<br /><br /><br />Part 1: The basics<br /><ul style=\"text-align: left;\"><li>How and when do you verify a package with SLSA?</li><li>How to handle artifacts without provenance?</li></ul>Part 2: The details<br /><br /><ul style=\"text-align: left;\"><li>Where is the provenance stored?</li><li>Where is the appropriate policy stored and who should verify it?</li><li>What should the policies check?</li><li>How do you establish trust &amp; distribute keys?</li></ul>Part 3: Putting it all together<ul style=\"text-align: left;\"><li>What does a secure, heterogeneous supply chain look like?</li></ul><h1 style=\"text-align: left;\">The Situation</h1>Our fictional example involves three organizations that want to use SLSA:<br /><br />Squirrel: a package manager with a large number of developers and users<br /><br />Oppy: an open source operating system with an enterprise distribution<br /><br />Acme: a mid sized enterprise. <br /><br />Squirrel wants to make SLSA as easy for their users as possible, even if that means abstracting some details away. Meanwhile, Oppy doesn’t want to abstract anything away from their users under the philosophy that they should explicitly understand exactly what they’re consuming.<br /><br />Acme is trying to produce a container image that contains three artifacts:<br /><ol style=\"text-align: left;\"><li>The Squirrel package ‘foo’</li><li>The Oppy package ‘baz’</li><li>A custom executable, ‘bar’, written by Acme employees</li></ol>This series demonstrates one approach to using SLSA that lets Acme verify the Squirrel and Oppy packages ‘foo’ and ‘baz’ and its customers verify the container image. Though not every suggested solution is perfect, the solutions described can be a starting point for discussion and a foundation for new solutions.<br /><br /><div><h1 style=\"text-align: left;\">Basics</h1>In order to SLSA, Squirrel, Oppy, and Acme will all need SLSA capable build services. Squirrel wants to give their maintainers wide latitude to pick a builder service of their own. To support this, Squirrel will qualify some build services at specific SLSA levels (meaning they can produce artifacts up to that level). To start, Squirrel plans to qualify GitHub Actions using an approach <a href=\"https://security.googleblog.com/2022/04/improving-software-supply-chain.html\">like this</a>, and hopes it can achieve SLSA 4 (pending the result of an independent audit). They’re also willing to qualify other build services as needed. Oppy on the other hand, doesn’t need to support arbitrary build services. They plan to have everyone use their Autobuilder network which they hope to qualify at SLSA 4 (they’ll conduct the audit/certification themselves). Finally, Acme plans to use Google Cloud Build which they’ll self-certify at SLSA 4 (pending the result of a Google-conducted audit).<br /><br />Squirrel, Oppy, and Acme will follow a similar qualification process for the source control systems they plan to support.<br /><br /></div><div><h1 style=\"text-align: left;\">Verification options</h1><b>Full verification</b><br /><br />At some point, one or more of the organizations will need to do full verification of each artifact to determine if it is acceptable for a given use case. This is accomplished by checking if the artifact meets the appropriate policy.<br /><br />Typically, full verification would take place with <a href=\"http://slsa.dev/provenance\">SLSA provenance</a>, <a href=\"https://github.com/in-toto/attestation/issues/47\">source attestations</a>, and perhaps other specialized attestations (like <a href=\"https://github.com/in-toto/attestation/issues/58\">vulnerability scan results</a>). While having to coordinate this data for all of its dependencies seems like a lot of work to Acme, they’re prepared to do full verification if Squirrel and Oppy are unable to.</div><div><br /><b>Delegated verification</b><br /><br />When Acme isn’t using full verification, they can instead use delegated verification where they check if an artifact is acceptable for a use case by checking if some other trusted party who performed a full verification (such as Squirrel or Oppy) believes the artifact is acceptable.<br /><br />Delegated verification is easier to perform quickly with limited data and network connectivity. It may also be easier for some users who value if someone they trust verified the artifact is good.<br /><br />Squirrel likes how easy delegated verification would make things for their users and plans to support it by creating a <a href=\"https://slsa.dev/verification_summary/v0.1\">Verification Summary Attestation (VSA)</a> when they perform full verification.<br /><br /></div><div><b>When to verify</b><br /><br />Verification (full or delegated) could happen at a number of different times.<br /><br /></div><div><b>On import to repo</b><br /><br />Squirrel plans to perform full verification when an artifact is published to their repo. This will ensure that packages in the repo have met their corresponding policy. It’s also helpful because all the required data can be gathered when latency isn’t critical.<br /><br />If this were the only time verification is performed, it would put the repository's storage in the trusted computing base (TCB) of its users. Squirrel’s plans to use delegated verification (and issue VSAs) can prevent this. The signature on the VSA will prevent the artifacts from being tampered with while sitting in storage, even if they’re just SLSA 0. Downstream users will just need to verify the VSA.<br /><br />Acme also wants to do some sort of verification on the import to their internal repo since it simplifies their security story. They’re not quite sure what this will look like yet.<br /><br /></div><div><b>On install</b><br /><br />Acme also wants to do verification when an artifact is actually installed since it can remove a number of intermediaries from their TCB (their repo, the network, upstream storage systems).<br /><br />If they perform full verification at install then they must gather all the required information. That could be a lot of data, but it might be simplified by gathering the data from external sources and caching it in their internal repo. A larger problem is that it requires Acme to have established trust in all parties that produced that information (e.g. every builder of every package). For a complex supply chain that may be difficult.<br /><br />If Acme performs delegated verification, they only need the VSA for the packages being installed and to explicitly trust a handful of parties. This allows the complex full verification to be performed once while allowing all users of that package to perform a much simpler operation.<br /><br />Given these tradeoffs Acme prefers delegated verification at install time. Squirrel also really likes the idea and plans to build install time verification directly into the Squirrel tool.</div><div><b><br /></b></div><div><b>On use</b></div><div><br />Verification could also take place each time an artifact is actually used. In this model, latency and reliability are very important (a sudden increase in site traffic may necessitate a scaling operation launching many new jobs).<br /><br />Time of use verification allows the most context with which decisions can be made (“is this job allowed to run this code and is it free from vulns right now?”). It also allows policy changes to affect already built &amp; installed software (which may or may not be desirable).<br /><br />Acme wants their users to be able to verify on use without too many dependencies so they plan to provide VSAs users can use to perform delegated verification when they start the container (perhaps using something like <a href=\"https://kyverno.io/docs/writing-policies/verify-images/#verifying-image-attestations\">Kyverno</a>).</div><div><br /><h1 style=\"text-align: left;\"><b>How to handle artifacts without provenance?</b></h1>Inevitably a build or system may require that an artifact without ‘original’ provenance is used. In these cases it may be desirable for the importer to generate provenance that details where it got this artifact. For example, this generated provenance shows that http://example.com/foo.tgz with sha256:abc was imported by ‘auto-importer’:<br /><br /><div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"https://blogger.googleusercontent.com/img/a/AVvXsEhmAA5fBrS7Mhd_8uGzHUaOUCRED1TfAJSa7e2g7PijIWy42BY9pKsvNVYu5PJ1Zz_z9gRz5yqBbvWZeSJJyMAqH2QZs2aD2JkXw4DlFrTa2hL8FgFS014LBMryf9NqPsMjCg82QGYvlU632L6KsvfgibR9NP2qn489XX5LDagNYp4cRiIUKdwsqaP_pA\" style=\"margin-left: 1em; margin-right: 1em;\"><img alt=\"\" data-original-height=\"362\" data-original-width=\"629\" height=\"368\" src=\"https://blogger.googleusercontent.com/img/a/AVvXsEhmAA5fBrS7Mhd_8uGzHUaOUCRED1TfAJSa7e2g7PijIWy42BY9pKsvNVYu5PJ1Zz_z9gRz5yqBbvWZeSJJyMAqH2QZs2aD2JkXw4DlFrTa2hL8FgFS014LBMryf9NqPsMjCg82QGYvlU632L6KsvfgibR9NP2qn489XX5LDagNYp4cRiIUKdwsqaP_pA=w640-h368\" width=\"640\" /></a></div><br />Such an artifact would likely not be accepted at higher SLSA levels, but the provenance can be used to: 1) prevent tampering with the artifact after it’s been imported and 2) be a data point for future analysis (e.g. should we prioritize asking for foo.tgz to be distributed with native SLSA provenance?).<br /><br />Acme might be interested in taking this approach at some point, but they don’t need it at the moment.<br /></div><div><h1 style=\"text-align: left;\"><b>Next time</b></h1>In our next post we’ll cover specific approaches that can be used to answer questions like “where should attestations and policies be stored?” and “how do I trust the attestations that I receive?”</div>",
  "link": [
    "",
    "",
    "",
    "",
    ""
  ],
  "author": {
    "name": "Unknown",
    "email": "noreply@blogger.com",
    "gd:image": ""
  },
  "media:thumbnail": "",
  "thr:total": 0
}