{
  "title": "The mean shift clustering algorithm",
  "link": "",
  "published": "2015-04-21T09:17:00-07:00",
  "updated": "2015-04-21T09:17:00-07:00",
  "author": {
    "name": "Damien RJ"
  },
  "id": "tag:efavdb.com,2015-04-21:/mean-shift",
  "summary": "<h3>Mean shift&nbsp;clustering</h3>\n<p>Mean shift clustering is a general non-parametric cluster finding procedure &#8212; introduced by Fukunaga and Hostetler [<a href=\"#1\">1</a>], and popular within the computer vision field. Nicely, and in contrast to the more-well-known K-means clustering algorithm, the output of mean shift does not depend on any explicit assumptions on the …</p>",
  "content": "<h3>Mean shift&nbsp;clustering</h3>\n<p>Mean shift clustering is a general non-parametric cluster finding procedure &#8212; introduced by Fukunaga and Hostetler [<a href=\"#1\">1</a>], and popular within the computer vision field. Nicely, and in contrast to the more-well-known K-means clustering algorithm, the output of mean shift does not depend on any explicit assumptions on the shape of the point distribution, the number of clusters, or any form of random&nbsp;initialization.</p>\n<p>We describe the mean shift algorithm in some detail in the <a href=\"#Tech\">technical background section</a> at the end of this post. However, its essence is readily explained in a few words: Essentially, mean shift treats the clustering problem by supposing that all points given represent samples from some underlying probability density function, with regions of high sample density corresponding to the local maxima of this distribution. To find these local maxima, the algorithm works by allowing the points to attract each other, via what might be considered a short-ranged &#8220;gravitational&#8221; force. Allowing the points to gravitate towards areas of higher density, one can show that they will eventually coalesce at a series of points, close to the local maxima of the distribution. Those data points that converge to the same local maxima are considered to be members of the same&nbsp;cluster.</p>\n<p>In the next couple of sections, we illustrate application of the algorithm to a couple of problems. We make use of the python package <a href=\"http://scikit-learn.org/stable/\">SkLearn</a>, which contains a mean shift implementation. Following this, we provide a quick discussion and an appendix on technical&nbsp;details.</p>\n<h3>Mean shift clustering in&nbsp;action</h3>\n<p>In today&#8217;s post we will have two examples. First, we will show how to use mean shift clustering to identify clusters of data in a 2D data set. Second, we will use the algorithm to segment a picture based on the colors in the image. To do this we need a handful of libraries from sklearn, numpy, matplotlib, and the Python Imaging Library (<span class=\"caps\">PIL</span>) to handle reading in a jpeg&nbsp;image.</p>\n<div class=\"highlight\"><pre><span></span><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"kn\">from</span> <span class=\"nn\">sklearn.cluster</span> <span class=\"kn\">import</span> <span class=\"n\">MeanShift</span><span class=\"p\">,</span> <span class=\"n\">estimate_bandwidth</span>\n<span class=\"kn\">from</span> <span class=\"nn\">sklearn.datasets.samples_generator</span> <span class=\"kn\">import</span> <span class=\"n\">make_blobs</span>\n<span class=\"kn\">import</span> <span class=\"nn\">matplotlib.pyplot</span> <span class=\"k\">as</span> <span class=\"nn\">plt</span>\n<span class=\"kn\">from</span> <span class=\"nn\">itertools</span> <span class=\"kn\">import</span> <span class=\"n\">cycle</span>\n<span class=\"kn\">from</span> <span class=\"nn\">PIL</span> <span class=\"kn\">import</span> <span class=\"n\">Image</span>\n</pre></div>\n\n\n<h4>Finding clusters in a 2D data&nbsp;set</h4>\n<p>This first example is based off of the sklearn <a href=\"http://scikit-learn.org/stable/auto_examples/cluster/plot_mean_shift.html\">tutorial</a> for mean shift clustering: We generate data points centered at 4 locations, making use of sklearn&#8217;s make_blobs library. To apply the clustering algorithm to the points generated, we must first set the attractive interaction length between examples, also know as the algorithm&#8217;s bandwidth. Sklearn&#8217;s implementation contains a built-in function that allows it to automatically estimate a reasonable value for this, based upon the typical distance between examples. We make use of that below, carry out the clustering, and then plot the&nbsp;results.</p>\n<div class=\"highlight\"><pre><span></span><span class=\"err\">#</span><span class=\"o\">%%</span><span class=\"w\"> </span><span class=\"n\">Generate</span><span class=\"w\"> </span><span class=\"n\">sample</span><span class=\"w\"> </span><span class=\"k\">data</span><span class=\"w\"></span>\n<span class=\"n\">centers</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">[1, 1</span><span class=\"o\">]</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">-.75, -1</span><span class=\"o\">]</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">1, -1</span><span class=\"o\">]</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">-3, 2</span><span class=\"o\">]</span><span class=\"err\">]</span><span class=\"w\"></span>\n<span class=\"n\">X</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">make_blobs</span><span class=\"p\">(</span><span class=\"n\">n_samples</span><span class=\"o\">=</span><span class=\"mi\">10000</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">centers</span><span class=\"o\">=</span><span class=\"n\">centers</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">cluster_std</span><span class=\"o\">=</span><span class=\"mf\">0.6</span><span class=\"p\">)</span><span class=\"w\"></span>\n\n<span class=\"err\">#</span><span class=\"o\">%%</span><span class=\"w\"> </span><span class=\"k\">Compute</span><span class=\"w\"> </span><span class=\"n\">clustering</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">MeanShift</span><span class=\"w\"></span>\n\n<span class=\"err\">#</span><span class=\"w\"> </span><span class=\"n\">The</span><span class=\"w\"> </span><span class=\"n\">bandwidth</span><span class=\"w\"> </span><span class=\"n\">can</span><span class=\"w\"> </span><span class=\"n\">be</span><span class=\"w\"> </span><span class=\"n\">automatically</span><span class=\"w\"> </span><span class=\"n\">estimated</span><span class=\"w\"></span>\n<span class=\"n\">bandwidth</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">estimate_bandwidth</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">quantile</span><span class=\"o\">=</span><span class=\"mf\">.1</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"n\">n_samples</span><span class=\"o\">=</span><span class=\"mi\">500</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"n\">ms</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MeanShift</span><span class=\"p\">(</span><span class=\"n\">bandwidth</span><span class=\"o\">=</span><span class=\"n\">bandwidth</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">bin_seeding</span><span class=\"o\">=</span><span class=\"k\">True</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"n\">ms</span><span class=\"p\">.</span><span class=\"n\">fit</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"n\">labels</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ms</span><span class=\"p\">.</span><span class=\"n\">labels_</span><span class=\"w\"></span>\n<span class=\"n\">cluster_centers</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ms</span><span class=\"p\">.</span><span class=\"n\">cluster_centers_</span><span class=\"w\"></span>\n\n<span class=\"n\">n_clusters_</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">labels</span><span class=\"p\">.</span><span class=\"nf\">max</span><span class=\"p\">()</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"w\"></span>\n\n<span class=\"err\">#</span><span class=\"o\">%%</span><span class=\"w\"> </span><span class=\"n\">Plot</span><span class=\"w\"> </span><span class=\"k\">result</span><span class=\"w\"></span>\n<span class=\"n\">plt</span><span class=\"p\">.</span><span class=\"n\">figure</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"n\">plt</span><span class=\"p\">.</span><span class=\"n\">clf</span><span class=\"p\">()</span><span class=\"w\"></span>\n\n<span class=\"n\">colors</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">cycle</span><span class=\"p\">(</span><span class=\"s1\">&#39;bgrcmykbgrcmykbgrcmykbgrcmyk&#39;</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">col</span><span class=\"w\"> </span><span class=\"ow\">in</span><span class=\"w\"> </span><span class=\"n\">zip</span><span class=\"p\">(</span><span class=\"k\">range</span><span class=\"p\">(</span><span class=\"n\">n_clusters_</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">colors</span><span class=\"p\">)</span><span class=\"err\">:</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">my_members</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">labels</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">cluster_center</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">cluster_centers</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">plt</span><span class=\"p\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"o\">[</span><span class=\"n\">my_members, 0</span><span class=\"o\">]</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">[</span><span class=\"n\">my_members, 1</span><span class=\"o\">]</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">col</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"s1\">&#39;.&#39;</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">plt</span><span class=\"p\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">cluster_center</span><span class=\"o\">[</span><span class=\"n\">0</span><span class=\"o\">]</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">cluster_center</span><span class=\"o\">[</span><span class=\"n\">1</span><span class=\"o\">]</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"s1\">&#39;o&#39;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">markerfacecolor</span><span class=\"o\">=</span><span class=\"n\">col</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">markeredgecolor</span><span class=\"o\">=</span><span class=\"s1\">&#39;k&#39;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">markersize</span><span class=\"o\">=</span><span class=\"mi\">14</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"n\">plt</span><span class=\"p\">.</span><span class=\"n\">title</span><span class=\"p\">(</span><span class=\"s1\">&#39;Estimated number of clusters: %d&#39;</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"w\"> </span><span class=\"n\">n_clusters_</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"n\">plt</span><span class=\"p\">.</span><span class=\"n\">show</span><span class=\"p\">()</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>As you can see below, the algorithm has found clusters centered on each of the blobs we&nbsp;generated.</p>\n<p><a href=\"https://efavdb.com/wp-content/uploads/2015/03/plot1.png\"><img alt=\"Plot 1\" src=\"https://efavdb.com/wp-content/uploads/2015/03/plot1.png\"></a></p>\n<h4>Segmenting a color&nbsp;photo</h4>\n<p>In the first example, we were using mean shift clustering to look for spatial clusters. In our second example, we will instead explore 3D color space, <span class=\"caps\">RGB</span>, by considering pixel values taken from an image of a toy car. The procedure is similar &#8212; here, we cluster points in 3d, but instead of having data(x,y) we have data(r,g,b) taken from the image&#8217;s <span class=\"caps\">RGB</span> pixel values. Clustering these color values in this 3d space returns a series of clusters, where the pixels in those clusters are similar in <span class=\"caps\">RGB</span> space. Recoloring pixels according to their cluster, we obtain a segmentation of the original&nbsp;image.</p>\n<div class=\"highlight\"><pre><span></span><span class=\"o\">#%%</span> <span class=\"n\">Part</span> <span class=\"mi\">2</span><span class=\"p\">:</span> <span class=\"n\">Color</span> <span class=\"n\">image</span> <span class=\"n\">segmentation</span> <span class=\"k\">using</span> <span class=\"n\">mean</span> <span class=\"n\">shift</span>\n\n<span class=\"n\">image</span> <span class=\"o\">=</span> <span class=\"n\">Image</span><span class=\"p\">.</span><span class=\"k\">open</span><span class=\"p\">(</span><span class=\"s1\">&#39;toy.jpg&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">image</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"p\">.</span><span class=\"nb\">array</span><span class=\"p\">(</span><span class=\"n\">image</span><span class=\"p\">)</span>\n\n<span class=\"o\">#</span><span class=\"n\">Need</span> <span class=\"k\">to</span> <span class=\"k\">convert</span> <span class=\"n\">image</span> <span class=\"k\">into</span> <span class=\"n\">feature</span> <span class=\"nb\">array</span> <span class=\"n\">based</span>\n<span class=\"o\">#</span><span class=\"k\">on</span> <span class=\"n\">rgb</span> <span class=\"n\">intensities</span>\n<span class=\"n\">flat_image</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">reshape</span><span class=\"p\">(</span><span class=\"n\">image</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">])</span>\n\n<span class=\"o\">#</span><span class=\"n\">Estimate</span> <span class=\"n\">bandwidth</span>\n<span class=\"n\">bandwidth2</span> <span class=\"o\">=</span> <span class=\"n\">estimate_bandwidth</span><span class=\"p\">(</span><span class=\"n\">flat_image</span><span class=\"p\">,</span>\n<span class=\"n\">quantile</span><span class=\"o\">=</span><span class=\"p\">.</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">n_samples</span><span class=\"o\">=</span><span class=\"mi\">500</span><span class=\"p\">)</span>\n<span class=\"n\">ms</span> <span class=\"o\">=</span> <span class=\"n\">MeanShift</span><span class=\"p\">(</span><span class=\"n\">bandwidth2</span><span class=\"p\">,</span> <span class=\"n\">bin_seeding</span><span class=\"o\">=</span><span class=\"k\">True</span><span class=\"p\">)</span>\n<span class=\"n\">ms</span><span class=\"p\">.</span><span class=\"n\">fit</span><span class=\"p\">(</span><span class=\"n\">flat_image</span><span class=\"p\">)</span>\n<span class=\"n\">labels</span><span class=\"o\">=</span><span class=\"n\">ms</span><span class=\"p\">.</span><span class=\"n\">labels_</span>\n\n<span class=\"o\">#</span> <span class=\"n\">Plot</span> <span class=\"n\">image</span> <span class=\"n\">vs</span> <span class=\"n\">segmented</span> <span class=\"n\">image</span>\n<span class=\"n\">plt</span><span class=\"p\">.</span><span class=\"n\">figure</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"p\">.</span><span class=\"n\">subplot</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"p\">.</span><span class=\"n\">imshow</span><span class=\"p\">(</span><span class=\"n\">image</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"p\">.</span><span class=\"n\">axis</span><span class=\"p\">(</span><span class=\"s1\">&#39;off&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"p\">.</span><span class=\"n\">subplot</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"p\">.</span><span class=\"n\">imshow</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">reshape</span><span class=\"p\">(</span><span class=\"n\">labels</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"mi\">851</span><span class=\"p\">,</span><span class=\"mi\">1280</span><span class=\"p\">]))</span>\n<span class=\"n\">plt</span><span class=\"p\">.</span><span class=\"n\">axis</span><span class=\"p\">(</span><span class=\"s1\">&#39;off&#39;</span><span class=\"p\">)</span>\n</pre></div>\n\n\n<p>The bottom image below illustrates that one can effectively use this approach to identify the key shapes within an image, all without doing any image processing to get rid of glare or background &#8212; pretty great!\n<a href=\"https://efavdb.com/wp-content/uploads/2015/03/test-e1428358370930.png\"><img alt=\"\" src=\"https://efavdb.com/wp-content/uploads/2015/03/test-e1428358370930.png\"></a></p>\n<h3>Discussion</h3>\n<p>Although mean shift is a reasonably versatile algorithm, it has primarily been applied to problems in computer vision, where it has been used for image segmentation, clustering, and video tracking. Application to big data problems can be challenging due to the fact the algorithm can become relatively slow in this limit. However, research is presently underway to speed up its convergence, which should enable its application to larger data&nbsp;sets.</p>\n<p>Mean shift&nbsp;pros:</p>\n<ol>\n<li>No assumptions on the shape or number of data&nbsp;clusters.</li>\n<li>The procedure only has one parameter, the&nbsp;bandwidth.</li>\n<li>Output doesn&#8217;t depend on&nbsp;initializations.</li>\n</ol>\n<p>Mean shift&nbsp;cons:</p>\n<ol>\n<li>Output does depend on bandwidth: too small and convergence is slow, too large and some clusters may be&nbsp;missed.</li>\n<li>Computationally expensive for large feature&nbsp;spaces.</li>\n<li>Often slower than K-Means&nbsp;clustering</li>\n</ol>\n<p>Technical details&nbsp;follow.</p>\n<h3 id=\"Tech\">Technical&nbsp;background</h3>\n<h4>Kernel density&nbsp;estimation</h4>\n<p>A general formulation of the mean shift algorithm can be developed through consideration of density kernels. These effectively work by smearing out each point example in space over some small window. Summing up the mass from each of these smeared units gives an estimate for the probability density at every point in space (by smearing, we are able to obtain estimates at locations that do not sit exactly atop any example). This approach is often referred to as <a href=\"http://en.wikipedia.org/wiki/Kernel_density_estimation\">kernel density estimation</a> &#8212; a method for density estimation that often converges more quickly than binning, or histogramming, and one that also nicely returns a continuous estimate for the density&nbsp;function.</p>\n<p>To illustrate, suppose we are given a data set <span class=\"math\">\\(\\{\\textbf{u}_i\\}\\)</span> of points in d-dimensional space, sampled from some larger population, and that we have chosen a kernel <span class=\"math\">\\(K\\)</span> having bandwidth parameter <span class=\"math\">\\(h\\)</span>. Together, these data and kernel function return the following kernel density estimator for the full population&#8217;s density&nbsp;function\n</p>\n<div class=\"math\">\\begin{eqnarray}\nf_K(\\textbf{u}) = \\frac{1}{nh^d}\\sum\\limits_{i=1}^n K(\\frac{\\textbf{u}-\\textbf{u}_i}{h})\n\\end{eqnarray}</div>\n<p>\nThe kernel (smearing) function here is required to satisfy the following two&nbsp;conditions:</p>\n<ol>\n<li><span class=\"math\">\\(\\int K(\\textbf{u})d\\textbf{u} =&nbsp;1\\)</span></li>\n<li><span class=\"math\">\\(K(\\textbf{u})=K(\\vert \\textbf{u} \\vert)\\)</span> for all values of <span class=\"math\">\\(\\textbf{u}\\)</span></li>\n</ol>\n<p>The first requirement is needed to ensure that our estimate is normalized, and the second is associated with the symmetry of our space. Two popular kernel functions that satisfy these conditions are given&nbsp;by</p>\n<ol>\n<li>Flat/Uniform <span class=\"math\">\\(<div class=\"math\">\\begin{align}\n    K(\\textbf{u}) = \\frac{1}{2}\\left\\{\n    \\begin{array}{lr}\n    1 &amp; -1 \\le \\vert \\textbf{u} \\vert \\le 1\\\n    0 &amp; else\n    \\end{array}\n    \\right.\n    \\end{align}</div>\\)</span></li>\n<li>Gaussian = <span class=\"math\">\\(K(\\textbf{u}) = \\frac{1}{\\left(2\\pi\\right)^{d/2}} e^{-\\frac{1}{2} \\vert \\textbf{u}&nbsp;\\vert^2}\\)</span></li>\n</ol>\n<p>Below we plot an example in 1-d using the gaussian kernel to estimate the density of some population along the x-axis. You can see that each sample point adds a small Gaussian to our estimate, centered about it: The equations above may look a bit intimidating, but the graphic here should clarify that the concept is pretty&nbsp;straightforward.</p>\n<p><a href=\"https://efavdb.com/wp-content/uploads/2015/03/KDE-plot.png\"><img alt=\"\" src=\"https://efavdb.com/wp-content/uploads/2015/03/KDE-plot.png\"></a>\nExample of a kernel density estimation using a gaussian kernel for each data point: Adding up small Gaussians about each example returns our net estimate for the total density, the black&nbsp;curve.</p>\n<h4>Mean shift&nbsp;algorithm</h4>\n<p>Recall that the basic goal of the mean shift algorithm is to move particles in the direction of local increasing density. To obtain an estimate for this direction, a gradient is applied to the kernel density estimate discussed above. Assuming an angularly symmetric kernel function, <span class=\"math\">\\(K(\\textbf{u}) = K(\\vert \\textbf{u} \\vert)\\)</span>, one can show that this gradient takes the&nbsp;form\n</p>\n<div class=\"math\">\\begin{eqnarray}\n\\nabla f_K(\\textbf{u}) = \\frac{2}{nh^{d+2}} \\left ( \\sum\\limits_{i=1}^n g(\\left \\vert \\frac{\\textbf{u}-\\textbf{u}_i}{h} \\right \\vert) \\right ) \\textbf{m}(\\textbf{u}).\n\\end{eqnarray}</div>\n<p>\nwhere\n</p>\n<div class=\"math\">\\begin{eqnarray} \\textbf{m}(\\textbf{u}) = \\left ( \\frac{\\sum\\limits_{i=1}^n \\textbf{u}_i g(\\left \\vert \\frac{\\textbf{u}-\\textbf{u}_i}{h} \\right \\vert)}{\\sum\\limits_{i=1}^n g(\\left \\vert \\frac{\\textbf{u}-\\textbf{u}_i}{h} \\right \\vert)}-\\textbf{u} \\right ),\n\\end{eqnarray}</div>\n<p>\nand <span class=\"math\">\\(g(\\vert \\textbf{u} \\vert ) = -K'(\\vert \\textbf{u} \\vert)\\)</span> is the derivative of the selected kernel profile. The vector <span class=\"math\">\\(\\textbf{m}(\\textbf{u})\\)</span> here, called the mean shift vector, points in the direction of increasing density &#8212; the direction we must move our example. With this estimate, then, the mean shift algorithm protocol&nbsp;becomes</p>\n<ul>\n<li>Compute the mean shift vector <span class=\"math\">\\(\\textbf{m}(\\textbf{u}_i)\\)</span>, evaluated at the location of each training example <span class=\"math\">\\(\\textbf{u}_i\\)</span></li>\n<li>Move each example from <span class=\"math\">\\(\\textbf{u}_i \\to \\textbf{u}_i +&nbsp;\\textbf{m}(\\textbf{u}_i)\\)</span></li>\n<li>Repeat until convergence &#8212; ie, until the particles have reached&nbsp;equilibrium.</li>\n</ul>\n<p>As a final step, one determines which examples have ended up at the same points, marking them as members of the same&nbsp;cluster.</p>\n<p>For a proof of convergence and further mathematical details, see <a href=\"https://courses.csail.mit.edu/6.869/handouts/PAMIMeanshift.pdf\">Comaniciu <span class=\"amp\">&amp;</span> Meer (2002)</a> [<a href=\"#2\">2</a>].</p>\n<p>​1. Fukunaga and Hostetler, &#8220;The Estimation of the Gradient of a Density Function, with Applications in Pattern Recognition&#8221;, <span class=\"caps\">IEEE</span> Transactions on Information Theory vol 21 , pp 32-40 ,1975\n2. Dorin Comaniciu and Peter Meer, Mean Shift : A Robust approach towards feature space analysis, <span class=\"caps\">IEEE</span> Transactions on Pattern Analysis and Machine Intelligence vol 24 No 5 May&nbsp;2002.</p>\n<script type=\"text/javascript\">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {\n    var align = \"center\",\n        indent = \"0em\",\n        linebreak = \"false\";\n\n    if (false) {\n        align = (screen.width < 768) ? \"left\" : align;\n        indent = (screen.width < 768) ? \"0em\" : indent;\n        linebreak = (screen.width < 768) ? 'true' : linebreak;\n    }\n\n    var mathjaxscript = document.createElement('script');\n    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';\n    mathjaxscript.type = 'text/javascript';\n    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';\n\n    var configscript = document.createElement('script');\n    configscript.type = 'text/x-mathjax-config';\n    configscript[(window.opera ? \"innerHTML\" : \"text\")] =\n        \"MathJax.Hub.Config({\" +\n        \"    config: ['MMLorHTML.js'],\" +\n        \"    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } },\" +\n        \"    jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" +\n        \"    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" +\n        \"    displayAlign: '\"+ align +\"',\" +\n        \"    displayIndent: '\"+ indent +\"',\" +\n        \"    showMathMenu: true,\" +\n        \"    messageStyle: 'normal',\" +\n        \"    tex2jax: { \" +\n        \"        inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" +\n        \"        displayMath: [ ['$$','$$'] ],\" +\n        \"        processEscapes: true,\" +\n        \"        preview: 'TeX',\" +\n        \"    }, \" +\n        \"    'HTML-CSS': { \" +\n        \"        availableFonts: ['STIX', 'TeX'],\" +\n        \"        preferredFont: 'STIX',\" +\n        \"        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" +\n        \"        linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" +\n        \"    }, \" +\n        \"}); \" +\n        \"if ('default' !== 'default') {\" +\n            \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" +\n                \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" +\n                \"VARIANT['normal'].fonts.unshift('MathJax_default');\" +\n                \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" +\n                \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" +\n                \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" +\n            \"});\" +\n            \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" +\n                \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" +\n                \"VARIANT['normal'].fonts.unshift('MathJax_default');\" +\n                \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" +\n                \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" +\n                \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" +\n            \"});\" +\n        \"}\";\n\n    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);\n    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);\n}\n</script>",
  "category": ""
}