{
  "guid": "tag:blogger.com,1999:blog-6300367579216018061.post-3120176371307585472",
  "pubDate": "Tue, 30 Aug 2016 16:19:00 +0000",
  "atom:updated": "2016-08-30T13:05:40.651-07:00",
  "category": [
    "cloud foundry",
    "cloud native java",
    "docker compose",
    "legacy modernization",
    "legacy systems",
    "microservices",
    "PCF dev",
    "soa",
    "spring boot",
    "spring cloud"
  ],
  "title": "Building Spring Cloud Microservices That Strangle Legacy Systems",
  "description": "<link rel=\"stylesheet\" href=\"https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans:400,700\"><style>.hljs-title, .hljs-id, .scss .hljs-preprocessor {    font-weight: 400 !important; } .hljs-class .hljs-title, .hljs-type, .vhdl .hljs-literal, .tex .hljs-command {    font-weight: 400 !important; } .hljs-keyword, .css .rule .hljs-keyword, .hljs-winutils, .nginx .hljs-title, .hljs-subst, .hljs-request, .hljs-status {    font-weight: 400 !important; } .sect1{padding-bottom:0!important} .sect1+.sect1{border:0!important} .conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:\"Open Sans\",\"DejaVu Sans\",sans-serif;font-style:normal;font-weight:bold} .conum[data-value] *{color:#fff!important} .conum[data-value]+b{display:none} .conum[data-value]:after{content:attr(data-value)} .fa-caret-up {     color: green;     text-shadow: 1px 1px 1px #ccc;     font-size: 1.75em !important; }  .fa-caret-down {     color: red;     text-shadow: 1px 1px 1px #ccc;     font-size: 1.75em !important; }  .fa-minus {     color: #999;     text-shadow: 1px 1px 1px #ccc;     font-size: 1em !important; }  .fa-plus {     font-size: 1em !important;     color: green;     text-shadow: 1px 1px 1px #ccc; }   @media screen and (min-width: 768px) { .table-responsive { font-size: 0.8em; max-width: 50em; } }  @media screen and (max-width: 768px) {     .table-responsive {     font-size: 0.65em; } }  .table-responsive th, .table-responsive tr, .table-responsive td { padding: 4px 4px 4px 4px !important; } p {     margin-bottom: 1.25em !important; line-height: 1.4; } li p { line-height: 1.4 !important; margin: 0 !important; } .blog-post-asciidoc .content img {  max-height: none; } .admonitionblock > table {     background: rgba(0, 0, 0, 0) none repeat scroll 0 0;     border: 0 none;     border-collapse: separate;     width: 100%; } table {     background: #fff none repeat scroll 0 0;     border: 1px solid #dedede;     margin-bottom: 1.25em; } pre .conum[data-value]{position:relative;top:-.125em} b.conum *{color:inherit!important} .conum:not([data-value]):empty{display:none} .hdlist>table,.colist>table{border:0;background:none} .hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none} td.hdlist1{padding-right:.75em;font-weight:bold} td.hdlist1,td.hdlist2{vertical-align:top} .literalblock+.colist,.listingblock+.colist{margin-top:-.5em} .colist>table tr>td:first-of-type{padding:0 .75em;line-height:1} .colist>table tr>td:last-of-type{padding:.25em 0} h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h3,h4,h6{font-family:\"Open Sans\",sans-serif;font-style:normal;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;} .blog-post-asciidoc p{margin-bottom:1.25rem} @media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}.sect1+.sect1{border-top:1px solid #efefed} pre, pre > code {     -moz-osx-font-smoothing: auto;     color: rgba(0, 0, 0, 0.9);     font-family: monospace,monospace;     font-weight: 400;     line-height: 1.45;     text-rendering: optimizelegibility; } .blog-post-asciidoc code,kbd,pre,samp{font-size:.9em;font-weight:400;} .blog-post-asciidoc .admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%} .blog-post-asciidoc .admonitionblock>table td.icon{text-align:center;width:80px} .blog-post-asciidoc .admonitionblock>table td.icon img{max-width:none} .blog-post-asciidoc .admonitionblock>table td.icon .title{font-weight:bold;font-family:\"Open Sans\",\"DejaVu Sans\",sans-serif;text-transform:uppercase} .blog-post-asciidoc .admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)} .blog-post-asciidoc .admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0} .blog-post-asciidoc .admonitionblock td.icon [class^=\"fa icon-\"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default} .blog-post-asciidoc .admonitionblock td.icon .icon-note:before{content:\"\\f05a\";color:#19407c} .blog-post-asciidoc .admonitionblock td.icon .icon-tip:before{content:\"\\f0eb\";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111} .blog-post-asciidoc .admonitionblock td.icon .icon-warning:before{content:\"\\f071\";color:#bf6900} .blog-post-asciidoc .admonitionblock td.icon .icon-caution:before{content:\"\\f06d\";color:#bf3400} .blog-post-asciidoc .admonitionblock td.icon .icon-important:before{content:\"\\f06a\";color:#bf0000} #personDataTable td {     vertical-align: middle; } .rank-col {     text-align: center; } #personDataTable img {     max-width: 35px;     padding: 0; } .table-responsive {     font-weight: 400; } .table > thead > tr > th {     border-bottom: 2px solid #ddd;     font-weight: 400;     padding: 8px !important;     vertical-align: bottom; } .table-responsive {     font-family: Helvetica,sans-serif; } .exampleblock pre {     margin-top: auto; } .exampleblock .content {     margin-top: auto; } blockquote {     border-left: 5px solid #eee;     color: #666;     font-size: 16px;     margin: 0;     padding: 10px 20px; } .attribution {     font-size: small;     text-align: right; } .table-responsive p { margin: 0 !important; } p.tableblock {   font-size: 14px;   margin: 0 !important; } table.tableblock { max-width: 100%; border-collapse: separate; } table.tableblock td > .paragraph:last-child p > p:last-child, table.tableblock th > p:last-child, table.tableblock td > p:last-child { margin-bottom: 0; }  table.tableblock, th.tableblock, td.tableblock { border: 0 solid #dddddd; }  table.grid-all th.tableblock, table.grid-all td.tableblock { border-width: 0 1px 1px 0; }  table.grid-all tfoot > tr > th.tableblock, table.grid-all tfoot > tr > td.tableblock { border-width: 1px 1px 0 0; }  table.grid-cols th.tableblock, table.grid-cols td.tableblock { border-width: 0 1px 0 0; }  table.grid-all * > tr > .tableblock:last-child, table.grid-cols * > tr > .tableblock:last-child { border-right-width: 0; }  table.grid-rows th.tableblock, table.grid-rows td.tableblock { border-width: 0 0 1px 0; }  table.grid-all tbody > tr:last-child > th.tableblock, table.grid-all tbody > tr:last-child > td.tableblock, table.grid-all thead:last-child > tr > th.tableblock, table.grid-rows tbody > tr:last-child > th.tableblock, table.grid-rows tbody > tr:last-child > td.tableblock, table.grid-rows thead:last-child > tr > th.tableblock { border-bottom-width: 0; }  table.grid-rows tfoot > tr > th.tableblock, table.grid-rows tfoot > tr > td.tableblock { border-width: 1px 0 0 0; }  table.frame-all { border-width: 1px; }  table.frame-sides { border-width: 0 1px; }  table.frame-topbot { border-width: 1px 0; }  th.halign-left, td.halign-left { text-align: left; }  th.halign-right, td.halign-right { text-align: right; }  th.halign-center, td.halign-center { text-align: center; }  th.valign-top, td.valign-top { vertical-align: top; }  th.valign-bottom, td.valign-bottom { vertical-align: bottom; }  th.valign-middle, td.valign-middle { vertical-align: middle; }  table thead th, table tfoot th { font-weight: bold; }  tbody tr th { display: table-cell; line-height: 1.4; background: whitesmoke; }  tbody tr th, tbody tr th p, tfoot tr th, tfoot tr th p { color: #222222; font-weight: bold; }  p.tableblock > code:only-child { background: none; padding: 0; }  table tr.even, table tr.alt, table tr:nth-of-type(2n) {     background: #f9f9f9 none repeat scroll 0 0; } div.table-responsive {  border: 0; }  .sql p {  font-family: courier; } </style><link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.2.0/css/font-awesome.min.css\"><div id=\"content\" class=\"blog-post-asciidoc\">  <div id=\"preamble\"><div class=\"sectionbody\"><div class=\"paragraph\"><p>It’s safe to say that any company who was writing software ten years ago—and is building <a href=\"http://martinfowler.com/articles/microservices.html\" target=\"_blank\">microservices</a> today—will need to integrate with <a href=\"https://en.wikipedia.org/wiki/Legacy_system\" target=\"_blank\">legacy systems</a>. In this article, we will explore building cloud-native microservices that still need to integrate with legacy systems. We’ll use practices from Martin Fowler’s <a href=\"http://www.martinfowler.com/bliki/StranglerApplication.html\" target=\"_blank\">Strangler Application</a> to slowly strangle domain data away from a legacy system using microservices.</p></div><div class=\"paragraph\"><p>When building microservices, the general approach is to take <a href=\"http://martinfowler.com/bliki/MonolithFirst.html\" target=\"_blank\">existing monoliths</a> and to decompose their components into new microservices. The most critical concerns in this method have much less to do with the application code and more to do with <em>handling data</em>. This article will focus on various methods of strangling a monolith’s ownership of domain data by transitioning the <a href=\"https://en.wikipedia.org/wiki/System_of_record\" target=\"_blank\">system of record</a> over time.</p></div><div class=\"paragraph\"><p>Throughout this article, we’ll use a <a href=\"https://github.com/kbastani/cloud-native-microservice-strangler-example\" target=\"_blank\">reference application</a> built with <a href=\"http://projects.spring.io/spring-boot/\" target=\"_blank\">Spring Boot</a> and <a href=\"http://projects.spring.io/spring-cloud/\" target=\"_blank\">Spring Cloud</a>. The example demonstrates techniques for integrating a cloud-native microservice architecture with legacy applications in an existing <a href=\"https://en.wikipedia.org/wiki/Service-oriented_architecture\" target=\"_blank\">SOA</a>.</p></div></div></div><div class=\"sect1\"><h2 id=\"_going_cloud_native\">Going Cloud Native</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p>Many companies want to start taking advantage of the public cloud without having to migrate every line of business application at the same time. The reasons for this are numerous. The existing line of business applications can be thought of as the vital organs of a living organism. During the migration, think about the complex relationships between the existing components deployed to your infrastructure. Think about the dependencies of your applications and the connections between them. Think about every application that relies on a database or network file system. These are among the many considerations that will cause a migration to become an expensive and time-consuming project.</p></div><div style=\"display: block; padding: inherit; max-width:30em;\" class=\"imageblock\"><div style=\"text-align: left; margin: auto;\" class=\"content\"><img style=\"margin: auto !important;\" src=\"http://i.imgur.com/cREaaaW.png\" alt=\"Hybrid cloud data center integration\"></div></div><div class=\"paragraph\"><p>The unfathomable complexity of migrating applications to the cloud can delay a decision from being made until the business deems necessary, which is usually triggered by a major event that results in a loss of revenue. This ticking time bomb will result in a <a href=\"http://searchcloudcomputing.techtarget.com/feature/When-to-adopt-the-lift-and-shift-cloud-migration-model\" target=\"_blank\"><em>lift-and-shift</em> migration</a> of applications. The problem with the lift and shift approach is that any technical debt that you had on-premises finds new life in the cloud environment. The problem being, the architectural and infrastructure issues that triggered the cloud migration still may not be fixed.</p></div><div class=\"paragraph\"><p>The approach I discuss in this article focuses on addressing the underlying symptoms of legacy systems that decrease system resiliency and lead to costly failures.</p></div></div></div><a name='more'></a><div class=\"sect1\"><h2 id=\"_legacy_systems\">Legacy Systems</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p>The chief benefit of building microservices is that the time it takes to deliver valuable features into production is significantly reduced. By creating microservices that are cloud-native, you can make use of on-demand virtual compute resources of the cloud to operate and scale your applications. Microservices provide agility while cloud-native architectures provide our distributed applications with additional performance, scalability, and resiliency characteristics.</p></div><div class=\"paragraph\"><p>To gain the benefit of agility with microservices, you may not be required to move some or even all of your existing applications to the cloud in a <a href=\"https://en.wikipedia.org/wiki/Big_bang_adoption\" target=\"_blank\">big bang migration</a>. There are <a href=\"https://en.wikipedia.org/wiki/Cloud_computing#Hybrid_cloud\" target=\"_blank\">hybrid approaches</a> that can enable you to begin transitioning your business logic to the cloud by creating cloud-native microservices that will strangle legacy systems that are still on-premises.</p></div><div class=\"paragraph\"><p>We can start by building microservices that are deployed to the public cloud and integrate with legacy systems that sit on-premises.</p></div></div></div><div class=\"sect1\"><h2 id=\"_data_ownership\">Data Ownership</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p>The most common pain point that companies experience when building microservices is handling <em>domain data</em>. Your domain data is likely going to be trapped inside a large shared database—probably being of the Oracle or IBM variety. Because of this, your new microservices will be dependent on retrieving data from a large shared database.</p></div><div class=\"paragraph\"><p>Refactoring your monoliths to microservices will take time. The data migration is going to be an immediate challenge, as parts of the monolith will involve access to data inside a large shared database. There are different approaches to managing this, depending on the severity of risk tolerable for the system.</p></div><div class=\"paragraph\"><p>Microservices can reach into the legacy system and fetch data in the same way that front-end applications do. While this isn’t a good long-term strategy, it can be an intermediate step in gaining control over the legacy backend.</p></div></div></div><div class=\"sect1\"><h2 id=\"_extending_domain_data\">Extending Domain Data</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p>One method for handling legacy data source integration for microservices is to extend domain data. In this approach, we gain the benefit of <em>agility</em> in microservices by extending base domain objects retrieved from a legacy system. Going back to the primary goal of building microservices, we’re doing it to gain <em>speed and agility</em> by being able to make changes quickly and having control to deploy changes to production continuously. We are still able to gain this benefit by extending domain data that can be retrieved from a legacy system.</p></div><div style=\"display: block; padding: inherit; max-width:26em;\" class=\"imageblock\"><div style=\"text-align: left; margin: auto;\" class=\"content\"><img style=\"margin: auto !important;\" src=\"http://i.imgur.com/qdXqYUl.png\" alt=\"Extending domain data\"></div></div><div class=\"paragraph\"><p>Suppose you’re developing software for a bank. You’ve been tasked with building a microservice that will wrap around an existing customer domain object. If you want to extend that customer object to include new fields for a feature, you can just persist the new fields of the customer object to the microservice’s database. Now when a customer domain object is requested through your microservice, a call to the legacy system will retrieve the base customer object, and any new extended fields are retrieved from your microservice’s database. The new fields are combined with the base customer object before being returned as a single domain object to consumers.</p></div><div class=\"paragraph\"><p>There are a few pros and cons to this approach.</p></div><div class=\"paragraph\"><p>Pros:</p></div><div class=\"ulist\"><ul><li><p>The legacy system does not need to be altered to support the development of new microservices</p></li><li><p>New features can be deployed independently without being tightly coupled to the legacy system</p></li><li><p>It ensures that any existing calls to a legacy web service are unaltered for other apps</p></li></ul></div><div class=\"paragraph\"><p>Cons:</p></div><div class=\"ulist\"><ul><li><p>Scalability may be a concern in the case that the base legacy service is not cloud-native</p></li><li><p>Availability will be impacted if the base legacy service’s shared database suffers an outage</p></li><li><p>The dependency on the legacy system’s shared database is increased, making it harder to decompose</p></li></ul></div></div></div><div class=\"sect1\"><h2 id=\"_legacy_soa_integration\">Legacy SOA Integration</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p>Eventually, the new features that extend the base customer object will need to be consumed by legacy applications. Any new applications that consume microservices will have the benefit of using newer libraries that provide REST clients to make integration relatively straightforward. The same will not be true for legacy applications. The existing legacy system needs to be able to consume the new microservices without having to upgrade an application framework, platform, or library.</p></div><div style=\"display: block; padding: inherit; max-width:24em;\" class=\"imageblock\"><div style=\"text-align: left; margin: auto;\" class=\"content\"><img style=\"margin: auto !important;\" src=\"http://i.imgur.com/7iz8pc1.png\" alt=\"Legacy SOAP web services and shared database\"></div></div><div class=\"paragraph\"><p>After a new microservice has been released—which <em>extends domain data</em> from the legacy system—we need to start migrating all applications to consume the new microservice. The benefit we gained with the extension approach was <em>agility</em> (and that’s good!), but we should be <em>decreasing</em> our reliance on a large shared database for the microservice approach. To do this, we need to create an application that will sit on the edge of our legacy system and provide integration services to legacy applications that need to consume data from our new microservices.</p></div><div style=\"display: block; padding: inherit; max-width:40em;\" class=\"imageblock\"><div style=\"text-align: left; margin: auto;\" class=\"content\"><img style=\"margin: auto !important;\" src=\"http://i.imgur.com/aG6qckH.png\" alt=\"Legacy edge service\"></div></div><div class=\"paragraph\"><p>To consume the new microservices from existing applications, you should think about limiting the amount of time spent on <a href=\"https://en.wikipedia.org/wiki/Software_modernization\" target=\"_blank\">legacy modernization</a>. Instead, there should be a focus on directing any available work cycles towards permanently reducing the risk per deployment—achieved by adopting a system that enables <em>deploying changes more often</em>. To support this goal, we can impose the following principles of integration for both legacy and microservices.</p></div><div class=\"ulist\"><ul><li><p>Legacy applications should be able to consume new microservices without being upgraded</p></li><li><p>Microservices should be <em>the only</em> direct consumer of existing legacy web services</p></li></ul></div><div class=\"paragraph\"><p>The Legacy Edge Service application will act as an adapter to support the expected contract and messaging protocols of existing legacy applications. The functions of the Legacy Edge Service will, in some ways, resemble functions and features that you would get from an <a href=\"https://en.wikipedia.org/wiki/Enterprise_service_bus\" target=\"_blank\">ESB (Enterprise Service Bus)</a>.</p></div><div class=\"sect2\"><h3 id=\"_the_dreaded_esb\">The Dreaded ESB</h3><div class=\"paragraph\"><p>The diagram below shows a view of the Customer Service connected to an ESB. This example is a familiar pattern of architecture for an SOA, where the ESB handles centralizing the integration concerns of applications.</p></div><div style=\"display: block; padding: inherit; max-width:30em;\" class=\"imageblock\"><div style=\"text-align: left; margin: auto;\" class=\"content\"><img style=\"margin: auto !important;\" src=\"http://i.imgur.com/0Y1ywRk.png\" alt=\"Legacy web services SOA and ESB\"></div></div><div class=\"paragraph\"><p>In this scenario, we would have already re-routed any point-to-point calls between web services through the ESB. The ESB acts as a gateway, router, and transport layer for orchestrating and composing larger business services from components existing as backend services. These larger composite business services are monoliths in the SOA that can be decomposed into microservices. There will also be front-end applications that consume the business services through the ESB. These applications will also need to be decomposed into microservices, where self-contained business logic or any ownership of domain data exists.</p></div><div class=\"paragraph\"><p>In this scenario, when new microservices are ready to start taking over ownership of domain data, we can use the ESB to switch incoming requests from the underlying service components to microservices.</p></div><div style=\"display: block; padding: inherit; max-width:30em;\" class=\"imageblock\"><div style=\"text-align: left; margin: auto;\" class=\"content\"><img style=\"margin: auto !important;\" src=\"http://i.imgur.com/cREaaaW.png\" alt=\"Legacy edge service ESB adapter\"></div></div><div class=\"paragraph\"><p>In the diagram above we see the Legacy Edge Service is providing adapter support to the ESB, which can be used to support any existing service orchestration or business process. As microservices begin replacing larger service units of the SOA, the ESB will switch traffic to the Legacy Edge Service and consume microservice routes that wrap around legacy web services that are being strangled.</p></div><div class=\"paragraph\"><p>It’s important that we can simply update the route configuration of existing legacy applications, making it possible to consume microservices without making source code changes. By doing this, we can defer modernizing legacy applications until they are ready to be refactored into microservices. The Legacy Edge Service provides this significant benefit.</p></div><div class=\"admonitionblock tip\"><table><tbody><tr><td class=\"icon\"><i class=\"fa icon-tip\" title=\"Tip\"></i></td><td class=\"content\">Spending time on legacy modernization is usually not a differentiator for the business. Instead, focus that engineering effort on tasks that help the business gain more agility—by <em>strangling</em> legacy applications with new microservices. </td></tr></tbody></table></div></div><div class=\"sect2\"><h3 id=\"_transferring_data_ownership\">Transferring Data Ownership</h3><div class=\"paragraph\"><p>After legacy consumers are re-routed to the Legacy Edge Service, the only consumer of a legacy web service component will be a microservice. Because of this, we are now able to <em>shift the system of record</em> safely for domain data retrieved from the legacy web services. With each unique request to a microservice that touches data in the legacy system, we can move ownership of that data to the new system of record—<em>our microservices</em>.</p></div><div class=\"paragraph\"><p>A microservice will transfer ownership of domain data by persisting the response from the legacy system to its exclusive database. Afterward, any subsequent request to the microservice for the same domain data will <em>not</em> require a call back to the legacy system. Utilizing this technique, we can slowly strangle the monolithic service components of the legacy system by transitioning the system of record for newly requested domain data.</p></div></div><div class=\"sect2\"><h3 id=\"_cloud_native_applications\">Cloud Native Applications</h3><div class=\"paragraph\"><p>As the volume of calls from microservices to the legacy system decreases over time, microservices can begin to take advantage of the other benefits of cloud-native architectures.</p></div><div class=\"paragraph\"><p>The approach here is similar to how web applications cache responses. We can consider for each call to the legacy system that we’re inevitably interacting with some <a href=\"https://en.wikipedia.org/wiki/Scalability#Horizontal_and_vertical_scaling\" target=\"_blank\">vertically scaled</a> infrastructure that has finite capacity. For each unique incoming request, we incur one hit on the legacy system, which can unfurl into many hits incurred on the vertically scaled infrastructure running on-premises. For every incoming non-unique request, we’ll incur one or more hit to cloud-native applications that are running on horizontally scaled infrastructure in the cloud. With this method, we’ll see the on-premises compute sharply drop off—<em>as more capacity is demanded</em>—in favor of <a href=\"https://en.wikipedia.org/wiki/Elasticity_(cloud_computing)\" target=\"_blank\">elastic compute</a> served from the public cloud.</p></div></div></div></div><div class=\"sect1\"><h2 id=\"_monolith_to_microservice\">Monolith to Microservice</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p>The method that I explained above came to me about a year after completing a greenfield microservices project on a similar architecture. The project would be a pilot for building microservices that would extend legacy components of a retail banking platform—a system that was already serving millions of users in production.</p></div><div class=\"paragraph\"><p>The result of the project was a success, as we realized the direct benefits of <a href=\"http://thenewstack.io/microservices-changed-matter/\" target=\"_blank\">being agile with the microservices approach</a>. While we were able to deliver business differentiating features quickly, our speed to market came at the cost of tightly coupling microservices to the existing components of the legacy system.</p></div><div class=\"paragraph\"><p>There were a few factors that required us to create this tight coupling.</p></div><div class=\"ulist\"><ul><li><p>We shackled ourselves into vertically scaled infrastructure provisioned in a private data center</p></li><li><p>We didn’t have a platform that supported cloud-native application development</p></li><li><p>We didn’t have a self-service tool in place to automate provisioning of databases for new microservices</p></li></ul></div><div class=\"paragraph\"><p>Because of these factors, we had to use the legacy system’s large shared database for persistence by our new microservices. We would use database access control features to isolate our microservice’s tables from being directly accessed by other applications. Even though these access features are for <a href=\"https://en.wikipedia.org/wiki/Multitenancy\" target=\"_blank\">multitenancy</a>, it would allow us to migrate the schema easily to a separate database at a later time.</p></div><div class=\"paragraph\"><p>The fundamental issue with this approach was that it took us seven months to get the first microservice release into production. The early dependency on the shared database posed too much of a risk of impacting millions of production users. We realized that risk when we discovered a framework defect that caused our new microservices to be unable to release database cursors when undergoing stress testing in the performance environment. The lesson learned in this experience was an important one.</p></div><div class=\"paragraph\"><p>A new microservice should encapsulate both the <em>unit of service</em> and the <em>unit of failure</em>—in production—on the very first day of development.</p></div><div class=\"paragraph\"><p>When I say <em>unit of service</em> and <em>unit of failure</em> I am referring to a quote by storied computer scientist, Jim Gray. Gray <a href=\"http://www.hpl.hp.com/techreports/tandem/TR-85.7.pdf\" target=\"_blank\">wrote a technical report</a> in 1985 titled <em>Why Do Computers Stop and What Can Be Done About It?</em></p></div><div class=\"paragraph\"><p>In the report, Gray talks about how to achieve fault-tolerance in software.</p></div><div class=\"quoteblock\"><blockquote>As with hardware, the key to software fault-tolerance is to hierarchically decompose large systems into modules, each module being a unit of service and a unit of failure. A failure of a module does not propagate beyond the module. </blockquote><div class=\"attribution\">— Jim Gray </div></div><div class=\"paragraph\"><p>When I hear thought leaders talk about microservices and say that the ideas are not new, I always think back to this quote by Jim.</p></div></div></div><div class=\"sect1\"><h2 id=\"_reference_architecture\">Reference Architecture</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p>The architecture for the reference application consists of multiple application layers deployed to infrastructure that is both on-premises and in the public cloud. This example works equally well when all your applications have been migrated to the cloud, but the reality is that this is almost never the case. We’ll assume throughout this example that the only viable path for you to adopt cloud-native microservices at your company is to go with a hybrid approach.</p></div><div style=\"display: block; padding: inherit; max-width:40em;\" class=\"imageblock\"><div style=\"text-align: left; margin: auto;\" class=\"content\"><img style=\"margin: auto !important;\" src=\"http://i.imgur.com/ZhuwpbZ.png\" alt=\"Example Cloud Native Strangler Microservice Architecture\"></div></div><div class=\"paragraph\"><p>The reference architecture in this diagram was modeled after a real world example of a hybrid cloud approach that uses <a href=\"https://en.wikipedia.org/wiki/Cloud_Foundry\" target=\"_blank\">Cloud Foundry</a> for operating cloud-native applications. The Cloud Foundry deployment uses a network bridge to connect to legacy systems deployed in a data center. Applications are categorized into different zones, which are deployed to infrastructure that is either in the public cloud or a data center.</p></div><div class=\"sect2\"><h3 id=\"_public_cloud\">Public Cloud</h3><div class=\"paragraph\"><p>Three zones represent applications deployed to the public cloud. These three areas separate applications into distinct categories. The difference between the zones has to do with how applications are located.</p></div><div class=\"ulist\"><ul><li><p>Public Internet – Front-end applications and public REST APIs</p></li><li><p>Platform Services – Managed cloud platform services</p></li><li><p>Service Discovery – Microservices that subscribe to a discovery service</p></li></ul></div><div class=\"paragraph\"><p>The <em>Public Internet Zone</em> uses routing from the cloud platform, requiring a server-side load balancer to route requests from the public internet to your applications.</p></div><div class=\"paragraph\"><p>The <em>Platform Services Zone</em> consists of services that are explicitly bound to applications deployed using the platform. The platform services are found through this relationship between platform and application.</p></div><div class=\"paragraph\"><p>The <em>Service Discovery Zone</em> consists of microservices that can only be discovered through the use of a discovery service. To locate other microservices, the platform provides a discovery service, which can be used to find the address of applications in the service discovery zone.</p></div></div><div class=\"sect2\"><h3 id=\"_data_center\">Data Center</h3><div class=\"paragraph\"><p>There is one zone in the data center, and that is the Legacy Application Zone. Microservices deployed in the public cloud will need to connect to web services deployed to infrastructure in this zone. While over time the business logic that exists in the legacy zone will be refactored into microservices, the migration of your domain data may require extracting and moving data that is stored in a large shared database. To solve this problem and keep the system online is similar to swapping out the engine of an airplane while still in flight.</p></div></div></div></div><div class=\"sect1\"><h2 id=\"_reference_applications\">Reference Applications</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p>The <a href=\"https://github.com/kbastani/cloud-native-microservice-strangler-example\" target=\"_blank\">source code</a> in this reference consists of eight separate applications. Each application in this example is built with Spring Boot and Spring Cloud.</p></div><div class=\"ulist\"><ul><li><p>Legacy Applications</p><div class=\"ulist\"><ul><li><p>Customer Service</p></li><li><p>Legacy Edge Service</p></li></ul></div></li><li><p>Microservices</p><div class=\"ulist\"><ul><li><p>Discovery Service</p></li><li><p>Edge Service</p></li><li><p>Config Service</p></li><li><p>User Service</p></li><li><p>Profile Service</p></li><li><p>Profile Web</p></li></ul></div></li></ul></div><div class=\"sect2\"><h3 id=\"_legacy_applications\">Legacy Applications</h3><div class=\"paragraph\"><p>The complexity of real world legacy systems will no doubt be more complicated than this scale model. This example application contains the minimum number of applications to demonstrate the strangler integration pattern.</p></div><div class=\"sect3\"><h4 id=\"_customer_service\">Customer Service</h4><div class=\"paragraph\"><p>The <em>Customer Service</em> is a Spring Boot application that simulates a typical SOA web service by exposing a single SOAP endpoint for retrieving a customer domain object.</p></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-java hljs\" data-lang=\"java\"><span class=\"hljs-annotation\">@Endpoint</span><br /><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CustomerEndpoint</span> </span>{<br />    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> String NAMESPACE_URI = <span class=\"hljs-string\">\"http://kennybastani.com/guides/customer-service\"</span>;<br /><br />    <span class=\"hljs-keyword\">private</span> CustomerRepository customerRepository;<br /><br />    <span class=\"hljs-annotation\">@Autowired</span><br />    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">CustomerEndpoint</span><span class=\"hljs-params\">(CustomerRepository customerRepository)</span> </span>{<br />        <span class=\"hljs-keyword\">this</span>.customerRepository = customerRepository;<br />    }<br /><br />    <span class=\"hljs-annotation\">@PayloadRoot</span>(namespace = NAMESPACE_URI, localPart = <span class=\"hljs-string\">\"getCustomerRequest\"</span>)<br />    <span class=\"hljs-annotation\">@ResponsePayload</span><br />    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> GetCustomerResponse <span class=\"hljs-title\">getCustomer</span><span class=\"hljs-params\">(@RequestPayload GetCustomerRequest request)</span> </span>{<br />        GetCustomerResponse response = <span class=\"hljs-keyword\">new</span> GetCustomerResponse();<br />        response.setCustomer(customerRepository.findCustomer(request.getUsername()));<br />        <span class=\"hljs-keyword\">return</span> response;<br />    }<br /><br />    <span class=\"hljs-annotation\">@PayloadRoot</span>(namespace = NAMESPACE_URI, localPart = <span class=\"hljs-string\">\"updateCustomerRequest\"</span>)<br />    <span class=\"hljs-annotation\">@ResponsePayload</span><br />    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> UpdateCustomerResponse <span class=\"hljs-title\">updateCustomer</span><span class=\"hljs-params\">(@RequestPayload UpdateCustomerRequest request)</span><br />            <span class=\"hljs-keyword\">throws</span> SOAPException </span>{<br />        UpdateCustomerResponse response = <span class=\"hljs-keyword\">new</span> UpdateCustomerResponse();<br />        response.setSuccess(customerRepository.updateCustomer(request.getCustomer()) &gt; <span class=\"hljs-number\">0</span>);<br />        <span class=\"hljs-keyword\">return</span> response;<br />    }<br />}</code></pre></div></div><div class=\"paragraph\"><p>The <code>CustomerEndpoint</code> has a <code>GetCustomer</code> method that is mapped to a SOAP request payload at <code>/v1/customers</code>. The input parameter for this request is simply the username of the customer. The username will be used to lookup the record from a \"large shared database\", which will be retrieved using <code>JdbcTemplate</code>.</p></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-java hljs\" data-lang=\"java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Customer <span class=\"hljs-title\">findCustomer</span><span class=\"hljs-params\">(String username)</span> </span>{<br />    Assert.notNull(username);<br /><br />    Customer result;<br /><br />    result = jdbcTemplate<br />            .query(<span class=\"hljs-string\">\"SELECT id, first_name, last_name, email, username FROM customer WHERE username = ?\"</span>,<br />                    <span class=\"hljs-keyword\">new</span> Object[]{username},<br />                    (rs, rowNum) -&gt; {<br />                        Customer customer = <span class=\"hljs-keyword\">new</span> Customer();<br />                        customer.setFirstName(rs.getString(<span class=\"hljs-string\">\"first_name\"</span>));<br />                        customer.setLastName(rs.getString(<span class=\"hljs-string\">\"last_name\"</span>));<br />                        customer.setEmail(rs.getString(<span class=\"hljs-string\">\"email\"</span>));<br />                        customer.setUsername(rs.getString(<span class=\"hljs-string\">\"username\"</span>));<br />                        <span class=\"hljs-keyword\">return</span> customer;<br />                    }).stream().findFirst().orElse(<span class=\"hljs-keyword\">null</span>);<br /><br />    <span class=\"hljs-keyword\">return</span> result;<br />}</code></pre></div></div><div class=\"paragraph\"><p>To retrieve a response from this service we will make a POST request of the content type <code>xml/text</code> to the endpoint <code>/v1/customers</code>.</p></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-xml hljs\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">soapenv:Envelope</span> <span class=\"hljs-attribute\">xmlns:soapenv</span>=<span class=\"hljs-value\">\"http://schemas.xmlsoap.org/soap/envelope/\"</span><br />                  <span class=\"hljs-attribute\">xmlns:gs</span>=<span class=\"hljs-value\">\"http://kennybastani.com/guides/customer-service\"</span>&gt;</span><br />   <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">soapenv:Header</span>/&gt;</span><br />   <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">soapenv:Body</span>&gt;</span><br />      <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">gs:getCustomerRequest</span>&gt;</span><br />         <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">gs:username</span>&gt;</span>user<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">gs:username</span>&gt;</span><br />      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">gs:getCustomerRequest</span>&gt;</span><br />   <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">soapenv:Body</span>&gt;</span><br /><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">soapenv:Envelope</span>&gt;</span></code></pre></div></div><div class=\"paragraph\"><p>An XML response is then returned from the SOAP request and looks like the following result.</p></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-xml hljs\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">SOAP-ENV:Envelope</span> <span class=\"hljs-attribute\">xmlns:SOAP-ENV</span>=<span class=\"hljs-value\">\"http://schemas.xmlsoap.org/soap/envelope/\"</span>&gt;</span><br />    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">SOAP-ENV:Header</span>/&gt;</span><br />    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">SOAP-ENV:Body</span>&gt;</span><br />        <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">ns2:getCustomerResponse</span> <span class=\"hljs-attribute\">xmlns:ns2</span>=<span class=\"hljs-value\">\"http://kennybastani.com/guides/customer-service\"</span>&gt;</span><br />            <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">ns2:customer</span>&gt;</span><br />                <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">ns2:username</span>&gt;</span>user<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">ns2:username</span>&gt;</span><br />                <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">ns2:firstName</span>&gt;</span>John<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">ns2:firstName</span>&gt;</span><br />                <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">ns2:lastName</span>&gt;</span>Doe<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">ns2:lastName</span>&gt;</span><br />                <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">ns2:email</span>&gt;</span>john.doe@example.com<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">ns2:email</span>&gt;</span><br />            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">ns2:customer</span>&gt;</span><br />        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">ns2:getCustomerResponse</span>&gt;</span><br />    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">SOAP-ENV:Body</span>&gt;</span><br /><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">SOAP-ENV:Envelope</span>&gt;</span></code></pre></div></div><div class=\"paragraph\"><p>The <em>Customer Service</em> here is simulating one of the most depended upon applications deployed on-premises. Simply modernizing this application will not solve the most important problem. The problem is that this service has to maintain expectations with mostly all critical applications that are running in production. Simply replacing this application with a microservice would mean updating every one of the applications that are depending on it.</p></div><div class=\"paragraph\"><p>To reduce the risk of disrupting applications relying on this service, we can start building a microservice that extends its customer object with new features. As legacy applications begin to be updated to use the new features of the microservice, we can create a <em>Legacy Edge</em> application that gives older applications a way to consume microservices without needing to modernize.</p></div></div><div class=\"sect3\"><h4 id=\"_legacy_edge_service\">Legacy Edge Service</h4><div class=\"paragraph\"><p>The <em>Legacy Edge Service</em> is an API gateway that maps requests from legacy applications to responses from microservices—while adhering to the messaging protocol expectations of the legacy consumers. This service will contain no business logic. The purpose of this service is vital to being able to rewire direct connections away from the <em>Customer Service</em>, so that we can safely transition the system of record for a customer’s domain data to a new microservice.</p></div><div style=\"display: block; padding: inherit; max-width:30em;\" class=\"imageblock\"><div style=\"text-align: left; margin: auto;\" class=\"content\"><img style=\"margin: auto !important;\" src=\"http://i.imgur.com/cREaaaW.png\" alt=\"Legacy edge microservice\"></div></div><div class=\"paragraph\"><p>Remember, we want to be able to make the switch as seamless as possible without performing any risky data migrations. This is the service that allows us to be able to do that.</p></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-java hljs\" data-lang=\"java\"><span class=\"hljs-annotation\">@Endpoint</span><br /><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CustomerEndpoint</span> </span>{<br />    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> String NAMESPACE_URI = <span class=\"hljs-string\">\"http://kennybastani.com/guides/customer-service\"</span>;<br /><br />    <span class=\"hljs-keyword\">private</span> OAuth2RestOperations restTemplate;<br /><br />    <span class=\"hljs-annotation\">@Autowired</span><br />    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">CustomerEndpoint</span><span class=\"hljs-params\">(OAuth2RestOperations oAuth2RestTemplate)</span> </span>{<br />        <span class=\"hljs-keyword\">this</span>.restTemplate = oAuth2RestTemplate;<br />    }<br /><br />    ...<br />}</code></pre></div></div><div class=\"paragraph\"><p>In the code snippet above, the <em>Legacy Edge Service</em> replicates the same SOAP endpoint as the <em>Customer Service</em>, with a few differences. There is a new microservice called the <em>Profile Service</em> that is protected with OAuth2 authorization. We should not expect that each of our legacy applications will be able to support the OAuth2 client specification without extensive changes. The legacy edge service will take care of these concerns for us.</p></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-java hljs\" data-lang=\"java\"><span class=\"hljs-annotation\">@PayloadRoot</span>(namespace = NAMESPACE_URI, localPart = <span class=\"hljs-string\">\"getCustomerRequest\"</span>)<br /><span class=\"hljs-annotation\">@ResponsePayload</span><br /><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> GetCustomerResponse <span class=\"hljs-title\">getCustomer</span><span class=\"hljs-params\">(@RequestPayload GetCustomerRequest request)</span> </span>{<br />    GetCustomerResponse response = <span class=\"hljs-keyword\">new</span> GetCustomerResponse();<br /><br />    <span class=\"hljs-comment\">// Get customer object from profile microservice</span><br />    response.setCustomer(Optional.ofNullable(<br />            restTemplate.getForObject(<span class=\"hljs-string\">\"http://profile-service/v1/profiles/{username}\"</span>,<br />                    Customer.class, request.getUsername()))<br />            .map(c -&gt; c).orElse(<span class=\"hljs-keyword\">null</span>));<br /><br />    <span class=\"hljs-keyword\">return</span> response;<br />}</code></pre></div></div><div class=\"paragraph\"><p>Here we see that the <em>Legacy Edge Service</em> uses the <em>Discovery Service</em> to make a request to an OAuth2 protected resource on the <em>Profile Service</em>. This microservice returns a <code>Profile</code> object, which is the extended domain object for <code>Customer</code>. The legacy edge service just translates the new <code>Profile</code> object to the expected <code>Customer</code> object and returns it as a SOAP response to consumers.</p></div><div class=\"paragraph\"><p>By providing this endpoint, no legacy applications will need to be upgraded. To start consuming microservices all we need to do is point a legacy application to the <code>Legacy Edge Service</code> instead of the <code>Customer Service</code>.</p></div><div class=\"paragraph\"><p>This example has a <a href=\"https://cloud.spring.io/spring-cloud-security/\" target=\"_blank\">Spring Cloud Security</a> OAuth2 resource and authorization server, which is a microservice named the <em>User Service</em>.</p></div><div class=\"paragraph\"><p>The <em>Legacy Edge Service</em> will use an authorization grant type of <code>client_credentials</code> to access the protected resources of a microservice. The beautiful thing about Spring Cloud Security is that each microservice will call back to the User Service to validate an access token before being granted with access to a protected resource. This process federated authorization for microservices is called <em>token relay</em>.</p></div><div class=\"paragraph\"><p>Any requests that come in from the public internet zone will need to authenticate using an authorization grant type of <code>authorization_code</code>. This grant type differs from <code>client_credentials</code> as it forces public internet users to authenticate through a provided login form before being granted an access token.</p></div><div class=\"paragraph\"><p>Since we cannot expect legacy applications to implement the OAuth2 workflow, the <code>Legacy Edge Service</code> uses the <code>client_credentials</code> grant type to request access tokens on behalf of the legacy system.</p></div></div></div><div class=\"sect2\"><h3 id=\"_microservices\">Microservices</h3><div class=\"paragraph\"><p>The microservices in this example are built using Spring Boot and Spring Cloud.</p></div><div class=\"sect3\"><h4 id=\"_discovery_service\">Discovery Service</h4><div class=\"paragraph\"><p>The <em>Discovery Service</em> is a platform service that maintains a service registry that is redistributed to applications in the <em>Service Discovery Zone</em>. For this example, we’ll stand up a <a href=\"https://spring.io/guides/gs/service-registration-and-discovery/\" target=\"_blank\">Eureka Server</a> from the Spring Cloud Netflix.</p></div><div style=\"display: block; padding: inherit; max-width:45em;\" class=\"imageblock\"><div style=\"text-align: left; margin: auto;\" class=\"content\"><img style=\"margin: auto !important;\" src=\"http://i.imgur.com/MRECAGD.png\" alt=\"Discovery service\"></div></div></div><div class=\"sect3\"><h4 id=\"_edge_service\">Edge Service</h4><div class=\"paragraph\"><p>The <em>Edge Service</em> is a platform service that uses the service registry from the <code>Discovery Service</code> to provide a public API gateway to the REST APIs exposed by the microservices. We’re using this <em>Edge Service</em> in a similar way as the <code>Legacy Edge Service</code>, but exposing it to the public internet zone. The <em>Edge Service</em> will compose each microservice into a single unified REST API that enforces the OAuth2 client specification. Any consumer of this service will be forced to use the <code>authorization_code</code> grant type, which requires user-level authentication.</p></div><div class=\"paragraph\"><p>For the <em>Edge Service</em>, we are again drawing from the Spring Cloud Netflix project to embed a <a href=\"https://spring.io/guides/gs/routing-and-filtering/\" target=\"_blank\">Zuul reverse proxy</a> that acts as a single gateway to each microservice. For front-end applications, we can bind to this <em>Edge Service</em> and use it as a single REST API that provides endpoints for every independent microservice.</p></div><div style=\"display: block; padding: inherit; max-width:45em;\" class=\"imageblock\"><div style=\"text-align: left; margin: auto;\" class=\"content\"><img style=\"margin: auto !important;\" src=\"http://i.imgur.com/FQvktwv.png\" alt=\"Edge service\"></div></div></div><div class=\"sect3\"><h4 id=\"_user_service\">User Service</h4><div class=\"paragraph\"><p>The <em>User Service</em> is a platform service that contains an OAuth2 authorization and resource server for accessing any protected resources of our microservices. The <em>User Service</em> will manage and secure how all consumers can access resources from our microservices. Here we are using Spring Cloud Security OAuth2 to issue and validate access tokens for each microservice. The added benefit of using Spring Cloud Security is that access tokens will be relayed in requests microservice-to-microservice, securing an entire chain of requests for resources as a feature of the application framework.</p></div><div style=\"display: block; padding: inherit; max-width:45em;\" class=\"imageblock\"><div style=\"text-align: left; margin: auto;\" class=\"content\"><img style=\"margin: auto !important;\" src=\"http://i.imgur.com/dbZDivd.png\" alt=\"User service\"></div></div></div><div class=\"sect3\"><h4 id=\"_profile_service\">Profile Service</h4><div class=\"paragraph\"><p>The <em>Profile Service</em> is a microservice that extends the domain data of the legacy <em>Customer Service</em>. This is the microservice that is strangling the domain data of the <em>Customer Service</em>—and in the process—slowly transitioning the system of record away from the <em>large shared database</em> in the legacy system. The <em>Profile Service</em> exposes protected domain resources as a REST API, using the Spring Cloud Security project to implement the OAuth2 client workflow.</p></div><div style=\"display: block; padding: inherit; max-width:45em;\" class=\"imageblock\"><div style=\"text-align: left; margin: auto;\" class=\"content\"><img style=\"margin: auto !important;\" src=\"http://i.imgur.com/6A9vwLr.png\" alt=\"Profile service\"></div></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-java hljs\" data-lang=\"java\"><span class=\"hljs-annotation\">@RestController</span><br /><span class=\"hljs-annotation\">@RequestMapping</span>(path = <span class=\"hljs-string\">\"/v1\"</span>)<br /><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ProfileControllerV1</span> </span>{<br /><br />    <span class=\"hljs-keyword\">private</span> ProfileServiceV1 profileService;<br /><br />    <span class=\"hljs-annotation\">@Autowired</span><br />    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">ProfileControllerV1</span><span class=\"hljs-params\">(ProfileServiceV1 profileService)</span> </span>{<br />        <span class=\"hljs-keyword\">this</span>.profileService = profileService;<br />    }<br /><br />    <span class=\"hljs-annotation\">@RequestMapping</span>(path = <span class=\"hljs-string\">\"/profiles/{username}\"</span>, method = RequestMethod.GET)<br />    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> ResponseEntity <span class=\"hljs-title\">getProfile</span><span class=\"hljs-params\">(@PathVariable String username)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{<br />        <span class=\"hljs-keyword\">return</span> Optional.ofNullable(profileService.getProfile(username))<br />                .map(a -&gt; <span class=\"hljs-keyword\">new</span> ResponseEntity&lt;&gt;(a, HttpStatus.OK))<br />                .orElseThrow(() -&gt; <span class=\"hljs-keyword\">new</span> Exception(<span class=\"hljs-string\">\"Profile for user does not exist\"</span>));<br />    }<br /><br />    <span class=\"hljs-annotation\">@RequestMapping</span>(path = <span class=\"hljs-string\">\"/profiles/{username}\"</span>, method = RequestMethod.POST)<br />    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> ResponseEntity <span class=\"hljs-title\">updateProfile</span><span class=\"hljs-params\">(@RequestBody Profile profile)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{<br />        <span class=\"hljs-keyword\">return</span> Optional.ofNullable(profileService.updateProfile(profile))<br />                .map(a -&gt; <span class=\"hljs-keyword\">new</span> ResponseEntity&lt;&gt;(a, HttpStatus.OK))<br />                .orElseThrow(() -&gt; <span class=\"hljs-keyword\">new</span> Exception(<span class=\"hljs-string\">\"Profile for user does not exist\"</span>));<br />    }<br />}</code></pre></div></div><div class=\"paragraph\"><p>In the code snippet above we see the <code>ProfileControllerV1</code> class, which is a REST controller that provides an endpoint for retrieving the <code>Profile</code> of a user. The <code>Profile</code> object we are retrieving here will extend fields from the <code>Customer</code> object, after retrieving domain data from the legacy <em>Customer Service</em>. To do this, we will call directly to the <em>Customer Service</em> in the legacy application zone using a SOAP client.</p></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-java hljs\" data-lang=\"java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CustomerClient</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">WebServiceGatewaySupport</span> </span>{<br /><br />    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> Logger log = LoggerFactory.getLogger(CustomerClient.class);<br /><br />    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> String ROOT_NAMESPACE = <span class=\"hljs-string\">\"http://kennybastani.com/guides/customer-service/\"</span>;<br />    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> String GET_CUSTOMER_NAMESPACE = <span class=\"hljs-string\">\"getCustomerRequest\"</span>;<br />    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> String UPDATE_CUSTOMER_NAMESPACE = <span class=\"hljs-string\">\"updateCustomerRequest\"</span>;<br /><br />    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> GetCustomerResponse <span class=\"hljs-title\">getCustomerResponse</span><span class=\"hljs-params\">(String username)</span> </span>{<br />      ...<br />    }<br /><br />    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> UpdateCustomerResponse <span class=\"hljs-title\">updateCustomerResponse</span><span class=\"hljs-params\">(Profile profile)</span> </span>{<br />      ...<br />    }<br />}</code></pre></div></div><div class=\"paragraph\"><p>In the snippet above we find the definition of the <code>CustomerClient</code>. This class will provide the <em>Profile Service</em> with a capable SOAP client that can retrieve a <code>Customer</code> record from the legacy <code>Customer Service</code>. We’ll use this client from the <code>ProfileServiceV1</code> class below to retrieve the <code>Customer</code> domain data that we will be extending in the <code>Profile</code> object.</p></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-java hljs\" data-lang=\"java\"><span class=\"hljs-annotation\">@Service</span><br /><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ProfileServiceV1</span> </span>{<br /><br />    <span class=\"hljs-keyword\">private</span> ProfileRepository profileRepository;<br />    <span class=\"hljs-keyword\">private</span> CustomerClient customerClient;<br /><br />    <span class=\"hljs-annotation\">@Autowired</span><br />    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">ProfileServiceV1</span><span class=\"hljs-params\">(ProfileRepository profileRepository, CustomerClient customerClient)</span> </span>{<br />        <span class=\"hljs-keyword\">this</span>.profileRepository = profileRepository;<br />        <span class=\"hljs-keyword\">this</span>.customerClient = customerClient;<br />    }<br /><br />    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Profile <span class=\"hljs-title\">getProfile</span><span class=\"hljs-params\">(String username)</span> </span>{<br />        ...<br />    }<br /><br />    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Profile <span class=\"hljs-title\">updateProfile</span><span class=\"hljs-params\">(Profile profile)</span> </span>{<br />        ...<br />    }<br />}</code></pre></div></div><div class=\"paragraph\"><p>The code snippet above contains the definition of the <code>ProfileServiceV1</code> class. This bean will conditionally call the legacy <em>Customer Service</em> by making a SOAP request from the <code>CustomerClient</code>. The <code>getProfile</code> method is called by the <code>ProfileControllerV1</code> class, returning a <code>Profile</code> object that extends domain data from the legacy <code>Customer</code> object.</p></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-java hljs\" data-lang=\"java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Profile <span class=\"hljs-title\">getProfile</span><span class=\"hljs-params\">(String username)</span> </span>{<br /><br />    <span class=\"hljs-comment\">// Check for the profile record</span><br />    Profile profile = profileRepository.getProfileByUsername(username);<br /><br />    <span class=\"hljs-comment\">// If the profile does not exist in the repository, import it from the SOAP service</span><br />    <span class=\"hljs-keyword\">if</span> (profile == <span class=\"hljs-keyword\">null</span>) {<br />        <span class=\"hljs-comment\">// Request the customer record from the legacy customer SOAP service</span><br />        profile = Optional.ofNullable(customerClient.getCustomerResponse(username)<br />                .getCustomer())<br />                .map(p -&gt; <span class=\"hljs-keyword\">new</span> Profile(p.getFirstName(), p.getLastName(),<br />                        p.getEmail(), p.getUsername()))<br />                .orElseGet(<span class=\"hljs-keyword\">null</span>);<br /><br />        <span class=\"hljs-keyword\">if</span> (profile != <span class=\"hljs-keyword\">null</span>) {<br />            <span class=\"hljs-comment\">// Migrate the system of record for the profile to this microservice</span><br />            profile = profileRepository.save(profile);<br />        }<br />    }<br /><br />    <span class=\"hljs-keyword\">return</span> profile;<br />}</code></pre></div></div><div class=\"paragraph\"><p>As a part of this workflow, the <em>Profile Service</em> looks to its attached MySQL database using the <code>ProfileRepository</code> to find a <code>Profile</code> record with <code>username</code> as the lookup key. If the <code>Profile</code> for the requested user does not exist in the database, a request to retrieve the <code>Customer</code> object is made to the <em>Customer Service</em>. If the <em>Customer Service</em> returns a <code>Customer</code> record in the response, the base domain data returned from the legacy <em>Customer Service</em> will be used to construct a new <code>Profile</code> record, which is consequently saved by the <em>Profile Service</em> to the attached MySQL database.</p></div><div class=\"paragraph\"><p>Using this workflow, the <em>Profile Service</em> only needs to call the legacy system <em>once</em> for each <code>Profile</code> that is requested. Since we’ve re-routed all requests from other legacy applications to use the <em>Legacy Edge Service</em>, we can safely transition the system of record for domain data away from the legacy <em>Customer Service</em> without performing any risky database migrations. Further, to support backward compatibility in the \"large shared database\", we can replicate any updates to the base <code>Customer</code> domain data by scheduling tasks asynchronously to call the <em>Customer Service</em> when a change is made to a <code>Profile</code>.</p></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-java hljs\" data-lang=\"java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Profile <span class=\"hljs-title\">updateProfile</span><span class=\"hljs-params\">(Profile profile)</span> <span class=\"hljs-keyword\">throws</span> IOException </span>{<br /><br />    Assert.notNull(profile);<br /><br />    <span class=\"hljs-comment\">// Get current authenticated user</span><br />    User user = oAuth2RestTemplate.getForObject(<span class=\"hljs-string\">\"http://user-service/uaa/v1/me\"</span>, User.class);<br /><br />    <span class=\"hljs-comment\">// Get current profile</span><br />    Profile currentProfile = getProfile(user.getUsername());<br /><br />    <span class=\"hljs-keyword\">if</span> (currentProfile != <span class=\"hljs-keyword\">null</span>) {<br />        <span class=\"hljs-keyword\">if</span> (currentProfile.getUsername().equals(profile.getUsername())) {<br />            <span class=\"hljs-comment\">// Save the profile</span><br />            profile.setId(currentProfile.getId());<br />            profile.setCreatedAt(currentProfile.getCreatedAt());<br />            profile = profileRepository.save(profile);<br /><br />            <span class=\"hljs-comment\">// Replicate the write to the legacy customer service</span><br />            amqpTemplate.convertAndSend(<span class=\"hljs-string\">\"customer.update\"</span>,<br />                    <span class=\"hljs-keyword\">new</span> ObjectMapper().writeValueAsString(profile));<br />        }<br />    }<br /><br />    <span class=\"hljs-keyword\">return</span> profile;<br />}</code></pre></div></div><div class=\"paragraph\"><p>The snippet above is the implementation of <code>updateProfile</code>. In this method we are receiving a request to update the profile of a user. The first step is to ensure that the profile being modified is the user who is currently authenticated. To make sure that only a user that owns the profile can update the domain resource, we check to see if the requested change is different from the profile of the authenticated user.</p></div><div class=\"admonitionblock warning\"><table><tbody><tr><td class=\"icon\"><i class=\"fa icon-warning\" title=\"Warning\"></i></td><td class=\"content\">To support backward compatibility with the legacy system, we’ll need to support a different workflow for validating the authenticated user, since the Legacy Edge Service uses <code>client_credentials</code> for authorization. </td></tr></tbody></table></div><div class=\"paragraph\"><p>After updating the profile, we need to replicate the write back to the customer service. To make sure that the cloud-native application is able to scale writes without dependency on the legacy system, we want to be able to durably replicate the write in an async workflow. By sending a durable message to a RabbitMQ queue, we can use the Profile Service to send back updates to the Customer Service asynchronously without tying up thread and memory resources of the web server.</p></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-java hljs\" data-lang=\"java\"><span class=\"hljs-annotation\">@RabbitListener</span>(queues = {<span class=\"hljs-string\">\"customer.update\"</span>})<br /><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">updateCustomer</span><span class=\"hljs-params\">(String message)</span> <span class=\"hljs-keyword\">throws</span> InterruptedException, IOException </span>{<br />    Profile profile = objectMapper.readValue(message, Profile.class);<br /><br />    <span class=\"hljs-keyword\">try</span> {<br />        <span class=\"hljs-comment\">// Update the customer service for the profile</span><br />        UpdateCustomerResponse response =<br />                customerClient.updateCustomerResponse(profile);<br /><br />        <span class=\"hljs-keyword\">if</span> (!response.isSuccess()) {<br />            String errorMsg =<br />                    String.format(<span class=\"hljs-string\">\"Could not update customer from profile for %s\"</span>,<br />                            profile.getUsername());<br />            log.error(errorMsg);<br />            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> UnexpectedException(errorMsg);<br />        }<br />    } <span class=\"hljs-keyword\">catch</span> (Exception ex) {<br />        <span class=\"hljs-comment\">// Throw AMQP exception and redeliver the message</span><br />        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> AmqpIllegalStateException(<span class=\"hljs-string\">\"Customer service update failed\"</span>, ex);<br />    }<br />}</code></pre></div></div><div class=\"paragraph\"><p>The snippet above is our message listener on the Profile Service that will asynchronously issue writes back to the Customer Service in the legacy system. Since the network is prone to failure, this workflow ensures that there will be no loss of data since the RabbitMQ message can only be acknowledged after an attempt to update the Customer Service was a success.</p></div></div></div><div class=\"sect2\"><h3 id=\"_profile_web\">Profile Web</h3><div class=\"paragraph\"><p>The <em>Profile Web</em> microservice is a front-end Spring Boot application that houses the static content of an AngularJS website. The <em>Profile Web</em> application will bind to the <em>Edge Service</em> and embed its API gateway using Spring Cloud Netflix’s Zuul as a reverse proxy. By embedding the <em>Edge Service</em> into the <em>Profile Application</em>, the client-side JavaScript of the AngularJS website will not need to request resources from a separate domain. The <em>Edge Service</em> will be made available as an endpoint at <code>/api/**</code>.</p></div></div></div></div><div class=\"sect1\"><h2 id=\"_running_the_example\">Running the Example</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p>There are two ways to run the reference application, with either Docker Compose or Cloud Foundry, the latter of which can be installed on a development machine using <a href=\"https://docs.pivotal.io/pcf-dev/\" target=\"_blank\">PCF Dev</a>. Since the distributed application is designed to be cloud-native, there is a lot to be gained from understanding how to deploy the example using Cloud Foundry.</p></div><div class=\"paragraph\"><p>The source code for the reference application is available on GitHub at <a href=\"https://github.com/kbastani/cloud-native-microservice-strangler-example\" target=\"_blank\">https://github.com/kbastani/cloud-native-microservice-strangler-example</a>. Clone the repository and run the example using the directions below.</p></div><div class=\"sect2\"><h3 id=\"_docker_compose\">Docker Compose</h3><div class=\"paragraph\"><p>To run the example using Docker Compose, a <code>run.sh</code> script is provided which will orchestrate the startup of each application. Since the example will run 8 applications and multiple backing services, it’s necessary to have at least 9GB of memory allocated to Docker.</p></div><div class=\"admonitionblock warning\"><table><tbody><tr><td class=\"icon\"><i class=\"fa icon-warning\" title=\"Warning\"></i></td><td class=\"content\">The <code>run.sh</code> script is designed to use Docker Machine, so if you’re using Docker for Mac, you’ll need to modify the <code>run.sh</code> script by setting <code>DOCKER_IP</code> to <code>localhost</code>. </td></tr></tbody></table></div></div><div class=\"sect2\"><h3 id=\"_cloud_foundry\">Cloud Foundry</h3><div class=\"paragraph\"><p>To run the example using Cloud Foundry, a <code>deploy.sh</code> script is provided which will orchestrate the deployment of each application to a simulated cloud-native environment. If you have enough resources available, you can deploy the example on <a href=\"http://run.pivotal.io\" target=\"_blank\">Pivotal Web Services</a>. If you’re new to Cloud Foundry, it’s highly recommended that you go with the PCF Dev approach, which you can install by following the directions at <a href=\"https://docs.pivotal.io/pcf-dev/\" target=\"_blank\">https://docs.pivotal.io/pcf-dev/</a>.</p></div><div class=\"paragraph\"><p>When you have a CF environment to deploy the example, go ahead and run the <code>deploy.sh</code> script in the parent directory of the project. The bash script is commented enough for most to understand the steps of the deployment. Each Cloud Foundry deployment manifest is located in the directory of the application and is named <code>manifest.yml</code>. The script will deploy the Spring Cloud backing services first, and afterward, each microservice will be deployed one by one until each application is running.</p></div></div><div class=\"sect2\"><h3 id=\"_managing_profiles\">Managing Profiles</h3><div class=\"paragraph\"><p>While the example project contains 8 separate applications, the only front-end application is the <em>Profile Web</em> microservice. If you’re running the example on PCF Dev, you can access the Eureka dashboard at <a href=\"http://discovery-service.local.pcfdev.io/\" target=\"_blank\">http://discovery-service.local.pcfdev.io/</a>.</p></div><div style=\"display: block; padding: inherit; max-width:45em;\" class=\"imageblock\"><div style=\"text-align: left; margin: auto;\" class=\"content\"><img style=\"margin: auto !important;\" src=\"http://i.imgur.com/qAaPHGt.png\" alt=\"Eureka Dashboard\"></div></div><div class=\"paragraph\"><p>If the applications listed in the Eureka dashboard looks like the example above, then the deployment was successful. To access the <em>Profile Web</em> application, go to <a href=\"http://profile-web.local.pcfdev.io/\" target=\"_blank\">http://profile-web.local.pcfdev.io/</a>. You’ll be immediately redirected to the OAuth2 gateway’s login form on the <em>User Service</em>.</p></div><div style=\"display: block; padding: inherit; max-width:45em;\" class=\"imageblock\"><div style=\"text-align: left; margin: auto;\" class=\"content\"><img style=\"margin: auto !important;\" src=\"http://i.imgur.com/Lj4J8Me.png\" alt=\"OAuth2 user login\"></div></div><div class=\"paragraph\"><p>The <em>User Service</em> is only configured to allow one user to sign-in. To login, use the very secure credentials of <strong>user</strong> and <strong>password</strong>, and you’ll be redirected back to the <em>Profile Web</em> application.</p></div><div style=\"display: block; padding: inherit; max-width:45em;\" class=\"imageblock\"><div style=\"text-align: left; margin: auto;\" class=\"content\"><img style=\"margin: auto !important;\" src=\"http://i.imgur.com/EMFqm0e.png\" alt=\"Manage profile\"></div></div><div class=\"paragraph\"><p>The <em>Profile Web</em> application will then allow you to update the current user’s profile information. Going back to earlier when we talked about the workflow for getting the profile information from the <em>Customer Service</em>, by the time the data is loaded, the workflow is complete. The <em>Profile Web</em> application will call the <em>Profile Service</em> through the embedded <em>Edge Service</em> application’s API gateway. The <em>Profile Service</em> will then check to see if the user’s profile information is stored in its database. If the data is unavailable, it will call the <em>Customer Service</em> using the SOAP client and then import the profile information by saving it to its database.</p></div><div class=\"paragraph\"><p>Now that the domain data has been migrated from the <em>Customer Service</em>, we need to verify that any updates from the <em>Profile Web</em> application find their way back into the legacy application’s shared database. To verify this, go ahead and update the fields on the <em>Profile Web</em> application’s UI.</p></div><div style=\"display: block; padding: inherit; max-width:45em;\" class=\"imageblock\"><div style=\"text-align: left; margin: auto;\" class=\"content\"><img style=\"margin: auto !important;\" src=\"http://i.imgur.com/S31zA7g.png\" alt=\"Update profile\"></div></div><div class=\"paragraph\"><p>Here I’ve updated the default user to my own profile information, and the result was successful. To verify that the legacy system is in sync with the microservices, we can send an HTTP SOAP request to the <em>Customer Service</em>.</p></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-xml hljs\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">soapenv:Envelope</span> <span class=\"hljs-attribute\">xmlns:soapenv</span>=<span class=\"hljs-value\">\"http://schemas.xmlsoap.org/soap/envelope/\"</span><br />      <span class=\"hljs-attribute\">xmlns:gs</span>=<span class=\"hljs-value\">\"http://kennybastani.com/guides/customer-service\"</span>&gt;</span><br />   <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">soapenv:Header</span>/&gt;</span><br />   <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">soapenv:Body</span>&gt;</span><br />      <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">gs:getCustomerRequest</span>&gt;</span><br />         <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">gs:username</span>&gt;</span>user<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">gs:username</span>&gt;</span><br />      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">gs:getCustomerRequest</span>&gt;</span><br />   <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">soapenv:Body</span>&gt;</span><br /><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">soapenv:Envelope</span>&gt;</span></code></pre></div></div><div class=\"paragraph\"><p>Using a REST client, send a POST request with the XML snippet above to the Customer Service at <a href=\"http://customer-service.local.pcfdev.io/v1/customers/user\">http://customer-service.local.pcfdev.io/v1/customers/user</a>.</p></div><div class=\"admonitionblock tip\"><table><tbody><tr><td class=\"icon\"><i class=\"fa icon-tip\" title=\"Tip\"></i></td><td class=\"content\">The REST client that you will use needs to send the POST request with a content type of <code>xml/text</code>, since the legacy service uses SOAP as the messaging protocol. </td></tr></tbody></table></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-xml hljs\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">SOAP-ENV:Envelope</span> <span class=\"hljs-attribute\">xmlns:SOAP-ENV</span>=<span class=\"hljs-value\">\"http://schemas.xmlsoap.org/soap/envelope/\"</span>&gt;</span><br />    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">SOAP-ENV:Header</span>/&gt;</span><br />    <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">SOAP-ENV:Body</span>&gt;</span><br />        <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">ns2:getCustomerResponse</span> <span class=\"hljs-attribute\">xmlns:ns2</span>=<span class=\"hljs-value\">\"http://kennybastani.com/guides/customer-service\"</span>&gt;</span><br />            <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">ns2:customer</span>&gt;</span><br />                <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">ns2:username</span>&gt;</span>user<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">ns2:username</span>&gt;</span><br />                <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">ns2:firstName</span>&gt;</span>Kenny<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">ns2:firstName</span>&gt;</span><br />                <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">ns2:lastName</span>&gt;</span>Bastani<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">ns2:lastName</span>&gt;</span><br />                <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">ns2:email</span>&gt;</span>kenny.bastani@example.com<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">ns2:email</span>&gt;</span><br />            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">ns2:customer</span>&gt;</span><br />        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">ns2:getCustomerResponse</span>&gt;</span><br />    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">SOAP-ENV:Body</span>&gt;</span><br /><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">SOAP-ENV:Envelope</span>&gt;</span></code></pre></div></div><div class=\"paragraph\"><p>You should see something similar to the response above. The <em>Customer Service</em> has no awareness of the new <em>Profile Service</em> and will only return back a response from the large database that it shares with other legacy applications.</p></div></div></div></div><div class=\"sect1\"><h2 id=\"_conclusion\">Conclusion</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p>Now that we’ve explored the reference application, there are a few extra things to be mindful of as you tackle the challenges that come with implementing this hybrid microservice approach. One concern is that the legacy system will still need to be able to mirror any updates to domain data from new microservices. To do this, we used a RabbitMQ message broker that can durably store ordered messages and asynchronously apply updates back to the legacy system. This method will be eventually consistent, which requires additional scrutiny when it comes to handling state.</p></div><div class=\"sect3\"><h4 id=\"_be_mindful_of_state\">Be mindful of state</h4><div class=\"paragraph\"><p>Some domain objects will come from the legacy system that will contain stateful properties. It’s much safer to migrate domain data that is stateless—but in reality, that’s an uncommon occurrence. Any field of an object that represents state will have a dependency on business logic. That’s an important consideration with this approach, so be mindful of the following.</p></div><div class=\"ulist\"><ul><li><p>Never deploy a new feature without ensuring backward compatibility with the legacy system</p></li><li><p>Identify fields sourced from the legacy system that represents state</p></li><li><p>Never store state as fields in microservices—store state as events</p></li></ul></div></div><div class=\"sect3\"><h4 id=\"_be_mindful_of_consistency\">Be mindful of consistency</h4><div class=\"paragraph\"><p>To be successful with this method and make the minimum amount of changes to the legacy system, you’ll need to replicate updates to domain data durably back to the legacy system. With microservices we need to embrace eventual consistency, so be mindful of the following.</p></div><div class=\"ulist\"><ul><li><p>Respect foreign key relationships in a monolith’s database</p></li><li><p>Work to decouple table constraints that block updates through a legacy web service</p></li><li><p>Move all legacy field validators (including database constraints) into your microservices</p></li><li><p>Make sure updates sent to a legacy service from a microservice are always able to succeed eventually</p></li></ul></div></div><div class=\"sect3\"><h4 id=\"_be_mindful_of_observability\">Be mindful of observability</h4><div class=\"paragraph\"><p>You can’t fix what you can’t measure. From the first day you’re in production, you should have maximal visibility into how your microservices are handling data capture from the legacy system. To increase observability, keep the following considerations in mind.</p></div><div class=\"ulist\"><ul><li><p>Monitor for failures during an attempt to update the legacy system from a microservice</p></li><li><p>Be quick to analyze and remediate failures that are blocking a microservice from replicating updates to the legacy system</p></li></ul></div></div><div class=\"sect3\"><h4 id=\"_be_mindful_of_resiliency\">Be mindful of resiliency</h4><div class=\"paragraph\"><p>Always account for the inevitable failures that will come with the first few iterations of integrating your new microservice with the legacy system. Use circuit breakers in <a href=\"https://cloud.spring.io/spring-cloud-netflix/\" target=\"_blank\">Spring Cloud Netflix</a> to create fallback plans that temporarily escalate the privilege of your microservice to be able to interact safely with a legacy data source in the event of repeated failure.</p></div><div class=\"ulist\"><ul><li><p>Make sure to provide mechanisms to override unknown constraints that block updates to the legacy system</p></li><li><p>Build in escalated fallback measures in the case that a microservice repeatedly fails to update a legacy data source</p></li><li><p>Make sure to performance test connecting to a shared database from your microservice in any fallback scenario</p></li><li><p>Spare no effort to prevent data loss by persisting any changes scheduled for the legacy system into durable storage</p></li></ul></div></div></div></div>   </div>",
  "link": "https://www.kennybastani.com/2016/08/strangling-legacy-microservices-spring-cloud.html",
  "author": "noreply@blogger.com (Kenny Bastani)",
  "thr:total": 0
}