{
  "title": "Logistic Regression",
  "link": "",
  "published": "2017-07-29T19:10:00-07:00",
  "updated": "2017-07-29T19:10:00-07:00",
  "author": {
    "name": "Jonathan Landy"
  },
  "id": "tag:efavdb.com,2017-07-29:/logistic-regression",
  "summary": "<p>We review binary logistic regression. In particular, we derive a) the equations needed to fit the algorithm via gradient descent, b) the maximum likelihood fit&#8217;s asymptotic coefficient covariance matrix, and c) expressions for model test point class membership probability confidence intervals. We also provide python code implementing a minimal …</p>",
  "content": "<p>We review binary logistic regression. In particular, we derive a) the equations needed to fit the algorithm via gradient descent, b) the maximum likelihood fit&#8217;s asymptotic coefficient covariance matrix, and c) expressions for model test point class membership probability confidence intervals. We also provide python code implementing a minimal &#8220;LogisticRegressionWithError&#8221; class whose &#8220;predict_proba&#8221; method returns prediction confidence intervals alongside its point&nbsp;estimates.</p>\n<p>Our python code can be downloaded from our github page, <a href=\"https://github.com/EFavDB/logistic-regression-with-error\">here</a>. Its use requires the jupyter, numpy, sklearn, and matplotlib&nbsp;packages.</p>\n<h3>Introduction</h3>\n<p>The logistic regression model is a linear classification model that can be used to fit binary data &#8212; data where the label one wishes to predict can take on one of two values &#8212; e.g., <span class=\"math\">\\(0\\)</span> or <span class=\"math\">\\(1\\)</span>. Its linear form makes it a convenient choice of model for fits that are required to be interpretable. Another of its virtues is that it can &#8212; with relative ease &#8212; be set up to return both point estimates and also confidence intervals for test point class membership probabilities. The availability of confidence intervals allows one to flag test points where the model prediction is not precise, which can be useful for some applications &#8212; eg fraud&nbsp;detection.</p>\n<p>In this note, we derive the expressions needed to fit the logistic model to a training data set. We assume the training data consists of a set of <span class=\"math\">\\(n\\)</span> feature vector- label pairs, <span class=\"math\">\\(\\{(\\vec{x}_i, y_i)\\)</span>, for <span class=\"math\">\\(i = 1, 2, \\ldots, n\\}\\)</span>, where the feature vectors <span class=\"math\">\\(\\vec{x}_i\\)</span> belong to some <span class=\"math\">\\(m\\)</span>-dimensional space and the labels are binary, <span class=\"math\">\\(y_i \\in \\{0, 1\\}.\\)</span> The logistic model states that the probability of belonging to class <span class=\"math\">\\(1\\)</span> is given&nbsp;by\n</p>\n<div class=\"math\">\\begin{eqnarray}\\tag{1} \\label{model1}\np(y=1 \\vert \\vec{x}) \\equiv \\frac{1}{1 + e^{- \\vec{\\beta} \\cdot \\vec{x} } },\n\\end{eqnarray}</div>\n<p>\nwhere <span class=\"math\">\\(\\vec{\\beta}\\)</span> is a coefficient vector characterizing the model. Note that with this choice of sign in the exponent, predictor vectors <span class=\"math\">\\(\\vec{x}\\)</span> having a large, positive component along <span class=\"math\">\\(\\vec{\\beta}\\)</span> will be predicted to have a large probability of being in class <span class=\"math\">\\(1\\)</span>. The probability of class <span class=\"math\">\\(0\\)</span> is given by the&nbsp;complement,\n</p>\n<div class=\"math\">\\begin{eqnarray}\\tag{2} \\label{model2}\np(y=0 \\vert \\vec{x}) \\equiv 1 - p(y=1 \\vert \\vec{x}) = \\frac{1}{1 + e^{ \\vec{\\beta} \\cdot \\vec{x} } }.\n\\end{eqnarray}</div>\n<p>\nThe latter equality above follows from simplifying algebra, after plugging in (\\ref{model1}) for <span class=\"math\">\\(p(y=1 \\vert&nbsp;\\vec{x}).\\)</span></p>\n<p>To fit the Logistic model to a training set &#8212; i.e., to find a good choice for the fit parameter vector <span class=\"math\">\\(\\vec{\\beta}\\)</span> &#8212; we consider here only the maximum-likelihood solution. This is that <span class=\"math\">\\(\\vec{\\beta}^*\\)</span> that maximizes the conditional probability of observing the training data. The essential results we review below are 1) a proof that the maximum likelihood solution can be found by gradient descent, and 2) a derivation for the asymptotic covariance matrix of <span class=\"math\">\\(\\vec{\\beta}\\)</span>. This latter result provides the basis for returning point estimate confidence&nbsp;intervals.</p>\n<p><a href=\"https://efavdb.com/wp-content/uploads/2017/07/errorbar.png\"><img alt=\"errorbar\" src=\"https://efavdb.com/wp-content/uploads/2017/07/errorbar.png\"></a></p>\n<p>On our GitHub <a href=\"https://github.com/EFavDB/logistic-regression-with-error\">page</a>, we provide a Jupyter notebook that contains some minimal code extending the SKLearn LogisticRegression class. This extension makes use of the results presented here and allows for class probability confidence intervals to be returned for individual test points. In the notebook, we apply the algorithm to the SKLearn Iris dataset. The figure at right illustrates the output of the algorithm along a particular cut through the Iris data set parameter space. The y-axis represents the probability of a given test point belong to Iris class <span class=\"math\">\\(1\\)</span>. The error bars in the plot provide insight that is completely missed when considering the point estimates only. For example, notice that the error bars are quite large for each of the far right points, despite the fact that the point estimates there are each near <span class=\"math\">\\(1\\)</span>. Without the error bars, the high probability of these point estimates might easily be misinterpreted as implying high model&nbsp;confidence.</p>\n<p>Our derivations below rely on some prerequisites: Properties of covariance matrices, the multivariate Cramer-Rao theorem, and properties of maximum likelihood estimators. These concepts are covered in two of our prior posts [<span class=\"math\">\\(1\\)</span>, <span class=\"math\">\\(2\\)</span>].</p>\n<h3>Optimization by gradient&nbsp;descent</h3>\n<p>In this section, we derive expressions for the gradient of the negative-log likelihood loss function and also demonstrate that this loss is everywhere convex. The latter result is important because it implies that gradient descent can be used to find the maximum likelihood&nbsp;solution.</p>\n<p>Again, to fit the logistic model to a training set, our aim is to find &#8212; and also to set the parameter vector to &#8212; the maximum likelihood value. Assuming the training set samples are independent, the likelihood of observing the training set labels is given&nbsp;by\n</p>\n<div class=\"math\">\\begin{eqnarray}\nL &amp;\\equiv&amp; \\prod_i p(y_i \\vert \\vec{x}_i) \\\\\n&amp;=&amp; \\prod_{i: y_i = 1} \\frac{1}{1 + e^{-\\vec{\\beta} \\cdot \\vec{x}_i}} \\prod_{i: y_i = 0} \\frac{1}{1 + e^{\\vec{\\beta} \\cdot \\vec{x}_i}}.\n\\tag{3} \\label{likelihood}\n\\end{eqnarray}</div>\n<p>\nMaximizing this is equivalent to minimizing its negative logarithm &#8212; a cost function that is somewhat easier to work&nbsp;with,\n</p>\n<div class=\"math\">\\begin{eqnarray}\nJ &amp;\\equiv&amp; -\\log L \\\\\n&amp;=&amp; \\sum_{\\{i: y_i = 1 \\}} \\log \\left (1 + e^{- \\vec{\\beta} \\cdot \\vec{x}_i } \\right ) + \\sum_{\\{i: y_i = 0 \\}} \\log \\left (1 + e^{\\vec{\\beta} \\cdot \\vec{x}_i } \\right ).\n\\tag{4} \\label{costfunction}\n\\end{eqnarray}</div>\n<p>\nThe maximum-likelihood solution, <span class=\"math\">\\(\\vec{\\beta}^*\\)</span>, is that coefficient vector that minimizes the above. Note that <span class=\"math\">\\(\\vec{\\beta}^*\\)</span> will be a function of the random sample, and so will itself be a random variable &#8212; characterized by a distribution having some mean value, covariance, etc. Given enough samples, a theorem on maximum-likelihood asymptotics (Cramer-Rao) guarantees that this distribution will be unbiased &#8212; i.e., it will have mean value given by the correct parameter values &#8212; and will also be of minimal covariance [<span class=\"math\">\\(1\\)</span>]. This theorem is one of the main results motivating use of the maximum-likelihood&nbsp;solution.</p>\n<p>Because <span class=\"math\">\\(J\\)</span> is convex (demonstrated below), the logistic regression maximum-likelihood solution can always be found by gradient descent. That is, one need only iteratively update <span class=\"math\">\\(\\vec{\\beta}\\)</span> in the direction of the negative <span class=\"math\">\\(\\vec{\\beta}\\)</span>-gradient of <span class=\"math\">\\(J\\)</span>, which&nbsp;is\n</p>\n<div class=\"math\">\\begin{eqnarray}\n- \\nabla_{\\vec{\\beta}} J &amp;=&amp; \\sum_{\\{i: y_i = 1 \\}}\\vec{x}_i \\frac{ e^{- \\vec{\\beta} \\cdot \\vec{x}_i } }{1 + e^{- \\vec{\\beta} \\cdot \\vec{x}_i }}\n- \\sum_{\\{i: y_i = 0 \\}} \\vec{x}_i \\frac{ e^{\\vec{\\beta} \\cdot \\vec{x}_i }}{1 + e^{\\vec{\\beta} \\cdot \\vec{x}_i } } \\\\\n&amp;\\equiv&amp; \\sum_{\\{i: y_i = 1 \\}}\\vec{x}_i p(y=0 \\vert \\vec{x}_i)\n-\\sum_{\\{i: y_i = 0 \\}} \\vec{x}_i p(y= 1 \\vert \\vec{x}_i). \\tag{5} \\label{gradient}\n\\end{eqnarray}</div>\n<p>\nNotice that the terms that contribute the most here are those that are most strongly misclassified &#8212; i.e., those where the model&#8217;s predicted probability for the observed class is very low. For example, a point with true label <span class=\"math\">\\(y=1\\)</span> but large model <span class=\"math\">\\(p(y=0 \\vert \\vec{x})\\)</span> will contribute a significant push on <span class=\"math\">\\(\\vec{\\beta}\\)</span> in the direction of <span class=\"math\">\\(\\vec{x}\\)</span> &#8212; so that the model will be more likely to predict <span class=\"math\">\\(y=1\\)</span> at this point going forward. Notice that the contribution of a term above is also proportional to the length of its feature vector &#8212; training points further from the origin have a stronger impact on the optimization process than those near the origin (at fixed classification&nbsp;difficulty).</p>\n<p>The Hessian (second partial derivative) matrix of the cost function follows from taking a second gradient of the above. With a little algebra, one can show that this has <span class=\"math\">\\(i-j\\)</span> component given&nbsp;by,\n</p>\n<div class=\"math\">\\begin{eqnarray}\nH(J)_{ij} &amp;\\equiv&amp; -\\partial_{\\beta_j} \\partial_{\\beta_i} \\log L \\\\\n&amp;=&amp; \\sum_k x_{k; i} x_{k; j} p(y= 0 \\vert \\vec{x}_k) p(y= 1 \\vert \\vec{x}_k). \\tag{6} \\label{Hessian}\n\\end{eqnarray}</div>\n<p>\nWe can prove that this is positive semi-definite using the fact that a matrix <span class=\"math\">\\(M\\)</span> is necessarily positive semi-definite if <span class=\"math\">\\(\\vec{s}^T \\cdot M \\cdot \\vec{s} \\geq 0\\)</span> for all real <span class=\"math\">\\(\\vec{s}\\)</span> [<span class=\"math\">\\(2\\)</span>]. Dotting our Hessian above on both sides by an arbitrary vector <span class=\"math\">\\(\\vec{s}\\)</span>, we&nbsp;obtain\n</p>\n<div class=\"math\">\\begin{eqnarray}\n\\vec{s}^T \\cdot H \\cdot \\vec{s} &amp;\\equiv&amp; \\sum_k \\sum_{ij} s_i x_{k; i} x_{k; j} s_j p(y= 0 \\vert \\vec{x}_k) p(y= 1 \\vert \\vec{x}_k) \\\\\n&amp;=&amp; \\sum_k \\vert \\vec{s} \\cdot \\vec{x}_k \\vert^2 p(y= 0 \\vert \\vec{x}_k) p(y= 1 \\vert \\vec{x}_k) \\geq 0.\n\\tag{7} \\label{convex}\n\\end{eqnarray}</div>\n<p>\nThe last form follows from the fact that both <span class=\"math\">\\(p(y= 0 \\vert \\vec{x}_k)\\)</span> and <span class=\"math\">\\(p(y= 1 \\vert \\vec{x}_k)\\)</span> are non-negative. This holds for any <span class=\"math\">\\(\\vec{\\beta}\\)</span> and any <span class=\"math\">\\(\\vec{s}\\)</span>, which implies that our Hessian is everywhere positive semi-definite. Because of this, convex optimization strategies &#8212; e.g., gradient descent &#8212; can always be applied to find the global maximum-likelihood&nbsp;solution.</p>\n<h3>Coefficient uncertainty and significance&nbsp;tests</h3>\n<p>The solution <span class=\"math\">\\(\\vec{\\beta}^*\\)</span> that minimizes <span class=\"math\">\\(J\\)</span> &#8212; which can be found by gradient descent &#8212; is a maximum likelihood estimate. In the asymptotic limit of a large number of samples, maximum-likelihood parameter estimates satisfy the Cramer-Rao lower bound [<span class=\"math\">\\(2\\)</span>]. That is, the parameter covariance matrix satisfies [<span class=\"math\">\\(3\\)</span>],\n</p>\n<div class=\"math\">\\begin{eqnarray}\n\\text{cov}(\\vec{\\beta}^*, \\vec{\\beta}^*) &amp;\\sim&amp; H(J)^{-1} \\\\\n&amp;\\approx&amp; \\frac{1}{\\sum_k \\vec{x}_{k} \\vec{x}_{k}^T p(y= 0 \\vert \\vec{x}_k) p(y= 1 \\vert \\vec{x}_k)}.\n\\tag{8} \\label{covariance}\n\\end{eqnarray}</div>\n<p>\nNotice that the covariance matrix will be small if the denominator above is large. Along a given direction, this requires that the training set contains samples over a wide range of values in that direction (we discuss this at some length in the analogous section of our post on Linear Regression [<span class=\"math\">\\(4\\)</span>]). For a term to contribute in the denominator, the model must also have some confusion about its values: If there are no difficult-to-classify training examples, this means that there are no examples near the decision boundary. When this occurs, there will necessarily be a lot of flexibility in where the decision boundary is placed, resulting in large parameter&nbsp;variances.</p>\n<p>Although the form above only holds in the asymptotic limit, we can always use it to approximate the true covariance matrix &#8212; keeping in mind that the accuracy of the approximation will degrade when working with small training sets. For example, using (\\ref{covariance}), the asymptotic variance for a single parameter can be approximated&nbsp;by\n</p>\n<div class=\"math\">\\begin{eqnarray}\n\\tag{9} \\label{single_cov}\n\\sigma^2_{\\beta^*_i} = \\text{cov}(\\vec{\\beta}^*, \\vec{\\beta}^*)_{ii}.\n\\end{eqnarray}</div>\n<p>\nIn the asymptotic limit, the maximum-likelihood parameters will be Normally-distributed [<span class=\"math\">\\(1\\)</span>], so we can provide confidence intervals for the parameters&nbsp;as\n</p>\n<div class=\"math\">\\begin{eqnarray}\n\\tag{10} \\label{parameter_interval}\n\\beta_i \\in \\left ( \\beta^*_i - z \\sigma_{\\beta^*_i}, \\beta_i^* + z \\sigma_{\\beta^*_i} \\right),\n\\end{eqnarray}</div>\n<p>\nwhere the value of <span class=\"math\">\\(z\\)</span> sets the size of the interval. For example, choosing <span class=\"math\">\\(z = 2\\)</span> gives an interval construction procedure that will cover the true value approximately <span class=\"math\">\\(95%\\)</span> of the time &#8212; a result of Normal statistics [<span class=\"math\">\\(5\\)</span>]. Checking which intervals do not cross zero provides a method for identifying which features contribute significantly to a given&nbsp;fit.</p>\n<h3>Prediction confidence&nbsp;intervals</h3>\n<p>The probability of class <span class=\"math\">\\(1\\)</span> for a test point <span class=\"math\">\\(\\vec{x}\\)</span> is given by (\\ref{model1}). Notice that this depends on <span class=\"math\">\\(\\vec{x}\\)</span> and <span class=\"math\">\\(\\vec{\\beta}\\)</span> only through the dot product <span class=\"math\">\\(\\vec{x} \\cdot \\vec{\\beta}\\)</span>. At fixed <span class=\"math\">\\(\\vec{x}\\)</span>, the variance (uncertainty) in this dot product follows from the coefficient covariance matrix above: We have [<span class=\"math\">\\(2\\)</span>],\n</p>\n<div class=\"math\">\\begin{eqnarray}\n\\tag{11} \\label{logit_var}\n\\sigma^2_{\\vec{x} \\cdot \\vec{\\beta}} \\equiv \\vec{x}^T \\cdot \\text{cov}(\\vec{\\beta}^*, \\vec{\\beta}^*) \\cdot \\vec{x}.\n\\end{eqnarray}</div>\n<p>\nWith this result, we can obtain an expression for the confidence interval for the dot product, or equivalently a confidence interval for the class probability. For example, the asymptotic interval for class <span class=\"math\">\\(1\\)</span> probability is given&nbsp;by\n</p>\n<div class=\"math\">\\begin{eqnarray}\n\\tag{12} \\label{prob_interval}\np(y=1 \\vert \\vec{x}) \\in \\left ( \\frac{1}{1 + e^{- \\vec{x} \\cdot \\vec{\\beta}^* + z \\sigma_{\\vec{x} \\cdot \\vec{\\beta}^*}}}, \\frac{1}{1 + e^{- \\vec{x} \\cdot \\vec{\\beta}^* - z \\sigma_{\\vec{x} \\cdot \\vec{\\beta}^*}}} \\right),\n\\end{eqnarray}</div>\n<p>\nwhere <span class=\"math\">\\(z\\)</span> again sets the size of the interval as above (<span class=\"math\">\\(z=2\\)</span> gives a <span class=\"math\">\\(95%\\)</span> confidence interval, etc. [<span class=\"math\">\\(5\\)</span>]), and <span class=\"math\">\\(\\sigma_{\\vec{x} \\cdot \\vec{\\beta}^*}\\)</span> is obtained from (\\ref{covariance}) and&nbsp;(\\ref{logit_var}).</p>\n<p>The results (\\ref{covariance}), (\\ref{logit_var}), and (\\ref{prob_interval}) are used in our Jupyter notebook. There we provide code for a minimal Logistic Regression class implementation that returns both point estimates and prediction confidence intervals for each test point. We used this code to generate the plot shown in the post introduction. Again, the code can be downloaded <a href=\"https://github.com/EFavDB/logistic-regression-with-error\">here</a> if you are interested in trying it&nbsp;out.</p>\n<h3>Summary</h3>\n<p>In this note, we have 1) reviewed how to fit a logistic regression model to a binary data set for classification purposes, and 2) have derived the expressions needed to return class membership probability confidence intervals for test&nbsp;points.</p>\n<p>Confidence intervals are typically not available for many out-of-the-box machine learning models, despite the fact that intervals can often provide significant utility. The fact that logistic regression allows for meaningful error bars to be returned with relative ease is therefore a notable, advantageous&nbsp;property.</p>\n<h3>Footnotes</h3>\n<p>[<span class=\"math\">\\(1\\)</span>] Our notes on the maximum-likelihood estimators can be found <a href=\"http://efavdb.github.io/maximum-likelihood-asymptotics\">here</a>.</p>\n<p>[<span class=\"math\">\\(2\\)</span>] Our notes on covariance matrices and the multivariate Cramer-Rao theorem can be found <a href=\"http://efavdb.github.io/multivariate-cramer-rao-bound\">here</a>.</p>\n<p>[<span class=\"math\">\\(3\\)</span>] The Cramer-Rao identity [<span class=\"math\">\\(2\\)</span>] states that covariance matrix of the maximum-likelihood estimators approaches the Hessian matrix of the log-likelihood, evaluated at their true values. Here, we approximate this by evaluating the Hessian at the maximum-likelihood point&nbsp;estimate.</p>\n<p>[<span class=\"math\">\\(4\\)</span>] Our notes on linear regression can be found <a href=\"http://efavdb.github.io/linear-regression\">here</a>.</p>\n<p>[<span class=\"math\">\\(5\\)</span>] Our notes on Normal distributions can be found <a href=\"http://efavdb.github.io/normal-distributions\">here</a>.</p>\n<script type=\"text/javascript\">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {\n    var align = \"center\",\n        indent = \"0em\",\n        linebreak = \"false\";\n\n    if (false) {\n        align = (screen.width < 768) ? \"left\" : align;\n        indent = (screen.width < 768) ? \"0em\" : indent;\n        linebreak = (screen.width < 768) ? 'true' : linebreak;\n    }\n\n    var mathjaxscript = document.createElement('script');\n    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';\n    mathjaxscript.type = 'text/javascript';\n    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';\n\n    var configscript = document.createElement('script');\n    configscript.type = 'text/x-mathjax-config';\n    configscript[(window.opera ? \"innerHTML\" : \"text\")] =\n        \"MathJax.Hub.Config({\" +\n        \"    config: ['MMLorHTML.js'],\" +\n        \"    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } },\" +\n        \"    jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" +\n        \"    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" +\n        \"    displayAlign: '\"+ align +\"',\" +\n        \"    displayIndent: '\"+ indent +\"',\" +\n        \"    showMathMenu: true,\" +\n        \"    messageStyle: 'normal',\" +\n        \"    tex2jax: { \" +\n        \"        inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" +\n        \"        displayMath: [ ['$$','$$'] ],\" +\n        \"        processEscapes: true,\" +\n        \"        preview: 'TeX',\" +\n        \"    }, \" +\n        \"    'HTML-CSS': { \" +\n        \"        availableFonts: ['STIX', 'TeX'],\" +\n        \"        preferredFont: 'STIX',\" +\n        \"        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" +\n        \"        linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" +\n        \"    }, \" +\n        \"}); \" +\n        \"if ('default' !== 'default') {\" +\n            \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" +\n                \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" +\n                \"VARIANT['normal'].fonts.unshift('MathJax_default');\" +\n                \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" +\n                \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" +\n                \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" +\n            \"});\" +\n            \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" +\n                \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" +\n                \"VARIANT['normal'].fonts.unshift('MathJax_default');\" +\n                \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" +\n                \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" +\n                \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" +\n            \"});\" +\n        \"}\";\n\n    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);\n    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);\n}\n</script>",
  "category": ""
}