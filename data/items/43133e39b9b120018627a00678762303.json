{
  "title": "Delegate.cash Contract Review",
  "link": "https://streamhacker.com/2022/10/08/delegate-cash-contract-review/#utm_source=feed&#038;utm_medium=feed&#038;utm_campaign=feed",
  "comments": "https://streamhacker.com/2022/10/08/delegate-cash-contract-review/#respond",
  "dc:creator": "Jacob",
  "pubDate": "Sat, 08 Oct 2022 18:18:38 +0000",
  "category": [
    "contracts",
    "airdrop",
    "eth",
    "nft",
    "slither",
    "token"
  ],
  "guid": "https://streamhacker.com/?p=2383",
  "description": "Contract review of Delegate.cash, a new protocol intended to make airdrops and token claims safer",
  "content:encoded": "\n<p><a href=\"https://delegate.cash/\">Delegate.cash</a> is a new protocol intended to make airdrops and token claims safer. If you have vaulted NFTs, you strongly want to avoid using that vault wallet to interact with any contracts. And if you have to move NFTs back & forth between your vault wallet and hot wallet to make claims, then you probably won&#8217;t. <a href=\"https://twitter.com/0xfoobar\">foobar</a>, one of the authors of delegate.cash, has a <a rel=\"noreferrer noopener\" href=\"https://0xfoobar.substack.com/p/delegatecash\" target=\"_blank\">great write up</a> on why this kind of protocol needs to exist. Let&#8217;s take a look at the <a rel=\"noreferrer noopener\" href=\"https://etherscan.io/address/0x00000000000076A84feF008CDAbe6409d2FE638B#code\" target=\"_blank\">code</a>&#8230;</p>\n\n\n\n<p><em>(note that the code blocks below contain some intermixed code from different parts of <a href=\"https://github.com/0xfoobar/delegation-registry/blob/main/src/DelegationRegistry.sol\">DelegationRegistry.sol</a> and <a href=\"https://github.com/0xfoobar/delegation-registry/blob/main/src/IDelegationRegistry.sol\">IDelegationRegistry.sol</a> for clarity of explanation)</em></p>\n\n\n\n<h2>Delegation</h2>\n\n\n\n<p>There are 3 types of delegation:</p>\n\n\n\n<ol><li><code>ALL</code> &#8211; the <code>vault</code> wallet delegates all actions to the <code>delegate</code> wallet</li><li><code>CONTRACT</code> &#8211; the <code>vault</code> wallet delegates all actions on a specific contract to the <code>delegate</code> wallet</li><li><code>TOKEN</code> &#8211; the <code>vault</code> wallet delegates all actions for a specific token (on a specific contract) to the <code>delegate</code> wallet</li></ol>\n\n\n\n<p>There are delegation functions for each of these delegation types that allow you to enable or disable the delegation (based on <code>value</code>). These functions must be called from the <code>vault</code> wallet (<code>vault = msg.sender</code>), but they are quite straightforward and safe:</p>\n\n\n\n<ol><li>Compute a <code>delegationHash</code></li><li>Set <code>DelegationInfo</code> values for that <code>delegationHash</code></li></ol>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-solidity\">enum DelegationType {\n\tNONE,\n\tALL,\n\tCONTRACT,\n\tTOKEN\n}\n\nfunction delegateForAll(address delegate, bool value) external override {\n\tbytes32 delegationHash = _computeAllDelegationHash(msg.sender, delegate);\n\t_setDelegationValues(\n\t\tdelegate, delegationHash, value, IDelegationRegistry.DelegationType.ALL, msg.sender, address(0), 0\n\t);\n\temit IDelegationRegistry.DelegateForAll(msg.sender, delegate, value);\n}\n\nfunction delegateForContract(address delegate, address contract_, bool value) external override {\n\tbytes32 delegationHash = _computeContractDelegationHash(msg.sender, delegate, contract_);\n\t_setDelegationValues(\n\t\tdelegate, delegationHash, value, IDelegationRegistry.DelegationType.CONTRACT, msg.sender, contract_, 0\n\t);\n\temit IDelegationRegistry.DelegateForContract(msg.sender, delegate, contract_, value);\n}\n\nfunction delegateForToken(address delegate, address contract_, uint256 tokenId, bool value) external override {\n\tbytes32 delegationHash = _computeTokenDelegationHash(msg.sender, delegate, contract_, tokenId);\n\t_setDelegationValues(\n\t\tdelegate, delegationHash, value, IDelegationRegistry.DelegationType.TOKEN, msg.sender, contract_, tokenId\n\t);\n\temit IDelegationRegistry.DelegateForToken(msg.sender, delegate, contract_, tokenId, value);\n}</code></pre>\n\n\n\n<h2>Delegation Hash</h2>\n\n\n\n<p>The <code>delegationHash</code> is where the authors got clever. Not only does the hash make delegation lookups faster and more efficient, it makes revoking delegations very cheap for gas. Every <code>vault</code> wallet has a numeric <code>vaultVersion</code>, which is initially <code>0</code>. If this gets changed, then the <code>delegationHash</code> will change. There is a similar numeric <code>delegateVersion</code> for <code>(vault, delegate)</code> pairs. Revoking (covered more below) is just a matter of changing those version numbers, therefore changing the hash.</p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-solidity\">/// @notice A mapping of wallets to versions (for cheap revocation)\nmapping(address => uint256) internal vaultVersion;\n\n/// @notice A mapping of wallets to delegates to versions (for cheap revocation)\nmapping(address => mapping(address => uint256)) internal delegateVersion;\n\t\nfunction delegateForAll(address delegate, bool value) external override {\n\tbytes32 delegationHash = _computeAllDelegationHash(msg.sender, delegate);\n\t_setDelegationValues(\n\t\tdelegate, delegationHash, value, IDelegationRegistry.DelegationType.ALL, msg.sender, address(0), 0\n\t);\n\temit IDelegationRegistry.DelegateForAll(msg.sender, delegate, value);\n}\n\nfunction delegateForContract(address delegate, address contract_, bool value) external override {\n\tbytes32 delegationHash = _computeContractDelegationHash(msg.sender, delegate, contract_);\n\t_setDelegationValues(\n\t\tdelegate, delegationHash, value, IDelegationRegistry.DelegationType.CONTRACT, msg.sender, contract_, 0\n\t);\n\temit IDelegationRegistry.DelegateForContract(msg.sender, delegate, contract_, value);\n}\n\nfunction delegateForToken(address delegate, address contract_, uint256 tokenId, bool value) external override {\n\tbytes32 delegationHash = _computeTokenDelegationHash(msg.sender, delegate, contract_, tokenId);\n\t_setDelegationValues(\n\t\tdelegate, delegationHash, value, IDelegationRegistry.DelegationType.TOKEN, msg.sender, contract_, tokenId\n\t);\n\temit IDelegationRegistry.DelegateForToken(msg.sender, delegate, contract_, tokenId, value);\n}</code></pre>\n\n\n\n<h2>Delegation Info</h2>\n\n\n\n<p>When delegating, a <code>DelegationInfo</code> object is created and stored by <code>delegateHash</code>. This <code>DelegationInfo</code> contains the following data:</p>\n\n\n\n<ul><li><code>vault</code>: the <code>vault</code> wallet</li><li><code>delegate</code>: the <code>delegate</code> or hot wallet</li><li><code>type_</code>: the <code>DelegationType</code>, which can be <code>ALL</code>, <code>CONTRACT</code>, or <code>TOKEN</code></li><li><code>contract_</code>: the contract address for <code>CONTRACT</code> & <code>TOKEN</code> types, or the <code>0</code> address for <code>ALL</code></li><li><code>tokenId</code>: the token number for the <code>TOKEN</code> type, or <code>0</code></li></ul>\n\n\n\n<p>If <code>value</code> is <code>false</code>, then the <code>delegateHash</code> and corresponding <code>DelegationInfo</code> are deleted, thereby revoking a specific delegation. However, there are cheaper ways to revoke delegation, covered next.</p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-solidity\">/// @notice Info about a single delegation, used for onchain enumeration\nstruct DelegationInfo {\n\tDelegationType type_;\n\taddress vault;\n\taddress delegate;\n\taddress contract_;\n\tuint256 tokenId;\n}\n\nfunction _setDelegationValues(\n\taddress delegate,\n\tbytes32 delegateHash,\n\tbool value,\n\tIDelegationRegistry.DelegationType type_,\n\taddress vault,\n\taddress contract_,\n\tuint256 tokenId\n) internal {\n\tif (value) {\n\t\tdelegations[vault][vaultVersion[vault]].add(delegateHash);\n\t\tdelegationHashes[delegate].add(delegateHash);\n\t\tdelegationInfo[delegateHash] =\n\t\t\tDelegationInfo({vault: vault, delegate: delegate, type_: type_, contract_: contract_, tokenId: tokenId});\n\t} else {\n\t\tdelegations[vault][vaultVersion[vault]].remove(delegateHash);\n\t\tdelegationHashes[delegate].remove(delegateHash);\n\t\tdelete delegationInfo[delegateHash];\n\t}\n}</code></pre>\n\n\n\n<h2>Revoking</h2>\n\n\n\n<p>The contract provides very cheap ways to revoke delegation, by changing the <code>vaultVersion</code> or <code>delegateVersion</code>.</p>\n\n\n\n<ul><li><code>revokeAllDelegates</code> would be called from the <code>vault</code> wallet, and invalidates all delegations for that wallet</li><li><code>revokeDelegate</code> would also be called from the <code>vault</code> wallet, to invalidate a specific <code>delegate</code> wallet</li><li><code>revokeSelf</code> would be called from a <code>delegate</code> wallet, to invalidate all delegations from a specific <code>vault</code> wallet</li></ul>\n\n\n\n<p>As mentioned above, instead of a complicated and gas expensive deletion of <code>DelegationInfo</code>, by incrementing a version number the delegation hash computation is changed. Technically this means the old <code>DelegationInfo</code> remains in the contract storage, but it is no longer accessible and cannot be used by any delegation lookups. There is also a theoretical limit of <code>2^256-1</code> for the number of times you can revoke and change either of the version numbers, but you&#8217;d have to try extremely hard and spend a lot of gas to do this.</p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-solidity\">function revokeAllDelegates() external override {\n\t++vaultVersion[msg.sender];\n\temit IDelegationRegistry.RevokeAllDelegates(msg.sender);\n}\n\nfunction revokeDelegate(address delegate) external override {\n\t_revokeDelegate(delegate, msg.sender);\n}\n\nfunction revokeSelf(address vault) external override {\n\t_revokeDelegate(msg.sender, vault);\n}\n\nfunction _revokeDelegate(address delegate, address vault) internal {\n\t++delegateVersion[vault][delegate];\n\t// For enumerations, filter in the view functions\n\temit IDelegationRegistry.RevokeDelegate(vault, msg.sender);\n}</code></pre>\n\n\n\n<h2>Delegation Lookups</h2>\n\n\n\n<p>There are a number of different ways to lookup delegations. I&#8217;ve included the function signatures below, but not the complete functions, as they are complicated, highly optimized loops iterating over the delegations created by the functions covered above. They are <code>view</code> only functions and therefore safe to call.</p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-solidity\">function getDelegatesForAll(address vault)\n    external view returns (address[] memory delegates)\n\nfunction getDelegatesForContract(address vault, address contract_)\n    external view override returns (address[] memory delegates)\n\nfunction getDelegatesForToken(address vault, address contract_, uint256 tokenId)\n    external view override returns (address[] memory delegates)\n\nfunction getContractLevelDelegations(address vault)\n    external view returns (IDelegationRegistry.ContractDelegation[] memory contractDelegations)\n\nfunction getTokenLevelDelegations(address vault)\n    external view returns (IDelegationRegistry.TokenDelegation[] memory tokenDelegations)\n\nfunction checkDelegateForAll(address delegate, address vault)\n    public view override returns (bool)\n\nfunction checkDelegateForContract(address delegate, address vault, address contract_)\n    public view override returns (bool)\n\nfunction checkDelegateForToken(address delegate, address vault, address contract_, uint256 tokenId)\n    public view override returns (bool)</code></pre>\n\n\n\n<p>These functions are designed to be called from other contracts or <a href=\"https://www.ledger.com/academy/what-is-a-dapp\" target=\"_blank\" rel=\"noreferrer noopener\">dapps</a>, to enable the delegation protocol. For example, if a <code>delegate</code> wallet wants to make a claim for a NFT, it could provide a <code>vault</code> wallet and <code>tokenId</code> to the claim contract. The claim contract would then do the following:</p>\n\n\n\n<ol><li>Confirm the <code>vault</code> wallet owns <code>tokenId</code></li><li>Call <code>checkDelegateForToken(delegate, vault, contract_, tokenId)</code></li><li>Proceed with the claim if <code>checkDelegateForToken</code> returns <code>true</code></li><li>Deny the claim if <code>checkDelegateForToken</code> returns <code>false</code></li></ol>\n\n\n\n<p>For the best UX, you&#8217;d probably want to call these functions initially from the dapp, but for security, you definitely want to verify everything within the claim contract.</p>\n\n\n\n<h2>Slither Analysis</h2>\n\n\n\n<p>Unfortunately, <code>slither 0x00000000000076A84feF008CDAbe6409d2FE638B</code> doesn&#8217;t work because the <a href=\"https://www.openzeppelin.com/contracts\" target=\"_blank\" rel=\"noreferrer noopener\">openzepplin</a> contract dependency paths are different than how <a href=\"https://etherscan.io/address/0x00000000000076A84feF008CDAbe6409d2FE638B#code\" target=\"_blank\" rel=\"noreferrer noopener\">etherscan</a> structures things. To make <a href=\"https://github.com/crytic/slither\" target=\"_blank\" rel=\"noreferrer noopener\">slither</a> work, I did the following:</p>\n\n\n\n<ol><li><code>git clone --recurse-submodules https://github.com/0xfoobar/delegation-registry.git</code></li><li><code>cd delegation-registry/lib</code></li><li><code>slither ../src/DelegationRegistry.sol --print human-summary</code></li><li><code>slither ../src/DelegationRegistry.sol</code></li></ol>\n\n\n\n<figure class=\"wp-block-image size-large\"><a href=\"https://i0.wp.com/streamhacker.com/wp-content/uploads/2022/10/Screen-Shot-2022-10-08-at-9.24.29-AM.png?ssl=1\"><img decoding=\"async\" width=\"474\" height=\"266\" src=\"https://i0.wp.com/streamhacker.com/wp-content/uploads/2022/10/Screen-Shot-2022-10-08-at-9.24.29-AM.png?resize=474%2C266&#038;ssl=1\" alt=\"\" class=\"wp-image-2392\" srcset=\"https://i0.wp.com/streamhacker.com/wp-content/uploads/2022/10/Screen-Shot-2022-10-08-at-9.24.29-AM.png?resize=1024%2C575&ssl=1 1024w, https://i0.wp.com/streamhacker.com/wp-content/uploads/2022/10/Screen-Shot-2022-10-08-at-9.24.29-AM.png?resize=300%2C168&ssl=1 300w, https://i0.wp.com/streamhacker.com/wp-content/uploads/2022/10/Screen-Shot-2022-10-08-at-9.24.29-AM.png?resize=768%2C431&ssl=1 768w, https://i0.wp.com/streamhacker.com/wp-content/uploads/2022/10/Screen-Shot-2022-10-08-at-9.24.29-AM.png?w=1218&ssl=1 1218w, https://i0.wp.com/streamhacker.com/wp-content/uploads/2022/10/Screen-Shot-2022-10-08-at-9.24.29-AM.png?w=948&ssl=1 948w\" sizes=\"(max-width: 474px) 100vw, 474px\" data-recalc-dims=\"1\" /></a><figcaption>Human summary of slither analysis</figcaption></figure>\n\n\n\n<p>As you can see, it&#8217;s in pretty good shape. The 4 medium issues are all <a rel=\"noreferrer noopener\" href=\"https://github.com/crytic/slither/wiki/Detector-Documentation#unused-return\" target=\"_blank\">unused returns</a> in <code>_setDelegationValues</code> when adding or removing delegation hashes from a set. The <code>add</code> and <code>remove</code> functions just return a <code>bool</code> if the set was changed, which doesn&#8217;t really matter for this contract, so ignoring the return value is totally fine.</p>\n\n\n\n<p>The 1 optimization issue is that <code>checkDelegateForToken</code> should be <a rel=\"noreferrer noopener\" href=\"https://github.com/crytic/slither/wiki/Detector-Documentation#public-function-that-could-be-declared-external\" target=\"_blank\">declared external</a>. It is actually <code>external</code> in the <code>IDelegationRegistry</code> interface, so I&#8217;m not sure why it&#8217;s <code>public</code> in <code>DelegationRegistry</code>. Maybe it&#8217;s just a simple oversight, but not really a big deal either.</p>\n\n\n\n<p>Some of the informational issues are about <a rel=\"noreferrer noopener\" href=\"https://github.com/crytic/slither/wiki/Detector-Documentation#assembly-usage\" target=\"_blank\">inline assembly</a> in some of the delegation lookups. Assembly should definitely be used with care. In this case, the assembly is in <code>view</code> only functions, in a way that helps reduce the computation cost.</p>\n\n\n\n<h2>Conclusion</h2>\n\n\n\n<p><a rel=\"noreferrer noopener\" href=\"https://delegate.cash/\" target=\"_blank\">Delegate.cash</a> does exactly what it claims to, in a very straightforward way. However, it&#8217;s useless on its own. For this protocol to work, developers have to start including it in their own contracts and dapps, then recommending it to their users. The team behind delegate.cash are attempting to make an official standard with <a href=\"https://eips.ethereum.org/EIPS/eip-5639\">EIP-5639</a>. But the best thing they can do is to provide easy to use libraries and sample code for integrating the protocol into other contracts and dapps. Ideally this would go as far as re-usable <a rel=\"noreferrer noopener\" href=\"https://reactjs.org/\" target=\"_blank\">React</a> components and a sample claim contract to demonstrate an entire user & wallet flow. If developers can essentially copy & paste to give their users more secure options, then adoption will be much easier.</p>\n",
  "wfw:commentRss": "https://streamhacker.com/2022/10/08/delegate-cash-contract-review/feed/",
  "slash:comments": 0,
  "post-id": 2383
}