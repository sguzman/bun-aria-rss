{
  "title": "Multiple Dispatch",
  "link": "",
  "updated": "2014-02-25T00:00:00+00:00",
  "id": "https://mrocklin.github.io/blog/work/2014/02/25/Multiple-Dispatch",
  "content": "<p><strong>tl;dr: We present a multiple dispatch system for Python.  We discuss issues\nthat arise from multiple dispatch.  We try to allay fears related to these\nissues.</strong></p>\n\n<h2 id=\"dispatch\">Dispatch</h2>\n\n<p>Abstract operations like addition, <code class=\"language-plaintext highlighter-rouge\">+</code>, have several different implementations.\nWe choose which implementation to use based on the type of the inputs.  For example:</p>\n\n<ul>\n  <li>The addition of two numbers results in arithmetic addition</li>\n  <li>The addition of two strings results in concatenation</li>\n  <li>The addition of two user defined objects results in <code class=\"language-plaintext highlighter-rouge\">__add__</code> or <code class=\"language-plaintext highlighter-rouge\">__radd__</code> calls</li>\n</ul>\n\n<p>The selection of implementation (e.g. arithmetic add) based on input types (e.g. integers) is called dispatch.</p>\n\n<p>As an object oriented language, Python dispatches on the type of the first\nargument, <code class=\"language-plaintext highlighter-rouge\">self</code>.  We call this single dispatch because it makes a selection\nfrom a single input.</p>\n\n<h2 id=\"dispatching-on-multiple-input-types\">Dispatching on multiple input types</h2>\n\n<p>The standard way to do multiple dispatch in Python is to branch on the type\nof other inputs within <code class=\"language-plaintext highlighter-rouge\">__add__</code></p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"k\">def</span> <span class=\"nf\">__add__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">other</span><span class=\"p\">):</span>\n    <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">other</span><span class=\"p\">,</span> <span class=\"n\">Foo</span><span class=\"p\">):</span>\n        <span class=\"p\">...</span>\n    <span class=\"k\">elif</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">other</span><span class=\"p\">,</span> <span class=\"n\">Bar</span><span class=\"p\">):</span>\n        <span class=\"p\">...</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"k\">raise</span> <span class=\"nb\">NotImplementedError</span><span class=\"p\">()</span></code></pre>\n</figure>\n\n<p>Or to raise a <code class=\"language-plaintext highlighter-rouge\">NotImplementedError</code>, which then tells Python to try\n<code class=\"language-plaintext highlighter-rouge\">other.__radd__(self)</code></p>\n\n<p>Both of these solutions are complex.  It gets worse when you consider\noperations with more than two inputs.</p>\n\n<h2 id=\"dispatching-on-all-types-with-decorators\">Dispatching on all types with decorators</h2>\n\n<p>The non-standard approach to multiple dispatch in Python is to decorate\nfunctions with type signatures:</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">multipledispatch</span> <span class=\"kn\">import</span> <span class=\"n\">dispatch</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"o\">@</span><span class=\"n\">dispatch</span><span class=\"p\">(</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">)</span>\n<span class=\"p\">...</span> <span class=\"k\">def</span> <span class=\"nf\">add</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">):</span>\n<span class=\"p\">...</span>     <span class=\"k\">return</span> <span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">y</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"o\">@</span><span class=\"n\">dispatch</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">,</span> <span class=\"nb\">object</span><span class=\"p\">)</span>\n<span class=\"p\">...</span> <span class=\"k\">def</span> <span class=\"nf\">add</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">):</span>\n<span class=\"p\">...</span>     <span class=\"k\">return</span> <span class=\"s\">\"%s + %s\"</span> <span class=\"o\">%</span> <span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">)</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">add</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"mi\">3</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">add</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"s\">'hello'</span><span class=\"p\">)</span>\n<span class=\"s\">'1 + hello'</span></code></pre>\n</figure>\n\n<p>As we define new implementations of <code class=\"language-plaintext highlighter-rouge\">add</code> decorated with new types we add to a\ncollection of <code class=\"language-plaintext highlighter-rouge\">{type-signature: function}</code> associations.  When we call <code class=\"language-plaintext highlighter-rouge\">add</code> on\na set of arguments the dispatch system performs dynamic type checking to find\nthe right function and then executes that function on those arguments.  This is\nexactly what happens in the object oriented solution, but now we dispatch on\nall of the arguments rather than only the first.</p>\n\n<p>The example above uses the <code class=\"language-plaintext highlighter-rouge\">multipledispatch</code> library found\n<a href=\"https://github.com/mrocklin/multipledispatch/\">here</a>.  It’s also installable\nfrom PyPI with the following command:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>pip install multipledispatch\n</code></pre></div></div>\n\n<h2 id=\"dispatch-supports-interactions-between-projects\">Dispatch Supports Interactions Between Projects</h2>\n\n<p>Multiple dispatch allows distinct types to interact over a shared abstract\ninterface.  For example, there currently exist several array programming\nsolutions in Python, each vying for the title “<code class=\"language-plaintext highlighter-rouge\">numpy</code> of the future”.\nMultiple dispatch supports efforts to interact between these disparate\nsolutions.</p>\n\n<p>For example most array programming solutions implement a dot-product operation,\n<code class=\"language-plaintext highlighter-rouge\">dot</code>.  Using multiple dispatch we could implement interactions like the\nfollowing:</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"o\">@</span><span class=\"n\">dispatch</span><span class=\"p\">(</span><span class=\"n\">numpy</span><span class=\"p\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">scipy</span><span class=\"p\">.</span><span class=\"n\">sparse</span><span class=\"p\">.</span><span class=\"n\">csr_matrix</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">dot</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">):</span>\n    <span class=\"p\">....</span>\n\n<span class=\"o\">@</span><span class=\"n\">dispatch</span><span class=\"p\">(</span><span class=\"n\">numpy</span><span class=\"p\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">theano</span><span class=\"p\">.</span><span class=\"n\">tensor</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">dot</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">):</span>\n    <span class=\"p\">...</span>\n\n<span class=\"o\">@</span><span class=\"n\">dispatch</span><span class=\"p\">(</span><span class=\"n\">numpy</span><span class=\"p\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">blaze</span><span class=\"p\">.</span><span class=\"n\">array</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">dot</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">):</span>\n    <span class=\"p\">...</span></code></pre>\n</figure>\n\n<p>These interactions don’t need to reside in each project.  Multiple dispatch\nseparates interaction code from core code.  This opens and democratizes\ninteraction, for better or for worse.</p>\n\n<h2 id=\"issues\">Issues</h2>\n\n<p>Programmers experienced with multiple dispatch know that it introduces the\nfollowing problems:</p>\n\n<ol>\n  <li>Dynamic multiple dispatch costs performance</li>\n  <li>It is possible to generate two type signatures that are equally valid for a\ngiven set of inputs.</li>\n  <li>Because we collect functions around their name we ignore namespaces.\nDifferent projects that reuse the same names may conflict.</li>\n</ol>\n\n<p>Lets handle these in order</p>\n\n<h3 id=\"1-performance\">1. Performance</h3>\n\n<p>Each call to a dispatched function requires a dynamic check of the types of the\ninputs against the type signatures of the known implementations at runtime.  This takes time.</p>\n\n<p>Using dictionaries, some static analysis, and caching we can push this cost\ndown to a couple of microseconds.  While this is slower than straight Python\nit’s not <em>that</em> much slower.  Don’t forget that objects do this dynamic\nchecking too.</p>\n\n<h3 id=\"2-conflicting-type-signatures-raise-ambiguities\">2. Conflicting type signatures raise ambiguities</h3>\n\n<p>Consider the following two functions</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"o\">@</span><span class=\"n\">dispatch</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">)</span>\n<span class=\"p\">...</span> <span class=\"k\">def</span> <span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">):</span>\n<span class=\"p\">...</span>     <span class=\"k\">return</span> <span class=\"mi\">1</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"o\">@</span><span class=\"n\">dispatch</span><span class=\"p\">(</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">object</span><span class=\"p\">)</span>\n<span class=\"p\">...</span> <span class=\"k\">def</span> <span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">):</span>\n<span class=\"p\">...</span>     <span class=\"k\">return</span> <span class=\"mi\">2</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span><span class=\"p\">(</span><span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"mf\">2.0</span><span class=\"p\">)</span>\n<span class=\"err\">?</span></code></pre>\n</figure>\n\n<p>What output do we expect, <code class=\"language-plaintext highlighter-rouge\">1</code> or <code class=\"language-plaintext highlighter-rouge\">2</code>?  In this case we have defined a set of\nimplementations that contain an <em>ambiguity</em>.  Due to inheritance both type\nsignatures <code class=\"language-plaintext highlighter-rouge\">(object, float)</code> and <code class=\"language-plaintext highlighter-rouge\">(float, object)</code> satisfy our argument types,\n<code class=\"language-plaintext highlighter-rouge\">(float, float)</code> equally well.  It’s ambiguous which implementation of <code class=\"language-plaintext highlighter-rouge\">f</code> we\nis most valid.  In large projects that depend on multiple dispatch, this\nbehavior can create bugs that are difficult to track down.</p>\n\n<p>Fortunately, we detect this problem statically at function definition time.\nInheritance of each of the type inputs induces a graph on all of the\nsignatures.  By looking for uncovered cycles within this graph we can identify\nambiguous collections of signatures and report them <em>before the code is run</em>.\nWe can suggest new signatures to cover the ambiguity:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&gt;&gt;&gt; @dispatch(float, object)\n... def f(x, y):\n...     return 2\n\nmultipledispatch/core.py:52: AmbiguityWarning:\n\nAmbiguities exist in dispatched function f\n\nThe following signatures may result in ambiguous behavior:\n    [float, object], [object, float]\n\n\nConsider making the following additions:\n\n    @dispatch(float, float)\n    def f(...)\n</code></pre></div></div>\n\n<h3 id=\"3-collecting-functions-by-name-ignores-namespaces\">3. Collecting functions by name ignores namespaces</h3>\n\n<p>Different projects implement functions with the same name all the time.  This\ncan cause some confusion.  Normally Python handles this problem with\nnamespaces.  Namespaces help to distinguish between <code class=\"language-plaintext highlighter-rouge\">your_library.foo</code> and\n<code class=\"language-plaintext highlighter-rouge\">my_library.foo</code>.  Namespaces are one heck of a good idea.</p>\n\n<p>Unfortunately multiple dispatch systems often group functions by their name and\nignore namespaces completely.  Can an ecosystem exist when several projects use\nmultiple dispatch without coordination?  Coordinating <code class=\"language-plaintext highlighter-rouge\">(name, type-signature)</code>\npairs to avoid conflicts between projects would inhibit the growth of the\necosystem.  Do multiple dispatch systems like what is described above make this\nnecessary?</p>\n\n<p>My opinion: <em>Yes, they do, but this coordination is easy - we do it already.</em></p>\n\n<p>Python already has globally dispatched operations.  Consider <code class=\"language-plaintext highlighter-rouge\">+</code>.  People add\nimplementations to <code class=\"language-plaintext highlighter-rouge\">+</code> every day.  The <code class=\"language-plaintext highlighter-rouge\">+</code> operation isn’t in a namespace, it\ndoesn’t need to be imported, it just dispatches based on the data given to it.\nAnd yet no problems arise <em>as long as no one monkey patches</em>.  That is, as long\nas people only define methods for types that they manage then globally\ndistributed dispatching systems are safe.</p>\n\n<p>Of course, dispatch systems like what we show above make monkey-patching of\ntypes easier.  For example in writing this post I defined <code class=\"language-plaintext highlighter-rouge\">add</code> on\n<code class=\"language-plaintext highlighter-rouge\">(object, object)</code> to mean string concatenation, clearly a pretty bold\ndecision.</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"o\">@</span><span class=\"n\">dispatch</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">,</span> <span class=\"nb\">object</span><span class=\"p\">)</span>\n<span class=\"p\">...</span> <span class=\"k\">def</span> <span class=\"nf\">add</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">):</span>\n<span class=\"p\">...</span>     <span class=\"k\">return</span> <span class=\"s\">\"%s + %s\"</span> <span class=\"o\">%</span> <span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">)</span></code></pre>\n</figure>\n\n<p>This was bad, as bad as is monkey patching.  My opinion is that globally\ndistributed dispatch is safe if we do not make broad claims like the example\nabove.</p>\n\n<h2 id=\"background\">Background</h2>\n\n<p>There have been several attempts at multiple dispatch in Python.  I’ll list a few below:</p>\n\n<ul>\n  <li><a href=\"http://www.artima.com/weblogs/viewpost.jsp?thread=101605\">Five-minute Multimethods in Python by Guido</a>:\nA quick explanation of multimethods and a simple implementation.  He leaves\nthe hard parts as “an exercise for the reader”.</li>\n  <li>Most links today point to the <a href=\"https://pypi.python.org/pypi/multimethods\"><code class=\"language-plaintext highlighter-rouge\">multimethods</code> package on PyPI</a>.</li>\n  <li>The single dispatch decorator is in Python 3.4’s <code class=\"language-plaintext highlighter-rouge\">functools</code>.  See <a href=\"http://legacy.python.org/dev/peps/pep-0443/\">PEP-443</a> and the <a href=\"http://docs.python.org/3.4/library/functools.html\"><code class=\"language-plaintext highlighter-rouge\">functools</code> docs</a></li>\n  <li>PEP-443 also calls out <a href=\"https://github.com/andreypopp/generic\">The <code class=\"language-plaintext highlighter-rouge\">generic</code> library</a> and <a href=\"https://github.com/smokedice/Gnosis/blob/master/gnosis/magic/multimethods.py\">the <code class=\"language-plaintext highlighter-rouge\">magic</code> module of <code class=\"language-plaintext highlighter-rouge\">Gnosis</code></a> as additional implementations.</li>\n  <li><a href=\"http://legacy.python.org/dev/peps/pep-3124/\">PEP 3124 - <em>Overloading, Generic Functions, Interfaces, and Adaptation</em></a> is a good read.  It was an ambitious proposal that didn’t stick.  Still contains lots of good thoughts.</li>\n</ul>\n\n<p><em>Special thanks to <a href=\"https://github.com/eriknw\">Erik Welch</a> for pointing me to a number of excellent Python references.</em></p>\n\n<p>The quickly growing Julia language handles multiple dispatch wonderfully.  Julia’s solution was what inspired me to play with this idea.</p>\n\n<ul>\n  <li>See the <a href=\"http://julia.readthedocs.org/en/latest/manual/methods/\">Julia methods docs</a>.</li>\n  <li><a href=\"http://nbviewer.ipython.org/gist/StefanKarpinski/b8fe9dbb36c1427b9f22\">Karpinksi’s notebook: <em>The Design Impact of Multiple Dispatch</em></a> provides motivation.</li>\n</ul>\n\n<p>And finally here is a link to the source code for my\nimplementation of <code class=\"language-plaintext highlighter-rouge\">multipledispatch</code></p>\n\n<ul>\n  <li><a href=\"https://github.com/mrocklin/multipledispatch/\">https://github.com/mrocklin/multipledispatch/</a>.</li>\n</ul>"
}