{
  "title": "Unification in SymPy",
  "link": "",
  "updated": "2012-11-01T00:00:00+00:00",
  "id": "https://mrocklin.github.io/blog/work/2012/11/01/Unification",
  "content": "<p>Unification is a way to ask questions by matching expressions against patterns. It is a powerful form of pattern matching found in logical programming languages like Prolog, Maude, and Datalog. It is the computational backbone behind the logical programming paradigm and is now a part of SymPy (in a pull request).</p>\n\n<p>Consider the following example. Imagine that you want to find the name of the MatrixSymbol within the Transpose in the following expression (i.e. we’re looking for the string <code class=\"language-plaintext highlighter-rouge\">'X'</code>)</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">X</span> <span class=\"o\">=</span> <span class=\"n\">MatrixSymbol</span><span class=\"p\">(</span><span class=\"s\">'X'</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">Y</span> <span class=\"o\">=</span> <span class=\"n\">MatrixSymbol</span><span class=\"p\">(</span><span class=\"s\">'Y'</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">expr</span> <span class=\"o\">=</span> <span class=\"n\">Transpose</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"n\">Y</span></code></pre>\n</figure>\n\n<p>Traditionally we could solve this toy problem with a simple function</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"k\">def</span> <span class=\"nf\">name_of_symbol_in_transpose_in_add</span><span class=\"p\">(</span><span class=\"n\">matadd</span><span class=\"p\">):</span>\n    <span class=\"k\">for</span> <span class=\"n\">arg</span> <span class=\"ow\">in</span> <span class=\"n\">matadd</span><span class=\"p\">.</span><span class=\"n\">args</span><span class=\"p\">:</span>\n        <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">,</span> <span class=\"n\">Transpose</span><span class=\"p\">)</span> <span class=\"ow\">and</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">.</span><span class=\"n\">arg</span><span class=\"p\">,</span> <span class=\"n\">MatrixSymbol</span><span class=\"p\">):</span>\n            <span class=\"k\">return</span> <span class=\"n\">arg</span><span class=\"p\">.</span><span class=\"n\">arg</span><span class=\"p\">.</span><span class=\"n\">name</span></code></pre>\n</figure>\n\n<p>We solve this task with unification by setting up a pattern and then unifying that pattern against a target expression</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">A</span> <span class=\"o\">=</span> <span class=\"n\">MatrixSymbol</span><span class=\"p\">(</span><span class=\"s\">'name'</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">m</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">B</span> <span class=\"o\">=</span> <span class=\"n\">MatrixSymbol</span><span class=\"p\">(</span><span class=\"s\">'B'</span><span class=\"p\">,</span> <span class=\"n\">m</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">)</span>\n<span class=\"c1\"># Look for an expression tree like A.T + B\n# Treat the leaves 'name', n, m, B as Wilds\n</span><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">pattern</span> <span class=\"o\">=</span> <span class=\"n\">Transpose</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"n\">B</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">wilds</span> <span class=\"o\">=</span> <span class=\"s\">'name'</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">m</span><span class=\"p\">,</span> <span class=\"n\">B</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">unify</span><span class=\"p\">(</span><span class=\"n\">pattern</span><span class=\"p\">,</span> <span class=\"n\">expr</span><span class=\"p\">,</span> <span class=\"n\">wilds</span><span class=\"o\">=</span><span class=\"n\">wilds</span><span class=\"p\">).</span><span class=\"nb\">next</span><span class=\"p\">()</span>\n<span class=\"p\">{</span><span class=\"s\">'name'</span><span class=\"p\">:</span> <span class=\"s\">'X'</span><span class=\"p\">,</span> <span class=\"n\">m</span><span class=\"p\">:</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">:</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"n\">B</span><span class=\"p\">:</span> <span class=\"n\">Y</span><span class=\"p\">}</span></code></pre>\n</figure>\n\n<p>We get back a matching for each of the wildcards (name, n, m, B) and see that <code class=\"language-plaintext highlighter-rouge\">'name'</code> was matched to the string <code class=\"language-plaintext highlighter-rouge\">'X'</code>. Is this better or worse than the straight Python solution? Given the relative number of users between Python and Prolog it’s a safe bet that the style of Python programs have some significant advantages over the logical programming paradigm. Why would we program in this strange way?</p>\n\n<p>Unification allows a clean separation between <em>what we’re looking for</em> and <em>how we find it</em>. In the Python solution the mathematical definition of what we want is spread among a few lines and is buried inside of control flow.</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"k\">for</span> <span class=\"n\">arg</span> <span class=\"ow\">in</span> <span class=\"n\">matadd</span><span class=\"p\">.</span><span class=\"n\">args</span><span class=\"p\">:</span>\n    <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">,</span> <span class=\"n\">Transpose</span><span class=\"p\">)</span> <span class=\"ow\">and</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">.</span><span class=\"n\">arg</span><span class=\"p\">,</span> <span class=\"n\">MatrixSymbol</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">arg</span><span class=\"p\">.</span><span class=\"n\">arg</span><span class=\"p\">.</span><span class=\"n\">name</span></code></pre>\n</figure>\n\n<p>In the unification solution the lines</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"n\">pattern</span> <span class=\"o\">=</span> <span class=\"n\">Transpose</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"n\">B</span>\n<span class=\"n\">wilds</span> <span class=\"o\">=</span> <span class=\"s\">'name'</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">m</span><span class=\"p\">,</span> <span class=\"n\">B</span></code></pre>\n</figure>\n\n<p>expresse exactly <em>what</em> we’re looking for and gives no information on <em>how</em> it should be found. The how is wrapped up in the call to <code class=\"language-plaintext highlighter-rouge\">unify</code></p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"n\">unify</span><span class=\"p\">(</span><span class=\"n\">pattern</span><span class=\"p\">,</span> <span class=\"n\">expr</span><span class=\"p\">,</span> <span class=\"n\">wilds</span><span class=\"o\">=</span><span class=\"n\">wilds</span><span class=\"p\">).</span><span class=\"nb\">next</span><span class=\"p\">()</span></code></pre>\n</figure>\n\n<p>This separation of the <em>what</em> and <em>how</em> is what excites me about declarative programming. I think that this separation is useful when mathematical and algorithmic programmers need to work together to solve a large problem. This is often the case in scientific computing. Mathematical programmers think about <em>what</em> should be done while algorithmic programmers think about <em>how</em> it can be efficiently computed. Declarative techniques like unification enables these two groups to work independently.</p>\n\n<h2 id=\"multiple-matches\">Multiple Matches</h2>\n\n<p>Lets see how unify works on a slightly more interesting expression</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">expr</span> <span class=\"o\">=</span> <span class=\"n\">Transpose</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"n\">Transpose</span><span class=\"p\">(</span><span class=\"n\">Y</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">unify</span><span class=\"p\">(</span><span class=\"n\">pattern</span><span class=\"p\">,</span> <span class=\"n\">expr</span><span class=\"p\">)</span>\n<span class=\"o\">&lt;</span><span class=\"n\">generator</span> <span class=\"nb\">object</span> <span class=\"n\">unify</span> <span class=\"n\">at</span> <span class=\"mh\">0x548cb90</span><span class=\"o\">&gt;</span></code></pre>\n</figure>\n\n<p>In this situation because both matrices <code class=\"language-plaintext highlighter-rouge\">X</code> and <code class=\"language-plaintext highlighter-rouge\">Y</code> are inside transposes our pattern to match “the name of a symbol in a transpose” could equally well return the strings <code class=\"language-plaintext highlighter-rouge\">'X'</code> or <code class=\"language-plaintext highlighter-rouge\">'Y'</code>. The unification algorithm will give us both of these options</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">for</span> <span class=\"n\">match</span> <span class=\"ow\">in</span> <span class=\"n\">unify</span><span class=\"p\">(</span><span class=\"n\">pattern</span><span class=\"p\">,</span> <span class=\"n\">expr</span><span class=\"p\">):</span>\n<span class=\"p\">...</span>    <span class=\"k\">print</span> <span class=\"n\">match</span>\n<span class=\"p\">{</span><span class=\"s\">'name'</span><span class=\"p\">:</span> <span class=\"s\">'Y'</span><span class=\"p\">,</span> <span class=\"n\">m</span><span class=\"p\">:</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">:</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"n\">B</span><span class=\"p\">:</span> <span class=\"s\">'X'</span><span class=\"p\">}</span>\n<span class=\"p\">{</span><span class=\"s\">'name'</span><span class=\"p\">:</span> <span class=\"s\">'X'</span><span class=\"p\">,</span> <span class=\"n\">m</span><span class=\"p\">:</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">:</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"n\">B</span><span class=\"p\">:</span> <span class=\"s\">'Y'</span><span class=\"p\">}</span></code></pre>\n</figure>\n\n<p>Because expr is commutative we can match <code class=\"language-plaintext highlighter-rouge\">{A: Transpose(X), B: Transpose(Y)}</code> or <code class=\"language-plaintext highlighter-rouge\">{A: Transpose(Y), B: Transpose(X)}</code> with equal validity. Instead of choosing one <code class=\"language-plaintext highlighter-rouge\">unify</code>, returns an iterable of all possible matches.</p>\n\n<h2 id=\"combinatorial-blowup\">Combinatorial Blowup</h2>\n\n<p>In how many ways can we match the following pattern</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>w + x + y + z\n</code></pre></div></div>\n\n<p>to the following expression?</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>a + b + c + d + e + f\n</code></pre></div></div>\n\n<p>This is a variant on the standard “N balls in K bins” problem often given in a discrete math course. The answer is “quite a few.” How can we avoid this combinatorial blowup?</p>\n\n<p><code class=\"language-plaintext highlighter-rouge\">unify</code> produces matches lazily. It returns a Python generator which yields results only as you ask for them. You can ask for just one match (a common case) very quickly.</p>\n\n<p>The bigger answer is that if you aren’t satisfied with this and want a better/stronger/faster way to find your desired match you could always <em>rewrite unify</em>. The <code class=\"language-plaintext highlighter-rouge\">unify</code> function is all about the <em>how</em> and is disconnected from the <em>what</em>. Algorithmic programmers can tweak unify without disrupting the mathematical code.</p>\n\n<h2 id=\"rewrites\">Rewrites</h2>\n\n<p>Unification is commonly used in term rewriting systems. Here is an example</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">sincos_to_one</span> <span class=\"o\">=</span> <span class=\"n\">rewriterule</span><span class=\"p\">(</span><span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"n\">cos</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">wilds</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">])</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">sincos_to_one</span><span class=\"p\">(</span><span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">+</span><span class=\"n\">b</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"n\">cos</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">+</span><span class=\"n\">b</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">).</span><span class=\"nb\">next</span><span class=\"p\">()</span>\n<span class=\"mi\">1</span></code></pre>\n</figure>\n\n<p>We were able to turn a mathematical identity <code class=\"language-plaintext highlighter-rouge\">sin(x)**2 + cos(x)**2 =&gt; 1</code> into a function very simply using unification. However unification only does exact pattern matching so we can only find the <code class=\"language-plaintext highlighter-rouge\">sin(x)**2 + cos(x)**2</code> pattern if that pattern is at the top node in the tree. As a result we’re not able to apply this simplification within a larger expression tree</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">sincos_to_one</span><span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"n\">c</span><span class=\"o\">**</span><span class=\"p\">(</span><span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">+</span><span class=\"n\">b</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"n\">cos</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">+</span><span class=\"n\">b</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">)))</span> <span class=\"c1\"># no matches\n</span><span class=\"p\">[]</span></code></pre>\n</figure>\n\n<p>I will leave the solution of this problem to a future post. Instead, I want to describe why I’m working on all of this.</p>\n\n<h2 id=\"matrix-computations\">Matrix Computations</h2>\n\n<p><a href=\"http://matthewrocklin.com/blog/work/2012/10/29/Matrix-Computations/\">My last post</a> was about translating Matrix Expressions into high-performance Fortran Code. I ended this post with the following problem:</p>\n\n<hr />\n\n<p><em>So how can we transform a matrix expression like</em></p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"p\">(</span><span class=\"n\">alpha</span><span class=\"o\">*</span><span class=\"n\">A</span><span class=\"o\">*</span><span class=\"n\">B</span><span class=\"p\">).</span><span class=\"n\">I</span> <span class=\"o\">*</span> <span class=\"n\">x</span></code></pre>\n</figure>\n\n<p>…</p>\n\n<p><em>Into a graph of <code class=\"language-plaintext highlighter-rouge\">BLAS</code> calls like one of the following?</em></p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"n\">DGEMM</span><span class=\"p\">(</span><span class=\"n\">alpha</span><span class=\"p\">,</span> <span class=\"n\">A</span><span class=\"p\">,</span> <span class=\"n\">B</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">B</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">DTRSV</span><span class=\"p\">(</span><span class=\"n\">alpha</span><span class=\"o\">*</span><span class=\"n\">A</span><span class=\"o\">*</span><span class=\"n\">B</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"n\">DTRMM</span><span class=\"p\">(</span><span class=\"n\">alpha</span><span class=\"p\">,</span> <span class=\"n\">A</span><span class=\"p\">,</span> <span class=\"n\">B</span><span class=\"p\">)</span>       <span class=\"o\">-&gt;</span> <span class=\"n\">DTRSV</span><span class=\"p\">(</span><span class=\"n\">alpha</span><span class=\"o\">*</span><span class=\"n\">A</span><span class=\"o\">*</span><span class=\"n\">B</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">)</span></code></pre>\n</figure>\n\n<hr />\n\n<p>This problem can be partially solved by unification and rewrite rules. Each <code class=\"language-plaintext highlighter-rouge\">BLAS</code> operation is described by a class</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"k\">class</span> <span class=\"nc\">MM</span><span class=\"p\">(</span><span class=\"n\">BLAS</span><span class=\"p\">):</span>\n    <span class=\"s\">\"\"\" Matrix Multiply \"\"\"</span>\n    <span class=\"n\">_inputs</span>   <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">alpha</span><span class=\"p\">,</span> <span class=\"n\">A</span><span class=\"p\">,</span> <span class=\"n\">B</span><span class=\"p\">,</span> <span class=\"n\">beta</span><span class=\"p\">,</span> <span class=\"n\">C</span><span class=\"p\">)</span>\n    <span class=\"n\">_outputs</span>  <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">alpha</span><span class=\"o\">*</span><span class=\"n\">A</span><span class=\"o\">*</span><span class=\"n\">B</span> <span class=\"o\">+</span> <span class=\"n\">beta</span><span class=\"o\">*</span><span class=\"n\">C</span><span class=\"p\">,)</span></code></pre>\n</figure>\n\n<p>The <code class=\"language-plaintext highlighter-rouge\">_outputs</code> and <code class=\"language-plaintext highlighter-rouge\">_inputs</code> fields mathematically define when <code class=\"language-plaintext highlighter-rouge\">MM</code> is appropriate. This is all we need to make a transformation</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"n\">source</span> <span class=\"o\">=</span> <span class=\"n\">MM</span><span class=\"p\">.</span><span class=\"n\">_outputs</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"n\">target</span> <span class=\"o\">=</span> <span class=\"n\">MM</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">MM</span><span class=\"p\">.</span><span class=\"n\">_inputs</span><span class=\"p\">)</span>\n<span class=\"n\">wilds</span>  <span class=\"o\">=</span> <span class=\"n\">MM</span><span class=\"p\">.</span><span class=\"n\">_inputs</span>\n<span class=\"n\">rewriterule</span><span class=\"p\">(</span><span class=\"n\">source</span><span class=\"p\">,</span> <span class=\"n\">target</span><span class=\"p\">,</span> <span class=\"n\">wilds</span><span class=\"p\">)</span></code></pre>\n</figure>\n\n<p>Unification allows us to describe <code class=\"language-plaintext highlighter-rouge\">BLAS</code> mathematically without thinking about\nhow each individual operation will be detected in an expression. The control\nflow and the math are completely separated allowing us to think hard about each\nproblem in isolation.</p>\n\n<h2 id=\"references\">References</h2>\n\n<p>I learned a great deal from the following sources</p>\n\n<ul>\n  <li><a href=\"http://aima.cs.berkeley.edu/\">Artificial Intelligence: A Modern Approach</a> by Stuart Russel and Peter Norvig (Particularly section 9.2 in the second edition)</li>\n  <li><a href=\"http://stackoverflow.com/questions/13092092/algorithms-for-unification-of-list-based-trees\">StackOverflow - Algorithms for Unification of list-based trees</a></li>\n  <li><a href=\"http://stackoverflow.com/questions/13131491/partition-n-items-into-k-bins-in-python-lazily\">StackOverflow - Partition N items into K bins in Python lazily</a> (Special thanks to <a href=\"https://github.com/smichr\">Chris Smith</a> who provided the best answer)</li>\n  <li><a href=\"http://en.wikipedia.org/wiki/Logic_programming\">Logic Programming</a></li>\n  <li><a href=\"http://en.wikipedia.org/wiki/Term_rewriting\">Term Rewriting</a></li>\n  <li><a href=\"http://www.learnprolognow.org/\">My favorite Prolog tutorial</a></li>\n  <li><a href=\"http://goo.gl/ZqVHJ\">SymPy E-mail thread on this topic</a></li>\n  <li><a href=\"https://github.com/sympy/sympy/pull/1633\">Pull Request</a></li>\n</ul>"
}