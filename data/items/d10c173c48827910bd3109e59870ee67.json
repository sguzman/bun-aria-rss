{
  "title": "Caches Considered Harmful for Machine Learning",
  "link": "https://petewarden.com/2022/06/02/caches-considered-harmful-for-machine-learning/",
  "comments": "https://petewarden.com/2022/06/02/caches-considered-harmful-for-machine-learning/#comments",
  "dc:creator": "Pete Warden",
  "pubDate": "Thu, 02 Jun 2022 01:10:54 +0000",
  "category": "Uncategorized",
  "guid": "http://petewarden.com/?p=7668",
  "description": "I&#8217;ve been working on a new research paper, and a friend gave me the feedback that he was confused by the statement &#8220;memory accesses can be accurately predicted at the compilation stage&#8221; for machine learning workloads, and that this made them a poor fit for conventional processor architectures with predictive caches. I realized that this [&#8230;]",
  "content:encoded": "\n<figure class=\"wp-block-image size-large\"><a href=\"https://npgallery.nps.gov/AssetDetail/281488ae-f834-438c-a0d0-c8a3340f5ac7\"><img data-attachment-id=\"7669\" data-permalink=\"https://petewarden.com/2022/06/02/caches-considered-harmful-for-machine-learning/food_cache/\" data-orig-file=\"https://petewarden.files.wordpress.com/2022/06/food_cache.jpg\" data-orig-size=\"3888,2592\" data-comments-opened=\"1\" data-image-meta=\"{\"aperture\":\"4\",\"credit\":\"\",\"camera\":\"Canon EOS 40D\",\"caption\":\"\",\"created_timestamp\":\"1309167616\",\"copyright\":\"\",\"focal_length\":\"75\",\"iso\":\"400\",\"shutter_speed\":\"0.016666666666667\",\"title\":\"\",\"orientation\":\"1\"}\" data-image-title=\"food_cache\" data-image-description=\"\" data-image-caption=\"\" data-medium-file=\"https://petewarden.files.wordpress.com/2022/06/food_cache.jpg?w=300\" data-large-file=\"https://petewarden.files.wordpress.com/2022/06/food_cache.jpg?w=550\" src=\"https://petewarden.files.wordpress.com/2022/06/food_cache.jpg?w=1024\" alt=\"\" class=\"wp-image-7669\" srcset=\"https://petewarden.files.wordpress.com/2022/06/food_cache.jpg?w=1024 1024w, https://petewarden.files.wordpress.com/2022/06/food_cache.jpg?w=2048 2048w, https://petewarden.files.wordpress.com/2022/06/food_cache.jpg?w=150 150w, https://petewarden.files.wordpress.com/2022/06/food_cache.jpg?w=300 300w, https://petewarden.files.wordpress.com/2022/06/food_cache.jpg?w=768 768w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" /></a><figcaption><em><a href=\"https://npgallery.nps.gov/AssetDetail/281488ae-f834-438c-a0d0-c8a3340f5ac7\">Photo by the National Park Service</a></em></figcaption></figure>\n\n\n\n<p>I&#8217;ve been working on a new research paper, and a friend gave me the feedback that he was confused by the statement <em>&#8220;memory accesses can be accurately predicted at the compilation stage&#8221;</em> for machine learning workloads, and that this made them a poor fit for conventional processor architectures with predictive caches. I realized that this was received wisdom among the ML engineers I know, but I wasn&#8217;t aware of any papers that discuss this point. I put out <a href=\"https://twitter.com/petewarden/status/1531799877683773441\">a request for help on Twitter</a>, but while there were a lot of interesting resources in the answers, I still couldn&#8217;t find any papers that focused on what feels like an important property for machine learning systems. With that in mind, I wanted to at least describe the issue as best as I can in this blog post, so there&#8217;s a trail of breadcrumbs for anyone else interested in how system designs might need to change to accommodate ML.</p>\n\n\n\n<p>So, what am I talking about? Modern processors are almost universally constructed around multiple layers of predictive memory caches. These are small areas of memory that can be accessed much faster than the main system memory, and are needed because processors can execute instructions far more quickly than they can fetch values from the DRAM used for main memory. In fact, you can usually run hundreds of instructions in the time it takes to bring one byte from the DRAM. This means if processors all executed directly from system memory, they would run hundreds of times more slowly than they could. For decades, the solution to the mismatch has been predictive caches. It&#8217;s possible to build memory that&#8217;s much faster to access than DRAM, but for power and area reasons it&#8217;s not easy to fit large amounts onto a chip. In modern systems you might have gigabytes of DRAM, but only single-digit megabytes of total cache. There are some great papers like <a href=\"https://www.akkadia.org/drepper/cpumemory.pdf\">What Every Programmer Should Know About Memory</a> that go into a lot more detail about the overall approach, but the most important thing to know is that memory stored in these caches can be accessed in a handful of cycles, instead of hundreds, so moving data into these areas is crucial if you want to run your programs faster.</p>\n\n\n\n<p>How do we decide what data should be placed in these caches though? This requires us to predict what memory locations will be accessed hundreds or thousands of cycles in the future, and with general programs with a lot of data dependent branches, comparisons, and complex address calculations this isn&#8217;t possible to do with complete accuracy. Instead, the caches use heuristics (like we just accessed address N, so also fetch N+1, N+2, etc in case we&#8217;re iterating through an array) to guess how to populate these small, fast areas of memory. The cost of making a mistake is still hundreds of cycles, but as long as most of the accesses are predicted correctly this works pretty well in practice. However there is still an underlying tension between the model used for programming languages, where memory is treated as a uniform arena, and the reality of hardware where data lives in multiple different places with very different characteristics. I never thought I&#8217;d be linking to a Hacker News comment, the community has enough toxic members I haven&#8217;t read it for years, but <a href=\"https://news.ycombinator.com/item?id=31548989#31551198\">this post</a> <a href=\"https://twitter.com/IanNappier/status/1531831139089801216\">I was pointed to</a> actually does a good job of talking about all the complexities that are introduced to make processors appear as if they&#8217;re working with uniform memory.</p>\n\n\n\n<p>Why does all this matter for machine learning? The fundamental problem predictive caches are trying to solve is &#8220;What data needs to be prefetched into fast memory from DRAM?&#8221;. For most computing workloads, like rendering HTML pages or dealing with network traffic, the answer to this question is highly dependent on the input data to the algorithm. The code is full of lines like &#8216;<code>if (a[i] == 10) { value = b[j] } else { value = b[k]; }</code>&#8216;, so predicting which addresses will be accessed requires advance knowledge of i, a[i], j, and k, at least. As more of these data-dependent conditionals accumulate, the permutations of possible access addresses become unmanageable, and effectively it&#8217;s impossible to predict addresses for code like this without accessing the data itself. Since the problem we&#8217;re trying to solve is that we can&#8217;t access the underlying data efficiently without a cache, we end up having to rely on heuristics instead.</p>\n\n\n\n<p>Machine learning operations are very different. The layers that take up the majority of the time for most models tend to be based on operations like convolutions, which <a href=\"https://petewarden.com/2015/04/20/why-gemm-is-at-the-heart-of-deep-learning/\">can be expressed as matrix multiplies</a>. Crucially, the memory access patterns don&#8217;t depend on the input data. There&#8217;s no &#8216;i<code>f (a[i] == 10) {...</code>&#8216; code in the inner loops of these kernels, they&#8217;re <a href=\"https://petewarden.com/2015/10/25/an-engineers-guide-to-gemm/\">much simpler</a>. The sizes of the inputs are also usually known ahead of time. These properties mean that we know exactly what data we need in fast memory for the entire execution of the layer ahead of time, with no dependencies on the values in that data. Each layer can often take hundreds of thousands of arithmetic operations to compute, and each value fetched has the potential to be used in multiple instructions, so making good use of the small amounts of fast memory available is crucial to reducing latency. What quickly becomes frustrating to any programmer trying to optimize these algorithms on conventional processors is that it&#8217;s very hard to transfer our complete knowledge of future access patterns into compiled code. </p>\n\n\n\n<p>The caches rely almost entirely on the heuristics that were designed for conventional usage patterns, so we essentially have to reverse-engineer those heuristics to persuade them to load the data we know we&#8217;ll need. There are some tools to help like prefetching instructions and branch hints, but optimizing inner loops often feels like a struggle against a system that thinks it&#8217;s being helpful, but is actually getting in the way. Optimized matrix multiplication implementations usually require us to gather the needed data into tiles that are a good fit for the fast memory available, so we can do as much as possible with the values while they&#8217;re quickly accessible. Getting these tiles the right size and ensuring they&#8217;re populated with the correct data before it&#8217;s needed requires in-depth knowledge of the capacity, access latencies, and predictive algorithms of all levels of the cache hierarchy on a particular processor. An implementation that works well on one chip may produce drastically poorer performance on another in the same family if any of those characteristics change.</p>\n\n\n\n<p>It would make more sense to expose the small, fast memories to the programmer directly, instead of relying on opaque heuristics to populate them. They could be made available as separate address spaces that can be explicitly preloaded ahead of time with data before it&#8217;s needed. We know what address ranges we&#8217;ll want to have and when, so give us a way to use this knowledge to provide perfect predictions to fill those areas of memory. Some embedded chips do offer this capability, known variously as <a href=\"https://developer.arm.com/documentation/ddi0338/g/level-one-memory-system/tightly-coupled-memory\">tightly-coupled memory</a>, or <a href=\"https://www.synopsys.com/designware-ip/technical-bulletin/performance-coding-advantages.html\">XY memory</a>, and we do <a href=\"https://github.com/tensorflow/tflite-micro/blob/main/tensorflow/lite/micro/kernels/arc_mli/scratch_buf_mgr.cc\">use this</a> to improve performance for TensorFlow Lite Micro on platforms that support it.</p>\n\n\n\n<p>There are lots of challenges to making this available more widely though. Modern desktop and mobile apps don&#8217;t have the luxury of targeting a single hardware platform, and are expected to be able to run across a wide variety of different chips within the same processor family. It would be very difficult to write efficient code that works for all those combinations of cache size, speed, and prefetch heuristics. Software libraries from the processor manufacturers themselves (like <a href=\"https://developer.nvidia.com/cudnn\">CuDNN</a> or <a href=\"https://www.intel.com/content/www/us/en/develop/documentation/oneapi-programming-guide/top/api-based-programming/intel-oneapi-math-kernel-library-onemkl.html\">Intel&#8217;s MKL</a>) are usually the best answer right now, since they are written by engineers with detailed knowledge of the hardware systems and will be updated to handle new releases. These still have to work around the underlying challenges of a programming model that tries to hide the cache hierarchy though, and every engineer I&#8217;ve talked to who has worked on these inner loops wishes they had a better way to take advantage of their knowledge of memory access patterns.</p>\n\n\n\n<p>This is also the kind of radical workload difference that has inspired a lot of new kinds of NPU hardware aimed specifically at deep learning. From my perspective, these have also been hard to work with, because while their programming models may work better for core operations like convolutions, models also require layers like <a href=\"https://petewarden.com/2022/02/21/non-max-suppressions-how-do-they-work/\">non-max suppressions</a> that are only efficiently written as procedural code with data-dependent branches. Without the ability to run this kind of general purpose code, accelerators lose many of their advantages because they have to keep passing off work to the main CPU, with a high latency cost (partly because this kind of handover usually involves flushing all caches to keep different memory areas in sync).</p>\n\n\n\n<p>I don&#8217;t know what the ultimate solution will look like, but I&#8217;d imagine it will either involve system programmers being able to populate parts of caches using explicit prefetching, maybe even just supplying a set of address ranges as requirements and relying on the processor to sort it out, or something more extreme. One possible idea is making matrix multiplies first-class instructions at the machine code level, and having each processor implement the optimal strategy in microcode, in a similar way to how floating-point operations have migrated from accelerators, to co-processors, and now to the core CPU. Whatever the future holds, I hope this post at least helps explain why conventional predictive caches are so unhelpful when trying to optimize machine learning operations.</p>\n",
  "wfw:commentRss": "https://petewarden.com/2022/06/02/caches-considered-harmful-for-machine-learning/feed/",
  "slash:comments": 3,
  "media:content": [
    {
      "media:title": "petewarden"
    },
    ""
  ]
}