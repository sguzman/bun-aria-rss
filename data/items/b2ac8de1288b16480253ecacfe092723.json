{
  "title": "MIFS",
  "link": "",
  "published": "2016-01-31T15:54:00+00:00",
  "updated": "2016-01-31T15:54:00+00:00",
  "id": "https://danielhomola.com/feature%20selection/phd/mifs-parallelized-mutual-information-based-feature-selection-module",
  "content": "<h2 id=\"quick-summary\">Quick summary</h2>\n\n<p>I wrapped up three mutual information based feature selection methods in a scikit-learn like module. You can find it on my <a href=\"https://github.com/danielhomola/mifs\">GitHub</a>. It is very easy to use, you can run the <code class=\"language-plaintext highlighter-rouge\">example.py</code> or import it into your project and apply it to your data like any other scikit-learn method.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><table class=\"rouge-table\"><tbody><tr><td class=\"gutter gl\"><pre class=\"lineno\">1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n</pre></td><td class=\"code\"><pre>    <span class=\"kn\">import</span> <span class=\"nn\">pandas</span> <span class=\"k\">as</span> <span class=\"n\">pd</span>\n    <span class=\"kn\">import</span> <span class=\"nn\">mifs</span>\n\n    <span class=\"c1\"># load X and y\n</span>    <span class=\"n\">X</span> <span class=\"o\">=</span> <span class=\"n\">pd</span><span class=\"p\">.</span><span class=\"n\">read_csv</span><span class=\"p\">(</span><span class=\"s\">'my_X_table.csv'</span><span class=\"p\">,</span> <span class=\"n\">index_col</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">).</span><span class=\"n\">values</span>\n    <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">pd</span><span class=\"p\">.</span><span class=\"n\">read_csv</span><span class=\"p\">(</span><span class=\"s\">'my_y_vector.csv'</span><span class=\"p\">,</span> <span class=\"n\">index_col</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">).</span><span class=\"n\">values</span>\n\n    <span class=\"c1\"># define MI_FS feature selection method\n</span>    <span class=\"n\">feat_selector</span> <span class=\"o\">=</span> <span class=\"n\">mifs</span><span class=\"p\">.</span><span class=\"n\">MutualInformationFeatureSelector</span><span class=\"p\">()</span>\n\n    <span class=\"c1\"># find all relevant features\n</span>    <span class=\"n\">feat_selector</span><span class=\"p\">.</span><span class=\"n\">fit</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># check selected features\n</span>    <span class=\"n\">feat_selector</span><span class=\"p\">.</span><span class=\"n\">support_</span>\n\n    <span class=\"c1\"># check ranking of features\n</span>    <span class=\"n\">feat_selector</span><span class=\"p\">.</span><span class=\"n\">ranking_</span>\n\n    <span class=\"c1\"># call transform() on X to filter it down to selected features\n</span>    <span class=\"n\">X_filtered</span> <span class=\"o\">=</span> <span class=\"n\">feat_selector</span><span class=\"p\">.</span><span class=\"n\">transform</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">)</span>\n</pre></td></tr></tbody></table></code></pre></figure>\n\n<h2 id=\"background\">Background</h2>\n\n<h3 id=\"mutual-information-based-filter-methods\">Mutual information based filter methods</h3>\n\n<p>In the past twenty years, a large variety of information theory based filter methods were developed. Filter methods represent a subclass of feature selection algorithms which are classifier independent and capture the discriminating power of each feature by calculating some sort of <em>relevance</em> statistics with respect to the outcome variable. These statistics are used in a heuristic scoring criterion which acts as a proxy measure for classification accuracy. Therefore filter methods can rank the features by their relevance computationally cheaply, without the need of training classifiers on the data.</p>\n\n<p>Information theory based filter methods assess the mutual information between the $latex m$ features of $latex X^{m \\times n}$ and $latex y$. To follow the conventional notation of introductory texts in information theory however, $latex X$ will have a different meaning in this post.</p>\n\n<p>Information theory is concerned about quantifying the uncertainty present in distributions, by measuring their <strong>entropy</strong>. The entropy of the distribution of variable $latex X$, denoted as $latex H(X)$, is defined as:</p>\n<p style=\"text-align: center;\">$latex H(X) = -\\sum_{x \\in \\mathcal{X}}p(x)\\log p(x), $</p>\n\n<p>where $latex x$ denotes a possible value of variable $latex X$, that it can take from a set of values $latex \\mathcal{X}$, and $latex p(x)$ is the distribution of $latex X$. This equation quantifies the uncertainty in $latex X$, and for discrete variables it could be computed by estimating $latex p(X)$ as the fraction of observations taking on value $latex x$ from the total $latex N$: $latex \\bar{p}(x)=\\frac{\\#x}{N}.$</p>\n\n<p>If $latex p(x)$ peaks around a certain value, than the entropy of it will be low, while if it is uniform, meaning all events in $latex X$ are equally likely, it will be high. Furthermore, <strong>conditional entropy</strong> of two distributions could be defined as:</p>\n<p style=\"text-align: center;\">$latex H(X|Y)=-\\sum_{y \\in \\mathcal{Y}}p(y) \\sum_{x \\in \\mathcal{X}}p(x|y)\\log p(x|y),$</p>\n\n<p>which represents the amount of uncertainty remaining in$latex X$ after we have seen $latex Y$.</p>\n\n<p><strong>Mutual information</strong> (Shannon 1948) between $latex X$ and $latex Y$ is then defined as:</p>\n<p style=\"text-align: center;\">$latex I(X;Y) = H(X) - H(X|Y)$</p>\n<p style=\"text-align: center;\">$latex \\sum_{x \\in \\mathcal{X}}\\sum_{y \\in \\mathcal{Y}}p(xy)\\log\\frac{p(xy)}{p(x)p(y)}$</p>\n\n<p>In this difference the first term represents the uncertainty <em>before</em> $latex Y$ is known, while the second term captures the uncertainty <em>after</em> $latex Y$ is known. Thus mutual information could also be thought of, as the amount of uncertainty in $latex X$ that is removed by knowing $latex Y$. Mutual information is symmetric $latex I(X;Y)=I(Y;X)$ and is zero if and only if $latex X$ and $latex Y$ are statistically independent.</p>\n\n<p>Building on the these concepts, and given we have three discrete random variables $latex X,Y,Z$, the <strong>c</strong><strong>onditional mutual information </strong>could be defined as:</p>\n<p style=\"text-align: center;\">$latex I(X;Y|Z)=H(X|Z)-H(X|Y,Z)=I(X;Y,Z)-I(X;Z),$</p>\n\n<p>where $latex I(X;Y,Z)$ is the <strong>joint mutual information</strong>.</p>\n\n<p>As described earlier, filter methods attempt to rank the features based on statistical <em>relevance</em> measures. Therefore the simplest information theoretic filter techniques simply calculate the mutual information between all features and $latex y$ independently, rank them, and select the $latex k$ best ones. This is called Mutual Information Maximisation and it has been used in many early algorithms (Lewis 1992). This method is known to be suboptimal however, when the features are interdependent, as it will end up selecting highly correlated thus <em>redundant </em>features.</p>\n\n<p>Using the Joint Mutual Information (JMI) Moody Moody 1999) and Meyer <em>et al.</em> (Meyer 2008) proposed a method that focuses on increasing the complementary information between the selected features:</p>\n<p style=\"text-align: center;\">$latex J_{jmi}(X_i) = \\sum_{X_j \\in S}I(X_i X_j;Y),$</p>\n\n<p>where $latex J_{jmi}(X_i)$ is the JMI score for feature $latex i$ under consideration, and $latex X_j \\in S$ represents all features that were selected in previous iterations of the algorithm. This selection criterion ensures, that the candidate feature $latex X_i$ has to be <em>complementary</em> with all the previously selected features $latex X_j$ in order to be added to $latex \\bar{S}$.</p>\n\n<p>Brown <em>et al. (</em>Brown 2012) in their extensive review, systematically benchmarked 17 information theoretic filter methods including the widely used Mutual Information Feature Selection (Battiti 1994) and Max-Relevance Min-Redundancy (Peng 2005) algorithms. They performed a large empirical study to rank these methods by their accuracy, stability and flexibility, and the JMI criterion based feature selection methods were picked as overall winners.</p>\n\n<h3 id=\"how-to-select-features-using-mutual-information\">How to select features using mutual information?</h3>\n\n<p>OK, see we have these mathematical concepts of entropy and mutual information and joint mutual information. They are very useful as they don’t really assume anything about our data, yet they can somehow capture if two random variables have any sort of similarity or “connection”. But how could we use these concepts to actually perform feature selection?</p>\n\n<p>Let’s introduce some notation. We have a matrix of data $latex X^{n \\times p}$ and an outcome variable $latex y$, which could be discrete or continuous. We want to select a set of features $latex S$ from $latex X$, such that $latex |S| &lt;&lt; p$. Let’s call the set of all features $latex F, |F|=p$. We do this btw to understand which features govern the system mostly and/or to reduce the chance of over-fitting the noise in our data.</p>\n\n<p>There are two problems to address with mutual information based feature selection:</p>\n\n<ol style=\"text-align: justify;\">\n\t<li>As the number of features in our dataset ($latex p$) grows, the possible combinations to consider for $latex S$ grows exponentially and becomes intractable even for a few dozen features.</li>\n\t<li>Although it is simple to compute entropy and consequently mutual information for discrete random variables, most of the time we have continuous measurements in real life datasets. Rounding them to the nearest integer, might seem tempting but it introduces a bias into our MI estimates. Using binning or histogram based methods are better but still suffer from the same bias issue.</li>\n</ol>\n\n<h4 id=\"the-first-problem\">The first problem</h4>\n\n<p>To overcome the first problem we could calculate the MI between each feature and our outcome variable and select an arbitrary amount of the top-scoring ones. This would be a univariate approach, and require us to assume that all of our features are completely independent from each other. As we have discussed in our earlier <a href=\"/feature%20selection/phd/borutapy-an-all-relevant-feature-selection-method/\" target=\"_blank\">post about Boruta</a>, this is rarely the scenario we find ourselves in.</p>\n\n<p>A better way would be to calculate the MI between each feature and $latex y$, $latex \\forall f_i \\in F \\text{compute} I(f_i;y)$. Then select $latex f_i$ with the largest $latex I(f_i;y)$, remove it from $latex F$ and add it to $latex S$.</p>\n\n<p>Then in each consecutive round we would perform a <strong>greedy search</strong> and find the feature $latex f_i \\in F$, which has the maximum joint mutual information with the previously selected features $latex f_i \\in S$ and $latex y$:</p>\n<p style=\"text-align: center;\">$latex \\arg\\max_{f_i \\in F-S}(\\sum_{s \\in S} (I(f_i, f_s; y)))$</p>\n\n<p>This is the selection criteria of the <a href=\"http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.41.4424&amp;rep=rep1&amp;type=pdf\" target=\"_blank\">JMI</a> method and it <a href=\"http://people.ee.duke.edu/~lcarin/brown12a.pdf\">was show</a> to perform best out of 17 information theory based filter methods. As with every greedy search algorithm it can happen that we end up with suboptimal set of $latex S$.</p>\n\n<p>A recent alteration of this criterion is the <a href=\"http://www.sciencedirect.com/science/article/pii/S0957417415004674\" target=\"_blank\">Joint Mutual Information Maximisation</a> (JMIM) which uses the maximum of the minimum of the JMI:</p>\n<p style=\"text-align: center;\">$latex \\arg\\max_{f_i \\in F-S}(\\min_{s \\in S} (I(f_i, f_s; y))).$</p>\n\n<p>Beyond these two methods, I also implemented a third MI based filter method the <a href=\"http://penglab.janelia.org/papersall/docpdf/2005_TPAMI_FeaSel.pdf\" target=\"_blank\">Minimum Redundancy Maximum Relevance</a> algorithm, which is quite famous  and heavily used in life sciences.</p>\n\n<h4 id=\"the-second-problem\">The second problem</h4>\n\n<p>To overcome the second problem I used the well established <a href=\"http://arxiv.org/pdf/cond-mat/0305641.pdf\" target=\"_blank\">kNN based</a> MI<a href=\"http://rspa.royalsocietypublishing.org/content/464/2093/1203.full-text.pdf\" target=\"_blank\"> estimation methods</a> in the case when both $latex X$ and $latex y$ are continuous. I used the excellent sklearn based Python implementation of <a href=\"https://gist.github.com/GaelVaroquaux/ead9898bd3c973c40429\" target=\"_blank\">Gael Varoquaux</a> on GitHub to get started.</p>\n\n<p>Most of the times in life sciences however, we have continuous measurements in $latex X$ and a discrete $latex y$ denoting some class membership like “treatment” vs “control”. None of the previously described MI estimating procedures apply to this scenario and until recently there was no accepted way to deal with this (at least to the best of my knowledge).</p>\n\n<p>Luckily an extension of the above described kNN method <a href=\"http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0087357\">got published</a> recently which deals with this problem. I coded up the method in Python and compared the MI estimates I got from it, with the Matlab implementation that came with the paper. The numbers matched up nicely and the Python version was 5-10 times faster, thanks to the fantastic kNN algorithm in scikit-learn. So the mifs module can be used to select features from a continuous $latex X$ matrix against a categorical or a discrete outcome variable, using mutual information based metrics.</p>\n\n<h3 id=\"going-parallel\">Going parallel</h3>\n\n<p>Since these filter methods spend most of the CPU time on calculating MI between columns of $latex X$ and $latex y$, which is embarrassingly parallel, I used joblib to make the mifs module run in parallel. It utilizes all the cores the user has and this can easily cut the time spent on feature selection in half or even make it shorter.</p>\n\n<h2 id=\"feedback\">Feedback</h2>\n\n<p>Hopefully this easy to use implementation will make these information theory based feature selection methods more appealing to researchers. Please let me know if I cocked something up or if you think I could improve this work. I’m planning to adopt a chapter from my late stage PhD report into another blog post and show some benchmarking results where I compare the MI based filter methods, the Boruta method and other better established FS methods, so stay tuned..</p>",
  "author": {
    "name": "danielhomola"
  },
  "category": [
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  "summary": "A Python package for parallelized Mutual Information based Feature Selection"
}