{
  "title": "Deterministic A/B tests via the hashing trick",
  "author": {
    "name": "Chris Stucchio"
  },
  "link": "",
  "updated": "2018-03-20T08:30:00+01:00Z",
  "published": "2018-03-20T08:30:00+01:00Z",
  "id": "https://www.chrisstucchio.com/blog/2018/deterministic_ab_test.html",
  "content": "\n                (If mathematical formulas are not showing up here, <a href=\"https://www.chrisstucchio.com/blog/2018/deterministic_ab_test.html?utm_medium=rss&utm_source=rss&utm_campaign=rss\">please read this on the web.</a>.)\n                <p>In principle A/B testing is really simple. To do it you need to define two separate user experiences, and then randomly allocate users between them:</p>\n<pre>def final_experience(user):\n    if random.choice([0,1]) == 0:\n        return user_experience_A(user)\n    else:\n        return user_experience_B(user)</pre>\n<p>So far this seems pretty simple. But then you think about edge cases:</p>\n<ul class=\"simple\">\n<li>Shouldn't the same user get the same experience if they do this twice?</li>\n<li>After the test is complete, how can I compare group A and b?</li>\n</ul>\n<p>It's not hard to track this data, but it certainly makes your code a bit uglier:</p>\n<pre>def final_experience(user):\n    user_variation = db.run_query(\"SELECT user_variation FROM users WHERE user_id = ?\", user.id)\n    if user_variation == 0: # If the user already saw a variation, show them the same one\n        return user_experience_A(user)\n    elif user_variation == 1:\n        return user_experience_B(user)\n    else: #No record in the DB\n        user_variation = random.choice([0,1])\n        db.run_query(\"INSERT INTO user_variation (user_id, variation) VALUES (?, ?)\", user.id, user_variation)\n        if user_variation == 0:\n            return user_experience_A(user)\n        else:\n            return user_experience_B(user)</pre>\n<p>This is doable, but the code is a lot longer and more annoying. Are there race conditions? Should everything live in a single transaction, potentially skewing things?</p>\n<p>Fortunately there's a better way: the hashing trick.:</p>\n<pre>def deterministic_random_choice(user_id, test_name, num_variations):\n    \"\"\"Returns a 'random'-ish number, between 0 and num_variations,\n       based on the user_id and the test name.\n\n       The number will not change if the user_id and test name\n       remain the same.\n       \"\"\"\n   return (hash(user_id + test_name) % num_variations)\n\ndef final_experience(user):\n    if deterministic_random_choice(user.id, \"experience_test\", 2) == 0:\n        return user_experience_A(user)\n    else:\n        return user_experience_B(user)</pre>\n<p>Usingdeterministic_random_choice instead of random.choice will ensure that the same user is always assigned to the same variation. This is done without any database access.</p>\n<p>It also makes it very easy to run analytics and compare the two groups, even though we never stored group membership in any database table:</p>\n<pre>SELECT SUM(user.revenue), COUNT(user.id), deterministic_random_choice(user.id, \"experience_test\", 2)\n        FROM users\n        WHERE user.signup_date > test_start_date\n      GROUP BY deterministic_random_choice(user.id, \"experience_test\", 2)</pre>\n<p>(This is not SQL that any real DB will actually run, but it's illustrative.)</p>\n<p>Whatever you currently do for analytics, you can take the exact same queries and either GROUP BY the deterministic_random_choice or else run the query once for each variation and put deterministic_random_choice(user.id, \"experience_test\", 2) = 0,1 into the WHERE clause.</p>\n<p>It's just a nice simple trick that makes it easy to start A/B testing today. No database migration in sight!</p>\n<p>This post was first published on the <a href=\"https://medium.com/simpl-under-the-hood/deterministic-a-b-tests-via-the-hashing-trick-d1ea49483202\">Simpl company blog</a>.</p>\n\n              "
}