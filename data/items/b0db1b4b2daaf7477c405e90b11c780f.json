{
  "title": "Independent component analysis",
  "link": "",
  "published": "2016-02-14T00:00:00-08:00",
  "updated": "2016-02-14T00:00:00-08:00",
  "author": {
    "name": "Jonathan Landy"
  },
  "id": "tag:efavdb.com,2016-02-14:/independent-component-analysis",
  "summary": "<p>Two microphones are placed in a room where two conversations are taking place simultaneously. Given these two recordings, can one &#8220;remix&#8221; them in some prescribed way to isolate the individual conversations? Yes! In this post, we review one simple approach to solving this type of problem, Independent Component Analysis (<span class=\"caps\">ICA …</span></p>",
  "content": "<p>Two microphones are placed in a room where two conversations are taking place simultaneously. Given these two recordings, can one &#8220;remix&#8221; them in some prescribed way to isolate the individual conversations? Yes! In this post, we review one simple approach to solving this type of problem, Independent Component Analysis (<span class=\"caps\">ICA</span>). We share an ipython document implementing <span class=\"caps\">ICA</span> and link to a youtube video illustrating its application to audio&nbsp;de-mixing.</p>\n<h3>Introduction</h3>\n<p>To formalize the problem posed in the abstract, let two desired conversation signals be represented by <span class=\"math\">\\(c_1(t)\\)</span> and <span class=\"math\">\\(c_2(t)\\)</span>, and two mixed microphone recordings of these by <span class=\"math\">\\(m_1(t)\\)</span> and <span class=\"math\">\\(m_2(t)\\)</span>. We&#8217;ll assume that the latter are both linear combinations of the former,&nbsp;with\n</p>\n<div class=\"math\">\\begin{align} \\label{mean}\nm_1(t) &amp;= a_1 c_1(t) + a_2 c_2(t) \\\\\nm_2(t) &amp;= a_3 c_1(t) + a_4 c_2(t). \\label{1} \\tag{1}\n\\end{align}</div>\n<p>\nHere, we stress that the <span class=\"math\">\\(a_i\\)</span> coefficients in (\\ref{1}) are hidden from us: We only have access to the <span class=\"math\">\\(m_i\\)</span>. Hypothetical illustrations are given in the figure below. Given only these mixed signals, we&#8217;d like to recover the underlying <span class=\"math\">\\(c_i\\)</span> used to construct them (spoiler: a sine wave and a saw-tooth function were used for this&nbsp;figure).</p>\n<p><a href=\"https://efavdb.com/wp-content/uploads/2016/02/mixed2.jpg\"><img alt=\"mixed\" src=\"https://efavdb.com/wp-content/uploads/2016/02/mixed2.jpg\"></a></p>\n<p>Amazingly, it turns out that with the introduction of a modest assumption, a simple solution to our problem can be obtained: We need only assume that the desired <span class=\"math\">\\(c_i\\)</span> are mutually independent<span class=\"math\">\\(^1\\)</span>. This assumption is helpful because it turns out that when two independent signals are added together, the resulting mixture is always &#8220;more Gaussian&#8221; than either of the individual, independent signals (a la the central limit theorem). Seeking linear combinations of the available <span class=\"math\">\\(m_i\\)</span> that locally extremize their non-Gaussian character therefore provides a way to identify the pure, unmixed signals. This approach to solving the problem is called &#8220;Independent Component Analysis&#8221;, or <span class=\"caps\">ICA</span>.</p>\n<p>Here, we demonstrate the principle of <span class=\"caps\">ICA</span> through consideration of the audio de-mixing problem. This is a really impressive application. However, one should strive to remember that the algorithm is not a one-trick-pony. <span class=\"caps\">ICA</span> is an unsupervised machine learning algorithm of general applicability &#8212; similar in nature, and complementary to, the more familiar <a href=\"http://efavdb.github.io/principal-component-analysis\"><span class=\"caps\">PCA</span></a> algorithm. Whereas in <span class=\"caps\">PCA</span> we seek the feature-space directions that maximize captured variance, in <span class=\"caps\">ICA</span> we seek those directions that maximize the &#8220;interestingness&#8221; of the distribution &#8212; i.e., the non-Gaussian character of the resulting projections. It can be fruitfully applied in many contexts<span class=\"math\">\\(^2\\)</span>.</p>\n<p>We turn now to the problem of audio de-mixing via <span class=\"caps\">ICA</span>.</p>\n<h3>Audio&nbsp;de-mixing</h3>\n<p>In this post, we use the kurtosis of a signal to quantify its degree of &#8220;non-Gaussianess&#8221;. For a given signal <span class=\"math\">\\(x(t)\\)</span>, this is defined&nbsp;as\n</p>\n<div class=\"math\">$$\n\\kappa(x) \\equiv \\left \\langle \\left (x- \\langle x \\rangle \\right)^4 \\right \\rangle - 3 \\left \\langle \\left (x- \\langle x \\rangle \\right)^2 \\right \\rangle^2, \\label{2} \\tag{2}\n$$</div>\n<p>\nwhere brackets represent an average over time (or index). It turns out that the kurtosis is always zero for a Gaussian-distributed signal, so (\\ref{2}) is a natural choice of score function for measuring deviation away from Gaussian behavior<span class=\"math\">\\(^3\\)</span>. Essentially, it&#8217;s a measure of how flat a distribution is &#8212; with numbers greater (smaller) than 0 corresponding to distributions that are more (less) flat than a&nbsp;Gaussian.</p>\n<p>With (\\ref{2}) chosen as our score function, we can now jump right into applying <span class=\"caps\">ICA</span>. The code snippet below considers all possible mixtures of two mixed signals <span class=\"math\">\\(m_1\\)</span> and <span class=\"math\">\\(m_2\\)</span>, obtains the resulting signal kurtosis values, and plots the&nbsp;result.</p>\n<div class=\"highlight\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">kurtosis_of_mixture</span><span class=\"p\">(</span><span class=\"n\">c1</span><span class=\"p\">):</span>\n    <span class=\"n\">c2</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sqrt</span><span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">-</span> <span class=\"n\">c1</span> <span class=\"o\">**</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n    <span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"n\">c1</span> <span class=\"o\">*</span> <span class=\"n\">m1</span> <span class=\"o\">+</span> <span class=\"n\">c2</span> <span class=\"o\">*</span> <span class=\"n\">m2</span>\n    <span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"n\">s</span> <span class=\"o\">/</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">std</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)</span>\n    <span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"n\">mean</span><span class=\"p\">([</span><span class=\"n\">item</span> <span class=\"o\">**</span> <span class=\"mi\">4</span> <span class=\"k\">for</span> <span class=\"n\">item</span> <span class=\"ow\">in</span> <span class=\"n\">s</span><span class=\"p\">])</span> <span class=\"o\">-</span> <span class=\"mi\">3</span>\n    <span class=\"k\">return</span> <span class=\"n\">k</span>\n\n<span class=\"n\">c_array</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mf\">0.001</span><span class=\"p\">)</span>\n<span class=\"n\">k_array</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">kurtosis_of_mixture</span><span class=\"p\">(</span><span class=\"n\">item</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">item</span> <span class=\"ow\">in</span> <span class=\"n\">c_array</span><span class=\"p\">]</span>\n\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">c_array</span><span class=\"p\">,</span> <span class=\"n\">k_array</span><span class=\"p\">)</span>\n</pre></div>\n\n\n<p><a href=\"https://efavdb.com/wp-content/uploads/2016/02/k3.jpg\"><img alt=\"k\" src=\"https://efavdb.com/wp-content/uploads/2016/02/k3.jpg\"></a></p>\n<p>In line <span class=\"math\">\\((3)\\)</span> of the code here, we define the &#8220;remixed&#8221; signal <span class=\"math\">\\(s\\)</span>, which is a linear combination of the two mixed signals <span class=\"math\">\\(m_1\\)</span> and <span class=\"math\">\\(m_2\\)</span>. Note that in line <span class=\"math\">\\((4)\\)</span>, we normalize the signal so that it always has variance <span class=\"math\">\\(1\\)</span> &#8212; this simply eliminates an arbitrary scale factor from the analysis. Similarly in line <span class=\"math\">\\((2)\\)</span>, we specify <span class=\"math\">\\(c_2\\)</span> as a function of <span class=\"math\">\\(c_1\\)</span>, requiring the sum of their squared values to equal one &#8212; this fixes another arbitrary scale&nbsp;factor.</p>\n<p>When we applied the code above to the two signals shown in the introduction, we obtained the top plot at right. This shows the kurtosis of <span class=\"math\">\\(s\\)</span> as a function of <span class=\"math\">\\(c_1\\)</span>, the weight applied to signal <span class=\"math\">\\(m_1\\)</span>. Notice that there are two internal extrema in this plot: a peak near <span class=\"math\">\\(-0.9\\)</span> and a local minimum near <span class=\"math\">\\(-0.7\\)</span>. These are the two <span class=\"math\">\\(c_1\\)</span> weight choices that <span class=\"caps\">ICA</span> suggests may relate to the pure, underlying signals we seek. To plot each of these signals, we used code similar to the following (the code shown is just for the&nbsp;maximum)</p>\n<div class=\"highlight\"><pre><span></span><span class=\"n\">index1</span> <span class=\"o\">=</span> <span class=\"n\">k_array</span><span class=\"o\">.</span><span class=\"n\">index</span><span class=\"p\">(</span><span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">k_array</span><span class=\"p\">))</span>\n<span class=\"n\">c1</span> <span class=\"o\">=</span> <span class=\"n\">c_array</span><span class=\"p\">[</span><span class=\"n\">index1</span><span class=\"p\">]</span>\n<span class=\"n\">c2</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sqrt</span><span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">-</span> <span class=\"n\">c1</span> <span class=\"o\">**</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"n\">int16</span><span class=\"p\">(</span><span class=\"n\">item</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">item</span> <span class=\"ow\">in</span> <span class=\"n\">c1</span> <span class=\"o\">*</span> <span class=\"n\">x1</span> <span class=\"o\">+</span> <span class=\"n\">c2</span> <span class=\"o\">*</span> <span class=\"n\">x2</span><span class=\"p\">])</span>\n<span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)</span>\n</pre></div>\n\n\n<p>This code finds the index where the kurtosis was maximized, generates the corresponding remix, and plots the result. Applying this, the bottom figure at right popped out. It worked! &#8212; and with just a few lines of code, which makes it seem all the more amazing. In summary, we looked for linear combinations of the <span class=\"math\">\\(m_i\\)</span> shown in the introduction that resulted in a stationary kurtosis &#8212; plotting these combinations, we found that these were precisely the pure signals we sought<span class=\"math\">\\(^4\\)</span>.</p>\n<p>A second application to actual audio clips is demoed in our youtube video linked below. The full ipython file utilized in the video can be downloaded on our github page, <a href=\"https://github.com/EFavDB/ICA\">here</a><span class=\"math\">\\(^5\\)</span>.</p>\n<h3>Conclusion</h3>\n<p>We hope this little post has you convinced that <span class=\"caps\">ICA</span> is a powerful, yet straightforward algorithm<span class=\"math\">\\(^6\\)</span>. Although we&#8217;ve only discussed one application here, many others can be found online: Analysis of financial data, an idea to use <span class=\"caps\">ICA</span> to isolate a desired wifi signal from a crowded frequency band, and the analysis of brain waves &#8212; see discussion in the article mentioned in reference 2 &#8212; etc. In general, the potential application set of <span class=\"caps\">ICA</span> may be as large as that for <span class=\"caps\">PCA</span>. Next time you need to do some unsupervised learning or data compression, definitely keep it in&nbsp;mind.</p>\n<h3>Footnotes and&nbsp;references</h3>\n<p>[1] Formally, saying that two signals are independent means that the evolution of one conveys no information about that of the&nbsp;other.</p>\n<p>[2] For those interested in further reading on the theory and applications of <span class=\"caps\">ICA</span>, we can recommend the review article by Hyvärinen and Oja &#8212; &#8220;Independent Component Analysis: Algorithms and Applications&#8221; &#8212; available for free&nbsp;online.</p>\n<p>[3] Other metrics can also be used in the application of <span class=\"caps\">ICA</span>. The kurtosis is easy to evaluate and is also well-motivated because of the fact that it is zero for any Gaussian. However, there are non-Gaussian distributions that also have zero kurtosis. Further, as seen in our linked youtube video, peaks in the kurtosis plot need not always correspond to the pure signals. A much more rigorous approach is to use the mutual information of the signals as your score. This function is zero if and only if you&#8217;ve found a projection that results in a fully independent set of signals. Thus, it will always work. The problem with this choice is that it is much harder to evaluate &#8212; thus, simpler scores are often used in practice, even though they aren&#8217;t necessarily rigorously correct. The article mentioned in footnote 2 gives a good review of some other popular score function&nbsp;choices.</p>\n<p>[4] In general, symmetry arguments imply that the pure signals will correspond to local extrema in the kurtosis landscape. This works because the kurtosis of <span class=\"math\">\\(x_1 + a x_2\\)</span> is the same as that of <span class=\"math\">\\(x_1 - a x_2\\)</span>, when <span class=\"math\">\\(x_1\\)</span> and <span class=\"math\">\\(x_2\\)</span> are independent. To complete the argument, you need to consider coefficient expansions in the mixed space. The fact that the pure signals can sometimes sit at kurtosis local minima doesn&#8217;t really jive with the intuitive argument about mixtures being more Gaussian &#8212; but that was a vague statement anyways. A rigorous, alternative introduction could be made via mutual information, as mentioned in the previous&nbsp;footnote.</p>\n<p>[5] To run the script, you&#8217;ll need ipython installed, as well as the python packages: scipy, numpy, matplotlib, and pyaudio &#8212; see instructions for the latter <a href=\"https://people.csail.mit.edu/hubert/pyaudio/\">here</a>. The pip install command for pyaudio didn&#8217;t work for me on my mac, but the following line did:\n<code>pip install --global-option='build_ext' --global-option='-I/usr/local/include' --global-option='-L/usr/local/lib' pyaudio</code></p>\n<p>[6] Of course, things get a bit more complicated when you have a large number of signals. However, fast, simple algorithms have been found to carry this out even in high dimensions. See the reference in footnote 2 for&nbsp;discussion.</p>\n<script type=\"text/javascript\">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {\n    var align = \"center\",\n        indent = \"0em\",\n        linebreak = \"false\";\n\n    if (false) {\n        align = (screen.width < 768) ? \"left\" : align;\n        indent = (screen.width < 768) ? \"0em\" : indent;\n        linebreak = (screen.width < 768) ? 'true' : linebreak;\n    }\n\n    var mathjaxscript = document.createElement('script');\n    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';\n    mathjaxscript.type = 'text/javascript';\n    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';\n\n    var configscript = document.createElement('script');\n    configscript.type = 'text/x-mathjax-config';\n    configscript[(window.opera ? \"innerHTML\" : \"text\")] =\n        \"MathJax.Hub.Config({\" +\n        \"    config: ['MMLorHTML.js'],\" +\n        \"    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } },\" +\n        \"    jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" +\n        \"    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" +\n        \"    displayAlign: '\"+ align +\"',\" +\n        \"    displayIndent: '\"+ indent +\"',\" +\n        \"    showMathMenu: true,\" +\n        \"    messageStyle: 'normal',\" +\n        \"    tex2jax: { \" +\n        \"        inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" +\n        \"        displayMath: [ ['$$','$$'] ],\" +\n        \"        processEscapes: true,\" +\n        \"        preview: 'TeX',\" +\n        \"    }, \" +\n        \"    'HTML-CSS': { \" +\n        \"        availableFonts: ['STIX', 'TeX'],\" +\n        \"        preferredFont: 'STIX',\" +\n        \"        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" +\n        \"        linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" +\n        \"    }, \" +\n        \"}); \" +\n        \"if ('default' !== 'default') {\" +\n            \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" +\n                \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" +\n                \"VARIANT['normal'].fonts.unshift('MathJax_default');\" +\n                \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" +\n                \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" +\n                \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" +\n            \"});\" +\n            \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" +\n                \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" +\n                \"VARIANT['normal'].fonts.unshift('MathJax_default');\" +\n                \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" +\n                \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" +\n                \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" +\n            \"});\" +\n        \"}\";\n\n    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);\n    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);\n}\n</script>",
  "category": ""
}