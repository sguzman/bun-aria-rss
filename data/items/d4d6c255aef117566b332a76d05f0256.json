{
  "title": "Elephant Enlightenment: Part 1",
  "link": "",
  "updated": "2013-05-21T09:49:00-04:00",
  "id": "http://beckerfuffle.com/blog/2013/05/21/elephant-enlightenment-part-1",
  "content": "<p><a href=\"https://engineering.aweber.com/?attachment_id=761\"><img src=\"https://engineering.aweber.com/wp-content/uploads/2013/05/Hadoop_logo.svg_.png\" title=\"Hadoop_logo.svg\" alt=\"\" /></a></p>\n\n<p>For some light vacation reading, I started reading <a href=\"http://goo.gl/9Kk20\">Hadoop Beginner&rsquo;s Guide</a>. I made it through about half of the book, and I wanted to share some random facts that I found particularly enlightening.</p>\n\n<h2>Data Serialization: Compression and Splitting</h2>\n\n<p>Splitting refers to the ability of Hadoop to split input files into chunks for input into the map phase of a <a href=\"http://en.wikipedia.org/wiki/MapReduce\">MapReduce</a> job. Splitting is important for 2 reasons:</p>\n\n<ol>\n<li>It allows the map phase to be parallelized. The more splits you can make of the data, the more map processes that can be run simultaneously.</li>\n<li>It allows for data locality. It helps ensure the data being processed by your map process is available on the node where the data lives. Hadoop parallelizes data storage, if the data is stored on the same node the map task is being run on, the map phase will be more efficient.</li>\n</ol>\n\n\n<p>When choosing a &ldquo;container format&rdquo; (a.k.a <a href=\"http://en.wikipedia.org/wiki/Serialization\">serialization</a> format) for your data, you need to make sure that you pick a format that is both splittable, compressible, and fast. There are a few container file formats these include Sequence File, RCFile, and Avro. These formats all support both splitting and compression. Of these, Avro seems the most promising as it has good cross language support. The main issue with using these formats is that you probably need a pre-processing phase where you convert your data into this format.</p>\n\n<p>If you don&rsquo;t want to use one of the container formats, but you want your data to be splitable, and you want your data to be compressed, you have 2 options.</p>\n\n<ol>\n<li>Use bz2 compression, this is the only compression format that supports splitting out of the box.</li>\n<li>Manually split your data into chunks and compress each chunk\nYou can find a great cheat sheet for compression & splitting in <a href=\"http://goo.gl/03FXt\" title=\"lmgtfy\">Table 4-1</a> of <a href=\"http://goo.gl/aDLsK\">Hadoop: The Definitive Guide</a></li>\n</ol>\n\n\n<h2>Data Loss</h2>\n\n<p>Data in Hadoop is replicated, but there are many ways you can lose data in Hadoop, so it&rsquo;s not an alternative to backups. Here are just a few ways you can lose data in Hadoop.</p>\n\n<h3>Parallel node failure</h3>\n\n<p>&ldquo;As the cluster size increases, so does the failure rate and having three node failures in a narrow window of time becomes less and less unlikely. Conversely, the impact also decreases but rapid multiple failures will always carry a risk of data loss.&rdquo; [<a href=\"http://goo.gl/Tp3ZT\">1</a>]</p>\n\n<h3>Cascading failures</h3>\n\n<p>A failure on one node will cause under-replicated data to be replicated to other nodes, which could result in additional failures, cascading to other machines, and so on. While this scenario is unlikely, it can occur.</p>\n\n<h3>Human Error</h3>\n\n<p>Data is not backed up or check-pointed in Hadoop. If someone accidentally deletes data, it&rsquo;s gone.</p>\n\n<h2>High Availability</h2>\n\n<p>With Hadoop 1.0, there is a single point of failure, the NameNode. The NameNode contains the fsimage file which tracks where all the data lives in the Hadoop cluster. If you lose your NameNode, you won&rsquo;t be able to use your cluster, and if you don&rsquo;t properly back up the fsimage, you <strong><span style=\"text-decoration: underline;\">will</span></strong> experience data loss. &#8221;Having to move NameNode due to a hardware failure is probably the worst crisis you can have with a Hadoop cluster.&ldquo; [<a href=\"http://goo.gl/vIVgR\">2</a>] This issue has been addressed in Hadoop 2.0, where NameNode High Availability has been implemented.</p>\n\n<h2>Bloom Filters</h2>\n\n<p>Often times in a map reduce job you want to logically combine two data sources together, or &ldquo;join&rdquo; them. There are a couple of methods for doing this; one way of doing this is by joining the data during the map portion of the MapReduce. This is more efficient that doing it in the reduce portion. To accomplish the join in the map portion of the job, you must be able to store one of your data sources in the memory of every cluster. But what if you can&rsquo;t fit all of the data into memory? &ldquo;In cases where we can accept some false positives while still guaranteeing no false negatives, a <a href=\"http://en.wikipedia.org/wiki/Bloom_filter\">Bloom filter</a> provides an extremely compact way of representing such information.&rdquo; [<a href=\"http://goo.gl/PBxJ8\">3</a>] &ldquo;The use of Bloom filters is in fact a standard technique for joining in distributed databases, and it’s used in commercial products such as Oracle 11g.&rdquo; [<a href=\"http://goo.gl/9KfWQ\">4</a>] More information on Bloom filters & Hadoop can be found in the book <a href=\"http://goo.gl/c6K47\">Hadoop in Action</a> in section 5.2. An example application of this can also be found <a href=\"http://blog.liveramp.com/2013/04/03/bloomjoin-bloomfilter-cogroup/\">here</a>.</p>\n\n<p>That&rsquo;s all for now. Check back in the future for further Elephant Enlightenments!</p>\n"
}