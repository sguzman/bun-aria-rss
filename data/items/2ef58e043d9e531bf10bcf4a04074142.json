{
  "title": "A toy DNS resolver",
  "link": "",
  "updated": "2022-02-01T09:15:14+00:00",
  "id": "https://jvns.ca/blog/2022/02/01/a-dns-resolver-in-80-lines-of-go/",
  "content": "\n\n<p>Hello! I wrote a comic last week called &ldquo;life of a DNS query&rdquo; that explains how\nDNS resolvers work.</p>\n\n<p>In this post, I want to explain how DNS resolvers work in a different way &ndash;\nwith a short Go program that does the same thing described in the comic.\nThe main function (<code>resolve</code>) is actually just 20 lines, including comments.</p>\n\n<p>I usually find it easier to understand things work when they come in the form\nof programs that I can run and modify and poke at, so hopefully this program\nwill be helpful to some of you.</p>\n\n<p>The program is here: <a href=\"https://github.com/jvns/tiny-resolver/blob/main/resolve.go\">https://github.com/jvns/tiny-resolver/blob/main/resolve.go</a></p>\n\n<h3 id=\"what-s-a-dns-resolver\">what&rsquo;s a DNS resolver?</h3>\n\n<p>When your browser needs to make a DNS query, it asks a <strong>DNS resolvers</strong>. When\nthey start, DNS resolvers don&rsquo;t know any DNS records (except the IP addresses\nof the root nameservers). But they <em>do</em> know how to find DNS records for you.</p>\n\n<p>Here&rsquo;s the &ldquo;life of a DNS query&rdquo; comic, which explains how DNS resolvers find DNS records for you.</p>\n\n<p><a href=\"https://wizardzines.com/comics/life-of-a-dns-query/\">\n<img src=\"https://wizardzines.com/comics/life-of-a-dns-query/life-of-a-dns-query.png\">\n</a></p>\n\n<h3 id=\"we-ll-use-a-library-for-parsing-dns-packets\">we&rsquo;ll use a library for parsing DNS packets.</h3>\n\n<p>I&rsquo;m not going to write this completely from scratch &ndash; I think parsing DNS\npackets is really interesting, but it&rsquo;s definitely more than 80 lines of\ncode, and I find that it kind of distracts from the algorithm.</p>\n\n<p>I really recommend writing a toy DNS resolver that actually does the parsing of\nDNS packets if you want to learn about binary protocols though, it&rsquo;s really fun\nand it&rsquo;s a totally doable to get something basic working in a weekend.</p>\n\n<p>So I&rsquo;ve used <a href=\"https://github.com/miekg/dns\">https://github.com/miekg/dns</a> for creating and parsing the DNS packets.</p>\n\n<h3 id=\"dns-responses-contain-4-sections\">DNS responses contain 4 sections</h3>\n\n<p>You might think of DNS queries as just being a question and an answer (&ldquo;what&rsquo;s\nthe IP for <code>example.com</code>? it&rsquo;s <code>93.184.216.34</code>!). But actually DNS responses\ncontain 4 sections, and we need to use all 4 sections to write our DNS\nresolver. So let&rsquo;s explain what they are.</p>\n\n<p>Here&rsquo;s the <code>Msg</code> struct from the <code>miekg/dns</code> library, which lists the sections.</p>\n\n<pre><code>type Msg struct {\n        MsgHdr\n        Compress bool       `json:\"-\"` // If true, the message will be compressed when converted to wire format.\n        Question []Question // Holds the RR(s) of the question section.\n        Answer   []RR       // Holds the RR(s) of the answer section.\n        Ns       []RR       // Holds the RR(s) of the authority section.\n        Extra    []RR       // Holds the RR(s) of the additional section.\n}\n</code></pre>\n\n<p><strong>Section 1: Question</strong>. This is the section you use when you&rsquo;re creating a\nquery. There&rsquo;s not much to it &ndash; it just has a query name (like <code>jvns.ca.</code>), a\ntype (like <code>A</code>, but encoded as an integer), and a class (which is always the\nsame these days, &ldquo;internet&rdquo;).</p>\n\n<p>Here&rsquo;s what the Question struct <code>miekg/dns</code> looks like:</p>\n\n<pre><code>type Question struct {\n        Name   string `dns:\"cdomain-name\"` // \"cdomain-name\" specifies encoding (and may be compressed)\n        Qtype  uint16\n        Qclass uint16\n}\n</code></pre>\n\n<p><strong>Section 2: Answer</strong>. When you make a request like this:</p>\n\n<pre><code>$ dig +short google.com\n93.184.216.34\n</code></pre>\n\n<p>the IP address <code>93.184.216.34</code> comes from the <strong>Answer</strong> section.</p>\n\n<p>The Answer, Authority, and Additional sections all contain <strong>DNS records</strong>.\nDifferent types of records have different formats, but they all contain a <strong>name</strong>, <strong>type</strong>, <strong>class</strong>, and <strong>TTL</strong></p>\n\n<p>Here&rsquo;s what the shared header looks like in <code>miekg/dns</code>:</p>\n\n<pre><code>type RR_Header struct {\n        Name     string `dns:\"cdomain-name\"`\n        Rrtype   uint16\n        Class    uint16\n        Ttl      uint32\n        Rdlength uint16 // Length of data after header.\n}\n</code></pre>\n\n<p>&ldquo;RR&rdquo; stands for &ldquo;Resource Record&rdquo;.</p>\n\n<p><strong>Section 3: Authority</strong>. When a nameserver redirects you to another server\n(&ldquo;ask <code>a.iana-servers.net</code> instead!&ldquo;), this is the section it uses. <code>miekg/dns</code>\ncalls this section <code>Ns</code> instead of <code>Authority</code>, I guess because it contains\n<code>NS</code> records.</p>\n\n<p>Here&rsquo;s an example of an record in the Authority section of a DNS response.</p>\n\n<pre><code>$ dig +noall +authority @h.root-servers.net example.com \ncom.\t\t\t172800\tIN\tNS\ta.gtld-servers.net.\ncom.\t\t\t172800\tIN\tNS\tb.gtld-servers.net.\n</code></pre>\n\n<p>The Authority section can also contain SOA records but that&rsquo;s not relevant to\nthis post so I&rsquo;m not going to talk about that.</p>\n\n<p><strong>Section 4: Additional</strong>. This is where &ldquo;glue records&rdquo; live. What&rsquo;s a glue\nrecord? Well, basically when a nameserver redirects you to another server,\noften it&rsquo;ll include the IP address of that server as well.</p>\n\n<p>Here are the glue records from the same query above.</p>\n\n<pre><code>$ dig +noall +additional @h.root-servers.net example.com \na.gtld-servers.net.\t172800\tIN\tA\t192.5.6.30\nb.gtld-servers.net.\t172800\tIN\tA\t192.33.14.30\n</code></pre>\n\n<p>There are other things in the Additional section as well, not just glue\nrecords, but they&rsquo;re not relevant to this blog post so I&rsquo;m not going to talk\nabout them.</p>\n\n<h3 id=\"the-basic-resolve-function-is-pretty-short\">the basic <code>resolve</code> function is pretty short</h3>\n\n<p>Now that we&rsquo;ve talked about the different sections in a DNS response, I can explain the resolver code.</p>\n\n<p>Let&rsquo;s jump into the main function for resolving a name to an IP address.</p>\n\n<p><code>name</code> here is a domain name, like <code>example.com.</code>`</p>\n\n<pre><code>func resolve(name string) net.IP {\n   // We always start with a root nameserver\n   nameserver := net.ParseIP(\"198.41.0.4\")\n   for {\n      reply := dnsQuery(name, nameserver)\n      if ip := getAnswer(reply); ip != nil { // look in the \"Answer\" section\n         // Best case: we get an answer to our query  and we're done\n         return ip\n      } else if nsIP := getGlue(reply); nsIP != nil { // look in the \"Additional\" section\n            // Second best: we get a \"glue record\" with the *IP address* of\n            // another nameserver to query \n         nameserver = nsIP\n      } else if domain := getNS(reply); domain != \"\" { // look in the \"Authority\" section\n            // Third best: we get the *domain name* of another nameserver to\n            // query, which we can look up the IP for\n         nameserver = resolve(domain)\n      } else {\n         // If there's no A record we just panic, this is not a very good\n         // resolver :)\n         panic(\"something went wrong\")\n      }\n   }\n}\n</code></pre>\n\n<p>Here&rsquo;s what that <code>resolve</code> function is doing:\n1. We start with the root nameserver\n2. Then we do a loop:\n    a. Query the nameserver and parse the response\n    a. Look in the &ldquo;Answer&rdquo; section for a response. If we find one, we&rsquo;re done\n    a. Look in the &ldquo;Additional&rdquo; section for a glue record. If we find one, use that as the nameserver for the next query\n    a. Look in the &ldquo;Authority&rdquo; section for a nameserver domain. If we find one, look up its IP and then use that IP as the nameserver for the next query</p>\n\n<p>That&rsquo;s basically the whole program. There are a few helper functions to get\nrecords out of the DNS response and to make DNS queries but I don&rsquo;t think\nthey&rsquo;re that interesting so I won&rsquo;t explain them.</p>\n\n<h3 id=\"the-output\">the output</h3>\n\n<p>The resolver prints out all DNS queries it made, and the record it used to figure out what query to make it next.</p>\n\n<p>It prints out <code>dig -r @SERVER DOMAIN</code> for each query even though it&rsquo;s not\nactually using <code>dig</code> to make the query because I liked being able to run\nthe same query myself from the command line to see the response myself, for\ndebugging purposes.</p>\n\n<p><code>-r</code> just means &ldquo;ignore what&rsquo;s in <code>.digrc</code>&rdquo;, it&rsquo;s there because I have some\noptions in my <code>.digrc</code>  (<code>+noall +answer</code>) that I wanted to disable when\ndebugging.</p>\n\n<p>Let&rsquo;s look at 3 examples of the output.</p>\n\n<h3 id=\"example-1-jvns-ca\">example 1: jvns.ca</h3>\n\n<pre><code>$ go run resolve.go jvns.ca.\ndig -r @198.41.0.4 jvns.ca.\n   any.ca-servers.ca.\t172800\tIN\tA\t199.4.144.2\ndig -r @199.4.144.2 jvns.ca.\n   jvns.ca.\t86400\tIN\tNS\tart.ns.cloudflare.com.\ndig -r @198.41.0.4 art.ns.cloudflare.com.\n   a.gtld-servers.net.\t172800\tIN\tA\t192.5.6.30\ndig -r @192.5.6.30 art.ns.cloudflare.com.\n   ns3.cloudflare.com.\t172800\tIN\tA\t162.159.0.33\ndig -r @162.159.0.33 art.ns.cloudflare.com.\n   art.ns.cloudflare.com.\t900\tIN\tA\t173.245.59.102\ndig -r @173.245.59.102 jvns.ca.\n   jvns.ca.\t256\tIN\tA\t172.64.80.1\n</code></pre>\n\n<p>We can see it had to make 6 DNS queries, 3 to look up <code>jvns.ca</code> and 3 to look up <code>jvns.ca</code>&rsquo;s nameserver, <code>art.ns.cloudflare.com</code></p>\n\n<h3 id=\"example-2-archive-org\">example 2: archive.org</h3>\n\n<pre><code>$ go run resolve.go archive.org.\ndig -r @198.41.0.4 archive.org.\n   a0.org.afilias-nst.info.\t172800\tIN\tA\t199.19.56.1\ndig -r @199.19.56.1 archive.org.\n   ns1.archive.org.\t86400\tIN\tA\t208.70.31.236\ndig -r @208.70.31.236 archive.org.\n   archive.org.\t300\tIN\tA\t207.241.224.2\nResult: 207.241.224.2\n</code></pre>\n\n<p>This one only had to make 3 DNS queries. This is because there was a glue\nrecord available for archive.org&rsquo;s nameserver (<code>ns1.archive.org.</code>).</p>\n\n<h3 id=\"example-3-www-maths-ox-ac-uk\">example 3: www.maths.ox.ac.uk</h3>\n\n<p>One last example: let&rsquo;s look up <code>www.maths.ox.ac.uk</code>. There&rsquo;s a reason for this one, I promise!</p>\n\n<pre><code>dig -r @198.41.0.4 www.maths.ox.ac.uk.\n   dns1.nic.uk.\t172800\tIN\tA\t213.248.216.1\ndig -r @213.248.216.1 www.maths.ox.ac.uk.\n   ac.uk.\t172800\tIN\tNS\tns0.ja.net.\ndig -r @198.41.0.4 ns0.ja.net.\n   e.gtld-servers.net.\t172800\tIN\tA\t192.12.94.30\ndig -r @192.12.94.30 ns0.ja.net.\n   ns0.ja.net.\t172800\tIN\tA\t128.86.1.20\ndig -r @128.86.1.20 ns0.ja.net.\n   ns0.ja.net.\t86400\tIN\tA\t128.86.1.20\ndig -r @128.86.1.20 www.maths.ox.ac.uk.\n   ns2.ja.net.\t86400\tIN\tA\t193.63.105.17\ndig -r @193.63.105.17 www.maths.ox.ac.uk.\n   www.maths.ox.ac.uk.\t300\tIN\tA\t129.67.184.128\nResult: 129.67.184.128\n</code></pre>\n\n<p>This makes <strong>7</strong> DNS queries, which is more than <code>jvns.ca</code>, which only needed\n6. Why does it make 7 DNS queries instead of 6?</p>\n\n<p>Well, it&rsquo;s because there are 4 nameservers involved in resolving <code>www.maths.ox.ac.uk</code> instead of 3. They are:</p>\n\n<ul>\n<li>the <code>.</code> nameserver</li>\n<li>the <code>uk.</code> nameserver</li>\n<li>the <code>ac.uk.</code> nameserver</li>\n<li>the <code>ox.ac.uk.</code> nameserver</li>\n</ul>\n\n<p>You could even imagine there being a 5th one (a <code>maths.ox.ac.uk.</code> nameserver), but there isn&rsquo;t in this case.</p>\n\n<p>jvns.ca only involves 3 nameservers:</p>\n\n<ul>\n<li>the <code>.</code> nameserver</li>\n<li>the <code>ca.</code> nameserver</li>\n<li>the <code>jvns.ca.</code> nameserver</li>\n</ul>\n\n<h3 id=\"real-dns-resolvers-actually-make-more-queries-than-this\">real DNS resolvers actually make more queries than this</h3>\n\n<p>When my resolver resolves <code>reddit.com.</code>, it only makes 3 DNS queries.</p>\n\n<pre><code>$ go run resolve.go reddit.com.\ndig -r @198.41.0.4 reddit.com.\n   e.gtld-servers.net.\t172800\tIN\tA\t192.12.94.30\ndig -r @192.12.94.30 reddit.com.\n   ns-378.awsdns-47.com.\t172800\tIN\tA\t205.251.193.122\ndig -r @205.251.193.122 reddit.com.\n   reddit.com.\t300\tIN\tA\t151.101.129.140\nResult: 151.101.129.140\n</code></pre>\n\n<p>But when <code>unbound</code> (the actual DNS resolver that I have running on my laptop)\nresolves reddit.com, it makes more DNS queries. I captured them with <code>tcpdump</code>\nto see what they were.</p>\n\n<p>This <code>tcpdump</code> output might be a little illegible because well, that&rsquo;s how\ntcpdump is, but hopefully it makes some sense.</p>\n\n<p>Unbound skips the first step, because it has the address of the <code>com.</code>\nnameserver cached.  Then the next 2 queries <code>unbound</code> makes are exactly the\nsame as my tiny Go resolver, except that it sends its first query to\n<code>k.gtld-servers.net</code> instead of <code>e.gtld-servers.net</code>:</p>\n\n<pre><code>12:38:35.479222 wlp3s0 Out IP pomegranate.19946 > k.gtld-servers.net.domain: 51686% [1au] A? reddit.com. (39)\n12:38:35.757033 wlp3s0 Out IP pomegranate.29111 > ns-378.awsdns-47.com.domain: 8859% [1au] A? reddit.com. (39)\n</code></pre>\n\n<p>But then it keeps making DNS queries, even after it&rsquo;s done resolving <code>reddit.com</code>:</p>\n\n<pre><code>12:38:35.757033 wlp3s0 Out IP pomegranate.29111 > ns-378.awsdns-47.com.domain: 8859% [1au] A? reddit.com. (39)\n12:38:35.757396 wlp3s0 Out IP pomegranate.31913 > ns-1775.awsdns-29.co.uk.domain: 54236% [1au] A? ns-378.awsdns-47.com. (49)\n12:38:35.757761 wlp3s0 Out IP pomegranate.62059 > g.gtld-servers.net.domain: 28793% [1au] A? awsdns-05.net. (42)\n12:38:35.757955 wlp3s0 Out IP pomegranate.34743 > b0.org.afilias-nst.org.domain: 24975% [1au] A? awsdns-00.org. (42)\n12:38:35.758051 wlp3s0 Out IP pomegranate.8977 > a0.org.afilias-nst.info.domain: 53387% [1au] A? awsdns-00.org. (42)\n12:38:35.758285 wlp3s0 Out IP pomegranate.11376 > j.gtld-servers.net.domain: 41181% [1au] A? awsdns-05.net. (42)\n12:38:35.775497 wlp3s0 In  IP ns-378.awsdns-47.com.domain > pomegranate.29111: 8859*-$ 4/4/1 A 151.101.1.140, A 151.101.129.140, A 151.101.65.140, A 151.101.193.140 (240)\n12:38:35.775948 lo    In  IP localhost.domain > localhost.34429: 4033 4/0/1 A 151.101.1.140, A 151.101.129.140, A 151.101.65.140, A 151.101.193.140 (103)\n# now it's done -- it returned its DNS response!\n# but it keeps making queries about reddit.com's nameservers...\n12:38:35.843811 wlp3s0 Out IP pomegranate.44738 > ns-706.awsdns-24.net.domain: 14817% [1au] A? ns-1029.awsdns-00.org. (50)\n12:38:35.845563 wlp3s0 Out IP pomegranate.55655 > ns-1027.awsdns-00.org.domain: 3120% [1au] A? ns-1029.awsdns-00.org. (50)\n12:38:36.017618 wlp3s0 Out IP pomegranate.53397 > ns-775.awsdns-32.net.domain: 32671% [1au] A? ns-557.awsdns-05.net. (49)\n12:38:36.045151 wlp3s0 Out IP pomegranate.40525 > ns-454.awsdns-56.com.domain: 20823% [1au] A? ns-557.awsdns-05.net. (49)\n</code></pre>\n\n<p>So that&rsquo;s kind of interesting. I guess it makes sense that unbound would want\nto cache more nameserver addresses in case it needs them in the future. Or\nmaybe that&rsquo;s what the DNS specification says to do?</p>\n\n<h3 id=\"is-this-a-recursive-program\">is this a &ldquo;recursive&rdquo; program?</h3>\n\n<p>DNS resolvers are often called &ldquo;recursive nameservers&rdquo;. I&rsquo;ve stopped using that\nterminology myself in explanations, but as far as I can tell, this is because\nthe <code>resolve</code> function is often a recursive function.</p>\n\n<p>And the <code>resolve</code> function I wrote is definitely recursive! But I ran this\nprogram on 500 different domains, and these are the number of times it\nrecursed:</p>\n\n<ol>\n<li>Sometimes 0 times (the function never calls itself)</li>\n<li>Sometimes 1 time (the function calls itself once, to look up the IP address of one nameserver)</li>\n<li>Very rarely 2 times (like for example to resolve <code>abc.net.au.</code> right now it needs to look up <code>r.au.</code>, then <code>eur2.akam.net.</code> then <code>abc.net.au.</code>)</li>\n<li>So far, never 3 times</li>\n</ol>\n\n<p>Maybe there&rsquo;s a domain that this function would recurse more than 2 times on, but I don&rsquo;t know.</p>\n\n<p>You definitely <em>could</em> write this program in a way that recurses more, by\nreplacing the loop with more recursion. And then it would recurse 3 or 6 or 7\nor 9 times, depending on the domain. But to me the loop feels easier to read so\nI wrote it with a loop instead.</p>\n\n<h3 id=\"a-bash-version-of-this-resolver\">a bash version of this resolver</h3>\n\n<p>I wanted to see if it was possible to write a DNS resolver in 10-15 lines of bash, similarly to <a href=\"https://gist.github.com/jvns/ea2e4d572b4e2285148b8e87f70eed73\">this short &ldquo;run a container&rdquo; script</a></p>\n\n<p>The program I came up with was kind of too long in the end (it&rsquo;s about 36 lines), but here it is anyway. It uses the exact same algorithm as the Go program.</p>\n\n<p><a href=\"https://github.com/jvns/tiny-resolver/blob/main/resolver.sh\">https://github.com/jvns/tiny-resolver/blob/main/resolver.sh</a></p>\n\n<p>The bash version is even more janky and uses <code>grep</code> in very questionable ways\nbut it did resolve every domain I tried which is cool.</p>\n\n<p>It actually helped me write the Go resolver (which I actually started back in\nNovember but got stuck on) because bash&rsquo;s limitations forced me to simplify the\ndesign and simplifying it fixed a bug I was running into.</p>\n\n<h3 id=\"how-is-this-different-from-a-real-dns-resolver\">how is this different from a &ldquo;real&rdquo; DNS resolver?</h3>\n\n<p>Obviously this is only 80 lines so there are a lot of differences between this\nan a &ldquo;real&rdquo; DNS resolver. Here are a few:</p>\n\n<ul>\n<li>it only handles A records, not other record types</li>\n<li>specifically it doesn&rsquo;t handle CNAME records (though you can easily add CNAME support with just <a href=\"https://github.com/jvns/tiny-resolver/commit/8a2dada63ec214ecf01046e3f57eb5406706b302\">another 12 lines of code</a>)</li>\n<li>it always only returns one A record even if there are more</li>\n<li>it has absolutely no ability to handle errors like &ldquo;there were no A records&rdquo; (the Go program just panics)</li>\n<li>the way it handles the glue records is a bit sketchy, probably it should\ncheck that they match the nameservers in the &ldquo;Authority&rdquo; section or\nsomething.  It seems to work though.</li>\n<li>DNS resolvers are usually servers, this is a command line program</li>\n<li>it doesn&rsquo;t validate DNSSEC or whatever</li>\n<li>it doesn&rsquo;t do caching</li>\n<li>it doesn&rsquo;t try a different nameserver if one of the domain&rsquo;s nameservers isn&rsquo;t working and times out the DNS query</li>\n<li>like we mentioned above, unbound seems to look up the addresses of all the nameservers for a domain</li>\n<li>probably there are other bugs and ways it violates the DNS spec that I don&rsquo;t know about</li>\n</ul>\n\n<h3 id=\"tiny-versions-of-real-programs-are-fun\">tiny versions of real programs are fun</h3>\n\n<p>As usual I always learn something from writing tiny versions of real programs.\nI&rsquo;ve written this program before but I think this version is better than the\nfirst version I wrote.</p>\n\n<p>In 2020 I ran a 2-day workshop with my friend Allison called &ldquo;Domain Name\nSaturday&rdquo; where all the participants wrote DNS resolvers. Basically the idea\nwas that you implement the algorithm described in this post, as well as the\nbinary parsing pieces that the <code>miekg/dns</code> library handles here. At some point\nI want to write up that workshop so that other people could run it, because it\nwas really fun.</p>\n\n<p>One question I still have is &ndash; are there domains where the <code>resolve</code> function\nwould recurse 3 times or more on? Obviously you could manufacture such a domain\nby making it intentionally have to go through a bunch of hoops, but.. do they\nexist in the real world?</p>\n"
}