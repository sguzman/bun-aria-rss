{
  "title": "Selecting good features – Part IV: stability selection, RFE and everything side by side",
  "link": "http://blog.datadive.net/selecting-good-features-part-iv-stability-selection-rfe-and-everything-side-by-side/",
  "comments": "http://blog.datadive.net/selecting-good-features-part-iv-stability-selection-rfe-and-everything-side-by-side/#comments",
  "dc:creator": "ando",
  "pubDate": "Sat, 20 Dec 2014 13:49:53 +0000",
  "category": [
    "Feature selection",
    "Machine learning"
  ],
  "guid": "http://blog.datadive.net/?p=1392",
  "description": "In my previous posts, I looked at univariate methods,linear models and regularization and random forests for feature selection.In this post, I&#8217;ll look at two other methods: stability selection and recursive feature elimination (RFE), which can both considered wrapper methods. They &#8230; <a href=\"http://blog.datadive.net/selecting-good-features-part-iv-stability-selection-rfe-and-everything-side-by-side/\">Continue reading <span class=\"meta-nav\">&#8594;</span></a>",
  "content:encoded": "<p>In my previous posts, I looked at <a href=\"/selecting-good-features-part-i-univariate-selection/\">univariate methods</a>,<a href=\"/selecting-good-features-part-ii-linear-models-and-regularization/\">linear models and regularization</a> and <a href=\"/selecting-good-features-part-iii-random-forests/\">random forests</a> for feature selection.</p><p>In this post, I&#8217;ll look at two other methods: stability selection and recursive feature elimination (RFE), which can both considered wrapper methods. They both build on top of other (model based) selection methods such as regression or SVM, building models on different subsets of data and extracting the ranking from the aggregates.</p><p>As a wrap-up I&#8217;ll run all previously discussed methods, to highlight their pros, cons and gotchas with respect to each other.</p>\n<h1>Stability selection </h1><p><a href=\"http://stat.ethz.ch/~nicolai/stability.pdf\">Stability selection</a> is a relatively novel method for feature selection, based on subsampling in combination with selection algorithms (which could be regression, SVMs or other similar method). The high level idea is to apply a feature selection algorithm on different subsets of data and with different subsets of features. After repeating the process a number of times, the selection results can be aggregated, for example by checking how many times a feature ended up being selected as important when it was in an inspected feature subset. We can expect strong features to have scores close to 100%, since they are always selected when possible. Weaker, but still relevant features will also have non-zero scores, since they would be selected when stronger features are not present in the currently selected subset, while irrelevant features would have scores (close to) zero, since they would never be among selected features.</p><p>Sklearn implements stability selection in the <a href=\"http://scikit-learn.org/stable/modules/generated/sklearn.linear_model.RandomizedLasso.html\">randomized lasso</a> and <a href=\"http://scikit-learn.org/stable/modules/generated/sklearn.linear_model.RandomizedLogisticRegression.html\">randomized logistics regression</a> classes.</p>\n<pre class=\"brush: python; collapse: false; title: ; wrap-lines: false; notranslate\">\nfrom sklearn.linear_model import RandomizedLasso\nfrom sklearn.datasets import load_boston\nboston = load_boston()\n\n#using the Boston housing data. \n#Data gets scaled automatically by sklearn's implementation\nX = boston[\"data\"]\nY = boston[\"target\"]\nnames = boston[\"feature_names\"]\n\nrlasso = RandomizedLasso(alpha=0.025)\nrlasso.fit(X, Y)\n\nprint \"Features sorted by their score:\"\nprint sorted(zip(map(lambda x: round(x, 4), rlasso.scores_), \n                 names), reverse=True)\n</pre>\n<blockquote><p><code><br />\nFeatures sorted by their score:<br />\n[(1.0, 'RM'), (1.0, 'PTRATIO'), (1.0, 'LSTAT'), (0.62, 'CHAS'), (0.595, 'B'), (0.39, 'TAX'), (0.385, 'CRIM'), (0.25, 'DIS'), (0.22, 'NOX'), (0.125, 'INDUS'), (0.045, 'ZN'), (0.02, 'RAD'), (0.015, 'AGE')]<br />\n</code></p></blockquote><p>As you can see from the example, the top 3 features have equal scores of 1.0, meaning they were always selected as useful features (of course this could and would change when changing the regularization parameter, but sklearn&#8217;s <a href=\"http://scikit-learn.org/stable/modules/generated/sklearn.linear_model.RandomizedLasso.html\">randomized lasso</a> implementation can choose a good \\(\\alpha\\) parameter automatically). The scores drop smoothly from there, but in general, the drop off is not sharp as is often the case with pure lasso, or random forest. This means stability selection is useful for both pure feature selection to reduce overfitting, but also for data interpretation: in general, good features won&#8217;t get 0 as coefficients just because there are similar, correlated features in the dataset (as is the case with lasso). For feature selection, I&#8217;ve found it to be among the top performing methods for many different datasets and settings.</p>\n<h1>Recursive feature elimination</h1><p>Recursive feature elimination is based on the idea to repeatedly construct a model (for example an SVM or a regression model) and choose either the best or worst performing feature (for example based on coefficients), setting the feature aside and then repeating the process with the rest of the features. This process is applied until all features in the dataset are exhausted. Features are then ranked according to when they were eliminated. As such, it is a greedy optimization for finding the best performing subset of features.</p><p>The stability of RFE depends heavily on the type of model that is used for feature ranking at each iteration. Just as non-regularized regression can be unstable, so can RFE when utilizing it, while using ridge regression can provide more stable results.</p><p>Sklearn provides <a href=\"http://scikit-learn.org/stable/modules/generated/sklearn.feature_selection.RFE.html\">RFE</a> for recursive feature elimination and <a href=\"http://scikit-learn.org/stable/modules/generated/sklearn.feature_selection.RFECV.html\">RFECV</a> for finding the ranks together with optimal number of features via a cross validation loop.</p>\n<pre class=\"brush: python; collapse: false; title: ; wrap-lines: false; notranslate\">\nfrom sklearn.feature_selection import RFE\nfrom sklearn.linear_model import LinearRegression\n\nboston = load_boston()\nX = boston[\"data\"]\nY = boston[\"target\"]\nnames = boston[\"feature_names\"]\n\n#use linear regression as the model\nlr = LinearRegression()\n#rank all features, i.e continue the elimination until the last one\nrfe = RFE(lr, n_features_to_select=1)\nrfe.fit(X,Y)\n\nprint \"Features sorted by their rank:\"\nprint sorted(zip(map(lambda x: round(x, 4), rfe.ranking_), names))\n</pre>\n<blockquote><p><code><br />\nFeatures sorted by their rank:<br />\n[(1.0, 'NOX'), (2.0, 'RM'), (3.0, 'CHAS'), (4.0, 'PTRATIO'), (5.0, 'DIS'), (6.0, 'LSTAT'), (7.0, 'RAD'), (8.0, 'CRIM'), (9.0, 'INDUS'), (10.0, 'ZN'), (11.0, 'TAX'), (12.0, 'B'), (13.0, 'AGE')]<br />\n</code></p></blockquote>\n<h1>Example: running the methods side by side </h1><p>I&#8217;ll now take all the examples from this post, and the <a href=\"/selecting-good-features-part-i-univariate-selection/\">three</a> <a href=\"/selecting-good-features-part-ii-linear-models-and-regularization/\">previous</a> <a href=\"/selecting-good-features-part-iii-random-forests/\">ones</a> and run the methods on a sample dataset to compare them side by side. The dataset will be the so called Friedman #1 regression dataset (from Friedman&#8217;s <a href=\"ftp://ftp.uic.edu/pub/depts/econ/hhstokes/e538/Friedman_mars_1991.pdf\">Multivariate Adaptive Regression Splines</a> paper). The data is generated according to formula \\(y = 10sin(\\pi x_1 x_2) + 20(x_3 &#8211; 0.5)^2 + 10X_4 + 5X_5 +\\epsilon\\), where the \\(x_1\\) to \\(x_5\\) are drawn from uniform distribution and \\(\\epsilon\\) is the standard normal deviate \\(N(0,1)\\). Additionally, the original dataset had five noise variables \\(x_6,&#8230;,x_{10}\\), independent of the response variable. We will increase the number of variables further and add four variables \\(x_{11},&#8230;,x_{14}\\) each of which are very strongly correlated with \\(x_1,&#8230;,x_4\\), respectively, generated by \\(f(x) = x + N(0, 0.01)\\). This yields a correlation coefficient of more than 0.999 between the variables. This will illustrate how different feature ranking methods deal with correlations in the data.</p><p>We&#8217;ll apply run each of the above listed methods on the dataset and normalize the scores so that that are between 0 (for lowest ranked feature) and 1 (for the highest feature). For recursive feature elimination, the top five feature will all get score 1, with the rest of the ranks spaced equally between 0 and 1 according to their rank.</p>\n<pre class=\"brush: python; collapse: false; title: ; wrap-lines: false; notranslate\">\nfrom sklearn.datasets import load_boston\nfrom sklearn.linear_model import (LinearRegression, Ridge, \n                                  Lasso, RandomizedLasso)\nfrom sklearn.feature_selection import RFE, f_regression\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.ensemble import RandomForestRegressor\nimport numpy as np\nfrom minepy import MINE\n\nnp.random.seed(0)\n\nsize = 750\nX = np.random.uniform(0, 1, (size, 14))\n\n#\"Friedamn #1” regression problem\nY = (10 * np.sin(np.pi*X[:,0]*X[:,1]) + 20*(X[:,2] - .5)**2 + \n     10*X[:,3] + 5*X[:,4] + np.random.normal(0,1))\n#Add 3 additional correlated variables (correlated with X1-X3)\nX[:,10:] = X[:,:4] + np.random.normal(0, .025, (size,4))\n\nnames = [\"x%s\" % i for i in range(1,15)]\n\nranks = {}\n\ndef rank_to_dict(ranks, names, order=1):\n    minmax = MinMaxScaler()\n    ranks = minmax.fit_transform(order*np.array([ranks]).T).T[0]\n    ranks = map(lambda x: round(x, 2), ranks)\n    return dict(zip(names, ranks ))\n\nlr = LinearRegression(normalize=True)\nlr.fit(X, Y)\nranks[\"Linear reg\"] = rank_to_dict(np.abs(lr.coef_), names)\n\nridge = Ridge(alpha=7)\nridge.fit(X, Y)\nranks[\"Ridge\"] = rank_to_dict(np.abs(ridge.coef_), names)\n\n\nlasso = Lasso(alpha=.05)\nlasso.fit(X, Y)\nranks[\"Lasso\"] = rank_to_dict(np.abs(lasso.coef_), names)\n\n\nrlasso = RandomizedLasso(alpha=0.04)\nrlasso.fit(X, Y)\nranks[\"Stability\"] = rank_to_dict(np.abs(rlasso.scores_), names)\n\n#stop the search when 5 features are left (they will get equal scores)\nrfe = RFE(lr, n_features_to_select=5)\nrfe.fit(X,Y)\nranks[\"RFE\"] = rank_to_dict(map(float, rfe.ranking_), names, order=-1)\n\nrf = RandomForestRegressor()\nrf.fit(X,Y)\nranks[\"RF\"] = rank_to_dict(rf.feature_importances_, names)\n\n\nf, pval  = f_regression(X, Y, center=True)\nranks[\"Corr.\"] = rank_to_dict(f, names)\n\nmine = MINE()\nmic_scores = []\nfor i in range(X.shape[1]):\n    mine.compute_score(X[:,i], Y)\n    m = mine.mic()\n    mic_scores.append(m)\n\nranks[\"MIC\"] = rank_to_dict(mic_scores, names) \n\n\nr = {}\nfor name in names:\n    r[name] = round(np.mean([ranks[method][name] \n                             for method in ranks.keys()]), 2)\n\nmethods = sorted(ranks.keys())\nranks[\"Mean\"] = r\nmethods.append(\"Mean\")\n\nprint \"\\t%s\" % \"\\t\".join(methods)\nfor name in names:\n    print \"%s\\t%s\" % (name, \"\\t\".join(map(str, \n                         [ranks[method][name] for method in methods])))\n\n</pre><p>Here&#8217;s the resulting table (sortable by clicking on the column header), with the results from each method + the mean </p>\n<div class=\"table-responsive\">\n<table  style=\"width:100%; \"  class=\"easy-table easy-table-default tablesorter  \" >\n<thead>\n<tr>\n<th class=' ' >Feature</th>\n<th class=' ' >Lin. corr.</th>\n<th class=' ' >Linear reg.</th>\n<th class=' ' >Lasso</th>\n<th class=' ' >MIC</th>\n<th class=' ' >RF</th>\n<th class=' ' >RFE</th>\n<th class=' ' >Ridge</th>\n<th class=' ' >Stability</th>\n<th class=' ' >Mean</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td >x1</td>\n<td >0.3</td>\n<td >1.0</td>\n<td >0.79</td>\n<td >0.39</td>\n<td >0.18</td>\n<td >1.0</td>\n<td >0.77</td>\n<td >0.61</td>\n<td >0.63</td>\n</tr>\n<tr>\n<td >x2</td>\n<td >0.44</td>\n<td >0.56</td>\n<td >0.83</td>\n<td >0.61</td>\n<td >0.24</td>\n<td >1.0</td>\n<td >0.75</td>\n<td >0.7</td>\n<td >0.64</td>\n</tr>\n<tr>\n<td >x3</td>\n<td >0.0</td>\n<td >0.5</td>\n<td >0.0</td>\n<td >0.34</td>\n<td >0.01</td>\n<td >1.0</td>\n<td >0.05</td>\n<td >0.0</td>\n<td >0.24</td>\n</tr>\n<tr>\n<td >x4</td>\n<td >1.0</td>\n<td >0.57</td>\n<td >1.0</td>\n<td >1.0</td>\n<td >0.45</td>\n<td >1.0</td>\n<td >1.0</td>\n<td >1.0</td>\n<td >0.88</td>\n</tr>\n<tr>\n<td >x5</td>\n<td >0.1</td>\n<td >0.27</td>\n<td >0.51</td>\n<td >0.2</td>\n<td >0.04</td>\n<td >0.78</td>\n<td >0.88</td>\n<td >0.6</td>\n<td >0.42</td>\n</tr>\n<tr>\n<td >x6</td>\n<td >0.0</td>\n<td >0.02</td>\n<td >0.0</td>\n<td >0.0</td>\n<td >0.0</td>\n<td >0.44</td>\n<td >0.05</td>\n<td >0.0</td>\n<td >0.06</td>\n</tr>\n<tr>\n<td >x7</td>\n<td >0.01</td>\n<td >0.0</td>\n<td >0.0</td>\n<td >0.07</td>\n<td >0.0</td>\n<td >0.0</td>\n<td >0.01</td>\n<td >0.0</td>\n<td >0.01</td>\n</tr>\n<tr>\n<td >x8</td>\n<td >0.02</td>\n<td >0.03</td>\n<td >0.0</td>\n<td >0.05</td>\n<td >0.0</td>\n<td >0.56</td>\n<td >0.09</td>\n<td >0.0</td>\n<td >0.09</td>\n</tr>\n<tr>\n<td >x9</td>\n<td >0.01</td>\n<td >0.0</td>\n<td >0.0</td>\n<td >0.09</td>\n<td >0.0</td>\n<td >0.11</td>\n<td >0.0</td>\n<td >0.0</td>\n<td >0.03</td>\n</tr>\n<tr>\n<td >x10</td>\n<td >0.0</td>\n<td >0.01</td>\n<td >0.0</td>\n<td >0.04</td>\n<td >0.0</td>\n<td >0.33</td>\n<td >0.01</td>\n<td >0.0</td>\n<td >0.05</td>\n</tr>\n<tr>\n<td >x11</td>\n<td >0.29</td>\n<td >0.6</td>\n<td >0.0</td>\n<td >0.43</td>\n<td >0.14</td>\n<td >1.0</td>\n<td >0.59</td>\n<td >0.39</td>\n<td >0.43</td>\n</tr>\n<tr>\n<td >x12</td>\n<td >0.44</td>\n<td >0.14</td>\n<td >0.0</td>\n<td >0.71</td>\n<td >0.12</td>\n<td >0.67</td>\n<td >0.68</td>\n<td >0.42</td>\n<td >0.4</td>\n</tr>\n<tr>\n<td >x13</td>\n<td >0.0</td>\n<td >0.48</td>\n<td >0.0</td>\n<td >0.23</td>\n<td >0.01</td>\n<td >0.89</td>\n<td >0.02</td>\n<td >0.0</td>\n<td >0.2</td>\n</tr>\n<tr>\n<td >x14</td>\n<td >0.99</td>\n<td >0.0</td>\n<td >0.16</td>\n<td >1.0</td>\n<td >1.0</td>\n<td >0.22</td>\n<td >0.95</td>\n<td >0.53</td>\n<td >0.61</td>\n</tr>\n</tbody>\n</table>\n</div><p>The example should highlight some the interesting characteristics of the different methods.</p><p>With <strong>linear correlation</strong> (Lin. corr.), each feature is evaluated independently, so the scores for features \\(x_1&#8230;x_4\\) are very similar to \\(x_{11}&#8230;x_{14}\\), while the noise features \\(x_5&#8230;x_{10}\\) are correctly identified to have almost no relation with the response variable. It&#8217;s not able to identify any relationship between \\(x_3\\) and the response variable, since the relationship is quadratic (in fact, this applies almost all other methods except for MIC). It&#8217;s also clear that while the method is able to measure the linear relationship between each feature and the response variable, it is not optimal for selecting the top performing features for improving the generalization of a model, since all top performing features would essentially be picked twice.</p><p><strong>Lasso</strong> picks out the top performing features, while forcing other features to be close to zero. It is clearly useful when reducing the number of features is required, but not necessarily for data interpretation (since it might lead one to believe that features \\(x_{11}&#8230;x_{13}\\) do not have a strong relationship with the output variable).</p><p><strong>MIC</strong> is similar to correlation coefficient in treating all features &#8220;equally&#8221;, additionally it is able to find the non-linear a relationship between \\(x_3\\) and the response.</p><p><strong>Random forest&#8217;s</strong> impurity based ranking is typically aggressive in the sense that there is a sharp drop-off of scores after the first few top ones. This can be seen from the example where the third ranked feature has already 4x smaller score than the top feature (whereas for the other ranking methods, the drop-off is clearly not that aggressive). </p><p><strong>Ridge regression</strong> forces regressions coefficients to spread out similarly between correlated variables. This is clearly visible in the example where \\(x_{11}&#8230;x_{14}\\) are close to \\(x_1&#8230;x_4\\) in terms of scores.</p><p><strong>Stability selection</strong> is often able to make a useful compromise between data interpretation and top feature selection for model improvement. This is illustrated well in the example. Just like Lasso it is able to identify the top features (\\(x_1\\), \\(x_2\\), \\(x_4\\), \\(x_5\\)). At the same time their correlated shadow variables also get a high score, illustrating their relation with the response.</p>\n<h1>Conclusions</h1><p>Feature ranking can be incredibly useful in a number of machine learning and data mining scenarios. The key though is to have the end goal clearly in mind and understand which method works best for achieving it. When selecting top features for model performance improvement, it is easy to verify if a particular method works well against alternatives simply by doing cross-validation. It&#8217;s not as straightforward when using feature ranking for data interpretation, where stability of the ranking method is crucial and a method that doesn&#8217;t have this property (such as lasso) could easily lead to incorrect conclusions. What can help there is subsampling the data and running the selection algorithms on the subsets. If the results are consistent across the subsets, it is relatively safe to trust the stability of the method on this particular data and therefor straightforward to interpret the data in terms of the ranking.</p>\n<div style=\"padding-top:0px;\t\npadding-right:0px;\npadding-bottom:0px;\npadding-left:0px;\nmargin-top:0px;\nmargin-right:0px;\nmargin-bottom:0px;\nmargin-left:0px;\"><a href=\"https://twitter.com/crossentropy\" class=\"twitter-follow-button\" \n\t\t\t\t\t\tdata-show-count=\"false\"\n\t\t\t\t\t\tdata-lang=\"autoLANGauto\"\n\t\t\t\t\t\tdata-width=\"250px\"\n\t\t\t\t\t\tdata-align=\"left\"\n\t\t\t\t\t\tdata-show-screen-name=\"true\"\n\t\t\t\t\t\tdata-size=\"medium\"\n\t\t\t\t\t\tdata-dnt=\"false\">\n\t\t\t\t\t\tFollow @crossentropy </a> </div>\n\t\t\t\t\t\t<script>\n\t\t\t\t\t\t!function(d,s,id) {\n\t\t\t\t\t\t  var js,fjs=d.getElementsByTagName(s)[0];\n\t\t\t\t\t\t  if(!d.getElementById(id)) {\n\t\t\t\t\t\t   js=d.createElement(s);\n\t\t\t\t\t\t   js.id=id;js.src=\"//platform.twitter.com/widgets.js\";\n\t\t\t\t\t\t   fjs.parentNode.insertBefore(js,fjs);\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t}\n\t\t\t\t\t\t(document,\"script\",\"twitter-wjs\");\n\t\t\t\t\t\t</script><div style=\"padding-top:0px;\t\npadding-right:0px;\npadding-bottom:0px;\npadding-left:0px;\nmargin-top:0px;\nmargin-right:0px;\nmargin-bottom:0px;\nmargin-left:0px;\"><a href=\"https://twitter.com/share\" class=\"twitter-share-button\" \n\t\t\t\t        data-url=\"http://blog.datadive.net/selecting-good-features-part-iv-stability-selection-rfe-and-everything-side-by-side/\" \n\t\t\t\t        data-via=\"crossentropy\"\n\t\t\t\t\t    data-text=\"Selecting good features – Part IV: stability selection, RFE and everything side by side\"\n\t\t\t\t\t    data-related=\"\"\n\t\t\t\t\t    data-count=\"horizontal\"\n\t\t\t\t\t    data-hashtags=\"\"\n\t\t\t\t\t    data-lang=\"autoLANGauto\"\n\t\t\t\t\t    data-counturl=\"\"\n\t\t\t\t\t    data-size=\"medium\"\n\t\t\t\t\t    data-dnt=\"false\"\t> Tweet </a> </div>\n\t\t                <script>\n\t\t\t\t\t    !function(d,s,id) {\n\t\t\t\t\t      var js,fjs=d.getElementsByTagName(s)[0];\n\t\t\t\t\t      if(!d.getElementById(id)) {\n\t\t\t\t\t       js=d.createElement(s);js.id=id;js.src=\"https://platform.twitter.com/widgets.js\";fjs.parentNode.insertBefore(js,fjs);\n\t\t\t\t\t      }\n\t\t\t\t\t    }\n\t\t\t\t\t   (document,\"script\",\"twitter-wjs\");\n\t\t\t\t\t    </script>",
  "wfw:commentRss": "http://blog.datadive.net/selecting-good-features-part-iv-stability-selection-rfe-and-everything-side-by-side/feed/",
  "slash:comments": 45
}