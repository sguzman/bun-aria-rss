{
  "title": "Counting the number of ways to make change for a trillion dollars",
  "link": "",
  "published": "2021-11-22T09:24:00-08:00",
  "updated": "2021-11-22T09:24:00-08:00",
  "author": {
    "name": "Jonathan Landy"
  },
  "id": "tag:efavdb.com,2021-11-22:/change",
  "summary": "<p>There are four ways to make change for <span class=\"math\">\\(N=10\\)</span> cents: <span class=\"math\">\\(\\{\\)</span>10 pennies; 1 nickel\nand 5 pennies; 2 nickels; 1 dime<span class=\"math\">\\(\\}\\)</span>.  How many ways are there to make change\nfor one trillion dollars &#8212; using just pennies, nickels, dimes, and quarters?\nTo answer this, we present here a hybrid dynamic …</p>",
  "content": "<p>There are four ways to make change for <span class=\"math\">\\(N=10\\)</span> cents: <span class=\"math\">\\(\\{\\)</span>10 pennies; 1 nickel\nand 5 pennies; 2 nickels; 1 dime<span class=\"math\">\\(\\}\\)</span>.  How many ways are there to make change\nfor one trillion dollars &#8212; using just pennies, nickels, dimes, and quarters?\nTo answer this, we present here a hybrid dynamic programming / analytic\nstrategy that allows us to count the number of ways <span class=\"math\">\\(\\mathbb{Q}(N)\\)</span> to make\nchange for any <span class=\"math\">\\(N\\)</span>.</p>\n<p>The result for one trillion&nbsp;dollars?</p>\n<p><span class=\"math\">\\(\\mathbb{Q}(10^{14}) = 133333333333423333333333351000000000001\\)</span>.</p>\n<h4>Dynamic programming&nbsp;solution</h4>\n<p>We begin by introducing a set of recursion relations that will directly allow\nfor a &#8220;pure&#8221; dynamic programming strategy for counting the number of ways to\nmake&nbsp;change:</p>\n<p>Let, <span class=\"math\">\\(\\mathbb{Q}(N), \\mathbb{D}(N), \\mathbb{N}(N)\\)</span> and <span class=\"math\">\\(\\mathbb{P}(N)\\)</span> be the\nnumber of ways to make change for <span class=\"math\">\\(N\\)</span> cents allowing all four denominations,\nallowing only up to dimes (i.e., excluding quarters), only up to nickels, and\nfinally only pennies, respectively.  Next, we note&nbsp;that\n</p>\n<div class=\"math\">\\begin{eqnarray} \\nonumber\n\\mathbb{Q}(N) &amp;=&amp; \\mathbb{D}(N) + \\mathbb{D}(N-25) + \\mathbb{D}(N - 50) +\n\\ldots \\\\\n&amp;\\equiv &amp; \\mathbb{D}(N) + \\mathbb{Q}(N-25). \\tag{1} \\label{q_iter}\n\\end{eqnarray}</div>\n<p>\nHere, we have decomposed the number of ways to make change in terms of the\nnumber of quarters included.  For example, the second term in the first line\nabove is the number of ways to make change when we have exactly <span class=\"math\">\\(1\\)</span> quarter:\nThe count in this case is simply the number of ways we can make change for\n<span class=\"math\">\\(N-25\\)</span> cents, using only dimes, nickels, and pennies &#8212; i.e.,\n<span class=\"math\">\\(\\mathbb{D}(N-25)\\)</span>.&nbsp;Similarly,\n</p>\n<div class=\"math\">\\begin{eqnarray} \\nonumber\n\\mathbb{D}(N) &amp;=&amp; \\mathbb{N}(N) +\\mathbb{N}(N-10) + \\mathbb{N}(N-20) + \\ldots\n\\\\\n&amp;\\equiv &amp; \\mathbb{N}(N) + \\mathbb{D}(N-10) \\tag{2} \\label{d_iter}\n\\end{eqnarray}</div>\n<p>\nand\n</p>\n<div class=\"math\">\\begin{eqnarray} \\nonumber\n\\mathbb{N}(N) &amp;=&amp; \\mathbb{P}(N) + \\mathbb{P}(N-5) + \\mathbb{P}(N-10) + \\ldots\n\\\\\n&amp;\\equiv &amp; \\mathbb{P}(N) + \\mathbb{N}(N-5).  \\tag{3}  \\label{n_iter} \n\\end{eqnarray}</div>\n<p>\nFinally, <span class=\"math\">\\(\\mathbb{P}(N) \\equiv 1\\)</span> for all natural <span class=\"math\">\\(N\\)</span>.</p>\n<p>It is straightforward to sum the above equations in reverse using dynamic\nprogramming: We start by using the fact that <span class=\"math\">\\(\\mathbb{P}(N) = 1\\)</span> all natural\n<span class=\"math\">\\(N\\)</span>, then evaluate <span class=\"math\">\\([\\mathbb{N}(1), \\ldots, \\mathbb{N}(N)]\\)</span> on a computer using\nthe iterative equation (\\ref{n_iter}).  Storing these values in memory, we can\nthen evaluate <span class=\"math\">\\([\\mathbb{D}(1), \\ldots, \\mathbb{D}(N)]\\)</span> using (\\ref{d_iter}),\nand then finally evaluate <span class=\"math\">\\([\\mathbb{Q}(1), \\ldots, \\mathbb{Q}(N)]\\)</span> using\n(\\ref{q_iter}).  A python program that carries out this strategy is given\nbelow.  Using this we are able to evaluate that, e.g., the number of ways to\nmake change for one dollar is <span class=\"math\">\\(\\mathbb{Q}(100) = 242\\)</span>.</p>\n<p>The program below is sufficient for &#8220;practical&#8221; <span class=\"math\">\\(N\\)</span>, but we need to do better\nto count the number of ways to make change for <em>one trillion dollars</em>:\nOn my laptop, I can evaluate the result for one-hundred thousand dollars in\nabout <span class=\"math\">\\(20\\)</span> seconds.  The runtime of our program scales linearly with <span class=\"math\">\\(N\\)</span>\nthough, so it would take it about <span class=\"math\">\\(2 \\cdot 10^{7}\\)</span> seconds to get our target\nresult &#8212; too&nbsp;slow.</p>\n<div class=\"highlight\"><pre><span></span><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">ways_to_make_change</span><span class=\"p\">(</span><span class=\"n\">N</span><span class=\"p\">,</span> <span class=\"n\">denominations_list</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">25</span><span class=\"p\">]):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    This function calculates the number of ways to make change for N cents,</span>\n<span class=\"sd\">    using only the denominations included in the passed `denominations_list`.</span>\n\n<span class=\"sd\">    parameters</span>\n<span class=\"sd\">    ----------</span>\n<span class=\"sd\">    N: int</span>\n<span class=\"sd\">        The target number of cents we wish to make change for.</span>\n\n<span class=\"sd\">    denominations_list: list</span>\n<span class=\"sd\">        A list of denominations that we can use to make change.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"k\">for</span> <span class=\"n\">index</span><span class=\"p\">,</span> <span class=\"n\">denom</span> <span class=\"ow\">in</span> <span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"n\">denominations_list</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"n\">index</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n            <span class=\"n\">counts</span> <span class=\"o\">=</span> <span class=\"mi\">1</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"n\">N</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">%</span> <span class=\"n\">denom</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"n\">counts_lower_denoms</span> <span class=\"o\">=</span> <span class=\"n\">counts</span><span class=\"o\">.</span><span class=\"n\">copy</span><span class=\"p\">()</span>\n            <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"n\">denom</span><span class=\"p\">,</span> <span class=\"n\">N</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">):</span>\n                <span class=\"n\">counts</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">counts_lower_denoms</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">counts</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"n\">denom</span><span class=\"p\">]</span>\n    <span class=\"k\">return</span> <span class=\"n\">counts</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">ways_to_make_change</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">)[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">])</span>  \n\n<span class=\"c1\"># output: 242</span>\n</pre></div>\n\n\n<h5>Geometric interpretation, large <span class=\"math\">\\(N\\)</span> limiting&nbsp;form</h5>\n<p><img alt=\"![lattice]({static}/images/change_lattice.png)\" src=\"https://efavdb.com/images/change_lattice.png\"></p>\n<p>In this section, we briefly consider the geometry of our problem. The plot\nabove is a 3d visual of all the possible ways to make change for one dollar:\nEach point here has an <span class=\"math\">\\((x,y,z)\\)</span> position that encodes the number of nickels,\ndimes, and quarters, respectively, in a particular change solution.  To get the\nfull solution for a particular lattice point, we calculate the sum <span class=\"math\">\\(5 x + 10 y\n+ 25 z\\)</span> &#8212; subtracting this from <span class=\"math\">\\(N=100\\)</span> gives the number of pennies that must\nbe included in its solution.  In this way, we see that we get a valid solution\nat each non-negative lattice point whose coordinates give a sum that is not\nlarger than <span class=\"math\">\\(100\\)</span>.</p>\n<p>For general <span class=\"math\">\\(N\\)</span>, we&nbsp;have\n</p>\n<div class=\"math\">\\begin{eqnarray}\n\\mathbb{Q}(N) = \\text{# of lattice points: } 5 x + 10 y + 25 z \\leq N \n\\tag{4} \\label{4}\n\\end{eqnarray}</div>\n<p> \nwhere we are again counting all non-negative lattice points on a lattice spaced\nalong <span class=\"math\">\\(x\\)</span> with distance <span class=\"math\">\\(5\\)</span>,&nbsp;etc.</p>\n<p>We note that the inequality (\\ref{4}) defines a polytope, and that there is a\nbeautiful, pre-existing body of work &#8212; based on the use of generating\nfunctions &#8212; that allows one to count the number of lattice points within an\narbitrary polytope <span class=\"math\">\\([1]\\)</span>.  One can look up results from that line of work to\ndirectly answer the change counting problem we are considering here.  However,\nthe hybrid dynamic programming / analytic approach that we present below &#8212;\nbased on our recursion relations above &#8212; is more tailored to our problem and\nconsequently easier to&nbsp;derive.</p>\n<p>Before moving on, we point out that we can get a good approximation to the\nnumber of lattice points at large <span class=\"math\">\\(N\\)</span> by simply considering the volume of the\npolytope:   The idea is to make use of the fact that the lattice points are\nevenly spaced. To the find an approximation to the number that sit inside the\npolytope then, we simply need to divide the polytope&#8217;s volume (<span class=\"math\">\\(\\frac{1}{3!}\nN^3\\)</span>) by the volume of each lattice cell (<span class=\"math\">\\(5 \\cdot 10 \\cdot 25\\)</span>).  This gives&nbsp;[2],\n</p>\n<div class=\"math\">\\begin{eqnarray}\n\\mathbb{Q}(N) \\sim \\frac{1}{7500}N^3.\n\\tag{5} \\label{5}\n\\end{eqnarray}</div>\n<p>\nEq. (\\ref{5}) is the correct, leading behavior at large <span class=\"math\">\\(N\\)</span>.  However, it&#8217;s not\nexact because of &#8220;discreteness effects&#8221; that occur at the boundary of our\npolytope &#8212; these determine whether specific, individual lattice points lie\ninside the polytope or not.  These effects result in correction terms at\nquadratic and lower powers of <span class=\"math\">\\(N\\)</span>.  Our calculation below provides one method\nfor capturing the full set of&nbsp;terms.</p>\n<h5>Exact&nbsp;solution</h5>\n<p>To get the exact result for <span class=\"math\">\\(\\mathbb{Q}(N)\\)</span>, we will directly sum the\nrecursions relations (\\ref{q_iter})-(\\ref{n_iter}):  Recall from above, that we&nbsp;have\n</p>\n<div class=\"math\">\\begin{eqnarray}\n\\mathbb{P}(N) \\equiv 1 \\tag{6} \\label{6}\n\\end{eqnarray}</div>\n<p>\nfor any natural <span class=\"math\">\\(N\\)</span>.  Plugging this into (\\ref{n_iter}), we&nbsp;obtain\n</p>\n<div class=\"math\">\\begin{eqnarray} \\tag{7} \\label{7}\n\\mathbb{N}(N) =  \\lfloor \\frac{N}{5} \\rfloor + 1\n\\end{eqnarray}</div>\n<p>\nNotice that if we evaluate this at a series of points separated by <span class=\"math\">\\(\\Delta N =\n5\\)</span>, we get back  what looks like a simple linear function of <span class=\"math\">\\(N\\)</span> &#8212; it\nincreases by <span class=\"math\">\\(1\\)</span> with each increase of <span class=\"math\">\\(5\\)</span> in <span class=\"math\">\\(N\\)</span>.</p>\n<p>Now, if we plug our last line into (\\ref{d_iter}) we&nbsp;obtain\n</p>\n<div class=\"math\">\\begin{eqnarray} \\nonumber\n\\mathbb{D}(N) &amp;=&amp; \\left ( \\lfloor \\frac{N}{5} \\rfloor + 1  \\right) + \\left(\n\\lfloor \\frac{N  - 10 }{5} \\rfloor  + 1\\right) + \\ldots \\\\ &amp;=&amp; \\left ( \\lfloor\n\\frac{N}{5}\\rfloor  +  1 \\right) + \\left ( \\lfloor \\frac{N}{5}\\rfloor  -  1\n\\right)  + \\ldots \\tag{8} \\label{8}\n\\end{eqnarray}</div>\n<p>\nThis is an arithmetic sequence that depends on <span class=\"math\">\\(\\lfloor \\frac{N}{5} \\rfloor\\)</span>.\nSumming this series, we&nbsp;obtain\n</p>\n<div class=\"math\">\\begin{eqnarray}\n\\mathbb{D}(N) =\n\\begin{cases}\n\\frac{1}{4}  \\left (\\lfloor \\frac{N}{5} \\rfloor + 2 \\right)^2, &amp; \\text{$\\lfloor\n\\frac{N}{5} \\rfloor$ even} \\\\\n\\frac{1}{4} \\left (\\lfloor \\frac{N}{5}\\rfloor  + 1 \\right)\\left (\\lfloor\n\\frac{N}{5}\\rfloor  + 3 \\right ), &amp;  \\text{$\\lfloor \\frac{N}{5}\\rfloor$ odd}\n\\tag{9} \\label{9}\n\\end{cases}\n\\end{eqnarray}</div>\n<p>\nNotice that in this case, if we evaluate the function at a series of points\neach separated by <span class=\"math\">\\(10\\)</span>, the result will again look like a simple, smooth\nfunction &#8212; this time a quadratic function of <span class=\"math\">\\(N\\)</span>.  However, the particular\nform of the quadratic depends on whether <span class=\"math\">\\(\\lfloor \\frac{N}{5} \\rfloor\\)</span> is even\nor odd &#8212; that is, the function skips back and forth between two different&nbsp;quadratics.</p>\n<p>We are now at the point where we can solve for the full number of ways to make\nchange, <span class=\"math\">\\(\\mathbb{Q}(N)\\)</span>.  In principle, all we need to do is to plug\n(\\ref{9}) into (\\ref{q_iter}), and sum as above.  This is straightforward\nfor a particular <span class=\"math\">\\(N\\)</span>, but we&#8217;d like a general formula.  If we work out a few\nterms for any particular value of <span class=\"math\">\\(N\\)</span>, we see that we will get alternating\nterms:  perhaps starting with a term of the upper type from (\\ref{9}), followed\nby a term of the lower type, etc.  The sums of the upper form can be evaluated\nanalytically (e.g., by using the pyramid summation method), as can the sum of\nthe terms of the bottom form. For any starting point,  the result is a cubic in\n<span class=\"math\">\\(\\lfloor \\frac{N}{5} \\rfloor\\)</span>.  However, a small bit of work shows that the\nprecise cubic form that applies depends on the value of <span class=\"math\">\\(\\lfloor \\frac{N}{5}\n\\rfloor (\\text{mod } 10)\\)</span>, so we have ten separate cubics to solve&nbsp;for.</p>\n<p>Rather than laboriously evaluate the sums for each of the ten possible\nremainders of <span class=\"math\">\\(\\lfloor \\frac{N}{5} \\rfloor\\)</span> modulo <span class=\"math\">\\(10\\)</span>, we can simply carry\nout polynomial fits to data that we get from our python implementation of the\ndynamic programming approach.  For example, plugging the first four values of\n<span class=\"math\">\\(N\\)</span> that satisfy <span class=\"math\">\\(\\lfloor \\frac{N}{5} \\rfloor \\equiv 0 (\\text{mod } 10)\\)</span> into\nour program, we&nbsp;get\n</p>\n<div class=\"math\">\\begin{eqnarray} \\nonumber\n\\mathbb{Q}(1) &amp;=&amp; 1 \\\\ \\nonumber\n\\mathbb{Q}(50) &amp;=&amp; 49 \\\\ \\nonumber\n\\mathbb{Q}(100) &amp;=&amp; 242 \\\\\n\\mathbb{Q}(150) &amp;=&amp; 680\n\\tag{10} \\label{10}\n\\end{eqnarray}</div>\n<p>\nFitting a cubic to this data &#8212; which involves solving a system of linear\nequations for the unknown coefficients of the polynomial &#8212;&nbsp;gives\n</p>\n<div class=\"math\">\\begin{eqnarray}\n\\mathbb{Q}(N) = \\frac{\\lfloor \\frac{N}{5}\\rfloor ^3}{60}+\\frac{9 \\lfloor\n\\frac{N}{5}\\rfloor ^2}{40}+\\frac{53 \\lfloor \\frac{N}{5}\\rfloor }{60}+1\n\\tag{11} \\label{11}\n\\end{eqnarray}</div>\n<p>\nAgain, this holds when <span class=\"math\">\\(\\lfloor \\frac{N}{5}\\rfloor \\equiv 0 (\\text{mod } 10)\\)</span>.\nThis is the equation we used to get the result quoted for one trillion dollars\nat the top of our post.  Notice that the leading term here matches what&#8217;s\nrequired by our asymptotic result,&nbsp;(\\ref{5}).</p>\n<p>It turns out that when we plug in data for each of the other nine possible\nremainders, the cubic fits returned are all the same &#8212; except for their\nconstant terms.  Presumably, this is because the coefficients of positive\npowers of <span class=\"math\">\\(N\\)</span> each correspond to some asymptotic, geometric effects that must\nall agree when <span class=\"math\">\\(N\\)</span> is large &#8212; as we discussed above. At any rate, we have\ntabulated the constant terms that apply for each possible remainder below, and\nthis completes our&nbsp;solution.</p>\n<table>\n<thead>\n<tr>\n<th><span class=\"math\">\\(\\lfloor \\frac{N}{5} \\rfloor \\mod(10)\\)</span></th>\n<th>constant term in <span class=\"math\">\\(\\mathbb{Q}(N)\\)</span></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><span class=\"math\">\\(0\\)</span></td>\n<td><span class=\"math\">\\(1\\)</span></td>\n</tr>\n<tr>\n<td><span class=\"math\">\\(1\\)</span></td>\n<td><span class=\"math\">\\(\\frac{7}{8}\\)</span></td>\n</tr>\n<tr>\n<td><span class=\"math\">\\(2\\)</span></td>\n<td><span class=\"math\">\\(\\frac{6}{5}\\)</span></td>\n</tr>\n<tr>\n<td><span class=\"math\">\\(3\\)</span></td>\n<td><span class=\"math\">\\(\\frac{7}{8}\\)</span></td>\n</tr>\n<tr>\n<td><span class=\"math\">\\(4\\)</span></td>\n<td><span class=\"math\">\\(\\frac{4}{5}\\)</span></td>\n</tr>\n<tr>\n<td><span class=\"math\">\\(5\\)</span></td>\n<td><span class=\"math\">\\(\\frac{7}{8}\\)</span></td>\n</tr>\n<tr>\n<td><span class=\"math\">\\(6\\)</span></td>\n<td><span class=\"math\">\\(1\\)</span></td>\n</tr>\n<tr>\n<td><span class=\"math\">\\(7\\)</span></td>\n<td><span class=\"math\">\\(\\frac{43}{40}\\)</span></td>\n</tr>\n<tr>\n<td><span class=\"math\">\\(8\\)</span></td>\n<td><span class=\"math\">\\(1\\)</span></td>\n</tr>\n<tr>\n<td><span class=\"math\">\\(9\\)</span></td>\n<td><span class=\"math\">\\(\\frac{27}{40}\\)</span></td>\n</tr>\n</tbody>\n</table>\n<h4>Acknowledgements</h4>\n<p>This work in this post was done in collaboration with my father, Steven&nbsp;Landy.</p>\n<h4>References</h4>\n<p>[1] Beck, Matthias, and Sinai Robins. Computing the continuous discretely. Vol.\n61. Berlin: Springer Science+ Business Media, <span class=\"caps\">LLC</span>,&nbsp;2007.</p>\n<p>[2] One way to derive this volume result is to integrate the recursion\nrelations (1)-(3), ignoring discreteness effects &#8212; i.e., integrate assuming\nthat each of the variables <span class=\"math\">\\(\\mathbb{P}(N), \\mathbb{N}(N), \\mathbb{D}(N)\\)</span>, and\n<span class=\"math\">\\(\\mathbb{Q}(N)\\)</span> are smooth functions of <span class=\"math\">\\(N\\)</span>.  This will hold in the large <span class=\"math\">\\(N\\)</span>\nlimit to leading order, so will give us the leading order&nbsp;result.</p>\n<script type=\"text/javascript\">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {\n    var align = \"center\",\n        indent = \"0em\",\n        linebreak = \"false\";\n\n    if (false) {\n        align = (screen.width < 768) ? \"left\" : align;\n        indent = (screen.width < 768) ? \"0em\" : indent;\n        linebreak = (screen.width < 768) ? 'true' : linebreak;\n    }\n\n    var mathjaxscript = document.createElement('script');\n    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';\n    mathjaxscript.type = 'text/javascript';\n    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';\n\n    var configscript = document.createElement('script');\n    configscript.type = 'text/x-mathjax-config';\n    configscript[(window.opera ? \"innerHTML\" : \"text\")] =\n        \"MathJax.Hub.Config({\" +\n        \"    config: ['MMLorHTML.js'],\" +\n        \"    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } },\" +\n        \"    jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" +\n        \"    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" +\n        \"    displayAlign: '\"+ align +\"',\" +\n        \"    displayIndent: '\"+ indent +\"',\" +\n        \"    showMathMenu: true,\" +\n        \"    messageStyle: 'normal',\" +\n        \"    tex2jax: { \" +\n        \"        inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" +\n        \"        displayMath: [ ['$$','$$'] ],\" +\n        \"        processEscapes: true,\" +\n        \"        preview: 'TeX',\" +\n        \"    }, \" +\n        \"    'HTML-CSS': { \" +\n        \"        availableFonts: ['STIX', 'TeX'],\" +\n        \"        preferredFont: 'STIX',\" +\n        \"        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" +\n        \"        linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" +\n        \"    }, \" +\n        \"}); \" +\n        \"if ('default' !== 'default') {\" +\n            \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" +\n                \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" +\n                \"VARIANT['normal'].fonts.unshift('MathJax_default');\" +\n                \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" +\n                \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" +\n                \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" +\n            \"});\" +\n            \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" +\n                \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" +\n                \"VARIANT['normal'].fonts.unshift('MathJax_default');\" +\n                \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" +\n                \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" +\n                \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" +\n            \"});\" +\n        \"}\";\n\n    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);\n    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);\n}\n</script>",
  "category": ""
}