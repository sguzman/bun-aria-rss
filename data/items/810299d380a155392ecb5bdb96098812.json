{
  "title": "A toy remote login server",
  "link": "",
  "updated": "2022-07-28T08:00:28+00:00",
  "id": "https://jvns.ca/blog/2022/07/28/toy-remote-login-server/",
  "content": "\n\n<p>Hello! The other day we talked about <a href=\"https://jvns.ca/blog/2022/07/20/pseudoterminals/\">what happened when you press a key in your terminal</a>.</p>\n\n<p>As a followup, I thought it might be fun to implement a program that&rsquo;s like a\ntiny ssh server, but without the security. You can find it <a href=\"https://github.com/jvns/tiny-remote-login/blob/main/server.go\">on github here</a>, and I&rsquo;ll explain how it works in this blog post.</p>\n\n<h3 id=\"the-goal-ssh-to-a-remote-computer\">the goal: &ldquo;ssh&rdquo; to a remote computer</h3>\n\n<p>Our goal is to be able to login to a remote computer and run commands, like you\ndo with SSH or telnet.</p>\n\n<p>The biggest difference between this program and SSH is that there&rsquo;s literally\nno security (not even a password) &ndash; anyone who can make a TCP connection to\nthe server can get a shell and run commands.</p>\n\n<p>Obviously this is not a useful program in real life, but our goal is to learn a\nlittle more about how terminals works, not to write a useful program.</p>\n\n<p>(I will run a version of it on the public internet for the next week though,\nyou can see how to connect to it at the end of this blog post)</p>\n\n<h3 id=\"let-s-start-with-the-server\">let&rsquo;s start with the server!</h3>\n\n<p>We&rsquo;re also going to write a client, but the server is the interesting part, so\nlet&rsquo;s start there. We&rsquo;re going to write a server that listens on a TCP port (I\npicked 7777) and creates remote terminals for any client that connects to it to\nuse.</p>\n\n<p>When the server receives a new connection it needs to:</p>\n\n<ol>\n<li>create a pseudoterminal for the client to use</li>\n<li>start a <code>bash</code> shell process for the client to use</li>\n<li>connect <code>bash</code> to the pseudoterminal</li>\n<li>continuously copy information back and forth between the TCP connection and\nthe pseudoterminal</li>\n</ol>\n\n<p>I just said the word &ldquo;pseudoterminal&rdquo; a lot, so let&rsquo;s talk about what that\nmeans.</p>\n\n<h3 id=\"what-s-a-pseudoterminal\">what&rsquo;s a pseudoterminal?</h3>\n\n<p>Okay, what the heck is a pseudoterminal?</p>\n\n<p>A pseudoterminal is a lot like a bidirectional pipe or a socket &ndash; you have two\nends, and they can both send and receive information. You can read more about\nthe information being sent and received in <a href=\"https://jvns.ca/blog/2022/07/20/pseudoterminals/\">what happens if you press a key in your terminal</a></p>\n\n<p>Basically the idea is that on one end, we have a TCP connection, and on the\nother end, we have a <code>bash</code> shell. So we need to hook one part of the\npseudoterminal up to the TCP connection and the other end to bash.</p>\n\n<p>The two parts of the pseudoterminal are called:</p>\n\n<ul>\n<li>the &ldquo;pseudoterminal master&rdquo;. This is the end we&rsquo;re going to hook up to the TCP connection.</li>\n<li>the &ldquo;slave pseudoterminal device&rdquo;. We&rsquo;re going to set our bash shell&rsquo;s <code>stdout</code>, <code>stderr</code>, and <code>stdin</code> to this.</li>\n</ul>\n\n<p>Once they&rsquo;re conected, we can communicate with <code>bash</code> over our TCP connection\nand we&rsquo;ll have a remote shell!</p>\n\n<h3 id=\"why-do-we-need-this-pseudoterminal-thing-anyway\">why do we need this &ldquo;pseudoterminal&rdquo; thing anyway?</h3>\n\n<p>You might be wondering &ndash; Julia, if a pseudoterminal is kind of like a socket,\nwhy can&rsquo;t we just set our bash shell&rsquo;s <code>stdout</code> / <code>stderr</code> / <code>stdin</code> to the TCP\nsocket?</p>\n\n<p>And you can! We could write a TCP connection handler like this that does exactly that, it&rsquo;s not a lot of code (<a href=\"https://github.com/jvns/tiny-remote-login/blob/main/server-notty.go\">server-notty.go</a>).</p>\n\n<pre><code>\nfunc handle(conn net.Conn) {\n\ttty, _ := conn.(*net.TCPConn).File()\n\t// start bash with tcp connection as stdin/stdout/stderr\n\tcmd := exec.Command(\"bash\")\n\tcmd.Stdin = tty\n\tcmd.Stdout = tty\n\tcmd.Stderr = tty\n\tcmd.Start()\n}\n\n</code></pre>\n\n<p>It even kind of works &ndash; if we connect to it with <code>nc localhost 7778</code>, we can\nrun commands and look at their output.</p>\n\n<p>But there are a few problems. I&rsquo;m not going to list all of them, just two.</p>\n\n<p><strong>problem 1: Ctrl + C doesn&rsquo;t work</strong></p>\n\n<p>The way Ctrl + C works in a remote login session is</p>\n\n<ul>\n<li>you press ctrl + c</li>\n<li>That gets translated to <code>0x03</code> and sent through the TCP connection</li>\n<li>The terminal receives it</li>\n<li>the Linux kernel on the other end notes &ldquo;hey, that was a Ctrl + C!&rdquo;</li>\n<li>Linux sends a <code>SIGINT</code> to the appropriate process (more on what the &ldquo;appropriate process&rdquo; is exactly later)</li>\n</ul>\n\n<p>If the &ldquo;terminal&rdquo; is just a TCP connection, this doesn&rsquo;t work, because when you\nsend <code>0x04</code> to a TCP connection, Linux won&rsquo;t magically send <code>SIGINT</code> to any\nprocess.</p>\n\n<p><strong>problem 2: <code>top</code> doesn&rsquo;t work</strong></p>\n\n<p>When I try to run <code>top</code> in this shell, I get the error message <code>top: failed tty get</code>. If we strace it, we see this system call:</p>\n\n<pre><code>ioctl(2, TCGETS, 0x7ffec4e68d60)        = -1 ENOTTY (Inappropriate ioctl for device)\n</code></pre>\n\n<p>So <code>top</code> is running an <code>ioctl</code> on its output file descriptor (2) to get some\ninformation about the terminal. But Linux is like &ldquo;hey, this isn&rsquo;t a terminal!&rdquo;\nand returns an error.</p>\n\n<p>There are a bunch of other things that go wrong, but hopefully at this point\nyou&rsquo;re convinced that we actually need to set bash&rsquo;s stdout/stderr to be a\nterminal, not some other thing like a socket.</p>\n\n<p>So let&rsquo;s start looking at the server code and see what creating a\npseudoterminal actually looks like.</p>\n\n<h3 id=\"step-1-create-a-pseudoterminal\">step 1: create a pseudoterminal</h3>\n\n<p>Here&rsquo;s some Go code to create a pseudoterminal on Linux. This is copied from <a href=\"https://github.com/creack/pty/blob/7de28cee0d53510e719c1aeb1850af0fa647c343/pty_linux.go\">github.com/creack/pty</a>,\nbut I removed some of the error handling to make the logic a bit easier to follow:</p>\n\n<pre><code>pty, _ := os.OpenFile(\"/dev/ptmx\", os.O_RDWR, 0)\nsname := ptsname(p)\nunlockpt(p)\ntty, _ := os.OpenFile(sname, os.O_RDWR|syscall.O_NOCTTY, 0)\n</code></pre>\n\n<p>In English, what we&rsquo;re doing is:</p>\n\n<ul>\n<li>open <code>/dev/ptmx</code> to get the &ldquo;pseudoterminal master&rdquo; Again, that&rsquo;s the part we&rsquo;re going to hook up to the TCP connection</li>\n<li>get the filename of the &ldquo;slave pseudoterminal device&rdquo;, which is going to be <code>/dev/pts/13</code> or something.</li>\n<li>&ldquo;unlock&rdquo; the pseudoterminal so that we can use it. I have no idea what the point of this is (why is it locked to begin with?) but you have to do it for some reason</li>\n<li>open <code>/dev/pts/13</code> (or whatever number we got from <code>ptsname</code>) to get the &ldquo;slave pseudoterminal device&rdquo;</li>\n</ul>\n\n<p>What do those <code>ptsname</code> and <code>unlockpt</code> functions do? They just make some\n<code>ioctl</code> system calls to the Linux kernel. All of the communication with the\nLinux kernel about terminals seems to be through various <code>ioctl</code> system calls.</p>\n\n<p>Here&rsquo;s the code, it&rsquo;s pretty short: (again, I just copied it from <a href=\"https://github.com/creack/pty/blob/7de28cee0d53510e719c1aeb1850af0fa647c343/pty_linux.go#L41-L54\">creack/pty</a>)</p>\n\n<pre><code>func ptsname(f *os.File) string {\n\tvar n uint32\n\tioctl(f.Fd(), syscall.TIOCGPTN, uintptr(unsafe.Pointer(&n)))\n\treturn \"/dev/pts/\" + strconv.Itoa(int(n))\n}\n\nfunc unlockpt(f *os.File) {\n\tvar u int32\n\t// use TIOCSPTLCK with a pointer to zero to clear the lock\n\tioctl(f.Fd(), syscall.TIOCSPTLCK, uintptr(unsafe.Pointer(&u)))\n}\n</code></pre>\n\n<h3 id=\"step-2-hook-the-pseudoterminal-up-to-bash\">step 2: hook the pseudoterminal up to <code>bash</code></h3>\n\n<p>The next thing we have to do is connect the pseudoterminal to <code>bash</code>. Luckily,\nthat&rsquo;s really easy &ndash; here&rsquo;s the Go code for it! We just need to start a new\nprocess and set the stdin, stdout, and stderr to <code>tty</code>.</p>\n\n<pre><code>cmd := exec.Command(\"bash\")\ncmd.Stdin = tty\ncmd.Stdout = tty\ncmd.Stderr = tty\ncmd.SysProcAttr = &syscall.SysProcAttr{\n  Setsid: true,\n}\ncmd.Start()\n</code></pre>\n\n<p>Easy! Though &ndash; why do we need this <code>Setsid: true</code> thing, you might ask? Well,\nI tried commenting out that code to see what went wrong. It turns out that what\ngoes wrong is &ndash; Ctrl + C doesn&rsquo;t work anymore!</p>\n\n<p><code>Setsid: true</code> creates a new <strong>session</strong> for the new bash process. But why does\nthat make <code>Ctrl + C</code> work? How does Linux know which process to send <code>SIGINT</code>\nto when you press <code>Ctrl + C</code>, and what does that have to do with sessions?</p>\n\n<h3 id=\"how-does-linux-know-which-process-to-send-ctrl-c-to\">how does Linux know which process to send Ctrl + C to?</h3>\n\n<p>I found this pretty confusing, so I reached for my favourite book for learning\nabout this kind of thing: <a href=\"https://man7.org/tlpi/\">the linux programming interface</a>, specifically chapter 34 on process groups\nand sessions.</p>\n\n<p>That chapter contains a few key facts: (#3, #4, and #5 are direct quotes from the book)</p>\n\n<ol>\n<li>Every process has a <strong>session id</strong> and a <strong>process group id</strong> (which may or may not be the same as its PID)</li>\n<li>A session is made up of multiple process groups</li>\n<li>All of the processes in a session share a single controlling terminal.</li>\n<li>A terminal may be the controlling terminal of at most one session.</li>\n<li>At any point in time, one of the process groups in a session is the\n<strong>foreground process group</strong> for the terminal, and the others are background\nprocess groups.</li>\n<li>When you press <code>Ctrl+C</code> in a terminal, SIGINT gets sent to all the processes in the foreground process group</li>\n</ol>\n\n<p>What&rsquo;s a process group? Well, my understanding is that:</p>\n\n<ul>\n<li>processes in the same pipe <code>x | y | z</code> are in the same process group</li>\n<li>processes you start on the same shell line (<code>x && y && z</code>) are in the same process group</li>\n<li>child processes are by default in the same process group, unless you explicitly decide otherwise</li>\n</ul>\n\n<p>I didn&rsquo;t know most of this (I had no idea processes had a session ID!) so this\nwas kind of a lot to absorb. I tried to draw a sketchy ASCII art diagram of the\nsituation</p>\n\n<pre><code>(maybe)  terminal --- session --- process group --- process\n                               |                 |- process\n                               |                 |- process\n                               |- process group \n                               |\n                               |- process group \n</code></pre>\n\n<p>So when we press Ctrl+C in a terminal, here&rsquo;s what I think happens:</p>\n\n<ul>\n<li><code>\\x04</code> gets written to the &ldquo;pseudotermimal master&rdquo; of a terminal</li>\n<li>Linux finds the <strong>session</strong> for that terminal (if it exists)</li>\n<li>Linux find the <strong>foreground process group</strong> for that session</li>\n<li>Linux sends <code>SIGINT</code></li>\n</ul>\n\n<p>If we don&rsquo;t create a new session for our new bash process, our new pseudoterminal\nactually won&rsquo;t have <strong>any</strong> session associated with it, so nothing happens when\nwe press <code>Ctrl+C</code>. But if we do create a new session, then the new\npseudoterminal will have the new session associated with it.</p>\n\n<h3 id=\"how-to-get-a-list-of-all-your-sessions\">how to get a list of all your sessions</h3>\n\n<p>As a quick aside, if you want to get a list of all the sessions on your Linux\nmachine, grouped by session, you can run:</p>\n\n<pre><code>$ ps -eo user,pid,pgid,sess,cmd | sort -k3\n</code></pre>\n\n<p>This includes the PID, process group ID, and session ID. As an example of the output, here are the two processes in the pipeline:</p>\n\n<pre><code>bork       58080   58080   57922 ps -eo user,pid,pgid,sess,cmd\nbork       58081   58080   57922 sort -k3\n</code></pre>\n\n<p>You can see that they share the same process group ID and session ID, but of\ncourse they have different PIDs.</p>\n\n<p>That was kind of a lot but that&rsquo;s all we&rsquo;re going to say about sessions and\nprocess groups in this post. Let&rsquo;s keep going!</p>\n\n<h3 id=\"step-3-set-the-window-size\">step 3: set the window size</h3>\n\n<p>We need to tell the terminal how big to be!</p>\n\n<p>Again, I just copied this from <code>creack/pty</code>. I decided to hardcode the size to 80x24.</p>\n\n<pre><code>Setsize(tty, &Winsize{\n\t\tCols: 80,\n\t\tRows: 24,\n\t})\n</code></pre>\n\n<p>Like with getting the terminal&rsquo;s pts filename and unlocking it, setting the\nsize is just one <code>ioctl</code> system call:</p>\n\n<pre><code>func Setsize(t *os.File, ws *Winsize) {\n\tioctl(t.Fd(), syscall.TIOCSWINSZ, uintptr(unsafe.Pointer(ws)))\n}\n</code></pre>\n\n<p>Pretty simple! We could do something smarter and get the real window size, but\nI&rsquo;m too lazy.</p>\n\n<h3 id=\"step-4-copy-information-between-the-tcp-connection-and-the-pseudoterminal\">step 4: copy information between the TCP connection and the pseudoterminal</h3>\n\n<p>As a reminder, our rough steps to set up this remote login server were:</p>\n\n<ol>\n<li>create a pseudoterminal for the client to use</li>\n<li>start a <code>bash</code> shell process</li>\n<li>connect <code>bash</code> to the pseudoterminal</li>\n<li>continuously copy information back and forth between the TCP connection and\nthe pseudoterminal</li>\n</ol>\n\n<p>We&rsquo;ve done 1, 2, and 3, now we just need to ferry information between the TCP\nconnection and the pseudoterminal.</p>\n\n<p>There are two <code>io.Copy</code> calls, one to copy the input <em>from</em> the tcp connection, and one to copy the output <em>to</em> the TCP connection. Here&rsquo;s what the code looks like:</p>\n\n<pre><code>\tgo func() {\n\t\t\tio.Copy(pty, conn)\n\t}()\n  io.Copy(conn, pty)\n</code></pre>\n\n<p>The first one is in a goroutine just so they can both run in parallel.</p>\n\n<p>Pretty simple!</p>\n\n<h3 id=\"step-5-exit-when-we-re-done\">step 5: exit when we&rsquo;re done</h3>\n\n<p>I also added a little bit of code to close the TCP connection when the command exits</p>\n\n<pre><code>go func() {\n  cmd.Wait()\n  conn.Close()\n}()\n\n</code></pre>\n\n<p>And that&rsquo;s it for the server!  You can see all of the Go code here: <a href=\"https://github.com/jvns/tiny-remote-login/blob/main/server.go\">server.go</a>.</p>\n\n<h3 id=\"next-write-a-client\">next: write a client</h3>\n\n<p>Next, we have to write a client. This is a lot easier than the server because we don&rsquo;t need to do quite as much terminal setup. There are just 3 steps:</p>\n\n<ol>\n<li>Put the terminal into raw mode</li>\n<li>copy stdin/stdout to the TCP connection</li>\n<li>reset the terminal</li>\n</ol>\n\n<h3 id=\"client-step-1-put-the-terminal-into-raw-mode\">client step 1: put the terminal into &ldquo;raw&rdquo; mode</h3>\n\n<p>We need to put the client terminal into &ldquo;raw&rdquo; mode so that every time you press\na key, it gets sent to the TCP connection immediately. If we don&rsquo;t do this,\neverything will only get sent when you press enter.</p>\n\n<p>&ldquo;Raw mode&rdquo; isn&rsquo;t actually a single thing, it&rsquo;s a bunch of flags that you want\nto turn off. There&rsquo;s a good tutorial explaining all the flags we have to turn\noff called <a href=\"https://viewsourcecode.org/snaptoken/kilo/02.enteringRawMode.html\">Entering raw mode</a>.</p>\n\n<p>Like everything else with terminals, this requires <code>ioctl</code> system calls. In\nthis case we get the terminal&rsquo;s current settings, modify them, and save the old\nsettings so that we can restore them later.</p>\n\n<p>I figured out how to do this in Go by going to <a href=\"https://grep.app\">https://grep.app</a> and typing in\n<code>syscall.TCSETS</code> to find some other Go code that was doing the same thing.</p>\n\n<pre><code>func MakeRaw(fd uintptr) syscall.Termios {\n\t// from https://github.com/getlantern/lantern/blob/devel/archive/src/golang.org/x/crypto/ssh/terminal/util.go\n\tvar oldState syscall.Termios\n\tioctl(fd, syscall.TCGETS, uintptr(unsafe.Pointer(&oldState)))\n\n\tnewState := oldState\n\tnewState.Iflag &^= syscall.ISTRIP | syscall.INLCR | syscall.ICRNL | syscall.IGNCR | syscall.IXON | syscall.IXOFF\n\tnewState.Lflag &^= syscall.ECHO | syscall.ICANON | syscall.ISIG\n\tioctl(fd, syscall.TCSETS, uintptr(unsafe.Pointer(&newState)))\n\treturn oldState\n}\n</code></pre>\n\n<h3 id=\"client-step-2-copy-stdin-stdout-to-the-tcp-connection\">client step 2: copy stdin/stdout to the TCP connection</h3>\n\n<p>This is exactly like what we did with the server. It&rsquo;s very little code:</p>\n\n<pre><code>go func() {\n\t\tio.Copy(conn, os.Stdin)\n\t}()\n\tio.Copy(os.Stdout, conn)\n</code></pre>\n\n<h3 id=\"client-step-3-restore-the-terminal-s-state\">client step 3: restore the terminal&rsquo;s state</h3>\n\n<p>We can put the terminal back into the mode it started in like this (another <code>ioctl</code>!):</p>\n\n<pre><code>func Restore(fd uintptr, oldState syscall.Termios) {\n\tioctl(fd, syscall.TCSETS, uintptr(unsafe.Pointer(&oldState)))\n}\n</code></pre>\n\n<h3 id=\"we-did-it\">we did it!</h3>\n\n<p>We have written a tiny remote login server that lets anyone log in! Hooray!</p>\n\n<p>Obviously this has zero security so I&rsquo;m not going to talk about that aspect.</p>\n\n<h3 id=\"it-s-running-on-the-public-internet-you-can-try-it-out\">it&rsquo;s running on the public internet! you can try it out!</h3>\n\n<p>For the next week or so I&rsquo;m going to run a demo of this on the internet at\n<code>tetris.jvns.ca</code>. It runs tetris instead of a shell because I wanted to avoid\nabuse, but if you want to try it with a shell you can run it on your own\ncomputer :).</p>\n\n<p>If you want to try it out, you can use <code>netcat</code> as a client instead of the\ncustom Go client program we wrote, because copying information to/from a TCP\nconnection is what netcat does. Here&rsquo;s how:</p>\n\n<pre><code>stty raw -echo && nc tetris.jvns.ca 7777 && stty sane\n</code></pre>\n\n<p>This will let you play a terminal tetris game called <code>tint</code>.</p>\n\n<p>You can also use the <a href=\"https://github.com/jvns/tiny-remote-login/blob/main/client.go\">client.go program</a> and run <code>go run client.go tetris.jvns.ca 7777</code>.</p>\n\n<h3 id=\"this-is-not-a-good-protocol\">this is not a good protocol</h3>\n\n<p>This protocol where we just copy bytes from the TCP connection to the terminal\nand nothing else is not good because it doesn&rsquo;t allow us to send over\ninformation information like the terminal or the actual window size of the\nterminal.</p>\n\n<p>I thought about implementing telnet&rsquo;s protocol so that we could use telnet as a\nclient, but I didn&rsquo;t feel like figuring out how telnet works so I didn&rsquo;t. (the\nserver 30% works with telnet as is, but a lot of things are broken, I don&rsquo;t\nquite know why, and I didn&rsquo;t feel like figuring it out)</p>\n\n<h3 id=\"it-ll-mess-up-your-terminal-a-bit\">it&rsquo;ll mess up your terminal a bit</h3>\n\n<p>As a warning: using this server to play tetris will probably mess up your\nterminal a bit because it sets the window size to 80x24. To fix that I just\nclosed the terminal tab after running that command.</p>\n\n<p>If we wanted to fix this for real, we&rsquo;d need to restore the window size after\nwe&rsquo;re done, but then we&rsquo;d need a slightly more real protocol  than &ldquo;just\nblindly copy bytes back and forth with TCP&rdquo; and I didn&rsquo;t feel like doing that.</p>\n\n<p>Also it sometimes takes a second to disconnect after the program exits for some\nreason, I&rsquo;m not sure why that is.</p>\n\n<h3 id=\"other-tiny-projects\">other tiny projects</h3>\n\n<p>That&rsquo;s all! There are a couple of other similar toy implementations of programs\nI&rsquo;ve written here:</p>\n\n<ul>\n<li><a href=\"https://jvns.ca/blog/2022/03/23/a-toy-version-of-tls/\">toy tls 1.3 implementation</a></li>\n<li><a href=\"https://jvns.ca/blog/2022/02/01/a-dns-resolver-in-80-lines-of-go/\">toy dns resolver</a></li>\n</ul>\n"
}