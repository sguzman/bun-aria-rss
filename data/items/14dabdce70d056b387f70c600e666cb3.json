{
  "title": "Recurrent Neural Networks",
  "link": "https://shapeofdata.wordpress.com/2015/10/20/recurrent-neural-networks/",
  "comments": "https://shapeofdata.wordpress.com/2015/10/20/recurrent-neural-networks/#comments",
  "dc:creator": "Jesse Johnson",
  "pubDate": "Tue, 20 Oct 2015 13:26:05 +0000",
  "category": "Neural Networks",
  "guid": "http://shapeofdata.wordpress.com/?p=1205",
  "description": "So far on this blog, we&#8217;ve mostly looked at data in two forms &#8211; vectors in which each data point is defined by a fixed set of features, and graphs in which each data point is defined by its connections &#8230; <a href=\"https://shapeofdata.wordpress.com/2015/10/20/recurrent-neural-networks/\">Continue reading <span class=\"meta-nav\">&#8594;</span></a>",
  "content:encoded": "<p>So far on this blog, we&#8217;ve mostly looked at data in two forms &#8211; vectors in which each data point is defined by a fixed set of features, and graphs in which each data point is defined by its connections to other data points. For other forms of data, notably sequences such as text and sound, I described a few ways of transforming these into vectors, such as <a href=\"https://shapeofdata.wordpress.com/2013/10/23/case-study-3-free-form-text/\">bag-of-words</a> and n-grams. However, it turns out there are also ways to build machine learning models that use sequential data directly. In this post, I want to describe one such approach, called a <em>recurrent neural network</em>.</p>\n<p><span id=\"more-1205\"></span><br />\n<a href=\"https://shapeofdata.files.wordpress.com/2015/10/ann4.png\"><img data-attachment-id=\"1216\" data-permalink=\"https://shapeofdata.wordpress.com/2015/10/20/recurrent-neural-networks/ann4/\" data-orig-file=\"https://shapeofdata.files.wordpress.com/2015/10/ann4.png\" data-orig-size=\"401,276\" data-comments-opened=\"1\" data-image-meta=\"{\"aperture\":\"0\",\"credit\":\"\",\"camera\":\"\",\"caption\":\"\",\"created_timestamp\":\"0\",\"copyright\":\"\",\"focal_length\":\"0\",\"iso\":\"0\",\"shutter_speed\":\"0\",\"title\":\"\",\"orientation\":\"0\"}\" data-image-title=\"ANN4\" data-image-description=\"\" data-image-caption=\"\" data-medium-file=\"https://shapeofdata.files.wordpress.com/2015/10/ann4.png?w=300\" data-large-file=\"https://shapeofdata.files.wordpress.com/2015/10/ann4.png?w=401\" class=\"size-full wp-image-1216 alignright\" src=\"https://shapeofdata.files.wordpress.com/2015/10/ann4.png?w=640\" alt=\"ANN4\" srcset=\"https://shapeofdata.files.wordpress.com/2015/10/ann4.png 401w, https://shapeofdata.files.wordpress.com/2015/10/ann4.png?w=150 150w, https://shapeofdata.files.wordpress.com/2015/10/ann4.png?w=300 300w\" sizes=\"(max-width: 401px) 100vw, 401px\"   /></a>Recall that a standard (artificial) <a href=\"https://shapeofdata.wordpress.com/2013/06/11/neural-networks-1-the-neuron/\">neural network</a>, is defined by a graph of neurons (the big circles on the right), each of which takes either the features of a given data point (the small circles), or the outputs from other neurons, and <a href=\"https://shapeofdata.wordpress.com/2013/06/18/neural-networks-2-evaluation/\">calculates its own output</a> from these values. In this way, each neuron defines a probability distribution on the space of possible input vectors. The density function of the distribution (shown inside each circle) is defined by the value that the neuron would output for any given input vector.</p>\n<p>We can think of each probability distribution, and thus each neuron, as defining a &#8220;concept&#8221; such that its output for a given input vector defines the probability that the input vector represents the concept. In the figure, the high-probability regions are shown in white. The neurons that are connected directly to the input data define relatively simple concepts/probability distributions, while later neurons combine these simple concepts/distributions into more complex ones. In the figure, the far-right neuron&#8217;s concept is the union of the other two &#8211; it is represented by any vector that represents one or the other.</p>\n<p>Implicit in this definition is the idea of a Directed Acyclic Graph, or DAG: Directed means that each edge in the network/graph has an arrow on it, pointing from a neuron whose output is used to the neuron that uses it. Acyclic means that if you follow these arrows, you can never go in a loop &#8211; all paths must move away from the input features and eventually make it to the output of the entire network, as with the top graph in the figure below.</p>\n<p><a href=\"https://shapeofdata.files.wordpress.com/2015/10/dag.png\"><img data-attachment-id=\"1213\" data-permalink=\"https://shapeofdata.wordpress.com/2015/10/20/recurrent-neural-networks/dag/\" data-orig-file=\"https://shapeofdata.files.wordpress.com/2015/10/dag.png\" data-orig-size=\"454,136\" data-comments-opened=\"1\" data-image-meta=\"{\"aperture\":\"0\",\"credit\":\"\",\"camera\":\"\",\"caption\":\"\",\"created_timestamp\":\"0\",\"copyright\":\"\",\"focal_length\":\"0\",\"iso\":\"0\",\"shutter_speed\":\"0\",\"title\":\"\",\"orientation\":\"0\"}\" data-image-title=\"dag\" data-image-description=\"\" data-image-caption=\"\" data-medium-file=\"https://shapeofdata.files.wordpress.com/2015/10/dag.png?w=300\" data-large-file=\"https://shapeofdata.files.wordpress.com/2015/10/dag.png?w=454\" class=\"alignleft size-full wp-image-1213\" src=\"https://shapeofdata.files.wordpress.com/2015/10/dag.png?w=640\" alt=\"dag\" srcset=\"https://shapeofdata.files.wordpress.com/2015/10/dag.png 454w, https://shapeofdata.files.wordpress.com/2015/10/dag.png?w=150 150w, https://shapeofdata.files.wordpress.com/2015/10/dag.png?w=300 300w\" sizes=\"(max-width: 454px) 100vw, 454px\"   /></a></p>\n<p>If you can follow the edges of a directed graph and get back to a vertex that you already visited, this is called a <em>cycle</em>. Notice how the two blue edges in the bottom graph create cycles. These are problematic for neural networks because when you calculate the output of a neuron, you need to know the outputs of all the neurons that point into it. If there&#8217;s a cycle, there&#8217;s no neuron that you can calculate first, before all the other neurons. In the graph above, you could reorder the vertices so that the blue edges point to the right, but then some of the other edges would have to point left.</p>\n<p>Whenever you do have a DAG, you can order the vertices (neurons) so that all the edges pointing into each vertex come from earlier vertices, i.e. all the edge point to the right. If you order the neurons in a standard neural network like this, you can calculate the outputs of the neurons in this order and know all the values needed to calculate each neuron&#8217;s output by the time you get to it.</p>\n<p>A recurrent neural network is a neural network that is not a DAG. So as noted above, there&#8217;s no natural order on the neurons in which all the arrows point forward. But, then, how do we calculate the output values of the neurons?</p>\n<p>It turns out the best thing to do is to carry on, pretending that there&#8217;s nothing wrong. In particular, we start by picking an ordering for the vertices, dropping the condition that the arrows defined by the edges have to point towards later vertices. This ordering will allow us to calculate the output values of all the neurons for a given input vector &#8211; for each neuron in the sequence, we use the output values from the earlier neurons that have already been calculated, and treat the outputs from the later neurons as if they were set to zero or some other default value.</p>\n<p>But then what&#8217;s the point of the arrows that point backwards? Well, remember that the goal of recurrent neural networks is to deal with sequential data, in which we get one vector after another. For example, if we&#8217;re analyzing text, we might use bag-of-words with a moving window &#8211; use the first five words for the first vector, the second through the sixth word for the next vector, then the third through seventh and so on.</p>\n<p><a href=\"https://shapeofdata.files.wordpress.com/2015/10/rnn-inputs.png\"><img data-attachment-id=\"1215\" data-permalink=\"https://shapeofdata.wordpress.com/2015/10/20/recurrent-neural-networks/rnn-inputs/\" data-orig-file=\"https://shapeofdata.files.wordpress.com/2015/10/rnn-inputs.png\" data-orig-size=\"301,169\" data-comments-opened=\"1\" data-image-meta=\"{\"aperture\":\"0\",\"credit\":\"\",\"camera\":\"\",\"caption\":\"\",\"created_timestamp\":\"0\",\"copyright\":\"\",\"focal_length\":\"0\",\"iso\":\"0\",\"shutter_speed\":\"0\",\"title\":\"\",\"orientation\":\"0\"}\" data-image-title=\"rnn-inputs\" data-image-description=\"\" data-image-caption=\"\" data-medium-file=\"https://shapeofdata.files.wordpress.com/2015/10/rnn-inputs.png?w=300\" data-large-file=\"https://shapeofdata.files.wordpress.com/2015/10/rnn-inputs.png?w=301\" class=\"size-full wp-image-1215 alignright\" src=\"https://shapeofdata.files.wordpress.com/2015/10/rnn-inputs.png?w=640\" alt=\"rnn-inputs\" srcset=\"https://shapeofdata.files.wordpress.com/2015/10/rnn-inputs.png 301w, https://shapeofdata.files.wordpress.com/2015/10/rnn-inputs.png?w=150 150w\" sizes=\"(max-width: 301px) 100vw, 301px\"   /></a></p>\n<p>When we process the first vector, we do exactly what we described above &#8211; using a default value for the output of any neuron with an arrow that points &#8220;backwards&#8221; in the ordering. But then, when we process the second vector and get to a neuron with an arrow pointing backwards, we discover that we now have an output value for it &#8211; the value that was set when we processed the first input vector. So the neuron output values determined by the second vector in the sequence are affected by the first vector in the sequence. We repeat this for the third input vector, ending up with output values that are affected by the first two input vectors as well. So the backward arrows function kind of like memory cells within the recurrent neural network, remembering which &#8220;concepts&#8221; the earlier inputs represented.</p>\n<p>Now, there are other, simpler ways we could create a model that takes into account more than one of these moving window vectors at a time. For example, we could concatenate the first <i>N</i> of the vectors together for some <em>N</em>, creating an input vector with <em>N</em> times as many dimensions as we started with. This is similar in principal to an n-gram. This would put the input back in standard vector form, so we could use any old model on it.</p>\n<p>A recurrent neural network is a more complex solution than this, but it has two big advantages over techniques like n-grams or this concatenation scheme: First, the recurrent neural network works the same way no matter how long the sequence of inputs is. In other words, you don&#8217;t have to choose a value <em>N</em> before you start using it.</p>\n<p>Second, and perhaps more importantly, a recurrent neural network reuses the same neurons for all the inputs in the sequence, allowing the overall network to be smaller/simpler. As each input vector comes in, it gets &#8220;compressed&#8221; into a set of concepts, defined by the neurons whose output will feed back into the next cycle of the network.</p>\n<p>Any scheme for turning a sequence into a vector would need to use some method to reduce the number of dimensions, such as restricting to the most common n-grams. The recurrent neural network does this implicitly, as part of the same training process (whose description will have to wait for a later post) as the rest of the network. So the process is much more natural, and doesn&#8217;t require as many arbitrary decisions.</p>\n",
  "wfw:commentRss": "https://shapeofdata.wordpress.com/2015/10/20/recurrent-neural-networks/feed/",
  "slash:comments": 6,
  "media:content": [
    {
      "media:title": "jessejohnson"
    },
    {
      "media:title": "ANN4"
    },
    {
      "media:title": "dag"
    },
    {
      "media:title": "rnn-inputs"
    }
  ]
}