{
  "title": "Adventures in Manipulating Python ASTs",
  "link": "",
  "id": "https://www.georgeho.org/manipulating-python-asts/",
  "updated": "2020-03-27T00:00:00Z",
  "published": "2020-03-27T00:00:00Z",
  "content": "<p>A while back, I explored the possibility of simplifying <sup id=\"fnref:1\"><a href=\"#fn:1\" class=\"footnote-ref\" role=\"doc-noteref\">1</a></sup> PyMC4&rsquo;s model specification\nAPI by manipulating the <a href=\"https://docs.python.org/3/library/ast.html\">Python abstract syntax\ntree</a> (AST) of the model code. The PyMC\ndevelopers didn&rsquo;t end up pursuing those API changes any further, but not until I had the\nchance to learn a lot about Python ASTs.</p>\n<p>Enough curious people have asked me about my experience tinkering with ASTs that I\nfigure I&rsquo;d write a short post about the details of my project, in the hope that someone\nelse will find it useful.</p>\n<p>You should read this blog post as a quick overview of my experience with Python ASTs, or\nan annotated list of links, and not a comprehensive tutorial on model specification APIs\nor Python ASTs. For a full paper trail of my adventures with Python ASTs, check out <a href=\"https://github.com/eigenfoo/random/tree/master/python/ast-hiding-yield\">my\nnotebooks on\nGitHub</a>.</p>\n<h2 id=\"the-problem\">The Problem</h2>\n<p>Originally, PyMC4&rsquo;s proposed model specification API looked something like this:</p>\n<div class=\"highlight\"><pre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"><code class=\"language-python\" data-lang=\"python\"><span style=\"display:flex;\"><span><span style=\"color:#66d9ef\">def</span> <span style=\"color:#a6e22e\">linear_regression</span>(x):\n</span></span><span style=\"display:flex;\"><span> scale <span style=\"color:#f92672\">=</span> <span style=\"color:#66d9ef\">yield</span> tfd<span style=\"color:#f92672\">.</span>HalfCauchy(<span style=\"color:#ae81ff\">0</span>, <span style=\"color:#ae81ff\">1</span>)\n</span></span><span style=\"display:flex;\"><span> coefs <span style=\"color:#f92672\">=</span> <span style=\"color:#66d9ef\">yield</span> tfd<span style=\"color:#f92672\">.</span>Normal(tf<span style=\"color:#f92672\">.</span>zeros(x<span style=\"color:#f92672\">.</span>shape[<span style=\"color:#ae81ff\">1</span>]), <span style=\"color:#ae81ff\">1</span>)\n</span></span><span style=\"display:flex;\"><span> predictions <span style=\"color:#f92672\">=</span> <span style=\"color:#66d9ef\">yield</span> tfd<span style=\"color:#f92672\">.</span>Normal(tf<span style=\"color:#f92672\">.</span>linalg<span style=\"color:#f92672\">.</span>matvec(x, coefs), scale)\n</span></span><span style=\"display:flex;\"><span> <span style=\"color:#66d9ef\">return</span> predictions\n</span></span></code></pre></div><p>The main drawback to this API was that the <code>yield</code> keyword was confusing. Many users\ndon’t really understand Python generators, and those who do might only understand\n<code>yield</code> as a drop-in replacement for <code>return</code> (that is, they might understand what it\nmeans for a function to end in <code>yield foo</code>, but would be uncomfortable with <code>bar = yield foo</code>).</p>\n<p>Furthermore, the <code>yield</code> keyword introduces a leaky abstraction<sup id=\"fnref:2\"><a href=\"#fn:2\" class=\"footnote-ref\" role=\"doc-noteref\">2</a></sup>: users don’t care\nabout whether model is a function or a generator, and they shouldn&rsquo;t need to. More\ngenerally, users shouldn&rsquo;t have to know anything about how PyMC works in order to use\nit: ideally, the only thing users would need to think about would be their data and\ntheir model. Having to graft several <code>yield</code> keywords into their code is a fairly big\nintrusion in that respect.</p>\n<p>Finally, this model specification API is essentially moving the problem off of our\nplates and onto our users. The entire point of the PyMC project is to provide a friendly\nand easy-to-use interface for Bayesian modelling.</p>\n<p>To enumerate the problem further, we wanted to:</p>\n<ol>\n<li>Hide the <code>yield</code> keyword from the user-facing model specification API.</li>\n<li>Obtain the user-defined model as a generator.</li>\n</ol>\n<p>The main difficulty with the first goal is that as soon as we remove <code>yield</code> from the\nmodel function, it is no longer a generator. However, the PyMC inference engine needs the\nmodel as a generator, since this allows us to interrupt the control flow of the model at\nvarious points to do certain things:</p>\n<ul>\n<li>Manage random variable names.</li>\n<li>Perform sampling.</li>\n<li>Other arbitrary PyMC magic that I&rsquo;m truthfully not familiar with.</li>\n</ul>\n<p>In short, the user writes their model as a function, but we require the model as a\ngenerator.</p>\n<p>I opine on why this problem is challenging a lot more\n<a href=\"https://github.com/eigenfoo/random/tree/master/python/ast-hiding-yield/00-prototype#why-is-this-problem-hard\">here</a>.</p>\n<h2 id=\"the-solution\">The Solution</h2>\n<p>First, I wrote a <code>FunctionToGenerator</code> class:</p>\n<div class=\"highlight\"><pre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"><code class=\"language-python\" data-lang=\"python\"><span style=\"display:flex;\"><span><span style=\"color:#66d9ef\">class</span> <span style=\"color:#a6e22e\">FunctionToGenerator</span>(ast<span style=\"color:#f92672\">.</span>NodeTransformer):\n</span></span><span style=\"display:flex;\"><span> <span style=\"color:#e6db74\">&#34;&#34;&#34;\n</span></span></span><span style=\"display:flex;\"><span><span style=\"color:#e6db74\"> This subclass traverses the AST of the user-written, decorated,\n</span></span></span><span style=\"display:flex;\"><span><span style=\"color:#e6db74\"> model specification and transforms it into a generator for the\n</span></span></span><span style=\"display:flex;\"><span><span style=\"color:#e6db74\"> model. Subclassing in this way is the idiomatic way to transform\n</span></span></span><span style=\"display:flex;\"><span><span style=\"color:#e6db74\"> an AST.\n</span></span></span><span style=\"display:flex;\"><span><span style=\"color:#e6db74\"> Specifically:\n</span></span></span><span style=\"display:flex;\"><span><span style=\"color:#e6db74\">\n</span></span></span><span style=\"display:flex;\"><span><span style=\"color:#e6db74\"> 1. Add `yield` keywords to all assignments\n</span></span></span><span style=\"display:flex;\"><span><span style=\"color:#e6db74\"> E.g. `x = tfd.Normal(0, 1)` -&gt; `x = yield tfd.Normal(0, 1)`\n</span></span></span><span style=\"display:flex;\"><span><span style=\"color:#e6db74\"> 2. Rename the model specification function to\n</span></span></span><span style=\"display:flex;\"><span><span style=\"color:#e6db74\"> `_pm_compiled_model_generator`. This is done out an abundance\n</span></span></span><span style=\"display:flex;\"><span><span style=\"color:#e6db74\"> of caution more than anything.\n</span></span></span><span style=\"display:flex;\"><span><span style=\"color:#e6db74\"> 3. Remove the @Model decorator. Otherwise, we risk running into\n</span></span></span><span style=\"display:flex;\"><span><span style=\"color:#e6db74\"> an infinite recursion.\n</span></span></span><span style=\"display:flex;\"><span><span style=\"color:#e6db74\"> &#34;&#34;&#34;</span>\n</span></span><span style=\"display:flex;\"><span> <span style=\"color:#66d9ef\">def</span> <span style=\"color:#a6e22e\">visit_Assign</span>(self, node):\n</span></span><span style=\"display:flex;\"><span> new_node <span style=\"color:#f92672\">=</span> node\n</span></span><span style=\"display:flex;\"><span> new_node<span style=\"color:#f92672\">.</span>value <span style=\"color:#f92672\">=</span> ast<span style=\"color:#f92672\">.</span>Yield(value<span style=\"color:#f92672\">=</span>new_node<span style=\"color:#f92672\">.</span>value)\n</span></span><span style=\"display:flex;\"><span>\n</span></span><span style=\"display:flex;\"><span> <span style=\"color:#75715e\"># Tie up loose ends in the AST.</span>\n</span></span><span style=\"display:flex;\"><span> ast<span style=\"color:#f92672\">.</span>copy_location(new_node, node)\n</span></span><span style=\"display:flex;\"><span> ast<span style=\"color:#f92672\">.</span>fix_missing_locations(new_node)\n</span></span><span style=\"display:flex;\"><span> self<span style=\"color:#f92672\">.</span>generic_visit(node)\n</span></span><span style=\"display:flex;\"><span> <span style=\"color:#66d9ef\">return</span> new_node\n</span></span><span style=\"display:flex;\"><span>\n</span></span><span style=\"display:flex;\"><span> <span style=\"color:#66d9ef\">def</span> <span style=\"color:#a6e22e\">visit_FunctionDef</span>(self, node):\n</span></span><span style=\"display:flex;\"><span> new_node <span style=\"color:#f92672\">=</span> node\n</span></span><span style=\"display:flex;\"><span> new_node<span style=\"color:#f92672\">.</span>name <span style=\"color:#f92672\">=</span> <span style=\"color:#e6db74\">&#34;_pm_compiled_model_generator&#34;</span>\n</span></span><span style=\"display:flex;\"><span> new_node<span style=\"color:#f92672\">.</span>decorator_list <span style=\"color:#f92672\">=</span> []\n</span></span><span style=\"display:flex;\"><span>\n</span></span><span style=\"display:flex;\"><span> <span style=\"color:#75715e\"># Tie up loose ends in the AST.</span>\n</span></span><span style=\"display:flex;\"><span> ast<span style=\"color:#f92672\">.</span>copy_location(new_node, node)\n</span></span><span style=\"display:flex;\"><span> ast<span style=\"color:#f92672\">.</span>fix_missing_locations(new_node)\n</span></span><span style=\"display:flex;\"><span> self<span style=\"color:#f92672\">.</span>generic_visit(node)\n</span></span><span style=\"display:flex;\"><span> <span style=\"color:#66d9ef\">return</span> new_node\n</span></span></code></pre></div><p>Subclassing <code>ast.NodeTransformer</code> (as <code>FunctionToGenerator</code> does) is the <a href=\"https://greentreesnakes.readthedocs.io/en/latest/manipulating.html#modifying-the-tree\">recommended\nway of modifying\nASTs</a>.\nThe functionality of <code>FunctionToGenerator</code> is pretty well described by the docstring:\nthe <code>visit_Assign</code> method adds the <code>yield</code> keyword to all assignments by wrapping the\nvisited <code>Assign</code> node within a <code>Yield</code> node. The <code>visit_FunctionDef</code> method removes the\ndecorator and renames the function to <code>_pm_compiled_model_generator</code>. All told, after\nthe <code>NodeTransformer</code> is done with the AST, we have one function,\n<code>_pm_compiled_model_generator</code>, which is a modified version of the user-defined\nfunction.</p>\n<p>Second, the <code>Model</code> class:</p>\n<div class=\"highlight\"><pre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"><code class=\"language-python\" data-lang=\"python\"><span style=\"display:flex;\"><span><span style=\"color:#66d9ef\">class</span> <span style=\"color:#a6e22e\">Model</span>:\n</span></span><span style=\"display:flex;\"><span> <span style=\"color:#e6db74\">&#34;&#34;&#34; pm.Model decorator. &#34;&#34;&#34;</span>\n</span></span><span style=\"display:flex;\"><span>\n</span></span><span style=\"display:flex;\"><span> <span style=\"color:#66d9ef\">def</span> __init__(self, func):\n</span></span><span style=\"display:flex;\"><span> self<span style=\"color:#f92672\">.</span>func <span style=\"color:#f92672\">=</span> func\n</span></span><span style=\"display:flex;\"><span>\n</span></span><span style=\"display:flex;\"><span> <span style=\"color:#75715e\"># Introspect wrapped function, instead of the decorator class.</span>\n</span></span><span style=\"display:flex;\"><span> functools<span style=\"color:#f92672\">.</span>update_wrapper(self, func)\n</span></span><span style=\"display:flex;\"><span>\n</span></span><span style=\"display:flex;\"><span> <span style=\"color:#75715e\"># Uncompile wrapped function.</span>\n</span></span><span style=\"display:flex;\"><span> uncompiled <span style=\"color:#f92672\">=</span> uncompile(func<span style=\"color:#f92672\">.</span>__code__)\n</span></span><span style=\"display:flex;\"><span>\n</span></span><span style=\"display:flex;\"><span> <span style=\"color:#75715e\"># Parse AST and modify it.</span>\n</span></span><span style=\"display:flex;\"><span> tree <span style=\"color:#f92672\">=</span> parse_snippet(<span style=\"color:#f92672\">*</span>uncompiled)\n</span></span><span style=\"display:flex;\"><span> tree <span style=\"color:#f92672\">=</span> FunctionToGenerator()<span style=\"color:#f92672\">.</span>visit(tree)\n</span></span><span style=\"display:flex;\"><span> uncompiled[<span style=\"color:#ae81ff\">0</span>] <span style=\"color:#f92672\">=</span> tree\n</span></span><span style=\"display:flex;\"><span>\n</span></span><span style=\"display:flex;\"><span> <span style=\"color:#75715e\"># Recompile wrapped function.</span>\n</span></span><span style=\"display:flex;\"><span> self<span style=\"color:#f92672\">.</span>recompiled <span style=\"color:#f92672\">=</span> recompile(<span style=\"color:#f92672\">*</span>uncompiled)\n</span></span><span style=\"display:flex;\"><span>\n</span></span><span style=\"display:flex;\"><span> <span style=\"color:#75715e\"># Execute recompiled code (defines `_pm_compiled_model_generator`)</span>\n</span></span><span style=\"display:flex;\"><span> <span style=\"color:#75715e\"># in the locals() namespace and assign it to an attribute.</span>\n</span></span><span style=\"display:flex;\"><span> <span style=\"color:#75715e\"># Refer to http://lucumr.pocoo.org/2011/2/1/exec-in-python/</span>\n</span></span><span style=\"display:flex;\"><span> exec(self<span style=\"color:#f92672\">.</span>recompiled, <span style=\"color:#66d9ef\">None</span>, locals())\n</span></span><span style=\"display:flex;\"><span> self<span style=\"color:#f92672\">.</span>model_generator <span style=\"color:#f92672\">=</span> locals()[<span style=\"color:#e6db74\">&#34;_pm_compiled_model_generator&#34;</span>]\n</span></span></code></pre></div><p>This class isn&rsquo;t meant to be instantiated: rather, it&rsquo;s <a href=\"https://realpython.com/primer-on-python-decorators/#classes-as-decorators\">meant to be used as a Python\ndecorator</a>.\nEssentially, it &ldquo;uncompiles&rdquo; the function to get the Python source code of the function.\nThis source code is then passed to the <code>parse_snippet</code><sup id=\"fnref:3\"><a href=\"#fn:3\" class=\"footnote-ref\" role=\"doc-noteref\">3</a></sup> function, which returns the\nAST for the function. We then modify this AST with the <code>FunctionToGenerator</code> class that\nwe defined above. Finally, we recompile this AST and execute it. Recall that executing\nthis recompiled AST defines a new function called <code>_pm_compiled_model_generator</code>. This\nnew function, accessed via the <code>locals</code> variable<sup id=\"fnref:4\"><a href=\"#fn:4\" class=\"footnote-ref\" role=\"doc-noteref\">4</a></sup>, is then bound to the class&rsquo;s\n<code>self.model_generator</code>, which explains the confusing-looking\n<code>self.model_generator = locals()[&quot;_pm_compiled_model_generator&quot;]</code>.</p>\n<p>Finally, the user facing API looks like this:</p>\n<div class=\"highlight\"><pre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"><code class=\"language-python\" data-lang=\"python\"><span style=\"display:flex;\"><span><span style=\"color:#a6e22e\">@Model</span>\n</span></span><span style=\"display:flex;\"><span><span style=\"color:#66d9ef\">def</span> <span style=\"color:#a6e22e\">linear_regression</span>(x):\n</span></span><span style=\"display:flex;\"><span> scale <span style=\"color:#f92672\">=</span> tfd<span style=\"color:#f92672\">.</span>HalfCauchy(<span style=\"color:#ae81ff\">0</span>, <span style=\"color:#ae81ff\">1</span>)\n</span></span><span style=\"display:flex;\"><span> coefs <span style=\"color:#f92672\">=</span> tfd<span style=\"color:#f92672\">.</span>Normal(tf<span style=\"color:#f92672\">.</span>zeros(x<span style=\"color:#f92672\">.</span>shape[<span style=\"color:#ae81ff\">1</span>]), <span style=\"color:#ae81ff\">1</span>)\n</span></span><span style=\"display:flex;\"><span> predictions <span style=\"color:#f92672\">=</span> tfd<span style=\"color:#f92672\">.</span>Normal(tf<span style=\"color:#f92672\">.</span>linalg<span style=\"color:#f92672\">.</span>matvec(x, coefs), scale)\n</span></span><span style=\"display:flex;\"><span> <span style=\"color:#66d9ef\">return</span> predictions\n</span></span><span style=\"display:flex;\"><span>\n</span></span><span style=\"display:flex;\"><span>\n</span></span><span style=\"display:flex;\"><span>linear_regression<span style=\"color:#f92672\">.</span>model_generator(tf<span style=\"color:#f92672\">.</span>zeros([<span style=\"color:#ae81ff\">3</span>, <span style=\"color:#ae81ff\">10</span>])) <span style=\"color:#75715e\"># Shape is irrelevant here</span>\n</span></span><span style=\"display:flex;\"><span>\n</span></span><span style=\"display:flex;\"><span><span style=\"color:#75715e\"># Out[8]:</span>\n</span></span><span style=\"display:flex;\"><span><span style=\"color:#75715e\"># &lt;generator object _pm_compiled_model_generator at 0x107a5c5c8&gt;</span>\n</span></span></code></pre></div><p>As you can see, the users need not write <code>yield</code> while specifying their models, and the\nPyMC inference engine can now simply call the <code>model_generator</code> method of\n<code>linear_regression</code> to produce a generator called <code>_pm_compiled_model_generator</code>, as\ndesired. Success!</p>\n<h2 id=\"lessons-learnt\">Lessons Learnt</h2>\n<p>Again, PyMC4&rsquo;s model specification API will <em>not</em> be incorporating these changes: the\nPyMC developers have since decided that the <code>yield</code> keyword is the most elegant (but not\nnecessarily the easiest) way for users to specify statistical models. This post is just\nmeant to summarize the lessons learnt while pursuing this line of inquiry.</p>\n<p>Reading and parsing the AST is perfectly safe: that&rsquo;s basically just a form of code\nintrospection, which is totally a valid thing to do! It&rsquo;s when you want to modify or\neven rewrite the AST that things start getting <del>janky</del> dangerous (especially if you\nwant to execute the modified AST <em>instead</em> of the written code, as I was trying to do!).</p>\n<p>If you want to programmatically modify the AST (e.g. &ldquo;insert a <code>yield</code> keyword in front\nof every assignment of a TensorFlow Distribution&rdquo;, as in our case), stop and consider if\nyou&rsquo;re attempting to modify the <em>semantics</em> of the written code, and if you&rsquo;re sure that\nthat&rsquo;s a good idea (e.g. the <code>yield</code> keywords in the code <em>mean something</em>, and remove\nthose keywords changes the apparent semantics of the code).</p>\n<h2 id=\"further-reading\">Further Reading</h2>\n<p>I&rsquo;ve only given a high-level overview of this project here, and a lot of the technical\ndetails were glossed over. If you&rsquo;re hungry for more, check out the following resources:</p>\n<ul>\n<li>Notebooks and more extensive documentation on this project <a href=\"https://github.com/eigenfoo/random/tree/master/python/ast-hiding-yield\">are on\nGitHub</a>. In\nparticular, it might be helpful to peruse the <a href=\"https://github.com/eigenfoo/random/tree/master/python/ast-hiding-yield/00-prototype#links-and-references\">links and references at the end of the\nREADMEs</a>.</li>\n<li>For those looking to programmatically inspect/modify Python ASTs the same way I did\nhere, you might find <a href=\"https://twitter.com/remilouf/status/1213079103156424704\">this Twitter\nthread</a> helpful.</li>\n<li>And for those wondering how PyMC4&rsquo;s model specification API ended up, some very smart\npeople gave their feedback on this work <a href=\"https://twitter.com/avibryant/status/1150827954319982592\">on\nTwitter</a>.</li>\n</ul>\n<div class=\"footnotes\" role=\"doc-endnotes\">\n<hr>\n<ol>\n<li id=\"fn:1\">\n<p>Or should I say, complicating? At any rate, changing!&#160;<a href=\"#fnref:1\" class=\"footnote-backref\" role=\"doc-backlink\">&#x21a9;&#xfe0e;</a></p>\n</li>\n<li id=\"fn:2\">\n<p>I was <a href=\"https://twitter.com/avibryant/status/1150827954319982592\">subsequently\nconvinced</a> that this\nisn&rsquo;t a leaky abstraction after all.&#160;<a href=\"#fnref:2\" class=\"footnote-backref\" role=\"doc-backlink\">&#x21a9;&#xfe0e;</a></p>\n</li>\n<li id=\"fn:3\">\n<p>I omitted the implementation of <code>parse_snippet</code> for brevity. If you want\nto see it, check out the &ldquo;AST Helper Functions&rdquo; section of <a href=\"https://github.com/eigenfoo/random/blob/master/python/ast-hiding-yield/00-prototype/hiding-yield.ipynb\">this\nnotebook</a>.&#160;<a href=\"#fnref:3\" class=\"footnote-backref\" role=\"doc-backlink\">&#x21a9;&#xfe0e;</a></p>\n</li>\n<li id=\"fn:4\">\n<p>For way more information on <code>exec</code>, <code>eval</code>, <code>locals</code> and <code>globals</code>, check\nout <a href=\"https://lucumr.pocoo.org/2011/2/1/exec-in-python/\">Armin Ronacher&rsquo;s blog\npost</a> and <a href=\"https://stackoverflow.com/questions/2220699/whats-the-difference-between-eval-exec-and-compile\">this\nStackOverflow\nanswer</a>.&#160;<a href=\"#fnref:4\" class=\"footnote-backref\" role=\"doc-backlink\">&#x21a9;&#xfe0e;</a></p>\n</li>\n</ol>\n</div>"
}