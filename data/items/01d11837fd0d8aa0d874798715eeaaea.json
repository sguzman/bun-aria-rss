{
  "title": "Diabetic retinopathy detection contest. What we did wrong",
  "link": "",
  "updated": "2015-08-17T00:00:00+00:00",
  "id": "http://yerevann.github.io//2015/08/17/diabetic-retinopathy-detection-contest-what-we-did-wrong",
  "content": "<p>After watching the <a href=\"https://www.youtube.com/playlist?list=PL6Xpj9I5qXYEcOhn7TqghAJ6NAPrNmUBH\">awesome video course by Hugo Larochelle</a> on neural nets (more on this in the <a href=\"/2015/07/30/getting-started-with-neural-networks/\">previous post</a>) we decided to test our knowledge on some computer vision contest. We looked at <a href=\"https://www.kaggle.com/competitions\">Kaggle</a> and the only active competition related to computer vision (except for the <a href=\"https://www.kaggle.com/c/digit-recognizer\">digit recognizer contest</a>, for which lots of perfect out-of-the-box solutions exist) was the <a href=\"https://www.kaggle.com/c/diabetic-retinopathy-detection\">Diabetic retinopathy detection contest</a>. This was probably quite hard to become our very first project, but nevertheless we decided to try. The team included <a href=\"https://www.linkedin.com/in/mahnerak\">Karen</a>, <a href=\"https://www.linkedin.com/in/galstyantik\">Tigran</a>, <a href=\"https://github.com/Harhro94\">Hrayr</a>, <a href=\"https://www.linkedin.com/pub/narek-hovsepyan/86/b35/380\">Narek</a> (1st to 3rd year bachelor students) and <a href=\"https://github.com/Hrant-Khachatrian\">me</a> (PhD student). Long story short, we finished at the <a href=\"https://www.kaggle.com/c/diabetic-retinopathy-detection/leaderboard\">82nd place</a> out of 661 participants, and in this post I will describe in details what we did and what mistakes we made. All required files are on these 2 <a href=\"https://github.com/YerevaNN/Caffe-python-tools\">github</a> <a href=\"https://github.com/YerevaNN/Kaggle-diabetic-retinopathy-detection\">repositories</a>. We hope this will be interesting for those who just start to play with neural networks. Also we hope to get feedback from experts and other participants.</p>\n\n<!--more-->\n\n<h2 class=\"no_toc\" id=\"contents\">Contents</h2>\n<ul id=\"markdown-toc\">\n  <li><a href=\"#the-contest\" id=\"markdown-toc-the-contest\">The contest</a></li>\n  <li><a href=\"#software-and-hardware\" id=\"markdown-toc-software-and-hardware\">Software and hardware</a></li>\n  <li><a href=\"#image-preprocessing\" id=\"markdown-toc-image-preprocessing\">Image preprocessing</a></li>\n  <li><a href=\"#data-augmentation\" id=\"markdown-toc-data-augmentation\">Data augmentation</a></li>\n  <li><a href=\"#choosing-training--validation-sets\" id=\"markdown-toc-choosing-training--validation-sets\">Choosing training / validation sets</a></li>\n  <li><a href=\"#convolutional-network-architecture\" id=\"markdown-toc-convolutional-network-architecture\">Convolutional network architecture</a></li>\n  <li><a href=\"#loss-function\" id=\"markdown-toc-loss-function\">Loss function</a></li>\n  <li><a href=\"#preparing-submissions\" id=\"markdown-toc-preparing-submissions\">Preparing submissions</a></li>\n  <li><a href=\"#attempts-to-ensemble\" id=\"markdown-toc-attempts-to-ensemble\">Attempts to ensemble</a></li>\n  <li><a href=\"#more-on-this-contest\" id=\"markdown-toc-more-on-this-contest\">More on this contest</a></li>\n  <li><a href=\"#acknowledgements\" id=\"markdown-toc-acknowledgements\">Acknowledgements</a></li>\n</ul>\n\n<h2 id=\"the-contest\">The contest</h2>\n<p><a href=\"https://en.wikipedia.org/wiki/Diabetic_retinopathy\">Diabetic retinopathy</a> is a disease when the retina of the eye is damaged due to diabetes. It is one of the leading causes of blindness in the world. The contest’s aim was to see if computer programs can diagnose the disease automatically from the image of the retina. <a href=\"https://www.kaggle.com/c/diabetic-retinopathy-detection/forums/t/15605/human-performance-on-the-competition-data-set\">It seems</a> the winners slightly surpassed the performance of general ophthalmologists.</p>\n\n<p>Each eye of the patient can be in one of the 5 levels: from 0 to 4, where 0 corresponds to the healthy state and 4 is the most severe state. Different eyes of the same person can be at different levels (although some contestants managed to leverage the fact that two eyes are not completely independent). Contestants <a href=\"https://www.kaggle.com/c/diabetic-retinopathy-detection/data\">were given</a> 35126 JPEG images of retinas for training (32.5GB), 53576 images for testing (49.6GB) and a CSV file where level of the disease is written for the train images. The goal was to create another CSV file where disease levels are written for each of the test images. Contestants could submit maximum 5 CSV files per day for evaluation.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th><img src=\"/public/2015-08-17/eye-0.jpeg\" alt=\"Healthy eye: level 0\" title=\"Healthy eye: level 0\" /></th>\n      <th><img src=\"/public/2015-08-17/eye-4.jpeg\" alt=\"Severe state: level 4\" title=\"Severe state: level 4\" /></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Healthy eye: level 0</td>\n      <td>Severe state: level 4</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>The score was evaluated using a metric called <strong>quadratic weighted kappa</strong>. It is <a href=\"https://www.kaggle.com/c/diabetic-retinopathy-detection/details/evaluation\">described</a> as being an <em>agreement</em> between two raters: the agreement between the scores assigned by human rater (which is unknown to contestants) and the predicted scores. If the agreement is random, the score is close 0 (sometimes it can even be negative). In case of a perfect agreement the score is 1. It is <em>quadratic</em> in a sense that, for example, if you predict level 4 for a healthy eye, it is 16 times worse than if you predict level 1. Winners achieved a score <a href=\"https://www.kaggle.com/c/diabetic-retinopathy-detection/leaderboard\">more than 0.84</a>. Our best result was around 0.50.</p>\n\n<h2 id=\"software-and-hardware\">Software and hardware</h2>\n<p>It was obvious that we were going to use a <a href=\"https://www.youtube.com/watch?v=rxKrCa4bg1I&amp;index=69&amp;list=PL6Xpj9I5qXYEcOhn7TqghAJ6NAPrNmUBH\">convolutional neural network</a> for predicting. Not only because of its <a href=\"https://en.wikipedia.org/wiki/Convolutional_neural_network#Applications\">awesome performance</a> on many computer vision problems, including another Kaggle competition on <a href=\"https://www.kaggle.com/c/datasciencebowl\">plankton classification</a>, but also because it was the only technique we knew for image classification. We were aware of several libraries that implement convolutional networks, namely Python-based <a href=\"http://deeplearning.net/software/theano/\">Theano</a>, <a href=\"http://caffe.berkeleyvision.org/\">Caffe</a> written in C++, <a href=\"https://github.com/dmlc/cxxnet\">cxxnet</a> (developed by the <a href=\"https://www.kaggle.com/c/datasciencebowl/forums/t/12887/brief-describe-method-and-cxxnet-v2/69545\">2nd  place winners</a> of the plankton contest) and <a href=\"https://github.com/torch/nn/\">Torch</a>. We chose Caffe because it seemed to be the simplest one for beginners: it allows to define the neural network by a simple text file (like <a href=\"https://github.com/BVLC/caffe/blob/master/examples/mnist/lenet.prototxt\">this</a>) and train a network without writing a single line of code.</p>\n\n<p>We didn’t have a computer with CUDA-enabled GPU in the university, but our friends at <a href=\"http://cyclopstudio.com/\">Cyclop Studio</a> donated us an Intel Core i5 computer with 4GB RAM and <a href=\"http://www.geforce.com/hardware/desktop-gpus/geforce-gtx-550ti/specifications\">NVidia GeForce GTX 550 TI</a> card. 550 TI has a 1GB of memory which forced us to use very small batch sizes for the neural network. Later we switched to <a href=\"http://www.geforce.com/hardware/desktop-gpus/geforce-gtx-980/specifications\">GeForce GTX 980</a> with 4GB memory, which was completely fine for us.</p>\n\n<p>Karen and Tigran managed to <a href=\"http://caffe.berkeleyvision.org/install_apt.html\">install Caffe on Ubuntu</a> and make it work with CUDA, which was enough to start the training. Later Narek and Hrayr found out how to play with Caffe models <a href=\"https://github.com/BVLC/caffe/tree/master/python/caffe\">using Python</a>, so we can run our models on the test set. Karen has <a href=\"https://docs.c9.io/docs/running-your-own-ssh-workspace\">connected Cloud9 to the server</a>, and we could work remotely through a web interface.</p>\n\n<h2 id=\"image-preprocessing\">Image preprocessing</h2>\n<p>Images from the training and test datasets have very different resolutions, aspect ratios, colors, are cropped in various ways, some are of very low quality, are out of focus etc. Neural networks require a fixed input size, so we had to resize / crop all of them to some fixed dimensions. Karen and Tigran looked at many sample images and decided that the optimal resolution which preserves the details required for classification is 512x512. We thought that in 256x256 we might lose the small details that differ healthy eye images from level 1 images. In fact, by the end of the competition we saw that our networks cannot differentiate between level 0 and 1 images even with 512x512, so probably we could safely work on 256x256 from the very beginning (which would be much faster to train). All preprocessing was done using <a href=\"http://www.imagemagick.org/\">imagemagick</a>.</p>\n\n<p>We tried three methods to preprocess the images. First, as suggested by Karen and Tigran, we resized the images and then applied the so called <em><a href=\"http://www.imagemagick.org/Usage/transform/#charcoal\">charcoal</a></em> effect which is basically an edge detector. This highlighted the signs of blood on the retina. One of the challenging problems throughout the contest was to define a naming convention for everything: databases of preprocessed images, convnet descriptions, models, CSV files etc. We used the prefix <code class=\"highlighter-rouge\">edge</code> for anything which was based on the images preprocessed this way. The best kappa score achieved on this dataset was 0.42.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th><img src=\"/public/2015-08-17/eye-edge-0.jpg\" alt=\"`edge` level 0\" title=\"`edge` level 0\" /></th>\n      <th><img src=\"/public/2015-08-17/eye-edge-3.jpg\" alt=\"`edge` level 3\" title=\"`edge` level 3\" /></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Preprocessed image <em>(edge)</em> level 0</td>\n      <td>Preprocessed image <em>(edge)</em> level 3</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>But later we noticed that this method makes the dirt on lens or other optical issues appear similar to a blood sign, and it really confused our neural networks. The following two images are of healthy eyes (level 0), but both were recognized by almost all our models as level 4.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th><img src=\"/public/2015-08-17/orig-35297_left-0.jpeg\" alt=\"healthy eye\" title=\"healthy eye\" /></th>\n      <th><img src=\"/public/2015-08-17/edge-35297_left-0.jpeg\" alt=\"`edge`, recognized as level 4\" title=\"`edge`, recognized as level 4\" /></th>\n    </tr>\n    <tr>\n      <th><img src=\"/public/2015-08-17/orig-44330_left-0.jpeg\" alt=\"healthy eye\" title=\"healthy eye\" /></th>\n      <th><img src=\"/public/2015-08-17/edge-44330_left-0.jpeg\" alt=\"`edge`, recognized as level 4\" title=\"`edge`, recognized as level 4\" /></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Original images of healthy eyes</td>\n      <td>Preprocessed versions <code class=\"highlighter-rouge\">edge</code> recognized as level 4</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>So we decided to avoid using filters on the images, and leave all the work to the convolutional network: just resize and convert to one channel image (to save space and memory). We thought that the color information is not very important to detect the disease, although this could be one of our mistakes. Following the discussion at <a href=\"https://www.kaggle.com/c/diabetic-retinopathy-detection/forums/t/13147/rgb-or-grayscale/69138\">Kaggle forums</a> we decided to use the green channel only. We got our best results (kappa = 0.5) on this dataset. We used prefix <code class=\"highlighter-rouge\">g</code> for these images.</p>\n\n<p>Finally we tried to apply the <a href=\"http://www.imagemagick.org/Usage/color_mods/#equalize\"><em>equalize</em></a> filter on top of the green channel, which makes the histogram of the image uniform. The best kappa score we managed to get on the dataset preprocessed this way was only 0.4. We used prefix <code class=\"highlighter-rouge\">ge</code> for these images.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th><img src=\"/public/2015-08-17/g-99_left-3.jpeg\" alt=\"Just the green channel: g\" title=\"Just the green channel: g\" /></th>\n      <th><img src=\"/public/2015-08-17/ge-99_left-3.jpeg\" alt=\"Histogram equalization on top of the green channel: ge\" title=\"Histogram equalization on top of the green channel: ge\" /></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Just the green channel: <code class=\"highlighter-rouge\">g</code></td>\n      <td>Histogram equalization on top of the green channel: <code class=\"highlighter-rouge\">ge</code></td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"data-augmentation\">Data augmentation</h2>\n<p>One of the problems of neural networks is that they are extremely powerful. They learn so well that they usually learn something that degrades their performance on other (previously unseen) data. One (made-up) example: the images in the training set are taken by different cameras and have different characteristics. If for some reason, say, the percentage of images of level 2 in dark images is higher than in general, the network may start to predict level 2 more often for dark images. We are not aware of any way to detect such “misleading” correlations by looking at neuron activations of convolution filters. But, fortunately, it is possible to train the network on one subset of data and test it on another, and if the performance on these subsets are different, then the network has learned something very specific to the training data, it has <strong>overfit</strong> the training data, and we should try to avoid it.</p>\n\n<p>One of the solutions to this problem is to enlarge the dataset in order to minimize the chances of such correlations to happen. This is called <em><a href=\"https://www.youtube.com/watch?v=Km1Q5VcSKAg&amp;index=77&amp;list=PL6Xpj9I5qXYEcOhn7TqghAJ6NAPrNmUBH\">data augmentation</a></em>. The organizers of this contest explicitly <a href=\"https://www.kaggle.com/c/diabetic-retinopathy-detection/rules\">forbid</a> to use data outside the dataset they provided. But it’s obvious that if you take an image, zoom it, rotate it, flip it, change the brightness etc. the level of the disease will not be changed. So it is possible to apply these transformations to the images and obtain much larger and “more random” training dataset. One approach is to take all versions of all images into the training set, another approach is to randomly choose one transformation for each of the images. The mixture of these approaches helps to solve another problem which will be discussed in the next section.</p>\n\n<p>We applied very limited transformations only. For every image we created 4 samples: original, rotated by 180 degrees, and the vertical flipped versions of these two. This helped to avoid the problem, that some of the images in the dataset <a href=\"https://www.kaggle.com/c/diabetic-retinopathy-detection/data\">were flipped</a>.</p>\n\n<p>We believe that we spent way too little time on data augmentation. All other contestants we have seen use much more sophisticated transformations. Probably this was our most important mistake.</p>\n\n<h2 id=\"choosing-training--validation-sets\">Choosing training / validation sets</h2>\n<p>There are two reasons to train the networks only on a subset of the train dataset provided by Kaggle. First reason is to be able to compare different models. We need to choose the model which generalizes best to the unseen data, not the one which performs best on the data it has been trained on. So we train various models on some subset of the dataset (again called a <em>training set</em>), then compare their performance on the other subset (called a <em>validation set</em>) and pick the one which works better on the latter.</p>\n\n<p>The second reason is to detect overfitting while training. During the training we sometimes (in Caffe this is configured by the <a href=\"http://caffe.berkeleyvision.org/tutorial/solver.html\"><em>test_interval</em> parameter</a>) run the network on the validation set and calculate the loss. When we see that the loss on the validation set does not decrease anymore, we know that overfitting happens. This is best illustrated in this <a href=\"https://en.wikipedia.org/wiki/Overfitting#/media/File:Overfitting_svg.svg\">image from Wikipedia</a>.</p>\n\n<p>The distribution of images of different levels in the training set provided by Kaggle was very uneven. More than half of the images were of healthy eyes:</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>Level</td>\n      <td>Number of images</td>\n      <td>Percentage</td>\n    </tr>\n    <tr>\n      <td>0</td>\n      <td>25810</td>\n      <td>73.48%</td>\n    </tr>\n    <tr>\n      <td>1</td>\n      <td>2443</td>\n      <td>6.95%</td>\n    </tr>\n    <tr>\n      <td>2</td>\n      <td>5292</td>\n      <td>15.07%</td>\n    </tr>\n    <tr>\n      <td>3</td>\n      <td>873</td>\n      <td>2.49%</td>\n    </tr>\n    <tr>\n      <td>4</td>\n      <td>708</td>\n      <td>2.02%</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>Neural networks seem to be very sensitive to this kind of distributions. Our very first neural network (using softmax classification) was randomly giving labels 0 and 2 to almost all images (which brought a kappa score 0.138). So we had to make the classes more or less equal. Here we did couple of trivial mistakes.</p>\n\n<p>At first we augmented the dataset by creating lots of rotations (multiples of 30 degrees, 12 versions of each image) and created a dataset of around 100K images with equally distributed classes. So we took 36 times more versions of images of level 4 than of images of level 0. As we had only 12 versions of each image, we took every image 3 times. Finally, we separated the training and validation sets <em>after</em> these augmentations. After training 88000 iterations (with batch size 2, we were still on GeForce 550 Ti) we had 0.55 kappa score on our validation set. But on Kaggle’s test set the score was only 0.23. So we had a terrible overfitting and didn’t detect it locally.</p>\n\n<p>The most important point here, as I understand it, is that the separation of training and validation sets should have been done <em>before</em> the data augmentation. In our case we had different rotations of the same image in both sets, which didn’t allow us to detect overfitting.</p>\n\n<p>So later we took 7472 images (21%) as a validation set, and performed the data augmentation on the remaining 27654 images. Validation set had the same ratio of classes as the Kaggle’s test set. This is important for choosing the best model: validation set should be similar to the test set as much as possible.</p>\n\n<p>Also we decided to get rid off the rotations by multiples of 30 degrees, as the images were being distorted (we applied rotations <em>after</em> resizing the images). Although, after the competition we saw that <a href=\"http://jeffreydf.github.io/diabetic-retinopathy-detection/\">other contestants</a> have used such rotations. So maybe this was another mistake.</p>\n\n<p>Then, it turned out that the idea of taking copies of the same image is terrible, because the network overfits the smaller classes (like level 3 and level 4) and it is hard to notice that just by looking at validation loss values, because the corresponding classes are very small in the validation set. We identified this problem by carefully visualizing neuron activations on training and validation sets (just 2 weeks before the competition deadline):</p>\n\n<table>\n  <thead>\n    <tr>\n      <th><img src=\"/public/2015-08-17/3-4-overfit.png\" alt=\"Blue dots are from the training set, orange dots are from the validation set. x axis is the activation of a top layer neuron. y axis is the original label (0 to 4)\" title=\"Blue dots are from the training set, orange dots are from the validation set. x axis is the activation of a top layer neuron. y axis is the original label (0 to 4)\" /></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Every dot corresponds to one image. Blue dots are from the training set, orange dots are from the validation set. <code class=\"highlighter-rouge\">x</code> axis is the activation of a top layer neuron. <code class=\"highlighter-rouge\">y</code> axis is the original label (0 to 4). Basically there is no overfitting for the images of level 0, 1 or 2: the activations are very similar. But the overfitting of the images of level 3 and 4 is obvious. Training samples are concentrated around fixed values, while validation samples are spread widely</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>Finally we decided to train a network to differentiate between two classes only: images of level 0 and 1 versus images of level 2, 3 and 4. The ratio of the images in these classes was 4:1. We augmented the training set only by vertical flipping and rotating by 180 degrees. We took all 4 versions of each image of the second class and we randomly took one of the 4 versions of each image of the first class. This way we ended up with a training set of two equal classes. This gave us our best kappa score 0.50.</p>\n\n<p>Later we wanted to train a classifier which would differentiate level 0 images from level 1 images only, but the networks we tried didn’t work at all. Another classifier we used to differentiate between level 2 and level 3 + level 4 images actually learned something, but we couldn’t increase the overall kappa score based on that.</p>\n\n<p>After preparing the list of files for the training and validation sets, we used a tool bundled with Caffe to create a <a href=\"http://leveldb.org/\">LevelDB</a> database from the directory of images. Caffe <a href=\"http://caffe.berkeleyvision.org/tutorial/data.html\">prefers</a> to read from LevelDB rather than from directory:</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-bash\" data-lang=\"bash\">./build/tools/convert_imageset <span class=\"nt\">-backend</span><span class=\"o\">=</span>leveldb <span class=\"nt\">-gray</span><span class=\"o\">=</span><span class=\"nb\">true</span> <span class=\"nt\">-shuffle</span><span class=\"o\">=</span><span class=\"nb\">true </span>data/train.g/ train.g.01v234.txt leveldb/train.g.01v234</code></pre></figure>\n\n<p><code class=\"highlighter-rouge\">gray</code> is set to <code class=\"highlighter-rouge\">true</code> because we use single-channel images and <code class=\"highlighter-rouge\">shuffle</code> is required to properly shuffle the images before importing into the database.</p>\n\n<h2 id=\"convolutional-network-architecture\">Convolutional network architecture</h2>\n\n<p>Our best performing <a href=\"https://github.com/YerevaNN/Kaggle-diabetic-retinopathy-detection/blob/master/g_01v234_40r-2-40r-2-40r-2-40r-4-256rd0.5-256rd0.5.prototxt\">neural network architecture</a> and corresponding <a href=\"https://github.com/YerevaNN/Kaggle-diabetic-retinopathy-detection/blob/master/best-performing-solver.prototxt\">solver</a> are on Github. <code class=\"highlighter-rouge\">Batch size</code> was always fixed to 20 (on GTX 980 card). We used a simple <em>stochastic gradient descent</em> with 0.9 <code class=\"highlighter-rouge\">momentum</code> and didn’t touch learning rate policy at all (it didn’t decrease the rate significantly). We started at 0.001 <code class=\"highlighter-rouge\">learning rate</code>, and sometimes manually decreased it (but not in this particular case which brought the best kappa score). Also in this best performing case we started with 0 <code class=\"highlighter-rouge\">weight decay</code>, and after the first signs of overfitting (after 48K iterations, which is almost 20 epochs) increased it to 0.0015.</p>\n\n<p>Convolution was done similar to the “traditional” <a href=\"http://caffe.berkeleyvision.org/gathered/examples/mnist.html\">LeNet architecture</a> (developed by <a href=\"http://yann.lecun.com/\">Yann LeCun</a>, who invented the convolutional networks): one max pooling layer after every convolution layer, with fully connected layers at the end.</p>\n\n<p>Almost all other contestants used the other famous approach, with multiple consecutive convolutional layers with small kernels before a pooling layer. This was developed by <a href=\"http://www.robots.ox.ac.uk/~vgg/research/very_deep/\">Karen Simonyan and Andrew Zisserman</a> at Visual Geometry Group, University of Oxford (that’s why it is called <em>VGGNet</em> or <em>OxfordNet</em>) for the <a href=\"http://www.image-net.org/challenges/LSVRC/2014/results#clsloc\">ImageNet 2014 contest</a> where they took 1st and 2nd places for localization and classification tasks, respectively. Their approach was popularized by <a href=\"http://cs231n.github.io/convolutional-networks/#case\">Andrej Karpathy</a> and was successfully used in the <a href=\"http://benanne.github.io/2015/03/17/plankton.html#architecture\">plankton classification contest</a>. I have tried this approach once, but it required significantly more memory and time, so I quickly abandoned it.</p>\n\n<p>Here is the structure of our network:</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td>Nr</td>\n      <td>Type</td>\n      <td>Batches</td>\n      <td>Channels</td>\n      <td>Width</td>\n      <td>Height</td>\n      <td>Kernel size / stride</td>\n    </tr>\n    <tr>\n      <td>0</td>\n      <td>Input</td>\n      <td>20</td>\n      <td>1</td>\n      <td>512</td>\n      <td>512</td>\n      <td> </td>\n    </tr>\n    <tr>\n      <td>1</td>\n      <td>Conv</td>\n      <td>20</td>\n      <td>40</td>\n      <td>506</td>\n      <td>506</td>\n      <td>7x7 / 1</td>\n    </tr>\n    <tr>\n      <td>2</td>\n      <td>ReLU</td>\n      <td>20</td>\n      <td>40</td>\n      <td>506</td>\n      <td>506</td>\n      <td> </td>\n    </tr>\n    <tr>\n      <td>3</td>\n      <td>MaxPool</td>\n      <td>20</td>\n      <td>40</td>\n      <td>253</td>\n      <td>253</td>\n      <td>3x3 / 2</td>\n    </tr>\n    <tr>\n      <td>4</td>\n      <td>Conv</td>\n      <td>20</td>\n      <td>40</td>\n      <td>249</td>\n      <td>249</td>\n      <td>5x5 / 1</td>\n    </tr>\n    <tr>\n      <td>5</td>\n      <td>ReLU</td>\n      <td>20</td>\n      <td>40</td>\n      <td>249</td>\n      <td>249</td>\n      <td> </td>\n    </tr>\n    <tr>\n      <td>6</td>\n      <td>MaxPool</td>\n      <td>20</td>\n      <td>40</td>\n      <td>124</td>\n      <td>124</td>\n      <td>3x3 / 2</td>\n    </tr>\n    <tr>\n      <td>7</td>\n      <td>Conv</td>\n      <td>20</td>\n      <td>40</td>\n      <td>120</td>\n      <td>120</td>\n      <td>5x5 / 1</td>\n    </tr>\n    <tr>\n      <td>8</td>\n      <td>ReLU</td>\n      <td>20</td>\n      <td>40</td>\n      <td>120</td>\n      <td>120</td>\n      <td> </td>\n    </tr>\n    <tr>\n      <td>9</td>\n      <td>MaxPool</td>\n      <td>20</td>\n      <td>40</td>\n      <td>60</td>\n      <td>60</td>\n      <td>3x3 / 2</td>\n    </tr>\n    <tr>\n      <td>10</td>\n      <td>Conv</td>\n      <td>20</td>\n      <td>40</td>\n      <td>56</td>\n      <td>56</td>\n      <td>5x5 / 1</td>\n    </tr>\n    <tr>\n      <td>11</td>\n      <td>ReLU</td>\n      <td>20</td>\n      <td>40</td>\n      <td>56</td>\n      <td>56</td>\n      <td> </td>\n    </tr>\n    <tr>\n      <td>12</td>\n      <td>MaxPool</td>\n      <td>20</td>\n      <td>40</td>\n      <td>14</td>\n      <td>14</td>\n      <td>4x4 / 4</td>\n    </tr>\n    <tr>\n      <td>13</td>\n      <td>Fully connected</td>\n      <td>20</td>\n      <td>256</td>\n      <td> </td>\n      <td> </td>\n      <td> </td>\n    </tr>\n    <tr>\n      <td>14</td>\n      <td>ReLU</td>\n      <td>20</td>\n      <td>256</td>\n      <td> </td>\n      <td> </td>\n      <td> </td>\n    </tr>\n    <tr>\n      <td>15</td>\n      <td>Dropout</td>\n      <td>20</td>\n      <td>256</td>\n      <td> </td>\n      <td> </td>\n      <td> </td>\n    </tr>\n    <tr>\n      <td>16</td>\n      <td>Fully connected</td>\n      <td>20</td>\n      <td>256</td>\n      <td> </td>\n      <td> </td>\n      <td> </td>\n    </tr>\n    <tr>\n      <td>17</td>\n      <td>ReLU</td>\n      <td>20</td>\n      <td>256</td>\n      <td> </td>\n      <td> </td>\n      <td> </td>\n    </tr>\n    <tr>\n      <td>18</td>\n      <td>Dropout</td>\n      <td>20</td>\n      <td>256</td>\n      <td> </td>\n      <td> </td>\n      <td> </td>\n    </tr>\n    <tr>\n      <td>19</td>\n      <td>Fully connected</td>\n      <td>20</td>\n      <td>1</td>\n      <td> </td>\n      <td> </td>\n      <td> </td>\n    </tr>\n    <tr>\n      <td>20</td>\n      <td>Euclidean Loss</td>\n      <td>1</td>\n      <td>1</td>\n      <td> </td>\n      <td> </td>\n      <td> </td>\n    </tr>\n  </tbody>\n</table>\n\n<p>Some observations related to the network architecture:</p>\n\n<ul>\n  <li><a href=\"https://en.wikipedia.org/wiki/Rectifier_(neural_networks)\">ReLU activations</a> on all convolutional and fully connected layers helped a lot, kappa score increased by almost 0.1. It’s interesting to note that Christian Szegedy, one of the GoogLeNet developers (winner of the classification contest at ImageNet 2014), <a href=\"https://www.youtube.com/watch?v=ySrj_G5gHWI\">expressed an opinion</a> that the main reason for the deep learning revolution happening now is the ReLU function :)</li>\n  <li>2 fully connected layers (256 neurons each) at the end is better than one fully connected layer. Kappa was increased by almost 0.03</li>\n  <li>Number of filters in the convolutional layers are not very important. Difference between, say, 20 and 40 filters is very little</li>\n  <li>Dropout helps fight overfitting (we used 50% probability everywhere)</li>\n  <li>We didn’t notice any difference with Local response normalization layers</li>\n</ul>\n\n<p>Below are the 40 filters of the first convolutional layer of our best model (visualization code is adapted from <a href=\"http://nbviewer.ipython.org/github/BVLC/caffe/blob/master/examples/00-classification.ipynb\">here</a>). They don’t seem to be very meaningful:</p>\n\n<p><img src=\"/public/2015-08-17/convolutional-filters.png\" alt=\"Filters of the 1st convolutional layer\" title=\"Filters of the 1st convolutional layer\" /></p>\n\n<p>I tried to use dropout on convolutional layers as well, but couldn’t make the network learn anything. The loss was quickly becoming <code class=\"highlighter-rouge\">nan</code>. Probably the learning rate should have been very different…</p>\n\n<h2 id=\"loss-function\">Loss function</h2>\n<p>Submissions of this contest were evaluated by the metric called <strong>quadratic weighted kappa</strong>. We found an <a href=\"http://www.real-statistics.com/reliability/weighted-cohens-kappa/\">Excel code</a> that implements it which helped us to get some intuition.</p>\n\n<p>At the beginning we started to use <a href=\"http://caffe.berkeleyvision.org/doxygen/classcaffe_1_1SoftmaxWithLossLayer.html\">softmax loss</a> on top of the 5 neurons of the final fully connected layer. Later we decided to use something that will take into account the fact that the order of the labels matters (0 and 1 are closer than 0 and 4). We left only one neuron in the last layer and tried to use <a href=\"http://caffe.berkeleyvision.org/doxygen/classcaffe_1_1EuclideanLossLayer.html\">Euclidean loss</a>. We even tried to “scale” the labels of the images in a way that will make it closer to being “quadratic”: we replaced the labels [0,1,2,3,4] with [0,2,3,4,6].</p>\n\n<p>Ideally we would like to have a loss function that implements the kappa metric. But we didn’t risk to implement a new layer in Caffe. <a href=\"http://jeffreydf.github.io/diabetic-retinopathy-detection/#the-opening\">Jeffrey De Fauw</a> has implemented some continuous approximation of kappa metric using Theano with a lot of success.</p>\n\n<p>When we switched to 0,1 vs 2,3,4 classification, I thought 2-neuron softmax would be better than Euclidean loss because of the second neuron: it might bring some information that could help to obtain better score. But after some tests I saw that the sum of the activations of the two softmax neurons tends to 1, so the second neuron does not bring new information. The rest of the training was done using Euclidean loss (although I am not sure if that was the best option).</p>\n\n<p>We logged the output of Caffe into a file, then plotted the graphs of training and validation losses using a <a href=\"https://github.com/YerevaNN/Caffe-python-tools/blob/master/plot_loss.py\">Python script</a> written by Hrayr:</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-bash\" data-lang=\"bash\">./build/tools/caffe train <span class=\"nt\">-solver</span><span class=\"o\">=</span>solver.prototxt &amp;&gt; log_g_g_01v234_40r-2-40r-2-40r-2-40r-4-256rd0.5-256rd0.5-wd0-lr0.001.txt\n\npython plot_loss.py log_g_01v234_40r-2-40r-2-40r-2-40r-4-256rd0.5-256rd0.5-wd0-lr0.001.txt</code></pre></figure>\n\n<p>The script allows to print multiple logs on the same image and uses <code class=\"highlighter-rouge\">moving average</code> to make the graph look smoother. It correctly aligns the graphs even if the log does not start from the first iteration (in case the training is resumed from a Caffe snapshot). For example, in the plot below <code class=\"highlighter-rouge\">train 1</code> and <code class=\"highlighter-rouge\">val 1</code> correspond to the model described in the previous section with <code class=\"highlighter-rouge\">weight decay=0</code>; <code class=\"highlighter-rouge\">train 2</code> and <code class=\"highlighter-rouge\">val 2</code> correspond to the model which started from the 48000th iteration of the previous model but used <code class=\"highlighter-rouge\">weight decay=0.0015</code>. The best kappa score was obtained on 81000th iteration of the second model. Then we observe overfitting.</p>\n\n<p><img src=\"/public/2015-08-17/log_g_01v234_40r-2-40r-2-40r-2-40r-4-256rd0.5-256rd0.5-wd0-lr0.001.txt.png\" alt=\"Training and validation losses for our best model\" title=\"Training and validation losses for our best model\" /></p>\n\n<p>Note that the validation loss is usually lower than the training loss. The reason is that the classes are equal in the training set and are far from being equal in the validation set. So the training and validation losses cannot be compared.</p>\n\n<h2 id=\"preparing-submissions\">Preparing submissions</h2>\n<p>After training the models we used a <a href=\"https://github.com/YerevaNN/Caffe-python-tools/blob/master/predict_regression.py\">Python script</a> to make predictions for the images in validation set. It creates a CSV file with neuron activations. Then we imported this CSV into Wolfram Mathematica and played with it there.</p>\n\n<p>I use Mathematica mainly because of its nice visualizations. Here is one of them: the <code class=\"highlighter-rouge\">x</code> axis is the activation of the single neuron of the last layer, and the graphs present the percentages of the images of each particular label that have <code class=\"highlighter-rouge\">x</code> activation. Ideally the graphs corresponding to different labels should be clearly separable by vertical lines. Unfortunately that’s not the case, which visually explains why the kappa score is so low.</p>\n\n<p><img src=\"/public/2015-08-17/best-model-graphs.png\" alt=\"Percentage of images per given neuron activation\" title=\"Percentage of images per given neuron activation\" /></p>\n\n<p>In order to convert the neuron activations to predicted levels we need to determine 4 “threshold” numbers. These graphs show that it’s not obvious how to choose these 4 numbers in order to maximize the kappa score. So we take, say, 1000 random 4-tuples of numbers between minimum and maximum activations of the neuron, and calculate the kappa score for each of the tuples. Then we take the 4-tuple for which the kappa was maximal, and use these numbers as thresholds for the images in the test set.</p>\n\n<p>Note that we calculate the kappa scores for the validation set, although there is a risk to overfit the validation set. Ideally we should choose those thresholds which attain maximum kappa score on the train set. But, in practice, the thresholds that maximize the kappa score on validation set perform better on the test set, mainly because the network has already overfit the training set!</p>\n\n<h2 id=\"attempts-to-ensemble\">Attempts to ensemble</h2>\n<p>Usually it is possible to improve the scores by merging several models. This is called <a href=\"https://en.wikipedia.org/wiki/Ensemble_learning\">ensembling</a>. For example, the 3rd place winners of this contest have merged the results of 9 convolutional networks.</p>\n\n<p>We developed couple of ways to merge the results from two networks, but they didn’t work well for us. They gave very small improvements (less than 0.01) only when both networks gave similar kappa scores. When one network was clearly stronger than the other one, the ensemble didn’t help at all. One of our ensemble methods was an extension of the “thresholding” method described in the previous section to 2 dimensions. We plot the images on a 2D plane in a way that each of the coordinates corresponds to a neuron activation of one model. Then we looked for random lines that split the plane in a way that maximizes the kappa score. We tried two methods of splitting the plane which are demonstrated below. Each blue dot corresponds to an image of label 0, orange dots correspond of images having label 4.</p>\n\n<table>\n  <tbody>\n    <tr>\n      <td><img src=\"/public/2015-08-17/model-merge-diagonals.png\" alt=\"Ensemble of two networks, threshold lines are diagonal\" title=\"Ensemble of two networks, threshold lines are diagonal\" /></td>\n      <td><img src=\"/public/2015-08-17/model-merge-lines.png\" alt=\"Ensemble of two networks, threshold curves are perpendicular lines\" title=\"Ensemble of two networks, threshold curves are perpendicular lines\" /></td>\n    </tr>\n  </tbody>\n</table>\n\n<p>We didn’t try to merge more than 2 networks at once. Probably this was another mistake.</p>\n\n<p>The only method of ensembling that worked for us was to take an average over 4 rotated / flipped versions of the images. We also tried to take minimum, maximum and harmonic mean of the neuron activations. Minimum and maximum brought 0.01 improvement to the kappa score, while harmonic and arithmetic means brought 0.02 improvement. The best result we achieved used the arithmetic mean. Note that this required to have 4 versions of test images (which took 2 days to rotate / flip) and to run the network on all versions (which took another day).</p>\n\n<p>All these experiments can be replicated in Mathematica by using the script <code class=\"highlighter-rouge\">main.nb</code> and the required CSV files that are <a href=\"https://github.com/YerevaNN/Kaggle-diabetic-retinopathy-detection/tree/master/mathematica\">available on Github</a>.</p>\n\n<p>Finally, note that Mathematica is the only non-free software used in the whole training process. We believe it is better to keep the ecosystem clean :) We will probably use <a href=\"http://ipython.org/\">IPython</a> next time.</p>\n\n<h2 id=\"more-on-this-contest\">More on this contest</h2>\n<p>Many contestants have published their solutions. Here are the ones I could find. Please, let me know if I missed something. Most of the solution are heavily influenced by the winner method of the plankton classification contest.</p>\n\n<ul>\n  <li>1st place: <a href=\"https://www.kaggle.com/c/diabetic-retinopathy-detection/forums/t/15801/competition-report-min-pooling-and-thank-you\">Min-Pooling</a> used OpenCV to preprocess the images, augmented the dataset by scaling, skewing and rotating (and notably not by changing colors), trained several networks on his own <a href=\"https://github.com/btgraham/SparseConvNet\">SparseConvNet</a> library and used random forests to combine predictions from two eyes of the same person. Kappa = 0.84958</li>\n  <li>2nd place: <a href=\"https://www.kaggle.com/c/diabetic-retinopathy-detection/forums/t/15807/team-o-o-competition-report-and-code\">o_O team</a> used Theano, Lasagne, nolearn to train OxfordNet-like network on minimal preprocessed images. They have heavily augmented the dataset. They note the importance of using larger images to achieve high scores. Kappa = 0.84479</li>\n  <li>3rd place: <a href=\"https://www.kaggle.com/c/diabetic-retinopathy-detection/forums/t/15845/3rd-place-solution-report\">Reformed Gamblers team</a> combined results of 9 convolutional networks (OxfordNet-like and others) with leaky ReLU activations and non-trivial loss functions. They used Torch on multiple GPUs. Kappa = 0.83937</li>\n  <li><strong>Update:</strong> 4th place: Julian and Daniel <a href=\"http://blog.kaggle.com/2015/08/14/diabetic-retinopathy-winners-interview-4th-place-julian-daniel/\">gave an interview</a> to Kaggle. They did extensive preprocessing and data augmentation, used CXXNet, PyLearn and Keras to train multiple OxfordNet-like networks. They highlight the importance of good parameter initialization.</li>\n  <li>5th place: <a href=\"http://jeffreydf.github.io/diabetic-retinopathy-detection/\">Jeffrey De Fauw</a> used Theano to train OxfordNet-like network with leaky ReLU activations on significantly augmented dataset. He has also implemented a smooth approximation of kappa metric and used it as a loss layer. Well written blog post. Kappa = 0.82899</li>\n  <li>20th place: <a href=\"http://ilyakava.tumblr.com/post/125230881527/my-1st-kaggle-convnet-getting-to-3rd-percentile\">Ilya Kavalerov</a>, again Theano, OxfordNet, good augmentation, non-obvious loss function. Interesting read. Kappa = 0.76523</li>\n  <li>46th place: <a href=\"https://nikogamulin.github.io/2015/07/31/Diabetic-retinopathy-detection-with-convolutional-neural-network.html\">Niko Gamulin</a> used Caffe on GTX 980 GPU (just like us) but OxfordNet architecture. Kappa = 0.63129</li>\n</ul>\n\n<p>After the contest we tried to use leaky ReLUs, something we just didn’t think of during the contest. The results are not promising. Here are the plots of the validation losses with negative slope values (<code class=\"highlighter-rouge\">ns</code>) 0, 0.01, 0.33 and 0.5 respectively:</p>\n\n<p><img src=\"/public/2015-08-17/leaky-ReLU.png\" alt=\"Validation losses using leaky ReLU activations\" title=\"Validation losses using leaky ReLU activations\" /></p>\n\n<p>Finally, Hrayr suggested to use different learning rates for different convolutional layers (Caffe supports this by specifying multiplication constants per layer). He used larger coefficients (12) for the first layers than for the top layers. The full prototxt file is on <a href=\"https://github.com/YerevaNN/Kaggle-diabetic-retinopathy-detection/blob/master/g_01v234_32r-2-64r-2-64r-2-128r-2-128r-2-256r-2-512rd0.5-256rd0.5_manual_learning_rates.prototxt\">Github</a>. This network allowed to get up to 0.52 kappa score on the local validation set. We didn’t try to run it on test images, although in almost all cases our scores on private leaderboard were higher than the scores on local validation sets.</p>\n\n<h2 id=\"acknowledgements\">Acknowledgements</h2>\n<p>We would like to express gratitude to Hugo Larochelle for his excellent video course on neural networks. After watching the videos we could easily understand almost all the terms in Caffe documentation.</p>\n\n<p>We would like to thank the organizers of the contest for a great competition and the contestants for helpful discussions in forums and published solutions. We learned a lot from this contest.</p>"
}