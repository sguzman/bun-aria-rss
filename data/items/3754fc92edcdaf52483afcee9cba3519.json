{
  "title": "Dictionaries v. Objects",
  "link": "",
  "updated": "2013-09-02T00:00:00+00:00",
  "id": "https://mrocklin.github.io/blog/work/2013/09/02/Shared-Abstractions",
  "content": "<p>Shannon Behrens recently published a <a href=\"http://jjinux.blogspot.com/2013/08/python-dicts-vs-classes.html\">brief post</a> on the use of dictionaries and objects to store named data.  He raised the following question:</p>\n\n<p><em>At what point do we transition from core data representations like <code class=\"language-plaintext highlighter-rouge\">dicts</code> to custom data representations with custom classes?</em></p>\n\n<p>Choices in data representation interest me quite a bit.  I think that the mechanisms we choose to store and share data strongly impact the longevity of the code that we write.</p>\n\n<p>Let’s borrow Shannon’s book example to compare two common options of data representation</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"s\">\" Book object \"</span>                                 <span class=\"s\">\" Plain Dictionary \"</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">Book</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">authors</span><span class=\"p\">,</span> <span class=\"n\">title</span><span class=\"p\">,</span> <span class=\"n\">isbn</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">authors</span> <span class=\"o\">=</span> <span class=\"n\">authors</span>\n        <span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">title</span> <span class=\"o\">=</span> <span class=\"n\">title</span>\n        <span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">isbn</span> <span class=\"o\">=</span> <span class=\"n\">isbn</span>\n                                                <span class=\"n\">book</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n<span class=\"n\">book</span> <span class=\"o\">=</span> <span class=\"n\">Book</span><span class=\"p\">([</span><span class=\"s\">\"Neil Gaiman\"</span><span class=\"p\">],</span>                        <span class=\"s\">\"authors\"</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"s\">\"Neil Gaiman\"</span><span class=\"p\">],</span>\n            <span class=\"s\">\"American Gods\"</span><span class=\"p\">,</span>                        <span class=\"s\">\"title\"</span><span class=\"p\">:</span> <span class=\"s\">\"American Gods\"</span><span class=\"p\">,</span>\n            <span class=\"s\">\"9780062113450\"</span><span class=\"p\">)</span>                        <span class=\"s\">\"isbn\"</span><span class=\"p\">:</span> <span class=\"s\">\"9780062113450\"</span>\n                                                <span class=\"p\">}</span>\n<span class=\"p\">}</span></code></pre>\n</figure>\n\n<p>Shannon advocates that you should “Keep it Simple” (right) for simple data structures but that, once things become more complex, you should transition to an object (left).</p>\n\n<p>I think that most Python programmers would agree with this sentiment.  It’s unclear (and thus interesting) exactly when this transition occurs though.  Personally I use core data structures (like <code class=\"language-plaintext highlighter-rouge\">dict</code>) to represent almost all of my data.  I create new classes very rarely.  I follow this practice because I believe in the principle of shared abstractions.  I’ll explain what I mean in a moment.</p>\n\n<h3 id=\"advantages-of-objects\">Advantages of Objects</h3>\n\n<p>To start, lets state some of the virtues of objects (this is a very incomplete list.)</p>\n\n<ul>\n  <li>\n    <p>Historically they’re just more commonly used for complex data.  It’s important to maintain coding standards that existing programmers find comfortable.</p>\n  </li>\n  <li>\n    <p>The attribute syntax is a lot nicer.  Compare the following syntax to access an attribute:</p>\n\n    <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>book[\"authors\"]      # 11 characters to get attribute, 4 of them awkward to type\nbook.authors         #  8 characters to get attribute, all of them common\n</code></pre></div>    </div>\n  </li>\n  <li>\n    <p>We can add functionality/methods to the objects in a controlled namespace.  For example</p>\n\n    <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>book.open()         .open clearly belongs to book\nopen(book)          open conflicts with standard Python function to open a file The attribute syntax note is convenient but not a game-changer.  The ability to associate a set of functions with the object (and reuse these functions on inherited classes) is really where objects shine.  To emulate this behavior with core data structures you need to respect namespaces\n</code></pre></div>    </div>\n\n    <p>import bookpy\nbookpy.open(book)</p>\n  </li>\n</ul>\n\n<p>And culturally many of us (myself included) are pretty bad at this.</p>\n\n<h3 id=\"advantages-of-dicts\">Advantages of Dicts</h3>\n\n<p>There are some small advantages to using dicts like the following</p>\n\n<ul>\n  <li>Literal syntax, we can jump right in and write down dicts without setting up a class first.</li>\n  <li>Efficient implementation (dicts are <em>really</em> fast)</li>\n</ul>\n\n<p>But, like the object attribute syntax these are merely convenient.</p>\n\n<p>The major reason to prefer core data structures is that they are an abstraction shared among all Python programmers.  As a result you can depend on standard code to <em>just work</em> on your data.</p>\n\n<p>For example we can serialize our data into JSON if, for example, we wanted to serialize it and send it over the internet.</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">json</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">book</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n<span class=\"p\">...</span>     <span class=\"s\">\"authors\"</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"s\">\"Neil Gaiman\"</span><span class=\"p\">],</span>\n<span class=\"p\">...</span>     <span class=\"s\">\"title\"</span><span class=\"p\">:</span> <span class=\"s\">\"American Gods\"</span><span class=\"p\">,</span>\n<span class=\"p\">...</span>     <span class=\"s\">\"isbn\"</span><span class=\"p\">:</span> <span class=\"s\">\"9780062113450\"</span>\n<span class=\"p\">...</span> <span class=\"p\">}</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">json</span><span class=\"p\">.</span><span class=\"n\">dumps</span><span class=\"p\">(</span><span class=\"n\">book</span><span class=\"p\">)</span>\n<span class=\"s\">'{\"title\": \"American Gods\", \"isbn\": \"9780062113450\", \"authors\": [\"Neil Gaiman\"]}'</span></code></pre>\n</figure>\n\n<p>The <code class=\"language-plaintext highlighter-rouge\">json</code> library fails to transform our <code class=\"language-plaintext highlighter-rouge\">book</code> object however.</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">json</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">book</span> <span class=\"o\">=</span> <span class=\"n\">Book</span><span class=\"p\">([</span><span class=\"s\">\"Neil Gaiman\"</span><span class=\"p\">],</span> <span class=\"s\">\"American Gods\"</span><span class=\"p\">,</span> <span class=\"s\">\"9780062113450\"</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">json</span><span class=\"p\">.</span><span class=\"n\">dumps</span><span class=\"p\">(</span><span class=\"n\">book</span><span class=\"p\">)</span>\n<span class=\"nb\">TypeError</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">__main__</span><span class=\"p\">.</span><span class=\"n\">Book</span> <span class=\"nb\">object</span> <span class=\"n\">at</span> <span class=\"mh\">0x10e4410</span><span class=\"o\">&gt;</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"n\">JSON</span> <span class=\"n\">serializable</span></code></pre>\n</figure>\n\n<p>This is to be expected.  The <code class=\"language-plaintext highlighter-rouge\">json</code> library developers have not seen our Book class.  No one has but us.</p>\n\n<p>While we may not think we need <code class=\"language-plaintext highlighter-rouge\">json</code> encoding it’s likely that if our project succeeds then someone will want to send our objects over the internet.  The decision to make a custom class shuts our project off from the rest of the development ecosystem.</p>\n\n<p>Custom classes inhibit interoperation with other libraries.  This limits growth out to unanticipated applications.  This is particularly tragic because our field thrives on connecting isolated components.  Shared abstractions serve as the connection links, like the regular bumps and divots in LEGO pieces.  Shared abstractions allow us to connect cool modules to create novel cool projects with ease.  Otherwise we’re stuck hacking together missing technology (like a <code class=\"language-plaintext highlighter-rouge\">Book.write_json</code> method) when perfectly adequate solutions (like <code class=\"language-plaintext highlighter-rouge\">json.dumps</code>) already exist.</p>\n\n<p>This example isn’t restricted to JSON encoding, in general we’re going to have to hack something together every time we want the Book objects to interact with foreign code.  This problem compounds as we begin to rely on more and more external projects.</p>\n\n<h3 id=\"custom-shared-abstractions\">Custom Shared Abstractions</h3>\n\n<p>Sometimes building custom classes is worth it.  This is certainly the case when you have a large developer base that can all agree on exactly the interface they want to use.  LEGO piece bumps aren’t the right fit for everyone.  If you have a large community you can establish other cool interfaces (like Lincoln Logs or Tinker Toys) but only if you have sufficient market power to do so.  No one buys the off-brand LEGOs that don’t quite fit.</p>\n\n<p>The <code class=\"language-plaintext highlighter-rouge\">numpy.ndarray</code> object is a perfect example of a custom class that has become a shared abstraction for the entire scientific computing ecosystem.  Object orientation provided convenient syntax and intelligent method handling of <code class=\"language-plaintext highlighter-rouge\">numpy.ndarrays</code> and <code class=\"language-plaintext highlighter-rouge\">numpy.matrix</code>.  I think that these features were key to this module’s wide adoption/success and a clear win for the object oriented crowd.</p>\n\n<p>In short, I think that new classes are really awesome but only in really rare cases.  They should be used sparingly.  If you’re developing for the Librarian Developers of the World then by all means, make an awesome, fully featured book class; otherwise try sticking with core data structures.  You’ll be happy later on as you leverage standard libraries for unanticipated applications.</p>\n\n<h3 id=\"best-of-both-worlds-or-fancy-solutions\">Best of Both Worlds (or, Fancy Solutions)</h3>\n\n<p>You can implement shared abstractions on top of custom classes.  For example you can implement the <code class=\"language-plaintext highlighter-rouge\">iterable</code> abstraction by implementing an <code class=\"language-plaintext highlighter-rouge\">__iter__</code> method on your class, allowing other foreign modules to leverage your custom data type without any trouble.  The <code class=\"language-plaintext highlighter-rouge\">namedtuple</code> function in <code class=\"language-plaintext highlighter-rouge\">collections</code> might be a good fit for the <code class=\"language-plaintext highlighter-rouge\">book</code> application above.</p>\n\n<p>Also, it’s worth noting that JavaScript handles this problem in a curious way.  Objects and dictionaries are equivalent.  It’s an interesting direction and something I suspect we could hack together in Python as well.</p>\n\n<p>Finally, most objects in Python actually <em>are</em> just dictionaries.  You can always operate on the <code class=\"language-plaintext highlighter-rouge\">object.__dict__</code> attribute.</p>"
}