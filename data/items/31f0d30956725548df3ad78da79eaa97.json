{
  "title": "What happens when you press a key in your terminal?",
  "link": "",
  "updated": "2022-07-20T20:57:15+00:00",
  "id": "https://jvns.ca/blog/2022/07/20/pseudoterminals/",
  "content": "\n\n<p>I&rsquo;ve been confused about what&rsquo;s going on with terminals for a long time.</p>\n\n<p>But this past week I was using <a href=\"https://xtermjs.org/\">xterm.js</a> to display an\ninteractive terminal in a browser and I finally thought to ask a pretty basic\nquestion: when you press a key on your keyboard in a terminal (like <code>Delete</code>, or <code>Escape</code>, or <code>a</code>), which\nbytes get sent?</p>\n\n<p>As usual we&rsquo;ll answer that question by doing some experiments and seeing what happens :)</p>\n\n<h3 id=\"remote-terminals-are-very-old-technology\">remote terminals are very old technology</h3>\n\n<p>First, I want to say that displaying a terminal in the browser with <code>xterm.js</code>\nmight seem like a New Thing, but it&rsquo;s really not. In the 70s, computers were\nexpensive. So many employees at an institution would share a single computer,\nand each person could have their own &ldquo;terminal&rdquo; to that computer.</p>\n\n<p>For example, here&rsquo;s a photo of a VT100 terminal from the 70s or 80s. This looks like\nit could be a computer (it&rsquo;s kind of big!), but it&rsquo;s not &ndash; it just displays\nwhatever information the actual computer sends it.</p>\n\n<p><a title=\"Jason Scott, CC BY 2.0 <https://creativecommons.org/licenses/by/2.0>, via Wikimedia Commons\" href=\"https://commons.wikimedia.org/wiki/File:DEC_VT100_terminal.jpg\"><img width=\"512\" alt=\"DEC VT100 terminal\" src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/9/99/DEC_VT100_terminal.jpg/512px-DEC_VT100_terminal.jpg\"></a></p>\n\n<p>Of course, in the 70s they didn&rsquo;t use websockets for this, but the information\nbeing sent back and forth is more or less the same as it was then.</p>\n\n<p><small>\n(the terminal in that photo is from the <a href=\"https://livingcomputers.org/\">Living Computer Museum</a> in Seattle which I got to visit once and write FizzBuzz in <code>ed</code> on a very old Unix system, so it&rsquo;s possible that I&rsquo;ve actually used that machine or one of its siblings! I really hope the Living Computer Museum opens again, it&rsquo;s very cool to get to play with old computers.)\n</small></p>\n\n<h3 id=\"what-information-gets-sent\">what information gets sent?</h3>\n\n<p>It&rsquo;s obvious that if you want to connect to a remote computer (with <code>ssh</code> or\nusing <code>xterm.js</code> and a websocket, or anything else), then some information\nneeds to be sent between the client and the server.</p>\n\n<p>Specifically:</p>\n\n<ul>\n<li>the <strong>client</strong> needs to send the keystrokes that the user typed in (like <code>ls -l</code>)</li>\n<li>the <strong>server</strong> needs to tell the client what to display on the screen</li>\n</ul>\n\n<p>Let&rsquo;s look at a real program that&rsquo;s running a remote terminal in a browser and see what information gets sent back and forth!</p>\n\n<h3 id=\"we-ll-use-goterm-to-experiment\">we&rsquo;ll use <code>goterm</code> to experiment</h3>\n\n<p>I found this tiny program on GitHub called\n<a href=\"https://github.com/freman/goterm\">goterm</a> that runs a Go server that lets you\ninteract with a terminal in the browser using <code>xterm.js</code>. This program is very insecure but it&rsquo;s simple and great for learning.</p>\n\n<p>I <a href=\"https://github.com/jvns/goterm\">forked it</a> to make it work with the latest xterm.js,\nsince it was last updated 6 years ago. Then I added some logging statements to\nprint out every time bytes are sent/received over the websocket.</p>\n\n<p>Let&rsquo;s look at sent and received during a few different terminal interactions!</p>\n\n<h3 id=\"example-ls\">example: <code>ls</code></h3>\n\n<p>First, let&rsquo;s run <code>ls</code>. Here&rsquo;s what I see on the <code>xterm.js</code> terminal:</p>\n\n<pre><code>bork@kiwi:/play$ ls\nfile\nbork@kiwi:/play$\n</code></pre>\n\n<p>and here&rsquo;s what gets sent and received: (in my code, I log <code>sent: [bytes]</code> every time the client sends bytes and <code>recv: [bytes]</code> every time it receives bytes from the server)</p>\n\n<pre><code>sent: \"l\"\nrecv: \"l\"\nsent: \"s\"\nrecv: \"s\"\nsent: \"\\r\"\nrecv: \"\\r\\n\\x1b[?2004l\\r\"\nrecv: \"file\\r\\n\"\nrecv: \"\\x1b[?2004hbork@kiwi:/play$ \"\n</code></pre>\n\n<p>I noticed 3 things in this output:</p>\n\n<ol>\n<li>Echoing: The client sends <code>l</code> and then immediately receives an <code>l</code> sent\nback. I guess the idea here is that the client is really dumb &ndash; it doesn&rsquo;t\nknow that when I type an <code>l</code>, I want an <code>l</code> to be echoed back to the screen.\nIt has to be told explicitly by the server process to display it.</li>\n<li>The newline: when I press enter, it sends a <code>\\r</code> (carriage return) symbol and not a <code>\\n</code> (newline)</li>\n<li>Escape sequences: <code>\\x1b</code> is the ASCII escape character, so <code>\\x1b[?2004h</code> is\ntelling the terminal to display something or other. I think this is a colour\nsequence but I&rsquo;m not sure. We&rsquo;ll talk a little more about escape sequences later.</li>\n</ol>\n\n<p>Okay, now let&rsquo;s do something slightly more complicated.</p>\n\n<h3 id=\"example-ctrl-c\">example: <code>Ctrl+C</code></h3>\n\n<p>Next, let&rsquo;s see what happens when we interrupt a process with <code>Ctrl+C</code>. Here&rsquo;s what I see in my terminal:</p>\n\n<pre><code>bork@kiwi:/play$ cat\n^C\nbork@kiwi:/play$\n</code></pre>\n\n<p>And here&rsquo;s what the client sends and receives.</p>\n\n<pre><code>sent: \"c\"\nrecv: \"c\"\nsent: \"a\"\nrecv: \"a\"\nsent: \"t\"\nrecv: \"t\"\nsent: \"\\r\"\nrecv: \"\\r\\n\\x1b[?2004l\\r\"\nsent: \"\\x03\"\nrecv: \"^C\"\nrecv: \"\\r\\n\"\nrecv: \"\\x1b[?2004h\"\nrecv: \"bork@kiwi:/play$ \"\n</code></pre>\n\n<p>When I press <code>Ctrl+C</code>, the client sends <code>\\x03</code>. If I look up an ASCII table,\n<code>\\x03</code> is &ldquo;End of Text&rdquo;, which seems reasonable. I thought this was really cool\nbecause I&rsquo;ve always been a bit confused about how Ctrl+C works &ndash; it&rsquo;s good to\nknow that it&rsquo;s just sending an <code>\\x03</code> character.</p>\n\n<p>I believe the reason <code>cat</code> gets interrupted when we press <code>Ctrl+C</code> is that the\nLinux kernel on the server side receives this <code>\\x03</code> character, recognizes that\nit means &ldquo;interrupt&rdquo;, and then sends a <code>SIGINT</code> to the process that owns the\npseudoterminal&rsquo;s process group. So it&rsquo;s handled in the kernel and not in\nuserspace.</p>\n\n<h3 id=\"example-ctrl-d\">example: <code>Ctrl+D</code></h3>\n\n<p>Let&rsquo;s try the exact same thing, except with <code>Ctrl+D</code>. Here&rsquo;s what I see in my terminal:</p>\n\n<pre><code>bork@kiwi:/play$ cat\nbork@kiwi:/play$\n</code></pre>\n\n<p>And here&rsquo;s what gets sent and received:</p>\n\n<pre><code>sent: \"c\"\nrecv: \"c\"\nsent: \"a\"\nrecv: \"a\"\nsent: \"t\"\nrecv: \"t\"\nsent: \"\\r\"\nrecv: \"\\r\\n\\x1b[?2004l\\r\"\nsent: \"\\x04\"\nrecv: \"\\x1b[?2004h\"\nrecv: \"bork@kiwi:/play$ \"\n</code></pre>\n\n<p>It&rsquo;s very similar to <code>Ctrl+C</code>, except that <code>\\x04</code> gets sent instead of <code>\\x03</code>.\nCool! <code>\\x04</code> corresponds to ASCII &ldquo;End of Transmission&rdquo;.</p>\n\n<h3 id=\"what-about-ctrl-another-letter\">what about Ctrl + another letter?</h3>\n\n<p>Next I got curious about &ndash; if I send <code>Ctrl+e</code>, what byte gets sent?</p>\n\n<p>It turns out that it&rsquo;s literally just the number of that letter in the alphabet, like this:</p>\n\n<ul>\n<li><code>Ctrl+a</code> => 1</li>\n<li><code>Ctrl+b</code> => 2</li>\n<li><code>Ctrl+c</code> => 3</li>\n<li><code>Ctrl+d</code> => 4</li>\n<li>&hellip;</li>\n<li><code>Ctrl+z</code> => 26</li>\n</ul>\n\n<p>Also, <code>Ctrl+Shift+b</code> does the exact same thing as <code>Ctrl+b</code> (it writes <code>0x2</code>).</p>\n\n<p>What about other keys on the keyboard? Here&rsquo;s what they map to:</p>\n\n<ul>\n<li>Tab -> 0x9 (same as Ctrl+I, since I is the 9th letter)</li>\n<li>Escape -> <code>\\x1b</code><br /></li>\n<li>Backspace -> <code>\\x7f</code></li>\n<li>Home -> <code>\\x1b[H</code></li>\n<li>End: <code>\\x1b[F</code></li>\n<li>Print Screen: <code>\\x1b\\x5b\\x31\\x3b\\x35\\x41</code></li>\n<li>Insert: <code>\\x1b\\x5b\\x32\\x7e</code></li>\n<li>Delete -> <code>\\x1b\\x5b\\x33\\x7e</code></li>\n<li>My <code>Meta</code> key does nothing at all</li>\n</ul>\n\n<p>What about Alt? From my experimenting (and some Googling), it seems like <code>Alt</code>\nis literally the same as &ldquo;Escape&rdquo;, except that pressing <code>Alt</code> by itself doesn&rsquo;t\nsend any characters to the terminal and pressing <code>Escape</code> by itself does. So:</p>\n\n<ul>\n<li>alt + d => <code>\\x1bd</code> (and the same for every other letter)</li>\n<li>alt + shift + d => <code>\\x1bD</code> (and the same for every other letter)</li>\n<li>etcetera</li>\n</ul>\n\n<p>Let&rsquo;s look at one more example!</p>\n\n<h3 id=\"example-nano\">example: <code>nano</code></h3>\n\n<p>Here&rsquo;s what gets sent and received when I run the text editor <code>nano</code>:</p>\n\n<pre><code>recv: \"\\r\\x1b[Kbork@kiwi:/play$ \"\nsent: \"n\" [[]byte{0x6e}]\nrecv: \"n\"\nsent: \"a\" [[]byte{0x61}]\nrecv: \"a\"\nsent: \"n\" [[]byte{0x6e}]\nrecv: \"n\"\nsent: \"o\" [[]byte{0x6f}]\nrecv: \"o\"\nsent: \"\\r\" [[]byte{0xd}]\nrecv: \"\\r\\n\\x1b[?2004l\\r\"\nrecv: \"\\x1b[?2004h\"\nrecv: \"\\x1b[?1049h\\x1b[22;0;0t\\x1b[1;16r\\x1b(B\\x1b[m\\x1b[4l\\x1b[?7h\\x1b[39;49m\\x1b[?1h\\x1b=\\x1b[?1h\\x1b=\\x1b[?25l\"\nrecv: \"\\x1b[39;49m\\x1b(B\\x1b[m\\x1b[H\\x1b[2J\"\nrecv: \"\\x1b(B\\x1b[0;7m  GNU nano 6.2 \\x1b[44bNew Buffer \\x1b[53b \\x1b[1;123H\\x1b(B\\x1b[m\\x1b[14;38H\\x1b(B\\x1b[0;7m[ Welcome to nano.  For basic help, type Ctrl+G. ]\\x1b(B\\x1b[m\\r\\x1b[15d\\x1b(B\\x1b[0;7m^G\\x1b(B\\x1b[m Help\\x1b[15;16H\\x1b(B\\x1b[0;7m^O\\x1b(B\\x1b[m Write Out   \\x1b(B\\x1b[0;7m^W\\x1b(B\\x1b[m Where Is    \\x1b(B\\x1b[0;7m^K\\x1b(B\\x1b[m Cut\\x1b[15;61H\"\n</code></pre>\n\n<p>You can see some text from the UI in there like &ldquo;GNU nano 6.2&rdquo;, and these\n<code>\\x1b[27m</code> things are escape sequences. Let&rsquo;s talk about escape sequences a bit!</p>\n\n<h3 id=\"ansi-escape-sequences\">ANSI escape sequences</h3>\n\n<p>These <code>\\x1b[</code> things above that <code>nano</code> is sending the client are called &ldquo;escape sequences&rdquo; or &ldquo;escape codes&rdquo;.\nThis is because they all start with <code>\\x1b</code>, the &ldquo;escape&rdquo; character. .  They change the\ncursor&rsquo;s position, make text bold or underlined, change colours, etc. <a href=\"https://en.wikipedia.org/wiki/ANSI_escape_code\">Wikipedia has some history</a> if you&rsquo;re interested.</p>\n\n<p>As a simple example: if you run</p>\n\n<pre><code>echo -e '\\e[0;31mhi\\e[0m there'\n</code></pre>\n\n<p>in your terminal, it&rsquo;ll print out &ldquo;hi there&rdquo; where &ldquo;hi&rdquo; is in red and &ldquo;there&rdquo;\nis in black. <a href=\"https://misc.flogisoft.com/bash/tip_colors_and_formatting\">This page</a> has some nice\nexamples of escape codes for colors and formatting.</p>\n\n<p>I think there are a few different standards for escape codes, but my\nunderstanding is that the most common set of escape codes that people use on\nUnix come from the VT100 (that old terminal in the picture at the top of the\nblog post), and hasn&rsquo;t really changed much in the last 40 years.</p>\n\n<p>Escape codes are why your terminal can get messed up if you <code>cat</code> a bunch of binary to\nyour screen &ndash; usually you&rsquo;ll end up accidentally printing a bunch of random\nescape codes which will mess up your terminal &ndash; there&rsquo;s bound to be a <code>0x1b</code>\nbyte in there somewhere if you <code>cat</code> enough binary to your terminal.</p>\n\n<h3 id=\"can-you-type-in-escape-sequences-manually\">can you type in escape sequences manually?</h3>\n\n<p>A few sections back, we talked about how the <code>Home</code> key maps to <code>\\x1b[H</code>. Those 3 bytes are <code>Escape + [ + H</code> (because Escape is\n<code>\\x1b</code>).</p>\n\n<p>And if I manually type Escape, then [, then H in the\n<code>xterm.js</code> terminal, I end up at the beginning of the line, exactly the same as if I&rsquo;d pressed <code>Home</code>.</p>\n\n<p>I noticed that this didn&rsquo;t work in <code>fish</code> on my computer though &ndash; if I typed\n<code>Escape</code> and then <code>[</code>, it just printed out <code>[</code> instead of letting me continue the\nescape sequence. I asked my friend Jesse who has written <a href=\"https://github.com/doy/vt100-rust\">a bunch of Rust\nterminal code</a> about this and Jesse told me\nthat a lot of programs implement a <strong>timeout</strong> for escape codes &ndash; if you don&rsquo;t\npress another key after some minimum amount of time, it&rsquo;ll decide that it&rsquo;s\nactually not an escape code anymore.</p>\n\n<p>Apparently this is configurable in fish with <code>fish_escape_delay_ms</code>, so I ran\n<code>set fish_escape_delay_ms 1000</code> and then I was able to type in escape codes by\nhand. Cool!</p>\n\n<h3 id=\"terminal-encoding-is-kind-of-weird\">terminal encoding is kind of weird</h3>\n\n<p>I want to pause here for a minute here and say that the way the keys you get\npressed get mapped to bytes is pretty weird. Like, if we were designing\nthe way keys are encoded from scratch today, we would probably not set it up so\nthat:</p>\n\n<ul>\n<li><code>Ctrl + a</code> does the exact same thing as <code>Ctrl + Shift + a</code></li>\n<li><code>Alt</code> is the same as <code>Escape</code></li>\n<li>control sequences (like colours / moving the cursor around) use the same byte\nas the <code>Escape</code> key, so that you need to rely on timing to determine if it\nwas a control sequence of the user just meant to press <code>Escape</code></li>\n</ul>\n\n<p>But all of this was designed in the 70s or 80s or something and then needed\nto stay the same forever for backwards compatibility, so that&rsquo;s what we get :)</p>\n\n<h3 id=\"changing-window-size\">changing window size</h3>\n\n<p>Not everything you can do in a terminal happens via sending bytes back and\nforth. For example, when the terminal gets resized, we have to tell Linux that the window size has\nchanged in a different way.</p>\n\n<p>Here&rsquo;s what the Go code in\n<a href=\"https://github.com/freman/goterm/blob/a644c10e180ce8af789ea3e4e4892dcf078e97e2/main.go#L110-L115\">goterm</a>\nto do that looks like:</p>\n\n<pre><code>syscall.Syscall(\n    syscall.SYS_IOCTL,\n    tty.Fd(),\n    syscall.TIOCSWINSZ,\n    uintptr(unsafe.Pointer(&resizeMessage)),\n)\n</code></pre>\n\n<p>This is using the <code>ioctl</code> system call. My understanding of <code>ioctl</code> is that it&rsquo;s\na system call for a bunch of random stuff that isn&rsquo;t covered by other system\ncalls, generally related to IO I guess.</p>\n\n<p><code>syscall.TIOCSWINSZ</code> is an integer constant which which tells <code>ioctl</code> which\nparticular thing we want it to to in this case (change the window size of a\nterminal).</p>\n\n<h3 id=\"this-is-also-how-xterm-works\">this is also how xterm works</h3>\n\n<p>In this post we&rsquo;ve been talking about remote terminals, where the client and\nthe server are on different computers. But actually if you use a terminal\nemulator like <code>xterm</code>, all of this works the exact same way, it&rsquo;s just harder\nto notice because the bytes aren&rsquo;t being sent over a network connection.</p>\n\n<h3 id=\"that-s-all-for-now\">that&rsquo;s all for now!</h3>\n\n<p>There&rsquo;s defimitely a lot more to know about terminals (we could talk more about\ncolours, or raw vs cooked mode, or unicode support, or the Linux pseudoterminal\ninterface) but I&rsquo;ll stop here because it&rsquo;s 10pm, this is getting kind of long,\nand I think my brain cannot handle more new information about terminals today.</p>\n\n<p><small>\nThanks to <a href=\"https://github.com/doy/\">Jesse Luehrs</a> for answering a billion of my questions about terminals, all the mistakes are mine :)\n</small></p>\n"
}