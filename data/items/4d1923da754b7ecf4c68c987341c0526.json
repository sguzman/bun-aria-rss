{
  "title": "Multiple Thread Pools in Rust",
  "link": "",
  "published": "2020-08-26T00:00:00+00:00",
  "updated": "2020-08-26T00:00:00+00:00",
  "id": "https://pkolaczk.github.io/multiple-threadpools-rust",
  "content": "<p>In <a href=\"/disk-parallelism/\">the previous post</a>, I showed how processing \nfile data in parallel can either boost or hurt performance \ndepending on the workload and device capabilities. Therefore, in complex programs that mix tasks\nof different types using different physical resources, e.g. CPU, storage (e.g. HDD/SSD) \nor network I/O, a need may arise to configure parallelism levels differently for each task type. \nThis is typically solved by scheduling tasks of different types on dedicated thread pools.\nIn this post I’m showing how to implement a solution in Rust with <a href=\"https://crates.io/crates/rayon\">Rayon</a>. \n<!--more--></p>\n\n<p>After I realized multi-threaded access to data on a single HDD is a <em>really bad idea</em>, \nI wanted to process files residing on HDD with only one thread-per-device, but still keep multithreading for SSDs.\nAlso, both groups of files should be processed independently, in parallel.\nHonestly, that didn’t look like something hard to do. I’ve been using thread pools in Java for years.\nFor each file to process, I just need to schedule an asynchronous hashing task on a proper thread pool \nexecutor and that’s it. How hard could that be in Rust?</p>\n\n<p>My program already used Rayon in a very functional style, so the main part of the code responsible for file hashing \nlooked like that:</p>\n\n<div class=\"language-rust highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">let</span> <span class=\"n\">files</span><span class=\"p\">:</span> <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"nn\">std</span><span class=\"p\">::</span><span class=\"nn\">path</span><span class=\"p\">::</span><span class=\"n\">PathBuf</span><span class=\"o\">&gt;</span> <span class=\"o\">=</span> <span class=\"o\">...</span>   <span class=\"c\">// collection of input files</span>\n<span class=\"k\">let</span> <span class=\"n\">hashes</span><span class=\"p\">:</span> <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">FileHash</span><span class=\"o\">&gt;</span> <span class=\"o\">=</span> <span class=\"n\">files</span>\n  <span class=\"nf\">.into_par_iter</span><span class=\"p\">()</span>           <span class=\"c\">// creates a Rayon parallel iterator over all files</span>\n  <span class=\"nf\">.map</span><span class=\"p\">(|</span><span class=\"n\">f</span><span class=\"p\">|</span> <span class=\"nf\">compute_hash</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">))</span>  <span class=\"c\">// reads the contents of a file and returns its hash; blocking</span>\n  <span class=\"nf\">.collect</span><span class=\"p\">();</span>                \n</code></pre></div></div>\n<p>In this approach, all the files are processed by the default Rayon thread pool and\nthere is no place to tell Rayon which thread pool to use for given file.</p>\n\n<h1 id=\"a-single-custom-thread-pool\">A Single Custom Thread Pool</h1>\n\n<p>Rayon allows to build custom thread pools with <code class=\"language-plaintext highlighter-rouge\">ThreadPoolBuilder</code> and <code class=\"language-plaintext highlighter-rouge\">ThreadPool</code> structs. \nIt is quite easy to create a custom thread pool and manually spawn tasks on it:</p>\n\n<div class=\"language-rust highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">use</span> <span class=\"nn\">std</span><span class=\"p\">::</span><span class=\"n\">thread</span><span class=\"p\">;</span>\n<span class=\"k\">let</span> <span class=\"n\">pool</span> <span class=\"o\">=</span> <span class=\"nn\">rayon</span><span class=\"p\">::</span><span class=\"nn\">ThreadPoolBuilder</span><span class=\"p\">::</span><span class=\"nf\">new</span><span class=\"p\">()</span>\n    <span class=\"nf\">.num_threads</span><span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"p\">)</span>\n    <span class=\"nf\">.build</span><span class=\"p\">()</span>\n    <span class=\"nf\">.unwrap</span><span class=\"p\">();</span>\n<span class=\"n\">pool</span><span class=\"nf\">.spawn</span><span class=\"p\">(||</span> <span class=\"nd\">println!</span><span class=\"p\">(</span><span class=\"s\">\"Task executes on thread: {:?}\"</span><span class=\"p\">,</span> <span class=\"nn\">thread</span><span class=\"p\">::</span><span class=\"nf\">current</span><span class=\"p\">()</span><span class=\"nf\">.id</span><span class=\"p\">()));</span>\n<span class=\"n\">pool</span><span class=\"nf\">.spawn</span><span class=\"p\">(||</span> <span class=\"nd\">println!</span><span class=\"p\">(</span><span class=\"s\">\"Task executes on thread: {:?}\"</span><span class=\"p\">,</span> <span class=\"nn\">thread</span><span class=\"p\">::</span><span class=\"nf\">current</span><span class=\"p\">()</span><span class=\"nf\">.id</span><span class=\"p\">()));</span>\n</code></pre></div></div>\n\n<p>In order to process our collection on this custom thread pool, we need to change the “main loop” of \na program slightly and replace the parallel iterator with a traditional loop and a channel to receive the \nresults:</p>\n\n<div class=\"language-rust highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">let</span> <span class=\"n\">pool</span> <span class=\"o\">=</span> <span class=\"nn\">rayon</span><span class=\"p\">::</span><span class=\"nn\">ThreadPoolBuilder</span><span class=\"p\">::</span><span class=\"nf\">new</span><span class=\"p\">()</span>\n    <span class=\"nf\">.num_threads</span><span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"p\">)</span>\n    <span class=\"nf\">.build</span><span class=\"p\">()</span>\n    <span class=\"nf\">.unwrap</span><span class=\"p\">();</span>\n<span class=\"k\">let</span> <span class=\"n\">files</span><span class=\"p\">:</span> <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"nn\">std</span><span class=\"p\">::</span><span class=\"nn\">path</span><span class=\"p\">::</span><span class=\"n\">PathBuf</span><span class=\"o\">&gt;</span> <span class=\"o\">=</span> <span class=\"o\">...</span>\n<span class=\"k\">let</span> <span class=\"p\">(</span><span class=\"n\">tx</span><span class=\"p\">,</span> <span class=\"n\">rx</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"nn\">std</span><span class=\"p\">::</span><span class=\"nn\">sync</span><span class=\"p\">::</span><span class=\"nn\">mpsc</span><span class=\"p\">::</span><span class=\"nf\">channel</span><span class=\"p\">();</span>\n<span class=\"k\">for</span> <span class=\"n\">f</span> <span class=\"n\">in</span> <span class=\"n\">files</span><span class=\"nf\">.into_iter</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">let</span> <span class=\"n\">tx</span> <span class=\"o\">=</span> <span class=\"n\">tx</span><span class=\"nf\">.clone</span><span class=\"p\">();</span>  \n    <span class=\"n\">pool</span><span class=\"nf\">.spawn</span><span class=\"p\">(</span><span class=\"k\">move</span> <span class=\"p\">||</span> <span class=\"p\">{</span> \n        <span class=\"n\">tx</span><span class=\"nf\">.send</span><span class=\"p\">(</span><span class=\"nf\">compute_hash</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">))</span><span class=\"nf\">.unwrap</span><span class=\"p\">();</span> \n    <span class=\"p\">});</span>\n<span class=\"p\">}</span>\n<span class=\"k\">drop</span><span class=\"p\">(</span><span class=\"n\">tx</span><span class=\"p\">);</span> <span class=\"c\">// need to close all senders, otherwise...</span>\n<span class=\"k\">let</span> <span class=\"n\">hashes</span><span class=\"p\">:</span> <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">FileHash</span><span class=\"o\">&gt;</span> <span class=\"o\">=</span> <span class=\"n\">rx</span><span class=\"nf\">.into_iter</span><span class=\"p\">()</span><span class=\"nf\">.collect</span><span class=\"p\">();</span>  <span class=\"c\">// ... this would block</span>\n</code></pre></div></div>\n\n<h1 id=\"multiple-thread-pools\">Multiple Thread Pools</h1>\n<p>Now it is quite straightforward to transform this approach to more than one thread pool:</p>\n\n<div class=\"language-rust highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">let</span> <span class=\"n\">hdd_pool</span> <span class=\"o\">=</span> <span class=\"nn\">rayon</span><span class=\"p\">::</span><span class=\"nn\">ThreadPoolBuilder</span><span class=\"p\">::</span><span class=\"nf\">new</span><span class=\"p\">()</span><span class=\"nf\">.num_threads</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"nf\">.build</span><span class=\"p\">()</span><span class=\"nf\">.unwrap</span><span class=\"p\">();</span>\n<span class=\"k\">let</span> <span class=\"n\">ssd_pool</span> <span class=\"o\">=</span> <span class=\"nn\">rayon</span><span class=\"p\">::</span><span class=\"nn\">ThreadPoolBuilder</span><span class=\"p\">::</span><span class=\"nf\">new</span><span class=\"p\">()</span><span class=\"nf\">.num_threads</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">)</span><span class=\"nf\">.build</span><span class=\"p\">()</span><span class=\"nf\">.unwrap</span><span class=\"p\">();</span> \n\n<span class=\"k\">let</span> <span class=\"n\">files</span><span class=\"p\">:</span> <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"nn\">std</span><span class=\"p\">::</span><span class=\"nn\">path</span><span class=\"p\">::</span><span class=\"n\">PathBuf</span><span class=\"o\">&gt;</span> <span class=\"o\">=</span> <span class=\"o\">...</span>\n<span class=\"k\">let</span> <span class=\"p\">(</span><span class=\"n\">tx</span><span class=\"p\">,</span> <span class=\"n\">rx</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"nn\">std</span><span class=\"p\">::</span><span class=\"nn\">sync</span><span class=\"p\">::</span><span class=\"nn\">mpsc</span><span class=\"p\">::</span><span class=\"nf\">channel</span><span class=\"p\">();</span>\n<span class=\"k\">for</span> <span class=\"n\">f</span> <span class=\"n\">in</span> <span class=\"n\">files</span><span class=\"nf\">.into_iter</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">let</span> <span class=\"n\">tx</span> <span class=\"o\">=</span> <span class=\"n\">tx</span><span class=\"nf\">.clone</span><span class=\"p\">();</span>  \n    <span class=\"k\">let</span> <span class=\"n\">pool</span> <span class=\"o\">=</span> <span class=\"k\">if</span> <span class=\"nf\">is_on_ssd</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">f</span><span class=\"p\">)</span> <span class=\"p\">{</span> \n        <span class=\"o\">&amp;</span><span class=\"n\">ssd_pool</span> \n    <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span> \n        <span class=\"o\">&amp;</span><span class=\"n\">hdd_pool</span> \n    <span class=\"p\">};</span>\n    <span class=\"n\">pool</span><span class=\"nf\">.spawn</span><span class=\"p\">(</span><span class=\"k\">move</span> <span class=\"p\">||</span> <span class=\"p\">{</span> \n        <span class=\"n\">tx</span><span class=\"nf\">.send</span><span class=\"p\">(</span><span class=\"nf\">compute_hash</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">))</span><span class=\"nf\">.unwrap</span><span class=\"p\">();</span> \n    <span class=\"p\">});</span>\n<span class=\"p\">}</span>\n<span class=\"k\">drop</span><span class=\"p\">(</span><span class=\"n\">tx</span><span class=\"p\">);</span> \n<span class=\"k\">let</span> <span class=\"n\">hashes</span><span class=\"p\">:</span> <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">FileHash</span><span class=\"o\">&gt;</span> <span class=\"o\">=</span> <span class=\"n\">rx</span><span class=\"nf\">.into_iter</span><span class=\"p\">()</span><span class=\"nf\">.collect</span><span class=\"p\">();</span> \n</code></pre></div></div>\n\n<p>The implementation of <code class=\"language-plaintext highlighter-rouge\">is_on_ssd</code> is left as an exercise for the reader ;)</p>\n\n<h1 id=\"scopes\">Scopes</h1>\n<p>Unfortunately <code class=\"language-plaintext highlighter-rouge\">ThreadPool.spawn()</code> method requires that the lambda passed to it has a \n<code class=\"language-plaintext highlighter-rouge\">'static</code> lifetime, which means it must not borrow any data other than global. \nThe examples above work only because we pass all the input data by <code class=\"language-plaintext highlighter-rouge\">move</code>, so the lambda\ndoes not close over anything outside and the <code class=\"language-plaintext highlighter-rouge\">'static</code> constraint is satisfied.</p>\n\n<p>Of course the real world is much more complex, and, in my program actually the spawned task<br />\nneeded to borrow the local context, which holds some common stuff like configuration or logger.</p>\n\n<p>Referencing any outside variable from inside of <code class=\"language-plaintext highlighter-rouge\">spawn</code> lambda does not compile:</p>\n<div class=\"language-rust highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">let</span> <span class=\"n\">logger</span><span class=\"p\">:</span> <span class=\"n\">Log</span> <span class=\"o\">=</span> <span class=\"nn\">Log</span><span class=\"p\">::</span><span class=\"nf\">new</span><span class=\"p\">();</span>\n<span class=\"k\">let</span> <span class=\"n\">logger</span> <span class=\"o\">=</span> <span class=\"o\">&amp;</span><span class=\"n\">logger</span><span class=\"p\">;</span>\n<span class=\"k\">for</span> <span class=\"n\">f</span> <span class=\"n\">in</span> <span class=\"n\">files</span><span class=\"nf\">.into_iter</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">let</span> <span class=\"n\">tx</span> <span class=\"o\">=</span> <span class=\"n\">tx</span><span class=\"nf\">.clone</span><span class=\"p\">();</span>\n    <span class=\"n\">pool</span><span class=\"nf\">.spawn</span><span class=\"p\">(</span><span class=\"k\">move</span> <span class=\"p\">||</span> <span class=\"p\">{</span>\n        <span class=\"n\">logger</span><span class=\"nf\">.println</span><span class=\"p\">(</span><span class=\"nd\">format!</span><span class=\"p\">(</span><span class=\"s\">\"Computing hash of: {}\"</span><span class=\"p\">,</span> <span class=\"n\">f</span><span class=\"nf\">.display</span><span class=\"p\">()));</span>\n        <span class=\"n\">tx</span><span class=\"nf\">.send</span><span class=\"p\">(</span><span class=\"nf\">compute_hash</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">))</span><span class=\"nf\">.unwrap</span><span class=\"p\">();</span>\n    <span class=\"p\">});</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<pre>\nerror[E0597]: `logger` does not live long enough\n  --&gt; src/pools.rs:13:18\n   |\n13 |       let logger = &logger;\n   |                    ^^^^^^^ borrowed value does not live long enough\n...\n16 | /         pool.spawn(move || {\n17 | |             logger.println(format!(\"Computing hash of: {}\", f.display()));\n18 | |             tx.send(f).unwrap();\n19 | |         });\n   | |__________- argument requires that `logger` is borrowed for `'static`\n...\n22 |   }\n   |   - `logger` dropped here while still borrowed\n\n</pre>\n\n<p>The compiler can’t see that all the tasks we spawned must finish before we leave the scope\nwhere <code class=\"language-plaintext highlighter-rouge\">logger</code> is valid. This is where Rayon scopes are coming to rescue us.</p>\n\n<p>Instead of spawning tasks directly on the thread pool struct, we first need to create a scope \nobject by calling <code class=\"language-plaintext highlighter-rouge\">scope</code> function. The scope is guaranteed to exit only after all tasks launched \ninside it finished. This essentially allows the tasks inside the scope to access variables that live \nat least as long as the scope:</p>\n\n<div class=\"language-rust highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">let</span> <span class=\"p\">(</span><span class=\"n\">tx</span><span class=\"p\">,</span> <span class=\"n\">rx</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"nn\">std</span><span class=\"p\">::</span><span class=\"nn\">sync</span><span class=\"p\">::</span><span class=\"nn\">mpsc</span><span class=\"p\">::</span><span class=\"nf\">channel</span><span class=\"p\">();</span>\n<span class=\"k\">let</span> <span class=\"n\">logger</span><span class=\"p\">:</span> <span class=\"o\">&amp;</span><span class=\"n\">Log</span> <span class=\"o\">=</span> <span class=\"o\">...</span><span class=\"p\">;</span>\n<span class=\"n\">pool</span><span class=\"nf\">.scope</span><span class=\"p\">(</span><span class=\"k\">move</span> <span class=\"p\">|</span><span class=\"n\">s</span><span class=\"p\">|</span> <span class=\"p\">{</span>\n    <span class=\"k\">for</span> <span class=\"n\">f</span> <span class=\"n\">in</span> <span class=\"n\">files</span><span class=\"nf\">.into_iter</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n        <span class=\"k\">let</span> <span class=\"n\">tx</span> <span class=\"o\">=</span> <span class=\"n\">tx</span><span class=\"nf\">.clone</span><span class=\"p\">();</span>\n        <span class=\"n\">s</span><span class=\"nf\">.spawn</span><span class=\"p\">(</span><span class=\"k\">move</span> <span class=\"p\">|</span><span class=\"n\">s</span><span class=\"p\">|</span> <span class=\"p\">{</span>\n            <span class=\"n\">logger</span><span class=\"nf\">.println</span><span class=\"p\">(</span><span class=\"nd\">format!</span><span class=\"p\">(</span><span class=\"s\">\"Computing hash of: {}\"</span><span class=\"p\">,</span> <span class=\"n\">f</span><span class=\"nf\">.display</span><span class=\"p\">()));</span>  <span class=\"c\">// ok</span>\n            <span class=\"n\">tx</span><span class=\"nf\">.send</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">)</span><span class=\"nf\">.unwrap</span><span class=\"p\">();</span>\n        <span class=\"p\">});</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">});</span>\n</code></pre></div></div>\n\n<p>What about multiple thread pools? \nA single <code class=\"language-plaintext highlighter-rouge\">Scope</code> in Rayon is always associated with a single <code class=\"language-plaintext highlighter-rouge\">ThreadPool</code>. \nTherefore, if we need multiple thread pools, then we need multiple scopes, active at the same time.\nFortunately, scopes can be nested:</p>\n\n<div class=\"language-rust highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">let</span> <span class=\"p\">(</span><span class=\"n\">tx</span><span class=\"p\">,</span> <span class=\"n\">rx</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"nn\">std</span><span class=\"p\">::</span><span class=\"nn\">sync</span><span class=\"p\">::</span><span class=\"nn\">mpsc</span><span class=\"p\">::</span><span class=\"nf\">channel</span><span class=\"p\">();</span>\n<span class=\"k\">let</span> <span class=\"n\">logger</span><span class=\"p\">:</span> <span class=\"o\">&amp;</span><span class=\"n\">Log</span> <span class=\"o\">=</span> <span class=\"o\">...</span><span class=\"p\">;</span>\n<span class=\"n\">hdd_pool</span><span class=\"nf\">.scope</span><span class=\"p\">(</span><span class=\"k\">move</span> <span class=\"p\">|</span><span class=\"n\">hdd_scope</span><span class=\"p\">|</span> <span class=\"p\">{</span>\n    <span class=\"n\">ssd_pool</span><span class=\"nf\">.scope</span><span class=\"p\">(</span><span class=\"k\">move</span> <span class=\"p\">|</span><span class=\"n\">ssd_scope</span><span class=\"p\">|</span> <span class=\"p\">{</span>\n        <span class=\"k\">for</span> <span class=\"n\">f</span> <span class=\"n\">in</span> <span class=\"n\">files</span><span class=\"nf\">.into_iter</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n            <span class=\"k\">let</span> <span class=\"n\">tx</span> <span class=\"o\">=</span> <span class=\"n\">tx</span><span class=\"nf\">.clone</span><span class=\"p\">();</span>\n            <span class=\"k\">if</span> <span class=\"nf\">is_on_ssd</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">f</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n              <span class=\"n\">ssd_scope</span><span class=\"nf\">.spawn</span><span class=\"p\">(</span><span class=\"k\">move</span> <span class=\"p\">|</span><span class=\"n\">s</span><span class=\"p\">|</span> <span class=\"p\">{</span> <span class=\"o\">...</span> <span class=\"p\">});</span>          \n            <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span> \n              <span class=\"n\">hdd_scope</span><span class=\"nf\">.spawn</span><span class=\"p\">(</span><span class=\"k\">move</span> <span class=\"p\">|</span><span class=\"n\">s</span><span class=\"p\">|</span> <span class=\"p\">{</span> <span class=\"o\">...</span> <span class=\"p\">});</span>\n            <span class=\"p\">}</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">});</span>\n<span class=\"p\">});</span>\n</code></pre></div></div>\n\n<h2 id=\"dynamic-number-of-thread-pools\">Dynamic Number of Thread Pools</h2>\n<p>With only two pools, nesting doesn’t look bad, but in my program I needed more than two pools – \none per each physical device. And even worse, I didn’t know the number of them statically at compile time.</p>\n\n<p>At this point I wanted to abstract out the process of creating nested scopes in a way it doesn’t pollute the \nlogic of the program. I came up with the following function idea:</p>\n\n<div class=\"language-rust highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">pub</span> <span class=\"k\">fn</span> <span class=\"n\">multi_scope</span><span class=\"o\">&lt;</span><span class=\"nv\">'scope</span><span class=\"p\">,</span> <span class=\"n\">OP</span><span class=\"p\">,</span> <span class=\"n\">R</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">pools</span><span class=\"p\">:</span> <span class=\"o\">&amp;</span><span class=\"p\">[</span><span class=\"o\">&amp;</span><span class=\"n\">ThreadPool</span><span class=\"p\">],</span> <span class=\"n\">op</span><span class=\"p\">:</span> <span class=\"n\">OP</span><span class=\"p\">)</span> <span class=\"k\">-&gt;</span> <span class=\"n\">R</span>\n<span class=\"k\">where</span>\n    <span class=\"n\">OP</span><span class=\"p\">:</span> <span class=\"k\">for</span><span class=\"o\">&lt;</span><span class=\"nv\">'s</span><span class=\"o\">&gt;</span> <span class=\"nf\">FnOnce</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nv\">'s</span> <span class=\"p\">[</span><span class=\"o\">&amp;</span><span class=\"nv\">'s</span> <span class=\"n\">Scope</span><span class=\"o\">&lt;</span><span class=\"nv\">'scope</span><span class=\"o\">&gt;</span><span class=\"p\">])</span> <span class=\"k\">-&gt;</span> <span class=\"n\">R</span> <span class=\"o\">+</span> <span class=\"nv\">'scope</span> <span class=\"o\">+</span> <span class=\"nb\">Send</span><span class=\"p\">,</span>\n    <span class=\"n\">R</span><span class=\"p\">:</span> <span class=\"nb\">Send</span>\n</code></pre></div></div>\n\n<p>This takes an array of <code class=\"language-plaintext highlighter-rouge\">ThreadPool</code> references, constructs a <code class=\"language-plaintext highlighter-rouge\">Scope</code> for each <code class=\"language-plaintext highlighter-rouge\">ThreadPool</code> \nand executes a user-defined operation (typically passed as a lambda) inside all of these scopes.\nThe operation receives a list of references to <code class=\"language-plaintext highlighter-rouge\">Scope</code> so it can spawn tasks on desired <code class=\"language-plaintext highlighter-rouge\">Scope</code> associated\nwith the given <code class=\"language-plaintext highlighter-rouge\">ThreadPool</code>. The usage is quite straightforward and very similar to the built-in <code class=\"language-plaintext highlighter-rouge\">scope</code>:</p>\n\n<div class=\"language-rust highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">use</span> <span class=\"nn\">rayon</span><span class=\"p\">::</span><span class=\"n\">ThreadPoolBuilder</span><span class=\"p\">;</span>\n\n<span class=\"k\">let</span> <span class=\"n\">hdd_pool</span> <span class=\"o\">=</span> <span class=\"nn\">rayon</span><span class=\"p\">::</span><span class=\"nn\">ThreadPoolBuilder</span><span class=\"p\">::</span><span class=\"nf\">new</span><span class=\"p\">()</span><span class=\"nf\">.num_threads</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"nf\">.build</span><span class=\"p\">()</span><span class=\"nf\">.unwrap</span><span class=\"p\">();</span>\n<span class=\"k\">let</span> <span class=\"n\">ssd_pool</span> <span class=\"o\">=</span> <span class=\"nn\">rayon</span><span class=\"p\">::</span><span class=\"nn\">ThreadPoolBuilder</span><span class=\"p\">::</span><span class=\"nf\">new</span><span class=\"p\">()</span><span class=\"nf\">.num_threads</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">)</span><span class=\"nf\">.build</span><span class=\"p\">()</span><span class=\"nf\">.unwrap</span><span class=\"p\">();</span> \n<span class=\"k\">let</span> <span class=\"n\">pools</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"o\">&amp;</span><span class=\"n\">hdd_pool</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">ssd_pool</span><span class=\"p\">];</span> <span class=\"c\">// this could be constructed dynamically in real-world code</span>\n\n<span class=\"k\">let</span> <span class=\"n\">common</span> <span class=\"o\">=</span> <span class=\"nd\">vec!</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">];</span> <span class=\"c\">// common data</span>\n<span class=\"nf\">multi_scope</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">pools</span><span class=\"p\">,</span> <span class=\"p\">|</span><span class=\"n\">scopes</span><span class=\"p\">|</span> <span class=\"p\">{</span>\n    <span class=\"n\">scopes</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"nf\">.spawn</span><span class=\"p\">(|</span><span class=\"n\">s</span><span class=\"p\">|</span> <span class=\"p\">{</span> <span class=\"cm\">/* execute on hdd_pool, can use &amp;common */</span> <span class=\"p\">});</span>\n    <span class=\"n\">scopes</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"nf\">.spawn</span><span class=\"p\">(|</span><span class=\"n\">s</span><span class=\"p\">|</span> <span class=\"p\">{</span> <span class=\"cm\">/* execute on ssd_pool, can use &amp;common */</span> <span class=\"p\">});</span>\n<span class=\"p\">});</span>\n</code></pre></div></div>\n\n<p>How to implement <code class=\"language-plaintext highlighter-rouge\">multi_scope</code>? There is no way to obtain a <code class=\"language-plaintext highlighter-rouge\">Scope</code> value directly from Rayon.\nThe only way we can get a reference to a <code class=\"language-plaintext highlighter-rouge\">Scope</code> is inside the lambda passed to <code class=\"language-plaintext highlighter-rouge\">scope</code>.\nSo if we need multiple scopes active at the same time, we must nest scopes in each other. \nThis sounds like a recursion.</p>\n\n<h2 id=\"my-code-is-correct-but-the-borrow-checker-disagrees\">My Code Is Correct, But The Borrow Checker Disagrees</h2>\n<p>My initial take looked like this:</p>\n\n<div class=\"language-rust highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">pub</span> <span class=\"k\">fn</span> <span class=\"n\">multi_scope</span><span class=\"o\">&lt;</span><span class=\"nv\">'scope</span><span class=\"p\">,</span> <span class=\"n\">OP</span><span class=\"p\">,</span> <span class=\"n\">R</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">pools</span><span class=\"p\">:</span> <span class=\"o\">&amp;</span><span class=\"p\">[</span><span class=\"o\">&amp;</span><span class=\"n\">ThreadPool</span><span class=\"p\">],</span> <span class=\"n\">op</span><span class=\"p\">:</span> <span class=\"n\">OP</span><span class=\"p\">)</span> <span class=\"k\">-&gt;</span> <span class=\"n\">R</span>\n<span class=\"k\">where</span>\n    <span class=\"n\">OP</span><span class=\"p\">:</span> <span class=\"k\">for</span><span class=\"o\">&lt;</span><span class=\"nv\">'s</span><span class=\"o\">&gt;</span> <span class=\"nf\">FnOnce</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nv\">'s</span> <span class=\"p\">[</span><span class=\"o\">&amp;</span><span class=\"nv\">'s</span> <span class=\"n\">Scope</span><span class=\"o\">&lt;</span><span class=\"nv\">'scope</span><span class=\"o\">&gt;</span><span class=\"p\">])</span> <span class=\"k\">-&gt;</span> <span class=\"n\">R</span> <span class=\"o\">+</span> <span class=\"nv\">'scope</span> <span class=\"o\">+</span> <span class=\"nb\">Send</span><span class=\"p\">,</span>\n    <span class=\"n\">R</span><span class=\"p\">:</span> <span class=\"nb\">Send</span><span class=\"p\">,</span>\n<span class=\"p\">{</span>\n    <span class=\"nf\">nest</span><span class=\"p\">(</span><span class=\"n\">pools</span><span class=\"p\">,</span> <span class=\"nn\">Vec</span><span class=\"p\">::</span><span class=\"nf\">with_capacity</span><span class=\"p\">(</span><span class=\"n\">pools</span><span class=\"nf\">.len</span><span class=\"p\">()),</span> <span class=\"n\">op</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">fn</span> <span class=\"n\">nest</span><span class=\"o\">&lt;</span><span class=\"nv\">'scope</span><span class=\"p\">,</span> <span class=\"n\">OP</span><span class=\"p\">,</span> <span class=\"n\">R</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">pools</span><span class=\"p\">:</span> <span class=\"o\">&amp;</span><span class=\"p\">[</span><span class=\"o\">&amp;</span><span class=\"n\">ThreadPool</span><span class=\"p\">],</span> <span class=\"n\">scopes</span><span class=\"p\">:</span> <span class=\"nb\">Vec</span><span class=\"o\">&lt;&amp;</span><span class=\"n\">Scope</span><span class=\"o\">&lt;</span><span class=\"nv\">'scope</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">,</span> <span class=\"n\">op</span><span class=\"p\">:</span> <span class=\"n\">OP</span><span class=\"p\">)</span> <span class=\"k\">-&gt;</span> <span class=\"n\">R</span>\n<span class=\"k\">where</span>\n    <span class=\"n\">OP</span><span class=\"p\">:</span> <span class=\"k\">for</span><span class=\"o\">&lt;</span><span class=\"nv\">'s</span><span class=\"o\">&gt;</span> <span class=\"nf\">FnOnce</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nv\">'s</span> <span class=\"p\">[</span><span class=\"o\">&amp;</span><span class=\"nv\">'s</span> <span class=\"n\">Scope</span><span class=\"o\">&lt;</span><span class=\"nv\">'scope</span><span class=\"o\">&gt;</span><span class=\"p\">])</span> <span class=\"k\">-&gt;</span> <span class=\"n\">R</span> <span class=\"o\">+</span> <span class=\"nv\">'scope</span> <span class=\"o\">+</span> <span class=\"nb\">Send</span><span class=\"p\">,</span>\n    <span class=\"n\">R</span><span class=\"p\">:</span> <span class=\"nb\">Send</span><span class=\"p\">,</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">!</span><span class=\"n\">pools</span><span class=\"nf\">.is_empty</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n        <span class=\"n\">pools</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"nf\">.scope</span><span class=\"p\">(</span><span class=\"k\">move</span> <span class=\"p\">|</span><span class=\"n\">s</span><span class=\"p\">|</span> <span class=\"p\">{</span>\n            <span class=\"k\">let</span> <span class=\"k\">mut</span> <span class=\"n\">scopes</span> <span class=\"o\">=</span> <span class=\"n\">scopes</span><span class=\"p\">;</span>\n            <span class=\"n\">scopes</span><span class=\"nf\">.push</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">);</span>\n            <span class=\"nf\">nest</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">pools</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"o\">..</span><span class=\"p\">],</span> <span class=\"n\">scopes</span><span class=\"p\">,</span> <span class=\"n\">op</span><span class=\"p\">)</span>\n        <span class=\"p\">})</span>\n    <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n        <span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">)(</span><span class=\"o\">&amp;</span><span class=\"n\">scopes</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>An additional function <code class=\"language-plaintext highlighter-rouge\">nest</code> creates one new <code class=\"language-plaintext highlighter-rouge\">Scope</code> and pushes it into the <code class=\"language-plaintext highlighter-rouge\">scopes</code> vector, then it calls itself\nrecursively until it runs out of <code class=\"language-plaintext highlighter-rouge\">ThreadPool</code> values. Finally it calls the user operation <code class=\"language-plaintext highlighter-rouge\">op</code> \npassing the created <code class=\"language-plaintext highlighter-rouge\">scopes</code> vector to it.</p>\n\n<p>To my surprise that didn’t compile. Oh well!</p>\n<pre>\nerror[E0621]: explicit lifetime required in the type of `scopes`\n  --&gt; src/pools.rs:42:25\n   |\n34 | fn nest&lt;'scope, OP, R&gt;(pools: &amp;[&amp;ThreadPool], scopes: Vec&lt;&amp;Scope&lt;'scope&gt;&gt;, op: OP) -&gt; R\n   |                                                       ------------------- help: add explicit lifetime `'scope` to the type of `scopes`: `std::vec::Vec&lt;&amp;'scope rayon_core::scope::Scope&lt;'scope&gt;&gt;`\n...\n42 |             scopes.push(s);\n   |                         ^ lifetime `'scope` required\n\n</pre>\n\n<p>Wait, there is a hint here. As usual with Rust coding, let’s apply the hint the compiler gave to us:</p>\n\n<div class=\"language-rust highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">fn</span> <span class=\"n\">nest</span><span class=\"o\">&lt;</span><span class=\"nv\">'scope</span><span class=\"p\">,</span> <span class=\"n\">OP</span><span class=\"p\">,</span> <span class=\"n\">R</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">pools</span><span class=\"p\">:</span> <span class=\"o\">&amp;</span><span class=\"p\">[</span><span class=\"o\">&amp;</span><span class=\"n\">ThreadPool</span><span class=\"p\">],</span> <span class=\"n\">scopes</span><span class=\"p\">:</span> <span class=\"nb\">Vec</span><span class=\"o\">&lt;&amp;</span><span class=\"nv\">'scope</span> <span class=\"n\">Scope</span><span class=\"o\">&lt;</span><span class=\"nv\">'scope</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">,</span> <span class=\"n\">op</span><span class=\"p\">:</span> <span class=\"n\">OP</span><span class=\"p\">)</span> <span class=\"k\">-&gt;</span> <span class=\"n\">R</span>\n</code></pre></div></div>\n\n<p>But this made it only worse:</p>\n<pre>\nerror[E0495]: cannot infer an appropriate lifetime due to conflicting requirements\n  --&gt; src/pools.rs:41:33\n   |\n41 |             let mut scopes: Vec&lt;&amp;Scope&lt;'scope&gt;&gt; = scopes;\n   |                                 ^\n   |\nnote: first, the lifetime cannot outlive the anonymous lifetime #2 defined on the body at 40:24...\n  --&gt; src/pools.rs:40:24\n   |\n40 |           pools[0].scope(move |s| {\n   |  ________________________^\n41 | |             let mut scopes: Vec&lt;&amp;Scope&lt;'scope&gt;&gt; = scopes;\n42 | |             scopes.push(s);\n43 | |             nest(&amp;pools[1..], scopes, op)\n44 | |         })\n   | |_________^\nnote: ...so that reference does not outlive borrowed content\n  --&gt; src/pools.rs:42:25\n   |\n42 |             scopes.push(s);\n   |                         ^\nnote: but, the lifetime must be valid for the lifetime `'scope` as defined on the function body at 34:9...\n  --&gt; src/pools.rs:34:9\n   |\n34 | fn nest&lt;'scope, OP, R&gt;(pools: &amp;[&amp;ThreadPool], scopes: Vec&lt;&amp;'scope Scope&lt;'scope&gt;&gt;, op: OP) -&gt; R\n   |         ^^^^^^\nnote: ...so that the expression is assignable\n  --&gt; src/pools.rs:43:31\n   |\n43 |             nest(&amp;pools[1..], scopes, op)\n   |                               ^^^^^^\n   = note: expected `std::vec::Vec&lt;&amp;rayon_core::scope::Scope&lt;'_&gt;&gt;`\n              found `std::vec::Vec&lt;&amp;rayon_core::scope::Scope&lt;'scope&gt;&gt;`\n</pre>\n\n<p>What happens if we try to “help” the compiler with inferring the <code class=\"language-plaintext highlighter-rouge\">scopes</code> vector lifetime and require all references to be valid for at least <code class=\"language-plaintext highlighter-rouge\">'scope</code>?</p>\n<div class=\"language-rust highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">fn</span> <span class=\"n\">nest</span><span class=\"o\">&lt;</span><span class=\"nv\">'scope</span><span class=\"p\">,</span> <span class=\"n\">OP</span><span class=\"p\">,</span> <span class=\"n\">R</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">pools</span><span class=\"p\">:</span> <span class=\"o\">&amp;</span><span class=\"nv\">'scope</span> <span class=\"p\">[</span><span class=\"o\">&amp;</span><span class=\"nv\">'scope</span> <span class=\"n\">ThreadPool</span><span class=\"p\">],</span> <span class=\"n\">scopes</span><span class=\"p\">:</span> <span class=\"nb\">Vec</span><span class=\"o\">&lt;&amp;</span><span class=\"nv\">'scope</span> <span class=\"n\">Scope</span><span class=\"o\">&lt;</span><span class=\"nv\">'scope</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">,</span> <span class=\"n\">op</span><span class=\"p\">:</span> <span class=\"n\">OP</span><span class=\"p\">)</span> <span class=\"k\">-&gt;</span> <span class=\"n\">R</span>\n<span class=\"k\">where</span>\n    <span class=\"n\">OP</span><span class=\"p\">:</span> <span class=\"k\">for</span><span class=\"o\">&lt;</span><span class=\"nv\">'s</span><span class=\"o\">&gt;</span> <span class=\"nf\">FnOnce</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nv\">'s</span> <span class=\"p\">[</span><span class=\"o\">&amp;</span><span class=\"nv\">'s</span> <span class=\"n\">Scope</span><span class=\"o\">&lt;</span><span class=\"nv\">'scope</span><span class=\"o\">&gt;</span><span class=\"p\">])</span> <span class=\"k\">-&gt;</span> <span class=\"n\">R</span> <span class=\"o\">+</span> <span class=\"nv\">'scope</span> <span class=\"o\">+</span> <span class=\"nb\">Send</span><span class=\"p\">,</span>\n    <span class=\"n\">R</span><span class=\"p\">:</span> <span class=\"nb\">Send</span><span class=\"p\">,</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">!</span><span class=\"n\">pools</span><span class=\"nf\">.is_empty</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n        <span class=\"n\">pools</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"nf\">.scope</span><span class=\"p\">(</span><span class=\"k\">move</span> <span class=\"p\">|</span><span class=\"n\">s</span><span class=\"p\">|</span> <span class=\"p\">{</span>\n            <span class=\"k\">let</span> <span class=\"k\">mut</span> <span class=\"n\">scopes</span><span class=\"p\">:</span> <span class=\"nb\">Vec</span><span class=\"o\">&lt;&amp;</span><span class=\"nv\">'scope</span> <span class=\"n\">Scope</span><span class=\"o\">&lt;</span><span class=\"nv\">'scope</span><span class=\"o\">&gt;&gt;</span> <span class=\"o\">=</span> <span class=\"n\">scopes</span><span class=\"p\">;</span>\n            <span class=\"n\">scopes</span><span class=\"nf\">.push</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">);</span>\n            <span class=\"nf\">nest</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">pools</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"o\">..</span><span class=\"p\">],</span> <span class=\"n\">scopes</span><span class=\"p\">,</span> <span class=\"n\">op</span><span class=\"p\">)</span>\n        <span class=\"p\">})</span>\n    <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n        <span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">)(</span><span class=\"o\">&amp;</span><span class=\"n\">scopes</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n\n</code></pre></div></div>\n<pre>\nerror[E0312]: lifetime of reference outlives lifetime of borrowed content...\n  --&gt; src/pools.rs:42:25\n   |\n42 |             scopes.push(s);\n   |                         ^\n   |\nnote: ...the reference is valid for the lifetime `'scope` as defined on the function body at 34:9...\n  --&gt; src/pools.rs:34:9\n   |\n34 | fn nest&lt;'scope, OP, R&gt;(pools: &amp;'scope [&amp;'scope ThreadPool], scopes: Vec&lt;&amp;'scope Scope&lt;'scope&gt;&gt;, op: OP) -&gt; R\n   |         ^^^^^^\nnote: ...but the borrowed content is only valid for the anonymous lifetime #2 defined on the body at 40:24\n  --&gt; src/pools.rs:40:24\n   |\n40 |           pools[0].scope(move |s| {\n   |  ________________________^\n41 | |             let mut scopes: Vec&lt;&amp;'scope Scope&lt;'scope&gt;&gt; = scopes;\n42 | |             scopes.push(s);\n43 | |             nest(&amp;pools[1..], scopes, op)\n44 | |         })\n   | |_________^\n</pre>\n\n<p>Looks like we can’t really add the new scope to the vector, because now the vector type requires \nthat the references stored in it live for the time of the outermost scope. Rust collections obviously cannot hold\nreferences to data that lives shorter than the collection itself, therefore <code class=\"language-plaintext highlighter-rouge\">'scope</code> must not be shorter than\nthe lifetime of the vector created at the outermost recursion level.</p>\n\n<h2 id=\"the-borrow-checker-doesnt-give-up-easily\">The Borrow Checker Doesn’t Give Up Easily</h2>\n\n<p>Another idea I tried was to decouple the lifetime of the references inside the vector from the actual <code class=\"language-plaintext highlighter-rouge\">'scope</code> by introducing\na new lifetime <code class=\"language-plaintext highlighter-rouge\">'vec</code>, hoping that the vector would narrow down the lifetime of the innermost scope inserted into it \n(which should be ok because we will lend the vector only to the innermost scope at the end):</p>\n\n<div class=\"language-rust highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">fn</span> <span class=\"n\">nest</span><span class=\"o\">&lt;</span><span class=\"nv\">'scope</span><span class=\"p\">,</span> <span class=\"nv\">'vec</span><span class=\"p\">,</span> <span class=\"n\">OP</span><span class=\"p\">,</span> <span class=\"n\">R</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">pools</span><span class=\"p\">:</span> <span class=\"o\">&amp;</span><span class=\"p\">[</span><span class=\"o\">&amp;</span><span class=\"n\">ThreadPool</span><span class=\"p\">],</span> <span class=\"n\">scopes</span><span class=\"p\">:</span> <span class=\"nb\">Vec</span><span class=\"o\">&lt;&amp;</span><span class=\"nv\">'vec</span> <span class=\"n\">Scope</span><span class=\"o\">&lt;</span><span class=\"nv\">'scope</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">,</span> <span class=\"n\">op</span><span class=\"p\">:</span> <span class=\"n\">OP</span><span class=\"p\">)</span> <span class=\"k\">-&gt;</span> <span class=\"n\">R</span>\n<span class=\"k\">where</span>\n    <span class=\"n\">OP</span><span class=\"p\">:</span> <span class=\"k\">for</span><span class=\"o\">&lt;</span><span class=\"nv\">'s</span><span class=\"o\">&gt;</span> <span class=\"nf\">FnOnce</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nv\">'s</span> <span class=\"p\">[</span><span class=\"o\">&amp;</span><span class=\"nv\">'s</span> <span class=\"n\">Scope</span><span class=\"o\">&lt;</span><span class=\"nv\">'scope</span><span class=\"o\">&gt;</span><span class=\"p\">])</span> <span class=\"k\">-&gt;</span> <span class=\"n\">R</span> <span class=\"o\">+</span> <span class=\"nv\">'scope</span> <span class=\"o\">+</span> <span class=\"nb\">Send</span><span class=\"p\">,</span>\n    <span class=\"n\">R</span><span class=\"p\">:</span> <span class=\"nb\">Send</span><span class=\"p\">,</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">!</span><span class=\"n\">pools</span><span class=\"nf\">.is_empty</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n        <span class=\"n\">pools</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"nf\">.scope</span><span class=\"p\">(</span><span class=\"k\">move</span> <span class=\"p\">|</span><span class=\"n\">s</span><span class=\"p\">|</span> <span class=\"p\">{</span>\n            <span class=\"k\">let</span> <span class=\"k\">mut</span> <span class=\"n\">scopes</span><span class=\"p\">:</span> <span class=\"nb\">Vec</span><span class=\"o\">&lt;&amp;</span><span class=\"n\">Scope</span><span class=\"o\">&lt;</span><span class=\"nv\">'scope</span><span class=\"o\">&gt;&gt;</span> <span class=\"o\">=</span> <span class=\"n\">scopes</span><span class=\"p\">;</span>\n            <span class=\"n\">scopes</span><span class=\"nf\">.push</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">);</span>\n            <span class=\"nf\">nest</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">pools</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"o\">..</span><span class=\"p\">],</span> <span class=\"n\">scopes</span><span class=\"p\">,</span> <span class=\"n\">op</span><span class=\"p\">)</span>\n        <span class=\"p\">})</span>\n    <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n        <span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">)(</span><span class=\"o\">&amp;</span><span class=\"n\">scopes</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>Almost worked, but still one more error to go…</p>\n<pre>\nerror[E0623]: lifetime mismatch\n  --&gt; src/pools.rs:42:25\n   |\n34 | fn nest&lt;'scope, 'vec, OP, R&gt;(pools: &amp;[&amp;ThreadPool], scopes: Vec&lt;&amp;'vec Scope&lt;'scope&gt;&gt;, op: OP) -&gt; R\n   |                                                                 -------------------\n   |                                                                 |\n   |                                                                 these two types are declared with different lifetimes...\n...\n42 |             scopes.push(s);\n   |                         ^ ...but data from `scopes` flows into `scopes` here\n</pre>\n\n<p>This time the error message is not helpful at all. Why is the compiler saying “these two types” while pointing to a single type?\nThis baffled me for a while, but eventually I realized this must have something to do with <code class=\"language-plaintext highlighter-rouge\">'vec</code> being inferred differently \nfor the next recursion level than <code class=\"language-plaintext highlighter-rouge\">'vec</code> on the current level. And what does it mean “<code class=\"language-plaintext highlighter-rouge\">scopes</code> flows into <code class=\"language-plaintext highlighter-rouge\">scopes</code>”?</p>\n\n<h2 id=\"blocked-by-invariance\">Blocked By Invariance</h2>\n\n<p>I started experimenting a bit by removing some code and I realized these two logically incorrect versions compile just fine:</p>\n\n<div class=\"language-rust highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">fn</span> <span class=\"n\">nest</span><span class=\"o\">&lt;</span><span class=\"nv\">'scope</span><span class=\"p\">,</span> <span class=\"nv\">'vec</span><span class=\"p\">,</span> <span class=\"n\">OP</span><span class=\"p\">,</span> <span class=\"n\">R</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">pools</span><span class=\"p\">:</span> <span class=\"o\">&amp;</span><span class=\"nv\">'scope</span><span class=\"p\">[</span><span class=\"o\">&amp;</span><span class=\"nv\">'scope</span> <span class=\"n\">ThreadPool</span><span class=\"p\">],</span> <span class=\"n\">scopes</span><span class=\"p\">:</span> <span class=\"nb\">Vec</span><span class=\"o\">&lt;&amp;</span><span class=\"nv\">'vec</span> <span class=\"n\">Scope</span><span class=\"o\">&lt;</span><span class=\"nv\">'scope</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">,</span> <span class=\"n\">op</span><span class=\"p\">:</span> <span class=\"n\">OP</span><span class=\"p\">)</span> <span class=\"k\">-&gt;</span> <span class=\"n\">R</span>\n<span class=\"k\">where</span>\n    <span class=\"n\">OP</span><span class=\"p\">:</span> <span class=\"k\">for</span><span class=\"o\">&lt;</span><span class=\"nv\">'s</span><span class=\"o\">&gt;</span> <span class=\"nf\">FnOnce</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nv\">'s</span> <span class=\"p\">[</span><span class=\"o\">&amp;</span><span class=\"nv\">'s</span> <span class=\"n\">Scope</span><span class=\"o\">&lt;</span><span class=\"nv\">'scope</span><span class=\"o\">&gt;</span><span class=\"p\">])</span> <span class=\"k\">-&gt;</span> <span class=\"n\">R</span> <span class=\"o\">+</span> <span class=\"nv\">'scope</span> <span class=\"o\">+</span> <span class=\"nb\">Send</span><span class=\"p\">,</span>\n    <span class=\"n\">R</span><span class=\"p\">:</span> <span class=\"nb\">Send</span><span class=\"p\">,</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">!</span><span class=\"n\">pools</span><span class=\"nf\">.is_empty</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n        <span class=\"n\">pools</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"nf\">.scope</span><span class=\"p\">(</span><span class=\"k\">move</span> <span class=\"p\">|</span><span class=\"n\">s</span><span class=\"p\">|</span> <span class=\"p\">{</span>\n            <span class=\"k\">let</span> <span class=\"k\">mut</span> <span class=\"n\">scopes</span> <span class=\"o\">=</span> <span class=\"nn\">Vec</span><span class=\"p\">::</span><span class=\"nf\">new</span><span class=\"p\">();</span>    <span class=\"c\">// &lt;--- look here</span>\n            <span class=\"n\">scopes</span><span class=\"nf\">.push</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">);</span>                 <span class=\"c\">// &lt;--- look here</span>\n            <span class=\"nf\">nest</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">pools</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"o\">..</span><span class=\"p\">],</span> <span class=\"n\">scopes</span><span class=\"p\">,</span> <span class=\"n\">op</span><span class=\"p\">)</span>\n        <span class=\"p\">})</span>\n    <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n        <span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">)(</span><span class=\"o\">&amp;</span><span class=\"n\">scopes</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<div class=\"language-rust highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">fn</span> <span class=\"n\">nest</span><span class=\"o\">&lt;</span><span class=\"nv\">'scope</span><span class=\"p\">,</span> <span class=\"nv\">'vec</span><span class=\"p\">,</span> <span class=\"n\">OP</span><span class=\"p\">,</span> <span class=\"n\">R</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">pools</span><span class=\"p\">:</span> <span class=\"o\">&amp;</span><span class=\"nv\">'scope</span><span class=\"p\">[</span><span class=\"o\">&amp;</span><span class=\"nv\">'scope</span> <span class=\"n\">ThreadPool</span><span class=\"p\">],</span> <span class=\"n\">scopes</span><span class=\"p\">:</span> <span class=\"nb\">Vec</span><span class=\"o\">&lt;&amp;</span><span class=\"nv\">'vec</span> <span class=\"n\">Scope</span><span class=\"o\">&lt;</span><span class=\"nv\">'scope</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">,</span> <span class=\"n\">op</span><span class=\"p\">:</span> <span class=\"n\">OP</span><span class=\"p\">)</span> <span class=\"k\">-&gt;</span> <span class=\"n\">R</span>\n<span class=\"k\">where</span>\n    <span class=\"n\">OP</span><span class=\"p\">:</span> <span class=\"k\">for</span><span class=\"o\">&lt;</span><span class=\"nv\">'s</span><span class=\"o\">&gt;</span> <span class=\"nf\">FnOnce</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nv\">'s</span> <span class=\"p\">[</span><span class=\"o\">&amp;</span><span class=\"nv\">'s</span> <span class=\"n\">Scope</span><span class=\"o\">&lt;</span><span class=\"nv\">'scope</span><span class=\"o\">&gt;</span><span class=\"p\">])</span> <span class=\"k\">-&gt;</span> <span class=\"n\">R</span> <span class=\"o\">+</span> <span class=\"nv\">'scope</span> <span class=\"o\">+</span> <span class=\"nb\">Send</span><span class=\"p\">,</span>\n    <span class=\"n\">R</span><span class=\"p\">:</span> <span class=\"nb\">Send</span><span class=\"p\">,</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">!</span><span class=\"n\">pools</span><span class=\"nf\">.is_empty</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n        <span class=\"n\">pools</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"nf\">.scope</span><span class=\"p\">(</span><span class=\"k\">move</span> <span class=\"p\">|</span><span class=\"n\">s</span><span class=\"p\">|</span> <span class=\"p\">{</span>\n            <span class=\"k\">let</span> <span class=\"k\">mut</span> <span class=\"n\">scopes</span> <span class=\"o\">=</span> <span class=\"n\">scopes</span><span class=\"p\">;</span>        <span class=\"c\">// &lt;--- look here</span>\n            <span class=\"nf\">nest</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">pools</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"o\">..</span><span class=\"p\">],</span> <span class=\"n\">scopes</span><span class=\"p\">,</span> <span class=\"n\">op</span><span class=\"p\">)</span>\n        <span class=\"p\">})</span>\n    <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n        <span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">)(</span><span class=\"o\">&amp;</span><span class=\"n\">scopes</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>So I can either add the newly created scope to my vector as the only item, or I can pass the existing vector as is without inserting the new scope!\nBut I can’t do both! This problem typically happens when you try to add values of different incompatible types to a collection, but here I’m adding \nvalues of the same type, so I should be fine…</p>\n\n<p>Unfortunately, Rayon’s <code class=\"language-plaintext highlighter-rouge\">Scope</code> struct is <em>invariant</em> over its lifetime parameter, and the lifetime is obviously a part of the type. \nIn this case the compiler won’t coerce one scope to another, e.g. by shortening the lifetime of the outer scope to match the lifetime of the inner scope,\nnor by extending the lifetime of the inner scope to match the outer scope. \nThis means we can’t put references to two scopes into a single vector, at least not without changing the \nsource code of Rayon or changing how the type system works in Rust. What a bummer!</p>\n\n<h2 id=\"going-unsafe\">Going Unsafe</h2>\n\n<p>Fortunately, the tiny difference in scope lifetimes caused by nesting is all internal to the <code class=\"language-plaintext highlighter-rouge\">nest</code> function and is never observable by \nthe client’s code. From the outside, we can safely assume all scopes were created with the same lifetime – \nthey are all created by <code class=\"language-plaintext highlighter-rouge\">nest</code> and all dropped by it together.</p>\n\n<p>This is the moment where Rust’s <code class=\"language-plaintext highlighter-rouge\">unsafe</code> comes to the rescue. \nWe can “cheat” a bit, and let the compiler adjust our scope lifetimes so they match and can be stored in a single vector:</p>\n\n<div class=\"language-rust highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">unsafe</span> <span class=\"k\">fn</span> <span class=\"n\">adjust_lifetime</span><span class=\"o\">&lt;</span><span class=\"nv\">'s</span><span class=\"p\">,</span> <span class=\"nv\">'a</span><span class=\"p\">,</span> <span class=\"nv\">'b</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">scope</span><span class=\"p\">:</span> <span class=\"o\">&amp;</span><span class=\"nv\">'s</span> <span class=\"n\">Scope</span><span class=\"o\">&lt;</span><span class=\"nv\">'a</span><span class=\"o\">&gt;</span><span class=\"p\">)</span> <span class=\"k\">-&gt;</span> <span class=\"o\">&amp;</span><span class=\"nv\">'s</span> <span class=\"n\">Scope</span><span class=\"o\">&lt;</span><span class=\"nv\">'b</span><span class=\"o\">&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nn\">std</span><span class=\"p\">::</span><span class=\"nn\">mem</span><span class=\"p\">::</span><span class=\"nn\">transmute</span><span class=\"p\">::</span><span class=\"o\">&lt;&amp;</span><span class=\"nv\">'s</span> <span class=\"n\">Scope</span><span class=\"o\">&lt;</span><span class=\"nv\">'a</span><span class=\"o\">&gt;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"nv\">'s</span> <span class=\"n\">Scope</span><span class=\"o\">&lt;</span><span class=\"nv\">'b</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">(</span><span class=\"n\">scope</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">fn</span> <span class=\"n\">nest</span><span class=\"o\">&lt;</span><span class=\"nv\">'scope</span><span class=\"p\">,</span> <span class=\"nv\">'vec</span><span class=\"p\">,</span> <span class=\"n\">OP</span><span class=\"p\">,</span> <span class=\"n\">R</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">pools</span><span class=\"p\">:</span> <span class=\"o\">&amp;</span><span class=\"nv\">'scope</span><span class=\"p\">[</span><span class=\"o\">&amp;</span><span class=\"nv\">'scope</span> <span class=\"n\">ThreadPool</span><span class=\"p\">],</span> <span class=\"n\">scopes</span><span class=\"p\">:</span> <span class=\"nb\">Vec</span><span class=\"o\">&lt;&amp;</span><span class=\"nv\">'vec</span> <span class=\"n\">Scope</span><span class=\"o\">&lt;</span><span class=\"nv\">'scope</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">,</span> <span class=\"n\">op</span><span class=\"p\">:</span> <span class=\"n\">OP</span><span class=\"p\">)</span> <span class=\"k\">-&gt;</span> <span class=\"n\">R</span>\n<span class=\"k\">where</span>\n    <span class=\"n\">OP</span><span class=\"p\">:</span> <span class=\"k\">for</span><span class=\"o\">&lt;</span><span class=\"nv\">'s</span><span class=\"o\">&gt;</span> <span class=\"nf\">FnOnce</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nv\">'s</span> <span class=\"p\">[</span><span class=\"o\">&amp;</span><span class=\"nv\">'s</span> <span class=\"n\">Scope</span><span class=\"o\">&lt;</span><span class=\"nv\">'scope</span><span class=\"o\">&gt;</span><span class=\"p\">])</span> <span class=\"k\">-&gt;</span> <span class=\"n\">R</span> <span class=\"o\">+</span> <span class=\"nv\">'scope</span> <span class=\"o\">+</span> <span class=\"nb\">Send</span><span class=\"p\">,</span>\n    <span class=\"n\">R</span><span class=\"p\">:</span> <span class=\"nb\">Send</span><span class=\"p\">,</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">!</span><span class=\"n\">pools</span><span class=\"nf\">.is_empty</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n        <span class=\"n\">pools</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"nf\">.scope</span><span class=\"p\">(</span><span class=\"k\">move</span> <span class=\"p\">|</span><span class=\"n\">s</span><span class=\"p\">|</span> <span class=\"p\">{</span>\n            <span class=\"k\">let</span> <span class=\"k\">mut</span> <span class=\"n\">scopes</span> <span class=\"o\">=</span> <span class=\"n\">scopes</span><span class=\"p\">;</span>\n            <span class=\"n\">scopes</span><span class=\"nf\">.push</span><span class=\"p\">(</span><span class=\"k\">unsafe</span> <span class=\"p\">{</span> <span class=\"nf\">adjust_lifetime</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)</span> <span class=\"p\">});</span>\n            <span class=\"nf\">nest</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">pools</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"o\">..</span><span class=\"p\">],</span> <span class=\"n\">scopes</span><span class=\"p\">,</span> <span class=\"n\">op</span><span class=\"p\">)</span>\n        <span class=\"p\">})</span>\n    <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n        <span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">)(</span><span class=\"o\">&amp;</span><span class=\"n\">scopes</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>Actually some lifetime annotations can be dropped and the compiler is still happy:</p>\n<div class=\"language-rust highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">unsafe</span> <span class=\"k\">fn</span> <span class=\"n\">adjust_lifetime</span><span class=\"o\">&lt;</span><span class=\"nv\">'s</span><span class=\"p\">,</span> <span class=\"nv\">'a</span><span class=\"p\">,</span> <span class=\"nv\">'b</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">scope</span><span class=\"p\">:</span> <span class=\"o\">&amp;</span><span class=\"nv\">'s</span> <span class=\"n\">Scope</span><span class=\"o\">&lt;</span><span class=\"nv\">'a</span><span class=\"o\">&gt;</span><span class=\"p\">)</span> <span class=\"k\">-&gt;</span> <span class=\"o\">&amp;</span><span class=\"nv\">'s</span> <span class=\"n\">Scope</span><span class=\"o\">&lt;</span><span class=\"nv\">'b</span><span class=\"o\">&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nn\">std</span><span class=\"p\">::</span><span class=\"nn\">mem</span><span class=\"p\">::</span><span class=\"nn\">transmute</span><span class=\"p\">::</span><span class=\"o\">&lt;&amp;</span><span class=\"nv\">'s</span> <span class=\"n\">Scope</span><span class=\"o\">&lt;</span><span class=\"nv\">'a</span><span class=\"o\">&gt;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"nv\">'s</span> <span class=\"n\">Scope</span><span class=\"o\">&lt;</span><span class=\"nv\">'b</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">(</span><span class=\"n\">scope</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">fn</span> <span class=\"n\">nest</span><span class=\"o\">&lt;</span><span class=\"nv\">'scope</span><span class=\"p\">,</span> <span class=\"n\">OP</span><span class=\"p\">,</span> <span class=\"n\">R</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">pools</span><span class=\"p\">:</span> <span class=\"o\">&amp;</span><span class=\"p\">[</span><span class=\"o\">&amp;</span><span class=\"n\">ThreadPool</span><span class=\"p\">],</span> <span class=\"n\">scopes</span><span class=\"p\">:</span> <span class=\"nb\">Vec</span><span class=\"o\">&lt;&amp;</span><span class=\"n\">Scope</span><span class=\"o\">&lt;</span><span class=\"nv\">'scope</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">,</span> <span class=\"n\">op</span><span class=\"p\">:</span> <span class=\"n\">OP</span><span class=\"p\">)</span> <span class=\"k\">-&gt;</span> <span class=\"n\">R</span>\n<span class=\"k\">where</span>\n    <span class=\"n\">OP</span><span class=\"p\">:</span> <span class=\"k\">for</span><span class=\"o\">&lt;</span><span class=\"nv\">'s</span><span class=\"o\">&gt;</span> <span class=\"nf\">FnOnce</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nv\">'s</span> <span class=\"p\">[</span><span class=\"o\">&amp;</span><span class=\"nv\">'s</span> <span class=\"n\">Scope</span><span class=\"o\">&lt;</span><span class=\"nv\">'scope</span><span class=\"o\">&gt;</span><span class=\"p\">])</span> <span class=\"k\">-&gt;</span> <span class=\"n\">R</span> <span class=\"o\">+</span> <span class=\"nv\">'scope</span> <span class=\"o\">+</span> <span class=\"nb\">Send</span><span class=\"p\">,</span>\n    <span class=\"n\">R</span><span class=\"p\">:</span> <span class=\"nb\">Send</span><span class=\"p\">,</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">!</span><span class=\"n\">pools</span><span class=\"nf\">.is_empty</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n        <span class=\"n\">pools</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"nf\">.scope</span><span class=\"p\">(</span><span class=\"k\">move</span> <span class=\"p\">|</span><span class=\"n\">s</span><span class=\"p\">|</span> <span class=\"p\">{</span>\n            <span class=\"k\">let</span> <span class=\"k\">mut</span> <span class=\"n\">scopes</span> <span class=\"o\">=</span> <span class=\"n\">scopes</span><span class=\"p\">;</span>\n            <span class=\"n\">scopes</span><span class=\"nf\">.push</span><span class=\"p\">(</span><span class=\"k\">unsafe</span> <span class=\"p\">{</span> <span class=\"nf\">adjust_lifetime</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)</span> <span class=\"p\">});</span>\n            <span class=\"nf\">nest</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">pools</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"o\">..</span><span class=\"p\">],</span> <span class=\"n\">scopes</span><span class=\"p\">,</span> <span class=\"n\">op</span><span class=\"p\">)</span>\n        <span class=\"p\">})</span>\n    <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n        <span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">)(</span><span class=\"o\">&amp;</span><span class=\"n\">scopes</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<h2 id=\"update-getting-rid-of-unsafe\">Update: Getting Rid of Unsafe</h2>\n<p>Fortunately Rayon 1.4.0 changed its <code class=\"language-plaintext highlighter-rouge\">scope</code> signature a bit and now it is possible to completely avoid <code class=\"language-plaintext highlighter-rouge\">unsafe</code>.</p>\n\n<p>Rayon 1.3.0 defines <code class=\"language-plaintext highlighter-rouge\">scope</code> function as follows:</p>\n\n<div class=\"language-rust highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\">/// Creates a scope that executes within this thread-pool.</span>\n<span class=\"c\">/// Equivalent to `self.install(|| scope(...))`.</span>\n<span class=\"c\">///</span>\n<span class=\"c\">/// See also: [the `scope()` function][scope].</span>\n<span class=\"c\">///</span>\n<span class=\"c\">/// [scope]: fn.scope.html</span>\n<span class=\"k\">pub</span> <span class=\"k\">fn</span> <span class=\"n\">scope</span><span class=\"o\">&lt;</span><span class=\"nv\">'scope</span><span class=\"p\">,</span> <span class=\"n\">OP</span><span class=\"p\">,</span> <span class=\"n\">R</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">self</span><span class=\"p\">,</span> <span class=\"n\">op</span><span class=\"p\">:</span> <span class=\"n\">OP</span><span class=\"p\">)</span> <span class=\"k\">-&gt;</span> <span class=\"n\">R</span>\n<span class=\"k\">where</span>\n    <span class=\"n\">OP</span><span class=\"p\">:</span> <span class=\"k\">for</span><span class=\"o\">&lt;</span><span class=\"nv\">'s</span><span class=\"o\">&gt;</span> <span class=\"nf\">FnOnce</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nv\">'s</span> <span class=\"n\">Scope</span><span class=\"o\">&lt;</span><span class=\"nv\">'scope</span><span class=\"o\">&gt;</span><span class=\"p\">)</span> <span class=\"k\">-&gt;</span> <span class=\"n\">R</span> <span class=\"o\">+</span> <span class=\"nv\">'scope</span> <span class=\"o\">+</span> <span class=\"nb\">Send</span><span class=\"p\">,</span>\n    <span class=\"n\">R</span><span class=\"p\">:</span> <span class=\"nb\">Send</span><span class=\"p\">,</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">self</span><span class=\"nf\">.install</span><span class=\"p\">(||</span> <span class=\"nf\">scope</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">))</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>There is an explicit requirement that the passed <code class=\"language-plaintext highlighter-rouge\">op</code> lambda lives for at least as\nlong as <code class=\"language-plaintext highlighter-rouge\">'scope</code> therefore <code class=\"language-plaintext highlighter-rouge\">'scope</code> can never be inferred to be wider than the lifetime of <code class=\"language-plaintext highlighter-rouge\">op</code>.</p>\n\n<p>In Rayon 1.4.0 <code class=\"language-plaintext highlighter-rouge\">scope</code> has been changed into:</p>\n\n<div class=\"language-rust highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\">/// Creates a scope that executes within this thread-pool.</span>\n<span class=\"c\">/// Equivalent to `self.install(|| scope(...))`.</span>\n<span class=\"c\">///</span>\n<span class=\"c\">/// See also: [the `scope()` function][scope].</span>\n<span class=\"c\">///</span>\n<span class=\"c\">/// [scope]: fn.scope.html</span>\n<span class=\"k\">pub</span> <span class=\"k\">fn</span> <span class=\"n\">scope</span><span class=\"o\">&lt;</span><span class=\"nv\">'scope</span><span class=\"p\">,</span> <span class=\"n\">OP</span><span class=\"p\">,</span> <span class=\"n\">R</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">self</span><span class=\"p\">,</span> <span class=\"n\">op</span><span class=\"p\">:</span> <span class=\"n\">OP</span><span class=\"p\">)</span> <span class=\"k\">-&gt;</span> <span class=\"n\">R</span>\n<span class=\"k\">where</span>\n    <span class=\"n\">OP</span><span class=\"p\">:</span> <span class=\"nf\">FnOnce</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">Scope</span><span class=\"o\">&lt;</span><span class=\"nv\">'scope</span><span class=\"o\">&gt;</span><span class=\"p\">)</span> <span class=\"k\">-&gt;</span> <span class=\"n\">R</span> <span class=\"o\">+</span> <span class=\"nb\">Send</span><span class=\"p\">,</span>\n    <span class=\"n\">R</span><span class=\"p\">:</span> <span class=\"nb\">Send</span><span class=\"p\">,</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">self</span><span class=\"nf\">.install</span><span class=\"p\">(||</span> <span class=\"nf\">scope</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">))</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>Now the <code class=\"language-plaintext highlighter-rouge\">'scope</code> is allowed to be a wider lifetime than the lifetime of a lambda.\nIf we nest scopes, they all can get the same <code class=\"language-plaintext highlighter-rouge\">'scope</code> that can hold the outermost \nlambda. Therefore it is enough to remove the <code class=\"language-plaintext highlighter-rouge\">+ 'scope</code> requirement in our code and drop the\n<code class=\"language-plaintext highlighter-rouge\">adjust_lifetime</code> call:</p>\n\n<div class=\"language-rust highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">use</span> <span class=\"nn\">rayon</span><span class=\"p\">::{</span><span class=\"n\">Scope</span><span class=\"p\">,</span> <span class=\"n\">ThreadPool</span><span class=\"p\">};</span>\n\n<span class=\"k\">fn</span> <span class=\"n\">nest</span><span class=\"o\">&lt;</span><span class=\"nv\">'scope</span><span class=\"p\">,</span> <span class=\"n\">OP</span><span class=\"p\">,</span> <span class=\"n\">R</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">pools</span><span class=\"p\">:</span> <span class=\"o\">&amp;</span><span class=\"p\">[</span><span class=\"o\">&amp;</span><span class=\"n\">ThreadPool</span><span class=\"p\">],</span> <span class=\"n\">scopes</span><span class=\"p\">:</span> <span class=\"nb\">Vec</span><span class=\"o\">&lt;&amp;</span><span class=\"n\">Scope</span><span class=\"o\">&lt;</span><span class=\"nv\">'scope</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">,</span> <span class=\"n\">op</span><span class=\"p\">:</span> <span class=\"n\">OP</span><span class=\"p\">)</span> <span class=\"k\">-&gt;</span> <span class=\"n\">R</span>\n<span class=\"k\">where</span>\n    <span class=\"n\">OP</span><span class=\"p\">:</span> <span class=\"nf\">FnOnce</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"p\">[</span><span class=\"o\">&amp;</span><span class=\"n\">Scope</span><span class=\"o\">&lt;</span><span class=\"nv\">'scope</span><span class=\"o\">&gt;</span><span class=\"p\">])</span> <span class=\"k\">-&gt;</span> <span class=\"n\">R</span> <span class=\"o\">+</span> <span class=\"nb\">Send</span><span class=\"p\">,</span>\n    <span class=\"n\">R</span><span class=\"p\">:</span> <span class=\"nb\">Send</span><span class=\"p\">,</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">!</span><span class=\"n\">pools</span><span class=\"nf\">.is_empty</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n        <span class=\"n\">pools</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"nf\">.scope</span><span class=\"p\">(</span><span class=\"k\">move</span> <span class=\"p\">|</span><span class=\"n\">s</span><span class=\"p\">|</span> <span class=\"p\">{</span>\n            <span class=\"k\">let</span> <span class=\"k\">mut</span> <span class=\"n\">scopes</span> <span class=\"o\">=</span> <span class=\"n\">scopes</span><span class=\"p\">;</span>\n            <span class=\"n\">scopes</span><span class=\"nf\">.push</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">);</span>\n            <span class=\"nf\">nest</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">pools</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"o\">..</span><span class=\"p\">],</span> <span class=\"n\">scopes</span><span class=\"p\">,</span> <span class=\"n\">op</span><span class=\"p\">)</span>\n        <span class=\"p\">})</span>\n    <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n        <span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">)(</span><span class=\"o\">&amp;</span><span class=\"n\">scopes</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"c\">/// Creates multiple Rayon scopes, one per given `ThreadPool`, around the given lambda `op`.</span>\n<span class=\"c\">/// The purpose of this method is to be able to spawn tasks on multiple thread pools when</span>\n<span class=\"c\">/// the number of thread pools is not known at compile-time. Same as with a single scope,</span>\n<span class=\"c\">/// all tasks spawned by `op` are guaranteed to finish before this call exits, so they</span>\n<span class=\"c\">/// are allowed to access structs from outside of the scope.</span>\n<span class=\"c\">///</span>\n<span class=\"c\">/// # Example</span>\n<span class=\"c\">/// ```</span>\n<span class=\"c\">/// use rayon::ThreadPoolBuilder;</span>\n<span class=\"c\">/// use fclones::pools::multi_scope;</span>\n<span class=\"c\">///</span>\n<span class=\"c\">/// let pool1 = ThreadPoolBuilder::new().build().unwrap();</span>\n<span class=\"c\">/// let pool2 = ThreadPoolBuilder::new().build().unwrap();</span>\n<span class=\"c\">/// let common = vec![0, 1, 2]; // common data, must be Send</span>\n<span class=\"c\">/// multi_scope(&amp;[&amp;pool1, &amp;pool2], |scopes| {</span>\n<span class=\"c\">///     scopes[0].spawn(|_| { /* execute on pool1, can use &amp;common */ });</span>\n<span class=\"c\">///     scopes[1].spawn(|_| { /* execute on pool2, can use &amp;common */ });</span>\n<span class=\"c\">/// });</span>\n<span class=\"c\">/// ```</span>\n<span class=\"k\">pub</span> <span class=\"k\">fn</span> <span class=\"n\">multi_scope</span><span class=\"o\">&lt;</span><span class=\"nv\">'scope</span><span class=\"p\">,</span> <span class=\"n\">OP</span><span class=\"p\">,</span> <span class=\"n\">R</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">pools</span><span class=\"p\">:</span> <span class=\"o\">&amp;</span><span class=\"p\">[</span><span class=\"o\">&amp;</span><span class=\"n\">ThreadPool</span><span class=\"p\">],</span> <span class=\"n\">op</span><span class=\"p\">:</span> <span class=\"n\">OP</span><span class=\"p\">)</span> <span class=\"k\">-&gt;</span> <span class=\"n\">R</span>\n<span class=\"k\">where</span>\n    <span class=\"n\">OP</span><span class=\"p\">:</span> <span class=\"nf\">FnOnce</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"p\">[</span><span class=\"o\">&amp;</span><span class=\"n\">Scope</span><span class=\"o\">&lt;</span><span class=\"nv\">'scope</span><span class=\"o\">&gt;</span><span class=\"p\">])</span> <span class=\"k\">-&gt;</span> <span class=\"n\">R</span> <span class=\"o\">+</span> <span class=\"nb\">Send</span><span class=\"p\">,</span>\n    <span class=\"n\">R</span><span class=\"p\">:</span> <span class=\"nb\">Send</span><span class=\"p\">,</span>\n<span class=\"p\">{</span>\n    <span class=\"nf\">nest</span><span class=\"p\">(</span><span class=\"n\">pools</span><span class=\"p\">,</span> <span class=\"nn\">Vec</span><span class=\"p\">::</span><span class=\"nf\">with_capacity</span><span class=\"p\">(</span><span class=\"n\">pools</span><span class=\"nf\">.len</span><span class=\"p\">()),</span> <span class=\"n\">op</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>",
  "author": {
    "name": "Piotr Kołaczkowski"
  },
  "category": [
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  "summary": "In the previous post, I showed how processing file data in parallel can either boost or hurt performance depending on the workload and device capabilities. Therefore, in complex programs that mix tasks of different types using different physical resources, e.g. CPU, storage (e.g. HDD/SSD) or network I/O, a need may arise to configure parallelism levels differently for each task type. This is typically solved by scheduling tasks of different types on dedicated thread pools. In this post I’m showing how to implement a solution in Rust with Rayon."
}