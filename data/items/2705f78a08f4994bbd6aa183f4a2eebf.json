{
  "title": "Credit Modeling with Dask",
  "link": "",
  "updated": "2018-02-09T00:00:00+00:00",
  "id": "https://mrocklin.github.io/blog/work/2018/02/09/credit-models-with-dask",
  "content": "<p>This post explores a real-world use case calculating complex credit models in Python using Dask.\nIt is an example of a complex parallel system that is well outside of the traditional “big data” workloads.</p>\n\n<h2 id=\"this-is-a-guest-post\">This is a guest post</h2>\n\n<p>Hi All,</p>\n\n<p>This is a guest post from <a href=\"https://github.com/postelrich\">Rich Postelnik</a>,\nan Anaconda employee who works with a large retail bank on their credit modeling system.\nThey’re doing interesting work with Dask to manage complex computations\n(see task graph below).\nThis is a nice example of using Dask for complex problems that are neither a big dataframe nor a big array, but are still highly parallel.\nRich was kind enough to write up this description of their problem and share it here.</p>\n\n<p>Thanks Rich!</p>\n\n<p><a href=\"https://mrocklin.github.io/blog/images/credit_models/simple-model.svg\">\n  <img src=\"https://mrocklin.github.io/blog/images/credit_models/simple-model.svg\" alt=\"zoomed model section\" width=\"100%\" /></a></p>\n\n<p><em>This is cross-posted at <a href=\"https://www.anaconda.com/blog/developer-blog/credit-modeling-with-dask/\">Anaconda’s Developer Blog</a>.</em></p>\n\n<p>P.S. If others have similar solutions and would like to share them I’d love to host those on this blog as well.</p>\n\n<h2 id=\"the-problem\">The Problem</h2>\n\n<p>When applying for a loan, like a credit card, mortgage, auto loan, etc., we want to estimate the likelihood of default and the profit (or loss) to be gained. Those models are composed of a complex set of equations that depend on each other. There can be hundreds of equations each of which could have up to 20 inputs and yield 20 outputs. That is a lot of information to keep track of! We want to avoid manually keeping track of the dependencies, as well as messy code like the following Python function:</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">final_equation</span><span class=\"p\">(</span><span class=\"n\">inputs</span><span class=\"p\">):</span>\n    <span class=\"n\">out1</span> <span class=\"o\">=</span> <span class=\"n\">equation1</span><span class=\"p\">(</span><span class=\"n\">inputs</span><span class=\"p\">)</span>\n    <span class=\"n\">out2_1</span><span class=\"p\">,</span> <span class=\"n\">out2_2</span><span class=\"p\">,</span> <span class=\"n\">out2_3</span> <span class=\"o\">=</span> <span class=\"n\">equation2</span><span class=\"p\">(</span><span class=\"n\">inputs</span><span class=\"p\">,</span> <span class=\"n\">out1</span><span class=\"p\">)</span>\n    <span class=\"n\">out3_1</span><span class=\"p\">,</span> <span class=\"n\">out3_2</span> <span class=\"o\">=</span> <span class=\"n\">equation3</span><span class=\"p\">(</span><span class=\"n\">out2_3</span><span class=\"p\">,</span> <span class=\"n\">out1</span><span class=\"p\">)</span>\n    <span class=\"p\">...</span>\n    <span class=\"n\">out_final</span> <span class=\"o\">=</span> <span class=\"n\">equation_n</span><span class=\"p\">(</span><span class=\"n\">inputs</span><span class=\"p\">,</span> <span class=\"n\">out</span><span class=\"p\">,...)</span>\n    <span class=\"k\">return</span> <span class=\"n\">out_final</span>\n</code></pre></div></div>\n\n<p>This boils down to a dependency and ordering problem known as task scheduling.</p>\n\n<h2 id=\"dags-to-the-rescue\">DAGs to the rescue</h2>\n\n<p><img style=\"margin: 0 auto; display: block;\" src=\"https://mrocklin.github.io/blog/images/credit_models/snatch.jpg\" alt=\"snatch joke\" /></p>\n\n<p>A <a href=\"https://en.wikipedia.org/wiki/Directed_acyclic_graph\">directed acyclic graph</a> (DAG) is commonly used to solve task scheduling problems. Dask is a library for delayed task computation that makes use of directed graphs at its core. <a href=\"http://dask.pydata.org/en/latest/delayed.html\">dask.delayed</a> is a simple decorator that turns a Python function into a graph vertex. If I pass the output from one delayed function as a parameter to another delayed function, Dask creates a directed edge between them. Let’s look at an example:</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">add</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">y</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">add</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"mi\">4</span>\n</code></pre></div></div>\n<p>So here we have a function to add two numbers together. Let’s see what happens when we wrap it with <code class=\"language-plaintext highlighter-rouge\">dask.delayed</code>:</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">add</span> <span class=\"o\">=</span> <span class=\"n\">dask</span><span class=\"p\">.</span><span class=\"n\">delayed</span><span class=\"p\">(</span><span class=\"n\">add</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">left</span> <span class=\"o\">=</span> <span class=\"n\">add</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">left</span>\n<span class=\"n\">Delayed</span><span class=\"p\">(</span><span class=\"s\">'add-f6204fac-b067-40aa-9d6a-639fc719c3ce'</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<p><code class=\"language-plaintext highlighter-rouge\">add</code> now returns a <code class=\"language-plaintext highlighter-rouge\">Delayed</code> object. We can pass this as an argument back into our <code class=\"language-plaintext highlighter-rouge\">dask.delayed</code> function to start building out a chain of computation.</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">right</span> <span class=\"o\">=</span> <span class=\"n\">add</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">four</span> <span class=\"o\">=</span> <span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">left</span><span class=\"p\">,</span> <span class=\"n\">right</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">four</span><span class=\"p\">.</span><span class=\"n\">compute</span><span class=\"p\">()</span>\n<span class=\"mi\">4</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">four</span><span class=\"p\">.</span><span class=\"n\">visualize</span><span class=\"p\">()</span>\n</code></pre></div></div>\n\n<p>Below we can see how the DAG starts to come together.</p>\n\n<p><img style=\"margin: 0 auto; display: block;\" src=\"https://mrocklin.github.io/blog/images/credit_models/four.png\" alt=\"four graph\" /></p>\n\n<h2 id=\"mock-credit-example\">Mock credit example</h2>\n\n<p>Let’s assume I’m a mortgage bank and have 10 people applying for a mortgage. I want to estimate the group’s average likelihood to default based on years of credit history and income.</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">hist_yrs</span> <span class=\"o\">=</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">)</span>\n<span class=\"n\">incomes</span> <span class=\"o\">=</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<p>Let’s also assume that default is a function of the incremented years history and half the years experience. While this could be written like:</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">default</span><span class=\"p\">(</span><span class=\"n\">hist</span><span class=\"p\">,</span> <span class=\"n\">income</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"n\">hist</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">**</span> <span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">income</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<p>I know in the future that I will need the incremented history for another calculation and want to be able to reuse the code as well as avoid doing the computation twice. Instead, I can break those functions out:</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">from</span> <span class=\"nn\">dask</span> <span class=\"kn\">import</span> <span class=\"n\">delayed</span>\n\n<span class=\"o\">@</span><span class=\"n\">delayed</span>\n<span class=\"k\">def</span> <span class=\"nf\">increment</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">1</span>\n\n<span class=\"o\">@</span><span class=\"n\">delayed</span>\n<span class=\"k\">def</span> <span class=\"nf\">halve</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">y</span> <span class=\"o\">/</span> <span class=\"mi\">2</span>\n\n<span class=\"o\">@</span><span class=\"n\">delayed</span>\n<span class=\"k\">def</span> <span class=\"nf\">default</span><span class=\"p\">(</span><span class=\"n\">hist</span><span class=\"p\">,</span> <span class=\"n\">income</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">hist</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"n\">income</span>\n</code></pre></div></div>\n\n<p>Note how I wrapped the functions with <code class=\"language-plaintext highlighter-rouge\">delayed</code>. Now instead of returning a number these functions will return a <code class=\"language-plaintext highlighter-rouge\">Delayed</code> object. Even better is that these functions can also take <code class=\"language-plaintext highlighter-rouge\">Delayed</code> objects as inputs. It is this passing of <code class=\"language-plaintext highlighter-rouge\">Delayed</code> objects as inputs to other <code class=\"language-plaintext highlighter-rouge\">delayed</code> functions that allows Dask to construct the task graph. I can now call these functions on my data in the style of normal Python code:</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">inc_hist</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">increment</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">n</span> <span class=\"ow\">in</span> <span class=\"n\">hist_yrs</span><span class=\"p\">]</span>\n<span class=\"n\">halved_income</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">halve</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">n</span> <span class=\"ow\">in</span> <span class=\"n\">income</span><span class=\"p\">]</span>\n<span class=\"n\">estimated_default</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">default</span><span class=\"p\">(</span><span class=\"n\">hist</span><span class=\"p\">,</span> <span class=\"n\">income</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">hist</span><span class=\"p\">,</span> <span class=\"n\">income</span> <span class=\"ow\">in</span> <span class=\"nb\">zip</span><span class=\"p\">(</span><span class=\"n\">inc_hist</span><span class=\"p\">,</span> <span class=\"n\">halved_income</span><span class=\"p\">)]</span>\n</code></pre></div></div>\n<p>If you look at these variables, you will see that nothing has actually been calculated yet. They are all lists of <code class=\"language-plaintext highlighter-rouge\">Delayed</code> objects.</p>\n\n<p>Now, to get the average, I could just take the sum of <code class=\"language-plaintext highlighter-rouge\">estimated_default</code> but I want this to scale (and make a more interesting graph) so let’s do a merge-style reduction.</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"o\">@</span><span class=\"n\">delayed</span>\n<span class=\"k\">def</span> <span class=\"nf\">agg</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">y</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">merge</span><span class=\"p\">(</span><span class=\"n\">seq</span><span class=\"p\">):</span>\n    <span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">seq</span><span class=\"p\">)</span> <span class=\"o\">&lt;</span> <span class=\"mi\">2</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"n\">seq</span>\n    <span class=\"n\">middle</span> <span class=\"o\">=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">seq</span><span class=\"p\">)</span><span class=\"o\">//</span><span class=\"mi\">2</span>\n    <span class=\"n\">left</span> <span class=\"o\">=</span> <span class=\"n\">merge</span><span class=\"p\">(</span><span class=\"n\">seq</span><span class=\"p\">[:</span><span class=\"n\">middle</span><span class=\"p\">])</span>\n    <span class=\"n\">right</span> <span class=\"o\">=</span> <span class=\"n\">merge</span><span class=\"p\">(</span><span class=\"n\">seq</span><span class=\"p\">[</span><span class=\"n\">middle</span><span class=\"p\">:])</span>\n    <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">right</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"n\">left</span>\n    <span class=\"k\">return</span> <span class=\"p\">[</span><span class=\"n\">agg</span><span class=\"p\">(</span><span class=\"n\">left</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">right</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])]</span>\n\n<span class=\"n\">default_sum</span> <span class=\"o\">=</span> <span class=\"n\">merge</span><span class=\"p\">(</span><span class=\"n\">estimated_defaults</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<p>At this point <code class=\"language-plaintext highlighter-rouge\">default_sum</code> is a list of length 1 and that first element is the sum of estimated default for all applicants. To get the average, we divide by the number of applicants and call compute:</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">avg_default</span> <span class=\"o\">=</span> <span class=\"n\">default_sum</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">/</span> <span class=\"mi\">10</span>\n<span class=\"n\">avg_default</span><span class=\"p\">.</span><span class=\"n\">compute</span><span class=\"p\">()</span>  <span class=\"c1\"># 40.75\n</span></code></pre></div></div>\n\n<p>To see the computation graph that Dask will use, we call <code class=\"language-plaintext highlighter-rouge\">visualize</code>:</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">avg_default</span><span class=\"p\">.</span><span class=\"n\">visualize</span><span class=\"p\">()</span>\n</code></pre></div></div>\n\n<p><img src=\"https://mrocklin.github.io/blog/images/credit_models/dummy_graph.png\" style=\"margin: 0 auto; display: block;\" alt=\"default graph\" width=\"100%\" /></p>\n\n<p>And that is how Dask can be used to construct a complex system of equations with reusable intermediary calculations.</p>\n\n<h2 id=\"how-we-used-dask-in-practice\">How we used Dask in practice</h2>\n\n<p>For our credit modeling problem, we used Dask to make a custom data structure to represent the individual equations. Using the default example above, this looked something like the following:</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Default</span><span class=\"p\">(</span><span class=\"n\">Equation</span><span class=\"p\">):</span>\n    <span class=\"n\">inputs</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s\">'inc_hist'</span><span class=\"p\">,</span> <span class=\"s\">'halved_income'</span><span class=\"p\">]</span>\n    <span class=\"n\">outputs</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s\">'defaults'</span><span class=\"p\">]</span>\n\n    <span class=\"o\">@</span><span class=\"n\">delayed</span>\n    <span class=\"k\">def</span> <span class=\"nf\">equation</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">inc_hist</span><span class=\"p\">,</span> <span class=\"n\">halved_income</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">inc_hist</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"n\">halved_income</span>\n</code></pre></div></div>\n\n<p>This allows us to write each equation as its own isolated function and mark its inputs and outputs. With this set of equation objects, we can determine the order of computation (with a <a href=\"https://en.wikipedia.org/wiki/Topological_sorting\">topological sort</a>) and let Dask handle the graph generation and computation. This eliminates the onerous task of manually passing around the arguments in the code base. Below is an example task graph for one particular model that the bank actually does.</p>\n\n<p><a href=\"https://mrocklin.github.io/blog/images/credit_models/simple.svg\">\n  <img src=\"https://mrocklin.github.io/blog/images/credit_models/simple.svg\" alt=\"calc task graph\" width=\"100%\" />\n  </a></p>\n\n<p>This graph was a bit too large to render with the normal <code class=\"language-plaintext highlighter-rouge\">my_task.visualize()</code> method, so instead we rendered it with <a href=\"https://gephi.org\">Gephi</a> to make the pretty colored graph above. The chaotic upper region of this graph is the individual equation calculations. Zooming in we can see the entry point, our input pandas DataFrame, as the large orange circle at the top and how it gets fed into many of the equations.</p>\n\n<p><a href=\"https://mrocklin.github.io/blog/images/credit_models/simple-model.svg\">\n  <img src=\"https://mrocklin.github.io/blog/images/credit_models/simple-model.svg\" alt=\"zoomed model section\" width=\"100%\" /></a></p>\n\n<p>The output of the model is about 100 times the size of the input so we do some aggregation at the end via tree reduction. This accounts for the more structured bottom half of the graph. The large green node at the bottom is our final output.</p>\n\n<p><a href=\"https://mrocklin.github.io/blog/images/credit_models/simple-agg.svg\">\n  <img src=\"https://mrocklin.github.io/blog/images/credit_models/simple-agg.svg\" alt=\"zoomed agg section\" width=\"100%\" /></a></p>\n\n<h2 id=\"final-thoughts\">Final Thoughts</h2>\n\n<p>With our Dask-based data structure, we spend more of our time writing model code rather than maintenance of the engine itself. This allows a clean separation between our analysts that design and write our models, and our computational system that runs them.  Dask also offers a number of advantages not covered above. For example, with Dask you also get access to <a href=\"https://distributed.readthedocs.io/en/latest/web.html\">diagnostics</a> such as time spent running each task and resources used. Also, you can easily distribute your computation with <a href=\"https://distributed.readthedocs.io/en/latest/\">dask distributed</a> with relative ease. Now if I want to run our model across larger-than-memory data or on a distributed cluster, we don’t have to worry about rewriting our code to incorporate something like Spark. Finally, Dask allows you to give pandas-capable business analysts or less technical folks access to large datasets with the <a href=\"http://dask.pydata.org/en/latest/dataframe.html\">dask dataframe</a>.</p>\n\n<h2 id=\"full-example\">Full Example</h2>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">from</span> <span class=\"nn\">dask</span> <span class=\"kn\">import</span> <span class=\"n\">delayed</span>\n\n\n<span class=\"o\">@</span><span class=\"n\">delayed</span>\n<span class=\"k\">def</span> <span class=\"nf\">increment</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">1</span>\n\n\n<span class=\"o\">@</span><span class=\"n\">delayed</span>\n<span class=\"k\">def</span> <span class=\"nf\">halve</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">y</span> <span class=\"o\">/</span> <span class=\"mi\">2</span>\n\n\n<span class=\"o\">@</span><span class=\"n\">delayed</span>\n<span class=\"k\">def</span> <span class=\"nf\">default</span><span class=\"p\">(</span><span class=\"n\">hist</span><span class=\"p\">,</span> <span class=\"n\">income</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">hist</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"n\">income</span>\n\n\n<span class=\"o\">@</span><span class=\"n\">delayed</span>\n<span class=\"k\">def</span> <span class=\"nf\">agg</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">y</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">merge</span><span class=\"p\">(</span><span class=\"n\">seq</span><span class=\"p\">):</span>\n    <span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">seq</span><span class=\"p\">)</span> <span class=\"o\">&lt;</span> <span class=\"mi\">2</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"n\">seq</span>\n    <span class=\"n\">middle</span> <span class=\"o\">=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">seq</span><span class=\"p\">)</span><span class=\"o\">//</span><span class=\"mi\">2</span>\n    <span class=\"n\">left</span> <span class=\"o\">=</span> <span class=\"n\">merge</span><span class=\"p\">(</span><span class=\"n\">seq</span><span class=\"p\">[:</span><span class=\"n\">middle</span><span class=\"p\">])</span>\n    <span class=\"n\">right</span> <span class=\"o\">=</span> <span class=\"n\">merge</span><span class=\"p\">(</span><span class=\"n\">seq</span><span class=\"p\">[</span><span class=\"n\">middle</span><span class=\"p\">:])</span>\n    <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">right</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"n\">left</span>\n    <span class=\"k\">return</span> <span class=\"p\">[</span><span class=\"n\">agg</span><span class=\"p\">(</span><span class=\"n\">left</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">right</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])]</span>\n\n\n<span class=\"n\">hist_yrs</span> <span class=\"o\">=</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">)</span>\n<span class=\"n\">incomes</span> <span class=\"o\">=</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">)</span>\n<span class=\"n\">inc_hist</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">increment</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">n</span> <span class=\"ow\">in</span> <span class=\"n\">hist_yrs</span><span class=\"p\">]</span>\n<span class=\"n\">halved_income</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">halve</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">n</span> <span class=\"ow\">in</span> <span class=\"n\">incomes</span><span class=\"p\">]</span>\n<span class=\"n\">estimated_defaults</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">default</span><span class=\"p\">(</span><span class=\"n\">hist</span><span class=\"p\">,</span> <span class=\"n\">income</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">hist</span><span class=\"p\">,</span> <span class=\"n\">income</span> <span class=\"ow\">in</span> <span class=\"nb\">zip</span><span class=\"p\">(</span><span class=\"n\">inc_hist</span><span class=\"p\">,</span> <span class=\"n\">halved_income</span><span class=\"p\">)]</span>\n<span class=\"n\">default_sum</span> <span class=\"o\">=</span> <span class=\"n\">merge</span><span class=\"p\">(</span><span class=\"n\">estimated_defaults</span><span class=\"p\">)</span>\n<span class=\"n\">avg_default</span> <span class=\"o\">=</span> <span class=\"n\">default_sum</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">/</span> <span class=\"mi\">10</span>\n<span class=\"n\">avg_default</span><span class=\"p\">.</span><span class=\"n\">compute</span><span class=\"p\">()</span>\n<span class=\"n\">avg_default</span><span class=\"p\">.</span><span class=\"n\">visualize</span><span class=\"p\">()</span>  <span class=\"c1\"># requires graphviz and python-graphviz to be installed\n</span></code></pre></div></div>\n\n<h2 id=\"acknowledgements\">Acknowledgements</h2>\n\n<p>Special thanks to Matt Rocklin, Michael Grant, Gus Cavanagh, and Rory Merritt for their feedback when writing this article.</p>"
}