{
  "title": "Meta-Learning Millions of Hyper-parameters using the Implicit Function Theorem",
  "description": "<p>Last night on the train I read this nice paper by David Duvenaud and colleagues. Around midnight I got a calendar notification \"it's David Duvenaud's birthday\". So I thought it's time for a David Duvenaud birthday special (don't get too</p>",
  "link": "https://www.inference.vc/meta-learning-with-the-implicit-function-theorem/",
  "guid": "5dcd5c2289b7c10044af6516",
  "dc:creator": "Ferenc Huszar",
  "pubDate": "Thu, 14 Nov 2019 15:33:49 GMT",
  "media:content": "",
  "content:encoded": "<img src=\"https://www.inference.vc/content/images/2019/11/Screen-Shot-2019-11-14-at-3.03.24-PM.png\" alt=\"Meta-Learning Millions of Hyper-parameters using the Implicit Function Theorem\"><p>Last night on the train I read this nice paper by David Duvenaud and colleagues. Around midnight I got a calendar notification \"it's David Duvenaud's birthday\". So I thought it's time for a David Duvenaud birthday special (don't get too excited David, I won't make it an annual tradition...)</p><ul><li>Jonathan Lorraine, Paul Vicol, David Duvenaud (2019) <a href=\"https://arxiv.org/abs/1911.02590\">Optimizing Millions of Hyperparameters by Implicit Differentiation</a></li></ul><h2 id=\"background\">Background</h2><p>I recently covered<a href=\"https://www.inference.vc/notes-on-imaml-meta-learning-without-differentiating-through/\"> iMAML: the meta-learning algorithm</a> that makes use of implicit gradients to sidestep backpropagating through the inner loop optimization in meta-learning/hyperparameter tuning. The method presented in (<a href=\"https://arxiv.org/abs/1911.02590\">Lorraine et al, 2019</a>) uses the same high-level idea, but introduces a different - on the surface less fiddly - approximation to the crucial inverse Hessian. I won't spend a lot of time introducing the whole meta-learning setup from scratch, you can use the previous post as a starting point.</p><h2 id=\"implicit-function-theorem\">Implicit Function Theorem</h2><p>Many - though not all - meta-learning or hyperparameter optimization problems can be stated as nested optimization problems. If we have some hyperparameters $\\lambda$ and some parameters $\\theta$ we are interested in</p><p>$$<br>\\operatorname{argmin}_\\lambda \\mathcal{L}_V (\\operatorname{argmin}_\\theta \\mathcal{L}_T(\\theta, \\lambda)),<br>$$</p><p>Where $\\mathcal{L}_T$ is some training loss and $\\mathcal{L}_V$ a validation loss. The optimal parameter to the training problem, $\\theta^\\ast$ implicitly depends on the hyperparameters $\\lambda$:</p><p>$$<br>\\theta^\\ast(\\lambda) = \\operatorname{argmin} f(\\theta, \\lambda)<br>$$</p><p>If this implicit function mapping $\\lambda$ to $\\theta^\\ast$ is differentiable, and subject to some other conditions, the implicit function theorem states that its derivative is</p><p>$$<br>\\left.\\frac{\\partial\\theta^{\\ast}}{\\partial\\lambda}\\right\\vert_{\\lambda_0} = \\left.-\\left[\\frac{\\partial^2 \\mathcal{L}_T}{\\partial \\theta \\partial \\theta}\\right]^{-1}\\frac{\\partial^2\\mathcal{L}_T}{\\partial \\theta \\partial \\lambda}\\right\\vert_{\\lambda_0, \\theta^\\ast(\\lambda_0)}<br>$$</p><p>The formula we obtained for iMAML is a special case of this where the $\\frac{\\partial^2\\mathcal{L}_T}{\\partial \\theta \\partial \\lambda}$ is the identity This is because there, the hyperparameter controls a quadratic regularizer $\\frac{1}{2}\\|\\theta - \\lambda\\|^2$, and indeed if you differentiate this with respect to both $\\lambda$ and $\\theta$ you are left with a constant times identity.</p><p>The primary difficulty of course is approximating the inverse Hessian, or indeed matrix-vector products involving this inverse Hessian. This is where iMAML and the method proposed by <a href=\"https://arxiv.org/abs/1911.02590\">Lorraine et al, (2019</a>) differ. iMAML uses a conjugate gradient method to iteratively approximate the gradient. In this work, they use a Neumann series approximation, which, for a matrix $U$ looks as follows:</p><p>$$<br>U^{-1} = \\sum_{i=0}^{\\infty}(I - U)^i<br>$$</p><p>This is basically a generalization of the better known sum of a geometric series: if you have a scalar $\\vert u \\vert<1$ then</p><p>$$<br>\\sum_{i=0}^\\infty q^i = \\frac{1}{1-q}.<br>$$</p><p>Using a finite truncation of the Neumann series one can approximate the inverse Hessian in the following way:</p><p>$$<br>\\left[\\frac{\\partial^2 \\mathcal{L}_T}{\\partial \\theta \\partial \\theta}\\right]^{-1} \\approx \\sum_{i=1}^j \\left(I - \\frac{\\partial^2 \\mathcal{L}_T}{\\partial \\theta \\partial \\theta}\\right)^i.<br>$$</p><p>This Neumann series approximation, at least on the surface, seems significantly less hassle to implement than running a conjugate gradient optimization step.</p><h2 id=\"experiments\">Experiments</h2><p>One of the fun bits of this paper is the interesting set of experiments the authors used to demonstrate the versatility of this approach. For example, in this framework, one can treat the training dataset as a hyperparameter. Optimizing pixel values in a small training dataset, one image per class, allowed the authors to \"distill\" a dataset into a set of prototypical examples. If you train your neural net on this distilled dataset, you get relatively good validation performance. The results are not quite as image-like as one would imagine, but for some classes, like bikes, you even get recognisable shapes:</p><p>In another experiment the authors trained a network to perform data augmentation, treating parameters of this network as a hyperparameter of a learning task. In both of these cases, the number of hyperparameters optimized were in the hundreds of thousands, way beyond the number we usually consider as hyperparameters.</p><h2 id=\"limitations\">Limitations</h2><p>This method inherits some of the limitations I already discussed with <a href=\"https://www.inference.vc/notes-on-imaml-meta-learning-without-differentiating-through/\">iMAML.</a> Please also see the comments where various people gave pointers to work that overcomes some of these limitations.</p><p>Most crucially, methods based on implicit gradients assume that your learning algorithm (inner loop) finds a unique, optimal parameter that minimises some loss function. This is simply not a valid assumption for SGD where different random seeds might produce very different and differently behaving optima.</p><p>Secondly, this assumption only allows for hyperparameters that control the loss function, but not for ones that control other aspects of the optimization algorithm, such as learning rates, batch sizes or initialization. For those kind of situations, explicit differentiation may still be the most competitive solution. On that note, I also recommend reading this recent paper on <a href=\"https://arxiv.org/abs/1910.01727\">generalized inner-loop meta-learnin</a>g and the associated pytorch package <a href=\"https://github.com/facebookresearch/higher\">higher</a>.</p><h2 id=\"conclusion\">Conclusion</h2><p>Happy birthday David. Nice work!</p>"
}