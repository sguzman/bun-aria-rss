{
  "title": "Using SymPy within Theano",
  "link": "",
  "updated": "2013-08-14T00:00:00+00:00",
  "id": "https://mrocklin.github.io/blog/work/2013/08/14/SymPy-Theano-part-4",
  "content": "<p>Several months ago I published a sequence of blogposts about using SymPy and Theano together to generate efficient mathematical codes.  Main points from the posts were as follows</p>\n\n<ul>\n  <li><a href=\"http://matthewrocklin.com/blog/work/2013/03/19/SymPy-Theano-part-1/\">Code Generation</a>: We created a drop-in replacement for SymPy’s code generation with a thin layer to Theano.</li>\n  <li><a href=\"http://matthewrocklin.com/blog/work/2013/03/28/SymPy-Theano-part-2/\">Scalar Simplificaiton</a>:  We used SymPy’s simplification routines to accelerate programs prior to code printing in Theano</li>\n  <li><a href=\"http://matthewrocklin.com/blog/work/2013/04/05/SymPy-Theano-part-3/\">Matrix Expressions</a>:  We generate fast blocked numeric linear algebra programs from SymPy’s matrix expressions using Theano array operations.</li>\n</ul>\n\n<p>A week ago <a href=\"https://groups.google.com/d/topic/sympy/VtaxCRNO4sE/discussion\">someone popped up on the SymPy mailing list</a> asking if a particular SymPy operation (<code class=\"language-plaintext highlighter-rouge\">sympy.Piecewise</code>) could be supported in the SymPy-Theano translation.  Because Theano has a similar operation (<code class=\"language-plaintext highlighter-rouge\">theano.tensor.switch</code>) it was simple to add this translation.  In general though this post raised some interesting questions:</p>\n\n<ul>\n  <li>Is there a way to avoid constantly making new translations for operations that exist both in SymPy and in Theano?</li>\n  <li>What do we do with SymPy’s more exotic operations for which no Theano analog exists?  E.g. how do we generate code for factorial or bessel functions?</li>\n</ul>\n\n<p>In an attempt to resolve these issues we recently merged a general <code class=\"language-plaintext highlighter-rouge\">SymPyCCode</code> operation into the <code class=\"language-plaintext highlighter-rouge\">Theano</code> project.  It enables the expression of a Theano scalar operation through SymPy expressions using SymPy’s original code generation capability.  For example we can create a simple addition operation like so</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"kn\">from</span> <span class=\"nn\">sympy</span> <span class=\"kn\">import</span> <span class=\"n\">Symbol</span><span class=\"p\">,</span> <span class=\"n\">symbols</span>\n<span class=\"kn\">from</span> <span class=\"nn\">theano.scalar.basic_sympy</span> <span class=\"kn\">import</span> <span class=\"n\">SymPyCCode</span>\n\n<span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">symbols</span><span class=\"p\">(</span><span class=\"s\">'x,y'</span><span class=\"p\">)</span>            <span class=\"c1\"># SymPy Symbols\n</span><span class=\"n\">add</span> <span class=\"o\">=</span> <span class=\"n\">SymPyCCode</span><span class=\"p\">([</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">],</span> <span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">y</span><span class=\"p\">)</span>  <span class=\"c1\"># A Theano addition operator</span></code></pre>\n</figure>\n\n<p>Theano operators can be applied to Theano variables to make compound Theano expressions</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"kn\">from</span> <span class=\"nn\">theano.scalar</span> <span class=\"kn\">import</span> <span class=\"n\">floats</span>\n\n<span class=\"n\">xt</span><span class=\"p\">,</span> <span class=\"n\">yt</span> <span class=\"o\">=</span> <span class=\"n\">floats</span><span class=\"p\">(</span><span class=\"s\">'xy'</span><span class=\"p\">)</span>\n<span class=\"n\">zt</span> <span class=\"o\">=</span> <span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">xt</span><span class=\"p\">,</span> <span class=\"n\">yt</span><span class=\"p\">)</span></code></pre>\n</figure>\n\n<p>Theano can then turn these expressions into functions</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"kn\">from</span> <span class=\"nn\">theano</span> <span class=\"kn\">import</span> <span class=\"n\">function</span>\n\n<span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">function</span><span class=\"p\">([</span><span class=\"n\">xt</span><span class=\"p\">,</span> <span class=\"n\">yt</span><span class=\"p\">],</span> <span class=\"n\">zt</span><span class=\"p\">)</span>\n<span class=\"n\">f</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>  <span class=\"c1\"># prints 5.0</span></code></pre>\n</figure>\n\n<p>So we can describe scalar operations in SymPy and use them directly in Theano without having to translate anything.  Of course, the <code class=\"language-plaintext highlighter-rouge\">add</code> operation is already native in Theano.  This is more useful for complex scalar expressions, particularly if Theano does not already have such an operation</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"kn\">from</span> <span class=\"nn\">sympy</span> <span class=\"kn\">import</span> <span class=\"n\">gamma</span>\n<span class=\"n\">theano_gamma</span> <span class=\"o\">=</span> <span class=\"n\">SymPyCCode</span><span class=\"p\">([</span><span class=\"n\">x</span><span class=\"p\">],</span> <span class=\"n\">gamma</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">))</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">sympy.stats.crv_types</span> <span class=\"kn\">import</span> <span class=\"n\">NormalDistribution</span>\n<span class=\"n\">mu</span> <span class=\"o\">=</span> <span class=\"n\">Symbol</span><span class=\"p\">(</span><span class=\"s\">'mu'</span><span class=\"p\">,</span> <span class=\"n\">bounded</span><span class=\"o\">=</span><span class=\"bp\">True</span><span class=\"p\">)</span>\n<span class=\"n\">sigma</span> <span class=\"o\">=</span> <span class=\"n\">Symbol</span><span class=\"p\">(</span><span class=\"s\">'sigma'</span><span class=\"p\">,</span> <span class=\"n\">positive</span><span class=\"o\">=</span><span class=\"bp\">True</span><span class=\"p\">)</span>\n<span class=\"n\">normal</span> <span class=\"o\">=</span> <span class=\"n\">SymPyCCode</span><span class=\"p\">([</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">mu</span><span class=\"p\">,</span> <span class=\"n\">sigma</span><span class=\"p\">],</span> <span class=\"n\">NormalDistribution</span><span class=\"p\">(</span><span class=\"n\">mu</span><span class=\"p\">,</span> <span class=\"n\">sigma</span><span class=\"p\">)(</span><span class=\"n\">x</span><span class=\"p\">))</span></code></pre>\n</figure>\n\n<h2 id=\"under-the-hood\">Under the Hood</h2>\n\n<p>Internally the <code class=\"language-plaintext highlighter-rouge\">SymPyCCode</code> op calls SymPy’s C code printers to generate an implementation of the scalar operation.  For example the following SymPy code generates C code to compute the probability density function of a normal distribution.</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">sympy.printing</span> <span class=\"kn\">import</span> <span class=\"n\">ccode</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">ccode</span><span class=\"p\">(</span><span class=\"n\">NormalDistribution</span><span class=\"p\">(</span><span class=\"n\">mu</span><span class=\"p\">,</span> <span class=\"n\">sigma</span><span class=\"p\">)(</span><span class=\"n\">x</span><span class=\"p\">))</span>\n<span class=\"p\">(</span><span class=\"mf\">1.0</span><span class=\"n\">L</span><span class=\"o\">/</span><span class=\"mf\">2.0</span><span class=\"n\">L</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"n\">sqrt</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"n\">exp</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mf\">1.0</span><span class=\"n\">L</span><span class=\"o\">/</span><span class=\"mf\">2.0</span><span class=\"n\">L</span><span class=\"o\">*</span><span class=\"nb\">pow</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"n\">mu</span> <span class=\"o\">+</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">/</span><span class=\"nb\">pow</span><span class=\"p\">(</span><span class=\"n\">sigma</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">))</span><span class=\"o\">/</span><span class=\"p\">(</span><span class=\"n\">sqrt</span><span class=\"p\">(</span><span class=\"n\">M_PI</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"n\">sigma</span><span class=\"p\">)</span></code></pre>\n</figure>\n\n<p>Theano is then able to use this generated C code within its generated C program.  Theano still handles memory, common sub-expressions, arrays, etc. but is now able to leverage SymPy to generate low-level kernels for mathematical operations.</p>\n\n<h2 id=\"but-dont-use-this\">But Don’t Use This</h2>\n\n<p>But you shouldn’t use this mechanism if you don’t have to.  Recall from the <a href=\"http://matthewrocklin.com/blog/work/2013/03/19/SymPy-Theano-part-1/\">first post</a> that SymPy can translate many standard operations to Theano directly, without having to wrap the SymPy expressions up in a black box Theano operation.  Native translation enables Theano to  use many additional optimizations like the use of the GPU, automatic differentiation, and common sub-expression elimination across many expressions.  This approach is mainly for cases where your complex scalar expressions don’t translate well to Theano.  In some cases the SymPyCCode op may also provide better performance (maybe SymPy’s generated C code is a bit tighter?)</p>\n\n<h2 id=\"future-work\">Future Work</h2>\n\n<p>We need to improve SymPy’s code printers.  While they support all the standard operators they neglect to cover the really interesting cases like bessel functions or factorial.  These are cases where the numerical analysis community can concisely describe the “right way” to compute many of these operations in isolation.   For example the factorial of <code class=\"language-plaintext highlighter-rouge\">n</code> can be computed as <code class=\"language-plaintext highlighter-rouge\">gamma(n+1)</code>, a fact rarely known by mainstream programmers.</p>\n\n\\[n! = \\Gamma(n+1) \\;\\; \\forall n \\in \\mathbb{N}\\]\n\n<p>I’ve been thinking about the right way to do this generally.  Right now my thought is that we should create a new <code class=\"language-plaintext highlighter-rouge\">expand</code> hint for computation.  If you have thoughts I’d love to hear about them; please speak up in the comments.</p>\n\n<h2 id=\"example\">Example</h2>\n\n<p>There are a number of ways to compute a SymPy expression numerically.  I’m going to explicily run throuh an example with a few of them below.  You should ignore this section if these are already familiar to you.</p>\n\n<p>We create a function to evaluate a normal distribution probability density function for a particular mean and standard deviation across a range of values for <code class=\"language-plaintext highlighter-rouge\">x</code>.</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"c1\"># The Target Expression\n</span><span class=\"kn\">from</span> <span class=\"nn\">sympy</span> <span class=\"kn\">import</span> <span class=\"n\">Symbol</span>\n<span class=\"kn\">from</span> <span class=\"nn\">sympy.stats.crv_types</span> <span class=\"kn\">import</span> <span class=\"n\">NormalDistribution</span>\n<span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">Symbol</span><span class=\"p\">(</span><span class=\"s\">'x'</span><span class=\"p\">)</span>\n<span class=\"n\">mu</span> <span class=\"o\">=</span> <span class=\"n\">Symbol</span><span class=\"p\">(</span><span class=\"s\">'mu'</span><span class=\"p\">,</span> <span class=\"n\">bounded</span><span class=\"o\">=</span><span class=\"bp\">True</span><span class=\"p\">)</span>\n<span class=\"n\">sigma</span> <span class=\"o\">=</span> <span class=\"n\">Symbol</span><span class=\"p\">(</span><span class=\"s\">'sigma'</span><span class=\"p\">,</span> <span class=\"n\">positive</span><span class=\"o\">=</span><span class=\"bp\">True</span><span class=\"p\">)</span>\n\n<span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">NormalDistribution</span><span class=\"p\">(</span><span class=\"n\">mu</span><span class=\"p\">,</span> <span class=\"n\">sigma</span><span class=\"p\">)(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Make a numpy `ufunc` with Pure SymPy\n</span><span class=\"kn\">from</span> <span class=\"nn\">sympy.utilities.autowrap</span> <span class=\"kn\">import</span> <span class=\"n\">ufuncify</span>\n<span class=\"n\">f_ufunc</span> <span class=\"o\">=</span> <span class=\"n\">ufuncify</span><span class=\"p\">([</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">mu</span><span class=\"p\">,</span> <span class=\"n\">sigma</span><span class=\"p\">],</span> <span class=\"n\">result</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Make a Theano function with SymPy\n</span><span class=\"kn\">from</span> <span class=\"nn\">sympy.printing.theanocode</span> <span class=\"kn\">import</span> <span class=\"n\">theano_function</span>\n<span class=\"n\">f_sym_theano</span> <span class=\"o\">=</span> <span class=\"n\">theano_function</span><span class=\"p\">([</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">mu</span><span class=\"p\">,</span> <span class=\"n\">sigma</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"n\">result</span><span class=\"p\">],</span> <span class=\"n\">dims</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">mu</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">sigma</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">})</span>\n\n<span class=\"c1\"># Make a special Theano op using a SymPyCCode\n</span><span class=\"kn\">from</span> <span class=\"nn\">theano.scalar.basic_sympy</span> <span class=\"kn\">import</span> <span class=\"n\">SymPyCCode</span>\n<span class=\"kn\">from</span> <span class=\"nn\">theano.tensor.elemwise</span> <span class=\"kn\">import</span> <span class=\"n\">Elemwise</span>\n<span class=\"n\">normal_op</span> <span class=\"o\">=</span> <span class=\"n\">Elemwise</span><span class=\"p\">(</span><span class=\"n\">SymPyCCode</span><span class=\"p\">([</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">mu</span><span class=\"p\">,</span> <span class=\"n\">sigma</span><span class=\"p\">],</span> <span class=\"n\">result</span><span class=\"p\">))</span>\n\n<span class=\"c1\"># And then use that `op` in plain Theano code\n</span><span class=\"kn\">import</span> <span class=\"nn\">theano</span>\n<span class=\"n\">xt</span>     <span class=\"o\">=</span> <span class=\"n\">theano</span><span class=\"p\">.</span><span class=\"n\">tensor</span><span class=\"p\">.</span><span class=\"n\">vector</span><span class=\"p\">(</span><span class=\"s\">'x'</span><span class=\"p\">)</span>\n<span class=\"n\">mut</span>    <span class=\"o\">=</span> <span class=\"n\">theano</span><span class=\"p\">.</span><span class=\"n\">scalar</span><span class=\"p\">.</span><span class=\"n\">float32</span><span class=\"p\">(</span><span class=\"s\">'mu'</span><span class=\"p\">)</span>\n<span class=\"n\">sigmat</span> <span class=\"o\">=</span> <span class=\"n\">theano</span><span class=\"p\">.</span><span class=\"n\">scalar</span><span class=\"p\">.</span><span class=\"n\">float32</span><span class=\"p\">(</span><span class=\"s\">'sigma'</span><span class=\"p\">)</span>\n\n<span class=\"n\">ft</span> <span class=\"o\">=</span> <span class=\"n\">theano</span><span class=\"p\">.</span><span class=\"n\">function</span><span class=\"p\">([</span><span class=\"n\">xt</span><span class=\"p\">,</span> <span class=\"n\">mut</span><span class=\"p\">,</span> <span class=\"n\">sigmat</span><span class=\"p\">],</span> <span class=\"n\">normal_op</span><span class=\"p\">(</span><span class=\"n\">xt</span><span class=\"p\">,</span> <span class=\"n\">mut</span><span class=\"p\">,</span> <span class=\"n\">sigmat</span><span class=\"p\">))</span></code></pre>\n</figure>"
}