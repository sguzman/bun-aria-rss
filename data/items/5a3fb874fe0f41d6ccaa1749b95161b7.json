{
  "id": "tag:blogger.com,1999:blog-1176949257541686127.post-3294366029953017136",
  "published": "2022-09-13T12:59:00.000-04:00",
  "updated": "2022-09-13T12:59:14.644-04:00",
  "category": [
    "",
    ""
  ],
  "title": "Use-after-freedom: MiraclePtr",
  "content": "<span class=\"byline-author\"> Posted by Adrian Taylor, Bartek Nowierski and Kentaro Hara on behalf of the MiraclePtr team</span> <p>Memory safety bugs are the most numerous category of Chrome security issues and we’re continuing to <a href=\"https://security.googleblog.com/2021/09/an-update-on-memory-safety-in-chrome.html\">investigate many solutions</a> – both in C++ and in new programming languages. The most common type of memory safety bug is the “use-after-free”. We <a href=\"https://security.googleblog.com/2022/05/retrofitting-temporal-memory-safety-on-c.html\">recently posted about</a> an exciting series of technologies designed to prevent these. Those technologies (collectively, *Scan, pronounced “star scan”) are very powerful but likely require hardware support for sufficient performance. </p><p>Today we’re going to talk about a different approach to solving the same type of bugs. </p><p>It’s hard, if not impossible, to avoid use-after-frees in a non-trivial codebase. It’s rarely a mistake by a single programmer. Instead, one programmer makes reasonable assumptions about how a bit of code will work, then a later change invalidates those assumptions. Suddenly, the data isn’t valid as long as the original programmer expected, and an exploitable bug results. </p><p>These bugs have real consequences. For example, according to Google Threat Analysis Group, a <a href=\"https://crbug.com/1296150\">use-after-free in the ChromeHTML engine</a> was <a href=\"https://blog.google/threat-analysis-group/countering-threats-north-korea/\">exploited this year</a> by North Korea. </p><p>Half of the known exploitable bugs in Chrome are use-after-frees:  <div class=\"separator\" style=\"clear: both;\"><a href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjol0tDHrKfloO3-RsAhVwMGPRBFmg8FmM2nMbHfA4kPTHu4PVaoqFAkdKXkE63ePSIC4U4rH8pMSa8FfLYY-0CdahMPzcP_GqoILj0bBtquIwVuf-oLRpnZqe6cNBgTHv6LPnM_l1YrkqPHote0DMbIkYy7BZjDiZITG2u05T9YoxV6OqhnonD1TlY9g/s512/bug%20types.png\" style=\"display: block; padding: 1em 0; text-align: center; \"><img alt=\"\" border=\"0\" width=\"600\" data-original-height=\"317\" data-original-width=\"512\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjol0tDHrKfloO3-RsAhVwMGPRBFmg8FmM2nMbHfA4kPTHu4PVaoqFAkdKXkE63ePSIC4U4rH8pMSa8FfLYY-0CdahMPzcP_GqoILj0bBtquIwVuf-oLRpnZqe6cNBgTHv6LPnM_l1YrkqPHote0DMbIkYy7BZjDiZITG2u05T9YoxV6OqhnonD1TlY9g/s600/bug%20types.png\"/></a></div> <p><strong>Diving Deeper: Not All Use-After-Free Bugs Are Equal</strong>  </p><p>Chrome has a <a href=\"https://www.chromium.org/developers/design-documents/multi-process-architecture/\">multi-process architecture</a>, partly to ensure that web content is isolated into a sandboxed “renderer” process where little harm can occur. An attacker therefore usually needs to find and exploit <em>two</em> vulnerabilities - one to achieve code execution in the renderer process, and another bug to break out of the sandbox. </p><p>The first stage is often the easier one. The attacker has lots of influence in the renderer process. It’s easy to arrange memory in a specific way, and the renderer process acts upon many different kinds of web content, giving a large “attack surface” that could potentially be exploited. </p><p>The second stage, escaping the renderer sandbox, is trickier. Attackers have two options how to do this: </p><ol> <li>They can exploit a bug in the underlying operating system (OS) through the limited interfaces available inside Chrome’s sandbox.  <li>Or, they can exploit a bug in a more powerful, privileged part of Chrome - like the “browser” process. This process coordinates all the other bits of Chrome, so fundamentally <em>has</em> to be all-powerful. </li></ol><p>We imagine the attackers squeezing through the narrow part of a funnel:  <div class=\"separator\" style=\"clear: both;\"><a href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjrD_PVCwSIrVn0tVWBs7b0PueDknbg8BrwznIfKHmYqgNFlGuVupFVZaPMSO9uoj4QawGujzyOS42-Nsemdl9AXD3gOaUFeqnBkhVd0Aem99UK5C9bt6trfnF_4UplnWFdXUrXfM-P4QvnZq81lrsz8o7M6QLZaKzSSLm7_ni10BPT2xaLSyhITCHE9A/s1600/Screenshot%202022-09-13%207.28.31%20AM.png\" style=\"display: block; padding: 1em 0; text-align: center; \"><img alt=\"\" border=\"0\" data-original-height=\"405\" data-original-width=\"646\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjrD_PVCwSIrVn0tVWBs7b0PueDknbg8BrwznIfKHmYqgNFlGuVupFVZaPMSO9uoj4QawGujzyOS42-Nsemdl9AXD3gOaUFeqnBkhVd0Aem99UK5C9bt6trfnF_4UplnWFdXUrXfM-P4QvnZq81lrsz8o7M6QLZaKzSSLm7_ni10BPT2xaLSyhITCHE9A/s1600/Screenshot%202022-09-13%207.28.31%20AM.png\"/></a></div> If we can reduce the size of the narrow part of the funnel, we will make it as hard as possible for attackers to assemble a full exploit chain. We can reduce the size of the orange slice by removing access to more OS interfaces within the renderer process sandbox, and we’re continuously working on that. The MiraclePtr project aims to reduce the size of the blue slice. </p><p>Here’s a sample of 100 recent high severity Chrome security bugs that made it to the stable channel, divided by root cause and by the process they affect. </p><p> <div class=\"separator\" style=\"clear: both;\"><a href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjNa-V0mokSe10I_waRxQNuH_GNg6kqPyAszlWZ2EqMIgiySJcLWQ_FQQYSCl5dnF-u7acqGaqNE1bKXKJGG9b2GKKzIDMrKQWPhJWdp-0Te2HZYOecDVpLJXamMCzdO8ErcezDkFly1D19YlPrPHDHDf01O8GisMqoCOnfsAK8jWl9W8_JeUDJglHLNw/s512/bugs%20chart%202.png\" style=\"display: block; padding: 1em 0; text-align: center; \"><img alt=\"\" border=\"0\" width=\"600\" data-original-height=\"317\" data-original-width=\"512\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjNa-V0mokSe10I_waRxQNuH_GNg6kqPyAszlWZ2EqMIgiySJcLWQ_FQQYSCl5dnF-u7acqGaqNE1bKXKJGG9b2GKKzIDMrKQWPhJWdp-0Te2HZYOecDVpLJXamMCzdO8ErcezDkFly1D19YlPrPHDHDf01O8GisMqoCOnfsAK8jWl9W8_JeUDJglHLNw/s600/bugs%20chart%202.png\"/></a></div></p><p>You might notice: </p><ul> <li>This doesn’t quite add up to 100 - that’s because a few bugs were in other processes beyond the renderer or browser.  <li>We claimed that the browser process is the more difficult part to exploit, yet there are more potentially-exploitable bugs! That may be so, but we believe they are typically harder to exploit because the attacker has less control over memory layout. </li></ul><p>As you can see, the biggest category of bugs in each process is: V8 in the renderer process (JavaScript engine logic bugs - <a href=\"https://docs.google.com/document/d/1FM4fQmIhEqPG8uGp5o9A-mnPB5BOeScZYpkHjo0KKA8/edit\">work in progress</a>) and use-after-free bugs in the browser process. If we can make that “thin” bit thinner still by removing some of those use-after-free bugs, we make the whole job of Chrome exploitation markedly harder. </p><p><strong>MiraclePtr: Preventing Exploitation of Use-After-Free Bugs</strong></p><p>This is where <a href=\"https://docs.google.com/document/d/1pnnOAIz_DMWDI4oIOFoMAqLnf_MZ2GsrJNb_dbQ3ZBg/edit\">MiraclePtr</a> comes in. It is a technology to prevent exploitation of use-after-free bugs. Unlike aforementioned *Scan technologies that offer a non-invasive approach to this problem, MiraclePtr relies on rewriting the codebase to use a new smart pointer type, <a href=\"https://chromium.googlesource.com/chromium/src/+/main/base/memory/raw_ptr.md\">raw_ptr&lt;T></a>. There are multiple ways to implement MiraclePtr. We came up with <a href=\"https://docs.google.com/document/d/1qsPh8Bcrma7S-5fobbCkBkXWaAijXOnorEqvIIGKzc0/edit\">~10 algorithms</a> and compared the pros and cons. After analyzing their performance overhead, memory overhead, security protection guarantees, developer ergonomics, etc., we concluded that BackupRefPtr was the most promising solution. </p><p><div class=\"separator\" style=\"clear: both;\"><a href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhqjNDqH-vs-iOJi4MZ8xgPNPFQin31tNdn0Ixh2w9wEKgTWB0KDsRBFg47IRrLsZ1BMSFAY0a1rmCUf5ETwzhUicglI4S9Lq6ue9h0UiK9vXX5WF6ZPVdEFSvDMGQOsLJ6MI0ZlyRbMCkd58hLxNBOy5FobolQUuyj7o6gYA2lZFDLt9QO_VLTpLJ1cA/s512/raw1.png\" style=\"display: block; padding: 1em 0; text-align: center; \"><img alt=\"\" border=\"0\" width=\"200\" data-original-height=\"484\" data-original-width=\"512\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhqjNDqH-vs-iOJi4MZ8xgPNPFQin31tNdn0Ixh2w9wEKgTWB0KDsRBFg47IRrLsZ1BMSFAY0a1rmCUf5ETwzhUicglI4S9Lq6ue9h0UiK9vXX5WF6ZPVdEFSvDMGQOsLJ6MI0ZlyRbMCkd58hLxNBOy5FobolQUuyj7o6gYA2lZFDLt9QO_VLTpLJ1cA/s200/raw1.png\"/></a></div>      The BackupRefPtr algorithm is based on reference counting. It uses support of Chrome's own heap allocator, <a href=\"https://chromium.googlesource.com/chromium/src/+/main/base/allocator/partition_allocator/PartitionAlloc.md\">PartitionAlloc</a>, which carves out a little extra space for a hidden reference count for each allocation. raw_ptr&lt;T> increments or decrements the reference count when it’s constructed, destroyed or modified. When the application calls free/delete and the reference count is greater than 0, PartitionAlloc quarantines that memory region instead of immediately releasing it. The memory region is then only made available for reuse once the reference count reaches 0. Quarantined memory is poisoned to further reduce the likelihood that use-after-free accesses will result in exploitable conditions, and in hope that future accesses lead to an easy-to-debug crash, turning these security issues into less-dangerous ones. </p>   <pre class=\"prettyprint\">class A { ... };<br />class B {<br />  B(A* a) : a_(a) {}<br />  void doSomething() { a_->doSomething(); }<br />  raw_ptr&lt;A> a_;  // MiraclePtr<br />};<br /><br />std::unique_ptr&lt;A> a = std::make_unique&lt;A>();<br />std::unique_ptr&lt;B> b = std::make_unique&lt;B>(a.get());<br />[…]<br />a = nullptr;  // The free is delayed because the MiraclePtr is still pointing to the object.<br />b->doSomething();  // Use-after-free is neutralized.</pre>  <p>We successfully <a href=\"https://chromium-review.googlesource.com/c/chromium/src/+/3305132\">rewrote more than 15,000 raw pointers</a> in the Chrome codebase into raw_ptr&lt;T>, then enabled BackupRefPtr for the browser process on Windows and Android (both 64 bit and 32 bit) in Chrome 102 Stable. We anticipate that MiraclePtr meaningfully reduces the browser process attack surface of Chrome by protecting ~50% of use-after-free issues against exploitation. We are now working on enabling BackupRefPtr in the network, utility and GPU processes, and for other platforms. In the end state, our goal is to enable BackupRefPtr on <em>all</em> platforms because that ensures that a given pointer is protected for <em>all</em> users of Chrome. </p><p><strong>Balancing Security and Performance</strong></p><p>There is no free lunch, however. This security protection comes at a cost, which we have carefully weighed in our decision making.  </p><p>Unsurprisingly, the main cost is memory. Luckily, related investments into PartitionAlloc over the past year led to 10-25% total memory savings, depending on usage patterns and platforms. So we were able to spend some of those savings on security: MiraclePtr increased the memory usage of the browser process 4.5-6.5% on Windows and 3.5-5% on Android<sup>1</sup>, still well below their previous levels. While we were worried about quarantined memory, in practice this is a tiny fraction (0.01%) of the browser process usage. By far the bigger culprit is the additional memory needed to store the reference count. One might think that adding 4 bytes to each allocation wouldn’t be a big deal. However, there are many small allocations in Chrome, so even the 4B overhead is not negligible. PartitionAlloc also uses pre-defined bucket sizes, so this extra 4B pushes certain allocations (particularly power-of-2 sized) into a larger bucket, e.g. 4096B->5120B. </p><p>We also considered the performance cost. Adding an atomic increment/decrement on common operations such as pointer assignment has unavoidable overhead. Having excluded a number of performance-critical pointers, we drove this overhead down until we could gain back the same margin through other performance optimizations. On Windows, no statistically significant performance regressions were observed on most of our top-level performance metrics like Largest Contentful Paint, First Input Delay, etc. The only adverse change there<sup>1</sup> is an increase of the main thread contention (~7%). On Android<sup>1</sup>, in addition to a similar increase in the main thread contention (~6%), there were small regressions in First Input Delay (~1%), Input Delay (~3%) and First Contentful Paint (~0.5%). We don't anticipate these regressions to have a noticeable impact on user experience, and are confident that they are strongly outweighed by the additional safety for our users.  </p><p>We should emphasize that MiraclePtr currently protects only class/struct pointer fields, to minimize the overhead. As future work, we are exploring options to expand the pointer coverage to on-stack pointers so that we can protect against more use-after-free bugs. </p><p>Note that the primary goal of MiraclePtr is to prevent exploitation of use-after-free bugs. Although it wasn’t designed for diagnosability, it already helped us find and fix a number of bugs that were previously undetected. We have ongoing efforts to make MiraclePtr crash reports even more informative and actionable. </p><p><strong>Continue to Provide Us Feedback</strong></p><p>Last but not least, we’d like to encourage security researchers to continue to report issues through the <a href=\"https://g.co/ChromeBugRewards\">Chrome Vulnerability Reward Program</a>, even if those issues are mitigated by MiraclePtr. We still need to make MiraclePtr available to all users, collect more data on its impact through reported issues, and further refine our processes and tooling. Until that is done, we will not consider MiraclePtr when determining the severity of a bug or the reward amount. </p><p><sup>1</sup> Measured in Chrome 99. </p>",
  "link": [
    "",
    "",
    "",
    "",
    ""
  ],
  "author": {
    "name": "Edward Fernandez",
    "uri": "http://www.blogger.com/profile/03784424747198152685",
    "email": "noreply@blogger.com",
    "gd:image": ""
  },
  "media:thumbnail": "",
  "thr:total": 0
}