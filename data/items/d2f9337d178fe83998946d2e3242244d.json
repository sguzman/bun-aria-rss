{
  "title": "Support Vector Machines for classification",
  "link": "",
  "published": "2015-10-22T14:24:00-07:00",
  "updated": "2015-10-22T14:24:00-07:00",
  "author": {
    "name": "Cathy Yeh"
  },
  "id": "tag:efavdb.com,2015-10-22:/svm-classification",
  "summary": "<p>To whet your appetite for support vector machines, here&#8217;s a quote from machine learning researcher Andrew&nbsp;Ng:</p>\n<blockquote>\n<p>“SVMs are among the best (and many believe are indeed the best) ‘off-the-shelf’ supervised learning&nbsp;algorithms.”</p>\n</blockquote>\n<p><a href=\"http://commons.wikimedia.org/wiki/File%3AAndrew_Ng.png\" title=\"See page for author [CC BY 3.0 us (http://creativecommons.org/licenses/by/3.0/us/deed.en)], via Wikimedia Commons\"><img alt=\"Andrew Ng\" src=\"//upload.wikimedia.org/wikipedia/commons/5/5c/Andrew_Ng.png\"></a></p>\n<p>Professor Ng covers SVMs in his excellent <a href=\"https://www.coursera.org/learn/machine-learning\">Machine Learning <span class=\"caps\">MOOC</span></a>, a gateway for many into the …</p>",
  "content": "<p>To whet your appetite for support vector machines, here&#8217;s a quote from machine learning researcher Andrew&nbsp;Ng:</p>\n<blockquote>\n<p>“SVMs are among the best (and many believe are indeed the best) ‘off-the-shelf’ supervised learning&nbsp;algorithms.”</p>\n</blockquote>\n<p><a href=\"http://commons.wikimedia.org/wiki/File%3AAndrew_Ng.png\" title=\"See page for author [CC BY 3.0 us (http://creativecommons.org/licenses/by/3.0/us/deed.en)], via Wikimedia Commons\"><img alt=\"Andrew Ng\" src=\"//upload.wikimedia.org/wikipedia/commons/5/5c/Andrew_Ng.png\"></a></p>\n<p>Professor Ng covers SVMs in his excellent <a href=\"https://www.coursera.org/learn/machine-learning\">Machine Learning <span class=\"caps\">MOOC</span></a>, a gateway for many into the realm of data science, but leaves out some details, motivating us to put together some notes here to answer the&nbsp;question:</p>\n<p><span class=\"dquo\">&#8220;</span>What are the <em>support vectors</em> in support vector&nbsp;machines?&#8221;</p>\n<p>We also provide python (https://github.com/EFavDB/svm-classification/blob/master/svm.ipynb) using scikit-learn&#8217;s svm module to fit a binary classification problem using a custom kernel, along with code to generate the (awesome!) interactive plots in Part&nbsp;3.</p>\n<p>This post consists of three&nbsp;sections:</p>\n<ul>\n<li>Part 1 sets up the problem from a geometric point of view and then shows how it can be framed as an optimization&nbsp;problem.</li>\n<li>Part 2 transforms the optimization problem and uncovers the support vectors in the&nbsp;process.</li>\n<li>Part 3 discusses how kernels can be used to separate non-linearly separable&nbsp;data.</li>\n</ul>\n<hr>\n<h2>Part 1: Defining the&nbsp;margin</h2>\n<h3>Maximizing the&nbsp;margin</h3>\n<p>The figure below is a binary classification problem (points labeled <span class=\"math\">\\(y_i = \\pm 1\\)</span>) that is linearly&nbsp;separable.</p>\n<p><a href=\"https://efavdb.com/wp-content/uploads/2015/05/binaryclass_2d.png\"><img alt=\"\" src=\"https://efavdb.com/wp-content/uploads/2015/05/binaryclass_2d.png\"></a></p>\n<p>There are many possible decision boundaries that would perfectly separate the two classes, but an <span class=\"caps\">SVM</span> will choose the line in 2-d (or “hyperplane”, more generally) that maximizes the margin around the&nbsp;boundary.</p>\n<p>Intuitively, we can be very confident about the labels of points that fall far from the boundary, but we’re less confident about points near the&nbsp;boundary.\n \n </p>\n<h3>Formulating the margin with&nbsp;geometry</h3>\n<p>Any point <span class=\"math\">\\(\\boldsymbol{x}\\)</span> lying on the separating hyperplane satisfies:\n<span class=\"math\">\\(\\boldsymbol{w} \\cdot \\boldsymbol{x} + b = 0\\)</span>\n<span class=\"math\">\\(\\boldsymbol{w}\\)</span> is the vector normal to the plane, and <span class=\"math\">\\(b\\)</span> is a constant that describes how much the plane is shifted relative to the origin.  The distance of the plane from the origin is <span class=\"math\">\\(b / \\| \\boldsymbol{w} \\|\\)</span>.</p>\n<p><a href=\"https://efavdb.com/wp-content/uploads/2015/05/binaryclass_margin.png\"><img alt=\"\" src=\"https://efavdb.com/wp-content/uploads/2015/05/binaryclass_margin.png\"></a></p>\n<p>Now draw parallel planes on either side of the decision boundary, so we have what looks like a road, with the decision boundary as the median, and the additional planes as gutters.  The margin, i.e. the width of the road, is (<span class=\"math\">\\(d_+ + d_-\\)</span>) and is restricted by the data points closest to the boundary, which lie on the&nbsp;gutters.</p>\n<p>The half-spaces bounded by the planes on the gutters&nbsp;are:</p>\n<p><span class=\"math\">\\(\\boldsymbol{w} \\cdot \\boldsymbol{x} + b \\geq +a\\)</span>, for <span class=\"math\">\\(y_i =&nbsp;+1\\)</span></p>\n<p><span class=\"math\">\\(\\boldsymbol{w} \\cdot \\boldsymbol{x} + b \\leq -a\\)</span>, for <span class=\"math\">\\(y_i =&nbsp;-1\\)</span></p>\n<p>These two conditions can be put more&nbsp;succinctly:</p>\n<p><span class=\"math\">\\(y_i (\\boldsymbol{w} \\cdot \\boldsymbol{x} + b) \\geq a, \\forall \\;&nbsp;i\\)</span></p>\n<p>Some arithmetic leads to the equation for the&nbsp;margin:</p>\n<p><span class=\"math\">\\(d_+ + d_- = 2a / \\| \\boldsymbol{w}&nbsp;\\|\\)</span></p>\n<p>Without loss of generality, we can set <span class=\"math\">\\(a=1\\)</span>, since it only sets the scale (units) of <span class=\"math\">\\(b\\)</span> and <span class=\"math\">\\(\\boldsymbol{w}\\)</span>.  So to maximize the margin, we have to maximize <span class=\"math\">\\(1 / \\| \\boldsymbol{w} \\|\\)</span>.  However, this is an unpleasant (non-convex) objective function.  Instead we minimize <span class=\"math\">\\(\\| \\boldsymbol{w}\\|^2\\)</span>, which is&nbsp;convex.</p>\n<h3>The optimization&nbsp;problem</h3>\n<p>Maximizing the margin boils down to a constrained optimization problem: minimize some quantity <span class=\"math\">\\(f(w)\\)</span>, subject to constraints <span class=\"math\">\\(g(w,b)\\)</span>.  This optimization problem is particularly nice because it is convex; the objective <span class=\"math\">\\(\\| \\boldsymbol{w}\\|^2\\)</span> is convex, as are the constraints, which are&nbsp;linear.</p>\n<p>In other words, we are faced with a <a href=\"http://en.wikipedia.org/wiki/Quadratic_programming\">quadratic programming</a> problem.  The standard format of the optimization problem for the separable case&nbsp;is</p>\n<div class=\"math\">$$\\tag{1} \\label{problem}\n\\begin{align}\n\\text{minimize} \\quad &amp; f(w) \\equiv (1/2) \\| \\boldsymbol{w}\\|^2 \\\n\\text{subject to} \\quad &amp; g(w,b) \\equiv -y_i (\\boldsymbol{w} \\cdot \\boldsymbol{x} + b) + 1 \\leq 0, \\; i = 1 \\ldots m\n\\end{align}\n$$</div>\n<p>Before we address how to solve this optimization problem in Part 2, let&#8217;s first consider the case when data is&nbsp;non-separable.</p>\n<h3>Soft margin <span class=\"caps\">SVM</span>: the non-separable problem and&nbsp;regularization</h3>\n<p><a href=\"https://efavdb.com/wp-content/uploads/2015/05/softmargin.png\"><img alt=\"\" src=\"https://efavdb.com/wp-content/uploads/2015/05/softmargin.png\"></a></p>\n<p>For non-separable data, we relax the constraints in (\\ref{problem}) while penalizing misclassified points via a cost parameter <span class=\"math\">\\(C\\)</span> and slack variables <span class=\"math\">\\(\\xi_i\\)</span> that define the amount by which data points are on the wrong side of the&nbsp;margin.</p>\n<div class=\"math\">$$\\tag{2} \\label{regularization}\n\\begin{align}\n\\text{minimize} \\quad &amp; (1/2) \\| \\boldsymbol{w}\\|^2 + C \\sum_i^m \\xi_i \\\\\n\\text{subject to} \\quad &amp; y_i (\\boldsymbol{w} \\cdot \\boldsymbol{x} + b) \\geq 1 - \\xi_i, \\; i = 1 \\ldots m \\\\\n&amp; \\xi_i \\geq 0, \\quad i = 1 \\ldots m\n\\end{align}\n$$</div>\n<p>\nA large penalty &#8212; large <span class=\"math\">\\(C\\)</span> &#8212; for misclassifications will lead to learning a lower bias, higher variance <span class=\"caps\">SVM</span>, and vice versa for small <span class=\"math\">\\(C\\)</span>.</p>\n<p>The soft margin is used in practice; even in the separable case, it can be desirable to allow tradeoffs between the size of the margin and number of misclassifications. Outliers can skew the decision boundary learned by (\\ref{problem}) towards a model with small margins + perfect classification, in contrast to a possibly more robust model learned by (\\ref{regularization}) with large margins + some misclassified&nbsp;points.</p>\n<hr>\n<h2>Part 2: Solving the optimization&nbsp;problem</h2>\n<p>In Part 1, we showed how to set up SVMs as an optimization problem. In this section, we&#8217;ll see how the eponymous support vectors emerge when we rephrase the minimization problem as an equivalent maximization&nbsp;problem.</p>\n<p>To recap: Given <span class=\"math\">\\(m\\)</span> training points that are labeled <span class=\"math\">\\(y_i = \\pm 1\\)</span>, our goal is to maximize the margin of the hyperplane defined by <span class=\"math\">\\(\\boldsymbol{w} \\cdot \\boldsymbol{x} + b = 0\\)</span>.</p>\n<p>We&#8217;ll use the separable case (\\ref{problem}) as our starting point, but the steps in the procedure and final result are similar for the non-separable case (also worked out in ref [<a href=\"#3\">3</a>]).</p>\n<h3>The Lagrangian&nbsp;formulation</h3>\n<p>How do we solve this optimization problem? Minimizing a function without constraints is probably familiar: set the derivative of the function (the objective) to zero and&nbsp;solve.</p>\n<p>With constraints, the procedure is similar to setting the derivative of the objective equal to zero. Instead of taking the derivative of the objective itself, however, we&#8217;ll operate on the Lagrangian <span class=\"math\">\\(\\mathcal{L}\\)</span>, which combines the objective and inequality constraints into one&nbsp;function:</p>\n<div class=\"math\">$$\\tag{3} \\label{Lagrangian}\n\\mathcal{L}(w,b,\\alpha) = f(w) + \\sum_i^m \\alpha_i g_i(w,b)\n$$</div>\n<p>We&#8217;ve just introduced additional variables <span class=\"math\">\\(\\alpha_i\\)</span>, Lagrange multipliers, that make it easier to work with the constraints (see Wikipedia about the <a href=\"https://en.wikipedia.org/wiki/Lagrange_multiplier\">method of Lagrange multipliers</a>). Note, a more general form for the Lagrangian would include another summation term in (\\ref{Lagrangian}) to uphold equality constraints. Since there are only inequality constraints here, we&#8217;ll omit the extra&nbsp;term.</p>\n<h3>Constructing the dual&nbsp;problem</h3>\n<p><em>Much of the following discussion is based off ref <a href=\"#2\">[2]</a>, which has a nice introduction to duality in the context of&nbsp;SVMs.</em></p>\n<p>First, let&#8217;s make the following&nbsp;observation:\n</p>\n<div class=\"math\">$$\\tag{Obs. 1}\n\\max_{\\alpha} \\mathcal{L}(w,b,\\alpha) =\n\\begin{cases}\nf(w), &amp; \\text{if } g_i(w) \\leq 0, \\; \\text{(constraints satisfied)} \\\\\n\\infty, &amp; \\text{if } g_i(w) \\gt 0, \\; \\text{(constraints violated)}\n\\end{cases}\n$$</div>\n<p>Basically, if any constraint <span class=\"math\">\\(j\\)</span> is violated, i.e. <span class=\"math\">\\(g_j(w) &gt; 0\\)</span>, then the Lagrange multiplier <span class=\"math\">\\(\\alpha_j\\)</span> that is multiplying <span class=\"math\">\\(g_j(w)\\)</span> can be made arbitrarily large (<span class=\"math\">\\(\\rightarrow \\infty\\)</span>) in order to maximize <span class=\"math\">\\(\\mathcal{L}\\)</span>.</p>\n<p>On the other hand, if all the constraints are satisfied, <span class=\"math\">\\(g_i(w) \\leq 0\\)</span> <span class=\"math\">\\(\\forall \\; i\\)</span>, then <span class=\"math\">\\(\\mathcal{L}\\)</span> is maximized by setting the <span class=\"math\">\\(\\alpha_i\\)</span>s that are multiplying negative quantities equal to zero. However, Lagrangian multipliers multiplying <span class=\"math\">\\(g_i(w)\\)</span> that satisfy the constraints with equality, <span class=\"math\">\\(g_i(w) = 0\\)</span>, can be non-zero without diminishing <span class=\"math\">\\(\\mathcal{L}\\)</span>.</p>\n<p>The last statement amounts to the property of &#8220;complementary slackness&#8221; in the <a href=\"http://en.wikipedia.org/wiki/Karush%E2%80%93Kuhn%E2%80%93Tucker_conditions\" title=\"KKT conditions\">Karush-Kuhn-Tucker</a> conditions for the&nbsp;solution:\n</p>\n<div class=\"math\">$$\\tag{4} \\label{complementarity}\n\\alpha_i g_i(w) = 0\n$$</div>\n<p>Recall from the original geometric picture: only a few points lie exactly on the margins, and those points are described by <span class=\"math\">\\(g_i(w) = 0\\)</span> (and thus have non-zero Lagrange multipliers). <strong>The points on the margin are the support&nbsp;vectors.</strong></p>\n<p>Next, we make use of the Max-Min&nbsp;inequality:\n</p>\n<div class=\"math\">$$\n\\max_{\\alpha} \\min_{w,b} \\mathcal{L}(w,b,\\alpha) \\leq \\min_{w,b} \\max_{\\alpha} \\mathcal{L}(w,b,\\alpha)\n$$</div>\n<p>This inequality is an equality under certain conditions, which our problem satisfies (convex <span class=\"math\">\\(f\\)</span> and <span class=\"math\">\\(g\\)</span>). The left side of the inequality is called the dual problem, and the right side is the primal&nbsp;problem.</p>\n<p>Now we can put it all together: Observation 1 tells us that solving the right side (primal problem) of the Max-Min inequality is the same as solving the original problem. Because our problem is convex, solving the left side (dual) is equivalent to solving the primal problem by the Max-Min&nbsp;inequality.</p>\n<p>Thus we&#8217;re set to approach the solution via the dual problem, which is useful for dealing with nonlinear decision&nbsp;boundaries.</p>\n<h3>Solving the dual&nbsp;problem</h3>\n<p>The dual problem to solve is <span class=\"math\">\\(\\max_{\\alpha} \\min_{w,b} \\mathcal{L}(w,b,\\alpha)\\)</span>, subject to constraints<a href=\"#note1\">*</a> on the Lagrange multipliers: <span class=\"math\">\\(\\alpha_i \\geq 0\\)</span>.</p>\n<p>Let&#8217;s work out the inner part of the expression explicitly. We obtain <span class=\"math\">\\(\\min_{w,b} \\mathcal{L}(w,b,\\alpha)\\)</span> by&nbsp;setting:\n</p>\n<div class=\"math\">$$\n\\nabla_\\boldsymbol{w} \\mathcal{L} = 0; \\quad \\partial_b \\mathcal{L} = 0\n$$</div>\n<p>These equations for the partial derivatives give us,&nbsp;respectively:\n</p>\n<div class=\"math\">$$\n\\boldsymbol{w} = \\sum_i \\alpha_i y_i \\boldsymbol{x}_i; \\quad \\sum_i \\alpha_i y_i = 0\n$$</div>\n<p><span class=\"math\">\\(\\boldsymbol{w}\\)</span> is a linear combination of the coordinates of the training data. Only the support vectors, which have non-zero <span class=\"math\">\\(\\alpha_i\\)</span>, contribute to the sum. To predict the label for a new test point <span class=\"math\">\\(\\boldsymbol{x_t}\\)</span>, simply evaluate the sign&nbsp;of\n</p>\n<div class=\"math\">$$\\tag{5} \\label{testing}\n\\boldsymbol{w} \\cdot \\boldsymbol{x} + b = \\sum_i \\alpha_i y_i \\boldsymbol{x}_i \\cdot \\boldsymbol{x_t} + b\n$$</div>\n<p>\nwhere b can be computed from the <span class=\"caps\">KKT</span> complementarity condition (\\ref{complementarity}) by plugging in the values for any support vector. The equation for the separating hyperplane is entirely determined by the support&nbsp;vectors.</p>\n<p>Plugging the last two equations into <span class=\"math\">\\(\\mathcal{L}\\)</span> leads to the dual formulation of the problem <span class=\"math\">\\( \\max_{\\alpha} \\mathcal{L}_D\\)</span>:</p>\n<div class=\"math\">$$\\tag{6} \\label{dual}\n\\begin{align}\n\\max_{\\alpha} \\quad &amp; \\sum_i \\alpha_i - (1/2) \\sum_{i,j} \\alpha_i \\alpha_j y_i y_j \\boldsymbol{x_i} \\cdot \\boldsymbol{x_j} \\\\\n\\text{subject to} \\quad &amp; \\alpha_i \\geq 0, \\; i = 1 \\ldots m \\\\\n&amp; \\sum_i \\alpha_i y_i = 0\n\\end{align}\n$$</div>\n<p>The dual for the non-separable primal Lagrangian (\\ref{regularization}) &#8212; derived using the same procedure we just followed &#8212; looks just like the dual for the separable case (\\ref{dual}), except that the Lagrange multipliers are bounded from above by the regularization constant: <span class=\"math\">\\(0 \\leq \\alpha_i \\leq C\\)</span>. Notably, the slack variables <span class=\"math\">\\(\\xi_i\\)</span> do not appear in the dual of the soft margin <span class=\"caps\">SVM</span>.</p>\n<p>The dual (called the Wolfe dual) is easier to solve because of the simpler form of its inequality constraints and is the form used in algorithms such as the <a href=\"http://research.microsoft.com/pubs/68391/smo-book.pdf\">Sequential Minimal Optimization</a> algorithm, which is implemented in the popular <span class=\"caps\">SVM</span> solver, <a href=\"https://www.csie.ntu.edu.tw/~cjlin/libsvm/\"><span class=\"caps\">LIBSVM</span></a>. The key feature of the dual is that training vectors only appear as dot products <span class=\"math\">\\(\\boldsymbol{x_i} \\cdot \\boldsymbol{x_j}\\)</span>. This property allows us to generalize to the nonlinear case via the &#8220;kernel trick&#8221; discussed in Part 3 of this&nbsp;post.</p>\n<ul>\n<li>Some of you may be familiar with using Lagrangian multipliers to optimize some function <span class=\"math\">\\(f(\\boldsymbol{x})\\)</span> subject to equality constraints <span class=\"math\">\\(g(\\boldsymbol{x}) = 0\\)</span>, in which case the Lagrangian multipliers are unconstrained. The <a href=\"http://en.wikipedia.org/wiki/Karush%E2%80%93Kuhn%E2%80%93Tucker_conditions\" title=\"KKT conditions\">Karush-Kuhn-Tucker conditions</a> generalize the method to include inequality constraints <span class=\"math\">\\(g(\\boldsymbol{x}) \\leq 0\\)</span>, which results in additional constraints on the associated Lagrangian multipliers (as we have&nbsp;here).</li>\n</ul>\n<hr>\n<h2>Part 3:&nbsp;Kernels</h2>\n<p>Data that is not linearly separable in the original input space may be separable if mapped to a different space. Consider the following example of nonlinearly separable, two-dimensional&nbsp;data:</p>\n<iframe width=\"600\" height=\"533\" frameborder=\"0\" scrolling=\"no\" src=\"//plot.ly/~frangipane/9.embed\"></iframe>\n\n<p>However, if we map the 2-d input data <span class=\"math\">\\(\\boldsymbol{x} = (x, y)\\)</span> to 3-d feature space by a function <span class=\"math\">\\(\\Phi(\\boldsymbol{x}) = (x,\\; y,\\; x^2 + y^2)\\)</span>, the blue and red points can be separated with a plane in the new (3-d) space. See the plot below of the decision boundary, the mapped points, as well as the the original data points in the x-y plane. Drag the figure to rotate it, or zoom in and out with your mouse&nbsp;wheel!</p>\n<iframe width=\"600\" height=\"533\" frameborder=\"0\" src=\"//plot.ly/~frangipane/35.embed\"></iframe>\n\n<p>Code to generate and fit the data in this example with scikit-learn&#8217;s <span class=\"caps\">SVM</span> module, as well as code to create the plot.ly interactive plots above, is available in IPython notebooks on <a href=\"https://github.com/EFavDB/svm-classification\">github</a>.</p>\n<h3>From maps to&nbsp;kernels</h3>\n<p>So how do we incorporate mapping the data into the formulation of the&nbsp;problem?</p>\n<p>Recall that the data appears as a dot product in the dual Lagrangian (\\ref{dual}). If we decide to train an <span class=\"caps\">SVM</span> on the mapped data, then the dot product of the input data in (\\ref{dual}) is replaced by the dot product of the mapped data: <span class=\"math\">\\(\\boldsymbol{x_i} \\cdot \\boldsymbol{x_j} \\rightarrow \\Phi(\\boldsymbol{x_i}) \\cdot&nbsp;\\Phi(\\boldsymbol{x_j})\\)</span></p>\n<p>The kernel is simply the dot product of the mapping functions. In the example above, the inner product of the mapping function is an instance of a polynomial&nbsp;kernel:\n</p>\n<div class=\"math\">$$\nK(x_i, x_j) = \\Phi(\\boldsymbol{x_i}) \\cdot \\Phi(\\boldsymbol{x_j}) = x_i x_j + y_i y_j + (x_i^2 + y_i^2)(x_j^2 + y_j^2)\n$$</div>\n<p>In practice, we work directly with the kernel <span class=\"math\">\\(K(x_i, x_j)\\)</span> rather than explicitly computing the map of the data points<a href=\"#note2\">**</a>. Computing the kernel directly allows us to sidestep the computationally expensive operation of mapping data to a high dimensional space and then taking a dot product (see ref [<a href=\"#2\">2</a>] for examples comparing computational times of the two&nbsp;methods).</p>\n<p>Using a kernel, the second term in the objective of the dual problem (\\ref{dual})&nbsp;becomes\n</p>\n<div class=\"math\">$$\n\\sum_{i,j} \\alpha_i \\alpha_j y_i y_j K(x_i, x_j)\n$$</div>\n<p>\nThe kernel also appears in the evaluation of (\\ref{testing}) to predict the classification of a test point <span class=\"math\">\\(\\boldsymbol{x_t}\\)</span>:\n</p>\n<div class=\"math\">$$\\tag{8} \\label{testingKernel}\nsgn \\left(\\sum_i \\alpha_i y_i K(x_i, x_t) + b \\right)\n$$</div>\n<p>Which functions are valid kernels to use in the kernel trick? i.e. given <span class=\"math\">\\(K(x_i, x_j)\\)</span>, does some feature map <span class=\"math\">\\(\\Phi\\)</span> exist such that <span class=\"math\">\\(K(x_i, x_j)=\\Phi(\\boldsymbol{x_i}) \\cdot \\Phi(\\boldsymbol{x_j})\\)</span> for any <span class=\"math\">\\(i,\\ j\\)</span>? Mercer&#8217;s condition states that a necessary and sufficient condition for <span class=\"math\">\\(K\\)</span> to be a valid kernel is that it is symmetric and positive semi-definite<a href=\"#note3\"><span class=\"math\">\\(^\\dagger\\)</span></a>.</p>\n<p>Some popular kernels&nbsp;are:\n</p>\n<div class=\"math\">$$\n\\begin{align}\n\\text{polynomial:} &amp; \\quad (\\boldsymbol{x_i} \\cdot \\boldsymbol{x_j} + c)^p \\\\\n\\text{Gaussian radial basis function:} &amp; \\quad \\exp(-\\|\\boldsymbol{x_i} - \\boldsymbol{x_j} \\|^2/2\\sigma^2)\n\\end{align}\n$$</div>\n<p>\nThe optimal parameters for the degree of the polynomial <span class=\"math\">\\(p\\)</span> and spread of the Gaussian <span class=\"math\">\\(\\sigma\\)</span> (as well as the regularization parameter) are determined by cross-validation. Computing the above kernels takes <span class=\"math\">\\(\\mathcal{O}(d)\\)</span> time, where <span class=\"math\">\\(d\\)</span> is the dimension of the input space, since we have to evaluate <span class=\"math\">\\(\\boldsymbol{x_i} \\cdot \\boldsymbol{x_j}\\)</span> in the polynomial kernel and <span class=\"math\">\\(\\boldsymbol{x_i} - \\boldsymbol{x_j}\\)</span> in the Gaussian&nbsp;kernel.</p>\n<h3>Comparing runtimes of linear and nonlinear&nbsp;kernels</h3>\n<p>The computational complexity for <strong>classification/prediction</strong>, i.e. at test time, can be obtained by eyeballing (\\ref{testing}) and (\\ref{testingKernel}). Let <span class=\"math\">\\(d\\)</span> be the dimension of the input space and <span class=\"math\">\\(n\\)</span> be the size of the training set, and assume the number of support vectors <span class=\"math\">\\(n_S\\)</span> is some fraction of <span class=\"math\">\\(n\\)</span>, <span class=\"math\">\\(n_S \\sim \\mathcal{O}(n)\\)</span>.</p>\n<p>In the case of working with the linear kernel/original input space, <span class=\"math\">\\(\\boldsymbol{w}\\)</span> can be explicitly evaluated to obtain the separating hyperplane parameters, so that classification in (\\ref{testing}) takes <span class=\"math\">\\(\\mathcal{O}(d)\\)</span> time. On the other hand, with the kernel trick, the hyperplane parameters are not explicitly evaluated. Assume calculating a kernel takes <span class=\"math\">\\(\\mathcal{O}(d)\\)</span> time, cf. the polynomial and Gaussian kernels; then test time for a nonlinear <span class=\"math\">\\(K\\)</span> in (\\ref{testingKernel}) takes <span class=\"math\">\\(\\mathcal{O}(nd)\\)</span>&nbsp;time.</p>\n<p>Estimating the computational complexity for <strong>training</strong> is complicated, so we defer the discussion to refs [<a href=\"#4a\">4a</a>, <a href=\"#4b\">4b</a>] and simply state the result: training for linear kernels is <span class=\"math\">\\(\\mathcal{O}(nd)\\)</span> while training for nonlinear kernels using the Sequential Minimal Optimization algorithm is <span class=\"math\">\\(\\mathcal{O}(n^2)\\)</span> to <span class=\"math\">\\(\\mathcal{O}(n^3)\\)</span> (dependent on the regularization parameter <span class=\"math\">\\(C\\)</span>), making nonlinear kernel SVMs impractical for larger datasets (a couple of 10,000 samples according to <a href=\"http://scikit-learn.org/stable/modules/generated/sklearn.svm.SVC.html\">scikit-learn</a>).</p>\n<p>** More than one mapping and feature space (dimension) may exist for a particular kernel. See section 4 of ref [<a href=\"#1\">1</a>] for&nbsp;examples.</p>\n<p><span class=\"math\">\\(^\\dagger\\)</span> See ref [<a href=\"#2\">2</a>] for a simple proof in terms of the Kernel (Gram) matrix, i.e. the kernel function evaluated on a finite set of&nbsp;points.</p>\n<hr>\n<h2>Discussion</h2>\n<p>We&#8217;ve glimpsed the elegant theory behind the construction of SVMs and seen how support vectors pop out of the mathematical machinery. Geometrically, the support vectors are the points lying on the margins of the decision&nbsp;boundary.</p>\n<p>How about using SVMs in&nbsp;practice?</p>\n<p>In his Coursera course, Professor Ng recommends linear and Gaussian kernels for most use cases. He also provides some rules of thumb (based on the current state of <span class=\"caps\">SVM</span> algorithms) for different sample sizes <span class=\"math\">\\(n\\)</span> and input data dimension/number of features <span class=\"math\">\\(d\\)</span>, restated&nbsp;here:</p>\n<p>case                                               method                                                           <span class=\"math\">\\(n\\)</span>         <span class=\"math\">\\(d\\)</span></p>\n<hr>\n<p><span class=\"math\">\\(n \\ll d\\)</span>, e.g. genomics, bioinformatics data   linear kernel <span class=\"caps\">SVM</span> or logistic regression                         10 - 1000     10,000\n  <span class=\"math\">\\(n\\)</span> intermediate, <span class=\"math\">\\(d\\)</span> small                    Gaussian kernel <span class=\"caps\">SVM</span>                                              10 - 10,000   1 - 1000\n  <span class=\"math\">\\(n \\gg d\\)</span>                                       create features, then linear kernel <span class=\"caps\">SVM</span> or logistic regression   50,000+       1 -&nbsp;1000</p>\n<p>The creators of the <span class=\"caps\">LIBSVM</span> and <span class=\"caps\">LIBLINEAR</span> packages also provide a <a href=\"https://www.csie.ntu.edu.tw/~cjlin/papers/guide/guide.pdf\">user&#8217;s guide</a> for novices, which includes a study of when to use linear instead of radial basis function kernels. They recommend linear SVMs when <span class=\"math\">\\(d\\)</span> and <span class=\"math\">\\(n\\)</span> are both large, often encountered in document classification problems where bag-of-words approaches can generate huge numbers of features (in their example <span class=\"math\">\\(n =\\)</span> 20,000, <span class=\"math\">\\(d =\\)</span>&nbsp;47,000).</p>\n<p>The idea is that if the input data is already high-dimensional, then it shouldn&#8217;t be necessary to apply nonlinear transformations to it in order to obtain a separating&nbsp;hyperplane.</p>\n<p>Tip: <span class=\"caps\">LIBLINEAR</span> is specifically optimized for linear kernels and should be used instead of <span class=\"caps\">LIBSVM</span> in the linear&nbsp;case.</p>\n<h3>Further&nbsp;reading</h3>\n<p>In addition to the many excellent written tutorials on SVMs online, we highly recommend viewing lectures 14 and 15 of Yaser Abu-Mostafa&#8217;s <span class=\"caps\">MOOC</span>, <a href=\"https://work.caltech.edu/telecourse.html\">Learning from Data</a>, which cover SVMs at about the same level as this post, with the considerable added benefit of Professor Abu-Mostafa&#8217;s explanations. He also discusses the generalization performance of SVMs as a function of the number of support vectors using <span class=\"caps\">VC</span> theory (also see [<a href=\"#1\">1</a>]).</p>\n<p>There is a lot more theory on SVMs that we haven&#8217;t touched upon. For example, SVMs can be framed as a penalization method [<a href=\"#3\">3</a>] or <a href=\"http://cbcl.mit.edu/cbcl/publications/ps/evgeniou-reviewall.pdf\">&#8220;regularization network&#8221;</a>, c.f. ridge regression, but with a hinge loss rather than squared error. Insights about the choice of a <a href=\"http://alex.smola.org/papers/1998/SmoSch98b.pdf\">kernel</a> have also been developed in that&nbsp;framework.</p>\n<hr>\n<p>[<a href=\"http://research.microsoft.com/pubs/67119/svmtutorial.pdf\">1</a>] Burges, <span class=\"caps\">C. J.C.</span>(1998). A Tutorial on Support Vector Machines for Pattern Recognition. Knowledge Discovery and Data Mining 2 (2)&nbsp;121-167.</p>\n<p>[<a href=\"http://cs229.stanford.edu/notes/cs229-notes3.pdf\">2</a>] Ng, A. Support Vector Machines [<span class=\"caps\">PDF</span> document]. Retrieved from lecture notes online: http://cs229.stanford.edu/notes/cs229-notes3.pdf\n<em>Lecture notes by Andrew Ng for a more advanced class (but still in his signature intuitive&nbsp;style).</em></p>\n<p>[<a href=\"http://statweb.stanford.edu/~tibs/ElemStatLearn/\">3</a>] Hastie, T., Tibshirani, R., and Friedman, J. (2009). The Elements of Statistical Learning.\n<em>See section 12.2.1, page 420, for derivation of the dual Lagrangian for the nonseparable&nbsp;case.</em></p>\n<p>[<a href=\"https://www.csie.ntu.edu.tw/~cjlin/papers/bottou_lin.pdf\">4a</a>] Bottou, L. and Lin C-J., (2006). Support Vector Machine Solvers.\n[<a href=\"http://www.csie.ntu.edu.tw/~cjlin/papers/libsvm.pdf\">4b</a>] Chang, C-C. and Lin C-J., (2013). <span class=\"caps\">LIBSVM</span>: A Library for Support Vector&nbsp;Machines.</p>\n<p>[<a href=\"http://www.cs.colostate.edu/~asa/pdfs/howto.pdf\">5</a>] Ben-Hur, A. and Weston, J. (2009). A User&#8217;s Guide to Support Vector Machines. In Carugo, O. and Eisenhaber, F. (Eds.), Methods in Molecular Biology 609,&nbsp;223-229.</p>\n<p>Andrew Ng photo credit: <a href=\"https://commons.wikimedia.org/wiki/User:InverseHypercube\">InverseHypercube</a>, <a href=\"http://creativecommons.org/licenses/by/3.0/us/deed.en\">creative commons license</a>.</p>\n<script type=\"text/javascript\">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {\n    var align = \"center\",\n        indent = \"0em\",\n        linebreak = \"false\";\n\n    if (false) {\n        align = (screen.width < 768) ? \"left\" : align;\n        indent = (screen.width < 768) ? \"0em\" : indent;\n        linebreak = (screen.width < 768) ? 'true' : linebreak;\n    }\n\n    var mathjaxscript = document.createElement('script');\n    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';\n    mathjaxscript.type = 'text/javascript';\n    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';\n\n    var configscript = document.createElement('script');\n    configscript.type = 'text/x-mathjax-config';\n    configscript[(window.opera ? \"innerHTML\" : \"text\")] =\n        \"MathJax.Hub.Config({\" +\n        \"    config: ['MMLorHTML.js'],\" +\n        \"    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } },\" +\n        \"    jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" +\n        \"    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" +\n        \"    displayAlign: '\"+ align +\"',\" +\n        \"    displayIndent: '\"+ indent +\"',\" +\n        \"    showMathMenu: true,\" +\n        \"    messageStyle: 'normal',\" +\n        \"    tex2jax: { \" +\n        \"        inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" +\n        \"        displayMath: [ ['$$','$$'] ],\" +\n        \"        processEscapes: true,\" +\n        \"        preview: 'TeX',\" +\n        \"    }, \" +\n        \"    'HTML-CSS': { \" +\n        \"        availableFonts: ['STIX', 'TeX'],\" +\n        \"        preferredFont: 'STIX',\" +\n        \"        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" +\n        \"        linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" +\n        \"    }, \" +\n        \"}); \" +\n        \"if ('default' !== 'default') {\" +\n            \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" +\n                \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" +\n                \"VARIANT['normal'].fonts.unshift('MathJax_default');\" +\n                \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" +\n                \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" +\n                \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" +\n            \"});\" +\n            \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" +\n                \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" +\n                \"VARIANT['normal'].fonts.unshift('MathJax_default');\" +\n                \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" +\n                \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" +\n                \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" +\n            \"});\" +\n        \"}\";\n\n    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);\n    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);\n}\n</script>",
  "category": [
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
}