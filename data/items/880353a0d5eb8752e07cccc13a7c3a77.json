{
  "title": "A cozy nest for your scripts",
  "description": "<p><a href=\"https://github.com/ianthehenry/sd\"><code>sd</code></a> is a tool for running scripts in your <code>s</code>cript <code>d</code>irectory.</p>\n<pre tabindex=\"0\"><code>$ tree ~/sd\n/Users/ian/sd\n├── blog\n│ ├── edit\n│ ├── preview\n│ └── publish\n├── book\n│ ├── open\n│ ├── words\n│ └── typeset\n├── nix\n│ ├── diff\n│ ├── info\n│ ├── install\n│ ├── shell\n│ └── sync\n└── video\n└── fix\n</code></pre><p>Directories become command groups; executables become subcommands. Instead of a flat <code>~/bin</code>, you have a cozy nest for your scripts. And you can type:</p>\n<pre tabindex=\"0\"><code>$ sd blog publish --deploy\n</code></pre><p>To run:</p>\n<pre tabindex=\"0\"><code>$ ~/sd/blog/publish --deploy\n</code></pre><p>Which, okay, sure. That&rsquo;s not that exciting.</p>\n<p>The exciting thing is that <code>sd</code> supports <em>fancy autocompletion</em>. Take a look:</p>\n<pre tabindex=\"0\"><code>$ sd nix &lt;TAB&gt;\ndiff -- prints what will happen if you run sync\ninfo -- &lt;package&gt; prints package description\ninstall -- &lt;package&gt; use --latest to install from nixpkgs-unstable\nshell -- add gcroots for shell.nix\nsync -- make user environment match ~/dotfiles/user.nix\n</code></pre><p><code>sd</code> pulls those descriptions from comments in the scripts themselves:</p>\n<pre tabindex=\"0\"><code>$ sd nix info --cat\n</code></pre><div class=\"highlight\"><pre tabindex=\"0\" class=\"chroma\"><code class=\"language-bash\" data-lang=\"bash\"><span class=\"cp\">#!/usr/bin/env bash\n</span><span class=\"cp\"></span>\n<span class=\"c1\"># &lt;package&gt; prints package description</span>\n<span class=\"nb\">set</span> -euo pipefail\nnix-env -qaA <span class=\"s2\">&#34;nixpkgs.</span><span class=\"nv\">$1</span><span class=\"s2\">&#34;</span> --json <span class=\"se\">\\\n</span><span class=\"se\"></span><span class=\"p\">|</span> jq -r <span class=\"s1\">&#39;.[] | .name + &#34; &#34; + .meta.description,\n</span><span class=\"s1\"> &#34;&#34;,\n</span><span class=\"s1\"> (.meta.longDescription | rtrimstr(&#34;\\n&#34;))&#39;</span>\n</code></pre></div><p>So they&rsquo;re very easy to write.</p>\n<p><code>sd</code> also makes it easy to create <em>new</em> scripts:</p>\n<pre tabindex=\"0\"><code>$ sd blog laud --new 'echo &quot;good blog ian&quot;'\n$ sd blog laud\ngood blog ian\n</code></pre><p>So you can easily stash oneliners, and you don&rsquo;t have to remember to <code>chmod +x</code>. (You can also call <code>--new</code> without providing an initial script, to go straight into your text editor.)</p>\n<aside>\n<p>And if you use <a href=\"https://github.com/ianthehenry/zsh-autoquoter\">zsh-autoquoter</a>, you can add a rule that lets you just write:</p>\n<pre><code>sd plugin laud --new echo &quot;good plugin ian&quot;\n^^^^^^^^^^^^^^^^^^^^^^\n</code></pre>\n<p>Which can be helpful for stashing complex commands. Here&rsquo;s the rule I use:</p>\n<div class=\"highlight\"><pre tabindex=\"0\" class=\"chroma\"><code class=\"language-zsh\" data-lang=\"zsh\"><span class=\"nv\">ZAQ_PREFIXES</span><span class=\"o\">+=(</span><span class=\"s1\">&#39;sd [^ ]* --new&#39;</span><span class=\"o\">)</span>\n</code></pre></div></aside>\n<p>You can also modify the template for new scripts, on a per-directory basis. Although new scripts default to a fairly reasonable <code>bash</code>:</p>\n<pre><code>$ sd blog laud --edit\n</code></pre>\n<div class=\"highlight\"><pre tabindex=\"0\" class=\"chroma\"><code class=\"language-bash\" data-lang=\"bash\"> <span class=\"m\">1</span> <span class=\"c1\">#!/usr/bin/env bash</span>\n<span class=\"m\">2</span>\n<span class=\"m\">3</span> <span class=\"nb\">set</span> -euo pipefail\n<span class=\"m\">4</span>\n<span class=\"m\">5</span> <span class=\"nb\">echo</span> <span class=\"s1\">&#39;good blog ian&#39;</span>\n~\n~\n<span class=\"s2\">&#34;~/sd/blog/laud&#34;</span> 5L, 61B\n</code></pre></div><h1 id=\"who-cares\">who cares</h1>\n<p>Take a peek at your <code>~/bin</code>. How many scripts there have names like <code>process</code> or <code>run</code> or <code>deploy</code>? How many of them have you forgotten ever writing?</p>\n<p>If the answer is &ldquo;none of them,&rdquo; <code>sd</code> might not be for you. It sounds like you&rsquo;ve got this figured out already. Good work.</p>\n<p>But <code>sd</code> is for script hoarders, who want to rage against the chaos of their <code>~/bin</code>. And <code>sd</code> is for people who spend a lot of time combing through <code>ctrl-r</code>, looking for that oneliner that they never thought to make into a script, because it was too much of a hassle and who knows if they&rsquo;ll ever run it again.</p>\n<p>Give it a name! Give it a meaningful command path. Hoard more. The cozy nest is never crowded.</p>\n<h1 id=\"sd-a-history\"><code>sd</code>: a history</h1>\n<p>A year ago I published <a href=\"https://ianthehenry.com/posts/sd-my-script-directory/\">my first post about <code>sd</code></a>.</p>\n<p>At the time, <code>sd</code> was a bundle of assorted shell scripts that I cobbled together one afternoon in 2018. I only &ldquo;publicized&rdquo; it all because I wanted to refer to it from <a href=\"https://ianthehenry.com/posts/how-to-learn-nix/switching-from-homebrew-to-nix/\">another blog post</a> I was writing &ndash; I didn&rsquo;t even really launch it in any usable form; I just described the idea and linked to <a href=\"https://github.com/ianthehenry/dotfiles\">my dotfiles</a>. I didn&rsquo;t even bother giving it its own repo!</p>\n<p>But even in that barely-baked form, the project got a small amount of traction. People reached out to me about it &ndash; people who actually wanted to <em>use</em> <code>sd</code>. Which gave me a very good excuse to buckle down and rewrite it, and I&rsquo;m happy to announce that <code>sd</code> recently reached &ldquo;1.0&rdquo; status. It is officially <em>a thing that exists that you can use</em>, instead of &ldquo;an idea I had that you can implement.&rdquo;</p>\n<p>And the thing that exists is <em>much better</em> than the thing I described a year ago. In a few ways:</p>\n<p>First off, autocomplete is <em>much faster</em> than the original version. It used to run <code>find</code>, but now it uses some fancy shell globbing instead. There used to be the tinest delay after pressing tab, but now autocomplete feels instantenous. Which is how autocomplete <em>should</em> feel.</p>\n<p>Second off, <code>sd</code> now works as a <em>shell function</em> in addition to working as a standalone executable &ndash; mostly because it&rsquo;s very easy to install it and set up completion and everything with a shell plugin manager. <code>sd</code> is not officially packaged anywhere that I&rsquo;m aware of, so this is a pretty convenient way to install it, if you already use a zsh plugin manager.</p>\n<p>But the biggest change is an ergonomic one.</p>\n<p>The original <code>sd</code> didn&rsquo;t support any flags: the <em>only</em> thing it could do was run scripts in the <code>~/sd</code> directory. It came with some &ldquo;built-in&rdquo; commands, like <code>sd edit</code>, but those were just scripts like any other: <code>~/sd/edit</code>. This was <em>elegant</em>, I suppose, but I really just did it this way because it was easy to implement and I was lazy.</p>\n<p>There were a lot of downsides to that approach. It made installation nontrivial, because you had to bootstrap your <code>~/sd</code> directory with these &ldquo;built-in&rdquo; commands. There was no code sharing between these scripts &ndash; except by <em>assuming</em> that certain scripts existed in <code>~/sd</code>, and failing horribly if they didn&rsquo;t. There was no autocomplete for the built-in commands, so if you ran <code>sd edit some command</code> you had to type <code>some command</code> yourself. And when you were autocompleting a command at the top-level, you had to tab past all of these &ldquo;built-in&rdquo; scripts before you got to the command group that you wanted.</p>\n<p>The right answer was clearly to support <code>sd some command --edit</code>, but I hesitated adding argument parsing for a while, because I didn&rsquo;t like the idea of hijacking arguments. What if you wrote a script that expected a <code>--help</code>?</p>\n<p>I got over this, eventually. Mostly because <em>I have never written a script that used <code>--help</code></em> in my <code>~/sd</code>. Writing a script that parsed its arguments would imply that I was writing something other than a quick bash script, which would imply that <code>sd</code> might not be the best place for it.</p>\n<p>But I added an escape hatch <em>just in case:</em> you can run <code>sd some command --help --really</code>, and <code>sd</code> will execute <code>~/sd/some/command --help</code>. (And yes, you can also run <code>sd some command --help --really --really</code> if your script expects a <code>--really</code> flag. Have you ever written a script that expects a <code>--really</code> flag? I want to hear about that. That sounds like a fun script.)</p>\n<h1 id=\"the-future-of-sd\">the future of <code>sd</code></h1>\n<p>I dunno, it&rsquo;s just a cute little program? It doesn&rsquo;t have much of a future. Check it out. <a href=\"https://github.com/ianthehenry/sd\">Nourish my fragile ego by lavishing stars upon the repo.</a></p>",
  "pubDate": "Fri, 11 Mar 2022 00:00:00 +0000",
  "link": "https://ianthehenry.com/posts/a-cozy-nest-for-your-scripts/",
  "guid": "https://ianthehenry.com/posts/a-cozy-nest-for-your-scripts/"
}