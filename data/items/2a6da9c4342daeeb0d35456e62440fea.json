{
  "title": "ensemble networks",
  "link": "http://matpalm.com/blog/ensemble_nets",
  "category": [
    "objax",
    "projects",
    "ensemble_nets",
    "jax"
  ],
  "guid": "http://matpalm.com/blog/ensemble_nets",
  "description": "ensemble networks",
  "content:encoded": "<h1>overview</h1>\n<p>ensemble nets are a method of representing an ensemble of\n   models as one single logical model. we use\n   <a href=\"https://github.com/google/jax\">jax's</a>\n   <a href=\"https://github.com/google/jax#auto-vectorization-with-vmap\">vmap</a>\n   operation to batch over not\n   just the inputs but additionally sets of model parameters.\n   we propose some\n   approaches for training ensemble nets and introduce logit dropout as\n   a way to improve ensemble generalisation as well as provide\n   a method of calculating model confidence.\n</p>\n<p><b>update: though i originally developed this project using vmap, which\n   is how things are described below, the latest version of the\n   <a href=\"https://github.com/matpalm/ensemble_net\">code</a>\n   is a port to use <a href=\"https://github.com/google/jax#spmd-programming-with-pmap\">pmap</a>\n   so we can run on a tpu pod slice, not just one machine</b>\n</p>\n\n<h1>background</h1>\n<p>as part of my \"embedding the chickens\" project i wanted to use\n   random projection embedding networks to generate pairs of similar\n   images for weak labelling. since this technique works really well\n   in an ensemble i did some playing around and got the ensemble\n   running pretty fast in jax. i wrote it up in\n   <a href=\"/blog/jax_random_embedding_ensemble_network/\">this blog post</a>.\n   since doing that i've been wondering how to not just run an\n   ensemble net forward pass but how you might <em>train</em> one too...\n</p>\n\n<h1>dataset & problem</h1>\n<p>for this problem we'll work with the\n   <a href=\"https://github.com/phelber/eurosat\">eurosat/rgb dataset</a>.\n   eurosat/rgb is a 10 way classification task across 27,000 64x64 RGB images\n</p>\n<p>here's a sample image from each of the ten classes...\n</p>\n<img src=\"/blog/imgs/2020/en/sample_images.png\" />\n\n\n<h1>base line model</h1>\n\n<h2>architecture</h2>\n<p>as a baseline we'll start with a simple non ensemble network. it'll consist of\n   a pretty vanilla convolutional stack, global spatial pooling, one dense layer\n   and a final 10 way classification layer.\n</p>\n<table class='data'>\n<tr><td><b>layer</b></td><td><b>shape</b></td></tr>\n<tr><td>input</td><td>(B, 64, 64, 3)</td></tr>\n<tr><td>conv2d</td><td>(B, 31, 31, 32)</td></tr>\n<tr><td>conv2d</td><td>(B, 15, 15, 64)</td></tr>\n<tr><td>conv2d</td><td>(B, 7, 7, 96)</td></tr>\n<tr><td>conv2d</td><td>(B, 3, 3, 96)</td></tr>\n<tr><td>global spatial pooling</td><td>(B, 96)</td></tr>\n<tr><td>dense</td><td>(B, 96)</td></tr>\n<tr><td>logits (i.e. dense with no activation)</td><td>(B, 10)</td></tr>\n</table>\n\n<p>all convolutions use 3x3 kernels with a stride of 2. the conv layers and the single\n   dense layer use a gelu activation. batch size is represented by <code>B</code>.\n</p>\n<p>we use no batch norm, no residual connections, nothing fancy at all.\n   we're more interested in the training than getting the absolute best value.\n   this network is small enough that we can train it fast but it still gives\n   reasonable results. residual connections would be trivial to add but batch\n   norm would be a bit more tricky given how we'll build the ensemble net later.\n</p>\n<p>we'll use <a href=\"https://github.com/google/objax\">objax</a> to manage the model params\n   and orchestrate the training loops.\n</p>\n\n<h2>training setup</h2>\n<p>training for the baseline will be pretty standard but let's walk through it\n   so we can call out a couple of specific things for comparison with an ensemble\n   net later...\n</p>\n<p>( we'll use 2 classes in these diagrams for ease of reading though\n   the eurosat problem has 10 classes. )\n</p>\n<img src=\"/blog/imgs/2020/en/d.non_ensemble.png\" />\n\n<p>walking through left to right...\n</p>\n<ol>\n <li>\n     input is a batch of images; <code>(B, H, W, 3)</code>\n </li>\n\n <li>\n     the output of the first convolutional layers with stride=2 & 32 filters will be <code>(B, H/2, W/2, 32)</code>\n </li>\n\n <li>\n     the network output for an example two class problem are logits shaped <code>(B, 2)</code>\n </li>\n\n <li>\n     for prediction probabilities we apply a softmax to the logits\n </li>\n\n <li>\n     for training we use cross entropy, take the mean loss and apply backprop\n </li>\n</ol>\n<p>we'll train on 80% of the data, do hyperparam tuning on 10% (validation set) and\n   report final results on the remaining 10% (test set)\n</p>\n<p>for hyperparam tuning we'll use <a href=\"https://ax.dev/\">ax</a> on very short runs of 30min\n   for all trials.\n   for experiment tracking we'll use <a href=\"https://www.wandb.com/\">wandb</a>\n</p>\n<p>the hyperparams we'll tune for the baseline will be...\n</p>\n<table class='data'>\n<tr><td><b>param</b></td><td><b>description</b></td></tr>\n<tr>\n<td>max_conv_size</td>\n<td>conv layers with be sized as [32, 64, 128, 256]</br>\nup to a max size of max_conv_size.</br>\ni.e. a max_conv_size of 75 would imply sizes [32, 64, 75, 75]</br></td>\n</tr>\n<tr>\n<td>dense_kernel_size</td>\n<td>how many units in the dense layer before the logits</td>\n</tr>\n<tr>\n<td>learning_rate</td>\n<td>learning rate for optimiser</td>\n</tr>\n</table>\n\n<p>we'd usually make choices like the conv sizes being powers of 2 instead of a smooth value but\n   i was curious about the behaviour of ax for tuning.\n   also we didn't bother with a learning rate schedule; we just use simple early\n   stopping (against the validation set)\n</p>\n<img src=\"/blog/imgs/2020/en/single_model.all_runs.png\" />\n\n<p>the best model of this group gets an accuracy of 0.913 on the validation set\n   and 0.903 on the test set. ( usually not a fan of accuracy but the classes\n   are pretty balanced so accuracy isn't a terrible thing to report. )\n</p>\n<table class='data'>\n<tr><td><b>model</td><td><b>validation</b></td><td><b>test</b></td></tr>\n<tr><td>baseline</td><td>0.913</td><td>0.903</td></tr>\n</table>\n\n\n<h1>ensemble net model</h1>\n<p>so what then is an ensemble net?\n</p>\n<p>logically we can think about our models as being functions that take two\n   things 1) the parameters of the model and 2) an input example. from\n   these they return an output.\n</p>\n<pre class=\"prettyprint\"><code class=\"language-python\"># pseudo code\nmodel(params, input) -> output\n</code></pre>\n\n<p>we pretty much always though run a batch of <code>B</code> inputs at once.\n   this can be easily represented as a leading axis on the input and allows us to\n   make better use of accelerated hardware as well as providing some benefits regarding\n   learning w.r.t gradient variance.\n</p>\n<p>jax's\n   <a href=\"https://github.com/google/jax#auto-vectorization-with-vmap\">vmap</a>\n   function makes this trivial to implement by vectorising a call to the model\n   across a vector of inputs to return a vector of outputs.\n</p>\n<pre class=\"prettyprint\"><code class=\"language-python\"># pseudo code\nvmap(partial(model, params))(b_inputs) -> b_outputs\n</code></pre>\n\n<p>interestingly we can use this same functionality to batch not across independent\n   inputs but instead batch across independent sets of <code>M</code> model params. this effectively\n   means we run the <code>M</code> models in parallel. we'll call these <code>M</code> models sub models\n   from now on.\n</p>\n<pre class=\"prettyprint\"><code class=\"language-python\"># pseudo code\nvmap(partial(model, input))(m_params) -> m_outputs\n</code></pre>\n\n<p>and there's no reason why we can't do both batching across both a set of inputs\n   as well as a set of model params at the same time.\n</p>\n<pre class=\"prettyprint\"><code class=\"language-python\"># pseudo code\nvmap(partial(model)(b_inputs, m_params) -> b_m_outputs\n</code></pre>\n\n<p>for a lot more specifics on how i use jax's vmap to support this\n   see my prior post on\n   <a href=\"http://matpalm.com/blog/jax_random_embedding_ensemble_network/\">jax random embedding ensemble nets</a>.\n</p>\n<p>and did somebody say TPUs? turns out we can make ensemble nets run\n   super fast on TPUs by simply swapping the vmap calls for pmap ones!\n   using pmap on a TPU will have each ensemble net run in parallel! see\n   <a href=\"https://colab.research.google.com/drive/1ijI77AlYqGOEXm5BqtnNomtUPnFr26o0?usp=sharing\">this colab</a>\n   for example code running pmap on TPUs\n</p>\n\n<h2>single_input ensemble</h2>\n<p>let's walk through this in a bit more detail with an ensemble net with two sub models.\n</p>\n<img src=\"/blog/imgs/2020/en/d.single_input.png\" />\n\n<ol>\n <li>\n     our input is the same as for the baseline; a batch of images <code>(B, H, W, 3)</code>\n </li>\n\n <li>\n     the output of the first conv layer now though has an additional <code>M</code> axis to\nrepresent the outputs from the <code>M</code> models and results in <code>(M, B, H/2, W/2, 32)</code>\n </li>\n\n <li>\n     this additional <code>M</code> axis is carried all the way through to the logits <code>(M, B, 2)</code>\n </li>\n\n <li>\n     at this point we have <code>(M, B, 2)</code> logits but we need <code>(B, 2)</code>\nto compare against <code>(B,)</code> labels. with logits this reduction is\nvery simple; just sum over the <code>M</code> axis!\n </li>\n\n <li>\n     for prediction probabilities we again apply a softmax\n </li>\n\n <li>\n     for training we again use cross entropy to calculate the mean loss and apply backprop\n </li>\n</ol>\n<p>this gives us a way to train the sub models to act as a single ensemble unit as well as\n   a way to run inference on the ensemble net in a single forward pass.\n</p>\n<p>we'll refer to this approach as <strong>single_input</strong> since we are starting with a single\n   image for all sub models.\n</p>\n\n<h2>multi_input ensemble</h2>\n<p>an alternative approach to training is to provide a separate image per sub model.\n   how would things differ if we did that?\n</p>\n<img src=\"/blog/imgs/2020/en/d.multi_input.png\" />\n\n<ol>\n <li>\n     now our input has an additional <code>M</code> axis since it's a different batch per sub model.\n<code>(M, B, H, W, 3)</code>\n </li>\n\n <li>\n     the output of the first conv layers carries this <code>M</code> axis through <code>(M, B, H/2, W/2, 32)</code>\n </li>\n\n <li>\n     which is carried to the logits <code>(M, B, 2)</code>\n </li>\n\n <li>\n     in this case though we have <code>M</code> seperate labels for the <code>M</code> inputs so we don't have to combine the logits at all, we can just calculate the mean loss across the <code>(M, B)</code> training instances.\n </li>\n</ol>\n<p>we'll call this approach <strong>multi_input</strong>.\n   note that this way of feeding separate images only really applies to training;\n   for inference if we want the representation of the ensemble it only really makes\n   sense to send a batch of <code>(B)</code> images, not <code>(M, B)</code>.\n</p>\n\n<h2>training the ensemble net</h2>\n<p>let's do some tuning as before but with a couple of additional hyper\n   parameters that this time we'll sweep across.\n</p>\n<p>we'll do each of the six combos of <code>[(single, 2), (single, 4), (single, 8),\n(multi, 2), (multi, 4), (multi, 8)]</code> and tune for 30 min for each.\n</p>\n<img src=\"/blog/imgs/2020/en/single_multi_sweeps.png\" />\n\n<p>when we poke around and facet by the various params there's only one that makes\n   a difference; single_input mode consistently does better than multi_input.\n</p>\n<p>in hindsight this is not surprising i suppose since single_input mode\n   is effectively training one network with xM parameters\n   (with an odd summing-of-logits kind of bottleneck)\n</p>\n<img src=\"/blog/imgs/2020/en/validation_boxplot.png\" />\n\n\n<h1>confusion matrix per sub model</h1>\n\n<h2>single_input ensemble</h2>\n<p>when we check the best single_input 4 sub model ensemble net we get an accuracy of 0.920\n   against the validation set and 0.901 against the test set\n</p>\n<table class='data'>\n<tr><td><b>model</td><td><b>validation</b></td><td><b>test</b></td></tr>\n<tr><td>baseline</td><td>0.913</td><td>0.903</td></tr>\n<tr><td>single_input</td><td>0.920</td><td>0.901</td></tr>\n</table>\n\n<p>looking at the confusion matrix the only\n   really thing to note is the slight confusion between 'Permanent Crop' and\n   'Herbaceous Vegetation' which is reasonable given the similarity in RGB.\n</p>\n<img src=\"/blog/imgs/2020/en/cm.simo.ensemble.png\" />\n\n<p>we can also review the confusion matrices of each of the 4 sub models run as\n   individuals; i.e. not working as an ensemble. we observe the quality of each isn't\n   great with accuracies of [0.111, 0.634, 0.157, 0.686].\n   again makes sense since they had been trained only to work together. that first model\n   really loves 'Forests', but don't we all...\n</p>\n<table>\n<tr>\n<td><img src=\"/blog/imgs/2020/en/cm.simo.model_0.png\" /></td>\n<td><img src=\"/blog/imgs/2020/en/cm.simo.model_1.png\" /></td>\n</tr>\n<tr>\n<td><img src=\"/blog/imgs/2020/en/cm.simo.model_2.png\" /></td>\n<td><img src=\"/blog/imgs/2020/en/cm.simo.model_3.png\" /></td>\n</tr>\n</table>\n\n\n<h2>multi_input ensemble</h2>\n<p>the performance of the multi_input ensemble isn't quite as good with\n   a validation accuracy of 0.902 and test accuracy of 0.896.\n   the confusion matrix looks similar to the single_input mode version.\n</p>\n<table class='data'>\n<tr><td><b>model</td><td><b>validation</b></td><td><b>test</b></td></tr>\n<tr><td>baseline</td><td>0.913</td><td>0.903</td></tr>\n<tr><td>single_input</td><td>0.920</td><td>0.901</td></tr>\n<tr><td>multi_input</td><td>0.902</td><td>0.896</td></tr>\n</table>\n\n<img src=\"/blog/imgs/2020/en/cm.mimo.ensemble.png\" />\n\n<p>this time though the output of each of the 4 sub models individually is much stronger\n   with accuracies of [0.842, 0.85, 0.84, 0.83, 0.86]. this makes sense\n   since they were trained to not predict as one model.\n   it is nice to see at least that the ensemble result is higher than any one model.\n   and reviewing their confusion matrices they seem to specialise in different\n   aspects with differing pairs of confused classes.\n</p>\n<table>\n<tr>\n<td><img src=\"/blog/imgs/2020/en/cm.mimo.model_0.png\" /></td>\n<td><img src=\"/blog/imgs/2020/en/cm.mimo.model_1.png\" /></td>\n</tr>\n<tr>\n<td><img src=\"/blog/imgs/2020/en/cm.mimo.model_2.png\" /></td>\n<td><img src=\"/blog/imgs/2020/en/cm.mimo.model_3.png\" /></td>\n</tr>\n</table>\n\n\n<h1>dropping logits</h1>\n<p>the main failing of the single_input approach is that the sub models\n   are trained to always operate together; that breaks some of\n   the core ideas of why we do ensembles in the first place. as i was\n   thinking about this i was reminded that the core idea of dropout is\n   quite similar; when nodes in a dense layer are running together\n   we can drop some out to ensure other nodes don't overfit to\n   expecting them to always behave in a particular way.\n</p>\n<p>so let's do the same with the sub models of the ensemble. my first thought\n   around this was that the most logical place would be at the logits. we can\n   zero out the logits of a random half of the models during training and,\n   given the ensembling is implemented by summing the logits, this effectively\n   removes those models from the ensemble.\n   the biggest con though is the waste of the forward pass of running those sub\n   models in the first place.\n   during inference we don't have to do anything in terms of masking & there's no\n   need to do any rescaling ( that i can think of ).\n</p>\n<p>so how does it do? accuracy is 0.914 against the validation set and 0.911 against\n   the test set; the best result so far! TBH though, these numbers are pretty\n   close anyways so maybe we were just lucky ;)\n</p>\n<table class='data'>\n<tr><td><b>model</td><td><b>validation</b></td><td><b>test</b></td></tr>\n<tr><td>baseline</td><td>0.913</td><td>0.903</td></tr>\n<tr><td>single_input</td><td>0.920</td><td>0.901</td></tr>\n<tr><td>multi_input</td><td>0.902</td><td>0.896</td></tr>\n<tr><td>logit drop</td><td>0.914</td><td>0.911</td></tr>\n</table>\n\n<img src=\"/blog/imgs/2020/en/cm.simo_ld.ensemble.png\" />\n\n<p>the sub models are all now doing OK with accuracies of\n   [0.764, 0.827, 0.772, 0.710]. though the sub models aren't as\n   strong as the sub models of the multi_input mode, the overall\n   performance is the best. great! seems like a nice compromise\n   between the two!\n</p>\n<table>\n<tr>\n<td><img src=\"/blog/imgs/2020/en/cm.simo_ld.model_0.png\" /></td>\n<td><img src=\"/blog/imgs/2020/en/cm.simo_ld.model_1.png\" /></td>\n</tr>\n<tr>\n<td><img src=\"/blog/imgs/2020/en/cm.simo_ld.model_2.png\" /></td>\n<td><img src=\"/blog/imgs/2020/en/cm.simo_ld.model_3.png\" /></td>\n</tr>\n</table>\n\n\n<h1>wait! don't drop logits, drop models instead!</h1>\n<p>the main problem i had with dropping logits is that there\n   is a wasted forward pass for half the sub models. then i realised\n   why run the models at all? instead of dropping logits we can just\n   choose, through advanced indexing, a random half of the models to\n   run a forward pass through. this has the same effect of running a random\n   half of the models at a time but only requires half the forward pass\n   compute. this approach of dropping models is what the code currently does.\n   (though the dropping of logits is in the git history)\n</p>\n\n<h1>using the sub models to measure confidence</h1>\n<p>ensembles also provide a clean way of measuring confidence of\n   a prediction. if the variance of predictions across sub models is low\n   it implies the ensemble as a whole is confident.\n   alternatively if the variance is high it implies the ensemble is not confident.\n</p>\n<p>with the ensemble model that has been trained with logit dropout we can\n   get an idea of this variance by considering the ensemble in a hold-one-out\n   fashion; we can obtain <code>M</code> different predictions from the ensemble\n   by running it as if each of the <code>M</code> sub models was not present (using the same\n   idea as the logit dropout).\n</p>\n<p>consider a class that the ensemble is very good at; e.g. 'Sea & Lake'.\n   given a batch of 8 of these images across an ensemble net with 4 sub\n   models we get the following prediction mean and stddevs.\n</p>\n<table class='data'>\n<tr><td><b>idx</b></td>\n<td><b>y_pred</b></td>\n<td><b>mean(P(class))</b></td>\n<td><b>std(P(class))</td></b></tr>\n<tr><td>0</td><td>Sea & Lake</td><td>0.927</td><td>0.068</td></tr>\n<tr><td>1</td><td>Sea & Lake</td><td>1.000</td><td>0.000</td></tr>\n<tr><td>2</td><td>Sea & Lake</td><td>1.000</td><td>0.000</td></tr>\n<tr><td>3</td><td>Sea & Lake</td><td>0.999</td><td>0.001</td></tr>\n<tr><td>4</td><td>Sea & Lake</td><td>0.989</td><td>0.019</td></tr>\n<tr><td>5</td><td>Sea & Lake</td><td>1.000</td><td>0.000</td></tr>\n<tr><td>6</td><td>Sea & Lake</td><td>1.000</td><td>0.000</td></tr>\n<tr><td>7</td><td>Sea & Lake</td><td>1.000</td><td>0.000</td></tr>\n</table>\n\n<p>whereas when we look at a class the model is not so sure of,\n   e.g. 'Permanent Crop', we can see that for the lower probability cases\n   have a higher variance across the models.\n</p>\n<table class='data'>\n<tr><td><b>idx</b></td>\n<td><b>y_pred</b></td>\n<td><b>mean(P(class))</b></td>\n<td><b>std(P(class))</td></b></tr>\n<tr><td>0</td><td>Industrial Buildings</td><td>0.508</td><td>0.282</td></tr>\n<tr><td>1</td><td>Permanent Crop</td><td>0.979</td><td>0.021</td></tr>\n<tr><td>2</td><td>Permanent Crop</td><td>0.703</td><td>0.167</td></tr>\n<tr><td>3</td><td>Herbaceous Vegetation</td><td>0.808</td><td>0.231</td></tr>\n<tr><td>4</td><td>Permanent Crop</td><td>0.941</td><td>0.076</td></tr>\n<tr><td>5</td><td>Permanent Crop</td><td>0.979</td><td>0.014</td></tr>\n<tr><td>6</td><td>Permanent Crop</td><td>0.833</td><td>0.155</td></tr>\n<tr><td>7</td><td>Permanent Crop</td><td>0.968</td><td>0.025</td></tr>\n</table>\n\n\n<h1>conclusions</h1>\n<ul>\n <li>\n     jax vmap provides a great way to represent an ensemble in a single ensemble net.\n </li>\n\n <li>\n     we have a couple of options on how to train an ensemble net.\n </li>\n\n <li>\n     the single_input approach gives a good result, but each sub model is poor by itself.\n </li>\n\n <li>\n     multi_input trains each model to predict well, and the ensemble gets a bump.\n </li>\n\n <li>\n     logit dropout gives a way to stop the single_input ensemble from overfitting by\n     preventing sub models from specialising.\n </li>\n\n <li>\n     variance across the sub models predictions gives a hint of prediction confidence.\n </li>\n</ul>\n\n<h1>TODOs</h1>\n<ul>\n <li>\n     compare the performance of single_input mode vs multi_input mode normalising for\n     the number of effective parameters ( recall; single_input mode, without logit dropout,\n     is basically training a single xM param large model )\n </li>\n\n <li>\n     what is the effect of sharing an optimiser? would it be better to train each with\n     seperate optimisers? can't see why; but might be missing something..\n </li>\n</ul>\n\n<h1>code</h1>\n<p><a href=\"https://github.com/matpalm/ensemble_net\">all on github</a>\n</p>"
}