{
  "title": "Deep reinforcement learning, battleship",
  "link": "",
  "published": "2016-10-15T13:52:00-07:00",
  "updated": "2016-10-15T13:52:00-07:00",
  "author": {
    "name": "Jonathan Landy"
  },
  "id": "tag:efavdb.com,2016-10-15:/battleship",
  "summary": "<p>Here, we provide a brief introduction to reinforcement learning (<span class=\"caps\">RL</span>) &#8212; a general technique for training programs to play games efficiently. Our aim is to explain its practical implementation: We cover some basic theory and then walk through a minimal python program that trains a neural network to play the game …</p>",
  "content": "<p>Here, we provide a brief introduction to reinforcement learning (<span class=\"caps\">RL</span>) &#8212; a general technique for training programs to play games efficiently. Our aim is to explain its practical implementation: We cover some basic theory and then walk through a minimal python program that trains a neural network to play the game&nbsp;battleship.</p>\n<h3>Introduction</h3>\n<p>Reinforcement learning (<span class=\"caps\">RL</span>) techniques are methods that can be used to teach algorithms to play games efficiently. Like supervised machine-learning (<span class=\"caps\">ML</span>) methods, <span class=\"caps\">RL</span> algorithms learn from data &#8212; in this case, past game play data. However, whereas supervised-learning algorithms train only on data that is already available, <span class=\"caps\">RL</span> addresses the challenge of performing well while still in the process of collecting data. In particular, we seek design principles&nbsp;that</p>\n<ul>\n<li>Allow programs to identify good strategies from past&nbsp;examples,</li>\n<li>Enable fast learning of new strategies through continued game&nbsp;play.</li>\n</ul>\n<p>The reason we particularly want our algorithms to learn fast here is that <span class=\"caps\">RL</span> is most fruitfully applied in contexts where training data is limited &#8212; or where the space of strategies is so large that it would be difficult to explore exhaustively. It is in these regimes that supervised techniques have trouble and <span class=\"caps\">RL</span> methods&nbsp;shine.</p>\n<p>In this post, we review one general <span class=\"caps\">RL</span> training procedure: The policy-gradient, deep-learning scheme. We review the theory behind this approach in the next section. Following that, we walk through a simple python implementation that trains a neural network to play the game&nbsp;battleship.</p>\n<p>Our python code can be downloaded from our github page, <a href=\"https://github.com/EFavDB/battleship\">here</a>. It requires the jupyter, tensorflow, numpy, and matplotlib&nbsp;packages.</p>\n<h3>Policy-gradient, deep <span class=\"caps\">RL</span></h3>\n<p>Policy-gradient, deep <span class=\"caps\">RL</span> algorithms consist of two main components: A policy network and a rewards function. We detail these two below and then describe how they work together to train good&nbsp;models.</p>\n<h4>The policy&nbsp;network</h4>\n<p>The policy for a given deep <span class=\"caps\">RL</span> algorithm is a neural network that maps state values <span class=\"math\">\\(s\\)</span> to probabilities for given game actions <span class=\"math\">\\(a\\)</span>. In other words, the input layer of the network accepts a numerical encoding of the environment &#8212; the state of the game at a particular moment. When this input is fed through the network, the values at the output layer correspond to the log probabilities that each of the actions available to us is optimal &#8212; one output node is present for each possible action that we can choose. Note that if we knew with certainty which move we should take, only one output node would have a finite probability. However, if our network is uncertain which action is optimal, more than one output node will have finite&nbsp;weight.</p>\n<p>To illustrate the above, we present a diagram of the network used in our battleship program below. (For a review of the rules of battleship, see footnote [1].) For simplicity, we work with a 1-d battleship grid. We then encode our current knowledge of the environment using one input neuron for each of our opponent&#8217;s grid positions. In particular, we use the following encoding for each neuron /&nbsp;index:</p>\n<div class=\"math\">\\begin{align} \\label{input} \\tag{1}\nx_{0,i} = \\begin{cases}\n-1 &amp; \\text{Have not yet bombed $i$} \\\\\n\\ 0 &amp; \\text{Have bombed $i$, no ship} \\\\\n+1 &amp; \\text{Have bombed $i$, ship present}.\n\\end{cases}\n\\end{align}</div>\n<p>\nIn our example figure below, we have five input neurons, so the board is of size five. The first three neurons have value <span class=\"math\">\\(-1\\)</span> implying we have not yet bombed those grid points. Finally, the last two are <span class=\"math\">\\(+1\\)</span> and <span class=\"math\">\\(0\\)</span>, respectively, implying that a ship does sit at the fourth site, but not at the&nbsp;fifth.</p>\n<p><a href=\"https://efavdb.com/wp-content/uploads/2016/10/nn.jpg\"><img alt=\"network\" src=\"https://efavdb.com/wp-content/uploads/2016/10/nn.jpg\"></a></p>\n<p>Note that in the output layer of the policy network shown, the first three values are labeled with log probabilities. These values correspond to the probabilities that we should next bomb each of these indices, respectively. We cannot re-bomb the fourth and fifth grid points, so although the network may output some values to these neurons, we&#8217;ll ignore&nbsp;them.</p>\n<p>Before moving on, we note that the reason we use a neural network for our policy is to allow for efficient generalization: For games like Go that have a very large number of states, it is not feasible to collect data on every possible board position. This is exactly the context where <span class=\"caps\">ML</span> algorithms excel &#8212; generalizing from past observations to make good predictions for new situations. In order to keep our focus on <span class=\"caps\">RL</span>, we won&#8217;t review how <span class=\"caps\">ML</span> algorithms work in this post (however, you can check out our <a href=\"http://efavdb.github.io/archives\">archives</a> section for relevant primers). Instead we simply note that &#8212; utilizing these tools &#8212; we can get good performance by training only on a <em>representative subset</em> of games &#8212; allowing us to avoid study of the full set, which can be much&nbsp;larger.</p>\n<h4>The rewards&nbsp;function</h4>\n<p>To train an <span class=\"caps\">RL</span> algorithm, we must carry out an iterative game play / scoring process: We play games according to our current policy, selecting moves with frequencies proportional to the probabilities output by the network. If the actions taken resulted in good outcomes, we want to strengthen the probability of those actions going&nbsp;forward.</p>\n<p>The rewards function is the tool we use to formally score our outcomes in past games &#8212; we will encourage our algorithm to try to maximize this quantity during game play. In effect, it is a hyper-parameter for the <span class=\"caps\">RL</span> algorithm: many different functions could be used, each resulting in different learning characteristics. For our battleship program, we have used the&nbsp;function\n</p>\n<div class=\"math\">\\begin{align} \\label{rewards} \\tag{2}\nr(a;t_0) = \\sum_{t \\geq t_0} \\left ( h(t) - \\overline{h(t)} \\right) (0.5)^{t-t0}\n\\end{align}</div>\n<p>\nGiven a completed game log, this function looks at the action <span class=\"math\">\\(a\\)</span> taken at time <span class=\"math\">\\(t_0\\)</span> and returns a weighted sum of hit values <span class=\"math\">\\(h(t)\\)</span> for this and all future steps in the game. Here, <span class=\"math\">\\(h(t)\\)</span> is <span class=\"math\">\\(1\\)</span> if we had a hit at step <span class=\"math\">\\(t\\)</span> and is <span class=\"math\">\\(0\\)</span>&nbsp;otherwise.</p>\n<p>In arriving at (\\ref{rewards}), we admit that we did not carry out a careful search over the set of all possible rewards functions. However, we have confirmed that this choice results in good game play, and it is well-motivated: In particular, we note that the weighting term <span class=\"math\">\\((0.5)^{t-t0}\\)</span> serves to strongly incentivize a hit on the current move (we get a reward of <span class=\"math\">\\(1\\)</span> for a hit at <span class=\"math\">\\(t_0\\)</span>), but a hit at <span class=\"math\">\\((t_0 + 1)\\)</span> also rewards the action at <span class=\"math\">\\(t_0\\)</span> &#8212; with value <span class=\"math\">\\(0.5\\)</span>. Similarly, a hit at <span class=\"math\">\\((t_0 + 2)\\)</span> rewards <span class=\"math\">\\(0.25\\)</span>, etc. This weighted look-ahead aspect of (\\ref{rewards}) serves to encourage efficient exploration of the board: It forces the program to care about moves that will enable future hits. The other ingredient of note present in (\\ref{rewards}) is the subtraction of <span class=\"math\">\\(\\overline{h(t)}\\)</span>. This is the expected rewards that a random network would obtain. By pulling this out, we only reward our network if it is outperforming random choices &#8212; this results in a net speed-up of the learning&nbsp;process.</p>\n<h4>Stochastic gradient&nbsp;descent</h4>\n<p>In order to train our algorithm to maximize captured rewards during game play, we apply gradient descent. To carry this out, we imagine allowing our network parameters <span class=\"math\">\\(\\theta\\)</span> to vary at some particular step in the game. Averaging over all possible actions, the gradient of the expected rewards is then&nbsp;formally,\n</p>\n<div class=\"math\">\\begin{align} \\nonumber\n\\partial_{\\theta} \\langle r(a \\vert s) \\rangle &amp;\\equiv &amp; \\partial_{\\theta} \\int p(a \\vert \\theta, s) r(a \\vert s) da \\\\ \\nonumber\n&amp;=&amp; \\int p(a \\vert \\theta, s) r(a \\vert s) \\partial_{\\theta} \\log \\left ( p(a \\vert \\theta, s) \\right) da \\\\\n&amp;\\equiv &amp; \\langle r(a \\vert s) \\partial_{\\theta} \\log \\left ( p(a \\vert \\theta, s) \\right) \\rangle. \\tag{3} \\label{formal_ev}\n\\end{align}</div>\n<p>\nHere, the <span class=\"math\">\\(p(a)\\)</span> values are the action probability outputs of our&nbsp;network.</p>\n<p>Unfortunately, we usually can&#8217;t evaluate the last line above. However, what we can do is approximate it using a sampled value: We simply play a game with our current network, then replace the expected value above by the reward actually captured on the <span class=\"math\">\\(i\\)</span>-th&nbsp;move,\n</p>\n<div class=\"math\">\\begin{align}\n\\hat{g}_i = r(a_i) \\nabla_{\\theta} \\log p(a_i \\vert s_i, \\theta). \\tag{4} \\label{estimator}\n\\end{align}</div>\n<p>\nHere, <span class=\"math\">\\(a_i\\)</span> is the action that was taken, <span class=\"math\">\\(r(a_i)\\)</span> is reward that was captured, and the derivative of the logarithm shown can be evaluated via back-propagation (aside for those experienced with neural networks: this is the derivative of the cross-entropy loss function that would apply if you treated the event like a supervised-learning training example &#8212; with the selected action <span class=\"math\">\\(a_i\\)</span> taken as the label). The function <span class=\"math\">\\(\\hat{g}_i\\)</span> provides a noisy estimate of the desired gradient, but taking many steps will result in a &#8220;stochastic&#8221; gradient descent, on average pushing us towards correct rewards&nbsp;maximization.</p>\n<h4>Summary of the training&nbsp;process</h4>\n<p>In summary, then, <span class=\"caps\">RL</span> training proceeds iteratively: To initialize an iterative step, we first play a game with our current policy network, selecting moves stochastically according to the network&#8217;s output. After the game is complete, we then score our outcome by evaluating the rewards captured on each move &#8212; for example, in the battleship game we use (\\ref{rewards}). Once this is done, we then estimate the gradient of the rewards function using (\\ref{estimator}). Finally, we update the network parameters, moving <span class=\"math\">\\(\\theta \\to \\theta + \\alpha \\sum \\hat{g}_i\\)</span>, with <span class=\"math\">\\(\\alpha\\)</span> a small step size parameter. To continue, we then play a new game with the updated network,&nbsp;etc.</p>\n<p>To see that this process does, in fact, encourage actions that have resulted in good outcomes during training, note that (\\ref{estimator}) is proportional to the rewards captured at the step <span class=\"math\">\\(i\\)</span>. Consequently, when we adjust our parameters in the direction of (\\ref{estimator}), we will strongly encourage those actions that have resulted in large rewards outcomes. Further, those moves with negative rewards are actually suppressed. In this way, over time, the network will learn to examine the system and suggest those moves that will likely produce the best&nbsp;outcomes.</p>\n<p>That&#8217;s it for the basics of deep, policy-gradient <span class=\"caps\">RL</span>. We now turn to our python example,&nbsp;battleship.</p>\n<h3>Python code walkthrough &#8212; battleship <span class=\"caps\">RL</span></h3>\n<p>Load the needed&nbsp;packages.</p>\n<div class=\"highlight\"><pre><span></span><span class=\"kn\">import</span> <span class=\"nn\">tensorflow</span> <span class=\"k\">as</span> <span class=\"nn\">tf</span>\n<span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"o\">%</span><span class=\"n\">matplotlib</span> <span class=\"n\">inline</span>\n<span class=\"kn\">import</span> <span class=\"nn\">pylab</span>\n</pre></div>\n\n\n<p>Define our network &#8212; a fully connected, three layer system. The code below is mostly tensorflow boilerplate that can be picked up by going through their first tutorials. The one unusual thing is that we have our learning rate in (26) set to the placeholder value (9). This will allow us to vary our step sizes with observed rewards captured&nbsp;below.</p>\n<div class=\"highlight\"><pre><span></span><span class=\"n\">BOARD_SIZE</span> <span class=\"o\">=</span> <span class=\"mi\">10</span>\n<span class=\"n\">SHIP_SIZE</span> <span class=\"o\">=</span> <span class=\"mi\">3</span>\n\n<span class=\"n\">hidden_units</span> <span class=\"o\">=</span> <span class=\"n\">BOARD_SIZE</span>\n<span class=\"n\">output_units</span> <span class=\"o\">=</span> <span class=\"n\">BOARD_SIZE</span>\n\n<span class=\"n\">input_positions</span> <span class=\"o\">=</span> <span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">placeholder</span><span class=\"p\">(</span><span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">float32</span><span class=\"p\">,</span> <span class=\"n\">shape</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">BOARD_SIZE</span><span class=\"p\">))</span>\n<span class=\"n\">labels</span> <span class=\"o\">=</span> <span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">placeholder</span><span class=\"p\">(</span><span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">int64</span><span class=\"p\">)</span>\n<span class=\"n\">learning_rate</span> <span class=\"o\">=</span> <span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">placeholder</span><span class=\"p\">(</span><span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">float32</span><span class=\"p\">,</span> <span class=\"n\">shape</span><span class=\"o\">=</span><span class=\"p\">[])</span>\n<span class=\"c1\"># Generate hidden layer</span>\n<span class=\"n\">W1</span> <span class=\"o\">=</span> <span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">Variable</span><span class=\"p\">(</span><span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">truncated_normal</span><span class=\"p\">([</span><span class=\"n\">BOARD_SIZE</span><span class=\"p\">,</span> <span class=\"n\">hidden_units</span><span class=\"p\">],</span>\n    <span class=\"n\">stddev</span><span class=\"o\">=</span><span class=\"mf\">0.1</span> <span class=\"o\">/</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sqrt</span><span class=\"p\">(</span><span class=\"nb\">float</span><span class=\"p\">(</span><span class=\"n\">BOARD_SIZE</span><span class=\"p\">))))</span>\n<span class=\"n\">b1</span> <span class=\"o\">=</span> <span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">Variable</span><span class=\"p\">(</span><span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">zeros</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">hidden_units</span><span class=\"p\">]))</span>\n<span class=\"n\">h1</span> <span class=\"o\">=</span> <span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">tanh</span><span class=\"p\">(</span><span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">matmul</span><span class=\"p\">(</span><span class=\"n\">input_positions</span><span class=\"p\">,</span> <span class=\"n\">W1</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"n\">b1</span><span class=\"p\">)</span>\n<span class=\"c1\"># Second layer -- linear classifier for action logits</span>\n<span class=\"n\">W2</span> <span class=\"o\">=</span> <span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">Variable</span><span class=\"p\">(</span><span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">truncated_normal</span><span class=\"p\">([</span><span class=\"n\">hidden_units</span><span class=\"p\">,</span> <span class=\"n\">output_units</span><span class=\"p\">],</span>\n    <span class=\"n\">stddev</span><span class=\"o\">=</span><span class=\"mf\">0.1</span> <span class=\"o\">/</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sqrt</span><span class=\"p\">(</span><span class=\"nb\">float</span><span class=\"p\">(</span><span class=\"n\">hidden_units</span><span class=\"p\">))))</span>\n<span class=\"n\">b2</span> <span class=\"o\">=</span> <span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">Variable</span><span class=\"p\">(</span><span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">zeros</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">output_units</span><span class=\"p\">]))</span>\n<span class=\"n\">logits</span> <span class=\"o\">=</span> <span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">matmul</span><span class=\"p\">(</span><span class=\"n\">h1</span><span class=\"p\">,</span> <span class=\"n\">W2</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"n\">b2</span>\n<span class=\"n\">probabilities</span> <span class=\"o\">=</span> <span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">softmax</span><span class=\"p\">(</span><span class=\"n\">logits</span><span class=\"p\">)</span>\n\n<span class=\"n\">init</span> <span class=\"o\">=</span> <span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">initialize_all_variables</span><span class=\"p\">()</span>\n<span class=\"n\">cross_entropy</span> <span class=\"o\">=</span> <span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">sparse_softmax_cross_entropy_with_logits</span><span class=\"p\">(</span>\n    <span class=\"n\">logits</span><span class=\"p\">,</span> <span class=\"n\">labels</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">&#39;xentropy&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">train_step</span> <span class=\"o\">=</span> <span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">train</span><span class=\"o\">.</span><span class=\"n\">GradientDescentOptimizer</span><span class=\"p\">(</span>\n<span class=\"n\">learning_rate</span><span class=\"o\">=</span><span class=\"n\">learning_rate</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">minimize</span><span class=\"p\">(</span><span class=\"n\">cross_entropy</span><span class=\"p\">)</span>\n<span class=\"c1\"># Start TF session</span>\n<span class=\"n\">sess</span> <span class=\"o\">=</span> <span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">Session</span><span class=\"p\">()</span>\n<span class=\"n\">sess</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"n\">init</span><span class=\"p\">)</span>\n</pre></div>\n\n\n<p>Next, we define a method that will allow us to play a game using our network. The <span class=\"caps\">TRAINING</span> variable specifies whether or not to take the optimal moves or to select moves stochastically. Note that the method returns a set of logs that record the game proceedings. These are needed for&nbsp;training.</p>\n<div class=\"highlight\"><pre><span></span><span class=\"n\">TRAINING</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>\n<span class=\"k\">def</span> <span class=\"nf\">play_game</span><span class=\"p\">(</span><span class=\"n\">training</span><span class=\"o\">=</span><span class=\"n\">TRAINING</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot; Play game of battleship using network.&quot;&quot;&quot;</span>\n    <span class=\"c1\"># Select random location for ship</span>\n    <span class=\"n\">ship_left</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">randint</span><span class=\"p\">(</span><span class=\"n\">BOARD_SIZE</span> <span class=\"o\">-</span> <span class=\"n\">SHIP_SIZE</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n    <span class=\"n\">ship_positions</span> <span class=\"o\">=</span> <span class=\"nb\">set</span><span class=\"p\">(</span><span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">ship_left</span><span class=\"p\">,</span> <span class=\"n\">ship_left</span> <span class=\"o\">+</span> <span class=\"n\">SHIP_SIZE</span><span class=\"p\">))</span>\n    <span class=\"c1\"># Initialize logs for game</span>\n    <span class=\"n\">board_position_log</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n    <span class=\"n\">action_log</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n    <span class=\"n\">hit_log</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n    <span class=\"c1\"># Play through game</span>\n    <span class=\"n\">current_board</span> <span class=\"o\">=</span> <span class=\"p\">[[</span><span class=\"o\">-</span><span class=\"mi\">1</span> <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">BOARD_SIZE</span><span class=\"p\">)]]</span>\n    <span class=\"k\">while</span> <span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"n\">hit_log</span><span class=\"p\">)</span> <span class=\"o\">&lt;</span> <span class=\"n\">SHIP_SIZE</span><span class=\"p\">:</span>\n        <span class=\"n\">board_position_log</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">([[</span><span class=\"n\">i</span> <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"n\">current_board</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]]])</span>\n        <span class=\"n\">probs</span> <span class=\"o\">=</span> <span class=\"n\">sess</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">([</span><span class=\"n\">probabilities</span><span class=\"p\">],</span> <span class=\"n\">feed_dict</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"n\">input_positions</span><span class=\"p\">:</span><span class=\"n\">current_board</span><span class=\"p\">})[</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n        <span class=\"n\">probs</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">p</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">index</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"n\">action_log</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">index</span><span class=\"p\">,</span> <span class=\"n\">p</span> <span class=\"ow\">in</span> <span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"n\">probs</span><span class=\"p\">)]</span>\n        <span class=\"n\">probs</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">p</span> <span class=\"o\">/</span> <span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"n\">probs</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">p</span> <span class=\"ow\">in</span> <span class=\"n\">probs</span><span class=\"p\">]</span>\n        <span class=\"k\">if</span> <span class=\"n\">training</span> <span class=\"o\">==</span> <span class=\"kc\">True</span><span class=\"p\">:</span>\n            <span class=\"n\">bomb_index</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">choice</span><span class=\"p\">(</span><span class=\"n\">BOARD_SIZE</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"o\">=</span><span class=\"n\">probs</span><span class=\"p\">)</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"n\">bomb_index</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">argmax</span><span class=\"p\">(</span><span class=\"n\">probs</span><span class=\"p\">)</span>\n        <span class=\"c1\"># update board, logs</span>\n        <span class=\"n\">hit_log</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">bomb_index</span> <span class=\"ow\">in</span> <span class=\"n\">ship_positions</span><span class=\"p\">))</span>\n        <span class=\"n\">current_board</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"n\">bomb_index</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">bomb_index</span> <span class=\"ow\">in</span> <span class=\"n\">ship_positions</span><span class=\"p\">)</span>\n        <span class=\"n\">action_log</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">bomb_index</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">board_position_log</span><span class=\"p\">,</span> <span class=\"n\">action_log</span><span class=\"p\">,</span> <span class=\"n\">hit_log</span>\n</pre></div>\n\n\n<p>Our implementation of the rewards function&nbsp;(\\ref{rewards}):</p>\n<div class=\"highlight\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">rewards_calculator</span><span class=\"p\">(</span><span class=\"n\">hit_log</span><span class=\"p\">,</span> <span class=\"n\">gamma</span><span class=\"o\">=</span><span class=\"mf\">0.5</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot; Discounted sum of future hits over trajectory&quot;&quot;&quot;</span>\n    <span class=\"n\">hit_log_weighted</span> <span class=\"o\">=</span> <span class=\"p\">[(</span><span class=\"n\">item</span> <span class=\"o\">-</span>\n    <span class=\"nb\">float</span><span class=\"p\">(</span><span class=\"n\">SHIP_SIZE</span> <span class=\"o\">-</span> <span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"n\">hit_log</span><span class=\"p\">[:</span><span class=\"n\">index</span><span class=\"p\">]))</span> <span class=\"o\">/</span> <span class=\"nb\">float</span><span class=\"p\">(</span><span class=\"n\">BOARD_SIZE</span> <span class=\"o\">-</span> <span class=\"n\">index</span><span class=\"p\">))</span> <span class=\"o\">*</span> <span class=\"p\">(</span>\n        <span class=\"n\">gamma</span> <span class=\"o\">**</span> <span class=\"n\">index</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">index</span><span class=\"p\">,</span> <span class=\"n\">item</span> <span class=\"ow\">in</span> <span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"n\">hit_log</span><span class=\"p\">)]</span>\n    <span class=\"k\">return</span> <span class=\"p\">[((</span><span class=\"n\">gamma</span><span class=\"p\">)</span> <span class=\"o\">**</span> <span class=\"p\">(</span><span class=\"o\">-</span><span class=\"n\">i</span><span class=\"p\">))</span> <span class=\"o\">*</span> <span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"n\">hit_log_weighted</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">:])</span> <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">hit_log</span><span class=\"p\">))]</span>\n</pre></div>\n\n\n<p>Finally, our training loop. Here, we iteratively play through many games, scoring after each game, then adjusting parameters &#8212; setting the placeholder learning rate equal to <span class=\"caps\">ALPHA</span> times the rewards&nbsp;captured.</p>\n<div class=\"highlight\"><pre><span></span><span class=\"n\">game_lengths</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n<span class=\"n\">TRAINING</span> <span class=\"o\">=</span> <span class=\"kc\">True</span> <span class=\"c1\"># Boolean specifies training mode</span>\n<span class=\"n\">ALPHA</span> <span class=\"o\">=</span> <span class=\"mf\">0.06</span> <span class=\"c1\"># step size</span>\n\n<span class=\"k\">for</span> <span class=\"n\">game</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">10000</span><span class=\"p\">):</span>\n    <span class=\"n\">board_position_log</span><span class=\"p\">,</span> <span class=\"n\">action_log</span><span class=\"p\">,</span> <span class=\"n\">hit_log</span> <span class=\"o\">=</span> <span class=\"n\">play_game</span><span class=\"p\">(</span><span class=\"n\">training</span><span class=\"o\">=</span><span class=\"n\">TRAINING</span><span class=\"p\">)</span>\n    <span class=\"n\">game_lengths</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">action_log</span><span class=\"p\">))</span>\n    <span class=\"n\">rewards_log</span> <span class=\"o\">=</span> <span class=\"n\">rewards_calculator</span><span class=\"p\">(</span><span class=\"n\">hit_log</span><span class=\"p\">)</span>\n    <span class=\"k\">for</span> <span class=\"n\">reward</span><span class=\"p\">,</span> <span class=\"n\">current_board</span><span class=\"p\">,</span> <span class=\"n\">action</span> <span class=\"ow\">in</span> <span class=\"nb\">zip</span><span class=\"p\">(</span><span class=\"n\">rewards_log</span><span class=\"p\">,</span> <span class=\"n\">board_position_log</span><span class=\"p\">,</span> <span class=\"n\">action_log</span><span class=\"p\">):</span>\n        <span class=\"c1\"># Take step along gradient</span>\n        <span class=\"k\">if</span> <span class=\"n\">TRAINING</span><span class=\"p\">:</span>\n            <span class=\"n\">sess</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">([</span><span class=\"n\">train_step</span><span class=\"p\">],</span>\n                <span class=\"n\">feed_dict</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"n\">input_positions</span><span class=\"p\">:</span><span class=\"n\">current_board</span><span class=\"p\">,</span> <span class=\"n\">labels</span><span class=\"p\">:[</span><span class=\"n\">action</span><span class=\"p\">],</span> <span class=\"n\">learning_rate</span><span class=\"p\">:</span><span class=\"n\">ALPHA</span> <span class=\"o\">*</span> <span class=\"n\">reward</span><span class=\"p\">})</span>\n</pre></div>\n\n\n<p>Running this last cell, we see that the training works! The following is an example trace from the play_game() method, with the variable <span class=\"caps\">TRAINING</span> set to False. This illustrates an intelligent move selection&nbsp;process.</p>\n<div class=\"highlight\"><pre><span></span><span class=\"c1\"># Example game trace output</span>\n<span class=\"p\">([[[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]],</span>\n<span class=\"p\">[[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]],</span>\n<span class=\"p\">[[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]],</span>\n<span class=\"p\">[[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]],</span>\n<span class=\"p\">[[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]]],</span>\n<span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">6</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"mi\">8</span><span class=\"p\">],</span>\n<span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">])</span>\n</pre></div>\n\n\n<p>Here, the first five lines are the board encodings that the network was fed each step &#8212; using (\\ref{input}). The second to last row presents the sequential grid selections that were chosen. Finally, the last row is the hit log. Notice that the first two moves nicely sample different regions of the board. After this, a hit was recorded at <span class=\"math\">\\(6\\)</span>. The algorithm then intelligently selects <span class=\"math\">\\(7\\)</span> and <span class=\"math\">\\(8\\)</span>, which it can infer must be the final locations of the&nbsp;ship.</p>\n<p>The plot below provides further characterization of the learning process. This shows the running average game length (steps required to fully bomb ship) versus training epoch. The program learns the basics quite quickly, then continues to gradually improve over time&nbsp;[2].</p>\n<p><a href=\"https://efavdb.com/wp-content/uploads/2016/10/trace.jpg\"><img alt=\"trace\" src=\"https://efavdb.com/wp-content/uploads/2016/10/trace.jpg\"></a></p>\n<h3>Summary</h3>\n<p>In this post, we have covered a variant of <span class=\"caps\">RL</span> &#8212; namely, the policy-gradient, deep <span class=\"caps\">RL</span> scheme. This is a method that typically defaults to the currently best-known strategy, but occasionally samples from other approaches, ultimately resulting in an iterative improvement in policy. The two main ingredients here are the policy network and the rewards function. Although network architecture design is usually the place where most of the thinking is involved in supervised learning, it is the rewards function that typically requires the most thought in the <span class=\"caps\">RL</span> context. A good choice should be as local in time as possible, so as to facilitate training (distant forecast dependence will result in a slow learning process). However, the rewards function should also directly attack the ultimate end of the process (&#8220;winning&#8221; the game &#8212; encouragement of side quests that aren&#8217;t necessary can often occur if care is not taken). Balancing these two competing demands can be a challenge, and rewards function design is therefore something of an art&nbsp;form.</p>\n<p>Our brief introduction here was intended only to illustrate the gist of how <span class=\"caps\">RL</span> is carried out in practice. For further details, we can recommend two resources: the text book by Sutton and Barto [3] and a recent talk by John Schulman&nbsp;[4].</p>\n<h3>Footnotes and&nbsp;references</h3>\n<p>[1] Game rules: Battleship is a two-player game. Both players begin with a finite regular grid of positions &#8212; hidden from their opponent &#8212; and a set of &#8220;ships&#8221;. Each player receives the same quantity of each type of ship. At the start of the game, each player places the ships on their grid in whatever locations they like, subject to some constraints: A ship of length 2, say, must occupy two contiguous indices on the board, and no two ships can occupy the same grid location. Once placed, the ships are fixed in position for the remainder of the game. At this point, game play begins, with the goal being to sink the opponent ships. The locations of the enemy ships are initially unknown because we cannot see the opponent&#8217;s grid. To find the ships, one &#8220;bombs&#8221; indices on the enemy grid &#8212; with bombing occurs in turns. When an opponent index is bombed, the opponent must truthfully state whether or not a ship was located at the index bombed. Whoever succeeds in bombing all their opponent&#8217;s occupied indices first wins the game. Therefore, the problem reduces to finding the enemy ship indices as quickly as&nbsp;possible.</p>\n<p>[2] One of my colleagues (<span class=\"caps\">HC</span>) has suggested that the program likely begins to overfit at some point. However, the 1-d version of the game has so few possible ship locations that characterization of this effect via a training and test set split does not seem appropriate. However, this approach could work were we to move to higher dimensions and introduce multiple&nbsp;ships.</p>\n<p>[3] Sutton and Barto, (2016). &#8220;Reinforcement Learning: An Introduction&#8221;. Text site, <a href=\"https://webdocs.cs.ualberta.ca/~sutton/book/the-book.html\">here</a>.</p>\n<p>[4] John Schulman, (2016). &#8220;Bay Area Deep Learning School&#8221;. Youtube recording of talk available <a href=\"https://www.youtube.com/watch?v=9dXiAecyJrY\">here</a>.</p>\n<script type=\"text/javascript\">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {\n    var align = \"center\",\n        indent = \"0em\",\n        linebreak = \"false\";\n\n    if (false) {\n        align = (screen.width < 768) ? \"left\" : align;\n        indent = (screen.width < 768) ? \"0em\" : indent;\n        linebreak = (screen.width < 768) ? 'true' : linebreak;\n    }\n\n    var mathjaxscript = document.createElement('script');\n    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';\n    mathjaxscript.type = 'text/javascript';\n    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';\n\n    var configscript = document.createElement('script');\n    configscript.type = 'text/x-mathjax-config';\n    configscript[(window.opera ? \"innerHTML\" : \"text\")] =\n        \"MathJax.Hub.Config({\" +\n        \"    config: ['MMLorHTML.js'],\" +\n        \"    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } },\" +\n        \"    jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" +\n        \"    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" +\n        \"    displayAlign: '\"+ align +\"',\" +\n        \"    displayIndent: '\"+ indent +\"',\" +\n        \"    showMathMenu: true,\" +\n        \"    messageStyle: 'normal',\" +\n        \"    tex2jax: { \" +\n        \"        inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" +\n        \"        displayMath: [ ['$$','$$'] ],\" +\n        \"        processEscapes: true,\" +\n        \"        preview: 'TeX',\" +\n        \"    }, \" +\n        \"    'HTML-CSS': { \" +\n        \"        availableFonts: ['STIX', 'TeX'],\" +\n        \"        preferredFont: 'STIX',\" +\n        \"        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" +\n        \"        linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" +\n        \"    }, \" +\n        \"}); \" +\n        \"if ('default' !== 'default') {\" +\n            \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" +\n                \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" +\n                \"VARIANT['normal'].fonts.unshift('MathJax_default');\" +\n                \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" +\n                \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" +\n                \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" +\n            \"});\" +\n            \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" +\n                \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" +\n                \"VARIANT['normal'].fonts.unshift('MathJax_default');\" +\n                \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" +\n                \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" +\n                \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" +\n            \"});\" +\n        \"}\";\n\n    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);\n    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);\n}\n</script>",
  "category": ""
}