{
  "title": "Implementing Poincaré Embeddings",
  "link": "https://rare-technologies.com/implementing-poincare-embeddings/",
  "comments": "https://rare-technologies.com/implementing-poincare-embeddings/#comments",
  "pubDate": "Sat, 09 Dec 2017 08:41:41 +0000",
  "dc:creator": "Jayant Jain",
  "category": [
    "gensim",
    "Open Source",
    "hyperbolic space",
    "poincare embedding"
  ],
  "guid": "https://rare-technologies.com/?p=10280",
  "description": "I have been working on implementing a model called Poincaré embeddings over the last month or so. The model is from an interesting paper by Facebook AI Research – Poincaré Embeddings for Learning Hierarchical Representations [1]. This post describes the model at a relatively high level of abstraction, and the detailed technical challenges faced in the process of implementing it. ... <div><a href=\"https://rare-technologies.com/implementing-poincare-embeddings/\" class=\"more-link\">Read More</a></div>",
  "content:encoded": "<p>\nI have been working on implementing a model called <strong>Poincaré embeddings</strong> over the last month or so. The model is from an interesting paper by Facebook AI Research – <a href=\"#ref-1\">Poincaré Embeddings for Learning Hierarchical Representations [1]</a>. This post describes the model at a relatively high level of abstraction, and the detailed technical challenges faced in the process of implementing it. <span id=\"more-10280\"></span> If your goal is instead to understand how and where the model can be used, this <a href=\"http://nbviewer.jupyter.org/github/RaRe-Technologies/gensim/blob/develop/docs/notebooks/Poincare%20Tutorial.ipynb\">tutorial notebook</a> is a more appropriate resource.\n</p>\n\n<div class=\"x-video player\" data-x-element=\"x_mejs\"><div class=\"x-video-inner\"><video class=\"x-mejs x-wp-video-shortcode advanced-controls\" id=\"video-10280-1\" width=\"742\" height=\"557\" loop=\"1\" autoplay=\"1\" preload=\"auto\" controls=\"controls\"><source type=\"video/mp4\" src=\"https://rare-technologies.com/wp-content/uploads/2017/12/training-animation.mp4?_=1\" /></video></div></div>\n\n<p style=\"text-align: center\"><i>Figure 1: Training process for 2-D Poincaré embeddings trained on a subset of the WordNet hierarchy. Each dot is a vector for a particular graph node, and edges represent (a sample of) relations from the training set. Animals that are close together in the WordNet graph end up being closer together in the embedding space.</i></p>\n\n<p>\nThis work was supported by the National Institutes of Health, Bethesda, MD, USA.\n</p>\n\n<h3>Table of Contents</h3>\n<ol>\n    <a href=\"#1_introduction_to_the_model\"><li>Introduction to the model</li></a>\n    <a href=\"#2_the_journey_of\"><li>The journey of implementation</li></a>\n<ol class=\"custom-nav-list\">\n    <a href=\"#h2-1\"><li>2.1 Datasets and other implementations</li></a>\n    <a href=\"#h2-2\"><li>2.2 Beginning the Gensim implementation</li></a>\n    <a href=\"#h2-3\"><li>2.3 Loss functions and partial derivatives</li></a>\n    <a href=\"#h2-4\"><li>2.4 Non-uniform negative sampling</li></a>\n    <a href=\"#h2-5\"><li>2.5 Into (sort of) unexplored territory</li></a>\n    <a href=\"#h2-6\"><li>2.6 Excluding positive edges from negative sampling</li></a>\n    <a href=\"#h2-7\"><li>2.7 Batchwise training</li></a>\n    <a href=\"#h2-8\"><li>2.8 Burn-in</li></a>\n    <a href=\"#h2-9\"><li>2.9 L2 regularization</li></a>\n</ol>\n</li>\n    <a href=\"#3_final_results\"><li>Final results</li></a>\n    <a href=\"#4_conclusion_and_next_steps\"><li>Conclusion and Next Steps</li></a>\n    <a href=\"#5_references\"><li>References</li></a>\n</ol>\n\n<h3>1. Introduction to the model</h3>\n\n<p>\nPoincaré embeddings are a method to learn vector representations of nodes in a graph. It takes as input a list of relations (edges) between nodes, and attempts to learn vector representations of nodes such that the distances between the vectors for the nodes accurately represent how close the nodes are in the graph. It can be used with a modification for both directed and undirected graphs, however we only talk about directed graphs in this post.\n</p>\n\n<p>\nThe learnt embeddings capture notions of both similarity — similarity by placing connected nodes close to each other and unconnected nodes far from each other — and hierarchy by placing nodes lower in the hierarchy farther from the origin, and nodes high in the hierarchy close to the origin.\n</p>\n\n<img src=\"https://rare-technologies.com/wp-content/uploads/2018/01/Poincare-Hierarchy-Similarity.png\" alt=\"poincare-hierarchy-similarity\" width=\"800\" height=\"800\" class=\"alignnone size-full wp-image-10319\" />\n<p style=\"text-align: center\"><i>Figure 2: Positions of a sample of node vectors in 2-D space from an actual Poincaré embedding. Note that as we move toward the boundary, we begin to see nodes lower and lower in the hierarchy. Also, nodes similar to each other are close to each other.</i></p>\n\n<p>\nThe model achieves this by defining a loss function that penalizes low distances between unconnected nodes and high distances between connected nodes, and then training over the list of connected nodes, along with randomly sampled negative examples, using gradient descent.\n</p>\n\n<p>\nThe main innovation here is that these embeddings are learnt in <a href=\"https://arxiv.org/pdf/1006.5169.pdf\">hyperbolic space</a>, a space that has received attention recently in network science, as it is naturally equipped to model hierarchical structures <a href=\"#ref-4\">[4]</a>, as opposed to the commonly used Euclidean space. The reason presented for this is that hyperbolic spaces are more suitable for capturing hierarchical information inherently present in the graph. Embedding nodes into a Euclidean space while accurately preserving the distance between the nodes usually requires a very high number of dimensions.\n</p>\n\n<p>\nAn important point to note in the visualizations above is that the actual distance between two nodes is not the same as the \"naked-eye distance\" that can be seen. The actual distance is the Poincaré distance, whereas the \"naked-eye distance\" is the Euclidean distance. To get a better sense of Poincaré distance, another visualization is presented below:\n</p>\n\n<div class=\"envira-gallery-feed-output\"><img class=\"envira-gallery-feed-image\" src=\"https://rare-technologies.com/wp-content/uploads/2017/12/poincare_dist-1-800x600.png\" title=\"poincare_dist-1\" alt=\"\" /></div>\n\n<p>\nFrom this visualization, we can observe a couple of things:\n</p>\n\n<ol>\n<li>\nDistances increase much more quickly when the origin point is closer to the boundary – this can be seen visually from the fact that the darker region around the origin point grows smaller and smaller. This is also borne out from the mathematical formula for Poincare distance.\n</li>\n<li>\nFor points close to the boundary, Poincare distance to other points close in Euclidean terms is relatively low, but then increases significantly and saturates – this explains the positioning of children of a parent node close to the boundary in a small arc around the parent node, and the presence of all negative nodes to the parent node outside of that small arc.\n</li>\n</ol>\n\n<h3>2. The journey of implementation</h3>\n\n<h4 id=\"h2-1\">2.1 Datasets and other implementations</h4>\n\n<p>\nThe paper makes use of the following datasets to train and/or evaluate a Poincaré model:\n\n<ol>\n    <li><a href=\"https://wordnet.princeton.edu/\"><a href=\"#ref-2\">WordNet noun hierarchy [2]</a></li>\n    <li><a href=\"https://arxiv.org/abs/1608.02117\"><a href=\"#ref-3\">HyperLex [3]</a></li>\n    <li><a href=\"https://snap.stanford.edu/data/index.html\">Scientific collaboration networks</a> (AstroPh, CondMat, GrQc, HepPh)</li>\n</ol>\n</p>\n\n<p>\nThankfully, all of these datasets are publicly available, removing one of the more significant hurdles often encountered while replicating research papers.\n</p>\n\n<p>\nThe authors haven't published a reference implementation yet (they have mentioned to us over email that they do plan do so), but we found a couple of independent open source implementations:\n<ol>\n    <li><a href=\"https://github.com/TatsuyaShirakawa/poincaré-embedding\">C++</a></li>\n    <li><a href=\"https://github.com/nishnik/poincare_embeddings\">NumPy</a></li>\n</ol>\n</p>\n\n<p>\nOur first idea was to evaluate these implementations to see how they did on the evaluation tasks described in the paper. The NumPy implementation had to be modified slightly to be able to use it with our own hyperparameters and user-specified data. In addition, we discovered a few errors in it, which we <a href=\"https://github.com/RaRe-Technologies/gensim/blob/develop/docs/notebooks/poincare/poincare_numpy.patch\">fixed</a> and then evaluated. We also made some <a href=\"https://github.com/RaRe-Technologies/gensim/blob/develop/docs/notebooks/poincare/poincare_burn_in_eps.patch\">changes</a> to the C++ implementation in order to use \"burn-in\", a unique initialization method described in the paper.\n</p>\n\n<p>\nAfter evaluating these implementations, we found that we couldn't achieve great results with the NumPy implementation, however the C++ implementation gave us fairly reasonable results. The results below are on the WordNet Reconstruction task from the paper, described in more detail in this detailed <a href=\"http://nbviewer.jupyter.org/github/RaRe-Technologies/gensim/blob/poincare_model_keyedvectors/docs/notebooks/Poincaré%20Report.ipynb\">evaluation notebook</a>:\n</p>\n\n<table class=\"results\">\n<tbody>\n    <tr>\n        <th colspan=\"1\">Task: WordNet Reconstruction</th>\n        <th colspan=\"6\" style=\"text-align:center\"> Dimensions</th>\n    </tr>\n    <tr>\n        <th>Model Description</th>\n        <th>5</th>\n        <th>10</th>\n        <th>20</th>\n        <th>50</th>\n        <th>100</th>\n        <th>200</th>\n    </tr>\n    <tr>\n        <td>C++: burn_in=0, epochs=200, eps=1e-06, neg=20, threads=8</td>\n        <td>191.69<br>0.34</td>\n        <td>97.65<br>0.43</td>\n        <td>72.07<br>0.51</td>\n        <td>55.48<br>0.57</td>\n        <td>46.76<br>0.59</td>\n        <td>49.62<br>0.59</td>\n    </tr>\n    <tr>\n        <td>C++: burn_in=0, epochs=50, eps=1e-06, neg=20, threads=8</td>\n        <td>265.72<br>0.28</td>\n        <td>116.94<br>0.41</td>\n        <td>90.81<br>0.49</td>\n        <td>59.47<br>0.56</td>\n        <td>55.14<br>0.58</td>\n        <td>54.31<br>0.59</td>\n    </tr>\n    <tr>\n        <td>Numpy: epochs=50, neg=20</td>\n        <td>9617.57<br>0.14</td>\n        <td>5902.65<br>0.16</td>\n        <td>3868.78<br>0.19</td>\n        <td>1117.77<br>0.25</td>\n        <td>529.92<br>0.30</td>\n        <td>377.45<br>0.35</td>\n    </tr>\n</tbody></table>\n<p style=\"text-align: center\"><i>Table 1: Mean rank and MAP (Mean Average Precision) for the C++ and NumPy implementations on the WordNet Reconstruction task for different model sizes and hyperparameters.</i></p>\n<h4 id=\"h2-2\">2.2 Beginning the Gensim implementation</h4>\n\n<p>\nSo, we decided to write our own implementation as part of Gensim. Our plan was to follow the C++ implementation as an initial reference point, as both the code quality and the results seemed fairly solid, and then once we'd achieved the same results, move on to improving them further to match the paper. We decided on using NumPy for the initial implementation instead of more featured machine learning libraries like Tensorflow or PyTorch, for 2 reasons:\n<ol>\n    <li>The model uses a variant of SGD called Riemannian Gradient Descent, and we were unsure if implementing this was easily doable in the above libraries. NumPy on the other hand gives us the flexibility to do so, although at the cost of figuring out how to compute the derivatives ourselves.</li>\n    <li>We didn't want to create new major dependencies for Gensim without a meaningful reason to do so.</li>\n</ol>\n</p>\n\n<p>\nWe also decided to use <a href=\"https://github.com/HIPS/autograd\">autograd</a>, a nifty Python library that computes the derivatives of a function defined in terms of NumPy operations. Autograd was too slow to use for actually computing the gradients during training, however it was super-useful for performing automated verification of the gradient calculations written by us ourselves, giving us confidence in the correctness of our calculations, and therefore letting us iterate quickly.\n</p>\n\n<p>\nA pure NumPy implementation can be slow, because NumPy does a significant amount of dynamic memory allocation internally for temporary arrays, which has a direct time-cost, as well as the indirect cost of ruining caches. Our plan was to get a correct implementation first, and then optimize the hotspots with Cython and BLAS (similar to the <a href=\"https://rare-technologies.com/word2vec-in-python-part-two-optimizing/\">word2vec optimization in Gensim</a>).\n</p>\n\n<p>Once we began our implementation, we discovered a fair amount of differences in the C++ implementation from the paper.\n</p>\n\n<h4 id=\"h2-3\">2.3 Loss functions and partial derivatives</h4>\n\n<p>\nThe paper mentions this loss function:\n</p>\n\n<img src=\"https://rare-technologies.com/wp-content/ql-cache/quicklatex.com-7b67923ae947370ea17bc1962545d0cc_l3.png\" class=\"ql-img-inline-formula quicklatex-auto-format\" alt=\" &#92;&#109;&#97;&#116;&#104;&#99;&#97;&#108;&#123;&#76;&#125;&#40;&#92;&#84;&#104;&#101;&#116;&#97;&#41;&#32;&#61;&#32; &#92;&#115;&#117;&#109;&#92;&#108;&#105;&#109;&#105;&#116;&#115;&#95;&#123;&#40;&#92;&#98;&#111;&#108;&#100;&#115;&#121;&#109;&#98;&#111;&#108;&#123;&#117;&#125;&#44;&#92;&#98;&#111;&#108;&#100;&#115;&#121;&#109;&#98;&#111;&#108;&#123;&#118;&#125;&#41;&#32;&#92;&#98;&#111;&#108;&#100;&#115;&#121;&#109;&#98;&#111;&#108;&#123;&#92;&#105;&#110;&#125;&#32;&#68;&#125; &#108;&#111;&#103;&#32;&#92;&#102;&#114;&#97;&#99;&#123;&#101;&#94;&#123;&#45;&#100;&#40;&#92;&#98;&#111;&#108;&#100;&#115;&#121;&#109;&#98;&#111;&#108;&#123;&#117;&#125;&#44;&#92;&#98;&#111;&#108;&#100;&#115;&#121;&#109;&#98;&#111;&#108;&#123;&#118;&#125;&#41;&#125;&#125;&#123;&#92;&#115;&#117;&#109;&#95;&#123;&#118;&#92;&#112;&#114;&#105;&#109;&#101;&#32;&#92;&#98;&#111;&#108;&#100;&#115;&#121;&#109;&#98;&#111;&#108;&#123;&#92;&#105;&#110;&#125;&#32;&#92;&#109;&#97;&#116;&#104;&#99;&#97;&#108;&#123;&#78;&#125;&#40;&#117;&#41;&#125;&#101;&#94;&#123;&#45;&#100;&#40;&#92;&#98;&#111;&#108;&#100;&#115;&#121;&#109;&#98;&#111;&#108;&#123;&#117;&#125;&#44;&#92;&#98;&#111;&#108;&#100;&#115;&#121;&#109;&#98;&#111;&#108;&#123;&#118;&#125;&#92;&#112;&#114;&#105;&#109;&#101;&#41;&#125;&#125; \" title=\"Rendered by QuickLaTeX.com\" height=\"39\" width=\"266\" style=\"vertical-align: -20px;\"/>\n\n<p>\nwhere <img src=\"https://rare-technologies.com/wp-content/ql-cache/quicklatex.com-c3d8a99595c4b10852c082aa2d60d990_l3.png\" class=\"ql-img-inline-formula quicklatex-auto-format\" alt=\"&#92;&#109;&#97;&#116;&#104;&#99;&#97;&#108;&#123;&#78;&#125;&#40;&#117;&#41;&#32;&#61;&#32;&#92;&#123;&#118;&#92;&#32;&#124;&#92;&#32;&#40;&#117;&#44;&#118;&#41;&#92;&#110;&#111;&#116;&#105;&#110;&#32;&#68;&#92;&#125;&#32;&#92;&#99;&#117;&#112;&#32;&#92;&#123;&#117;&#92;&#125;\" title=\"Rendered by QuickLaTeX.com\" height=\"19\" width=\"234\" style=\"vertical-align: -5px;\"/> is the set of negative examples for <img src=\"https://rare-technologies.com/wp-content/ql-cache/quicklatex.com-43fe27dc3e528266a619764d90fce60b_l3.png\" class=\"ql-img-inline-formula quicklatex-auto-format\" alt=\"&#117;\" title=\"Rendered by QuickLaTeX.com\" height=\"8\" width=\"10\" style=\"vertical-align: 0px;\"/>.\n</p>\n\n\n<p>\nThe denominator consists of terms involving the distance between node <img src=\"https://rare-technologies.com/wp-content/ql-cache/quicklatex.com-43fe27dc3e528266a619764d90fce60b_l3.png\" class=\"ql-img-inline-formula quicklatex-auto-format\" alt=\"&#117;\" title=\"Rendered by QuickLaTeX.com\" height=\"8\" width=\"10\" style=\"vertical-align: 0px;\"/> and negative examples of nodes <img src=\"https://rare-technologies.com/wp-content/ql-cache/quicklatex.com-4f25b809dad00357b23a1dd15afa1fb9_l3.png\" class=\"ql-img-inline-formula quicklatex-auto-format\" alt=\"&#118;&#92;&#112;&#114;&#105;&#109;&#101;\" title=\"Rendered by QuickLaTeX.com\" height=\"10\" width=\"14\" style=\"vertical-align: 0px;\"/> for <img src=\"https://rare-technologies.com/wp-content/ql-cache/quicklatex.com-43fe27dc3e528266a619764d90fce60b_l3.png\" class=\"ql-img-inline-formula quicklatex-auto-format\" alt=\"&#117;\" title=\"Rendered by QuickLaTeX.com\" height=\"8\" width=\"10\" style=\"vertical-align: 0px;\"/>.\n</p>\n\n<p>\nHowever, the C++ implementation makes use of a slightly modified loss function:\n</p>\n\n<img src=\"https://rare-technologies.com/wp-content/ql-cache/quicklatex.com-16724a9b23cba35fcc7c260615544fef_l3.png\" class=\"ql-img-inline-formula quicklatex-auto-format\" alt=\" &#92;&#109;&#97;&#116;&#104;&#99;&#97;&#108;&#123;&#76;&#125;&#40;&#92;&#84;&#104;&#101;&#116;&#97;&#41;&#32;&#61;&#32; &#92;&#115;&#117;&#109;&#92;&#108;&#105;&#109;&#105;&#116;&#115;&#95;&#123;&#40;&#92;&#98;&#111;&#108;&#100;&#115;&#121;&#109;&#98;&#111;&#108;&#123;&#117;&#125;&#44;&#92;&#98;&#111;&#108;&#100;&#115;&#121;&#109;&#98;&#111;&#108;&#123;&#118;&#125;&#41;&#32;&#92;&#98;&#111;&#108;&#100;&#115;&#121;&#109;&#98;&#111;&#108;&#123;&#92;&#105;&#110;&#125;&#32;&#68;&#125; &#108;&#111;&#103;&#32;&#92;&#102;&#114;&#97;&#99;&#123;&#101;&#94;&#123;&#45;&#100;&#40;&#92;&#98;&#111;&#108;&#100;&#115;&#121;&#109;&#98;&#111;&#108;&#123;&#117;&#125;&#44;&#92;&#98;&#111;&#108;&#100;&#115;&#121;&#109;&#98;&#111;&#108;&#123;&#118;&#125;&#41;&#125;&#125; &#123;&#101;&#94;&#123;&#45;&#100;&#40;&#92;&#98;&#111;&#108;&#100;&#115;&#121;&#109;&#98;&#111;&#108;&#123;&#117;&#125;&#44;&#92;&#98;&#111;&#108;&#100;&#115;&#121;&#109;&#98;&#111;&#108;&#123;&#118;&#125;&#41;&#125;&#32;&#43;&#32;&#92;&#115;&#117;&#109;&#95;&#123;&#118;&#92;&#112;&#114;&#105;&#109;&#101;&#32;&#92;&#98;&#111;&#108;&#100;&#115;&#121;&#109;&#98;&#111;&#108;&#123;&#92;&#105;&#110;&#125;&#32;&#92;&#109;&#97;&#116;&#104;&#99;&#97;&#108;&#123;&#78;&#125;&#40;&#117;&#41;&#125;&#101;&#94;&#123;&#45;&#100;&#40;&#92;&#98;&#111;&#108;&#100;&#115;&#121;&#109;&#98;&#111;&#108;&#123;&#117;&#125;&#44;&#92;&#98;&#111;&#108;&#100;&#115;&#121;&#109;&#98;&#111;&#108;&#123;&#118;&#125;&#92;&#112;&#114;&#105;&#109;&#101;&#41;&#125;&#125; \" title=\"Rendered by QuickLaTeX.com\" height=\"39\" width=\"328\" style=\"vertical-align: -20px;\"/>\n\n<p>\nwhere the denominator also includes the term from the numerator: <img src=\"https://rare-technologies.com/wp-content/ql-cache/quicklatex.com-92af5223c9a909201a6368719ef66d73_l3.png\" class=\"ql-img-inline-formula quicklatex-auto-format\" alt=\"&#101;&#94;&#123;&#45;&#100;&#40;&#92;&#98;&#111;&#108;&#100;&#115;&#121;&#109;&#98;&#111;&#108;&#123;&#117;&#125;&#44;&#92;&#98;&#111;&#108;&#100;&#115;&#121;&#109;&#98;&#111;&#108;&#123;&#118;&#125;&#41;&#125;\" title=\"Rendered by QuickLaTeX.com\" height=\"17\" width=\"57\" style=\"vertical-align: 0px;\"/>.\n</p>\n\n<p>\nThis more closely resembles a traditional softmax log-loss function. The gradients used to update the vectors depend on this choice of loss function. We attempted both variants of the loss function and the corresponding partial derivatives, and found that the softmax-like loss function yielded better results.\n</p>\n\n<p>\nNote that negative sampling is used while training, as mentioned in the paper, since training over all the negative examples from the dataset is not computationally feasible.\n</p>\n\n<h4 id=\"h2-4\">2.4 Non-uniform negative sampling</h4>\n\n<p>\nWe were a fair way off from the C++ results, and we weren't sure why this was the case. It turned out that, under the hood of the rather misleadingly named <i>UniformNegativeSampler</i>, the underlying random number generator <i>std::discrete_distribution</i> was being initialized with the counts of how many times each node occurred in the dataset. Therefore, more common nodes were more likely to be chosen as negative examples, and therefore far more updates were likely to be performed on these nodes, affecting the final vectors significantly.\n</p>\n\n<p>\nThe paper mentions uniform negative sampling too, which is why this wasn't detected earlier. Using weighted negative sampling helped us achieve the same results as the C++ implementation.\n</p>\n\n<h4 id=\"h2-5\">2.5 Into (sort of) unexplored territory</h4>\n\n<p>\nWe'd finally achieved the same results as the C++ implementation, however we were still quite some way off from the results in the paper. The following were the changes we made that helped us exceed the C++ quality and get closer to the final results.\n</p>\n\n<h4 id=\"h2-6\">2.6 Excluding positive edges from negative sampling</h4>\n\n<p>\nThe C++ version implements negative sampling simply as weighted sampling from the entire list of nodes in the dataset. Crucially, this can potentially select positively connected nodes to the input node as a negative example, causing the connected nodes to move away from each other, which is undesirable. The simple solution is to discard the positively connected nodes from the nodes to be sampled from before sampling. However, in combination with non-uniform weights, this is difficult to implement in a performant way.\n</p>\n\n<p>\nThe method we used was:\n<ol>\n    <li style=\"font-weight: 400\">Sample (with repetitions) a large buffer of candidate nodes based on their frequency distribution</li>\n    <li style=\"font-weight: 400\">Fetch the required number of negative examples from this buffer; if the buffer is empty, perform (1) again</li>\n    <li style=\"font-weight: 400\">If the fetched nodes have any duplicates, or any positively connected nodes to the target node, discard them and perform (2) again.</li>\n</ol>\n</p>\n\n<p>\nThe reason this works well is that the probability of a duplicate or positively connected node being present in the fetched sample is usually fairly low, and also because generating a large buffer of samples a few times is much faster than generating smaller samples a large number of times. In the process, we also discovered a useful trick with random sampling in NumPy: \n</p>\n\n<blockquote class=\"twitter-tweet\" data-width=\"550\"><p lang=\"en\" dir=\"ltr\">Random <a href=\"https://twitter.com/hashtag/Numpy?src=hash&ref_src=twsrc%5Etfw\">#Numpy</a> tip:<br><br>Avoid \"np.random.choice\" for sampling elements with probabilities, where performance matters. Too much overhead. Here 17x SLOWER than simple cumsum+searchsorted: <a href=\"https://t.co/hKFObqPHCq\">pic.twitter.com/hKFObqPHCq</a></p>&mdash; Radim Řehůřek (@RadimRehurek) <a href=\"https://twitter.com/RadimRehurek/status/928671225861296128?ref_src=twsrc%5Etfw\">November 9, 2017</a></blockquote><script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\n<h4 id=\"h2-7\">2.7 Batchwise training</h4>\n\n<p>\nOver email, the paper authors mentioned that they were using mini-batches of sizes 10-50 for gradient descent, and that smaller batches lead to better results. The paper does not mention batch-wise training, and the C++ version trains one example at a time. We implemented batch-wise training – this did not significantly change the evaluation results, however the faster computations did allow us to train on more epochs and iterate faster.\n</p>\n\n<h4 id=\"h2-8\">2.8 Burn-in</h4>\n\n<p>\nThe paper describes a rather unique method (to the best of our knowledge) of initializing the vectors before training, which the authors call \"burn-in\". Basically, this involves initializing the vectors to a uniform distribution and then training with a much reduced learning rate for a few epochs. The rationale is that this results in a better initial angular layout of the vectors and reduces the sensitivity of the final vectors to a possibly \"unlucky\" random initialization. This did not seem to work well in practice for us at first, however after implementing the next step (L2 regularization), burn-in significantly improved results.\n</p>\n\n<h4 id=\"h2-9\">2.9 L2 regularization</h4>\n\n<p>\nFor debugging, we'd been training 2-D Poincaré embeddings on a subset of the WordNet noun hierarchy, and visualizing the embeddings in 2-D Euclidean space (thanks to the authors for this suggestion). These were the results we'd been obtaining:\n</p>\n\n<img class=\"alignnone size-full wp-image-10284\" src=\"https://rare-technologies.com/wp-content/uploads/2018/01/mammals_200_ep.png\" alt=\"mammals_200_ep\" width=\"800\" height=\"800\" />\n\n<p>\nWe noticed that almost all of the vectors were too close to the boundary (the vectors are constrained to a unit norm via clipping). This makes sense mathematically, as Poincaré distances near the boundary change extremely fast, and therefore it is easier for the optimizer to achieve a lower loss. However, this is essentially a form of overfitting – our goal is to obtain useful representations, not simply achieve the minimum loss value.\n</p>\n\n<p>\nIt seemed to us that the nodes higher in the hierarchy (often parent nodes in the set of edges) should be closer to the origin, and the nodes lower in the hierarchy (often child nodes and leaf nodes) should be closer to the boundary. A mathematical way to enforce this was by adding penalties on the norm of the <em>parent node</em> in an edge via L2 regularization. Note that L2 regularization is often used for <em>all</em> parameters, however we're only using it for the parent node in a training example. After adding L2 regularization, the results looked a lot more reasonable:\n</p>\n\n<img class=\"alignnone size-full wp-image-10285\" src=\"https://rare-technologies.com/wp-content/uploads/2018/01/mammals_350_ep_l2_reg.png\" alt=\"mammals_350_ep_l2_reg\" width=\"800\" height=\"800\" />\n\n<p>\nHere, the nodes with a large number of children are further away from the boundary than above. Also, the positive edges for these nodes are focused in much smaller arcs, and aren't scattered around the whole circle like in the previous example.\n</p>\n\n<h3>3. Final results</h3>\n\n<p>\nThe following are the results we obtained for the WordNet Reconstruction task, where we evaluate two correlated metrics – Mean Average Precision and Mean Rank.\n</p>\n\n<p>\nOur results:\n</p>\n\n<table class=\"results\">\n<tbody>\n    <tr>\n        <th colspan=\"1\">Task: WordNet Reconstruction</th>\n        <th colspan=\"6\" style=\"text-align:center\"> Dimensions</th>\n    </tr>\n    <tr>\n        <th>Model Description</th>\n        <th>5</th>\n        <th>10</th>\n        <th>20</th>\n        <th>50</th>\n        <th>100</th>\n        <th>200</th>\n    </tr>\n    <tr>\n        <td>C++: burn_in=0, epochs=200, eps=1e-06, neg=20, threads=8</td>\n        <td>191.69<br>0.34</td>\n        <td>97.65<br>0.43</td>\n        <td>72.07<br>0.51</td>\n        <td>55.48<br>0.57</td>\n        <td>46.76<br>0.59</td>\n        <td>49.62<br>0.59</td>\n    </tr>\n    <tr>\n        <td>C++: burn_in=0, epochs=50, eps=1e-06, neg=20, threads=8</td>\n        <td>265.72<br>0.28</td>\n        <td>116.94<br>0.41</td>\n        <td>90.81<br>0.49</td>\n        <td>59.47<br>0.56</td>\n        <td>55.14<br>0.58</td>\n        <td>54.31<br>0.59</td>\n    </tr>\n    <tr>\n        <td>Gensim: batch_size=10, burn_in=0, epochs=50, neg=20, reg=0.0</td>\n        <td>154.41<br>0.40</td>\n        <td>62.77<br>0.63</td>\n        <td>27.32<br>0.72</td>\n        <td>20.22<br>0.77</td>\n        <td>16.15<br>0.78</td>\n        <td>13.20<br>0.79</td>\n    </tr>\n    <tr>\n        <td>Gensim: batch_size=10, burn_in=10, epochs=200, neg=10, reg=1</td>\n        <td>61.48<br>0.38</td>\n        <td>54.70<br>0.41</td>\n        <td>53.02<br>0.41</td>\n        <td>50.80<br>0.42</td>\n        <td>49.58<br>0.42</td>\n        <td>48.56<br>0.43</td>\n    </tr>\n    <tr>\n        <td>Numpy: epochs=50, neg=20</td>\n        <td>9617.57<br>0.14</td>\n        <td>5902.65<br>0.16</td>\n        <td>3868.78<br>0.19</td>\n        <td>1117.77<br>0.25</td>\n        <td>529.92<br>0.30</td>\n        <td>377.45<br>0.35</td>\n    </tr>\n</tbody></table>\n<p style=\"text-align: center\"><i>Table 2: Mean rank and MAP (Mean Average Precision) for the Gensim, C++ and NumPy implementations on the WordNet Reconstruction task for different model sizes and hyperparameters.</i></p>\n\n<p>\nResults as reported in the paper:\n</p>\n\n<img class=\"alignnone size-full wp-image-10286\" src=\"https://rare-technologies.com/wp-content/uploads/2018/01/reconstruction_paper.png\" alt=\"reconstruction_paper\" width=\"920\" height=\"286\" />\n\n<p>\nWe see that we still have some way to go to match the original results reported in the paper, especially for lower dimensional embeddings. However, we’re much closer for higher dimensional embeddings, while also significantly outperforming previous state-of-the-art results as well as the results of Poincaré embeddings from other open source implementations.\n</p>\n\n<p>\nOn the Lexical Entailment task from HyperLex <a href=\"#ref-3\">[3]</a>, these are the results - \n</p>\n\n<table class=\"results\">\n<tbody>\n    <tr>\n        <th colspan=\"1\">Lexical Entailment (HyperLex)</th>\n        <th colspan=\"6\" style=\"text-align:center\"> Dimensions</th>\n    </tr>\n    <tr>\n        <th>Model Description</th>\n        <th>5</th>\n        <th>10</th>\n        <th>20</th>\n        <th>50</th>\n        <th>100</th>\n        <th>200</th>\n    </tr>\n    <tr>\n        <td>C++: burn_in=0, epochs=200, eps=1e-06, neg=20, threads=8</td>\n        <td>0.45</td>\n        <td>0.46</td>\n        <td>0.45</td>\n        <td>0.45</td>\n        <td>0.45</td>\n        <td>0.46</td>\n    </tr>\n    <tr>\n        <td>C++: burn_in=0, epochs=50, eps=1e-06, neg=20, threads=8</td>\n        <td>0.44</td>\n        <td>0.43</td>\n        <td>0.47</td>\n        <td>0.44</td>\n        <td>0.45</td>\n        <td>0.44</td>\n    </tr>\n    <tr>\n        <td>Gensim: batch_size=10, burn_in=0, epochs=50, neg=20, reg=0.0</td>\n        <td>0.47</td>\n        <td>0.45</td>\n        <td>0.47</td>\n        <td>0.47</td>\n        <td>0.48</td>\n        <td>0.47</td>\n    </tr>\n    <tr>\n        <td>Gensim: batch_size=10, burn_in=10, epochs=200, neg=10, reg=1</td>\n        <td>0.52</td>\n        <td>0.51</td>\n        <td>0.51</td>\n        <td>0.51</td>\n        <td>0.52</td>\n        <td>0.51</td>\n    </tr>\n    <tr>\n        <td>Numpy: epochs=50, neg=20</td>\n        <td>0.15</td>\n        <td>0.19</td>\n        <td>0.20</td>\n        <td>0.20</td>\n        <td>0.24</td>\n        <td>0.26</td>\n    </tr>\n</tbody>\n</table>\n<p style=\"text-align: center\"><i>Table 3: Spearman's rank correlation for the Gensim, C++ and NumPy implementations on the HyperLex Lexical Entailment task for different model sizes and hyperparameters.</i></p>\n\nThese are the results from paper (for Poincaré Embeddings, as well as other embeddings from previous papers) - \n\n<img src=\"https://rare-technologies.com/wp-content/uploads/2017/12/entailment_paper.png\" alt=\"entailment_paper\" width=\"778\" height=\"104\" class=\"alignnone size-full wp-image-10363\" />\n\n<p>\nOn this task, we achieve very similar results as the paper with the Gensim implementation.\nHowever, there are a few ambiguities and caveats -\n<ul>\n<li>\nThe paper does not mention which hyperparameters and model size have been used for the above mentioned result. Hence it is possible that the results are achieved with a significantly lower model size than the one we use, which would imply that our implementation still has some way to go.\n</li>\n\n<li>\nThe same word can have multiple nodes in the WordNet dataset for different senses of the word, and it is unclear from the paper how to decide which node to pick. For the above results, we have gone with the sane default of picking the particular sense that has the maximum similarity score with the target word.\n</li>\n\n<li>\nCertain words in the HyperLex dataset seem to be absent from the WordNet data - the paper does not mention any such thing. Pairs containing missing words have been omitted from the evaluation (182/2163).\n</li>\n\n</ul>\n\n</p>\n\n\n<h3>4. Conclusion and Next Steps</h3>\n\n<p>\nIn conclusion, dealing with all these challenges was extremely enjoyable, and the journey resulted in a model that finally looks practically useful. We still have some way to go:\n<ol>\n    <li>Optimizing the training using Cython/BLAS for the hotspots.</li>\n    <li>Matching the exact results from the paper (elusive despite direct email communication with the authors and trying everything we could think of).</li>\n    <li>Decreasing memory requirements; right now the model requires memory linearly proportional to the number of edges in the dataset. Gensim is built on the idea of <a href=\"https://rare-technologies.com/data-streaming-in-python-generators-iterators-iterables/\">document streaming</a>, as requiring the entire dataset to be in RAM limits scalability. This leaves room for implementing Poincaré embeddings using online training.</li>\n</ol>\n</p>\n\n<h3>5. References</h3>\n\n<p>\n\n[1] <span id=\"ref-1\"><a href=\"https://arxiv.org/pdf/1705.08039\">Maximilian Nickel and Douwe Kiela. Poincaré embeddings for learning hierarchical representations, 2017.</a></span>\n<br />\n<br />\n\n[2] <span id=\"ref-2\"><a href=\"http://wordnetcode.princeton.edu/5papers.pdf\">George Miller and Christiane Fellbaum. Wordnet: An electronic lexical database, 1998.</a></span>\n<br />\n<br />\n\n[3] <span id=\"ref-3\"><a href=\"https://arxiv.org/pdf/1608.02117\">Ivan Vulic, Daniela Gerz, Douwe Kiela, Felix Hill, and Anna Korhonen. Hyperlex: A large-scale evaluation of graded lexical entailment, 2016.</a></span>\n<br />\n<br />\n\n[4] <span id=\"ref-4\"><a href=\"https://arxiv.org/abs/1006.5169\">Dmitri Krioukov, Fragkiskos Papadopoulos, Maksim Kitsak, Amin Vahdat, and Marián Boguná. Hyperbolic geometry of complex networks, 2010.</a></span>\n<br />\n</p>",
  "wfw:commentRss": "https://rare-technologies.com/implementing-poincare-embeddings/feed/",
  "slash:comments": 10
}