{
  "id": "tag:blogger.com,1999:blog-8474926331452026626.post-4863623362813999190",
  "published": "2022-09-22T14:33:00.009-07:00",
  "updated": "2022-10-22T20:01:27.187-07:00",
  "category": [
    "",
    "",
    ""
  ],
  "title": "TensorStore for High-Performance, Scalable Array Storage",
  "content": "<span class=\"byline-author\">Posted by Jeremy Maitin-Shepard and Laramie Leavitt, Software Engineers, Connectomics at Google</span><img src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgX9DAdPcFpMfSPteAKTplWpi2h3okSemN9o1J3B6K45LHBjkp2OiSbNimITgluVBLLyyVwXIhe0tvhwDIG01lWXXPCW-Lh0HqOg6qRBE96ON4ndUBmb4kdDmQ0cMsk2dZcsHkTNU2quF7UMttmX8-GbfMLGmXfKePb1sGIa0qSODsf6oV4dXPZhoo-/s800/image1.gif\" style=\"display: none;\" /><p>Many exciting contemporary applications of computer science and machine learning (ML) manipulate multidimensional datasets that span a single large coordinate system, for example, <a href=\"https://ai.googleblog.com/2021/11/metnet-2-deep-learning-for-12-hour.html\">weather modeling</a> from atmospheric measurements over a spatial grid or <a href=\"https://ai.googleblog.com/2021/09/detecting-abnormal-chest-x-rays-using.html\">medical imaging</a> predictions from multi-channel image intensity values in a 2d or 3d scan. In these settings, even a single dataset may require terabytes or petabytes of data storage. Such datasets are also challenging to work with as users may read and write data at irregular intervals and varying scales, and are often interested in performing analyses using numerous machines working in parallel.  </p><a name='more'></a><p>Today we are introducing <a href=\"https://github.com/google/tensorstore\">TensorStore</a>, an open-source C++ and Python software library designed for storage and manipulation of <em>n-</em>dimensional data that: </p><ul><li>Provides a uniform API for reading and writing multiple array formats, including <a href=\"https://zarr.readthedocs.io/en/stable/\">zarr</a> and <a href=\"https://github.com/saalfeldlab/n5\">N5</a>.  </li>  <li>Natively supports <a href=\"https://google.github.io/tensorstore/kvstore/index.html\">multiple storage systems</a>, including <a href=\"https://google.github.io/tensorstore/kvstore/gcs/index.html\">Google Cloud Storage</a>, <a href=\"https://google.github.io/tensorstore/kvstore/file/index.html\">local and network filesystems</a>, <a href=\"https://google.github.io/tensorstore/kvstore/http/index.html\">HTTP servers</a>, and <a href=\"https://google.github.io/tensorstore/kvstore/memory/index.html\">in-memory storage</a>. </li>  <li>Supports read/writeback caching and transactions, with strong <a href=\"https://en.wikipedia.org/wiki/ACID\">atomicity, isolation, consistency, and durability</a> (ACID) guarantees. </li>  <li>Supports safe, efficient access from multiple processes and machines via optimistic concurrency. </li>  <li>Offers an asynchronous API to enable high-throughput access even to high-latency remote storage. </li>  <li>Provides advanced, fully composable <a href=\"https://google.github.io/tensorstore/python/indexing.html\">indexing</a> operations and virtual views. </li></ul><p>TensorStore has already been used to solve key engineering challenges in scientific computing (e.g., management and processing of large datasets in neuroscience, such as <a href=\"https://ai.googleblog.com/2021/06/a-browsable-petascale-reconstruction-of.html\">peta-scale 3d electron microscopy data</a> and “4d” <a href=\"https://www.youtube.com/watch?v=Nxa19uWC_oA\">videos of neuronal activity</a>). TensorStore has also been used in the creation of large-scale machine learning models such as <a href=\"https://ai.googleblog.com/2022/04/pathways-language-model-palm-scaling-to.html\">PaLM</a> by addressing the problem of managing model parameters (checkpoints) during distributed training.  </p><div style=\"line-height:40%;\">    <br></div><h2>Familiar API for Data Access and Manipulation</h2><p>TensorStore provides a simple Python API for loading and manipulating large array data. In the following example, we create a TensorStore object that represents a 56 trillion voxel <a href=\"https://ai.googleblog.com/2020/01/releasing-drosophila-hemibrain.html\">3d image of a fly brain</a> and access a small 100x100 patch of the data as a <a href=\"https://numpy.org/\">NumPy</a> array: </p><span style=\"font-size: small;\">  <pre class=\"prettyprint\" style=\"margin-left: 40px; margin-right: 40px; white-space: pre-wrap;\">&gt;&gt;&gt; import tensorstore as ts<br />&gt;&gt;&gt; import numpy as np<br /><br /># Create a TensorStore object to work with fly brain data.<br />&gt;&gt;&gt; dataset = ts.open({<br />...     'driver':<br />...         'neuroglancer_precomputed',<br />...     'kvstore':<br />...         'gs://neuroglancer-janelia-flyem-hemibrain/' + <br />...         'v1.1/segmentation/',<br />... }).result()<br /><br /># Create a 3-d view (remove singleton 'channel' dimension):<br />&gt;&gt;&gt; dataset_3d = dataset[ts.d['channel'][0]]<br />&gt;&gt;&gt; dataset_3d.domain<br />{ \"x\": [0, 34432), \"y\": [0, 39552), \"z\": [0, 41408) }<br /><br /># Convert a 100x100x1 slice of the data to a numpy ndarray<br />&gt;&gt;&gt; slice = np.array(dataset_3d[15000:15100, 15000:15100, 20000])</pre></span> <p>Crucially, no actual data is accessed or stored in memory until the specific 100x100 slice is requested; hence arbitrarily large underlying datasets can be loaded and manipulated without having to store the entire dataset in memory, using indexing and manipulation syntax largely identical to standard NumPy operations. TensorStore also provides extensive support for <a href=\"https://google.github.io/tensorstore/python/indexing.html\">advanced indexing features</a>, including transforms, <a href=\"https://google.github.io/tensorstore/index_space.html#alignment-and-broadcasting\">alignment, broadcasting</a>, and virtual views (<a href=\"https://google.github.io/tensorstore/python/api/tensorstore.cast.html#tensorstore.cast\">data type conversion</a>, <a href=\"https://google.github.io/tensorstore/python/api/tensorstore.downsample-store.html\">downsampling</a>, <a href=\"https://google.github.io/tensorstore/python/api/tensorstore.virtual_chunked.html\">lazily on-the-fly generated arrays</a>).  </p><p>The following example demonstrates how TensorStore can be used to create a zarr array, and how its asynchronous API enables higher throughput: </p><span style=\"font-size: small;\"><pre class=\"prettyprint\" style=\"margin-left: 40px; margin-right: 40px; white-space: pre-wrap;\">&gt;&gt;&gt; import tensorstore as ts<br />&gt;&gt;&gt; import numpy as np<br /><br />&gt;&gt;&gt; # Create a zarr array on the local filesystem<br />&gt;&gt;&gt; dataset = ts.open({<br />...     'driver': 'zarr',<br />...     'kvstore': 'file:///tmp/my_dataset/',<br />... },<br />... dtype=ts.uint32,<br />... chunk_layout=ts.ChunkLayout(chunk_shape=[256, 256, 1]),<br />... create=True,<br />... shape=[5000, 6000, 7000]).result()<br /><br />&gt;&gt;&gt; # Create two numpy arrays with example data to write.<br />&gt;&gt;&gt; a = np.arange(100*200*300, dtype=np.uint32).reshape((100, 200, 300))<br />&gt;&gt;&gt; b = np.arange(200*300*400, dtype=np.uint32).reshape((200, 300, 400))<br /><br />&gt;&gt;&gt; # Initiate two asynchronous writes, to be performed concurrently.<br />&gt;&gt;&gt; future_a = dataset[1000:1100, 2000:2200, 3000:3300].write(a)<br />&gt;&gt;&gt; future_b = dataset[3000:3200, 4000:4300, 5000:5400].write(b)<br /><br />&gt;&gt;&gt; # Wait for the asynchronous writes to complete<br />&gt;&gt;&gt; future_a.result()<br />&gt;&gt;&gt; future_b.result()</pre></span> <div style=\"line-height:40%;\">    <br></div><h2>Safe and Performant Scaling </h2><p>Processing and analyzing large numerical datasets requires significant computational resources. This is typically achieved through parallelization across numerous CPU or accelerator cores spread across many machines. Therefore a fundamental goal of TensorStore has been to enable parallel processing of individual datasets that is both safe (i.e., avoids corruption or inconsistencies arising from parallel access patterns) and high performance (i.e., reading and writing to TensorStore is not a bottleneck during computation). In fact, in a test within Google’s datacenters, we found nearly linear scaling of read and write performance as the number of CPUs was increased: </p><table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto;\"><tbody><tr><td style=\"text-align: center;\"><a href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg8b07lDLRkn-9O0urUMRv4nU96Yd-m3chrVmIAgw5tlceIU3dRKtpvK0IZAUS-hiqxtT-U1oe-AZBLdri1V-PJmTMw8EoVMlSO0BqzQRmmJN0oadFab5OyP4CieM1m9S1nNFOCWGNZ7obq5Jx9N5AXhf6zjChzLFnM7YECO3mJ6YEqQpc0o8JagSVX/s1999/image2.jpg\" style=\"margin-left: auto; margin-right: auto;\"><img border=\"0\" data-original-height=\"1066\" data-original-width=\"1999\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg8b07lDLRkn-9O0urUMRv4nU96Yd-m3chrVmIAgw5tlceIU3dRKtpvK0IZAUS-hiqxtT-U1oe-AZBLdri1V-PJmTMw8EoVMlSO0BqzQRmmJN0oadFab5OyP4CieM1m9S1nNFOCWGNZ7obq5Jx9N5AXhf6zjChzLFnM7YECO3mJ6YEqQpc0o8JagSVX/s16000/image2.jpg\" /></a></td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\">Read and write performance for a TensorStore dataset in <a href=\"https://google.github.io/tensorstore/driver/zarr/index.html\">zarr format</a> residing on Google Cloud Storage (GCS) accessed concurrently using a variable number of single-core compute tasks in Google data centers. Both read and write performance scales nearly linearly with the number of compute tasks.</td></tr></tbody></table><p>Performance is achieved by implementing core operations in C++, extensive use of multithreading for operations such as encoding/decoding and network I/O, and partitioning large datasets into much smaller units through chunking to enable efficiently reading and writing subsets of the entire dataset. TensorStore also provides configurable in-memory caching (which reduces slower storage system interactions for frequently accessed data) and an asynchronous API that enables a read or write operation to continue in the background while a program completes other work.  </p><p>Safety of parallel operations when many machines are accessing the same dataset is achieved through the use of <a href=\"https://en.wikipedia.org/wiki/Optimistic_concurrency_control\">optimistic concurrency</a>, which maintains compatibility with diverse underlying storage layers (including Cloud storage platforms, such as <a href=\"https://cloud.google.com/storage/?gclid=CjwKCAjwlqOXBhBqEiwA-hhitER-4ub5UNrYCHC4rdBFwwNEl7PDYPvu9maM9G1d1wM1eY5QrzJ4NhoCme4QAvD_BwE&amp;gclsrc=aw.ds\">GCS</a>, as well as local filesystems) without significantly impacting performance. TensorStore also provides strong ACID guarantees for all individual operations executing within a single runtime.  </p><p>To make distributed computing with TensorStore compatible with many existing data processing workflows, we have also integrated TensorStore with parallel computing libraries such as <a href=\"https://beam.apache.org/\">Apache Beam</a> (<a href=\"https://github.com/google/tensorstore/tree/master/tensorstore/examples/python/beam\">example code</a>) and <a href=\"https://www.dask.org/\">Dask</a> (<a href=\"https://github.com/google-research/connectomics\">example code</a>).  </p><div style=\"line-height:40%;\">    <br></div><h2>Use Case: Language Models </h2><p>An exciting recent development in ML is the emergence of more advanced language models such as <a href=\"https://ai.googleblog.com/2022/04/pathways-language-model-palm-scaling-to.html\">PaLM</a>. These neural networks contain hundreds of billions of parameters and exhibit <a href=\"https://ai.googleblog.com/2022/05/language-models-perform-reasoning-via.html\">some surprising capabilities</a> in natural language understanding and generation. These models also push the limits of computational infrastructure; in particular, training a language model such as PaLM requires thousands of TPUs working in parallel.  </p><p>One challenge that arises during this training process is efficiently reading and writing the model parameters. Training is distributed across many separate machines, but parameters must be regularly saved to a single object (“checkpoint”) on a permanent storage system without slowing down the overall training process. Individual training jobs must also be able to read just the specific set of parameters they are concerned with in order to avoid the overhead that would be required to load the entire set of model parameters (which could be hundreds of gigabytes).  </p><p>TensorStore has already been used to address these challenges. It has been applied to manage checkpoints associated with large-scale (“<a href=\"https://cloud.google.com/blog/products/ai-machine-learning/googles-scalable-supercomputers-for-machine-learning-cloud-tpu-pods-are-now-publicly-available-in-beta\">multipod</a>”) models trained with <a href=\"https://github.com/google/jax\">JAX</a>&nbsp;(<a href=\"https://github.com/google/jax/blob/640e15fe070a887197143b76a19a3dced816c8df/jax/experimental/gda_serialization/serialization.py\">code example</a>) and has been integrated with frameworks such as <a href=\"https://arxiv.org/pdf/2203.17189.pdf\">T5X</a>&nbsp;(<a href=\"https://github.com/google-research/t5x/blob/d34fff62ddc71c86b680300f8dca198f9db7b246/t5x/checkpoints.py\">code example</a>) and <a href=\"https://blog.google/technology/ai/introducing-pathways-next-generation-ai-architecture/\">Pathways</a>. Model parallelism is used to partition the full set of parameters, which can occupy more than a terabyte of memory, over hundreds of TPUs. Checkpoints are stored in zarr format using TensorStore, with a chunk structure chosen to allow the partition for each TPU to be read and written independently in parallel. </p><table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto;\"><tbody><tr><td style=\"text-align: center;\"><a href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgX9DAdPcFpMfSPteAKTplWpi2h3okSemN9o1J3B6K45LHBjkp2OiSbNimITgluVBLLyyVwXIhe0tvhwDIG01lWXXPCW-Lh0HqOg6qRBE96ON4ndUBmb4kdDmQ0cMsk2dZcsHkTNU2quF7UMttmX8-GbfMLGmXfKePb1sGIa0qSODsf6oV4dXPZhoo-/s800/image1.gif\" style=\"margin-left: auto; margin-right: auto;\"><img border=\"0\" data-original-height=\"746\" data-original-width=\"800\" height=\"373\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgX9DAdPcFpMfSPteAKTplWpi2h3okSemN9o1J3B6K45LHBjkp2OiSbNimITgluVBLLyyVwXIhe0tvhwDIG01lWXXPCW-Lh0HqOg6qRBE96ON4ndUBmb4kdDmQ0cMsk2dZcsHkTNU2quF7UMttmX8-GbfMLGmXfKePb1sGIa0qSODsf6oV4dXPZhoo-/w400-h373/image1.gif\" width=\"400\" /></a></td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\">When saving a checkpoint, each model parameter is written using TensorStore in zarr format using a chunk grid that further subdivides the grid used to partition the parameter over TPUs. The host machines write in parallel the zarr chunks for each of the partitions assigned to TPUs attached to that host. Using TensorStore's asynchronous API, training proceeds even while the data is still being written to persistent storage. When resuming from a checkpoint, each host reads only the chunks that make up the partitions assigned to that host.</td></tr></tbody></table> <h2>Use Case: 3D Brain Mapping</h2><p>The field of synapse-resolution <a href=\"https://en.wikipedia.org/wiki/Connectomics\">connectomics</a> aims to map the wiring of <a href=\"https://ai.googleblog.com/2020/01/releasing-drosophila-hemibrain.html\">animal</a> and <a href=\"http://ai.googleblog.com/2021/06/a-browsable-petascale-reconstruction-of.html\">human</a> brains at the detailed level of individual synaptic connections. This requires imaging the brain at extremely high resolution (nanometers) over fields of view of up to millimeters or more, which yields datasets that can span petabytes in size. In the future these datasets may extend to exabytes as scientists contemplate mapping <a href=\"https://www.sciencedirect.com/science/article/pii/S0092867420310011\">entire mouse</a> or primate brains. However, even current datasets pose significant challenges related to storage, manipulation, and processing; in particular, even a single brain sample may require millions of gigabytes with a coordinate system (pixel space) of hundreds of thousands pixels in each dimension.  </p><p>We have used TensorStore to solve computational challenges associated with large-scale connectomic datasets. Specifically, TensorStore has managed some of the largest and most widely accessed connectomic datasets, with Google Cloud Storage as the underlying object storage system. For example, it has been applied to the <a href=\"https://ai.googleblog.com/2021/06/a-browsable-petascale-reconstruction-of.html\">human cortex “h01” dataset</a>, which is a 3d nanometer-resolution image of human brain tissue. The raw imaging data is 1.4 petabytes (roughly 500,000 * 350,000 * 5,000 pixels large, and is further associated with additional content such as 3d segmentations and annotations that reside in the same coordinate system. The raw data is subdivided into individual chunks 128x128x16 pixels large and stored in the “<a href=\"https://google.github.io/tensorstore/driver/neuroglancer_precomputed/index.html\">Neuroglancer precomputed</a>” format, which is optimized for <a href=\"https://github.com/google/neuroglancer\">web-based interactive viewing</a> and can be easily <a href=\"https://colab.research.google.com/gist/jbms/1ec1192c34ec816c2c517a3b51a8ed6c/h01_data_access.ipynb\">manipulated from TensorStore</a>.  </p><table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto;\"><tbody><tr><td style=\"text-align: center;\"><a href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhM2p80P4faZAfq1_1m0GtjZP1-pFR1idRhN_z8XKijvrnvCYmmY_8bpF3qzloedAy444kxa8VqgAGSHLaWehjgLmLUn_-ZEZlAz3W_0rvIqk86DJhdoxg8Hp3eHcVqhYfrvpcpT7glU88g0GvbTqA5ho2okVK2emPi3OQuhvd65Vg14KKdq6O7AdHz/s640/image3.gif\" style=\"margin-left: auto; margin-right: auto;\"><img border=\"0\" data-original-height=\"360\" data-original-width=\"640\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhM2p80P4faZAfq1_1m0GtjZP1-pFR1idRhN_z8XKijvrnvCYmmY_8bpF3qzloedAy444kxa8VqgAGSHLaWehjgLmLUn_-ZEZlAz3W_0rvIqk86DJhdoxg8Hp3eHcVqhYfrvpcpT7glU88g0GvbTqA5ho2okVK2emPi3OQuhvd65Vg14KKdq6O7AdHz/s16000/image3.gif\" /></a></td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\">A fly brain <a href=\"https://ai.googleblog.com/2020/01/releasing-drosophila-hemibrain.html\">reconstruction</a> for which the underlying data can be easily <a href=\"https://colab.research.google.com/gist/jbms/10b7a91c8b2f8ecbf30a869a1c50defb/flyem-hemibrain-data-access.ipynb\">accessed and manipulated using TensorStore</a>.</td></tr></tbody></table> <h2>Getting Started</h2><p>To get started using the TensorStore Python API, you can install the <a href=\"https://pypi.org/project/tensorstore/\">tensorstore PyPI package</a> using: </p><code style=\"margin-left: 40px; margin-right: 40px;\">pip install tensorstore </code><p>Refer to the <a href=\"https://google.github.io/tensorstore/python/tutorial.html\">tutorials</a> and <a href=\"https://google.github.io/tensorstore/python/api/index.html\">API documentation</a> for usage details. For other installation options and for using the C++ API, refer to <a href=\"https://google.github.io/tensorstore/installation.html\">installation instructions</a>. </p><div style=\"line-height:40%;\">    <br></div><h2>Acknowledgements</h2><p><em>Thanks to <a href=\"https://research.google/people/105450/\">Tim Blakely</a>, <a href=\"https://research.google/people/VirenJain/\">Viren Jain</a>, <a href=\"https://github.com/yashk2810\">Yash Katariya</a>, <a href=\"https://www.jan-matthis.de/\">Jan-Matthis Luckmann</a>, <a href=\"https://research.google/people/MichalJanuszewski/\">Michał Januszewski</a>, <a href=\"https://research.google/people/PeterLi/\">Peter Li</a>, <a href=\"https://research.google/people/104881/\">Adam Roberts</a>, <a href=\"https://research.google/people/107327/\">Brain Williams</a>, and <a href=\"https://research.google/people/HectorYee/\">Hector Yee</a> from Google Research, and <a href=\"https://www.janelia.org/people/davis-bennett\">Davis Bennet</a>, <a href=\"https://www.janelia.org/people/stuart-berg\">Stuart Berg</a>, <a href=\"https://www.yikes.com/~eric/\">Eric Perlman</a>, <a href=\"https://scholar.google.com/citations?user=Pc1TkM0AAAAJ&amp;hl=en\">Stephen Plaza</a>, and <a href=\"https://research.monash.edu/en/persons/juan-nunez-iglesias\">Juan Nunez-Iglesias</a> from the broader scientific community for valuable feedback on the design, early testing and debugging.</em></p>",
  "link": [
    "",
    "",
    "",
    "",
    ""
  ],
  "author": {
    "name": "Andrew Helton",
    "uri": "http://www.blogger.com/profile/12510940840342590054",
    "email": "noreply@blogger.com",
    "gd:image": ""
  },
  "media:thumbnail": "",
  "thr:total": 0
}