{
  "title": "Introduction to reinforcement learning by example",
  "link": "",
  "published": "2020-03-11T12:00:00-07:00",
  "updated": "2020-03-11T12:00:00-07:00",
  "author": {
    "name": "Cathy Yeh"
  },
  "id": "tag:efavdb.com,2020-03-11:/intro-rl-toy-example",
  "summary": "<p>We take a top-down approach to introducing reinforcement learning (<span class=\"caps\">RL</span>) by starting with a toy example: a student going through college.  In order to frame the problem from the <span class=\"caps\">RL</span> point-of-view, we&#8217;ll walk through the following&nbsp;steps:</p>\n<ul>\n<li><strong>Setting up a model of the problem</strong> as a Markov Decision Process …</li></ul>",
  "content": "<p>We take a top-down approach to introducing reinforcement learning (<span class=\"caps\">RL</span>) by starting with a toy example: a student going through college.  In order to frame the problem from the <span class=\"caps\">RL</span> point-of-view, we&#8217;ll walk through the following&nbsp;steps:</p>\n<ul>\n<li><strong>Setting up a model of the problem</strong> as a Markov Decision Process, the framework that underpins the <span class=\"caps\">RL</span> approach to sequential decision-making&nbsp;problems</li>\n<li><strong>Deciding on an objective</strong>: maximize&nbsp;rewards</li>\n<li><strong>Writing down an equation whose solution is our objective</strong>: Bellman&nbsp;equations</li>\n</ul>\n<p>David Silver walks through this example in his <a href=\"http://www0.cs.ucl.ac.uk/staff/d.silver/web/Teaching.html\">lecture notes</a> on <span class=\"caps\">RL</span>, but as far as we can tell, does not provide code, so we&#8217;re sharing our implementation,&nbsp;comprising:</p>\n<ul>\n<li>the student&#8217;s college <a href=\"https://github.com/frangipane/reinforcement-learning/blob/master/02-dynamic-programming/discrete_limit_env.py\">environment</a> using the OpenAI gym&nbsp;package.</li>\n<li>a <a href=\"https://github.com/frangipane/reinforcement-learning/blob/master/02-dynamic-programming/student_MDP.ipynb\">jupyter notebook</a> sampling from the&nbsp;model</li>\n</ul>\n<h2>Student in toy&nbsp;college</h2>\n<p>We model the student as an agent in a college environment who can move between five states: <span class=\"caps\">CLASS</span> 1, 2, 3, the <span class=\"caps\">FACEBOOK</span> state, and <span class=\"caps\">SLEEP</span> state.  The states are represented by the four circles and square.  The <span class=\"caps\">SLEEP</span> state &#8212; the square with no outward bound arrows &#8212; is a terminal state, i.e. once a student reaches that state, her journey is&nbsp;finished.</p>\n<p><img alt=\"student MDP\" src=\"https://efavdb.com/images/student_mdp.png\"></p>\n<p>Actions that a student can take in her current state are labeled in red (facebook/quit/study/sleep/pub) and influence which state she’ll find herself in&nbsp;next.</p>\n<p>In this model, most state transitions are deterministic functions of the action in the current state, e.g. if she decides to study in <span class=\"caps\">CLASS</span> 1, then she’ll definitely advance to <span class=\"caps\">CLASS</span> 2.  The single non-deterministic state transition is if she goes pubbing while in <span class=\"caps\">CLASS</span> 3, where the pubbing action is indicated by a solid dot; she can end up in <span class=\"caps\">CLASS</span> 1, 2 or back in 3 with probability 0.2, 0.4, or 0.4, respectively, depending on how reckless the pubbing&nbsp;was.</p>\n<p>The model also specifies the reward <span class=\"math\">\\(R\\)</span> associated with acting in one state and ending up in the next.  In this example, the dynamics <span class=\"math\">\\(p(s’,r|s,a)\\)</span>, are given to us, i.e. we have a full model of the environment, and, hopefully, the rewards have been designed to capture the actual end goal of the&nbsp;student.</p>\n<h2>Markov Decision&nbsp;Process</h2>\n<p>Formally, we’ve modeled the student’s college experience as a finite Markov Decision Process (<span class=\"caps\">MDP</span>).  The dynamics are Markov because the probability of ending up in the next state depends only on the current state and action, not on any history leading up to the current state.  The Markov property is integral to the simplification of the equations that describe the model, which we&#8217;ll see in a&nbsp;bit.</p>\n<p>The components of an <span class=\"caps\">MDP</span>&nbsp;are:</p>\n<ul>\n<li><span class=\"math\">\\(S\\)</span> - the set of possible&nbsp;states</li>\n<li><span class=\"math\">\\(R\\)</span> - the set of (scalar)&nbsp;rewards</li>\n<li><span class=\"math\">\\(A\\)</span> - the set of possible actions in each&nbsp;state</li>\n</ul>\n<p>The dynamics of the system are described by the probabilities of receiving a reward in the next state given the current state and action taken, <span class=\"math\">\\(p(s’,r|s,a)\\)</span>.  In this example, the <span class=\"caps\">MDP</span> is finite because there are a finite number of states, rewards, and&nbsp;actions.</p>\n<p>The student’s agency in this environment comes from how she decides to act in each state.  The mapping of a state to actions is the <strong>policy</strong>, <span class=\"math\">\\(\\pi(a|s) := p(a|s)\\)</span>, and can be a deterministic or stochastic function of her&nbsp;state.</p>\n<p>Suppose we have an indifferent student who always chooses actions randomly.  We can sample from the <span class=\"caps\">MDP</span> to get some example trajectories the student might experience with this policy.  In the sample trajectories below, the states are enclosed in parentheses <code>(STATE)</code>, and actions enclosed in square brackets <code>[action]</code>.</p>\n<p><strong>Sample trajectories</strong>:</p>\n<div class=\"highlight\"><pre><span></span><span class=\"p\">(</span><span class=\"n\">CLASS1</span><span class=\"p\">)</span><span class=\"c1\">--[facebook]--&gt;(FACEBOOK)--[facebook]--&gt;(FACEBOOK)--[facebook]--&gt;(FACEBOOK)--[facebook]--&gt;(FACEBOOK)--[quit]--&gt;(CLASS1)--[facebook]--&gt;(FACEBOOK)--[quit]--&gt;(CLASS1)--[study]--&gt;(CLASS2)--[sleep]--&gt;(SLEEP)</span>\n\n<span class=\"p\">(</span><span class=\"n\">FACEBOOK</span><span class=\"p\">)</span><span class=\"c1\">--[quit]--&gt;(CLASS1)--[study]--&gt;(CLASS2)--[study]--&gt;(CLASS3)--[study]--&gt;(SLEEP)</span>\n\n<span class=\"p\">(</span><span class=\"n\">SLEEP</span><span class=\"p\">)</span><span class=\"w\"></span>\n\n<span class=\"p\">(</span><span class=\"n\">CLASS1</span><span class=\"p\">)</span><span class=\"c1\">--[facebook]--&gt;(FACEBOOK)--[quit]--&gt;(CLASS1)--[study]--&gt;(CLASS2)--[sleep]--&gt;(SLEEP)</span>\n\n<span class=\"p\">(</span><span class=\"n\">FACEBOOK</span><span class=\"p\">)</span><span class=\"c1\">--[facebook]--&gt;(FACEBOOK)--[facebook]--&gt;(FACEBOOK)--[facebook]--&gt;(FACEBOOK)--[facebook]--&gt;(FACEBOOK)--[quit]--&gt;(CLASS1)--[facebook]--&gt;(FACEBOOK)--[quit]--&gt;(CLASS1)--[study]--&gt;(CLASS2)--[study]--&gt;(CLASS3)--[pub]--&gt;(CLASS2)--[study]--&gt;(CLASS3)--[study]--&gt;(SLEEP)</span>\n</pre></div>\n\n\n<p><strong>Rewards following a random policy</strong>:</p>\n<p>Under this random policy, what total reward would the student expect when starting from any of the states?  We can estimate the expected rewards by summing up the rewards per trajectory and plotting the distributions of total rewards per starting&nbsp;state:</p>\n<p><img alt=\"histogram of sampled returns\" src=\"https://efavdb.com/images/intro_rl_histogram_sampled_returns.png\"></p>\n<h2>Maximizing rewards: discounted return and value&nbsp;functions</h2>\n<p>We’ve just seen how we can estimate rewards starting from each state given a random policy.  Next, we’ll formalize our goal in terms of maximizing&nbsp;returns.</p>\n<h3>Returns</h3>\n<p>We simply summed the rewards from the sample trajectories above, but the quantity we often want to maximize in practice is the <strong>discounted return <span class=\"math\">\\(G_t\\)</span></strong>, which is a sum of the weighted&nbsp;rewards:</p>\n<div class=\"math\">\\begin{eqnarray}\\label{return} \\tag{1}\nG_t := R_{t+1} + \\gamma R_{t+2} + … = \\sum_{k=0}^\\infty \\gamma^k R_{t+k+1}\n\\end{eqnarray}</div>\n<p>where <span class=\"math\">\\(0 \\leq \\gamma \\leq 1\\)</span>.  <span class=\"math\">\\(\\gamma\\)</span> is the <em>discount rate</em> which characterizes how much we weight rewards now vs. later.  Discounting is mathematically useful for avoiding infinite returns in MDPs without a terminal state and allows us to account for uncertainty in the future when we don’t have a perfect model of the&nbsp;environment.</p>\n<p><strong>Aside</strong></p>\n<p>The discount factor introduces a time scale since it says that we don&#8217;t care about rewards that are far in the future.  The half-life (actually, the <span class=\"math\">\\(1/e\\)</span> life) of a reward in units of time steps is <span class=\"math\">\\(1/(1-\\gamma)\\)</span>, which comes from a definition of <span class=\"math\">\\(1/e\\)</span>:</p>\n<div class=\"math\">\\begin{align}\n\\frac{1}{e} = \\lim_{n \\rightarrow \\infty} \\left(1 - \\frac{1}{n} \\right)^n\n\\end{align}</div>\n<p><span class=\"math\">\\(\\gamma = 0.99\\)</span> is often used in practice, which corresponds to a half-life of 100 timesteps since <span class=\"math\">\\(0.99^{100} = (1 - 1/100)^{100} \\approx 1/e\\)</span>.</p>\n<h3>Value&nbsp;functions</h3>\n<p>Earlier, we were able to estimate the expected undiscounted returns starting from each state by sampling from the <span class=\"caps\">MDP</span> under a random policy.  Value functions formalize this notion of the &#8220;goodness&#8221; of being in a&nbsp;state.</p>\n<h4>State value function <span class=\"math\">\\(v\\)</span></h4>\n<p>The <strong>state value function</strong> <span class=\"math\">\\(v_{\\pi}(s)\\)</span> is the expected return when starting in state <span class=\"math\">\\(s\\)</span>, following policy <span class=\"math\">\\(\\pi\\)</span>.</p>\n<div class=\"math\">\\begin{eqnarray}\\label{state-value} \\tag{2}\nv_{\\pi}(s) = \\mathbb{E}_{\\pi}[G_t | S_t = s]\n\\end{eqnarray}</div>\n<p>The state value function can be written as a recursive relationship, the Bellman expectation equation, expressing the value of a state in terms of the values of its neighors by making use of the Markov&nbsp;property.</p>\n<div class=\"math\">\\begin{eqnarray}\\label{state-value-bellman} \\tag{3}\nv_{\\pi}(s) &amp;=&amp; \\mathbb{E}_{\\pi}[G_t | S_t = s] \\\\\n       &amp;=&amp; \\mathbb{E}_{\\pi}[R_{t+1} + \\gamma G_{t+2} | S_t = s] \\\\\n       &amp;=&amp; \\sum_{a} \\pi(a|s) \\sum_{s’, r} p(s’, r | s, a) [r + \\gamma v_{\\pi}(s’) ]\n\\end{eqnarray}</div>\n<p>This equation expresses the value of a state as an average over the discounted value of its neighbor / successor states, plus the expected reward transitioning from <span class=\"math\">\\(s\\)</span> to <span class=\"math\">\\(s’\\)</span>, and <span class=\"math\">\\(v_{\\pi}\\)</span> is the unique<a href=\"#unique\">*</a> solution.  The distribution of rewards depends on the student’s policy since her actions influence her future&nbsp;rewards.</p>\n<p><em>Note on terminology</em>:\nPolicy <em>evaluation</em> uses the Bellman expectation equation to solve for the value function given a policy <span class=\"math\">\\(\\pi\\)</span> and environment dynamics <span class=\"math\">\\(p(s’, r | s, a)\\)</span>.  This is different from policy iteration and value iteration, which are concerned with finding an optimal&nbsp;policy.</p>\n<p>We can solve the Bellman equation for the value function as an alternative to the sampling we did earlier for the student toy example.  Since the problem has a small number of states and actions, and we have full knowledge of the environment, an exact solution is feasible by directly solving the system of linear equations or iteratively using dynamic programming.  Here is the solution to (\\ref{state-value-bellman}) for <span class=\"math\">\\(v\\)</span> under a random policy in the student example (compare to the sample means in the histogram of&nbsp;returns):</p>\n<p><img alt=\"student MDP value function random policy\" src=\"https://efavdb.com/images/student_mdp_values_random_policy.png\"></p>\n<p>We can verify that the solution is self-consistent by spot checking the value of a state in terms of the values of its neighboring states according to the Bellman equation, e.g. the <span class=\"caps\">CLASS1</span> state with <span class=\"math\">\\(v_{\\pi}(\\text{CLASS1}) = -1.3\\)</span>:</p>\n<div class=\"math\">$$\nv_{\\pi}(\\text{CLASS1}) = 0.5 [-2 + 2.7] + 0.5 [-1 + -2.3] = -1.3\n$$</div>\n<h4>Action value function <span class=\"math\">\\(q\\)</span></h4>\n<p>Another value function is the action value function <span class=\"math\">\\(q_{\\pi}(s, a)\\)</span>, which is the expected return from a state <span class=\"math\">\\(s\\)</span> if we follow a policy <span class=\"math\">\\(\\pi\\)</span> after taking an action <span class=\"math\">\\(a\\)</span>:</p>\n<div class=\"math\">\\begin{eqnarray}\\label{action-value} \\tag{4}\nq_{\\pi}(s, a) := \\mathbb{E}_{\\pi} [ G_t | S_t = s, A = a ]\n\\end{eqnarray}</div>\n<p>We can also write <span class=\"math\">\\(v\\)</span> and <span class=\"math\">\\(q\\)</span> in terms of each other.  For example, the state value function can be viewed as an average over the action value functions for that state, weighted by the probability of taking each action, <span class=\"math\">\\(\\pi\\)</span>, from that&nbsp;state:</p>\n<div class=\"math\">\\begin{eqnarray}\\label{state-value-one-step-backup} \\tag{5}\nv_{\\pi}(s) = \\sum_{a} \\pi(a|s) q_{\\pi}(s, a)\n\\end{eqnarray}</div>\n<p>Rewriting <span class=\"math\">\\(v\\)</span> in terms of <span class=\"math\">\\(q\\)</span> in (\\ref{state-value-one-step-backup}) is useful later for thinking about the &#8220;advantage&#8221;, <span class=\"math\">\\(A(s,a)\\)</span>, of taking an action in a state, namely how much better is an action in that state than the&nbsp;average?</p>\n<div class=\"math\">\\begin{align}\nA(s,a) \\equiv q(s,a) - v(s)\n\\end{align}</div>\n<hr>\n<p><strong>Why <span class=\"math\">\\(q\\)</span> in addition to <span class=\"math\">\\(v\\)</span>?</strong></p>\n<p>Looking ahead, we almost never have access to the environment dynamics in real world problems, but solving for <span class=\"math\">\\(q\\)</span> instead of <span class=\"math\">\\(v\\)</span> lets us get around this problem; we can figure out the best action to take in a state solely using <span class=\"math\">\\(q\\)</span> (we further expand on this in our <a href=\"#optimalq\">discussion</a> below on the Bellman optimality equation for <span class=\"math\">\\(q_*\\)</span>.</p>\n<p>A concrete example of using <span class=\"math\">\\(q\\)</span> is provided in our <a href=\"https://efavdb.com/multiarmed-bandits\">post</a> on multiarmed bandits (an example of a simple single-state <span class=\"caps\">MDP</span>), which discusses agents/algorithms that don&#8217;t have access to the true environment dynamics.  The strategy amounts to estimating the action value function of the slot machine and using those estimates to inform which slot machine arms to pull in order to maximize&nbsp;rewards.</p>\n<hr>\n<h2>Optimal value and&nbsp;policy</h2>\n<p>The crux of the <span class=\"caps\">RL</span> problem is finding a policy that maximizes the expected return.  A policy <span class=\"math\">\\(\\pi\\)</span> is defined to be better than another policy <span class=\"math\">\\(\\pi’\\)</span> if <span class=\"math\">\\(v_{\\pi}(s) &gt; v_{\\pi’}(s)\\)</span> for all states.  We are guaranteed<a href=\"#unique\">*</a> an optimal state value function <span class=\"math\">\\(v_*\\)</span> which corresponds to one or more optimal policies <span class=\"math\">\\(\\pi*\\)</span>.</p>\n<p>Recall that the value function for an arbitrary policy can be written in terms of an average over the action values for that state (\\ref{state-value-one-step-backup}).  In contrast, the optimal value function <span class=\"math\">\\(v_*\\)</span> must be consistent with following a policy that selects the action that maximizes the action value functions from a state, i.e. taking a <span class=\"math\">\\(\\max\\)</span> (\\ref{state-value-bellman-optimality}) instead of an average (\\ref{state-value-one-step-backup}) over <span class=\"math\">\\(q\\)</span>, leading to the <strong>Bellman optimality equation</strong> for <span class=\"math\">\\(v_*\\)</span>:</p>\n<div class=\"math\">\\begin{eqnarray}\\label{state-value-bellman-optimality} \\tag{6}\nv_*(s) &amp;=&amp; \\max_a q_{\\pi*}(s, a) \\\\\n    &amp;=&amp; \\max_a \\mathbb{E}_{\\pi*} [R_{t+1} + \\gamma v_*(S_{t+1}) | S_t = s, A_t = a] \\\\\n    &amp;=&amp; \\max_a \\sum_{s’, r} p(s’, r | s, a) [r + \\gamma v_*(s’) ]\n\\end{eqnarray}</div>\n<p>The optimal policy immediately follows: take the action in a state that maximizes the right hand side of (\\ref{state-value-bellman-optimality}).  The <a href=\"https://en.wikipedia.org/wiki/Bellman_equation#Bellman's_Principle_of_Optimality\">principle of optimality</a>, which applies to the Bellman optimality equation, means that this greedy policy actually corresponds to the optimal policy!  Note: Unlike the Bellman expectation equations, the Bellman optimality equations are a nonlinear system of equations due to taking the&nbsp;max.</p>\n<p>The Bellman optimality equation for the action value function <span class=\"math\">\\(q_*(s,a)\\)</span><a name=\"optimalq\"></a>&nbsp;is:</p>\n<div class=\"math\">\\begin{eqnarray}\\label{action-value-bellman-optimality} \\tag{7}\nq_*(s, a) &amp;=&amp; \\mathbb{E}_{\\pi*} [R_{t+1} + \\gamma \\max_{a'} q_*(S_{t+1}', a') | S_t = s, A_t = a] \\\\\n          &amp;=&amp; \\sum_{s', r} p(s', r | s, a) [r + \\gamma \\max_{a'} q_*(s', a') ]\n\\end{eqnarray}</div>\n<hr>\n<p>Looking ahead: In practice, without a knowledge of the environment dynamics, <span class=\"caps\">RL</span> algorithms based on solving value functions can approximate the expectation in (\\ref{action-value-bellman-optimality}) by sampling, i.e. interacting with the environment, and iteratively selecting the action that corresponds to maximizing <span class=\"math\">\\(q\\)</span> in each state that the agent lands in along its trajectory, which is possible since the maximum occurs <strong>inside</strong> the summation in (\\ref{action-value-bellman-optimality}).   In contrast, this sampling approach doesn&#8217;t work for (\\ref{state-value-bellman-optimality}) because of the maximum <strong>outside</strong> the summation in&#8230;that&#8217;s why action value functions are so useful when we lack a model of the&nbsp;environment!</p>\n<hr>\n<p>Here is the optimal state value function and policy for the student example, which we solve for in a later&nbsp;post:</p>\n<p><img alt=\"student MDP optimal value function\" src=\"https://efavdb.com/images/student_mdp_optimal_values.png\"></p>\n<p>Comparing the values per state under the optimal policy vs the random policy, the value in every state under the optimal policy exceeds the value under the random&nbsp;policy.</p>\n<h2>Summary</h2>\n<p>We’ve discussed how the problem of sequential decision making can be framed as an <span class=\"caps\">MDP</span> using the student toy <span class=\"caps\">MDP</span> as an example.  The goal in <span class=\"caps\">RL</span> is to figure out a policy &#8212; what actions to take in each state &#8212; that maximizes our&nbsp;returns.</p>\n<p>MDPs provide a framework for approaching the problem by defining the value of each state, the value functions, and using the value functions to define what a “best policy” means.  The value functions are unique solutions to the Bellman equations, and the <span class=\"caps\">MDP</span> is “solved” when we know the optimal value&nbsp;function.</p>\n<p>Much of reinforcement learning centers around trying to solve these equations under different conditions, e.g. unknown environment dynamics and large &#8212; possibly continuous &#8212; states and/or action spaces that require approximations to the value&nbsp;functions.</p>\n<p>We&#8217;ll discuss how we arrived at the solutions for this toy problem in a future&nbsp;post!</p>\n<h3>Example&nbsp;code</h3>\n<p>Code for sampling from the student environment under a random policy in order to generate the trajectories and histograms of returns is available in this <a href=\"https://github.com/frangipane/reinforcement-learning/blob/master/02-dynamic-programming/student_MDP.ipynb\">jupyter notebook</a>.</p>\n<p>The <a href=\"https://github.com/frangipane/reinforcement-learning/blob/master/02-dynamic-programming/discrete_limit_env.py\">code</a> for the student environment creates an environment with an <span class=\"caps\">API</span> that is compatible with OpenAI gym &#8212; specifically, it is derived from the <code>gym.envs.toy_text.DiscreteEnv</code> environment.</p>\n<p><a name=\"unique\"><em></a>The uniqueness of the solution to the Bellman equations for finite MDPs is stated without proof in Ref [2], but Ref [1] motivates it briefly via the </em>contraction mapping&nbsp;theorem*.</p>\n<h2>References</h2>\n<p>[1] David Silver&#8217;s <span class=\"caps\">RL</span> Course Lecture 2 - (<a href=\"https://www.youtube.com/watch?v=lfHX2hHRMVQ\">video</a>,\n  <a href=\"https://www.davidsilver.uk/wp-content/uploads/2020/03/MDP.pdf\">slides</a>)</p>\n<p>[2] Sutton and Barto -\n  <a href=\"http://incompleteideas.net/book/RLbook2018.pdf\">Reinforcement Learning: An Introduction</a> - Chapter 3: Finite Markov Decision&nbsp;Processes</p>\n<script type=\"text/javascript\">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {\n    var align = \"center\",\n        indent = \"0em\",\n        linebreak = \"false\";\n\n    if (false) {\n        align = (screen.width < 768) ? \"left\" : align;\n        indent = (screen.width < 768) ? \"0em\" : indent;\n        linebreak = (screen.width < 768) ? 'true' : linebreak;\n    }\n\n    var mathjaxscript = document.createElement('script');\n    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';\n    mathjaxscript.type = 'text/javascript';\n    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';\n\n    var configscript = document.createElement('script');\n    configscript.type = 'text/x-mathjax-config';\n    configscript[(window.opera ? \"innerHTML\" : \"text\")] =\n        \"MathJax.Hub.Config({\" +\n        \"    config: ['MMLorHTML.js'],\" +\n        \"    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } },\" +\n        \"    jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" +\n        \"    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" +\n        \"    displayAlign: '\"+ align +\"',\" +\n        \"    displayIndent: '\"+ indent +\"',\" +\n        \"    showMathMenu: true,\" +\n        \"    messageStyle: 'normal',\" +\n        \"    tex2jax: { \" +\n        \"        inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" +\n        \"        displayMath: [ ['$$','$$'] ],\" +\n        \"        processEscapes: true,\" +\n        \"        preview: 'TeX',\" +\n        \"    }, \" +\n        \"    'HTML-CSS': { \" +\n        \"        availableFonts: ['STIX', 'TeX'],\" +\n        \"        preferredFont: 'STIX',\" +\n        \"        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" +\n        \"        linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" +\n        \"    }, \" +\n        \"}); \" +\n        \"if ('default' !== 'default') {\" +\n            \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" +\n                \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" +\n                \"VARIANT['normal'].fonts.unshift('MathJax_default');\" +\n                \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" +\n                \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" +\n                \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" +\n            \"});\" +\n            \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" +\n                \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" +\n                \"VARIANT['normal'].fonts.unshift('MathJax_default');\" +\n                \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" +\n                \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" +\n                \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" +\n            \"});\" +\n        \"}\";\n\n    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);\n    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);\n}\n</script>",
  "category": [
    "",
    "",
    "",
    ""
  ]
}