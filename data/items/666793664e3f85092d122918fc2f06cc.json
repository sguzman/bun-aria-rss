{
  "title": "Commutative Unification",
  "link": "",
  "updated": "2013-01-25T00:00:00+00:00",
  "id": "https://mrocklin.github.io/blog/work/2013/01/25/Commutative-Unification",
  "content": "<p>LogPy now supports commutative and associative pattern matching on expression trees.  This is a standard requirement for computer algebra systems like SymPy but not a traditional feature of logic programming systems.</p>\n\n<p>Pattern-matching in LogPy is expressed by the <code class=\"language-plaintext highlighter-rouge\">eq</code> goal.  This goal relies on unification to match trees of tuples.  Unification is a computational cornerstone of LogPy.  Traditionally <code class=\"language-plaintext highlighter-rouge\">eq</code> performs exact structural pattern matching.  For example</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>(1, x, (5, y, 7))  matches  (1, (2, 3, 4), (5, 6, 7))\n</code></pre></div></div>\n\n<p>with the following substitution</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>{x: (2, 3, 4), y: 6}\n</code></pre></div></div>\n\n<h2 id=\"expression-trees\">Expression Trees</h2>\n\n<p>We traditionally represent both mathematical expressions and computer programs with expression trees.  For example \\(y * (1 + x)\\) can be visualized as follows</p>\n\n<p><img src=\"http://mrocklin.github.com/blog/images/arith-expr.png\" alt=\"\" /></p>\n\n<p>We represent this expression in LogPy with tuples.  The head/first element of each tuple is an operation like <code class=\"language-plaintext highlighter-rouge\">add</code> or <code class=\"language-plaintext highlighter-rouge\">mul</code>.  All subsequent elements (the tail) are the arguments/children of that expression.</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>y * (x + 1) -&gt; (mul, y, (add, x, 1))\n</code></pre></div></div>\n\n<h2 id=\"matching-expression-trees\">Matching Expression Trees</h2>\n\n<p>This form is exactly what we use for unification.  We could match this pattern against the following expression, treating <code class=\"language-plaintext highlighter-rouge\">x</code> and <code class=\"language-plaintext highlighter-rouge\">y</code> as wildcard logic variables</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>(mul, y, (add, x, 1))  matches  (mul, (pow, 2, 10), (add, 3, 1))\n</code></pre></div></div>\n\n<p>with the following substitution</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>{x: 3, y: (pow, 2, 10)}\n</code></pre></div></div>\n\n<p>But what about the following?</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>(add, x, 1)  matches?  (add, 1, 3)\n</code></pre></div></div>\n\n<p>This doesn’t unify.  While the first (<code class=\"language-plaintext highlighter-rouge\">add</code>, <code class=\"language-plaintext highlighter-rouge\">add</code>) and second (<code class=\"language-plaintext highlighter-rouge\">x</code>, <code class=\"language-plaintext highlighter-rouge\">1</code>) elements can match (if <code class=\"language-plaintext highlighter-rouge\">{x: 1}</code>) the third elements (<code class=\"language-plaintext highlighter-rouge\">1</code>, <code class=\"language-plaintext highlighter-rouge\">3</code>) will not.</p>\n\n<p>As mathematicians however we know that because <code class=\"language-plaintext highlighter-rouge\">add</code> is commutative these expressions should match if we are allowed to rearrange the terms in the tail and match <code class=\"language-plaintext highlighter-rouge\">1</code> to <code class=\"language-plaintext highlighter-rouge\">1</code> and <code class=\"language-plaintext highlighter-rouge\">x</code> to <code class=\"language-plaintext highlighter-rouge\">3</code>.  LogPy doesn’t know this by default.  LogPy is not a math library.</p>\n\n<h2 id=\"building-commutative-equality\">Building Commutative Equality</h2>\n\n<p>Given the goal <code class=\"language-plaintext highlighter-rouge\">seteq</code> for set unification and a goal <code class=\"language-plaintext highlighter-rouge\">conso</code> for head-tail pattern matching we build <code class=\"language-plaintext highlighter-rouge\">eq_commutative</code> for commutative matching.</p>\n\n<p>Example of <code class=\"language-plaintext highlighter-rouge\">seteq</code></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>run(0, x, seteq((1, 2, x), (3, 1, 2)))  # seteq matches within sets\n(3,)\n</code></pre></div></div>\n\n<p>Example of <code class=\"language-plaintext highlighter-rouge\">conso</code></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>run(0, head,  conso(head, tail, (1, 2, 3, 4)))\n(1,)\nrun(0, tail,  conso(head, tail, (1, 2, 3, 4)))\n((2, 3, 4),)\n</code></pre></div></div>\n\n<p>Given these two it is easy to build <code class=\"language-plaintext highlighter-rouge\">eq_commutative</code></p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"k\">def</span> <span class=\"nf\">eq_commutative</span><span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"p\">):</span>\n    <span class=\"n\">operation</span><span class=\"p\">,</span> <span class=\"n\">utail</span><span class=\"p\">,</span> <span class=\"n\">vtail</span> <span class=\"o\">=</span> <span class=\"n\">var</span><span class=\"p\">(),</span> <span class=\"n\">var</span><span class=\"p\">(),</span> <span class=\"n\">var</span><span class=\"p\">()</span>\n    <span class=\"k\">return</span> <span class=\"n\">lall</span><span class=\"p\">(</span><span class=\"n\">conso</span><span class=\"p\">(</span><span class=\"n\">operation</span><span class=\"p\">,</span> <span class=\"n\">utail</span><span class=\"p\">,</span> <span class=\"n\">u</span><span class=\"p\">),</span>\n                <span class=\"n\">conso</span><span class=\"p\">(</span><span class=\"n\">operation</span><span class=\"p\">,</span> <span class=\"n\">vtail</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"p\">),</span>\n                <span class=\"n\">commutative</span><span class=\"p\">(</span><span class=\"n\">operation</span><span class=\"p\">),</span>\n                <span class=\"n\">seteq</span><span class=\"p\">(</span><span class=\"n\">utail</span><span class=\"p\">,</span> <span class=\"n\">vtail</span><span class=\"p\">))</span></code></pre>\n</figure>\n\n<p>That is we require all of the following (<code class=\"language-plaintext highlighter-rouge\">lall</code> is logical all).</p>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">u</code> must be of the form <code class=\"language-plaintext highlighter-rouge\">(operation, utail....)</code></li>\n  <li><code class=\"language-plaintext highlighter-rouge\">v</code> must be of the form <code class=\"language-plaintext highlighter-rouge\">(operation, vtail....)</code>.  Note that the same variable <code class=\"language-plaintext highlighter-rouge\">operation</code> must be the same in both expressions.</li>\n  <li>The operation must be commutative (operations register themselves beforehand, see example below)</li>\n  <li><code class=\"language-plaintext highlighter-rouge\">utail</code> and <code class=\"language-plaintext highlighter-rouge\">vtail</code> must unify under set equality.</li>\n</ul>\n\n<p>I am glossing over some details here, like “what about associative matching” and “how does <code class=\"language-plaintext highlighter-rouge\">seteq</code> work?” but this should give a high-level view of how logic programs are made.  Lets see an example of associative/commutative matching</p>\n\n<h2 id=\"example\">Example</h2>\n\n<p>This is the <a href=\"https://github.com/logpy/logpy/blob/master/examples/commutative.py\">standard example</a> for commutative matching found in the <a href=\"https://github.com/logpy/logpy\">repository</a></p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"kn\">from</span> <span class=\"nn\">logpy</span> <span class=\"kn\">import</span> <span class=\"n\">run</span><span class=\"p\">,</span> <span class=\"n\">var</span><span class=\"p\">,</span> <span class=\"n\">fact</span>\n<span class=\"kn\">from</span> <span class=\"nn\">logpy.assoccomm</span> <span class=\"kn\">import</span> <span class=\"n\">eq_assoccomm</span> <span class=\"k\">as</span> <span class=\"n\">eq</span>\n<span class=\"kn\">from</span> <span class=\"nn\">logpy.assoccomm</span> <span class=\"kn\">import</span> <span class=\"n\">commutative</span><span class=\"p\">,</span> <span class=\"n\">associative</span>\n\n<span class=\"c1\"># Define some dummy Operationss\n</span><span class=\"n\">add</span> <span class=\"o\">=</span> <span class=\"s\">'add'</span>\n<span class=\"n\">mul</span> <span class=\"o\">=</span> <span class=\"s\">'mul'</span>\n\n<span class=\"c1\"># Register that these ops are commutative using the facts system\n</span><span class=\"n\">fact</span><span class=\"p\">(</span><span class=\"n\">commutative</span><span class=\"p\">,</span> <span class=\"n\">mul</span><span class=\"p\">)</span>\n<span class=\"n\">fact</span><span class=\"p\">(</span><span class=\"n\">commutative</span><span class=\"p\">,</span> <span class=\"n\">add</span><span class=\"p\">)</span>\n<span class=\"n\">fact</span><span class=\"p\">(</span><span class=\"n\">associative</span><span class=\"p\">,</span> <span class=\"n\">mul</span><span class=\"p\">)</span>\n<span class=\"n\">fact</span><span class=\"p\">(</span><span class=\"n\">associative</span><span class=\"p\">,</span> <span class=\"n\">add</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Define some wild variables\n</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">var</span><span class=\"p\">(</span><span class=\"s\">'x'</span><span class=\"p\">),</span> <span class=\"n\">var</span><span class=\"p\">(</span><span class=\"s\">'y'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Two expressions to match\n</span><span class=\"n\">pattern</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">mul</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">add</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">),</span> <span class=\"n\">y</span><span class=\"p\">)</span>                <span class=\"c1\"># (1 + x) * y\n</span><span class=\"n\">expr</span>    <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">mul</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">add</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">))</span>                <span class=\"c1\"># 2 * (3 + 1)\n</span><span class=\"k\">print</span> <span class=\"n\">run</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"n\">y</span><span class=\"p\">),</span> <span class=\"n\">eq</span><span class=\"p\">(</span><span class=\"n\">pattern</span><span class=\"p\">,</span> <span class=\"n\">expr</span><span class=\"p\">))</span>\n<span class=\"c1\"># ((3, 2),) #  meaning one result with x matches to 3 and y matches to 2</span></code></pre>\n</figure>\n\n<h2 id=\"conclusion\">Conclusion</h2>\n\n<p>With this LogPy contains all of the functionality of SymPy’s old <code class=\"language-plaintext highlighter-rouge\">unify</code> module but in a cleaner and much more extensible form.</p>"
}