{
  "title": "50 states Rural Postman Problem",
  "link": "",
  "id": "http://brooksandrew.github.io/simpleblog/articles/fifty-states-rural-postman-problem",
  "published": "2017-11-19T00:00:00+00:00",
  "updated": "2017-11-19T00:00:00+00:00",
  "author": {
    "name": "andrew brooks",
    "uri": "http://brooksandrew.github.io/simpleblog",
    "email": "andrewbrooksct@gmail.com"
  },
  "content": "<h4 id=\"motivation\">Motivation</h4>\n\n<p>Recently I spent a considerable amount of time writing the <a href=\"https://github.com/brooksandrew/postman_problems\">postman_problems</a> python library implementing solvers for the Chinese and Rural Postman Problems (CPP and RPP respectively).  I wrote about\nmy initial motivation for the project: finding the optimal route through a trail system in a state park <a href=\"http://brooksandrew.github.io/simpleblog/articles/intro-to-graph-optimization-solving-cpp/\">here</a>.  Although I’ve still yet to run the 34 mile optimal trail\nroute, I am pleased with the optimization procedure.  However, I couldn’t help but feel that all those nights and weekends hobbying on this thing deserved a more satisfying visual than my static SVGs\nand hacky GIF.  So to spice it up, I decided to solve the RPP on a graph derived from geodata and visualize on an interactive Leaflet map.</p>\n\n<h4 id=\"the-problem\">The Problem</h4>\n\n<p>In short, ride all 50 state named avenues in DC end-to-end following the shortest route possible.</p>\n\n<p>There happens to be an annual <a href=\"https://org.salsalabs.com/o/451/p/salsa/event/common/public/?event_KEY=99906\">50 states ride</a> sponsored by our regional bike association, <a href=\"http://www.waba.org/\">WABA</a>, that takes riders to each of the 50<sup>†</sup> state named avenues in DC.  Each state’s avenue is\n<em>touched</em>, but not covered in full.  This problem takes it a step further by instituting this requirement.  Thus, it boils to the RPP where the required edges are state avenues (end-to-end) and the\noptional edges are every other road within DC city limits.</p>\n\n<p>For those unfamiliar with DC street naming convention, that can (and should) be remedied with a read through the history behind the street system <a href=\"https://dc.curbed.com/2014/8/13/10061100/facts-and-myths-about-dcs-street-system\">here</a>.  Seriously, it’s an\ninteresting read.  Basically there are 50 state named avenues in DC ranging from 0.3 miles (Indiana Avenue) to 10 miles (Massachusetts Avenue) comprising <a href=\"https://en.wikipedia.org/wiki/List_of_state-named_roadways_in_Washington,_D.C.#cite_note-AL2-2\">115 miles</a> in total.</p>\n\n<h4 id=\"the-solution\">The Solution</h4>\n\n<p>The data is grabbed from Open Street Maps (OSM).  Most of the post is spent wrangling the OSM geodata into shape for the RPP algorithm using NetworkX graphs.  The final route (and intermediate steps)\nare visualized using Leaflet maps through <a href=\"https://github.com/jwass/mplleaflet\">mplleaflet</a> which enable interactivity using tiles from Mapbox and CartoDB among others.</p>\n\n<p>Note to readers: the rendering of these maps can work the browser pretty hard; allow a couple extra seconds for loading.</p>\n\n<h4 id=\"the-approach\">The Approach</h4>\n\n<p>Most of the heavy lifting leverages functions from the <a href=\"https://github.com/brooksandrew/postman_problems_examples/blob/master/graph.py\">graph.py</a> module in the <a href=\"https://github.com/brooksandrew/postman_problems_examples\">postman_problems_examples</a> repo.  The majority of pre-RPP processing employs heuristics that simplify the computation\nsuch that this code can run in a reasonable amount of time.  The parameters employed here, which I believe get pretty darn close to the optimal solution, run in about 50 minutes.  By tweaking a couple\nparameters, accuracy can be sacrificed for time to get run time down to ~5 minutes on a standard 4 core laptop.</p>\n\n<p>Verbose technical details about the guts of each step are omitted from this post for readability.  However the interested reader can find these in the docstrings in <a href=\"https://github.com/brooksandrew/postman_problems_examples/blob/master/graph.py\">graph.py</a>.</p>\n\n<p>The table of contents below provides the best high-level summary of the approach.  All code needed to reproduce this analysis is in the <a href=\"https://github.com/brooksandrew/postman_problems_examples\">postman_problems_examples</a> repo, including the jupyter notebook\nused to author this blog post and a conda environment.</p>\n\n<p><sup>†</sup> While there are 50 <em>roadways</em>, there are technically only 48 state named <em>avenues</em>: Ohio Drive and California Street are the stubborn exceptions.</p>\n\n<!-- #### Animation\n\nBig thanks and kudos to my sister [@laurabrooks](https://github.com/laurabrooks) for helping me create this.  Street names are there, they just need a bit of zoom.  Code [here][rpp_animation_gh].\n\n[rpp_animation_gh]: https://github.com/brooksandrew/postman_problems_examples/tree/master/50states/animation\n\n<iframe src=\"https://cdn.rawgit.com/brooksandrew/postman_problems_examples/9d4f0965ca02ff69cbbe80a477f9baa1b1678b2f/50states/animation/index.html\" height=\"600\" width=\"750\"></iframe>\n -->\n\n<h4 id=\"table-of-contents\">Table of Contents</h4>\n\n<ul id=\"markdown-toc\">\n  <li><a href=\"#0-get-the-data\" id=\"markdown-toc-0-get-the-data\">0: Get the data</a></li>\n  <li><a href=\"#1-load-osm-to-networkx\" id=\"markdown-toc-1-load-osm-to-networkx\">1: Load OSM to NetworkX</a></li>\n  <li><a href=\"#2-make-graph-w-state-avenues-only\" id=\"markdown-toc-2-make-graph-w-state-avenues-only\">2: Make Graph w State Avenues only</a>    <ul>\n      <li><a href=\"#21-viz-state-avenues\" id=\"markdown-toc-21-viz-state-avenues\">2.1 Viz state avenues</a></li>\n    </ul>\n  </li>\n  <li><a href=\"#3-remove-redundant-state-avenues\" id=\"markdown-toc-3-remove-redundant-state-avenues\">3. Remove Redundant State Avenues</a>    <ul>\n      <li><a href=\"#31-create-state-avenue-graph-with-one-way-edges-only\" id=\"markdown-toc-31-create-state-avenue-graph-with-one-way-edges-only\">3.1 Create state avenue graph with one-way edges only</a></li>\n      <li><a href=\"#32-split-connected-components\" id=\"markdown-toc-32-split-connected-components\">3.2 Split connected components</a></li>\n      <li><a href=\"#33--34-match-connected-components\" id=\"markdown-toc-33--34-match-connected-components\">3.3 &amp; 3.4 Match connected components</a></li>\n      <li><a href=\"#35-build-graph-without-redundant-edges\" id=\"markdown-toc-35-build-graph-without-redundant-edges\">3.5 Build graph without redundant edges</a></li>\n    </ul>\n  </li>\n  <li><a href=\"#4-create-single-connected-component\" id=\"markdown-toc-4-create-single-connected-component\">4. Create Single Connected Component</a>    <ul>\n      <li><a href=\"#41-contract-edges\" id=\"markdown-toc-41-contract-edges\">4.1 Contract edges</a></li>\n      <li><a href=\"#42-calculate-haversine-distance-between-components\" id=\"markdown-toc-42-calculate-haversine-distance-between-components\">4.2 Calculate haversine distance between components</a></li>\n      <li><a href=\"#43-find-minimum-distance-connectors\" id=\"markdown-toc-43-find-minimum-distance-connectors\">4.3 Find minimum distance connectors</a></li>\n      <li><a href=\"#44-build-single-component-graph\" id=\"markdown-toc-44-build-single-component-graph\">4.4 Build single component graph</a></li>\n      <li><a href=\"#45-viz-single-connected-component\" id=\"markdown-toc-45-viz-single-connected-component\">4.5 Viz single connected component</a></li>\n    </ul>\n  </li>\n  <li><a href=\"#5-solve-cpp\" id=\"markdown-toc-5-solve-cpp\">5. Solve CPP</a>    <ul>\n      <li><a href=\"#51-create-cpp-edgelist\" id=\"markdown-toc-51-create-cpp-edgelist\">5.1 Create CPP edgelist</a></li>\n      <li><a href=\"#52-cpp-solver\" id=\"markdown-toc-52-cpp-solver\">5.2 CPP solver</a></li>\n      <li><a href=\"#53-cpp-results\" id=\"markdown-toc-53-cpp-results\">5.3: CPP results</a></li>\n    </ul>\n  </li>\n  <li><a href=\"#6-solve-rpp\" id=\"markdown-toc-6-solve-rpp\">6. Solve RPP</a>    <ul>\n      <li><a href=\"#61-create-rpp-edgelist\" id=\"markdown-toc-61-create-rpp-edgelist\">6.1 Create RPP edgelist</a></li>\n      <li><a href=\"#62-rpp-solver\" id=\"markdown-toc-62-rpp-solver\">6.2 RPP solver</a></li>\n      <li><a href=\"#63-rpp-results\" id=\"markdown-toc-63-rpp-results\">6.3 RPP results</a></li>\n      <li><a href=\"#64-viz-rpp-graph\" id=\"markdown-toc-64-viz-rpp-graph\">6.4 Viz RPP graph</a></li>\n      <li><a href=\"#65-serialize-rpp-solution\" id=\"markdown-toc-65-serialize-rpp-solution\">6.5 Serialize RPP solution</a></li>\n    </ul>\n  </li>\n</ul>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"kn\">import</span> <span class=\"nn\">mplleaflet</span>\n<span class=\"kn\">import</span> <span class=\"nn\">networkx</span> <span class=\"k\">as</span> <span class=\"n\">nx</span>\n<span class=\"kn\">import</span> <span class=\"nn\">pandas</span> <span class=\"k\">as</span> <span class=\"n\">pd</span>\n<span class=\"kn\">import</span> <span class=\"nn\">matplotlib.pyplot</span> <span class=\"k\">as</span> <span class=\"n\">plt</span>\n<span class=\"kn\">from</span> <span class=\"nn\">collections</span> <span class=\"kn\">import</span> <span class=\"n\">Counter</span>\n\n<span class=\"c\"># can be found in https://github.com/brooksandrew/postman_problems_examples</span>\n<span class=\"kn\">from</span> <span class=\"nn\">osm2nx</span> <span class=\"kn\">import</span> <span class=\"n\">read_osm</span><span class=\"p\">,</span> <span class=\"n\">haversine</span>\n<span class=\"kn\">from</span> <span class=\"nn\">graph</span> <span class=\"kn\">import</span> <span class=\"p\">(</span>\n    <span class=\"n\">states_to_state_avenue_name</span><span class=\"p\">,</span> <span class=\"n\">subset_graph_by_edge_name</span><span class=\"p\">,</span> <span class=\"n\">keep_oneway_edges_only</span><span class=\"p\">,</span> <span class=\"n\">create_connected_components</span><span class=\"p\">,</span>\n    <span class=\"n\">create_unkinked_connected_components</span><span class=\"p\">,</span> <span class=\"n\">nodewise_distance_connected_components</span><span class=\"p\">,</span>\n    <span class=\"n\">calculate_component_overlap</span><span class=\"p\">,</span> <span class=\"n\">calculate_redundant_components</span><span class=\"p\">,</span> <span class=\"n\">create_deduped_state_road_graph</span><span class=\"p\">,</span> \n    <span class=\"n\">create_contracted_edge_graph</span><span class=\"p\">,</span> <span class=\"n\">shortest_paths_between_components</span><span class=\"p\">,</span> <span class=\"n\">find_minimum_weight_edges_to_connect_components</span><span class=\"p\">,</span>\n    <span class=\"n\">create_rpp_edgelist</span>\n    <span class=\"p\">)</span>\n\n<span class=\"c\"># can be found in https://github.com/brooksandrew/postman_problems</span>\n<span class=\"kn\">from</span> <span class=\"nn\">postman_problems.tests.utils</span> <span class=\"kn\">import</span> <span class=\"n\">create_mock_csv_from_dataframe</span>\n<span class=\"kn\">from</span> <span class=\"nn\">postman_problems.solver</span> <span class=\"kn\">import</span> <span class=\"n\">rpp</span><span class=\"p\">,</span> <span class=\"n\">cpp</span>\n<span class=\"kn\">from</span> <span class=\"nn\">postman_problems.stats</span> <span class=\"kn\">import</span> <span class=\"n\">calculate_postman_solution_stats</span></code></pre></figure>\n\n<h2 id=\"0-get-the-data\">0: Get the data</h2>\n\n<p>There are many ways to grab Open Street Map (OSM) data, since it’s, well, open.  I grabbed the DC map from GeoFabrik <a href=\"http://download.geofabrik.de/north-america/us/district-of-columbia.html\">here</a>.</p>\n\n<h2 id=\"1-load-osm-to-networkx\">1: Load OSM to NetworkX</h2>\n\n<p>While some libraries like <a href=\"https://github.com/gboeing/osmnx\">OSMnx</a> provide an elegant interface to downloading, transforming and manipulating OSM data in NetworkX, I decided to start with the raw\ndata itself.  I adopted an OSM-to-nx parser from a hodge podge of Gists (<a href=\"https://gist.github.com/aflaxman/287370/\">here</a> and <a href=\"https://gist.github.com/Tofull/49fbb9f3661e376d2fe08c2e9d64320e\">there</a>) to <a href=\"https://github.com/brooksandrew/50states/blob/master/osm2nx.py\"><code class=\"highlighter-rouge\">read_osm</code></a>.</p>\n\n<p><code class=\"highlighter-rouge\">read_osm</code> creates a directed graph.  However, for this analysis, we’ll use undirected graphs with the assumption that all roads are bidirectional on a bike one way or another.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"o\">%%</span><span class=\"n\">time</span>\n\n<span class=\"c\"># load OSM to a directed NX</span>\n<span class=\"n\">g</span> <span class=\"o\">=</span> <span class=\"n\">read_osm</span><span class=\"p\">(</span><span class=\"s\">'district-of-columbia-latest.osm'</span><span class=\"p\">)</span>  \n\n<span class=\"c\"># create an undirected graph</span>\n<span class=\"n\">g_ud</span> <span class=\"o\">=</span> <span class=\"n\">g</span><span class=\"o\">.</span><span class=\"n\">to_undirected</span><span class=\"p\">()</span></code></pre></figure>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;class 'networkx.classes.digraph.DiGraph'&gt;\nCPU times: user 46.6 s, sys: 2.1 s, total: 48.7 s\nWall time: 50.2 s\n</code></pre></div></div>\n\n<p>This is a pretty big graph, about 275k edges.  It takes about a minute to load on my machine (Macbook w 4 cores)</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"k\">print</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">g</span><span class=\"o\">.</span><span class=\"n\">edges</span><span class=\"p\">()))</span> <span class=\"c\"># number of edges</span></code></pre></figure>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>275429\n</code></pre></div></div>\n\n<h2 id=\"2-make-graph-w-state-avenues-only\">2: Make Graph w State Avenues only</h2>\n\n<h4 id=\"generate-state-avenue-names\">Generate state avenue names</h4>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"n\">STATE_STREET_NAMES</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n    <span class=\"s\">'Alabama'</span><span class=\"p\">,</span><span class=\"s\">'Alaska'</span><span class=\"p\">,</span><span class=\"s\">'Arizona'</span><span class=\"p\">,</span><span class=\"s\">'Arkansas'</span><span class=\"p\">,</span><span class=\"s\">'California'</span><span class=\"p\">,</span><span class=\"s\">'Colorado'</span><span class=\"p\">,</span>\n    <span class=\"s\">'Connecticut'</span><span class=\"p\">,</span><span class=\"s\">'Delaware'</span><span class=\"p\">,</span><span class=\"s\">'Florida'</span><span class=\"p\">,</span><span class=\"s\">'Georgia'</span><span class=\"p\">,</span><span class=\"s\">'Hawaii'</span><span class=\"p\">,</span><span class=\"s\">'Idaho'</span><span class=\"p\">,</span><span class=\"s\">'Illinois'</span><span class=\"p\">,</span>\n    <span class=\"s\">'Indiana'</span><span class=\"p\">,</span><span class=\"s\">'Iowa'</span><span class=\"p\">,</span><span class=\"s\">'Kansas'</span><span class=\"p\">,</span><span class=\"s\">'Kentucky'</span><span class=\"p\">,</span><span class=\"s\">'Louisiana'</span><span class=\"p\">,</span><span class=\"s\">'Maine'</span><span class=\"p\">,</span><span class=\"s\">'Maryland'</span><span class=\"p\">,</span>\n    <span class=\"s\">'Massachusetts'</span><span class=\"p\">,</span><span class=\"s\">'Michigan'</span><span class=\"p\">,</span><span class=\"s\">'Minnesota'</span><span class=\"p\">,</span><span class=\"s\">'Mississippi'</span><span class=\"p\">,</span><span class=\"s\">'Missouri'</span><span class=\"p\">,</span><span class=\"s\">'Montana'</span><span class=\"p\">,</span>\n    <span class=\"s\">'Nebraska'</span><span class=\"p\">,</span><span class=\"s\">'Nevada'</span><span class=\"p\">,</span><span class=\"s\">'New Hampshire'</span><span class=\"p\">,</span><span class=\"s\">'New Jersey'</span><span class=\"p\">,</span><span class=\"s\">'New Mexico'</span><span class=\"p\">,</span><span class=\"s\">'New York'</span><span class=\"p\">,</span>\n    <span class=\"s\">'North Carolina'</span><span class=\"p\">,</span><span class=\"s\">'North Dakota'</span><span class=\"p\">,</span><span class=\"s\">'Ohio'</span><span class=\"p\">,</span><span class=\"s\">'Oklahoma'</span><span class=\"p\">,</span><span class=\"s\">'Oregon'</span><span class=\"p\">,</span><span class=\"s\">'Pennsylvania'</span><span class=\"p\">,</span>\n    <span class=\"s\">'Rhode Island'</span><span class=\"p\">,</span><span class=\"s\">'South Carolina'</span><span class=\"p\">,</span><span class=\"s\">'South Dakota'</span><span class=\"p\">,</span><span class=\"s\">'Tennessee'</span><span class=\"p\">,</span><span class=\"s\">'Texas'</span><span class=\"p\">,</span><span class=\"s\">'Utah'</span><span class=\"p\">,</span>\n    <span class=\"s\">'Vermont'</span><span class=\"p\">,</span><span class=\"s\">'Virginia'</span><span class=\"p\">,</span><span class=\"s\">'Washington'</span><span class=\"p\">,</span><span class=\"s\">'West Virginia'</span><span class=\"p\">,</span><span class=\"s\">'Wisconsin'</span><span class=\"p\">,</span><span class=\"s\">'Wyoming'</span>\n<span class=\"p\">]</span></code></pre></figure>\n\n<p>Most state avenues are written in the long form (ex. Connecticut Avenue Northwest).  However, some, such as Florida Ave NW, are written in the short form.  To be safe, we grab any permutation OSM\ncould throw at us.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"n\">candidate_state_avenue_names</span> <span class=\"o\">=</span> <span class=\"n\">states_to_state_avenue_name</span><span class=\"p\">(</span><span class=\"n\">STATE_STREET_NAMES</span><span class=\"p\">)</span>\n\n<span class=\"c\"># two states break the \"Avenue\" pattern</span>\n<span class=\"n\">candidate_state_avenue_names</span> <span class=\"o\">+=</span> <span class=\"p\">[</span><span class=\"s\">'California Street Northwest'</span><span class=\"p\">,</span> <span class=\"s\">'Ohio Drive Southwest'</span><span class=\"p\">]</span>\n\n<span class=\"c\"># preview</span>\n<span class=\"n\">candidate_state_avenue_names</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">:</span><span class=\"mi\">20</span><span class=\"p\">]</span></code></pre></figure>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>['Alabama Ave Southeast',\n 'Alabama Ave Southwest',\n 'Alabama Ave Northeast',\n 'Alabama Ave Northwest',\n 'Alabama Ave SE',\n 'Alabama Ave SW',\n 'Alabama Ave NE',\n 'Alabama Ave NW',\n 'Alabama Avenue Southeast',\n 'Alabama Avenue Southwest',\n 'Alabama Avenue Northeast',\n 'Alabama Avenue Northwest',\n 'Alabama Avenue SE',\n 'Alabama Avenue SW',\n 'Alabama Avenue NE',\n 'Alabama Avenue NW',\n 'Alaska Ave Southeast',\n 'Alaska Ave Southwest',\n 'Alaska Ave Northeast',\n 'Alaska Ave Northwest']\n</code></pre></div></div>\n\n<h4 id=\"create-graph-w-state-avenues-only\">Create graph w state avenues only</h4>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"n\">g_st</span> <span class=\"o\">=</span> <span class=\"n\">subset_graph_by_edge_name</span><span class=\"p\">(</span><span class=\"n\">g</span><span class=\"p\">,</span> <span class=\"n\">candidate_state_avenue_names</span><span class=\"p\">)</span>\n\n<span class=\"c\"># Add state edge attribute from full streetname (with avenue/drive and quandrant)</span>\n<span class=\"k\">for</span> <span class=\"n\">e</span> <span class=\"ow\">in</span> <span class=\"n\">g_st</span><span class=\"o\">.</span><span class=\"n\">edges</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"o\">=</span><span class=\"bp\">True</span><span class=\"p\">):</span>\n    <span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">][</span><span class=\"s\">'state'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">][</span><span class=\"s\">'name'</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">rsplit</span><span class=\"p\">(</span><span class=\"s\">' '</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)[</span><span class=\"mi\">0</span><span class=\"p\">]</span></code></pre></figure>\n\n<p>This is a much smaller graph:</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"k\">print</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">g_st</span><span class=\"o\">.</span><span class=\"n\">edges</span><span class=\"p\">()))</span></code></pre></figure>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>7148\n</code></pre></div></div>\n\n<p>But every state is represented:</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"n\">edge_count_by_state</span> <span class=\"o\">=</span> <span class=\"n\">Counter</span><span class=\"p\">([</span><span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">][</span><span class=\"s\">'state'</span><span class=\"p\">]</span> <span class=\"k\">for</span> <span class=\"n\">e</span> <span class=\"ow\">in</span> <span class=\"n\">g_st</span><span class=\"o\">.</span><span class=\"n\">edges</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"o\">=</span><span class=\"bp\">True</span><span class=\"p\">)])</span>\n\n<span class=\"c\"># number of unique states </span>\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">edge_count_by_state</span><span class=\"p\">))</span></code></pre></figure>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>50\n</code></pre></div></div>\n\n<p>Here they are by edge count:</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"n\">edge_count_by_state</span></code></pre></figure>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Counter({'Alabama': 348,\n         'Alaska': 36,\n         'Arizona': 89,\n         'Arkansas': 64,\n         'California': 24,\n         'Colorado': 59,\n         'Connecticut': 283,\n         'Delaware': 66,\n         'Florida': 253,\n         'Georgia': 185,\n         'Hawaii': 84,\n         'Idaho': 50,\n         'Illinois': 37,\n         'Indiana': 29,\n         'Iowa': 30,\n         'Kansas': 74,\n         'Kentucky': 47,\n         'Louisiana': 37,\n         'Maine': 199,\n         'Maryland': 233,\n         'Massachusetts': 581,\n         'Michigan': 225,\n         'Minnesota': 214,\n         'Mississippi': 102,\n         'Missouri': 66,\n         'Montana': 74,\n         'Nebraska': 183,\n         'Nevada': 122,\n         'New Hampshire': 259,\n         'New Jersey': 170,\n         'New Mexico': 66,\n         'New York': 333,\n         'North Carolina': 87,\n         'North Dakota': 16,\n         'Ohio': 391,\n         'Oklahoma': 48,\n         'Oregon': 170,\n         'Pennsylvania': 433,\n         'Rhode Island': 282,\n         'South Carolina': 60,\n         'South Dakota': 124,\n         'Tennessee': 40,\n         'Texas': 123,\n         'Utah': 66,\n         'Vermont': 154,\n         'Virginia': 134,\n         'Washington': 58,\n         'West Virginia': 56,\n         'Wisconsin': 257,\n         'Wyoming': 27})\n</code></pre></div></div>\n\n<h3 id=\"21-viz-state-avenues\">2.1 Viz state avenues</h3>\n\n<p>As long as your NetworkX graph has <code class=\"highlighter-rouge\">lat</code> and <code class=\"highlighter-rouge\">lon</code> node attributes, <a href=\"https://github.com/jwass/mplleaflet\">mplleaflet</a> can be used to pretty effortlessly plot your NetworkX graph on an interactive map.</p>\n\n<p>Here’s the map with all the state avenues…</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"n\">fig</span><span class=\"p\">,</span> <span class=\"n\">ax</span> <span class=\"o\">=</span> <span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">subplots</span><span class=\"p\">(</span><span class=\"n\">figsize</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">8</span><span class=\"p\">))</span>\n\n<span class=\"n\">pos</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"n\">k</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"n\">g_st</span><span class=\"o\">.</span><span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">k</span><span class=\"p\">][</span><span class=\"s\">'lon'</span><span class=\"p\">],</span> <span class=\"n\">g_st</span><span class=\"o\">.</span><span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">k</span><span class=\"p\">][</span><span class=\"s\">'lat'</span><span class=\"p\">])</span> <span class=\"k\">for</span> <span class=\"n\">k</span> <span class=\"ow\">in</span> <span class=\"n\">g_st</span><span class=\"o\">.</span><span class=\"n\">nodes</span><span class=\"p\">()}</span>    \n<span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">draw_networkx_edges</span><span class=\"p\">(</span><span class=\"n\">g_st</span><span class=\"p\">,</span> <span class=\"n\">pos</span><span class=\"p\">,</span> <span class=\"n\">width</span><span class=\"o\">=</span><span class=\"mf\">4.0</span><span class=\"p\">,</span> <span class=\"n\">edge_color</span><span class=\"o\">=</span><span class=\"s\">'black'</span><span class=\"p\">,</span> <span class=\"n\">alpha</span><span class=\"o\">=</span><span class=\"mf\">0.7</span><span class=\"p\">)</span>\n\n<span class=\"c\"># save viz    </span>\n<span class=\"n\">mplleaflet</span><span class=\"o\">.</span><span class=\"n\">save_html</span><span class=\"p\">(</span><span class=\"n\">fig</span><span class=\"p\">,</span> <span class=\"s\">'state_avenues_all.html'</span><span class=\"p\">,</span> <span class=\"n\">tiles</span><span class=\"o\">=</span><span class=\"s\">'cartodb_positron'</span><span class=\"p\">)</span></code></pre></figure>\n\n<iframe src=\"https://cdn.rawgit.com/brooksandrew/postman_problems_examples/master/50states/maps/state_avenues_all.html\" height=\"400\" width=\"750\"></iframe>\n\n<p>You can even customize with your favorite tiles.  For example:</p>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>mplleaflet.display(fig=ax.figure, tiles='stamen_wc')\n</code></pre></div></div>\n\n<p><img src=\"https://github.com/brooksandrew/postman_problems_examples/raw/master/50states/fig/stamen_wc_state_ave.jpeg\" width=\"700\" /></p>\n\n<p>…But there’s a wrinkle.  Zoom in on bigger avenues, like New York or Rhode Island, and you’ll notice that there are two parallel edges representing each direction as a separate one-way road.  This\nusually occurs when there are several lanes of traffic in each direction, or physical dividers between directions.  Example below:</p>\n\n<p>This is great for OSM and point A to B routing problems, but for the Rural Postman problem it imposes the requirement that each main avenue be cycled twice.  We’re not into that.</p>\n\n<p><strong>Example:</strong> Rhode Island Ave (parallel edges) vs Florida Ave (single edge)</p>\n\n<p><img src=\"https://github.com/brooksandrew/postman_problems_examples/raw/master/50states/fig/parallel_edge_ex.png\" alt=\"parallel_edge_ex\" /></p>\n\n<h2 id=\"3-remove-redundant-state-avenues\">3. Remove Redundant State Avenues</h2>\n\n<p>As it turns out, removing these parallel (redundant) edges is a nontrivial problem to solve.  My approach is the following:</p>\n<ol>\n  <li>Build graph with one-way state avenue edges only.</li>\n  <li>For each state avenue, create list of connected components that represent sequences of OSM ways in the same direction (broken up by intersections and turns).</li>\n  <li>Compute distance between each node in a component to every other node in the other candidate components.</li>\n  <li>Identify redundant components as those with the majority of their nodes below some threshold distance away from another component.</li>\n  <li>Build graph without redundant edges.</li>\n</ol>\n\n<h3 id=\"31-create-state-avenue-graph-with-one-way-edges-only\">3.1 Create state avenue graph with one-way edges only</h3>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"n\">g_st1</span> <span class=\"o\">=</span> <span class=\"n\">keep_oneway_edges_only</span><span class=\"p\">(</span><span class=\"n\">g_st</span><span class=\"p\">)</span></code></pre></figure>\n\n<p>The one-way avenues are plotted in red below.  A brief look indicates that 80-90% of the one-way avenues are parallel (redundant). A few, like Idaho Avenue NW and Ohio Drive SW, are single one-way\nroads with no accompanying parallel edge for us to remove.</p>\n\n<p>NOTE: you’ll need to zoom in 3-4 levels to see the parallel edges.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"n\">fig</span><span class=\"p\">,</span> <span class=\"n\">ax</span> <span class=\"o\">=</span> <span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">subplots</span><span class=\"p\">(</span><span class=\"n\">figsize</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">6</span><span class=\"p\">))</span>\n\n<span class=\"n\">pos</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"n\">k</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"n\">g_st1</span><span class=\"o\">.</span><span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">k</span><span class=\"p\">][</span><span class=\"s\">'lon'</span><span class=\"p\">],</span> <span class=\"n\">g_st1</span><span class=\"o\">.</span><span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">k</span><span class=\"p\">][</span><span class=\"s\">'lat'</span><span class=\"p\">])</span> <span class=\"k\">for</span> <span class=\"n\">k</span> <span class=\"ow\">in</span> <span class=\"n\">g_st1</span><span class=\"o\">.</span><span class=\"n\">nodes</span><span class=\"p\">()}</span>\n<span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">draw_networkx_edges</span><span class=\"p\">(</span><span class=\"n\">g_st1</span><span class=\"p\">,</span> <span class=\"n\">pos</span><span class=\"p\">,</span> <span class=\"n\">width</span><span class=\"o\">=</span><span class=\"mf\">3.0</span><span class=\"p\">,</span> <span class=\"n\">edge_color</span><span class=\"o\">=</span><span class=\"s\">'red'</span><span class=\"p\">,</span> <span class=\"n\">alpha</span><span class=\"o\">=</span><span class=\"mf\">0.7</span><span class=\"p\">)</span>\n\n<span class=\"c\"># save viz</span>\n<span class=\"n\">mplleaflet</span><span class=\"o\">.</span><span class=\"n\">save_html</span><span class=\"p\">(</span><span class=\"n\">fig</span><span class=\"p\">,</span> <span class=\"s\">'oneway_state_avenues.html'</span><span class=\"p\">,</span> <span class=\"n\">tiles</span><span class=\"o\">=</span><span class=\"s\">'cartodb_positron'</span><span class=\"p\">)</span></code></pre></figure>\n\n<iframe src=\"https://cdn.rawgit.com/brooksandrew/postman_problems_examples/master/50states/maps/oneway_state_avenues.html\" height=\"400\" width=\"750\"></iframe>\n\n<h4 id=\"create-connected-components-with-one-way-state-avenues\">Create connected components with one-way state avenues</h4>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"n\">comps</span> <span class=\"o\">=</span> <span class=\"n\">create_connected_components</span><span class=\"p\">(</span><span class=\"n\">g_st1</span><span class=\"p\">)</span></code></pre></figure>\n\n<p>There are 163 distinct components in the graph above.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">comps</span><span class=\"p\">)</span></code></pre></figure>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>163\n</code></pre></div></div>\n\n<h3 id=\"32-split-connected-components\">3.2 Split connected components</h3>\n\n<h4 id=\"remove-kinked-nodes\">Remove kinked nodes</h4>\n\n<p>However, we need to break some of these components up into smaller ones.  Many components, like the one below, have bends or a connected cycle that contain both the parallel edges, where we only want\none.  My approach is to identify the nodes with sharp angles and remove them.  I don’t know what the proper name for these is (you can read about <a href=\"https://en.wikipedia.org/wiki/Angular_resolution_(graph_drawing)\">angular resolution</a>), but we’ll call them “kinked\nnodes.”</p>\n\n<p>This will split the connected component below into two, allowing us to determine that one of them is redundant.</p>\n\n<p><img src=\"https://github.com/brooksandrew/postman_problems_examples/raw/master/50states/fig/kinked_node_ex.png\" alt=\"kinked_node_ex\" /></p>\n\n<p>I borrow <a href=\"https://gist.github.com/jeromer/2005586\">this code</a> from <code class=\"highlighter-rouge\">jeromer</code> to calculate the compass bearing (0 to 360) of each edge.  Wherever the the bearing difference between two adjacent edges is greater than\n<code class=\"highlighter-rouge\">bearing_thresh</code>, we call the node shared by both edges a “kinked node.”  A relative low <code class=\"highlighter-rouge\">bearing_thresh</code> of 60 appeared to work best after some experimentation.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"c\"># create list of comps (graphs) without kinked nodes</span>\n<span class=\"n\">comps_unkinked</span> <span class=\"o\">=</span> <span class=\"n\">create_unkinked_connected_components</span><span class=\"p\">(</span><span class=\"n\">comps</span><span class=\"o\">=</span><span class=\"n\">comps</span><span class=\"p\">,</span> <span class=\"n\">bearing_thresh</span><span class=\"o\">=</span><span class=\"mi\">60</span><span class=\"p\">)</span>\n\n<span class=\"c\"># comps in dict form for easy lookup</span>\n<span class=\"n\">comps_dict</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"n\">comp</span><span class=\"o\">.</span><span class=\"n\">graph</span><span class=\"p\">[</span><span class=\"s\">'id'</span><span class=\"p\">]:</span><span class=\"n\">comp</span> <span class=\"k\">for</span> <span class=\"n\">comp</span> <span class=\"ow\">in</span> <span class=\"n\">comps_unkinked</span><span class=\"p\">}</span> </code></pre></figure>\n\n<p>After removing these “kinked nodes,” our list of components grows from 163 to 246:</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">comps_unkinked</span><span class=\"p\">)</span></code></pre></figure>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>246\n</code></pre></div></div>\n\n<h4 id=\"viz-components-without-kinked-nodes\">Viz components without kinked nodes</h4>\n\n<p><strong>Example:</strong> Here’s the Massachusetts Ave example from above after we remove kinked nodes:</p>\n\n<p><img src=\"https://github.com/brooksandrew/postman_problems_examples/raw/master/50states/fig/unkinked_node_ex.png\" alt=\"unkinked_node_ex\" /></p>\n\n<p><strong>Full map:</strong> Zoom in on the map below and you’ll see that we split up most of the obvious components that should be.  There are a few corner cases that we miss, but I’d estimate we programmatically\nsplit about 95% of the components correctly.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"n\">fig</span><span class=\"p\">,</span> <span class=\"n\">ax</span> <span class=\"o\">=</span> <span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">subplots</span><span class=\"p\">(</span><span class=\"n\">figsize</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">6</span><span class=\"p\">))</span>\n\n<span class=\"k\">for</span> <span class=\"n\">comp</span> <span class=\"ow\">in</span> <span class=\"n\">comps_unkinked</span><span class=\"p\">:</span>\n    <span class=\"n\">pos</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"n\">k</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"n\">comp</span><span class=\"o\">.</span><span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">k</span><span class=\"p\">][</span><span class=\"s\">'lon'</span><span class=\"p\">],</span> <span class=\"n\">comp</span><span class=\"o\">.</span><span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">k</span><span class=\"p\">][</span><span class=\"s\">'lat'</span><span class=\"p\">])</span> <span class=\"k\">for</span> <span class=\"n\">k</span> <span class=\"ow\">in</span> <span class=\"n\">comp</span><span class=\"o\">.</span><span class=\"n\">nodes</span><span class=\"p\">()}</span>\n    <span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">draw_networkx_edges</span><span class=\"p\">(</span><span class=\"n\">comp</span><span class=\"p\">,</span> <span class=\"n\">pos</span><span class=\"p\">,</span> <span class=\"n\">width</span><span class=\"o\">=</span><span class=\"mf\">3.0</span><span class=\"p\">,</span> <span class=\"n\">edge_color</span><span class=\"o\">=</span><span class=\"s\">'orange'</span><span class=\"p\">,</span> <span class=\"n\">alpha</span><span class=\"o\">=</span><span class=\"mf\">0.7</span><span class=\"p\">)</span>\n    \n<span class=\"n\">mplleaflet</span><span class=\"o\">.</span><span class=\"n\">save_html</span><span class=\"p\">(</span><span class=\"n\">fig</span><span class=\"p\">,</span> <span class=\"s\">'oneway_state_avenues_without_kinked_nodes.html'</span><span class=\"p\">,</span> <span class=\"n\">tiles</span><span class=\"o\">=</span><span class=\"s\">'cartodb_positron'</span><span class=\"p\">)</span></code></pre></figure>\n\n<iframe src=\"https://cdn.rawgit.com/brooksandrew/postman_problems_examples/master/50states/maps/oneway_state_avenues_without_kinked_nodes.html\" height=\"500\" width=\"750\"></iframe>\n\n<h3 id=\"33--34-match-connected-components\">3.3 &amp; 3.4 Match connected components</h3>\n\n<p>Now that we’ve crafted the right components, we calculate how close (parallel) each component is to one another.</p>\n\n<p>This is a relatively coarse approach, but performs surprisingly well:</p>\n\n<p><strong>1.</strong> Find closest nodes from candidate components to each node in each component (pseudo code below):</p>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>  For each node N in component C:\n    For each C_cand in components with same street avenue as C:\n      Calculate closest node in C_cand to N.\n</code></pre></div></div>\n\n<p><strong>2.</strong> Calculate overlap between components.  Using the distances calculated in <strong>1.</strong>, we say that a node from component <code class=\"highlighter-rouge\">C</code> is matched to a component <code class=\"highlighter-rouge\">C_cand</code> if the distance is less than\n<code class=\"highlighter-rouge\">thresh_distance</code> specified in <code class=\"highlighter-rouge\">calculate_component_overlap</code>.  75 meters seemed to work pretty well.  Essentially we’re saying these nodes are close enough to be considered interchangeable.</p>\n\n<p><strong>3.</strong> Use the node-wise matching calculated in <strong>2.</strong> to calculate which components are redundant.  If <code class=\"highlighter-rouge\">thresh_pct</code> of nodes in component <code class=\"highlighter-rouge\">C</code> are close enough (within <code class=\"highlighter-rouge\">thresh_distance</code>) to nodes in\ncomponent <code class=\"highlighter-rouge\">C_cand</code>, we call <code class=\"highlighter-rouge\">C</code> redundant and discard it.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"c\"># caclulate nodewise distances between each node in comp with closest node in each candidate</span>\n<span class=\"n\">comp_matches</span> <span class=\"o\">=</span> <span class=\"n\">nodewise_distance_connected_components</span><span class=\"p\">(</span><span class=\"n\">comps_unkinked</span><span class=\"p\">)</span>\n\n<span class=\"c\"># calculate overlap between components</span>\n<span class=\"n\">comp_overlap</span> <span class=\"o\">=</span> <span class=\"n\">calculate_component_overlap</span><span class=\"p\">(</span><span class=\"n\">comp_matches</span><span class=\"p\">,</span> <span class=\"n\">thresh_distance</span><span class=\"o\">=</span><span class=\"mi\">75</span><span class=\"p\">)</span>\n\n<span class=\"c\"># identify redundant and non-redundant components</span>\n<span class=\"n\">remove_comp_ids</span><span class=\"p\">,</span> <span class=\"n\">keep_comp_ids</span> <span class=\"o\">=</span> <span class=\"n\">calculate_redundant_components</span><span class=\"p\">(</span><span class=\"n\">comp_overlap</span><span class=\"p\">,</span> <span class=\"n\">thresh_pct</span><span class=\"o\">=</span><span class=\"mf\">0.75</span><span class=\"p\">)</span></code></pre></figure>\n\n<h4 id=\"viz-redundant-component-solution\">Viz redundant component solution</h4>\n\n<p>The map below visualizes the solution to the redundant parallel edges problem.  There are some misses, but overall this simple approach works surprisingly well:</p>\n\n<ul>\n  <li><strong><font color=\"red\">red</font></strong>: redundant one-way edges to remove</li>\n  <li><strong><font color=\"black\">black</font></strong>: one-way edges to keep</li>\n  <li><strong><font color=\"blue\">blue</font></strong>: all state avenues</li>\n</ul>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"n\">fig</span><span class=\"p\">,</span> <span class=\"n\">ax</span> <span class=\"o\">=</span> <span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">subplots</span><span class=\"p\">(</span><span class=\"n\">figsize</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">8</span><span class=\"p\">))</span>\n\n<span class=\"c\"># plot redundant one-way edges</span>\n<span class=\"k\">for</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">road</span> <span class=\"ow\">in</span> <span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"n\">remove_comp_ids</span><span class=\"p\">):</span>\n    <span class=\"k\">for</span> <span class=\"n\">comp_id</span> <span class=\"ow\">in</span> <span class=\"n\">remove_comp_ids</span><span class=\"p\">[</span><span class=\"n\">road</span><span class=\"p\">]:</span>\n        <span class=\"n\">comp</span> <span class=\"o\">=</span> <span class=\"n\">comps_dict</span><span class=\"p\">[</span><span class=\"n\">comp_id</span><span class=\"p\">]</span>\n        <span class=\"n\">posc</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"n\">k</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"n\">comp</span><span class=\"o\">.</span><span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">k</span><span class=\"p\">][</span><span class=\"s\">'lon'</span><span class=\"p\">],</span> <span class=\"n\">comp</span><span class=\"o\">.</span><span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">k</span><span class=\"p\">][</span><span class=\"s\">'lat'</span><span class=\"p\">])</span> <span class=\"k\">for</span> <span class=\"n\">k</span> <span class=\"ow\">in</span> <span class=\"n\">comp</span><span class=\"o\">.</span><span class=\"n\">nodes</span><span class=\"p\">()}</span>\n        <span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">draw_networkx_edges</span><span class=\"p\">(</span><span class=\"n\">comp</span><span class=\"p\">,</span> <span class=\"n\">posc</span><span class=\"p\">,</span> <span class=\"n\">width</span><span class=\"o\">=</span><span class=\"mf\">7.0</span><span class=\"p\">,</span> <span class=\"n\">edge_color</span><span class=\"o\">=</span><span class=\"s\">'red'</span><span class=\"p\">)</span>\n\n<span class=\"c\"># plot keeper one-way edges </span>\n<span class=\"k\">for</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">road</span> <span class=\"ow\">in</span> <span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"n\">keep_comp_ids</span><span class=\"p\">):</span>\n    <span class=\"k\">for</span> <span class=\"n\">comp_id</span> <span class=\"ow\">in</span> <span class=\"n\">keep_comp_ids</span><span class=\"p\">[</span><span class=\"n\">road</span><span class=\"p\">]:</span>\n        <span class=\"n\">comp</span> <span class=\"o\">=</span> <span class=\"n\">comps_dict</span><span class=\"p\">[</span><span class=\"n\">comp_id</span><span class=\"p\">]</span>\n        <span class=\"n\">posc</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"n\">k</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"n\">comp</span><span class=\"o\">.</span><span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">k</span><span class=\"p\">][</span><span class=\"s\">'lon'</span><span class=\"p\">],</span> <span class=\"n\">comp</span><span class=\"o\">.</span><span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">k</span><span class=\"p\">][</span><span class=\"s\">'lat'</span><span class=\"p\">])</span> <span class=\"k\">for</span> <span class=\"n\">k</span> <span class=\"ow\">in</span> <span class=\"n\">comp</span><span class=\"o\">.</span><span class=\"n\">nodes</span><span class=\"p\">()}</span>\n        <span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">draw_networkx_edges</span><span class=\"p\">(</span><span class=\"n\">comp</span><span class=\"p\">,</span> <span class=\"n\">posc</span><span class=\"p\">,</span> <span class=\"n\">width</span><span class=\"o\">=</span><span class=\"mf\">3.0</span><span class=\"p\">,</span> <span class=\"n\">edge_color</span><span class=\"o\">=</span><span class=\"s\">'black'</span><span class=\"p\">)</span>\n\n<span class=\"c\"># plot all state avenues</span>\n<span class=\"n\">pos_st</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"n\">k</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"n\">g_st</span><span class=\"o\">.</span><span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">k</span><span class=\"p\">][</span><span class=\"s\">'lon'</span><span class=\"p\">],</span> <span class=\"n\">g_st</span><span class=\"o\">.</span><span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">k</span><span class=\"p\">][</span><span class=\"s\">'lat'</span><span class=\"p\">])</span> <span class=\"k\">for</span> <span class=\"n\">k</span> <span class=\"ow\">in</span> <span class=\"n\">g_st</span><span class=\"o\">.</span><span class=\"n\">nodes</span><span class=\"p\">()}</span>    \n<span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">draw_networkx_edges</span><span class=\"p\">(</span><span class=\"n\">g_st</span><span class=\"p\">,</span> <span class=\"n\">pos_st</span><span class=\"p\">,</span> <span class=\"n\">width</span><span class=\"o\">=</span><span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"n\">edge_color</span><span class=\"o\">=</span><span class=\"s\">'blue'</span><span class=\"p\">,</span> <span class=\"n\">alpha</span><span class=\"o\">=</span><span class=\"mf\">0.7</span><span class=\"p\">)</span>\n\n<span class=\"n\">mplleaflet</span><span class=\"o\">.</span><span class=\"n\">save_html</span><span class=\"p\">(</span><span class=\"n\">fig</span><span class=\"p\">,</span> <span class=\"s\">'redundant_edges.html'</span><span class=\"p\">,</span> <span class=\"n\">tiles</span><span class=\"o\">=</span><span class=\"s\">'cartodb_positron'</span><span class=\"p\">)</span></code></pre></figure>\n\n<iframe src=\"https://cdn.rawgit.com/brooksandrew/postman_problems_examples/master/50states/maps/redundant_edges.html\" height=\"500\" width=\"750\"></iframe>\n\n<h3 id=\"35-build-graph-without-redundant-edges\">3.5 Build graph without redundant edges</h3>\n\n<p>This is the essentially the graph with just <strong>black</strong> and <strong><font color=\"blue\">blue</font></strong> edges from the map above.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"c\"># create a single graph with deduped state roads</span>\n<span class=\"n\">g_st_nd</span> <span class=\"o\">=</span> <span class=\"n\">create_deduped_state_road_graph</span><span class=\"p\">(</span><span class=\"n\">g_st</span><span class=\"p\">,</span> <span class=\"n\">comps_dict</span><span class=\"p\">,</span> <span class=\"n\">remove_comp_ids</span><span class=\"p\">)</span></code></pre></figure>\n\n<p>After deduping the redundant edges, our connected component count drops from 246 to 96.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">connected_components</span><span class=\"p\">(</span><span class=\"n\">g_st_nd</span><span class=\"p\">)))</span></code></pre></figure>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>96\n</code></pre></div></div>\n\n<h2 id=\"4-create-single-connected-component\">4. Create Single Connected Component</h2>\n\n<p>The strategy I employ for solving the Rural Postman Problem (RPP) in <a href=\"https://github.com/brooksandrew/postman_problems\">postman_problems</a> is simple in that it reuses the machinery from the Chinese Postman Problem (CPP) solver <a href=\"https://github.com/brooksandrew/postman_problems/blob/master/postman_problems/solver.py#L14\">here</a>.\nHowever, it makes the strong assumption that the graph’s required edges form a single connected component.  This is obviously not true for our state avenue graph as-is, but it’s not too off.  Although\nthere are 96 components, there are only a couple more than a few hundred meters to the next closest component.</p>\n\n<p>So we hack it a bit by adding required edges to the graph to make it a single connected component.  The tricky part is choosing the edges that add as little distance as possible.  This was the first\ncomputationally intensive step that required some clever tricks and approximations to ensure execution in a reasonable amount of time.</p>\n\n<p>My approach:</p>\n\n<ol>\n  <li>\n    <p>Build graph with <a href=\"https://en.wikipedia.org/wiki/Edge_contraction\">contracted edges</a> only.</p>\n  </li>\n  <li>\n    <p>Calculate haversine distance between each possible pair of components.</p>\n  </li>\n  <li>\n    <p>Find minimum distance connectors: iterate through the data structure created in <strong>2.</strong> to calculate shortest paths for top candidates based on haversine distance and add shortest connectors to\ngraph.  More details below.</p>\n  </li>\n  <li>\n    <p>Build single component graph.</p>\n  </li>\n</ol>\n\n<h3 id=\"41-contract-edges\">4.1 Contract edges</h3>\n\n<p>Nodes with degree 2 are collapsed into an edge stretching from a dead-end node (degree 1) or intersection (degree &gt;= 3) to another.  This achieves two things:</p>\n<ul>\n  <li>Limits the number of distance calculations.</li>\n  <li>Ensures that components are connected at logical points (dead ends and intersections) rather than arbitrary parts of a roadway.  This will make for a more continuous route.</li>\n</ul>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"c\"># Create graph with contracted edges only</span>\n<span class=\"n\">g_st_contracted</span> <span class=\"o\">=</span> <span class=\"n\">create_contracted_edge_graph</span><span class=\"p\">(</span><span class=\"n\">graph</span><span class=\"o\">=</span><span class=\"n\">g_st_nd</span><span class=\"p\">,</span> \n                                               <span class=\"n\">edge_weight</span><span class=\"o\">=</span><span class=\"s\">'length'</span><span class=\"p\">)</span></code></pre></figure>\n\n<p>This significantly reduces the nodes needed for distances computations by a factor of &gt; 15.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s\">'Number of nodes in contracted graph: {}'</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">g_st_contracted</span><span class=\"o\">.</span><span class=\"n\">nodes</span><span class=\"p\">())))</span>\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s\">'Number of nodes in original graph: {}'</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">g_st_nd</span><span class=\"o\">.</span><span class=\"n\">nodes</span><span class=\"p\">())))</span></code></pre></figure>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Number of nodes in contracted graph: 347\nNumber of nodes in original graph: 5962\n</code></pre></div></div>\n\n<h3 id=\"42-calculate-haversine-distance-between-components\">4.2 Calculate haversine distance between components</h3>\n\n<p>The 345 nodes from the contracted edge graph translate to &gt;100,000 possible node pairings.  That means &gt;100,000 distance calculations.  While applying a shortest path algorithm over the graph would\ncertainly be more exact, it is painfully slow compared to simple haversine distance.  This is mainly due to the high number of nodes and edges in the DC OSM map (over 250k edges).</p>\n\n<p>On my laptop I averaged about 4 shortest path calculations per second.  Not too bad for a handful, but 115k would take about 7 hours.  Haversine distance, by comparison, churns through 115k in a\ncouple seconds.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"c\"># create dataframe with shortest paths (haversine distance) between each component</span>\n<span class=\"n\">dfsp</span> <span class=\"o\">=</span> <span class=\"n\">shortest_paths_between_components</span><span class=\"p\">(</span><span class=\"n\">g_st_contracted</span><span class=\"p\">)</span></code></pre></figure>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"n\">dfsp</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>  <span class=\"c\"># number of rows (node pairs)</span></code></pre></figure>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>116526\n</code></pre></div></div>\n\n<h3 id=\"43-find-minimum-distance-connectors\">4.3 Find minimum distance connectors</h3>\n\n<p>This gets a bit tricky.  Basically we iterate through the top (closest) candidate pairs of components and connect them iteration-by-iteration with the shortest path edge.  We use pre-calculated\nhaversine distance to get in the right ballpark, then refine with true shortest path for the closest 20 candidates.  This helps us avoid the scenario where we naively connect two nodes that are\ngeographically close as the crow flies (haversine), but far away via available roads.  Two nodes separated by highways or train tracks, for example.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"c\"># min weight edges that create a single connected component</span>\n<span class=\"n\">connector_edges</span> <span class=\"o\">=</span> <span class=\"n\">find_minimum_weight_edges_to_connect_components</span><span class=\"p\">(</span><span class=\"n\">dfsp</span><span class=\"o\">=</span><span class=\"n\">dfsp</span><span class=\"p\">,</span> \n                                                                  <span class=\"n\">graph</span><span class=\"o\">=</span><span class=\"n\">g_ud</span><span class=\"p\">,</span> \n                                                                  <span class=\"n\">edge_weight</span><span class=\"o\">=</span><span class=\"s\">'length'</span><span class=\"p\">,</span> \n                                                                  <span class=\"n\">top</span><span class=\"o\">=</span><span class=\"mi\">20</span><span class=\"p\">)</span></code></pre></figure>\n\n<p>We had 96 components to connect, so it makes sense that we have 95 connectors.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">connector_edges</span><span class=\"p\">)</span></code></pre></figure>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>95\n</code></pre></div></div>\n\n<h3 id=\"44-build-single-component-graph\">4.4 Build single component graph</h3>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"c\"># adding connector edges to create one single connected component</span>\n<span class=\"k\">for</span> <span class=\"n\">e</span> <span class=\"ow\">in</span> <span class=\"n\">connector_edges</span><span class=\"p\">:</span>\n    <span class=\"n\">g_st_contracted</span><span class=\"o\">.</span><span class=\"n\">add_edge</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">distance</span><span class=\"o\">=</span><span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">][</span><span class=\"s\">'distance'</span><span class=\"p\">],</span> <span class=\"n\">path</span><span class=\"o\">=</span><span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">][</span><span class=\"s\">'path'</span><span class=\"p\">],</span> <span class=\"n\">required</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">connector</span><span class=\"o\">=</span><span class=\"bp\">True</span><span class=\"p\">)</span></code></pre></figure>\n\n<p>We add about 12 miles with the 95 additional required edges.  That’s not too bad: an average distance of 0.13 miles per each edge added.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"k\">print</span><span class=\"p\">(</span><span class=\"nb\">sum</span><span class=\"p\">([</span><span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">][</span><span class=\"s\">'distance'</span><span class=\"p\">]</span> <span class=\"k\">for</span> <span class=\"n\">e</span> <span class=\"ow\">in</span> <span class=\"n\">g_st_contracted</span><span class=\"o\">.</span><span class=\"n\">edges</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"o\">=</span><span class=\"bp\">True</span><span class=\"p\">)</span> <span class=\"k\">if</span> <span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s\">'connector'</span><span class=\"p\">)])</span><span class=\"o\">/</span><span class=\"mf\">1609.34</span><span class=\"p\">)</span></code></pre></figure>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>12.341087779659958\n</code></pre></div></div>\n\n<p>So that leaves us with a single component of 125 miles of required edges to optimize a route through.  That means the distance of deduped state avenues alone, without connectors (~112 miles) is just a\ncouple miles away from what <a href=\"https://en.wikipedia.org/wiki/List_of_state-named_roadways_in_Washington,_D.C.\">Wikipedia reports</a> (115 miles).</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"k\">print</span><span class=\"p\">(</span><span class=\"nb\">sum</span><span class=\"p\">([</span><span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">][</span><span class=\"s\">'distance'</span><span class=\"p\">]</span> <span class=\"k\">for</span> <span class=\"n\">e</span> <span class=\"ow\">in</span> <span class=\"n\">g_st_contracted</span><span class=\"o\">.</span><span class=\"n\">edges</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"o\">=</span><span class=\"bp\">True</span><span class=\"p\">)])</span><span class=\"o\">/</span><span class=\"mf\">1609.34</span><span class=\"p\">)</span></code></pre></figure>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>125.06645388481837\n</code></pre></div></div>\n\n<p>Make graph with granular edges (filling in those that were contracted) connecting components:</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"n\">g1comp</span> <span class=\"o\">=</span> <span class=\"n\">g_st_contracted</span><span class=\"o\">.</span><span class=\"n\">copy</span><span class=\"p\">()</span>\n<span class=\"k\">for</span> <span class=\"n\">e</span> <span class=\"ow\">in</span> <span class=\"n\">g_st_contracted</span><span class=\"o\">.</span><span class=\"n\">edges</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"o\">=</span><span class=\"bp\">True</span><span class=\"p\">):</span>\n    <span class=\"k\">if</span> <span class=\"s\">'path'</span> <span class=\"ow\">in</span> <span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]:</span>\n        <span class=\"n\">granular_type</span> <span class=\"o\">=</span> <span class=\"s\">'connector'</span> <span class=\"k\">if</span> <span class=\"s\">'connector'</span> <span class=\"ow\">in</span> <span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"k\">else</span> <span class=\"s\">'state'</span>\n        \n        <span class=\"c\"># add granular connector edges to graph </span>\n        <span class=\"k\">for</span> <span class=\"n\">pair</span> <span class=\"ow\">in</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"nb\">zip</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">][</span><span class=\"s\">'path'</span><span class=\"p\">][:</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">][</span><span class=\"s\">'path'</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">:])):</span>\n            <span class=\"n\">g1comp</span><span class=\"o\">.</span><span class=\"n\">add_edge</span><span class=\"p\">(</span><span class=\"n\">pair</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">pair</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">granular</span><span class=\"o\">=</span><span class=\"s\">'True'</span><span class=\"p\">,</span> <span class=\"n\">granular_type</span><span class=\"o\">=</span><span class=\"n\">granular_type</span><span class=\"p\">)</span>\n            \n        <span class=\"c\"># add granular connector nodes to graph</span>\n        <span class=\"k\">for</span> <span class=\"n\">n</span> <span class=\"ow\">in</span> <span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">][</span><span class=\"s\">'path'</span><span class=\"p\">]:</span>\n            <span class=\"n\">g1comp</span><span class=\"o\">.</span><span class=\"n\">add_node</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">lat</span><span class=\"o\">=</span><span class=\"n\">g</span><span class=\"o\">.</span><span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">n</span><span class=\"p\">][</span><span class=\"s\">'lat'</span><span class=\"p\">],</span> <span class=\"n\">lon</span><span class=\"o\">=</span><span class=\"n\">g</span><span class=\"o\">.</span><span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">n</span><span class=\"p\">][</span><span class=\"s\">'lon'</span><span class=\"p\">])</span></code></pre></figure>\n\n<h3 id=\"45-viz-single-connected-component\">4.5 Viz single connected component</h3>\n\n<p><strong>Black</strong> edges represent the deduped state avenues.\n<strong><font color=\"red\">Red</font></strong> edges represent the 12 miles of connectors that create the single connected component.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"n\">fig</span><span class=\"p\">,</span> <span class=\"n\">ax</span> <span class=\"o\">=</span> <span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">subplots</span><span class=\"p\">(</span><span class=\"n\">figsize</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">6</span><span class=\"p\">))</span>\n\n<span class=\"n\">g1comp_conn</span> <span class=\"o\">=</span> <span class=\"n\">g1comp</span><span class=\"o\">.</span><span class=\"n\">copy</span><span class=\"p\">()</span>\n<span class=\"n\">g1comp_st</span> <span class=\"o\">=</span> <span class=\"n\">g1comp</span><span class=\"o\">.</span><span class=\"n\">copy</span><span class=\"p\">()</span>\n\n<span class=\"k\">for</span> <span class=\"n\">e</span> <span class=\"ow\">in</span> <span class=\"n\">g1comp</span><span class=\"o\">.</span><span class=\"n\">edges</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"o\">=</span><span class=\"bp\">True</span><span class=\"p\">):</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"s\">'granular_type'</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">])</span> <span class=\"ow\">or</span> <span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">][</span><span class=\"s\">'granular_type'</span><span class=\"p\">]</span> <span class=\"o\">!=</span> <span class=\"s\">'connector'</span><span class=\"p\">):</span>\n        <span class=\"n\">g1comp_conn</span><span class=\"o\">.</span><span class=\"n\">remove_edge</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">])</span>\n\n<span class=\"k\">for</span> <span class=\"n\">e</span> <span class=\"ow\">in</span> <span class=\"n\">g1comp</span><span class=\"o\">.</span><span class=\"n\">edges</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"o\">=</span><span class=\"bp\">True</span><span class=\"p\">):</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"s\">'granular_type'</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">])</span> <span class=\"ow\">or</span> <span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">][</span><span class=\"s\">'granular_type'</span><span class=\"p\">]</span> <span class=\"o\">!=</span> <span class=\"s\">'state'</span><span class=\"p\">):</span>\n        <span class=\"n\">g1comp_st</span><span class=\"o\">.</span><span class=\"n\">remove_edge</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">])</span>\n    \n<span class=\"n\">pos</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"n\">k</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"n\">g1comp_conn</span><span class=\"o\">.</span><span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">k</span><span class=\"p\">][</span><span class=\"s\">'lon'</span><span class=\"p\">],</span> <span class=\"n\">g1comp_conn</span><span class=\"o\">.</span><span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">k</span><span class=\"p\">][</span><span class=\"s\">'lat'</span><span class=\"p\">])</span> <span class=\"k\">for</span> <span class=\"n\">k</span> <span class=\"ow\">in</span> <span class=\"n\">g1comp_conn</span><span class=\"o\">.</span><span class=\"n\">nodes</span><span class=\"p\">()}</span>    \n<span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">draw_networkx_edges</span><span class=\"p\">(</span><span class=\"n\">g1comp_conn</span><span class=\"p\">,</span> <span class=\"n\">pos</span><span class=\"p\">,</span> <span class=\"n\">width</span><span class=\"o\">=</span><span class=\"mf\">5.0</span><span class=\"p\">,</span> <span class=\"n\">edge_color</span><span class=\"o\">=</span><span class=\"s\">'red'</span><span class=\"p\">)</span>\n\n<span class=\"n\">pos_st</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"n\">k</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"n\">g1comp_st</span><span class=\"o\">.</span><span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">k</span><span class=\"p\">][</span><span class=\"s\">'lon'</span><span class=\"p\">],</span> <span class=\"n\">g1comp_st</span><span class=\"o\">.</span><span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">k</span><span class=\"p\">][</span><span class=\"s\">'lat'</span><span class=\"p\">])</span> <span class=\"k\">for</span> <span class=\"n\">k</span> <span class=\"ow\">in</span> <span class=\"n\">g1comp_st</span><span class=\"o\">.</span><span class=\"n\">nodes</span><span class=\"p\">()}</span>    \n<span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">draw_networkx_edges</span><span class=\"p\">(</span><span class=\"n\">g1comp_st</span><span class=\"p\">,</span> <span class=\"n\">pos_st</span><span class=\"p\">,</span> <span class=\"n\">width</span><span class=\"o\">=</span><span class=\"mf\">3.0</span><span class=\"p\">,</span> <span class=\"n\">edge_color</span><span class=\"o\">=</span><span class=\"s\">'black'</span><span class=\"p\">)</span>\n\n<span class=\"c\"># save viz</span>\n<span class=\"n\">mplleaflet</span><span class=\"o\">.</span><span class=\"n\">save_html</span><span class=\"p\">(</span><span class=\"n\">fig</span><span class=\"p\">,</span> <span class=\"s\">'single_connected_comp.html'</span><span class=\"p\">,</span> <span class=\"n\">tiles</span><span class=\"o\">=</span><span class=\"s\">'cartodb_positron'</span><span class=\"p\">)</span></code></pre></figure>\n\n<iframe src=\"https://cdn.rawgit.com/brooksandrew/postman_problems_examples/master/50states/maps/single_connected_comp.html\" height=\"500\" width=\"750\"></iframe>\n\n<h2 id=\"5-solve-cpp\">5. Solve CPP</h2>\n\n<p>I don’t expect the Chinese Postman solution to be optimal since it only utilizes the required edges.  However, I do expect it to execute quickly and serve as a benchmark for the Rural Postman\nsolution.  In the age of “deep learning,” I agree with Smerity, <a href=\"http://smerity.com/articles/2017/baselines_need_love.html\">baselines need more love</a>.</p>\n\n<h3 id=\"51-create-cpp-edgelist\">5.1 Create CPP edgelist</h3>\n\n<p>The <a href=\"https://github.com/brooksandrew/postman_problems/blob/master/postman_problems/solver.py#L65\">cpp solver</a> I wrote operates off an edgelist (text file).  This feels a bit clunky here, but it works.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"c\"># create list with edge attributes and \"from\" &amp; \"to\" nodes</span>\n<span class=\"n\">tmp</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n<span class=\"k\">for</span> <span class=\"n\">e</span> <span class=\"ow\">in</span> <span class=\"n\">g_st_contracted</span><span class=\"o\">.</span><span class=\"n\">edges</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"o\">=</span><span class=\"bp\">True</span><span class=\"p\">):</span>\n    <span class=\"n\">tmpi</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">copy</span><span class=\"p\">()</span>  <span class=\"c\"># so we don't mess w original graph</span>\n    <span class=\"n\">tmpi</span><span class=\"p\">[</span><span class=\"s\">'start_node'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n    <span class=\"n\">tmpi</span><span class=\"p\">[</span><span class=\"s\">'end_node'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n    <span class=\"n\">tmp</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">tmpi</span><span class=\"p\">)</span>\n\n<span class=\"c\"># create dataframe w node1 and node2 in order</span>\n<span class=\"n\">eldf</span> <span class=\"o\">=</span> <span class=\"n\">pd</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">(</span><span class=\"n\">tmp</span><span class=\"p\">)</span>   \n<span class=\"n\">eldf</span> <span class=\"o\">=</span> <span class=\"n\">eldf</span><span class=\"p\">[[</span><span class=\"s\">'start_node'</span><span class=\"p\">,</span> <span class=\"s\">'end_node'</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"nb\">set</span><span class=\"p\">(</span><span class=\"n\">eldf</span><span class=\"o\">.</span><span class=\"n\">columns</span><span class=\"p\">)</span><span class=\"o\">-</span><span class=\"p\">{</span><span class=\"s\">'start_node'</span><span class=\"p\">,</span> <span class=\"s\">'end_node'</span><span class=\"p\">})]</span></code></pre></figure>\n\n<p>The first two columns are interpeted as the <em>from</em> and <em>to</em> nodes; everything else as edge attributes.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"n\">eldf</span><span class=\"o\">.</span><span class=\"n\">head</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)</span></code></pre></figure>\n\n<div>\n<style scoped=\"\">\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>start_node</th>\n      <th>end_node</th>\n      <th>comp</th>\n      <th>name</th>\n      <th>connector</th>\n      <th>path</th>\n      <th>distance</th>\n      <th>required</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>3788079770</td>\n      <td>649840206</td>\n      <td>0.0</td>\n      <td>Texas Avenue Southeast</td>\n      <td>NaN</td>\n      <td>[649840206, 649840209, 649840220, 30100500, 64...</td>\n      <td>1244.893849</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>3788079770</td>\n      <td>49744479</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>True</td>\n      <td>[3788079770, 49751669, 4630443674, 49751671, 4...</td>\n      <td>674.458290</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>49765126</td>\n      <td>49765287</td>\n      <td>1.0</td>\n      <td>Georgia Avenue Northwest</td>\n      <td>NaN</td>\n      <td>[49765126, 49765129, 49765130, 49765131, 49765...</td>\n      <td>559.251509</td>\n      <td>1</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n\n<h3 id=\"52-cpp-solver\">5.2 CPP solver</h3>\n\n<h4 id=\"starting-point\">Starting point</h4>\n\n<p>I fix the starting node for the solution to OSM node <code class=\"highlighter-rouge\">49765113</code> which corresponds to (<strong>38.917002</strong>, <strong>-77.0364987</strong>): the intersection of New Hampshire Avenue NW, 16th St NW and U St NW…  and also\nthe close to my house:</p>\n\n<p><img src=\"https://github.com/brooksandrew/postman_problems_examples/raw/master/50states/fig/start_node_map.png\" alt=\"start_node_map\" /></p>\n\n<h4 id=\"solve\">Solve</h4>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"c\"># create mockfilename</span>\n<span class=\"n\">elfn</span> <span class=\"o\">=</span> <span class=\"n\">create_mock_csv_from_dataframe</span><span class=\"p\">(</span><span class=\"n\">eldf</span><span class=\"p\">)</span>\n\n<span class=\"c\"># solve</span>\n<span class=\"n\">START_NODE</span> <span class=\"o\">=</span> <span class=\"s\">'49765113'</span>  <span class=\"c\"># New Hampshire Ave NW &amp; U St NW.</span>\n<span class=\"n\">circuit_cpp</span><span class=\"p\">,</span> <span class=\"n\">gcpp</span> <span class=\"o\">=</span> <span class=\"n\">cpp</span><span class=\"p\">(</span><span class=\"n\">elfn</span><span class=\"p\">,</span> <span class=\"n\">start_node</span><span class=\"o\">=</span><span class=\"n\">START_NODE</span><span class=\"p\">)</span></code></pre></figure>\n\n<h3 id=\"53-cpp-results\">5.3: CPP results</h3>\n\n<p>The CPP solution covers roughly 390,000 meters, about <strong>242 miles</strong>.\nThe optimal CPP route doubles the required distance, doublebacking every edge on average… definitely not ideal.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"c\"># circuit stats</span>\n<span class=\"n\">calculate_postman_solution_stats</span><span class=\"p\">(</span><span class=\"n\">circuit_cpp</span><span class=\"p\">)</span></code></pre></figure>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>OrderedDict([('distance_walked', 391523.723281576),\n             ('distance_doublebacked', 190249.27638658223),\n             ('distance_walked_once', 201274.44689499377),\n             ('distance_walked_optional', 0),\n             ('distance_walked_required', 391523.723281576),\n             ('edges_walked', 688),\n             ('edges_doublebacked', 337),\n             ('edges_walked_once', 351),\n             ('edges_walked_optional', 0),\n             ('edges_walked_required', 688)])\n</code></pre></div></div>\n\n<h2 id=\"6-solve-rpp\">6. Solve RPP</h2>\n\n<p>The RPP should improve the CPP solution as it considers optional edges that can drastically limit the amount of doublebacking.</p>\n\n<p>We could add every possible edge that connects the required nodes, but it turns out that computation blows up quickly, and I’m not that patient.  The <code class=\"highlighter-rouge\">get_shortest_paths_distances</code> is the bottleneck\napplying dijkstra path length on all possible combinations.  There are ~14k pairs to calculate shortest path for (4 per second) which would take almost one hour.</p>\n\n<p>However, we can use some heuristics to speed this up dramatically without sacrificing too much.</p>\n\n<h3 id=\"61-create-rpp-edgelist\">6.1 Create RPP edgelist</h3>\n\n<p>Ideally optional edges will be relatively short, since they are, well, optional.  It is unlikely that the RPP algorithm will find that leveraging an optional edge that stretches from one corner of the\ngraph to another will be efficient.  Thus we constrain the set of optional edges presented to the RPP solver to include only those less than <code class=\"highlighter-rouge\">max_distance</code>.</p>\n\n<p>I experimented with several thresholds.  3200 meters certainly took longer (~40 minutes), but yielded the best route results.  I tried 4000m which ran for about 4 hours and returned a route with the\nsame distance (160 miles) as the 3200m threshold.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"o\">%%</span><span class=\"n\">time</span>\n<span class=\"n\">dfrpp</span> <span class=\"o\">=</span> <span class=\"n\">create_rpp_edgelist</span><span class=\"p\">(</span><span class=\"n\">g_st_contracted</span><span class=\"o\">=</span><span class=\"n\">g_st_contracted</span><span class=\"p\">,</span> \n                            <span class=\"n\">graph_full</span><span class=\"o\">=</span><span class=\"n\">g_ud</span><span class=\"p\">,</span> \n                            <span class=\"n\">edge_weight</span><span class=\"o\">=</span><span class=\"s\">'length'</span><span class=\"p\">,</span> \n                            <span class=\"n\">max_distance</span><span class=\"o\">=</span><span class=\"mi\">3200</span><span class=\"p\">)</span></code></pre></figure>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>CPU times: user 34min 38s, sys: 20.5 s, total: 34min 59s\nWall time: 36min 3s\n</code></pre></div></div>\n\n<p>Check how many optional edges are considered (0=optional, 1=required):</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"n\">Counter</span><span class=\"p\">(</span><span class=\"n\">dfrpp</span><span class=\"p\">[</span><span class=\"s\">'required'</span><span class=\"p\">])</span></code></pre></figure>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Counter({0: 16021, 1: 351})\n</code></pre></div></div>\n\n<h3 id=\"62-rpp-solver\">6.2 RPP solver</h3>\n\n<p>Apply the RPP solver to the processed dataset.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"o\">%%</span><span class=\"n\">time</span>\n\n<span class=\"c\"># create mockfilename</span>\n<span class=\"n\">elfn</span> <span class=\"o\">=</span> <span class=\"n\">create_mock_csv_from_dataframe</span><span class=\"p\">(</span><span class=\"n\">dfrpp</span><span class=\"p\">)</span>\n\n<span class=\"c\"># solve</span>\n<span class=\"n\">circuit_rpp</span><span class=\"p\">,</span> <span class=\"n\">grpp</span> <span class=\"o\">=</span> <span class=\"n\">rpp</span><span class=\"p\">(</span><span class=\"n\">elfn</span><span class=\"p\">,</span> <span class=\"n\">start_node</span><span class=\"o\">=</span><span class=\"n\">START_NODE</span><span class=\"p\">)</span></code></pre></figure>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>CPU times: user 7min 25s, sys: 1.68 s, total: 7min 27s\nWall time: 7min 31s\n</code></pre></div></div>\n\n<h3 id=\"63-rpp-results\">6.3 RPP results</h3>\n\n<p>As expected, the RPP route is considerably shorter than the CPP solution.  The <strong>~242</strong> mile CPP route is cut significantly to <strong>~160</strong> with the RPP approach.</p>\n\n<p>~26,000m (~161 miles) in total with ~59,000m (37 miles) of doublebacking.  Not bad… but probably a 2-day ride.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"c\"># RPP route distance (miles)</span>\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"nb\">sum</span><span class=\"p\">([</span><span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">][</span><span class=\"s\">'distance'</span><span class=\"p\">]</span> <span class=\"k\">for</span> <span class=\"n\">e</span> <span class=\"ow\">in</span> <span class=\"n\">circuit_rpp</span><span class=\"p\">])</span><span class=\"o\">/</span><span class=\"mf\">1609.34</span><span class=\"p\">)</span></code></pre></figure>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>161.58546891004886\n</code></pre></div></div>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"c\"># hack to convert 'path' from str back to list.  Caused by `create_mock_csv_from_dataframe`</span>\n<span class=\"k\">for</span> <span class=\"n\">e</span> <span class=\"ow\">in</span> <span class=\"n\">circuit_rpp</span><span class=\"p\">:</span>\n    <span class=\"k\">if</span> <span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">][</span><span class=\"s\">'path'</span><span class=\"p\">])</span> <span class=\"o\">==</span> <span class=\"nb\">str</span><span class=\"p\">:</span>\n        <span class=\"k\">exec</span><span class=\"p\">(</span><span class=\"s\">'e[3][\"path\"]='</span> <span class=\"o\">+</span> <span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">][</span><span class=\"s\">\"path\"</span><span class=\"p\">])</span></code></pre></figure>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"n\">calculate_postman_solution_stats</span><span class=\"p\">(</span><span class=\"n\">circuit_rpp</span><span class=\"p\">)</span></code></pre></figure>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>OrderedDict([('distance_walked', 260045.958535698),\n             ('distance_doublebacked', 58771.511640704295),\n             ('distance_walked_once', 201274.4468949937),\n             ('distance_walked_optional', 51891.485571184385),\n             ('distance_walked_required', 208154.47296451364),\n             ('edges_walked', 447),\n             ('edges_doublebacked', 96),\n             ('edges_walked_once', 351),\n             ('edges_walked_optional', 57),\n             ('edges_walked_required', 390)])\n</code></pre></div></div>\n\n<p>As seen below, filling the contracted edges back in with the granular nodes adds considerably to the edge count.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s\">'Number of edges in RPP circuit (with contracted edges): {}'</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">circuit_rpp</span><span class=\"p\">)))</span>\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s\">'Number of edges in RPP circuit (with granular edges): {}'</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">rppdf</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]))</span></code></pre></figure>\n\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Number of edges in RPP circuit (with contracted edges): 447\nNumber of edges in RPP circuit (with granular edges): 9081\n</code></pre></div></div>\n\n<h3 id=\"64-viz-rpp-graph\">6.4 Viz RPP graph</h3>\n\n<h4 id=\"create-rpp-granular-graph\">Create RPP granular graph</h4>\n\n<p>Add the granular edges (that we contracted for computation) back to the graph.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"c\"># calc shortest path between optional nodes and add to g1comp graph</span>\n<span class=\"k\">for</span> <span class=\"n\">e</span> <span class=\"ow\">in</span> <span class=\"p\">[</span><span class=\"n\">e</span> <span class=\"k\">for</span> <span class=\"n\">e</span> <span class=\"ow\">in</span> <span class=\"n\">circuit_rpp</span> <span class=\"k\">if</span> <span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">][</span><span class=\"s\">'required'</span><span class=\"p\">]</span><span class=\"o\">==</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"p\">:</span>\n    \n    <span class=\"c\"># add granular optional edges to g1comp</span>\n    <span class=\"n\">path</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">][</span><span class=\"s\">'path'</span><span class=\"p\">]</span>\n    <span class=\"k\">for</span> <span class=\"n\">pair</span> <span class=\"ow\">in</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"nb\">zip</span><span class=\"p\">(</span><span class=\"n\">path</span><span class=\"p\">[:</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">path</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">:])):</span>\n        <span class=\"k\">if</span> <span class=\"n\">g1comp</span><span class=\"o\">.</span><span class=\"n\">has_edge</span><span class=\"p\">(</span><span class=\"n\">pair</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">pair</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]):</span>\n            <span class=\"k\">continue</span>\n        <span class=\"n\">g1comp</span><span class=\"o\">.</span><span class=\"n\">add_edge</span><span class=\"p\">(</span><span class=\"n\">pair</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">pair</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">granular</span><span class=\"o\">=</span><span class=\"s\">'True'</span><span class=\"p\">,</span> <span class=\"n\">granular_type</span><span class=\"o\">=</span><span class=\"s\">'optional'</span><span class=\"p\">)</span>\n    \n    <span class=\"c\"># add granular nodes from optional edge paths to g1comp</span>\n    <span class=\"k\">for</span> <span class=\"n\">n</span> <span class=\"ow\">in</span> <span class=\"n\">path</span><span class=\"p\">:</span>\n        <span class=\"n\">g1comp</span><span class=\"o\">.</span><span class=\"n\">add_node</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">lat</span><span class=\"o\">=</span><span class=\"n\">g</span><span class=\"o\">.</span><span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">n</span><span class=\"p\">][</span><span class=\"s\">'lat'</span><span class=\"p\">],</span> <span class=\"n\">lon</span><span class=\"o\">=</span><span class=\"n\">g</span><span class=\"o\">.</span><span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">n</span><span class=\"p\">][</span><span class=\"s\">'lon'</span><span class=\"p\">])</span></code></pre></figure>\n\n<h4 id=\"visualize-rpp-solution-by-edge-type\">Visualize RPP solution by edge type</h4>\n\n<ul>\n  <li><strong><font color=\"black\">black</font></strong>: required state avenue edges</li>\n  <li><strong><font color=\"red\">red</font></strong>: required non-state avenue edges added to form single component</li>\n  <li><strong><font color=\"blue\">blue</font></strong>: optional non-state avenue roads</li>\n</ul>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"n\">fig</span><span class=\"p\">,</span> <span class=\"n\">ax</span> <span class=\"o\">=</span> <span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">subplots</span><span class=\"p\">(</span><span class=\"n\">figsize</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">12</span><span class=\"p\">))</span>\n\n<span class=\"n\">g1comp_conn</span> <span class=\"o\">=</span> <span class=\"n\">g1comp</span><span class=\"o\">.</span><span class=\"n\">copy</span><span class=\"p\">()</span>\n<span class=\"n\">g1comp_st</span> <span class=\"o\">=</span> <span class=\"n\">g1comp</span><span class=\"o\">.</span><span class=\"n\">copy</span><span class=\"p\">()</span>\n<span class=\"n\">g1comp_opt</span> <span class=\"o\">=</span> <span class=\"n\">g1comp</span><span class=\"o\">.</span><span class=\"n\">copy</span><span class=\"p\">()</span>\n\n<span class=\"k\">for</span> <span class=\"n\">e</span> <span class=\"ow\">in</span> <span class=\"n\">g1comp</span><span class=\"o\">.</span><span class=\"n\">edges</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"o\">=</span><span class=\"bp\">True</span><span class=\"p\">):</span>\n    <span class=\"k\">if</span> <span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s\">'granular_type'</span><span class=\"p\">)</span> <span class=\"o\">!=</span> <span class=\"s\">'connector'</span><span class=\"p\">:</span>\n        <span class=\"n\">g1comp_conn</span><span class=\"o\">.</span><span class=\"n\">remove_edge</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">])</span>\n\n<span class=\"k\">for</span> <span class=\"n\">e</span> <span class=\"ow\">in</span> <span class=\"n\">g1comp</span><span class=\"o\">.</span><span class=\"n\">edges</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"o\">=</span><span class=\"bp\">True</span><span class=\"p\">):</span>\n    <span class=\"c\">#if e[2].get('name') not in candidate_state_avenue_names:</span>\n    <span class=\"k\">if</span> <span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s\">'granular_type'</span><span class=\"p\">)</span> <span class=\"o\">!=</span> <span class=\"s\">'state'</span><span class=\"p\">:</span>\n        <span class=\"n\">g1comp_st</span><span class=\"o\">.</span><span class=\"n\">remove_edge</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">])</span>\n\n<span class=\"k\">for</span> <span class=\"n\">e</span> <span class=\"ow\">in</span> <span class=\"n\">g1comp</span><span class=\"o\">.</span><span class=\"n\">edges</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"o\">=</span><span class=\"bp\">True</span><span class=\"p\">):</span>\n    <span class=\"k\">if</span> <span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s\">'granular_type'</span><span class=\"p\">)</span> <span class=\"o\">!=</span> <span class=\"s\">'optional'</span><span class=\"p\">:</span>\n        <span class=\"n\">g1comp_opt</span><span class=\"o\">.</span><span class=\"n\">remove_edge</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">])</span>\n\n        \n<span class=\"n\">pos</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"n\">k</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"n\">g1comp_conn</span><span class=\"o\">.</span><span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">k</span><span class=\"p\">][</span><span class=\"s\">'lon'</span><span class=\"p\">],</span> <span class=\"n\">g1comp_conn</span><span class=\"o\">.</span><span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">k</span><span class=\"p\">][</span><span class=\"s\">'lat'</span><span class=\"p\">])</span> <span class=\"k\">for</span> <span class=\"n\">k</span> <span class=\"ow\">in</span> <span class=\"n\">g1comp_conn</span><span class=\"o\">.</span><span class=\"n\">nodes</span><span class=\"p\">()}</span>    \n<span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">draw_networkx_edges</span><span class=\"p\">(</span><span class=\"n\">g1comp_conn</span><span class=\"p\">,</span> <span class=\"n\">pos</span><span class=\"p\">,</span> <span class=\"n\">width</span><span class=\"o\">=</span><span class=\"mf\">6.0</span><span class=\"p\">,</span> <span class=\"n\">edge_color</span><span class=\"o\">=</span><span class=\"s\">'red'</span><span class=\"p\">)</span>\n\n<span class=\"n\">pos_st</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"n\">k</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"n\">g1comp_st</span><span class=\"o\">.</span><span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">k</span><span class=\"p\">][</span><span class=\"s\">'lon'</span><span class=\"p\">],</span> <span class=\"n\">g1comp_st</span><span class=\"o\">.</span><span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">k</span><span class=\"p\">][</span><span class=\"s\">'lat'</span><span class=\"p\">])</span> <span class=\"k\">for</span> <span class=\"n\">k</span> <span class=\"ow\">in</span> <span class=\"n\">g1comp_st</span><span class=\"o\">.</span><span class=\"n\">nodes</span><span class=\"p\">()}</span>    \n<span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">draw_networkx_edges</span><span class=\"p\">(</span><span class=\"n\">g1comp_st</span><span class=\"p\">,</span> <span class=\"n\">pos_st</span><span class=\"p\">,</span> <span class=\"n\">width</span><span class=\"o\">=</span><span class=\"mf\">4.0</span><span class=\"p\">,</span> <span class=\"n\">edge_color</span><span class=\"o\">=</span><span class=\"s\">'black'</span><span class=\"p\">)</span>\n\n<span class=\"n\">pos_opt</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"n\">k</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"n\">g1comp_opt</span><span class=\"o\">.</span><span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">k</span><span class=\"p\">][</span><span class=\"s\">'lon'</span><span class=\"p\">],</span> <span class=\"n\">g1comp_opt</span><span class=\"o\">.</span><span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">k</span><span class=\"p\">][</span><span class=\"s\">'lat'</span><span class=\"p\">])</span> <span class=\"k\">for</span> <span class=\"n\">k</span> <span class=\"ow\">in</span> <span class=\"n\">g1comp_opt</span><span class=\"o\">.</span><span class=\"n\">nodes</span><span class=\"p\">()}</span>    \n<span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">draw_networkx_edges</span><span class=\"p\">(</span><span class=\"n\">g1comp_opt</span><span class=\"p\">,</span> <span class=\"n\">pos_opt</span><span class=\"p\">,</span> <span class=\"n\">width</span><span class=\"o\">=</span><span class=\"mf\">2.0</span><span class=\"p\">,</span> <span class=\"n\">edge_color</span><span class=\"o\">=</span><span class=\"s\">'blue'</span><span class=\"p\">)</span>\n\n<span class=\"c\"># save vbiz</span>\n<span class=\"n\">mplleaflet</span><span class=\"o\">.</span><span class=\"n\">save_html</span><span class=\"p\">(</span><span class=\"n\">fig</span><span class=\"p\">,</span> <span class=\"s\">'rpp_solution_edge_type.html'</span><span class=\"p\">,</span> <span class=\"n\">tiles</span><span class=\"o\">=</span><span class=\"s\">'cartodb_positron'</span><span class=\"p\">)</span></code></pre></figure>\n\n<iframe src=\"https://cdn.rawgit.com/brooksandrew/postman_problems_examples/master/50states/maps/rpp_solution_edge_type.html\" height=\"500\" width=\"750\"></iframe>\n\n<h4 id=\"visualize-rpp-solution-by-edge-walk-count\">Visualize RPP solution by edge walk count</h4>\n\n<p>Edge walks per color:</p>\n\n<p><strong><font color=\"black\">black</font></strong>: 1  <br />\n<strong><font color=\"magenta\">magenta</font></strong>: 2  <br />\n<strong><font color=\"orange\">orange</font></strong>: 3  <br /></p>\n\n<p>Edges walked more than once are also widened.</p>\n\n<p>This solution feels pretty reasonable with surprisingly little doublebacking.  After staring at this for several minutes, I could think of roads I’d prefer not to cycle on, but no obvious shorter\npaths.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"c\">## Create graph directly from rpp_circuit and original graph w lat/lon (g_ud)</span>\n<span class=\"n\">color_seq</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"bp\">None</span><span class=\"p\">,</span> <span class=\"s\">'black'</span><span class=\"p\">,</span> <span class=\"s\">'magenta'</span><span class=\"p\">,</span> <span class=\"s\">'orange'</span><span class=\"p\">,</span> <span class=\"s\">'yellow'</span><span class=\"p\">]</span>\n<span class=\"n\">grppviz</span> <span class=\"o\">=</span> <span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">Graph</span><span class=\"p\">()</span>\n<span class=\"n\">edges_cnt</span> <span class=\"o\">=</span> <span class=\"n\">Counter</span><span class=\"p\">([</span><span class=\"nb\">tuple</span><span class=\"p\">(</span><span class=\"nb\">sorted</span><span class=\"p\">([</span><span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]]))</span> <span class=\"k\">for</span> <span class=\"n\">e</span> <span class=\"ow\">in</span> <span class=\"n\">circuit_rpp</span><span class=\"p\">])</span>\n\n<span class=\"k\">for</span> <span class=\"n\">e</span> <span class=\"ow\">in</span> <span class=\"n\">circuit_rpp</span><span class=\"p\">:</span>\n    <span class=\"k\">for</span> <span class=\"n\">n1</span><span class=\"p\">,</span> <span class=\"n\">n2</span> <span class=\"ow\">in</span> <span class=\"nb\">zip</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">][</span><span class=\"s\">'path'</span><span class=\"p\">][:</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">][</span><span class=\"s\">'path'</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">:]):</span>\n        <span class=\"k\">if</span> <span class=\"n\">grppviz</span><span class=\"o\">.</span><span class=\"n\">has_edge</span><span class=\"p\">(</span><span class=\"n\">n1</span><span class=\"p\">,</span> <span class=\"n\">n2</span><span class=\"p\">):</span>\n            <span class=\"n\">grppviz</span><span class=\"p\">[</span><span class=\"n\">n1</span><span class=\"p\">][</span><span class=\"n\">n2</span><span class=\"p\">][</span><span class=\"s\">'linewidth'</span><span class=\"p\">]</span> <span class=\"o\">+=</span> <span class=\"mi\">2</span>\n            <span class=\"n\">grppviz</span><span class=\"p\">[</span><span class=\"n\">n1</span><span class=\"p\">][</span><span class=\"n\">n2</span><span class=\"p\">][</span><span class=\"s\">'cnt'</span><span class=\"p\">]</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>                \n            <span class=\"n\">grppviz</span><span class=\"o\">.</span><span class=\"n\">add_edge</span><span class=\"p\">(</span><span class=\"n\">n1</span><span class=\"p\">,</span> <span class=\"n\">n2</span><span class=\"p\">,</span> <span class=\"n\">linewidth</span><span class=\"o\">=</span><span class=\"mf\">2.5</span><span class=\"p\">)</span>\n            <span class=\"n\">grppviz</span><span class=\"p\">[</span><span class=\"n\">n1</span><span class=\"p\">][</span><span class=\"n\">n2</span><span class=\"p\">][</span><span class=\"s\">'color_st'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s\">'black'</span> <span class=\"k\">if</span> <span class=\"n\">g_st</span><span class=\"o\">.</span><span class=\"n\">has_edge</span><span class=\"p\">(</span><span class=\"n\">n1</span><span class=\"p\">,</span> <span class=\"n\">n2</span><span class=\"p\">)</span> <span class=\"k\">else</span> <span class=\"s\">'red'</span>\n            <span class=\"n\">grppviz</span><span class=\"p\">[</span><span class=\"n\">n1</span><span class=\"p\">][</span><span class=\"n\">n2</span><span class=\"p\">][</span><span class=\"s\">'cnt'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n            <span class=\"n\">grppviz</span><span class=\"o\">.</span><span class=\"n\">add_node</span><span class=\"p\">(</span><span class=\"n\">n1</span><span class=\"p\">,</span> <span class=\"n\">lat</span><span class=\"o\">=</span><span class=\"n\">g_ud</span><span class=\"o\">.</span><span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">n1</span><span class=\"p\">][</span><span class=\"s\">'lat'</span><span class=\"p\">],</span> <span class=\"n\">lon</span><span class=\"o\">=</span><span class=\"n\">g_ud</span><span class=\"o\">.</span><span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">n1</span><span class=\"p\">][</span><span class=\"s\">'lon'</span><span class=\"p\">])</span>\n            <span class=\"n\">grppviz</span><span class=\"o\">.</span><span class=\"n\">add_node</span><span class=\"p\">(</span><span class=\"n\">n2</span><span class=\"p\">,</span> <span class=\"n\">lat</span><span class=\"o\">=</span><span class=\"n\">g_ud</span><span class=\"o\">.</span><span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">n2</span><span class=\"p\">][</span><span class=\"s\">'lat'</span><span class=\"p\">],</span> <span class=\"n\">lon</span><span class=\"o\">=</span><span class=\"n\">g_ud</span><span class=\"o\">.</span><span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">n2</span><span class=\"p\">][</span><span class=\"s\">'lon'</span><span class=\"p\">])</span> \n\n<span class=\"k\">for</span> <span class=\"n\">e</span> <span class=\"ow\">in</span> <span class=\"n\">grppviz</span><span class=\"o\">.</span><span class=\"n\">edges</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"o\">=</span><span class=\"bp\">True</span><span class=\"p\">):</span>\n    <span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">][</span><span class=\"s\">'color_cnt'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">color_seq</span><span class=\"p\">[</span><span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">][</span><span class=\"s\">'cnt'</span><span class=\"p\">]]</span></code></pre></figure>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"n\">fig</span><span class=\"p\">,</span> <span class=\"n\">ax</span> <span class=\"o\">=</span> <span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">subplots</span><span class=\"p\">(</span><span class=\"n\">figsize</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">12</span><span class=\"p\">))</span>\n\n<span class=\"n\">pos</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"n\">k</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"n\">grppviz</span><span class=\"o\">.</span><span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">k</span><span class=\"p\">][</span><span class=\"s\">'lon'</span><span class=\"p\">],</span> <span class=\"n\">grppviz</span><span class=\"o\">.</span><span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">k</span><span class=\"p\">][</span><span class=\"s\">'lat'</span><span class=\"p\">])</span> <span class=\"k\">for</span> <span class=\"n\">k</span> <span class=\"ow\">in</span> <span class=\"n\">grppviz</span><span class=\"o\">.</span><span class=\"n\">nodes</span><span class=\"p\">()}</span>    \n<span class=\"n\">e_width</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">][</span><span class=\"s\">'linewidth'</span><span class=\"p\">]</span> <span class=\"k\">for</span> <span class=\"n\">e</span> <span class=\"ow\">in</span> <span class=\"n\">grppviz</span><span class=\"o\">.</span><span class=\"n\">edges</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"o\">=</span><span class=\"bp\">True</span><span class=\"p\">)]</span>\n<span class=\"n\">e_color</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">][</span><span class=\"s\">'color_cnt'</span><span class=\"p\">]</span> <span class=\"k\">for</span> <span class=\"n\">e</span> <span class=\"ow\">in</span> <span class=\"n\">grppviz</span><span class=\"o\">.</span><span class=\"n\">edges</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"o\">=</span><span class=\"bp\">True</span><span class=\"p\">)]</span>\n<span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">draw_networkx_edges</span><span class=\"p\">(</span><span class=\"n\">grppviz</span><span class=\"p\">,</span> <span class=\"n\">pos</span><span class=\"p\">,</span> <span class=\"n\">width</span><span class=\"o\">=</span><span class=\"n\">e_width</span><span class=\"p\">,</span> <span class=\"n\">edge_color</span><span class=\"o\">=</span><span class=\"n\">e_color</span><span class=\"p\">,</span> <span class=\"n\">alpha</span><span class=\"o\">=</span><span class=\"mf\">0.7</span><span class=\"p\">)</span>\n    \n<span class=\"c\"># save viz</span>\n<span class=\"n\">mplleaflet</span><span class=\"o\">.</span><span class=\"n\">save_html</span><span class=\"p\">(</span><span class=\"n\">fig</span><span class=\"p\">,</span> <span class=\"s\">'rpp_solution_edge_cnt.html'</span><span class=\"p\">,</span> <span class=\"n\">tiles</span><span class=\"o\">=</span><span class=\"s\">'cartodb_positron'</span><span class=\"p\">)</span></code></pre></figure>\n\n<iframe src=\"https://cdn.rawgit.com/brooksandrew/postman_problems_examples/master/50states/maps/rpp_solution_edge_cnt.html\" height=\"500\" width=\"750\"></iframe>\n\n<h3 id=\"65-serialize-rpp-solution\">6.5 Serialize RPP solution</h3>\n\n<h4 id=\"csv\">CSV</h4>\n\n<p>Remember we contracted the edges in <strong>4.1</strong> for more efficient computation.  However, when we visualize the solution, the more granular edges within the larger contracted ones are filled back in, so\nwe can see the exact route to ride with all the bends and squiggles.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"c\"># fill in RPP solution edgelist with granular nodes</span>\n<span class=\"n\">rpplist</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n<span class=\"k\">for</span> <span class=\"n\">ee</span> <span class=\"ow\">in</span> <span class=\"n\">circuit_rpp</span><span class=\"p\">:</span>\n    <span class=\"n\">path</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"nb\">zip</span><span class=\"p\">(</span><span class=\"n\">ee</span><span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">][</span><span class=\"s\">'path'</span><span class=\"p\">][:</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">ee</span><span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">][</span><span class=\"s\">'path'</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">:]))</span>\n    <span class=\"k\">for</span> <span class=\"n\">e</span> <span class=\"ow\">in</span> <span class=\"n\">path</span><span class=\"p\">:</span>\n        <span class=\"n\">rpplist</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">({</span>\n            <span class=\"s\">'start_node'</span><span class=\"p\">:</span> <span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span>\n            <span class=\"s\">'end_node'</span><span class=\"p\">:</span> <span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">],</span>\n            <span class=\"s\">'start_lat'</span><span class=\"p\">:</span> <span class=\"n\">g_ud</span><span class=\"o\">.</span><span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]][</span><span class=\"s\">'lat'</span><span class=\"p\">],</span>\n            <span class=\"s\">'start_lon'</span><span class=\"p\">:</span> <span class=\"n\">g_ud</span><span class=\"o\">.</span><span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]][</span><span class=\"s\">'lon'</span><span class=\"p\">],</span>\n            <span class=\"s\">'end_lat'</span><span class=\"p\">:</span> <span class=\"n\">g_ud</span><span class=\"o\">.</span><span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]][</span><span class=\"s\">'lat'</span><span class=\"p\">],</span>\n            <span class=\"s\">'end_lon'</span><span class=\"p\">:</span> <span class=\"n\">g_ud</span><span class=\"o\">.</span><span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]][</span><span class=\"s\">'lon'</span><span class=\"p\">],</span>\n            <span class=\"s\">'street_name'</span><span class=\"p\">:</span> <span class=\"n\">g_ud</span><span class=\"p\">[</span><span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]][</span><span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]]</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s\">'name'</span><span class=\"p\">)</span>\n        <span class=\"p\">})</span>\n        \n<span class=\"c\"># write solution to disk</span>\n<span class=\"n\">rppdf</span> <span class=\"o\">=</span> <span class=\"n\">pd</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">(</span><span class=\"n\">rpplist</span><span class=\"p\">)</span>\n<span class=\"n\">rppdf</span><span class=\"o\">.</span><span class=\"n\">to_csv</span><span class=\"p\">(</span><span class=\"s\">'rpp_solution.csv'</span><span class=\"p\">,</span> <span class=\"n\">index</span><span class=\"o\">=</span><span class=\"bp\">False</span><span class=\"p\">)</span></code></pre></figure>\n\n<h4 id=\"geojson\">Geojson</h4>\n\n<p>Similarly, we create a geojson object of the RPP solution using the <code class=\"highlighter-rouge\">time</code> attribute to keep track of the route order.  This data structure can be used for fancy js/d3 visualizations.  Coming soon,\nhopefully.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"n\">geojson</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s\">'features'</span><span class=\"p\">:[],</span> <span class=\"s\">'type'</span><span class=\"p\">:</span> <span class=\"s\">'FeatureCollection'</span><span class=\"p\">}</span>\n<span class=\"n\">time</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n<span class=\"n\">path</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"nb\">reversed</span><span class=\"p\">(</span><span class=\"n\">circuit_rpp</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">3</span><span class=\"p\">][</span><span class=\"s\">'path'</span><span class=\"p\">]))</span>\n\n<span class=\"k\">for</span> <span class=\"n\">e</span> <span class=\"ow\">in</span> <span class=\"n\">circuit_rpp</span><span class=\"p\">:</span>\n    <span class=\"k\">if</span> <span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">][</span><span class=\"s\">'path'</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">!=</span> <span class=\"n\">path</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]:</span> \n        <span class=\"n\">path</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"nb\">reversed</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">][</span><span class=\"s\">'path'</span><span class=\"p\">]))</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"n\">path</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">][</span><span class=\"s\">'path'</span><span class=\"p\">]</span>\n    \n    <span class=\"k\">for</span> <span class=\"n\">n</span> <span class=\"ow\">in</span> <span class=\"n\">path</span><span class=\"p\">:</span>\n        <span class=\"n\">time</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n        <span class=\"n\">doc</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s\">'type'</span><span class=\"p\">:</span> <span class=\"s\">'Feature'</span><span class=\"p\">,</span>\n              <span class=\"s\">'properties'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n                  <span class=\"s\">'latitude'</span><span class=\"p\">:</span> <span class=\"n\">g</span><span class=\"o\">.</span><span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">n</span><span class=\"p\">][</span><span class=\"s\">'lat'</span><span class=\"p\">],</span>\n                  <span class=\"s\">'longitude'</span><span class=\"p\">:</span> <span class=\"n\">g</span><span class=\"o\">.</span><span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">n</span><span class=\"p\">][</span><span class=\"s\">'lon'</span><span class=\"p\">],</span>\n                  <span class=\"s\">'time'</span><span class=\"p\">:</span> <span class=\"n\">time</span><span class=\"p\">,</span>\n                  <span class=\"s\">'id'</span><span class=\"p\">:</span> <span class=\"n\">e</span><span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s\">'id'</span><span class=\"p\">)</span>\n              <span class=\"p\">},</span>\n              <span class=\"s\">'geometry'</span><span class=\"p\">:{</span>\n                  <span class=\"s\">'type'</span><span class=\"p\">:</span> <span class=\"s\">'Point'</span><span class=\"p\">,</span>\n                  <span class=\"s\">'coordinates'</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"n\">g</span><span class=\"o\">.</span><span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">n</span><span class=\"p\">][</span><span class=\"s\">'lon'</span><span class=\"p\">],</span> <span class=\"n\">g</span><span class=\"o\">.</span><span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">n</span><span class=\"p\">][</span><span class=\"s\">'lat'</span><span class=\"p\">]]</span>\n              <span class=\"p\">}</span>\n          <span class=\"p\">}</span>\n        <span class=\"n\">geojson</span><span class=\"p\">[</span><span class=\"s\">'features'</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">doc</span><span class=\"p\">)</span></code></pre></figure>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><span class=\"k\">with</span> <span class=\"nb\">open</span><span class=\"p\">(</span><span class=\"s\">'circuit_rpp.geojson'</span><span class=\"p\">,</span><span class=\"s\">'w'</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">f</span><span class=\"p\">:</span>\n    <span class=\"n\">json</span><span class=\"o\">.</span><span class=\"n\">dump</span><span class=\"p\">(</span><span class=\"n\">geojson</span><span class=\"p\">,</span> <span class=\"n\">f</span><span class=\"p\">)</span></code></pre></figure>\n\n\n  <p><a href=\"http://brooksandrew.github.io/simpleblog/articles/fifty-states-rural-postman-problem/\">50 states Rural Postman Problem</a> was originally published by andrew brooks at <a href=\"http://brooksandrew.github.io/simpleblog\">andrew brooks</a> on November 19, 2017.</p>"
}