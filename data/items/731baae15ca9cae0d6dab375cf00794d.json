{
  "id": "tag:blogger.com,1999:blog-19803222.post-5453515752749061703",
  "published": "2016-07-29T11:18:00.002-06:00",
  "updated": "2016-07-29T11:18:29.705-06:00",
  "title": "A quick comment on structured input vs structured output learning",
  "content": "When I think of structured input models, I typically think of things like kernels over discrete input spaces. For instance, the famous <a href=\"http://www.stat.purdue.edu/~vishy/talks/StringKernels.pdf\">all-substrings kernel</a> for which K(d1,d2) effectively counts the number of common substrings in two documents, without spending exponential time enumerating them all. Of course there are many more ways of thinking about structured inputs: tree-to-string machine translation has a tree structured input. RNNs (on the input side) are essentially structured input models for sequence structures.<br /><br />When I think of structured output models, I typically think of things like CRFs, structured SVMs/M3Ns, multilabel predictors (those are borderline), various transition-based methods (eg., shift/reduce parsers), etc. Here, my internal model for the structure is essentially at prediction time: find a high scoring structure from this complicated discrete output space.<br /><br />Perhaps this has been obvious to everyone-but-me for a decade, but I only recently came to the recognition that these are essentially the same, at least if you restrict the sort of models you're willing to consider. (In particular, if you ignore things like imitation learning/learning to search for a moment.)<br /><br />In a pure structured input setting, you have some simple label space <i>Y</i> (let's assume it's the real numbers) and some complex input space<i> X</i>. Typically you want to learn a function <i>f : X ➝ Y</i>, which has low loss. In particular you want to minimize the expectation of <i>loss(y, f(x))</i> over random draws of <i>x,y</i>. And the \"interesting\" thing is that <i>x</i> isn't just a vector, so you have to be clever.<br /><br />In the pure structure output setting, in, for instance, the structured SVM/CRF setup, you have some input space <i>X</i> (which may or may not be structured) and some complex output space <i>Y</i>. As before, you want to learn a function <i>f : X ➝ Y</i>, which has low loss. However, in the most common setups, the way you accomplish this is that <i>instead</i> of directly learning <i>f</i>, you instead learn a <i>scoring</i> function <i>s</i> that scores <i>x,y</i> pairs based on how \"good\" that <i>y</i> is for the corresponding <i>x</i>. For a fixed scoring function <i>s</i>, you derive <i>f</i> according to the argmax rule: <i>f<sub>s</sub>(x) := argmax<sub>y</sub> s(x,y)</i>. In this way, you have effectively separated the learning problem (get a good <i>s</i>) from the structured problem (solve the argmax). [Whether this is good or not is up to debate; I'm personally on the \"nay\" side.] You then want to minimize something like the expectation of <i>loss(y, argmax<sub>y'</sub> s(x,y'))</i> over random draws <i>x,y</i>.<br /><br />The observation is that these two problems are essentially the same thing. That is, if you know how to do the structured input problem, then the structured output problem is essentially the same thing, as far as the learning problem goes. That is, if you can put structure in <i>f(x)</i> for structured input, you can just as well put structure in <i>s(x,y</i>)<i> </i>for structured output. Or, by example, if you can predict the fluency of an English sentence <i>x</i> as a structured input problem, you can predict the translation quality of a French/English sentence pair <i>x,y</i> in a structured output problem. This doesn't solve the <i>argmax</i> problem -- you have to do that separately -- but the underlying learning problem is essentially identical.<br /><br />You see similar ideas being reborn these days with papers like David Belanger's <a href=\"http://www.cs.umass.edu/~belanger/belanger_spen_icml.pdf\">ICML paper this year on energy networks</a>. With this framework of think-of-structured-input-and-structured-output-as-the-same, basically what they're doing is building a structured score function that uses both the input and output simultaneously, and throwing these through a deep network. (Ok it's a bit more than that, but that's the cartoon.)<br /><br />At any rate, maybe obvious to everyone but me, but I thought I'd write it down anyway :).",
  "link": [
    "",
    "",
    "",
    "",
    ""
  ],
  "author": {
    "name": "hal",
    "uri": "http://www.blogger.com/profile/02162908373916390369",
    "email": "noreply@blogger.com",
    "gd:image": ""
  },
  "thr:total": 1
}