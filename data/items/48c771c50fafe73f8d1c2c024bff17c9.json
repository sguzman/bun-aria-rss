{
  "title": "Overhead of Returning Optional Values in Java and Rust",
  "link": "",
  "published": "2021-10-16T00:00:00+00:00",
  "updated": "2021-10-16T00:00:00+00:00",
  "id": "https://pkolaczk.github.io/overhead-of-optional",
  "content": "<p>Some programming languages like Java or Scala offer more than one way to express\na concept of “lack of value”. Traditionally, a special <code class=\"language-plaintext highlighter-rouge\">null</code> value is used to denote\nreferences that don’t reference any value at all. However, over time we \nhave learned that using <code class=\"language-plaintext highlighter-rouge\">null</code>s can be very error-prone and can cause many troubles like \n<code class=\"language-plaintext highlighter-rouge\">NullPointerException</code> errors crashing a program in the most unexpected moment. \nTherefore, modern programming style recommends avoiding <code class=\"language-plaintext highlighter-rouge\">nulls</code> wherever possible \nin favor of a much better <code class=\"language-plaintext highlighter-rouge\">Option</code>, <code class=\"language-plaintext highlighter-rouge\">Optional</code> or <code class=\"language-plaintext highlighter-rouge\">Maybe</code> data type \n(called differently in many languages, but the concept is the same).\nUnfortunately, it is believed that optional values in Java may come with a \nperformance penalty. In this blog post, I’ll try to answer whether \nit is true, and if the performance penalty really exists, how serious it is.</p>\n\n<!--more-->\n\n<p>Before we start, let me point out that if you don’t care much about extreme runtime performance, \nyou should never use <code class=\"language-plaintext highlighter-rouge\">null</code> in Java nor Scala, except for in rare cases of working with legacy APIs. \nJust forget <code class=\"language-plaintext highlighter-rouge\">null</code> ever existed in the language. And if you receive an occasional <code class=\"language-plaintext highlighter-rouge\">null</code> from an API \nyou can’t control, just wrap it immediately in <code class=\"language-plaintext highlighter-rouge\">Optional&lt;T&gt;</code> / <code class=\"language-plaintext highlighter-rouge\">Option[T]</code>. Don’t let <code class=\"language-plaintext highlighter-rouge\">nulls</code> bite you. \nYou won’t regret it. To learn the reasons why null pointers / null references are a bad idea,\nwatch <a href=\"https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/\">this talk by Tony Hoare</a>.</p>\n\n<p>Ok, but if we care about performance? How much do optionals actually cost? \nSome say optionals are expensive because they cause heap allocation and often force the underlying type to be boxed.\nNot only heap allocation is costly, but it also forces the garbage collector to run more frequently.\nOthers say that it doesn’t really matter, because the JVM compiler will eliminate the overhead thanks to inlining and escape analysis,\nand in most cases it should transform the code to an equivalent of code using null pointers.</p>\n\n<p>Who is right? Let’s make a quick benchmark.</p>\n\n<h1 id=\"java-benchmark\">Java Benchmark</h1>\n<p>How to measure <code class=\"language-plaintext highlighter-rouge\">Optional</code> overhead? The time to create an <code class=\"language-plaintext highlighter-rouge\">Optional</code> object instance, even assuming a pessimistic case \nof allocating it on the heap, is likely too small to measure it directly. We need to create many <code class=\"language-plaintext highlighter-rouge\">Optional</code> objects \nin a tight loop and time the whole loop.</p>\n\n<p>We also need to make sure the compiler doesn’t notice the code does nothing or does\nsomething trivial. We don’t want the loop to be eliminated. \nA proper way of dealing with this problem is using all of the <code class=\"language-plaintext highlighter-rouge\">Optional</code> objects we create so that\ntheir values affect the final result computed in the benchmark. Then the final result must be consumed by a black hole. \nFortunately a benchmarking tool like <a href=\"https://github.com/openjdk/jmh\">JMH</a> makes it all easy.</p>\n\n<p>I created three variants of code solving the same task. The task was to compute a sum of all the numbers, skipping the number \nwhenever it is equal to a magic constant. The variants differ by the way how skipping is realized:</p>\n\n<ol>\n  <li>We return primitive <code class=\"language-plaintext highlighter-rouge\">long</code>s and check if we need to skip by performing a comparison with the magic value directly in the summing loop.</li>\n  <li>We return boxed <code class=\"language-plaintext highlighter-rouge\">Long</code>s and we return <code class=\"language-plaintext highlighter-rouge\">null</code> whenever we need to skip a number.</li>\n  <li>We return boxed <code class=\"language-plaintext highlighter-rouge\">Long</code>s wrapped in <code class=\"language-plaintext highlighter-rouge\">Optional</code> and we return <code class=\"language-plaintext highlighter-rouge\">Optional.empty()</code> whenever we need to skip a number.</li>\n</ol>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@State</span><span class=\"o\">(</span><span class=\"nc\">Scope</span><span class=\"o\">.</span><span class=\"na\">Benchmark</span><span class=\"o\">)</span>\n<span class=\"nd\">@Fork</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"nd\">@Warmup</span><span class=\"o\">(</span><span class=\"n\">iterations</span> <span class=\"o\">=</span> <span class=\"mi\">2</span><span class=\"o\">)</span>\n<span class=\"nd\">@Measurement</span><span class=\"o\">(</span><span class=\"n\">iterations</span> <span class=\"o\">=</span> <span class=\"mi\">5</span><span class=\"o\">)</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">OptionBenchmark</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"kt\">long</span> <span class=\"no\">MAGIC_NUMBER</span> <span class=\"o\">=</span> <span class=\"mi\">7</span><span class=\"o\">;</span>\n\n    <span class=\"c1\">// Variant 1.</span>\n    <span class=\"c1\">// Probably the simplest way to sum numbers.</span>\n    <span class=\"c1\">// No boxing, no objects involved, just primitive long values everywhere.</span>\n    <span class=\"c1\">// This is probably what a C-programmer converted to Java would write ;)</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">long</span> <span class=\"nf\">getNumber</span><span class=\"o\">(</span><span class=\"kt\">long</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">i</span> <span class=\"o\">&amp;</span> <span class=\"mh\">0xFF</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"nd\">@Benchmark</span>\n    <span class=\"nd\">@BenchmarkMode</span><span class=\"o\">(</span><span class=\"nc\">Mode</span><span class=\"o\">.</span><span class=\"na\">AverageTime</span><span class=\"o\">)</span>\n    <span class=\"nd\">@OutputTimeUnit</span><span class=\"o\">(</span><span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">MICROSECONDS</span><span class=\"o\">)</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">long</span> <span class=\"nf\">sumSimple</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"kt\">long</span> <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">long</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"mi\">1_000_000</span><span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kt\">long</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">getNumber</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">);</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">!=</span> <span class=\"no\">MAGIC_NUMBER</span><span class=\"o\">)</span>\n                <span class=\"n\">sum</span> <span class=\"o\">+=</span> <span class=\"n\">n</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">sum</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"c1\">// Variant 2.</span>\n    <span class=\"c1\">// Replace MAGIC_NUMBER with a null.</span>\n    <span class=\"c1\">// To be able to return null, we need to box long into a Long object.</span>\n    <span class=\"kd\">private</span> <span class=\"nc\">Long</span> <span class=\"nf\">getNumberOrNull</span><span class=\"o\">(</span><span class=\"kt\">long</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">long</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">i</span> <span class=\"o\">&amp;</span> <span class=\"mh\">0xFF</span><span class=\"o\">;</span>\n        <span class=\"k\">return</span> <span class=\"n\">n</span> <span class=\"o\">==</span> <span class=\"no\">MAGIC_NUMBER</span> <span class=\"o\">?</span> <span class=\"kc\">null</span> <span class=\"o\">:</span> <span class=\"n\">n</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"nd\">@Benchmark</span>\n    <span class=\"nd\">@BenchmarkMode</span><span class=\"o\">(</span><span class=\"nc\">Mode</span><span class=\"o\">.</span><span class=\"na\">AverageTime</span><span class=\"o\">)</span>\n    <span class=\"nd\">@OutputTimeUnit</span><span class=\"o\">(</span><span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">MICROSECONDS</span><span class=\"o\">)</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">long</span> <span class=\"nf\">sumNulls</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"kt\">long</span> <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">long</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"mi\">1_000_000</span><span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"nc\">Long</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">getNumberOrNull</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">);</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"n\">sum</span> <span class=\"o\">+=</span> <span class=\"n\">n</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">sum</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n\n    <span class=\"c1\">// Variant 3.</span>\n    <span class=\"c1\">// Replace MAGIC_NUMBER with Optional.empty().</span>\n    <span class=\"c1\">// Now we not only need to box the value into a Long, but also create the Optionsl wrapper.</span>\n    <span class=\"kd\">private</span> <span class=\"nc\">Optional</span><span class=\"o\">&lt;</span><span class=\"nc\">Long</span><span class=\"o\">&gt;</span> <span class=\"nf\">getOptionalNumber</span><span class=\"o\">(</span><span class=\"kt\">long</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">long</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">i</span> <span class=\"o\">&amp;</span> <span class=\"mh\">0xFF</span><span class=\"o\">;</span>\n        <span class=\"k\">return</span> <span class=\"n\">n</span> <span class=\"o\">==</span> <span class=\"no\">MAGIC_NUMBER</span> <span class=\"o\">?</span> <span class=\"nc\">Optional</span><span class=\"o\">.</span><span class=\"na\">empty</span><span class=\"o\">()</span> <span class=\"o\">:</span> <span class=\"nc\">Optional</span><span class=\"o\">.</span><span class=\"na\">of</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"nd\">@Benchmark</span>\n    <span class=\"nd\">@BenchmarkMode</span><span class=\"o\">(</span><span class=\"nc\">Mode</span><span class=\"o\">.</span><span class=\"na\">AverageTime</span><span class=\"o\">)</span>\n    <span class=\"nd\">@OutputTimeUnit</span><span class=\"o\">(</span><span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">MICROSECONDS</span><span class=\"o\">)</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">long</span> <span class=\"nf\">sumOptional</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"kt\">long</span> <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">long</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"mi\">1_000_000</span><span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"nc\">Optional</span><span class=\"o\">&lt;</span><span class=\"nc\">Long</span><span class=\"o\">&gt;</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">getOptionalNumber</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">);</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">.</span><span class=\"na\">isPresent</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n                <span class=\"n\">sum</span> <span class=\"o\">+=</span> <span class=\"n\">n</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">sum</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n</code></pre></div></div>\n\n<h1 id=\"results\">Results</h1>\n\n<p>Obviously all variants compute the same sum, so a <em>sufficiently smart compiler</em> should be able to generate exactly the same machine \ncode for all of them. The method returning the number is very short and trivial, so I was expecting the compiler to inline it,\nremove all of object overhead through escape analysis, unroll and maybe even vectorize the loop.\nThe number of invocations is constant and known at compile time, and the computations are trivial.\nReal code in real projects is usually not as simple as this microbenchmark, so we’re essentially testing the best-case scenario here.</p>\n\n<p>OpenJDK 8 (JDK 1.8.0_292, OpenJDK 64-Bit Server VM, 25.292-b10):</p>\n<pre>\nBenchmark                    Mode  Cnt     Score     Error  Units\nOptionBenchmark.sumSimple    avgt    5  1141,557 ± 366,538  us/op\nOptionBenchmark.sumNulls     avgt    5  2324,597 ±  79,033  us/op\nOptionBenchmark.sumOptional  avgt    5  4576,383 ± 288,571  us/op\n</pre>\n\n<p>OpenJDK 11 (Java HotSpot(TM) 64-Bit Server VM, 11+28):</p>\n<pre>\nBenchmark                    Mode  Cnt     Score     Error  Units\nOptionBenchmark.sumSimple    avgt    5   603,683 ±  13,246  us/op\nOptionBenchmark.sumNulls     avgt    5  2444,626 ±  35,236  us/op\nOptionBenchmark.sumOptional  avgt    5  4303,527 ± 109,900  us/op\n</pre>\n\n<p>Graal Community 21.2 (JDK 16.0.2, OpenJDK 64-Bit Server VM, 16.0.2+7-jvmci-21.2-b08):</p>\n<pre>\nOptionBenchmark.sumSimple    avgt    5   868,155 ±  42,103  us/op\nOptionBenchmark.sumNulls     avgt    5  1937,866 ±  29,938  us/op\nOptionBenchmark.sumOptional  avgt    5  4201,451 ± 613,179  us/op\n</pre>\n\n<p>OpenJDK 17 (JDK 17-ea, OpenJDK 64-Bit Server VM, 17-ea+19-Ubuntu-1ubuntu1):</p>\n<pre>\nBenchmark                    Mode  Cnt     Score     Error  Units\nOptionBenchmark.sumSimple    avgt    5   449,811 ±  60,889  us/op\nOptionBenchmark.sumNulls     avgt    5   952,622 ±  84,138  us/op\nOptionBenchmark.sumOptional  avgt    5  4002,787 ± 264,937  us/op\n</pre>\n\n<p>Seriously, these outcomes are totally not what I expected. In all cases\nJVM did a poor job of eliminating both the boxing and the optionals. \nThis led to about 8x worse timings for looping over optionals than looping \nover primitive longs on JDK 17. I even reran the benchmarks \nwith explicit <code class=\"language-plaintext highlighter-rouge\">-XX:+DoEscapeAnalysis -XX:+Inline</code> to make sure these are turned on, \nbut that hasn’t changed anything (they should be enabled by default anyway).</p>\n\n<p>At least, there is a steady progress in performance between different JDK versions.</p>\n\n<h2 id=\"disabling-inlining\">Disabling Inlining</h2>\n<p>In real production code it can also happen that a method that returns an <code class=\"language-plaintext highlighter-rouge\">Optional</code> doesn’t get inlined.\nHow does it affect the overhead? I reran the benchmarks with <code class=\"language-plaintext highlighter-rouge\">-XX:-Inline</code> option:</p>\n\n<p>JDK 1.8.0_292, OpenJDK 64-Bit Server VM, 25.292-b10:</p>\n<pre>\nBenchmark                    Mode  Cnt      Score      Error  Units\nOptionBenchmark.sumSimple    avgt    5   2244,281 ± 1271,115  us/op\nOptionBenchmark.sumNulls     avgt    5   9024,197 ±  391,510  us/op\nOptionBenchmark.sumOptional  avgt    5  20045,933 ±  777,194  us/op\n\n</pre>\n\n<p>JDK 11, Java HotSpot(TM) 64-Bit Server VM, 11+28</p>\n<pre>\nBenchmark                    Mode  Cnt      Score      Error  Units\nOptionBenchmark.sumSimple    avgt    5   2385,597 ±  323,662  us/op\nOptionBenchmark.sumNulls     avgt    5   7900,140 ± 2841,416  us/op\nOptionBenchmark.sumOptional  avgt    5  20507,346 ± 5236,451  us/op\n</pre>\n\n<p>JDK 17-ea, OpenJDK 64-Bit Server VM, 17-ea+19-Ubuntu-1ubuntu1:</p>\n<pre>\nBenchmark                    Mode  Cnt      Score      Error  Units\nOptionBenchmark.sumSimple    avgt    5   2382,109 ± 1346,017  us/op\nOptionBenchmark.sumNulls     avgt    5   7664,463 ± 2040,463  us/op\nOptionBenchmark.sumOptional  avgt    5  17961,942 ±  773,224  us/op\n</pre>\n\n<p>Everything got much slower, but optionals and boxing overhead are still clearly visible and the ratio\nis still more than 7x. The difference between JDKs is much smaller this time.</p>\n\n<h1 id=\"rust-benchmark\">Rust Benchmark</h1>\n\n<p>I’ve rewritten everything to Rust because Rust also has optional values, and I was curious if a similar \ndifference would be present. The code was trivial to port, except the variant that was using nulls, because Rust has no nulls \n(which is IMHO a good thing). Instead, I added two more variants:</p>\n<ul>\n  <li>A variant with <code class=\"language-plaintext highlighter-rouge\">NonZeroU64</code> (non zero integer) which should allow the compiler to get rid of the option overhead, \nand just use value <code class=\"language-plaintext highlighter-rouge\">0</code> for representing <code class=\"language-plaintext highlighter-rouge\">None</code>.</li>\n  <li>A special “I would never write Rust like that” variant that returns the value in a <code class=\"language-plaintext highlighter-rouge\">Box</code> on the heap. This is because a friend\nof mine, after seeing my results, told me I was cheating, because all Rust versions so far used registers/stack to return the value, \nand Java was at a disadvantage due to returning on the heap (by default). So here you are.</li>\n</ul>\n\n<div class=\"language-rust highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">use</span> <span class=\"nn\">std</span><span class=\"p\">::</span><span class=\"nn\">num</span><span class=\"p\">::</span><span class=\"n\">NonZeroU64</span><span class=\"p\">;</span>\n\n<span class=\"k\">const</span> <span class=\"n\">MAGIC</span><span class=\"p\">:</span> <span class=\"nb\">u64</span> <span class=\"o\">=</span> <span class=\"mi\">7</span><span class=\"p\">;</span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">get_int</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">:</span> <span class=\"nb\">u64</span><span class=\"p\">)</span> <span class=\"k\">-&gt;</span> <span class=\"nb\">u64</span> <span class=\"p\">{</span>\n    <span class=\"n\">n</span> <span class=\"o\">&amp;</span> <span class=\"mi\">0xFF</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">pub</span> <span class=\"k\">fn</span> <span class=\"nf\">sum_simple</span><span class=\"p\">()</span> <span class=\"k\">-&gt;</span> <span class=\"nb\">u64</span> <span class=\"p\">{</span>\n    <span class=\"k\">let</span> <span class=\"k\">mut</span> <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"n\">in</span> <span class=\"mi\">0</span><span class=\"o\">..</span><span class=\"mi\">1_000_000</span> <span class=\"p\">{</span>\n        <span class=\"k\">let</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"nf\">get_int</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">);</span>\n        <span class=\"k\">if</span> <span class=\"n\">n</span> <span class=\"o\">!=</span> <span class=\"n\">MAGIC</span> <span class=\"p\">{</span>\n            <span class=\"n\">sum</span> <span class=\"o\">+=</span> <span class=\"n\">n</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">sum</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">get_optional_int</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">:</span> <span class=\"nb\">u64</span><span class=\"p\">)</span> <span class=\"k\">-&gt;</span> <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"nb\">u64</span><span class=\"o\">&gt;</span> <span class=\"p\">{</span>\n    <span class=\"k\">let</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">n</span> <span class=\"o\">&amp;</span> <span class=\"mi\">0xFF</span><span class=\"p\">;</span>\n    <span class=\"k\">if</span> <span class=\"n\">i</span> <span class=\"o\">==</span> <span class=\"n\">MAGIC</span> <span class=\"p\">{</span> <span class=\"nb\">None</span> <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span> <span class=\"nf\">Some</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n\n<span class=\"k\">pub</span> <span class=\"k\">fn</span> <span class=\"nf\">sum_optional</span><span class=\"p\">()</span> <span class=\"k\">-&gt;</span> <span class=\"nb\">u64</span> <span class=\"p\">{</span>\n    <span class=\"k\">let</span> <span class=\"k\">mut</span> <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"n\">in</span> <span class=\"mi\">0</span><span class=\"o\">..</span><span class=\"mi\">1_000_000</span> <span class=\"p\">{</span>\n        <span class=\"k\">let</span> <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"nf\">get_optional_int</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">);</span>\n        <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"nf\">Some</span><span class=\"p\">(</span><span class=\"n\">k</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"n\">value</span> <span class=\"p\">{</span>\n            <span class=\"n\">sum</span> <span class=\"o\">+=</span> <span class=\"n\">k</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">sum</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">get_optional_non_zero</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">:</span> <span class=\"nb\">u64</span><span class=\"p\">)</span> <span class=\"k\">-&gt;</span> <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">NonZeroU64</span><span class=\"o\">&gt;</span> <span class=\"p\">{</span>\n    <span class=\"k\">let</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">n</span> <span class=\"o\">&amp;</span> <span class=\"mi\">0xFF</span><span class=\"p\">;</span>\n    <span class=\"k\">if</span> <span class=\"n\">i</span> <span class=\"o\">==</span> <span class=\"n\">MAGIC</span> <span class=\"p\">{</span> <span class=\"nb\">None</span> <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span> <span class=\"nn\">NonZeroU64</span><span class=\"p\">::</span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">pub</span> <span class=\"k\">fn</span> <span class=\"nf\">sum_optional_non_zero</span><span class=\"p\">()</span> <span class=\"k\">-&gt;</span> <span class=\"nb\">u64</span> <span class=\"p\">{</span>\n    <span class=\"k\">let</span> <span class=\"k\">mut</span> <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"n\">in</span> <span class=\"mi\">0</span><span class=\"o\">..</span><span class=\"mi\">1_000_000</span> <span class=\"p\">{</span>\n        <span class=\"k\">let</span> <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"nf\">get_optional_non_zero</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">);</span>\n        <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"nf\">Some</span><span class=\"p\">(</span><span class=\"n\">k</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"n\">value</span> <span class=\"p\">{</span>\n            <span class=\"n\">sum</span> <span class=\"o\">+=</span> <span class=\"n\">k</span><span class=\"nf\">.get</span><span class=\"p\">();</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">sum</span>\n<span class=\"p\">}</span>\n\n\n<span class=\"k\">fn</span> <span class=\"nf\">get_int_boxed</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">:</span> <span class=\"nb\">u64</span><span class=\"p\">)</span> <span class=\"k\">-&gt;</span> <span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"nb\">u64</span><span class=\"o\">&gt;&gt;</span> <span class=\"p\">{</span>\n    <span class=\"k\">let</span> <span class=\"n\">opt</span> <span class=\"o\">=</span> <span class=\"k\">if</span> <span class=\"n\">n</span> <span class=\"o\">==</span> <span class=\"n\">MAGIC</span> <span class=\"p\">{</span> <span class=\"nb\">None</span> <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span> <span class=\"nf\">Some</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span> <span class=\"p\">};</span>\n    <span class=\"nn\">Box</span><span class=\"p\">::</span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">opt</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">pub</span> <span class=\"k\">fn</span> <span class=\"nf\">sum_boxed</span><span class=\"p\">()</span> <span class=\"k\">-&gt;</span> <span class=\"nb\">u64</span> <span class=\"p\">{</span>\n    <span class=\"k\">let</span> <span class=\"k\">mut</span> <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"n\">in</span> <span class=\"mi\">0</span><span class=\"o\">..</span><span class=\"mi\">1_000_000</span> <span class=\"p\">{</span>\n        <span class=\"k\">let</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"nf\">get_int_boxed</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">);</span>\n        <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"nf\">Some</span><span class=\"p\">(</span><span class=\"n\">k</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"o\">*</span><span class=\"n\">n</span> <span class=\"p\">{</span>\n            <span class=\"n\">sum</span> <span class=\"o\">+=</span> <span class=\"n\">k</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">sum</span>\n<span class=\"p\">}</span>\n\n</code></pre></div></div>\n\n<h2 id=\"results-1\">Results</h2>\n<p>Let the numbers speak for themselves.</p>\n\n<p>With inlining, compiled specifically for my CPU with <code class=\"language-plaintext highlighter-rouge\">RUSTFLAGS=\"-C target-cpu=native\"</code>:</p>\n<pre>\nsum_simple              time:   [121.33 us 121.60 us 121.89 us]                        \nsum_optional            time:   [121.65 us 121.97 us 122.29 us]                         \nsum_optional_non_zero   time:   [123.22 us 123.71 us 124.26 us]                                  \nsum_boxed               time:   [122.36 us 123.19 us 124.21 us]    \n</pre>\n\n<p>With default release options:</p>\n<pre>\nsum_simple              time:   [375.58 us 377.02 us 378.73 us]                        \nsum_optional            time:   [373.19 us 374.20 us 375.31 us]                         \nsum_optional_non_zero   time:   [373.09 us 374.24 us 375.60 us]                                  \nsum_boxed               time:   [313.62 us 314.76 us 316.09 us]                      \n</pre>\n\n<p>With default release options, but with inlining of the inner functions \nreturning the number blocked by <code class=\"language-plaintext highlighter-rouge\">#[inline(never)]</code>:</p>\n<pre>\nsum_simple              time:   [1.3899 ms 1.3940 ms 1.3987 ms]                         \nsum_optional            time:   [1.4066 ms 1.4117 ms 1.4177 ms]                          \nsum_optional_non_zero   time:   [1.1041 ms 1.1089 ms 1.1145 ms]                                   \nsum_boxed               time:   [14.882 ms 14.936 ms 14.994 ms]                      \n</pre>\n\n<h1 id=\"analysis\">Analysis</h1>\n\n<p>Why has Java scored so bad compared to Rust?</p>\n\n<p>I added the <code class=\"language-plaintext highlighter-rouge\">-perfasm</code> option to the JMH options of the <code class=\"language-plaintext highlighter-rouge\">sumOptional</code> Java benchmark \nand it resulted in the following disassembly output (I’m actually showing only a relevant fragment of it):</p>\n\n<pre>\n  0,01%   ╭ │     0x00007fcc78d3a3eb:   jmp    0x00007fcc78d3a495           ;*goto {reexecute=0 rethrow=0 return_oop=0}\n          │ │                                                               ; - pk.OptionBenchmark::sumOptional@45 (line 73)\n  0,31%   │ │  ↗  0x00007fcc78d3a3f0:   mov    QWORD PTR [r15+0x108],rsi\n  3,08%   │ │  │  0x00007fcc78d3a3f7:   prefetchw BYTE PTR [rsi+0xc0]\n  3,34%   │ │  │  0x00007fcc78d3a3fe:   mov    QWORD PTR [r10],0x1\n  0,24%   │ │  │  0x00007fcc78d3a405:   mov    DWORD PTR [r10+0x8],0x49770  ;   {metadata(&apos;java/lang/Long&apos;)}\n  0,54%   │ │  │  0x00007fcc78d3a40d:   mov    DWORD PTR [r10+0xc],r12d     ;*new {reexecute=0 rethrow=0 return_oop=0}\n          │ │  │                                                            ; - java.lang.Long::valueOf@31 (line 1211)\n          │ │  │                                                            ; - pk.OptionBenchmark::getOptionalNumber@21 (line 65)\n          │ │  │                                                            ; - pk.OptionBenchmark::sumOptional@14 (line 74)\n  2,55%   │ │  │  0x00007fcc78d3a411:   mov    QWORD PTR [r10+0x10],r11\n  1,58%   │ │ ↗│  0x00007fcc78d3a415:   mov    rax,QWORD PTR [r15+0x108]\n  2,71%   │ │ ││  0x00007fcc78d3a41c:   mov    r11,rax\n  0,72%   │ │ ││  0x00007fcc78d3a41f:   add    r11,0x10\n  3,48%   │ │ ││  0x00007fcc78d3a423:   cmp    r11,QWORD PTR [r15+0x118]\n          │ │ ││  0x00007fcc78d3a42a:   jae    0x00007fcc78d3a574           ;*goto {reexecute=0 rethrow=0 return_oop=0}\n          │ │ ││                                                            ; - pk.OptionBenchmark::sumOptional@45 (line 73)\n  1,90%   │ │ ││  0x00007fcc78d3a430:   mov    QWORD PTR [r15+0x108],r11\n  1,80%   │ │ ││  0x00007fcc78d3a437:   prefetchw BYTE PTR [r11+0xc0]\n  5,22%   │ │ ││  0x00007fcc78d3a43f:   mov    QWORD PTR [rax],0x1\n  3,78%   │ │ ││  0x00007fcc78d3a446:   mov    DWORD PTR [rax+0x8],0x11af00 ;*new {reexecute=0 rethrow=0 return_oop=0}\n          │ │ ││                                                            ; - java.util.Optional::of@0 (line 113)\n          │ │ ││                                                            ; - pk.OptionBenchmark::getOptionalNumber@24 (line 65)\n          │ │ ││                                                            ; - pk.OptionBenchmark::sumOptional@14 (line 74)\n          │ │ ││                                                            ;   {metadata(&apos;java/util/Optional&apos;)}\n  2,20%   │ │ ││  0x00007fcc78d3a44d:   mov    r11,r10\n  1,54%   │ │ ││  0x00007fcc78d3a450:   shr    r11,0x3\n  0,87%   │ │ ││  0x00007fcc78d3a454:   mov    DWORD PTR [rax+0xc],r11d     ;*synchronization entry\n          │ │ ││                                                            ; - pk.OptionBenchmark::getOptionalNumber@-1 (line 64)\n          │ │ ││                                                            ; - pk.OptionBenchmark::sumOptional@14 (line 74)\n  3,23%   │ │ ││  0x00007fcc78d3a458:   mov    r11d,DWORD PTR [rax+0xc]     ;*getfield value {reexecute=0 rethrow=0 return_oop=0}\n          │ │ ││                                                            ; - java.util.Optional::isPresent@1 (line 154)\n          │ │ ││                                                            ; - pk.OptionBenchmark::sumOptional@21 (line 75)\n  2,24%   │ │ ││  0x00007fcc78d3a45c:   nop    DWORD PTR [rax+0x0]\n  1,47%   │ │ ││  0x00007fcc78d3a460:   test   r11d,r11d\n          │╭│ ││  0x00007fcc78d3a463:   je     0x00007fcc78d3a47f\n  2,72%   │││ ││  0x00007fcc78d3a465:   mov    r10d,DWORD PTR [r12+r11*8+0x8]\n 11,00%   │││ ││  0x00007fcc78d3a46a:   shl    r11,0x3\n  0,92%   │││ ││  0x00007fcc78d3a46e:   cmp    r10d,0x49770                 ;*synchronization entry\n          │││ ││                                                            ; - pk.OptionBenchmark::getOptionalNumber@-1 (line 64)\n          │││ ││                                                            ; - pk.OptionBenchmark::sumOptional@14 (line 74)\n          │││ ││                                                            ;   {metadata(&apos;java/lang/Long&apos;)}\n          │││ ││  0x00007fcc78d3a475:   jne    0x00007fcc78d3a687           ;*checkcast {reexecute=0 rethrow=0 return_oop=0}\n          │││ ││                                                            ; - pk.OptionBenchmark::sumOptional@33 (line 76)\n  4,53%   │││ ││  0x00007fcc78d3a47b:   add    rcx,QWORD PTR [r11+0x10]     ;*lload_3 {reexecute=0 rethrow=0 return_oop=0}\n          │││ ││                                                            ; - pk.OptionBenchmark::sumOptional@41 (line 73)\n  5,89%   │↘│ ││  0x00007fcc78d3a47f:   add    r8,0x1\n  0,92%   │ │ ││  0x00007fcc78d3a483:   mov    r11,r8                       ;*synchronization entry\n          │ │ ││                                                            ; - pk.OptionBenchmark::getOptionalNumber@-1 (line 64)\n          │ │ ││                                                            ; - pk.OptionBenchmark::sumOptional@14 (line 74)\n  0,62%   │ │ ││  0x00007fcc78d3a486:   movzx  r11,r11b                     ;*land {reexecute=0 rethrow=0 return_oop=0}\n          │ │ ││                                                            ; - pk.OptionBenchmark::getOptionalNumber@4 (line 64)\n          │ │ ││                                                            ; - pk.OptionBenchmark::sumOptional@14 (line 74)\n  1,14%   │ │ ││  0x00007fcc78d3a48a:   inc    edi\n  4,42%   │ │ ││  0x00007fcc78d3a48c:   cmp    edi,r9d\n          │ ╰ ││  0x00007fcc78d3a48f:   jge    0x00007fcc78d3a3b3\n</pre>\n\n<p>My knowledge of Intel assembly is quite limited, but I can clearly see a few things:</p>\n<ul>\n  <li>The call to <code class=\"language-plaintext highlighter-rouge\">getOptionalNumber</code> got inlined. There are no calls anywhere in the body of the loop. This is good.</li>\n  <li>There is a lot of code caused by allocating and initializing the <code class=\"language-plaintext highlighter-rouge\">Long</code> instance. \nWe can see <code class=\"language-plaintext highlighter-rouge\">java.lang.Long::valueOf@31 (line 1211)</code> got inlined, but the allocation hasn’t been eliminated. This is very bad.</li>\n  <li>There is a similar problem with the <code class=\"language-plaintext highlighter-rouge\">Option</code> object - it got inlined, but it is still allocated on the heap and \nits internal structure remained intact. I was hoping for a scalar-replacement here, but weirdly it hasn’t happened.</li>\n  <li>The number to be summed is being copied out from the <code class=\"language-plaintext highlighter-rouge\">Option</code> object. There are many needless data transfers between memory and registers.</li>\n  <li>Skipping the magic number is performed by a conditional jump. In this case it is probably not a problem, \nbecause we’re skipping just one number per 256, but this could potentially cause branch misprediction if the ratio was different and not so regular.</li>\n  <li>No SSE/AVX used anywhere. It treated my CPU as if it was some ancient Pentium :(</li>\n</ul>\n\n<p>To confirm my interpretation of the disassembly, I also ran all the benchmarks with <code class=\"language-plaintext highlighter-rouge\">-perf gc</code>:</p>\n<pre>\nBenchmark                                                     Mode  Cnt         Score        Error   Units\nOptionBenchmark.sumSimple:·gc.alloc.rate                      avgt    5        ≈ 10⁻⁴               MB/sec\nOptionBenchmark.sumSimple:·gc.count                           avgt    5           ≈ 0               counts\n\nOptionBenchmark.sumNulls:·gc.alloc.rate                       avgt    5        ≈ 10⁻⁴               MB/sec\nOptionBenchmark.sumNulls:·gc.count                            avgt    5           ≈ 0               counts\n\nOptionBenchmark.sumOptional:·gc.alloc.rate                    avgt    5      6193,432 ±    424,465  MB/sec\nOptionBenchmark.sumOptional:·gc.count                         avgt    5       546,000               counts\n</pre>\n\n<p>As you can see, the <code class=\"language-plaintext highlighter-rouge\">sumOptional</code> benchmark was allocating at rate over 6 GB/s!</p>\n\n<h2 id=\"rust-output-code\">Rust output code</h2>\n<p>The code generated by Rust using default options looks much simpler:</p>\n\n<pre>\n            Disassembly of section .text:\n               \n            0000000000050f40 &lt;benchmark::sum_optional&gt;:\n            benchmark::sum_optional:\n              mov    $0x4,%ecx\n              xor    %edx,%edx\n              xor    %eax,%eax\n              nop           \n  2,67  10:   lea    -0x4(%rcx),%esi\n  5,65        lea    -0x3(%rcx),%edi\n  2,61        movzbl %sil,%esi\n  4,29        cmp    $0x7,%rsi\n  2,76        cmove  %rdx,%rsi\n  5,71        add    %rax,%rsi\n  2,47        lea    -0x2(%rcx),%eax\n  4,41        movzbl %dil,%edi\n  2,69        cmp    $0x7,%rdi\n  6,05        cmove  %rdx,%rdi\n  3,29        add    %rsi,%rdi\n  3,98        lea    -0x1(%rcx),%esi\n  2,53        movzbl %al,%eax\n  5,09        cmp    $0x7,%rax\n  3,37        cmove  %rdx,%rax\n  4,76        add    %rdi,%rax\n  2,75        movzbl %sil,%esi\n  4,80        cmp    $0x7,%rsi\n  3,15        cmove  %rdx,%rsi\n  5,64        add    %rax,%rsi\n  2,23        movzbl %cl,%eax\n  4,18        cmp    $0x7,%rax\n  2,78        cmove  %rdx,%rax\n  5,31        add    %rsi,%rax\n  2,44        add    $0x5,%rcx\n              cmp    $0xf4244,%rcx\n  4,40      ↑ jne    10     \n  0,01      ← ret           \n</pre>\n\n<p>The code is much shorter, even despite the fact the loop has been unrolled. It is also way simpler and easier to understand.\nIn the body of the loop there are no moves between memory and registers, and there are no branches.\nSkipping the number is performed with a conditional move instruction which looks like a very natural choice to me.</p>\n\n<p>It is worth noting the code for all of four variants is identical and the compiler even merged copies into one.\nThe compiler managed to get rid of all the overhead of <code class=\"language-plaintext highlighter-rouge\">Option</code> and <code class=\"language-plaintext highlighter-rouge\">Box</code>.\nThese abstrations turned out to be truly zero-cost!</p>\n\n<p>As a final check I compiled the benchmark with <code class=\"language-plaintext highlighter-rouge\">RUSTFLAGS=\"-C target-cpu=native\"</code>:</p>\n\n<pre>\n             Disassembly of section .text:\n               \n             0000000000057d50 &lt;benchmark::sum_classic&gt;:\n             btree_benchmark::sum_optional:\n               sub          $0x38,%rsp\n  0,00         vmovdqa      anon.b26f45dd7d0ea1d60480ae6c3c88753d.34.llvm.65588711349491208+0x4d0,%ymm0\n               vpxor        %xmm11,%xmm11,%xmm11\n               mov          $0xf4240,%eax\n               vpbroadcastq 0x1d5b31(%rip),%ymm1        # 22d8a0 &lt;anon.b26f45dd7d0ea1d60480ae6c3c88753d.34.llvm.65588711349491208+0x4f0&gt;\n               vmovdqu      %ymm1,(%rsp)\n               vpbroadcastq 0x1d5b2b(%rip),%ymm2        # 22d8a8 &lt;anon.b26f45dd7d0ea1d60480ae6c3c88753d.34.llvm.65588711349491208+0x4f8&gt;\n               vpbroadcastq 0x1d5b2a(%rip),%ymm3        # 22d8b0 &lt;anon.b26f45dd7d0ea1d60480ae6c3c88753d.34.llvm.65588711349491208+0x500&gt;\n               vpbroadcastq 0x1d5b29(%rip),%ymm4        # 22d8b8 &lt;anon.b26f45dd7d0ea1d60480ae6c3c88753d.34.llvm.65588711349491208+0x508&gt;\n               vpbroadcastq 0x1d5b28(%rip),%ymm5        # 22d8c0 &lt;anon.b26f45dd7d0ea1d60480ae6c3c88753d.34.llvm.65588711349491208+0x510&gt;\n               vpbroadcastq 0x1d5b27(%rip),%ymm6        # 22d8c8 &lt;anon.b26f45dd7d0ea1d60480ae6c3c88753d.34.llvm.65588711349491208+0x518&gt;\n               vpbroadcastq 0x1d5b26(%rip),%ymm7        # 22d8d0 &lt;anon.b26f45dd7d0ea1d60480ae6c3c88753d.34.llvm.65588711349491208+0x520&gt;\n               vpbroadcastq 0x1d5b25(%rip),%ymm8        # 22d8d8 &lt;anon.b26f45dd7d0ea1d60480ae6c3c88753d.34.llvm.65588711349491208+0x528&gt;\n               vpbroadcastq 0x1d5b24(%rip),%ymm9        # 22d8e0 &lt;anon.b26f45dd7d0ea1d60480ae6c3c88753d.34.llvm.65588711349491208+0x530&gt;\n               vpbroadcastq 0x1d5b23(%rip),%ymm10        # 22d8e8 &lt;anon.b26f45dd7d0ea1d60480ae6c3c88753d.34.llvm.65588711349491208+0x538&gt;\n               vpxor        %xmm12,%xmm12,%xmm12\n               vpxor        %xmm13,%xmm13,%xmm13\n               vpxor        %xmm14,%xmm14,%xmm14\n               data16       data16 cs nopw 0x0(%rax,%rax,1)\n  1,34   90:   vpand        %ymm4,%ymm0,%ymm15\n  3,66         vpcmpeqq     %ymm5,%ymm15,%ymm1\n  3,04         vpandn       %ymm15,%ymm1,%ymm1\n  0,96         vpaddq       (%rsp),%ymm0,%ymm15\n  1,25         vpand        %ymm4,%ymm15,%ymm15\n  3,51         vpaddq       %ymm1,%ymm11,%ymm1\n  2,94         vpcmpeqq     %ymm5,%ymm15,%ymm11\n  2,25         vpandn       %ymm15,%ymm11,%ymm11\n  0,80         vpaddq       %ymm2,%ymm0,%ymm15\n  3,11         vpand        %ymm4,%ymm15,%ymm15\n  3,38         vpaddq       %ymm12,%ymm11,%ymm12\n  2,45         vpcmpeqq     %ymm5,%ymm15,%ymm11\n  1,73         vpandn       %ymm15,%ymm11,%ymm11\n  1,92         vpaddq       %ymm3,%ymm0,%ymm15\n  2,93         vpand        %ymm4,%ymm15,%ymm15\n  4,20         vpaddq       %ymm13,%ymm11,%ymm13\n  1,64         vpcmpeqq     %ymm5,%ymm15,%ymm11\n  2,02         vpandn       %ymm15,%ymm11,%ymm11\n  4,99         vpaddq       %ymm14,%ymm11,%ymm14\n  2,13         vpaddq       %ymm6,%ymm0,%ymm11\n  0,66         vpand        %ymm4,%ymm11,%ymm11\n  1,97         vpcmpeqq     %ymm5,%ymm11,%ymm15\n  4,79         vpandn       %ymm11,%ymm15,%ymm11\n  1,72         vpaddq       %ymm7,%ymm0,%ymm15\n  0,67         vpand        %ymm4,%ymm15,%ymm15\n  2,54         vpaddq       %ymm1,%ymm11,%ymm11\n  3,66         vpcmpeqq     %ymm5,%ymm15,%ymm1\n  2,39         vpandn       %ymm15,%ymm1,%ymm1\n  0,42         vpaddq       %ymm0,%ymm8,%ymm15\n  2,02         vpand        %ymm4,%ymm15,%ymm15\n  4,75         vpaddq       %ymm1,%ymm12,%ymm12\n  2,23         vpcmpeqq     %ymm5,%ymm15,%ymm1\n  1,99         vpandn       %ymm15,%ymm1,%ymm1\n  1,44         vpaddq       %ymm0,%ymm9,%ymm15\n  3,94         vpand        %ymm4,%ymm15,%ymm15\n  4,01         vpaddq       %ymm1,%ymm13,%ymm13\n  1,84         vpcmpeqq     %ymm5,%ymm15,%ymm1\n  1,90         vpandn       %ymm15,%ymm1,%ymm1\n  3,97         vpaddq       %ymm1,%ymm14,%ymm14\n  1,96         vpaddq       %ymm0,%ymm10,%ymm0\n  0,00         add          $0xffffffffffffffe0,%rax\n  0,84       ↑ jne          90\n  0,00         vpaddq       %ymm11,%ymm12,%ymm0\n  0,00         vpaddq       %ymm0,%ymm13,%ymm0\n               vpaddq       %ymm0,%ymm14,%ymm0\n               vextracti128 $0x1,%ymm0,%xmm1\n               vpaddq       %xmm1,%xmm0,%xmm0\n               vpshufd      $0xee,%xmm0,%xmm1\n  0,00         vpaddq       %xmm1,%xmm0,%xmm0\n               vmovq        %xmm0,%rax\n               add          $0x38,%rsp\n               vzeroupper     \n  0,00       ← ret            \n\n</pre>\n\n<p>The loop got nicely vectorised and there are no branches inside the body of the loop either.\nIt is a bit longer, but it does more per each cycle of the loop and needs fewer cycles.</p>\n\n<h1 id=\"conclusions\">Conclusions</h1>\n<ul>\n  <li>Using <code class=\"language-plaintext highlighter-rouge\">Optional</code> values in an extremely performance sensitive Java code is likely a bad idea. All JVMs tested here failed to optimize them out.</li>\n  <li>Wrapping primitives in <code class=\"language-plaintext highlighter-rouge\">Optional</code> caused up to 8x speed degradation and increased allocation rate significantly. Escape analysis optimization failed.</li>\n  <li>Avoid boxing numbers and nulls in Java as well. More recent JVMs seem to cope with them better, but none managed to get rid of the overhead totally.</li>\n  <li>The most ugly and error-prone solution turned out to be the fastest: primitive types and magic values.</li>\n  <li>Don’t count on JVM taking advantage of knowing the target CPU and utilizing modern instruction sets like AVX automatically. \nActually even the <code class=\"language-plaintext highlighter-rouge\">sumSimple</code> hasn’t been vectorized here, despite being a textbook case for vectorization.</li>\n  <li>Knowing the actual performance profile of the program didn’t give JVM any edge here either.</li>\n  <li>Fortunately, the advice above does not apply to Rust. Rust <code class=\"language-plaintext highlighter-rouge\">Option</code> is zero-cost in most cases and, even without inlining, the added cost is tiny. \nYou don’t have to trade code readability nor safety to gain speed.</li>\n  <li>Rust code returning <code class=\"language-plaintext highlighter-rouge\">Option</code> optimized for my CPU was over <strong>30x</strong> faster than Java code returning <code class=\"language-plaintext highlighter-rouge\">Optional</code>, \nand still over <strong>10x</strong> faster if compiled in a portable way with default settings and no vectorization.</li>\n  <li>Quite surprisingly, even the pessimized version of Rust code forced to allocate the <code class=\"language-plaintext highlighter-rouge\">Option</code> on heap with no inlining was still faster than JVM doing the same. \nIs manual heap allocation not really slower than GC-based allocation? Probably a topic for another blog post.</li>\n  <li>Languages and their compilers vastly differ in optimization strength. Don’t assume all languages that can compile to machine code are the same.</li>\n</ul>\n\n<p>Disclaimer: Do measure performance by yourself and don’t assume particular optimizations will / won’t take place because you saw someone mentioning them in the blog post.\nYMMV.</p>",
  "author": {
    "name": "Piotr Kołaczkowski"
  },
  "category": [
    "",
    "",
    "",
    ""
  ],
  "summary": "Some programming languages like Java or Scala offer more than one way to express a concept of “lack of value”. Traditionally, a special null value is used to denote references that don’t reference any value at all. However, over time we have learned that using nulls can be very error-prone and can cause many troubles like NullPointerException errors crashing a program in the most unexpected moment. Therefore, modern programming style recommends avoiding nulls wherever possible in favor of a much better Option, Optional or Maybe data type (called differently in many languages, but the concept is the same). Unfortunately, it is believed that optional values in Java may come with a performance penalty. In this blog post, I’ll try to answer whether it is true, and if the performance penalty really exists, how serious it is."
}