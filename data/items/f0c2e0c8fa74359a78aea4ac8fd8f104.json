{
  "title": "Python Data Structures are Fast",
  "link": "",
  "updated": "2014-05-01T00:00:00+00:00",
  "id": "https://mrocklin.github.io/blog/work/2014/05/01/Fast-Data-Structures",
  "content": "<p><strong>tl;dr: Our intuition that Python is slow is often incorrect.  Data structure\nbound Python computations are fast.</strong></p>\n\n<p>You may also want to see the companion post, <a href=\"https://matthewrocklin.com/blog/work/2014/05/01/Introducing-CyToolz\">Introducing\nCyToolz</a>.</p>\n\n<h2 id=\"we-think-that-python-is-slow\">We think that Python is slow</h2>\n\n<p>Our intuition says that Python is slow:</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># Python speeds\n</span><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">L</span> <span class=\"o\">=</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">1000000</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">timeit</span> <span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">)</span>\n<span class=\"n\">timeit</span> <span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">s100</span> <span class=\"n\">loops</span><span class=\"p\">,</span> <span class=\"n\">best</span> <span class=\"n\">of</span> <span class=\"mi\">3</span><span class=\"p\">:</span> <span class=\"mf\">7.79</span> <span class=\"n\">ms</span> <span class=\"n\">per</span> <span class=\"n\">loop</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># C speeds\n</span><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"n\">np</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">A</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"mi\">1000000</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">timeit</span> <span class=\"n\">np</span><span class=\"p\">.</span><span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">)</span>\n<span class=\"mi\">1000</span> <span class=\"n\">loops</span><span class=\"p\">,</span> <span class=\"n\">best</span> <span class=\"n\">of</span> <span class=\"mi\">3</span><span class=\"p\">:</span> <span class=\"mi\">725</span> <span class=\"n\">µs</span> <span class=\"n\">per</span> <span class=\"n\">loop</span></code></pre>\n</figure>\n\n<p>Numerical Python with lots of loops is much slower than the equivalent C or\nJava code.  For this we use one of the numeric projects like NumPy, Cython,\nTheano, or Numba.</p>\n\n<h2 id=\"but-that-only-applies-to-normally-cheap-operations\">But that only applies to normally cheap operations</h2>\n\n<p>This slowdown occurs for cheap operations for which the Python overhead\nis large relative to their cost in C.  However for more complex operations,\nlike data structure random access, this overhead is less important.  Consider\nthe relative difference between integer addition and dictionary assignment.</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">3</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">timeit</span> <span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">y</span>\n<span class=\"mi\">10000000</span> <span class=\"n\">loops</span><span class=\"p\">,</span> <span class=\"n\">best</span> <span class=\"n\">of</span> <span class=\"mi\">3</span><span class=\"p\">:</span> <span class=\"mf\">43.7</span> <span class=\"n\">ns</span> <span class=\"n\">per</span> <span class=\"n\">loop</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">d</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"mi\">1</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">:</span> <span class=\"mi\">2</span><span class=\"p\">}</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">timeit</span> <span class=\"n\">d</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">y</span>\n<span class=\"mi\">10000000</span> <span class=\"n\">loops</span><span class=\"p\">,</span> <span class=\"n\">best</span> <span class=\"n\">of</span> <span class=\"mi\">3</span><span class=\"p\">:</span> <span class=\"mf\">65.7</span> <span class=\"n\">ns</span> <span class=\"n\">per</span> <span class=\"n\">loop</span></code></pre>\n</figure>\n\n<p>A Python dictionary assignment is about as fast as a Python add.</p>\n\n<p><em>Disclaimer: this benchmark gets a point across but is is very artificial,\nmicro-benchmarks like this are hard to do well.</em></p>\n\n<h2 id=\"micro-benchmark-frequency-counting\">Micro-Benchmark: Frequency Counting</h2>\n\n<p><em>Warning: cherry-picked</em></p>\n\n<p>To really show off the speed of Python data structures lets count frequencies\nof strings.  I.e. given a long list of strings</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s\">'Alice'</span><span class=\"p\">,</span> <span class=\"s\">'Bob'</span><span class=\"p\">,</span> <span class=\"s\">'Charlie'</span><span class=\"p\">,</span> <span class=\"s\">'Dan'</span><span class=\"p\">,</span> <span class=\"s\">'Edith'</span><span class=\"p\">,</span> <span class=\"s\">'Frank'</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"mi\">1000000</span></code></pre>\n</figure>\n\n<p>We want to count the occurence of each name.  In principle we would write a\nlittle function like <code class=\"language-plaintext highlighter-rouge\">frequencies</code></p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"k\">def</span> <span class=\"nf\">frequencies</span><span class=\"p\">(</span><span class=\"n\">seq</span><span class=\"p\">):</span>\n    <span class=\"s\">\"\"\" Count the number of occurences of each element in seq \"\"\"</span>\n    <span class=\"n\">d</span> <span class=\"o\">=</span> <span class=\"nb\">dict</span><span class=\"p\">()</span>\n    <span class=\"k\">for</span> <span class=\"n\">item</span> <span class=\"ow\">in</span> <span class=\"n\">seq</span><span class=\"p\">:</span>\n        <span class=\"k\">if</span> <span class=\"n\">item</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"n\">d</span><span class=\"p\">:</span>\n            <span class=\"n\">d</span><span class=\"p\">[</span><span class=\"n\">item</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"n\">d</span><span class=\"p\">[</span><span class=\"n\">item</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">d</span><span class=\"p\">[</span><span class=\"n\">item</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"mi\">1</span>\n    <span class=\"k\">return</span> <span class=\"n\">d</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">frequencies</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">)</span>\n<span class=\"p\">{</span><span class=\"s\">'Alice'</span><span class=\"p\">:</span> <span class=\"mi\">1000000</span><span class=\"p\">,</span>\n <span class=\"s\">'Bob'</span><span class=\"p\">:</span> <span class=\"mi\">1000000</span><span class=\"p\">,</span>\n <span class=\"s\">'Charlie'</span><span class=\"p\">:</span> <span class=\"mi\">1000000</span><span class=\"p\">,</span>\n <span class=\"s\">'Dan'</span><span class=\"p\">:</span> <span class=\"mi\">1000000</span><span class=\"p\">,</span>\n <span class=\"s\">'Edith'</span><span class=\"p\">:</span> <span class=\"mi\">1000000</span><span class=\"p\">,</span>\n <span class=\"s\">'Frank'</span><span class=\"p\">:</span> <span class=\"mi\">1000000</span><span class=\"p\">}</span></code></pre>\n</figure>\n\n<p>This simple operation tests grouping reductions on non-numerical data.\nThis represents an emerging class of problems that doesn’t fit our\nperformance intuition from our history with numerics.</p>\n\n<p>We compare the naive <code class=\"language-plaintext highlighter-rouge\">frequencies</code> function against the following equivalent implementations</p>\n\n<ul>\n  <li>The standard library’s <code class=\"language-plaintext highlighter-rouge\">collections.Counter</code></li>\n  <li>PyToolz’ benchmarked and tuned <code class=\"language-plaintext highlighter-rouge\">frequencies</code> operation</li>\n  <li>Pandas’ <code class=\"language-plaintext highlighter-rouge\">Series.value_counts</code> method</li>\n  <li>A naive implementation in Java, found <a href=\"https://gist.github.com/mrocklin/3a774401288a5aad12c6\">here</a></li>\n</ul>\n\n<p>We present the results from worst to best:</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">timeit</span> <span class=\"n\">collections</span><span class=\"p\">.</span><span class=\"n\">Counter</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">)</span>        <span class=\"mf\">1.59</span>  <span class=\"n\">s</span>     <span class=\"c1\"># Standard Lib\n</span><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">timeit</span> <span class=\"n\">frequencies</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">)</span>                 <span class=\"mi\">805</span> <span class=\"n\">ms</span>     <span class=\"c1\"># Naive Python\n</span><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">timeit</span> <span class=\"n\">toolz</span><span class=\"p\">.</span><span class=\"n\">frequencies</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">)</span>           <span class=\"mi\">522</span> <span class=\"n\">ms</span>     <span class=\"c1\"># Tuned Python\n</span><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">series</span> <span class=\"o\">=</span> <span class=\"n\">Series</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">timeit</span> <span class=\"n\">series</span><span class=\"p\">.</span><span class=\"n\">value_counts</span><span class=\"p\">()</span>             <span class=\"mi\">286</span> <span class=\"n\">ms</span>     <span class=\"c1\"># Pandas</span></code></pre>\n</figure>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>$ java Frequencies                           207 ms     # Straight Java\n</code></pre></div></div>\n\n<p>Lets observe the following:</p>\n\n<ul>\n  <li>The standard library <code class=\"language-plaintext highlighter-rouge\">collections.Counter</code> performs surprisingly poorly.\nThis is unfair because the <code class=\"language-plaintext highlighter-rouge\">Counter</code> object is more complex,\nproviding more exotic functionality that we don’t use here.</li>\n  <li>The Pandas solution uses C code and C data structures to beat the Python\nsolution, but not by a huge amount.  This isn’t the 10x-100x speedup that\nwe expect from numerical applications.</li>\n  <li>The <code class=\"language-plaintext highlighter-rouge\">toolz.frequencies</code> function improves on the standard Python solution\nand gets to within a factor of 2x of Pandas.   The PyToolz development team\nhas benchmarked and tuned several implementatations.  I believe that this is\nthe <a href=\"http://toolz.readthedocs.org/en/latest/_modules/toolz/itertoolz.html#frequencies\">fastest solution available</a> in Pure Python.</li>\n  <li>The compiled <a href=\"https://gist.github.com/mrocklin/3a774401288a5aad12c6\">Java Solution</a>\nis generally fast but, as with the Pandas case it’s not <em>that</em> much faster.</li>\n</ul>\n\n<p>For data structure bound computations, like frequency counting, Python is\ngenerally fast enough for me.  I’m willing to pay a 2x cost in order to gain\naccess to Pure Python’s streaming data structures and low entry cost.</p>\n\n<h2 id=\"cytoolz\">CyToolz</h2>\n\n<p>Personally, I’m fine with fast Python speeds.  Erik Welch on the other hand,\nwanted unreasonably fast C speeds so he rewrote <code class=\"language-plaintext highlighter-rouge\">toolz</code> in Cython;  he calls it\n<a href=\"http://github.com/pytoolz/cytoolz/\">CyToolz</a>.  His results are pretty amazing.</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># import toolz\n</span><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">cytoolz</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">timeit</span> <span class=\"n\">toolz</span><span class=\"p\">.</span><span class=\"n\">frequencies</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">)</span>           <span class=\"mi\">522</span> <span class=\"n\">ms</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">timeit</span> <span class=\"n\">series</span><span class=\"p\">.</span><span class=\"n\">value_counts</span><span class=\"p\">()</span>             <span class=\"mi\">286</span> <span class=\"n\">ms</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">timeit</span> <span class=\"n\">cytoolz</span><span class=\"p\">.</span><span class=\"n\">frequencies</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">)</span>         <span class=\"mi\">214</span> <span class=\"n\">ms</span></code></pre>\n</figure>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>$ java Frequencies                           207 ms\n</code></pre></div></div>\n\n<p>CyToolz actually beats the Pandas solution (in this one particular benchmark.)  Lets appreciate this for a moment.</p>\n\n<p>Cython on raw Python data structures runs at Java speeds.  We discuss CyToolz\nfurther in <a href=\"http://matthewrocklin.com/blog/work/2014/05/01/Introducing-CyToolz/\">our next blog\npost</a></p>\n\n<h2 id=\"conclusion\">Conclusion</h2>\n\n<p>We learn that data structure bound computations aren’t as slow in Python as we\nmight think.  Although we incur a small slowdown (2x-5x), probably due to\nPython method dispatching, this can be avoided through Cython. When using\nCython, the use of Python data structures can match perofrmance we expect from\ncompiled languages like Java.</p>"
}