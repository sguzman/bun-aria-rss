{
  "id": "tag:blogger.com,1999:blog-6894866515532737257.post-2647822839967657501",
  "published": "2017-04-26T12:12:00.002-07:00",
  "updated": "2017-04-26T14:07:19.523-07:00",
  "title": "Python as a way of thinking",
  "content": "<style type=\"text/css\">.highlight{background: #f8f8f8; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .1em;padding:0em .5em;border-radius: 4px;} .k{color: #338822; font-weight: bold;} .kn{color: #338822; font-weight: bold;} .mi{color: #000000;} .o{color: #000000;} .ow{color: #BA22FF;  font-weight: bold;} .nb{color: #338822;} .n{color: #000000;} .s{color: #cc2222;} .se{color: #cc2222; font-weight: bold;} .si{color: #C06688; font-weight: bold;} .nn{color: #4D00FF; font-weight: bold;} </style>This article contains supporting material for <a href=\"https://blogs.scientificamerican.com/guest-blog/programming-as-a-way-of-thinking/?WT.mc_id=SA_TW_TECH_BLOG\">this blog post at&nbsp;<i>Scientific American</i></a>. &nbsp;The thesis of the post is that modern programming languages (like Python) are qualitatively different from the first generation (like FORTRAN and C), in ways that make them effective tools for teaching, learning, exploring, and thinking.<br /><br />I presented a longer version of this argument in a talk I presented at Olin College last fall. &nbsp;The slides are here:<br /><br /><iframe allowfullscreen=\"true\" frameborder=\"0\" height=\"389\" mozallowfullscreen=\"true\" src=\"https://docs.google.com/presentation/d/1BBFHUUcaliCAYpU5uMrNVGBvSrm30VAFkqC5heolZ3I/embed?start=false&amp;loop=false&amp;delayms=3000\" webkitallowfullscreen=\"true\" width=\"480\"></iframe> <br /><br /><br />Here are Jupyter notebooks with the code examples I mentioned in the talk:<br /><ul><li><a href=\"https://github.com/AllenDowney/ProbablyOverthinkingIt/blob/master/bfs_example.ipynb\">Breadth-first search in Python</a></li><li><a href=\"https://github.com/AllenDowney/PythonCounterPmf/blob/master/PythonCounterPmf.ipynb\">Using Counters</a>, including the Bayesian update example.</li><li><a href=\"https://github.com/AllenDowney/CompStats/blob/master/pmf_intro.ipynb\">Introduction to PMFs</a>, including the anagram example.</li><li><a href=\"https://github.com/AllenDowney/ProbablyOverthinkingIt/blob/master/frame_example.ipynb\">Vectors, Frames, and Transforms</a>.</li><li><a href=\"https://nbviewer.jupyter.org/github/AllenDowney/ThinkDSP/blob/master/code/cacophony.ipynb\">Cacophony for the Whole Family</a>, an example from <i>Think DSP</i>.</li></ul><div><br /></div><div>Here's my presentation at SciPy 2015, where I talked more about Python as a way of teaching and learning DSP:</div><div><br /></div><div class=\"separator\" style=\"clear: both; text-align: center;\"><iframe allowfullscreen=\"\" class=\"YOUTUBE-iframe-video\" data-thumbnail-src=\"https://i.ytimg.com/vi/0ALKGR0I5MA/0.jpg\" frameborder=\"0\" height=\"266\" src=\"https://www.youtube.com/embed/0ALKGR0I5MA?feature=player_embedded\" width=\"320\"></iframe></div><div class=\"separator\" style=\"clear: both; text-align: center;\"><br /></div><div class=\"separator\" style=\"clear: both; text-align: center;\"><br /></div><div>Finally, here's the notebook \"Using Counters\", which uses Python's Counter object to implement a PMF (probability mass function) and perform Bayesian updates.</div><div><br /></div><div></div><div class=\"cell border-box-sizing code_cell rendered\"><div class=\"input\"><div class=\"prompt input_prompt\">In&nbsp;[13]:</div><div class=\"inner_cell\"><div class=\"input_area\"><div class=\" highlight hl-ipython2\"><pre><span class=\"kn\">from</span> <span class=\"nn\">__future__</span> <span class=\"kn\">import</span> <span class=\"n\">print_function</span><span class=\"p\">,</span> <span class=\"n\">division</span><br /><br /><span class=\"kn\">from</span> <span class=\"nn\">collections</span> <span class=\"kn\">import</span> <span class=\"n\">Counter</span><br /><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"kn\">as</span> <span class=\"nn\">np</span><br /></pre></div></div></div></div></div><div class=\"cell border-box-sizing text_cell rendered\"><div class=\"prompt input_prompt\"></div><div class=\"inner_cell\"><div class=\"text_cell_render border-box-sizing rendered_html\">A counter is a map from values to their frequencies.  If you initialize a counter with a string, you get a map from each letter to the number of times it appears.  If two words are anagrams, they yield equal Counters, so you can use Counters to test anagrams in linear time.</div></div></div><div class=\"cell border-box-sizing code_cell rendered\"><div class=\"input\"><div class=\"prompt input_prompt\">In&nbsp;[3]:</div><div class=\"inner_cell\"><div class=\"input_area\"><div class=\" highlight hl-ipython2\"><pre><span class=\"k\">def</span> <span class=\"nf\">is_anagram</span><span class=\"p\">(</span><span class=\"n\">word1</span><span class=\"p\">,</span> <span class=\"n\">word2</span><span class=\"p\">):</span><br />    <span class=\"sd\">\"\"\"Checks whether the words are anagrams.</span><br /><br /><span class=\"sd\">    word1: string</span><br /><span class=\"sd\">    word2: string</span><br /><br /><span class=\"sd\">    returns: boolean</span><br /><span class=\"sd\">    \"\"\"</span><br />    <span class=\"k\">return</span> <span class=\"n\">Counter</span><span class=\"p\">(</span><span class=\"n\">word1</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"n\">Counter</span><span class=\"p\">(</span><span class=\"n\">word2</span><span class=\"p\">)</span><br /></pre></div></div></div></div></div><div class=\"cell border-box-sizing code_cell rendered\"><div class=\"input\"><div class=\"prompt input_prompt\">In&nbsp;[4]:</div><div class=\"inner_cell\"><div class=\"input_area\"><div class=\" highlight hl-ipython2\"><pre><span class=\"n\">is_anagram</span><span class=\"p\">(</span><span class=\"s1\">'tachymetric'</span><span class=\"p\">,</span> <span class=\"s1\">'mccarthyite'</span><span class=\"p\">)</span><br /></pre></div></div></div></div><div class=\"output_wrapper\"><div class=\"output\"><div class=\"output_area\"><div class=\"prompt output_prompt\">Out[4]:</div><div class=\"output_text output_subarea output_execute_result\"><pre>True</pre></div></div></div></div></div><div class=\"cell border-box-sizing code_cell rendered\"><div class=\"input\"><div class=\"prompt input_prompt\">In&nbsp;[5]:</div><div class=\"inner_cell\"><div class=\"input_area\"><div class=\" highlight hl-ipython2\"><pre><span class=\"n\">is_anagram</span><span class=\"p\">(</span><span class=\"s1\">'banana'</span><span class=\"p\">,</span> <span class=\"s1\">'peach'</span><span class=\"p\">)</span><br /></pre></div></div></div></div><div class=\"output_wrapper\"><div class=\"output\"><div class=\"output_area\"><div class=\"prompt output_prompt\">Out[5]:</div><div class=\"output_text output_subarea output_execute_result\"><pre>False</pre></div></div></div></div></div><div class=\"cell border-box-sizing text_cell rendered\"><div class=\"prompt input_prompt\"></div><div class=\"inner_cell\"><div class=\"text_cell_render border-box-sizing rendered_html\"><strong>Multisets</strong><br />A Counter is a natural representation of a multiset, which is a set where the elements can appear more than once.  You can extend Counter with set operations like is_subset:</div></div></div><div class=\"cell border-box-sizing code_cell rendered\"><div class=\"input\"><div class=\"prompt input_prompt\">In&nbsp;[6]:</div><div class=\"inner_cell\"><div class=\"input_area\"><div class=\" highlight hl-ipython2\"><pre><span class=\"k\">class</span> <span class=\"nc\">Multiset</span><span class=\"p\">(</span><span class=\"n\">Counter</span><span class=\"p\">):</span><br />    <span class=\"sd\">\"\"\"A multiset is a set where elements can appear more than once.\"\"\"</span><br /><br />    <span class=\"k\">def</span> <span class=\"nf\">is_subset</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">other</span><span class=\"p\">):</span><br />        <span class=\"sd\">\"\"\"Checks whether self is a subset of other.</span><br /><br /><span class=\"sd\">        other: Multiset</span><br /><br /><span class=\"sd\">        returns: boolean</span><br /><span class=\"sd\">        \"\"\"</span><br />        <span class=\"k\">for</span> <span class=\"n\">char</span><span class=\"p\">,</span> <span class=\"n\">count</span> <span class=\"ow\">in</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">():</span><br />            <span class=\"k\">if</span> <span class=\"n\">other</span><span class=\"p\">[</span><span class=\"n\">char</span><span class=\"p\">]</span> <span class=\"o\">&lt;</span> <span class=\"n\">count</span><span class=\"p\">:</span><br />                <span class=\"k\">return</span> <span class=\"bp\">False</span><br />        <span class=\"k\">return</span> <span class=\"bp\">True</span><br />    <br />    <span class=\"c1\"># map the &lt;= operator to is_subset</span><br />    <span class=\"n\">__le__</span> <span class=\"o\">=</span> <span class=\"n\">is_subset</span><br /></pre></div></div></div></div></div><div class=\"cell border-box-sizing text_cell rendered\"><div class=\"prompt input_prompt\"></div><div class=\"inner_cell\"><div class=\"text_cell_render border-box-sizing rendered_html\">You could use <tt>is_subset</tt> in a game like Scrabble to see if a given set of tiles can be used to spell a given word.</div></div></div><div class=\"cell border-box-sizing code_cell rendered\"><div class=\"input\"><div class=\"prompt input_prompt\">In&nbsp;[7]:</div><div class=\"inner_cell\"><div class=\"input_area\"><div class=\" highlight hl-ipython2\"><pre><span class=\"k\">def</span> <span class=\"nf\">can_spell</span><span class=\"p\">(</span><span class=\"n\">word</span><span class=\"p\">,</span> <span class=\"n\">tiles</span><span class=\"p\">):</span><br />    <span class=\"sd\">\"\"\"Checks whether a set of tiles can spell a word.</span><br /><br /><span class=\"sd\">    word: string</span><br /><span class=\"sd\">    tiles: string</span><br /><br /><span class=\"sd\">    returns: boolean</span><br /><span class=\"sd\">    \"\"\"</span><br />    <span class=\"k\">return</span> <span class=\"n\">Multiset</span><span class=\"p\">(</span><span class=\"n\">word</span><span class=\"p\">)</span> <span class=\"o\">&lt;=</span> <span class=\"n\">Multiset</span><span class=\"p\">(</span><span class=\"n\">tiles</span><span class=\"p\">)</span><br /></pre></div></div></div></div></div><div class=\"cell border-box-sizing code_cell rendered\"><div class=\"input\"><div class=\"prompt input_prompt\">In&nbsp;[8]:</div><div class=\"inner_cell\"><div class=\"input_area\"><div class=\" highlight hl-ipython2\"><pre><span class=\"n\">can_spell</span><span class=\"p\">(</span><span class=\"s1\">'SYZYGY'</span><span class=\"p\">,</span> <span class=\"s1\">'AGSYYYZ'</span><span class=\"p\">)</span><br /></pre></div></div></div></div><div class=\"output_wrapper\"><div class=\"output\"><div class=\"output_area\"><div class=\"prompt output_prompt\">Out[8]:</div><div class=\"output_text output_subarea output_execute_result\"><pre>True</pre></div></div></div></div></div><div class=\"cell border-box-sizing text_cell rendered\"><div class=\"prompt input_prompt\"></div><div class=\"inner_cell\"><div class=\"text_cell_render border-box-sizing rendered_html\"><h2 id=\"Probability-Mass-Functions\">Probability Mass Functions<a class=\"anchor-link\" href=\"https://www.blogger.com/blogger.g?blogID=6894866515532737257#Probability-Mass-Functions\">¶</a></h2>You can also extend Counter to represent a probability mass function (PMF).<br /><code>normalize</code> computes the total of the frequencies and divides through, yielding probabilities that add to 1.<br /><code>__add__</code> enumerates all pairs of value and returns a new Pmf that represents the distribution of the sum.<br /><code>__hash__</code> and <code>__id__</code> make Pmfs hashable; this is not the best way to do it, because they are mutable.  So this implementation comes with a warning that if you use a Pmf as a key, you should not modify it.  A better alternative would be to define a frozen Pmf.<br /><code>render</code> returns the values and probabilities in a form ready for plotting</div></div></div><div class=\"cell border-box-sizing code_cell rendered\"><div class=\"input\"><div class=\"prompt input_prompt\">In&nbsp;[9]:</div><div class=\"inner_cell\"><div class=\"input_area\"><div class=\" highlight hl-ipython2\"><pre><span class=\"k\">class</span> <span class=\"nc\">Pmf</span><span class=\"p\">(</span><span class=\"n\">Counter</span><span class=\"p\">):</span><br />    <span class=\"sd\">\"\"\"A Counter with probabilities.\"\"\"</span><br /><br />    <span class=\"k\">def</span> <span class=\"nf\">normalize</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span><br />        <span class=\"sd\">\"\"\"Normalizes the PMF so the probabilities add to 1.\"\"\"</span><br />        <span class=\"n\">total</span> <span class=\"o\">=</span> <span class=\"nb\">float</span><span class=\"p\">(</span><span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">values</span><span class=\"p\">()))</span><br />        <span class=\"k\">for</span> <span class=\"n\">key</span> <span class=\"ow\">in</span> <span class=\"bp\">self</span><span class=\"p\">:</span><br />            <span class=\"bp\">self</span><span class=\"p\">[</span><span class=\"n\">key</span><span class=\"p\">]</span> <span class=\"o\">/=</span> <span class=\"n\">total</span><br /><br />    <span class=\"k\">def</span> <span class=\"nf\">__add__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">other</span><span class=\"p\">):</span><br />        <span class=\"sd\">\"\"\"Adds two distributions.</span><br /><br /><span class=\"sd\">        The result is the distribution of sums of values from the</span><br /><span class=\"sd\">        two distributions.</span><br /><br /><span class=\"sd\">        other: Pmf</span><br /><br /><span class=\"sd\">        returns: new Pmf</span><br /><span class=\"sd\">        \"\"\"</span><br />        <span class=\"n\">pmf</span> <span class=\"o\">=</span> <span class=\"n\">Pmf</span><span class=\"p\">()</span><br />        <span class=\"k\">for</span> <span class=\"n\">key1</span><span class=\"p\">,</span> <span class=\"n\">prob1</span> <span class=\"ow\">in</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">():</span><br />            <span class=\"k\">for</span> <span class=\"n\">key2</span><span class=\"p\">,</span> <span class=\"n\">prob2</span> <span class=\"ow\">in</span> <span class=\"n\">other</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">():</span><br />                <span class=\"n\">pmf</span><span class=\"p\">[</span><span class=\"n\">key1</span> <span class=\"o\">+</span> <span class=\"n\">key2</span><span class=\"p\">]</span> <span class=\"o\">+=</span> <span class=\"n\">prob1</span> <span class=\"o\">*</span> <span class=\"n\">prob2</span><br />        <span class=\"k\">return</span> <span class=\"n\">pmf</span><br /><br />    <span class=\"k\">def</span> <span class=\"nf\">__hash__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span><br />        <span class=\"sd\">\"\"\"Returns an integer hash value.\"\"\"</span><br />        <span class=\"k\">return</span> <span class=\"nb\">id</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span><br />    <br />    <span class=\"k\">def</span> <span class=\"nf\">__eq__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">other</span><span class=\"p\">):</span><br />        <span class=\"k\">return</span> <span class=\"bp\">self</span> <span class=\"ow\">is</span> <span class=\"n\">other</span><br /><br />    <span class=\"k\">def</span> <span class=\"nf\">render</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span><br />        <span class=\"sd\">\"\"\"Returns values and their probabilities, suitable for plotting.\"\"\"</span><br />        <span class=\"k\">return</span> <span class=\"nb\">zip</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"nb\">sorted</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">()))</span><br /></pre></div></div></div></div></div><div class=\"cell border-box-sizing text_cell rendered\"><div class=\"prompt input_prompt\"></div><div class=\"inner_cell\"><div class=\"text_cell_render border-box-sizing rendered_html\">As an example, we can make a Pmf object that represents a 6-sided die.</div></div></div><div class=\"cell border-box-sizing code_cell rendered\"><div class=\"input\"><div class=\"prompt input_prompt\">In&nbsp;[10]:</div><div class=\"inner_cell\"><div class=\"input_area\"><div class=\" highlight hl-ipython2\"><pre><span class=\"n\">d6</span> <span class=\"o\">=</span> <span class=\"n\">Pmf</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">4</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">,</span><span class=\"mi\">6</span><span class=\"p\">])</span><br /><span class=\"n\">d6</span><span class=\"o\">.</span><span class=\"n\">normalize</span><span class=\"p\">()</span><br /><span class=\"n\">d6</span><span class=\"o\">.</span><span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"s1\">'one die'</span><br /><span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">d6</span><span class=\"p\">)</span><br /></pre></div></div></div></div><div class=\"output_wrapper\"><div class=\"output\"><div class=\"output_area\"><div class=\"prompt\"></div><div class=\"output_subarea output_stream output_stdout output_text\"><pre>Pmf({1: 0.16666666666666666, 2: 0.16666666666666666, 3: 0.16666666666666666, 4: 0.16666666666666666, 5: 0.16666666666666666, 6: 0.16666666666666666})<br /></pre></div></div></div></div></div><div class=\"cell border-box-sizing text_cell rendered\"><div class=\"prompt input_prompt\"></div><div class=\"inner_cell\"><div class=\"text_cell_render border-box-sizing rendered_html\">Using the add operator, we can compute the distribution for the sum of two dice.</div></div></div><div class=\"cell border-box-sizing code_cell rendered\"><div class=\"input\"><div class=\"prompt input_prompt\">In&nbsp;[11]:</div><div class=\"inner_cell\"><div class=\"input_area\"><div class=\" highlight hl-ipython2\"><pre><span class=\"n\">d6_twice</span> <span class=\"o\">=</span> <span class=\"n\">d6</span> <span class=\"o\">+</span> <span class=\"n\">d6</span><br /><span class=\"n\">d6_twice</span><span class=\"o\">.</span><span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"s1\">'two dice'</span><br /><br /><span class=\"k\">for</span> <span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"n\">prob</span> <span class=\"ow\">in</span> <span class=\"n\">d6_twice</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">():</span><br />    <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"n\">prob</span><span class=\"p\">)</span><br /></pre></div></div></div></div><div class=\"output_wrapper\"><div class=\"output\"><div class=\"output_area\"><div class=\"prompt\"></div><div class=\"output_subarea output_stream output_stdout output_text\"><pre>2 0.0277777777778<br />3 0.0555555555556<br />4 0.0833333333333<br />5 0.111111111111<br />6 0.138888888889<br />7 0.166666666667<br />8 0.138888888889<br />9 0.111111111111<br />10 0.0833333333333<br />11 0.0555555555556<br />12 0.0277777777778<br /></pre></div></div></div></div></div><div class=\"cell border-box-sizing text_cell rendered\"><div class=\"prompt input_prompt\"></div><div class=\"inner_cell\"><div class=\"text_cell_render border-box-sizing rendered_html\">Using numpy.sum, we can compute the distribution for the sum of three dice.</div></div></div><div class=\"cell border-box-sizing code_cell rendered\"><div class=\"input\"><div class=\"prompt input_prompt\">In&nbsp;[14]:</div><div class=\"inner_cell\"><div class=\"input_area\"><div class=\" highlight hl-ipython2\"><pre><span class=\"c1\"># if we use the built-in sum we have to provide a Pmf additive identity value</span><br /><span class=\"c1\"># pmf_ident = Pmf([0])</span><br /><span class=\"c1\"># d6_thrice = sum([d6]*3, pmf_ident)</span><br /><br /><span class=\"c1\"># with np.sum, we don't need an identity</span><br /><span class=\"n\">d6_thrice</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sum</span><span class=\"p\">([</span><span class=\"n\">d6</span><span class=\"p\">,</span> <span class=\"n\">d6</span><span class=\"p\">,</span> <span class=\"n\">d6</span><span class=\"p\">])</span><br /><span class=\"n\">d6_thrice</span><span class=\"o\">.</span><span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"s1\">'three dice'</span><br /></pre></div></div></div></div></div><div class=\"cell border-box-sizing text_cell rendered\"><div class=\"prompt input_prompt\"></div><div class=\"inner_cell\"><div class=\"text_cell_render border-box-sizing rendered_html\">And then plot the results (using Pmf.render)</div></div></div><div class=\"cell border-box-sizing code_cell rendered\"><div class=\"input\"><div class=\"prompt input_prompt\">In&nbsp;[19]:</div><div class=\"inner_cell\"><div class=\"input_area\"><div class=\" highlight hl-ipython2\"><pre><span class=\"kn\">import</span> <span class=\"nn\">matplotlib.pyplot</span> <span class=\"kn\">as</span> <span class=\"nn\">plt</span><br /><span class=\"o\">%</span><span class=\"k\">matplotlib</span> inline<br /></pre></div></div></div></div></div><div class=\"cell border-box-sizing code_cell rendered\"><div class=\"input\"><div class=\"prompt input_prompt\">In&nbsp;[20]:</div><div class=\"inner_cell\"><div class=\"input_area\"><div class=\" highlight hl-ipython2\"><pre><span class=\"k\">for</span> <span class=\"n\">die</span> <span class=\"ow\">in</span> <span class=\"p\">[</span><span class=\"n\">d6</span><span class=\"p\">,</span> <span class=\"n\">d6_twice</span><span class=\"p\">,</span> <span class=\"n\">d6_thrice</span><span class=\"p\">]:</span><br />    <span class=\"n\">xs</span><span class=\"p\">,</span> <span class=\"n\">ys</span> <span class=\"o\">=</span> <span class=\"n\">die</span><span class=\"o\">.</span><span class=\"n\">render</span><span class=\"p\">()</span><br />    <span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">xs</span><span class=\"p\">,</span> <span class=\"n\">ys</span><span class=\"p\">,</span> <span class=\"n\">label</span><span class=\"o\">=</span><span class=\"n\">die</span><span class=\"o\">.</span><span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">linewidth</span><span class=\"o\">=</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"n\">alpha</span><span class=\"o\">=</span><span class=\"mf\">0.5</span><span class=\"p\">)</span><br />    <br /><span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">xlabel</span><span class=\"p\">(</span><span class=\"s1\">'Total'</span><span class=\"p\">)</span><br /><span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">ylabel</span><span class=\"p\">(</span><span class=\"s1\">'Probability'</span><span class=\"p\">)</span><br /><span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">legend</span><span class=\"p\">()</span><br /><span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">()</span><br /></pre></div></div></div></div><div class=\"output_wrapper\"><div class=\"output\"><div class=\"output_area\"><div class=\"prompt\"></div><div class=\"output_png output_subarea \"><img src=\"data:image/png;base64,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 \" /></div></div></div></div></div><div class=\"cell border-box-sizing text_cell rendered\"><div class=\"prompt input_prompt\"></div><div class=\"inner_cell\"><div class=\"text_cell_render border-box-sizing rendered_html\"><h2 id=\"Bayesian-statistics\">Bayesian statistics<a class=\"anchor-link\" href=\"https://www.blogger.com/blogger.g?blogID=6894866515532737257#Bayesian-statistics\">¶</a></h2>A Suite is a Pmf that represents a set of hypotheses and their probabilities; it provides <code>bayesian_update</code>, which updates the probability of the hypotheses based on new data.<br />Suite is an abstract parent class; child classes should provide a likelihood method that evaluates the likelihood of the data under a given hypothesis.  <code>update_bayesian</code> loops through the hypothesis, evaluates the likelihood of the data under each hypothesis, and updates the probabilities accordingly.  Then it re-normalizes the PMF.</div></div></div><div class=\"cell border-box-sizing code_cell rendered\"><div class=\"input\"><div class=\"prompt input_prompt\">In&nbsp;[21]:</div><div class=\"inner_cell\"><div class=\"input_area\"><div class=\" highlight hl-ipython2\"><pre><span class=\"k\">class</span> <span class=\"nc\">Suite</span><span class=\"p\">(</span><span class=\"n\">Pmf</span><span class=\"p\">):</span><br />    <span class=\"sd\">\"\"\"Map from hypothesis to probability.\"\"\"</span><br /><br />    <span class=\"k\">def</span> <span class=\"nf\">bayesian_update</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">data</span><span class=\"p\">):</span><br />        <span class=\"sd\">\"\"\"Performs a Bayesian update.</span><br /><span class=\"sd\">        </span><br /><span class=\"sd\">        Note: called bayesian_update to avoid overriding dict.update</span><br /><br /><span class=\"sd\">        data: result of a die roll</span><br /><span class=\"sd\">        \"\"\"</span><br />        <span class=\"k\">for</span> <span class=\"n\">hypo</span> <span class=\"ow\">in</span> <span class=\"bp\">self</span><span class=\"p\">:</span><br />            <span class=\"n\">like</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">likelihood</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">hypo</span><span class=\"p\">)</span><br />            <span class=\"bp\">self</span><span class=\"p\">[</span><span class=\"n\">hypo</span><span class=\"p\">]</span> <span class=\"o\">*=</span> <span class=\"n\">like</span><br /><br />        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">normalize</span><span class=\"p\">()</span><br /></pre></div></div></div></div></div><div class=\"cell border-box-sizing text_cell rendered\"><div class=\"prompt input_prompt\"></div><div class=\"inner_cell\"><div class=\"text_cell_render border-box-sizing rendered_html\">As an example, I'll use Suite to solve the \"Dice Problem,\" from Chapter 3 of <i>Think Bayes</i>.<br />\"Suppose I have a box of dice that contains a 4-sided die, a 6-sided die, an 8-sided die, a 12-sided die, and a 20-sided die. If you have ever played Dungeons &amp; Dragons, you know what I am talking about.  Suppose I select a die from the box at random, roll it, and get a 6. What is the probability that I rolled each die?\"<br />I'll start by making a list of Pmfs to represent the dice:</div></div></div><div class=\"cell border-box-sizing code_cell rendered\"><div class=\"input\"><div class=\"prompt input_prompt\">In&nbsp;[31]:</div><div class=\"inner_cell\"><div class=\"input_area\"><div class=\" highlight hl-ipython2\"><pre><span class=\"k\">def</span> <span class=\"nf\">make_die</span><span class=\"p\">(</span><span class=\"n\">num_sides</span><span class=\"p\">):</span><br />    <span class=\"n\">die</span> <span class=\"o\">=</span> <span class=\"n\">Pmf</span><span class=\"p\">(</span><span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">num_sides</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">))</span><br />    <span class=\"n\">die</span><span class=\"o\">.</span><span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"s1\">'d'</span> <span class=\"o\">+</span> <span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">num_sides</span><span class=\"p\">)</span><br />    <span class=\"n\">die</span><span class=\"o\">.</span><span class=\"n\">normalize</span><span class=\"p\">()</span><br />    <span class=\"k\">return</span> <span class=\"n\">die</span><br /><br /><span class=\"n\">dice</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">make_die</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">x</span> <span class=\"ow\">in</span> <span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">6</span><span class=\"p\">,</span> <span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"mi\">12</span><span class=\"p\">,</span> <span class=\"mi\">20</span><span class=\"p\">]]</span><br /><span class=\"k\">for</span> <span class=\"n\">die</span> <span class=\"ow\">in</span> <span class=\"n\">dice</span><span class=\"p\">:</span><br />    <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">die</span><span class=\"p\">)</span><br /></pre></div></div></div></div><div class=\"output_wrapper\"><div class=\"output\"><div class=\"output_area\"><div class=\"prompt\"></div><div class=\"output_subarea output_stream output_stdout output_text\"><pre>Pmf({1: 0.25, 2: 0.25, 3: 0.25, 4: 0.25})<br />Pmf({1: 0.16666666666666666, 2: 0.16666666666666666, 3: 0.16666666666666666, 4: 0.16666666666666666, 5: 0.16666666666666666, 6: 0.16666666666666666})<br />Pmf({1: 0.125, 2: 0.125, 3: 0.125, 4: 0.125, 5: 0.125, 6: 0.125, 7: 0.125, 8: 0.125})<br />Pmf({1: 0.08333333333333333, 2: 0.08333333333333333, 3: 0.08333333333333333, 4: 0.08333333333333333, 5: 0.08333333333333333, 6: 0.08333333333333333, 7: 0.08333333333333333, 8: 0.08333333333333333, 9: 0.08333333333333333, 10: 0.08333333333333333, 11: 0.08333333333333333, 12: 0.08333333333333333})<br />Pmf({1: 0.05, 2: 0.05, 3: 0.05, 4: 0.05, 5: 0.05, 6: 0.05, 7: 0.05, 8: 0.05, 9: 0.05, 10: 0.05, 11: 0.05, 12: 0.05, 13: 0.05, 14: 0.05, 15: 0.05, 16: 0.05, 17: 0.05, 18: 0.05, 19: 0.05, 20: 0.05})<br /></pre></div></div></div></div></div><div class=\"cell border-box-sizing text_cell rendered\"><div class=\"prompt input_prompt\"></div><div class=\"inner_cell\"><div class=\"text_cell_render border-box-sizing rendered_html\">Next I'll define DiceSuite, which inherits <code>bayesian_update</code> from Suite and provides <code>likelihood</code>.<br /><code>data</code> is the observed die roll, 6 in the example.<br /><code>hypo</code> is the hypothetical die I might have rolled; to get the likelihood of the data, I select, from the given die, the probability of the given value.</div></div></div><div class=\"cell border-box-sizing code_cell rendered\"><div class=\"input\"><div class=\"prompt input_prompt\">In&nbsp;[26]:</div><div class=\"inner_cell\"><div class=\"input_area\"><div class=\" highlight hl-ipython2\"><pre><span class=\"k\">class</span> <span class=\"nc\">DiceSuite</span><span class=\"p\">(</span><span class=\"n\">Suite</span><span class=\"p\">):</span><br />    <br />    <span class=\"k\">def</span> <span class=\"nf\">likelihood</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">hypo</span><span class=\"p\">):</span><br />        <span class=\"sd\">\"\"\"Computes the likelihood of the data under the hypothesis.</span><br /><br /><span class=\"sd\">        data: result of a die roll</span><br /><span class=\"sd\">        hypo: Pmf object representing a die</span><br /><span class=\"sd\">        \"\"\"</span><br />        <span class=\"k\">return</span> <span class=\"n\">hypo</span><span class=\"p\">[</span><span class=\"n\">data</span><span class=\"p\">]</span><br /></pre></div></div></div></div></div><div class=\"cell border-box-sizing text_cell rendered\"><div class=\"prompt input_prompt\"></div><div class=\"inner_cell\"><div class=\"text_cell_render border-box-sizing rendered_html\">Finally, I use the list of dice to instantiate a Suite that maps from each die to its prior probability.  By default, all dice have the same prior.<br />Then I update the distribution with the given value and print the results:</div></div></div><div class=\"cell border-box-sizing code_cell rendered\"><div class=\"input\"><div class=\"prompt input_prompt\">In&nbsp;[33]:</div><div class=\"inner_cell\"><div class=\"input_area\"><div class=\" highlight hl-ipython2\"><pre><span class=\"n\">dice_suite</span> <span class=\"o\">=</span> <span class=\"n\">DiceSuite</span><span class=\"p\">(</span><span class=\"n\">dice</span><span class=\"p\">)</span><br /><br /><span class=\"n\">dice_suite</span><span class=\"o\">.</span><span class=\"n\">bayesian_update</span><span class=\"p\">(</span><span class=\"mi\">6</span><span class=\"p\">)</span><br /><br /><span class=\"k\">for</span> <span class=\"n\">die</span> <span class=\"ow\">in</span> <span class=\"nb\">sorted</span><span class=\"p\">(</span><span class=\"n\">dice_suite</span><span class=\"p\">):</span><br />    <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">die</span><span class=\"p\">),</span> <span class=\"n\">dice_suite</span><span class=\"p\">[</span><span class=\"n\">die</span><span class=\"p\">])</span><br /></pre></div></div></div></div><div class=\"output_wrapper\"><div class=\"output\"><div class=\"output_area\"><div class=\"prompt\"></div><div class=\"output_subarea output_stream output_stdout output_text\"><pre>4 0.0<br />6 0.392156862745<br />8 0.294117647059<br />12 0.196078431373<br />20 0.117647058824<br /></pre></div></div></div></div></div><div class=\"cell border-box-sizing text_cell rendered\"><div class=\"prompt input_prompt\"></div><div class=\"inner_cell\"><div class=\"text_cell_render border-box-sizing rendered_html\">As expected, the 4-sided die has been eliminated; it now has 0 probability.  The 6-sided die is the most likely, but the 8-sided die is still quite possible.<br />Now suppose I roll the die again and get an 8.  We can update the Suite again with the new data</div></div></div><div class=\"cell border-box-sizing code_cell rendered\"><div class=\"input\"><div class=\"prompt input_prompt\">In&nbsp;[30]:</div><div class=\"inner_cell\"><div class=\"input_area\"><div class=\" highlight hl-ipython2\"><pre><span class=\"n\">dice_suite</span><span class=\"o\">.</span><span class=\"n\">bayesian_update</span><span class=\"p\">(</span><span class=\"mi\">8</span><span class=\"p\">)</span><br /><br /><span class=\"k\">for</span> <span class=\"n\">die</span><span class=\"p\">,</span> <span class=\"n\">prob</span> <span class=\"ow\">in</span> <span class=\"nb\">sorted</span><span class=\"p\">(</span><span class=\"n\">dice_suite</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">()):</span><br />    <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">die</span><span class=\"o\">.</span><span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">prob</span><span class=\"p\">)</span><br /></pre></div></div></div></div><div class=\"output_wrapper\"><div class=\"output\"><div class=\"output_area\"><div class=\"prompt\"></div><div class=\"output_subarea output_stream output_stdout output_text\"><pre>d4 0.0<br />d6 0.0<br />d8 0.623268698061<br />d12 0.277008310249<br />d20 0.0997229916898<br /></pre></div></div></div></div></div><div class=\"cell border-box-sizing text_cell rendered\"><div class=\"prompt input_prompt\"></div><div class=\"inner_cell\"><div class=\"text_cell_render border-box-sizing rendered_html\">Now the 6-sided die has been eliminated, the 8-sided die is most likely, and there is less than a 10% chance that I am rolling a 20-sided die.<br />These examples demonstrate the versatility of the Counter class, one of Python's underused data structures.</div></div></div><div class=\"cell border-box-sizing code_cell rendered\"><div class=\"input\"><div class=\"prompt input_prompt\">In&nbsp;[&nbsp;]:</div><div class=\"inner_cell\"><div class=\"input_area\"><div class=\" highlight hl-ipython2\"><pre> <br /></pre></div></div></div></div></div>",
  "link": [
    "",
    "",
    "",
    "",
    ""
  ],
  "author": {
    "name": "Allen Downey",
    "uri": "http://www.blogger.com/profile/01633071333405221858",
    "email": "noreply@blogger.com",
    "gd:image": ""
  },
  "media:thumbnail": "",
  "thr:total": 0
}