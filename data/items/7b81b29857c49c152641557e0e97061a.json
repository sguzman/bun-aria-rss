{
  "id": "tag:blogger.com,1999:blog-4446292666398344382.post-8935922293128364622",
  "published": "2016-07-04T21:02:00.000-07:00",
  "updated": "2016-07-05T11:50:29.824-07:00",
  "category": [
    "",
    ""
  ],
  "title": "ICML 2016 Thoughts",
  "content": "ICML is too big for me to ``review'' it per se, but I can provide a myopic perspective.<br /><br />The heavy hitting topics were Deep Learning, Reinforcement Learning, and Optimization; but there was a heavy tail of topics receiving attention.  It felt like deep learning was less dominant this year; but the success of deep learning has led to multiple application specific alternative venues (e.g., CVPR, EMNLP), and ICLR is also a prestigious venue; so deep learning at ICML this year was heavyweight in either the more theoretical or multimodal works.  Arguably, reinforcement learning and optimization both should partially count towards deep learning's footprint; reinforcement learning has been this way for at least a year, but optimization has recently developed more interest in non-convex problems, especially the kind that are empirically tractable in deep learning (sometimes, although seemingly innocuous architecture changes can spoil the pudding; I suppose one dream of the optimization community would be the identification of a larger-than-convex class of problems which are still tractable, to provide guidance).<br /><br />Here are some papers I liked:<br /><ol><li><a href=\"http://jmlr.org/proceedings/papers/v48/balduzzi16.pdf\">Strongly-Typed Recurrent Neural Networks</a><br />The off-putting title makes sense if you are into type theory, or if you've ever been a professional Haskell programmer and have had to figure out wtf a monad is.  tl;dr: if you put units of measurement on the various components of a recurrent neural network, you'll discover that you are adding apples and oranges.  T-LSTM, a modification of the standard LSTM to fix the problem, behaves similarly empirically; but is amenable to analysis.  Theorem 1 was the nice part for me: the modified architectures are shown to compute temporal convolutions with dynamic pooling.  Could type consistency provide a useful prior on architectures?  That'd be a welcome development.</li><li><a href=\"http://arxiv.org/abs/1503.08895\">Ask Me Anything:<br />Dynamic Memory Networks for Natural Language Processing</a> and <a href=\"http://jmlr.org/proceedings/papers/v48/xiong16.pdf\">Dynamic Memory Networks for Visual and Textual Question Answering</a><br />More titles I'm not over the moon about: everybody seems to be equating &ldquo;memory&rdquo; = &ldquo;attention over current example substructure&rdquo;.  If you ask for the layperson's definition, they would say that memory is about stuff you <i>can't</i> see at the moment (note: Jason started this particular abuse of terminology with <a href=\"http://arxiv.org/abs/1503.08895\">End-to-End Memory Networks</a>).  Pedantry aside, undeniably these <b>iterated attention architectures</b> have become the state of the art in question-answering style problems and the baseline to beat.  Note since the next step in iterated attention is to incorporate previously seen and stored examples, the use of the term &ldquo;memory&rdquo; will soon become less objectionable.</li><li><a href=\"http://jmlr.org/proceedings/papers/v48/martins16.pdf\">From Softmax to Sparsemax:<br />A Sparse Model of Attention and Multi-Label Classification</a> This is an alternative to the softmax layer (&ldquo;link function&rdquo;) used as the last layer of a neural network.  Softmax maps $\\mathbb{R}^n$ onto the (interior of the) simplex, whereas sparsemax projects onto the simplex.  One big difference is that sparsemax can &ldquo;hit the corners&rdquo;, i.e., zero out some components.  Empirically the differences in aggregate task performance when swapping softmax with sparsemax are modest and attributable to the selection pressures on experimental sections. So why care?  Attention mechanisms are often implemented with softmax, and it is plausible that a truly sparse attention mechanism might scale better (either computationally or statistically) to larger problems (such as those involving <i>actual</i> memory, c.f., previous paragraph). <br /></li><li><a href=\"http://jmlr.org/proceedings/papers/v48/finn16.pdf\">Guided Cost Learning: Deep Inverse Optimal Control via Policy Optimization</a><br />I find Inverse RL unintuitive: didn't Vapnik say not to introduce difficult intermediate problems?  Nonetheless, it seems to work well.  Perhaps requiring the learned policy to be &ldquo;rational&rdquo; under some cost function is a useful prior which mitigates sample complexity?  I'm not sure, I have to noodle on it.  In the meantime, cool videos of robots doing the dishes!<br /></li><li><a href=\"http://jmlr.org/proceedings/papers/v48/wangf16.pdf\">Dueling Network Architectures for Deep Reinforcement Learning</a>.<br />Best paper, so I'm not adding any value by pointing it out to you.  However, after reading it, meditate on why learning two things is better than learning one.  Then re-read the discussion section.  Then meditate on whether a similar variance isolation trick applies to your current problem.<br /></li></ol><br />From the workshops, some fun stuff I heard:<br /><ol><li>Gerald Tesauro dusted off his old <a href=\"https://en.wikipedia.org/wiki/Neurogammon\">Neurogammon</a> code, ran it on a more powerful computer (his current laptop), and got much better results.  Unfortunately, we cannot conclude that NVIDIA will solve AI for us if we wait long enough.  In 2 player games or in simulated environments more generally, computational power equates to more data resources, because you can simulate more.  In the real world we have sample complexity constraints: you have to perform actual actions to get actual rewards.  However, in the same way that cars and planes are faster than people because they have unfair energetic advantages (we are 100W machines; airplanes are <a href=\"http://aviation.stackexchange.com/questions/19569/how-many-kilowatts-to-get-an-electric-747-8-airborne\">much higher</a>), I think &ldquo;superhuman AI&rdquo;, should it come about, will be because of sample complexity advantages, i.e., a distributed collection of robots that can perform more actions and experience more rewards (and remember and share all of them with each other).  So really Boston Dynamics, not NVIDIA, is the key to the singularity.  (In the meantime &hellip; buy my vitamins!)<br /></li><li>Ben Recht talked about the virtues of <a href=\"http://www.argmin.net/2016/06/20/hypertuning/\">random hyperparameter optimization</a> and an <a href=\"http://arxiv.org/abs/1603.06560\">acceleration technique</a> that looks like a cooler version of <a href=\"https://blogs.technet.microsoft.com/machinelearning/2014/09/24/online-learning-and-sub-linear-debugging/\">sub-linear debugging</a>.  This style, in my experience, works.<br /></li><li>Leon Bottou pointed out that first order methods are now within constant factors of optimal convergence, with the corollary that any putative improvement has to be extremely cheap to compute since it can only yield a constant factor.  He also presented a plausible improvement on batch normalization in the same talk.<br /></li></ol>",
  "link": [
    "",
    "",
    "",
    "",
    ""
  ],
  "author": {
    "name": "Paul Mineiro",
    "uri": "http://www.blogger.com/profile/05439062526157173163",
    "email": "noreply@blogger.com",
    "gd:image": ""
  },
  "thr:total": 0
}