{
  "title": "What's the future of the pandas library?",
  "description": "pandas is a very popular Python library for data analysis, manipulation, and visualization, but it still hasn't reached version 1.0. What's next for pandas?",
  "link": "https://www.dataschool.io/future-of-pandas/",
  "guid": "5c5c44a4331d440017e2be06",
  "category": "Python",
  "dc:creator": "Kevin Markham",
  "pubDate": "Wed, 12 Dec 2018 15:51:34 GMT",
  "content:encoded": "<!--kg-card-begin: markdown--><p><a href=\"http://pandas.pydata.org/\">pandas</a> is a powerful, open source Python library for <strong>data analysis, manipulation, and visualization</strong>. I've been teaching data scientists to use pandas since 2014, and in the years since, it has grown in popularity to an estimated <strong>5 to 10 million users</strong> and become a \"must-use\" tool in the Python data science toolkit.</p>\n<p>I started using pandas around version <strong>0.14.0</strong>, and I've followed the library as it has significantly matured to its current version, <strong>0.23.4</strong>. But numerous data scientists have asked me questions like these over the years:</p>\n<ul>\n<li>\"Is pandas reliable?\"</li>\n<li>\"Will it keep working in the future?\"</li>\n<li>\"Is it buggy? <strong>They haven't even released version 1.0!</strong>\"</li>\n</ul>\n<p>Version numbers can be used to signal the maturity of a product, and so I understand why someone might be hesitant to rely on <strong>\"pre-1.0\" software</strong>. But in the world of open source, version numbers don't necessarily tell you anything about the maturity or reliability of a library. (Yes, pandas is both mature and reliable!) Rather, version numbers communicate the <strong>stability of the API.</strong></p>\n<p>In particular, <strong>version 1.0</strong> signals to the user: \"We've figured out what the API should look like, and so API-breaking changes will only occur with major releases (2.0, 3.0, etc.)\" In other words, version 1.0 marks the point at which <strong>your code should never break</strong> just by upgrading to the next minor release.</p>\n<p>So the question remains: <strong>What's coming in pandas 1.0, and when is it coming?</strong></p>\n<h2 id=\"towardspandas10\">Towards pandas 1.0</h2>\n<p>I recently watched a talk from PyData London called <a href=\"https://www.youtube.com/watch?v=hK6o_TDXXN8\">Towards pandas 1.0</a>, given by pandas core developer <a href=\"https://datapythonista.me/\">Marc Garcia</a>. It was an enlightening talk about the <strong>future of pandas</strong>, and so I wanted to highlight and comment on a few of the items that were mentioned:</p>\n<ul>\n<li><a href=\"#methodchaining\">Method chaining</a> &#x1F44D;</li>\n<li><a href=\"#inplace\">inplace</a> &#x1F44E;</li>\n<li><a href=\"#apachearrow\">Apache Arrow</a> &#x1F44D;</li>\n<li><a href=\"#extensionarrays\">Extension Arrays</a> &#x1F44D;</li>\n<li><a href=\"#otherdeprecations\">Other deprecations</a> &#x1F44E;</li>\n<li><a href=\"#roadmap\">Roadmap</a></li>\n</ul>\n<!--\nIf you want to follow along with the **full talk slides**, they can be found in this [Jupyter notebook](http://nbviewer.jupyter.org/github/datapythonista/towards_pandas_1/blob/master/Towards%20pandas%201.0.ipynb).\n-->\n<h2 id=\"methodchaining\">Method chaining &#x1F44D;</h2>\n<p>The pandas core team now <strong>encourages</strong> the use of \"method chaining\". This is a style of programming in which you chain together multiple method calls into a single statement. This allows you to pass intermediate results from one method to the next rather than storing the intermediate results using variables.</p>\n<p>Here's the example Marc used that <strong>does not use method chaining:</strong></p>\n<pre><code class=\"language-python\">import pandas\ndf = pandas.read_csv('data/titanic.csv.gz')\ndf = df[df.Age < df.Age.quantile(.99)]\ndf['Age'].fillna(df.Age.median(), inplace=True)\ndf['Age'] = pandas.cut(df['Age'],\n                       bins=[df.Age.min(), 18, 40, df.Age.max()],\n                       labels=['Underage', 'Young', 'Experienced'])\ndf['Sex'] = df['Sex'].replace({'female': 1, 'male': 0})\ndf = df.pivot_table(values='Sex', columns='Pclass', index='Age', aggfunc='mean')\ndf = df.rename_axis('', axis='columns')\ndf = df.rename('Class {}'.format, axis='columns')\ndf.style.format('{:.2%}')\n</code></pre>\n<p>Here is the equivalent code that <strong>uses method chaining:</strong></p>\n<pre><code class=\"language-python\">import pandas\n(pandas.read_csv('data/titanic.csv.gz')\n       .query('Age < Age.quantile(.99)')\n       .assign(Sex=lambda df: df['Sex'].replace({'female': 1, 'male': 0}),\n               Age=lambda df: pandas.cut(df['Age'].fillna(df.Age.median()),\n                                         bins=[df.Age.min(), 18, 40, df.Age.max()],\n                                         labels=['Underage', 'Young', 'Experienced']))\n       .pivot_table(values='Sex', columns='Pclass', index='Age', aggfunc='mean')\n       .rename_axis('', axis='columns')\n       .rename('Class {}'.format, axis='columns')\n       .style.format('{:.2%}'))\n</code></pre>\n<p>Their primary reasons for preferring method chains are:</p>\n<ul>\n<li><strong>readability:</strong> In their opinion, method chains are more readable.</li>\n<li><strong>performance:</strong> Since the method chain tells pandas everything you want to do ahead of time, pandas can plan its operations more efficiently.</li>\n</ul>\n<p>Here are my thoughts:</p>\n<ul>\n<li>I've been writing <strong>short method chains</strong> for years, and I find them to be more readable than the alternative. For example, I would never break <code>df.isnull().sum()</code> or <code>ser.value_counts().sort_index()</code> into multiple lines of code by using intermediate variables.</li>\n<li>However, I actually find <strong>long method chains</strong> (Marc's second example) to be less readable than the alternative, but maybe that's because I'm not used to writing them. Specifically, it's hard for me to follow the lambda functions inside the <code>assign()</code> method.</li>\n</ul>\n<p>Tom Augspurger, another pandas core developer, also <a href=\"https://tomaugspurger.github.io/method-chaining.html\">noted</a>:</p>\n<blockquote>\n<p>\"One drawback to excessively long chains is that debugging can be harder. If something looks wrong at the end, you don't have intermediate values to inspect.\"</p>\n</blockquote>\n<p>To be clear, method chaining has always been available in pandas, but <strong>support for chaining has increased</strong> through the addition of new \"chain-able\" methods. For example, the <code>query()</code> method (used in the chain above) was previously tagged as \"experimental\" in the documentation, which is why I haven't been using it or teaching it. That tag was <a href=\"https://github.com/pandas-dev/pandas/pull/18973#discussion_r159014851\">removed</a> in pandas 0.23, which may indicate that the core team is now encouraging the use of <code>query()</code>.</p>\n<p>I don't think you will ever be <strong>required to use method chains</strong>, but I presume that the documentation may eventually migrate to using that style.</p>\n<p>For a longer discussion of this topic, see Tom Augspurger's <a href=\"https://tomaugspurger.github.io/method-chaining.html\">Method Chaining post</a>, which was part 2 of his <a href=\"https://tomaugspurger.github.io/modern-1-intro\">Modern pandas</a> series.</p>\n<h2 id=\"inplace\">inplace &#x1F44E;</h2>\n<p>The pandas core team <strong>discourages</strong> the use of the <code>inplace</code> parameter, and eventually it will be <a href=\"https://github.com/pandas-dev/pandas/issues/16529\">deprecated</a> (which means \"scheduled for removal from the library\"). Here's why:</p>\n<ul>\n<li><code>inplace</code> won't work within a method chain.</li>\n<li>The use of <code>inplace</code> often doesn't prevent copies from being created, contrary to what the name implies.</li>\n<li>Removing the <code>inplace</code> option would reduce the complexity of the pandas codebase.</li>\n</ul>\n<p>Personally, I'm a fan of <code>inplace</code> and I happen to prefer writing <code>df.reset_index(inplace=True)</code> instead of <code>df = df.reset_index()</code>, for example. That being said, lots of beginners do get confused by <code>inplace</code>, and it's nice to have <strong>one clear way to do things</strong> in pandas, so ultimately I'd be fine with deprecation.</p>\n<p>If you'd like to learn more about <strong>how memory is managed in pandas</strong>, I recommend watching this <a href=\"https://www.youtube.com/watch?v=hK6o_TDXXN8&t=700\">5-minute section</a> of Marc's talk.</p>\n<h2 id=\"apachearrow\">Apache Arrow &#x1F44D;</h2>\n<p>Apache Arrow is a \"work in progress\" to become the pandas back-end. Arrow was created in 2015 by Wes McKinney, the founder of pandas, to resolve many of the <strong>underlying limitations of the pandas DataFrame</strong> (as well as similar data structures in other languages).</p>\n<p>The goal of Arrow is to create an <strong>open standard for representing tabular data</strong> that natively supports complex data formats and is highly optimized for performance. Although Arrow was inspired by pandas, it's designed to be a shared computational infrastructure for data science work across multiple languages.</p>\n<p>Because Arrow is an infrastructure layer, its eventual use as the pandas back-end (likely coming after pandas 1.0) will ideally be transparent to pandas end users. However, it should result in <strong>much better performance</strong> as well as support for <strong>working with \"larger-than-RAM\" datasets</strong> in pandas.</p>\n<p>For more details about Arrow, I recommend reading Wes McKinney's 2017 blog post, <a href=\"http://wesmckinney.com/blog/apache-arrow-pandas-internals/\">Apache Arrow and the \"10 Things I Hate About pandas\"</a>, as well as watching his <a href=\"https://www.youtube.com/watch?v=y7zGnKzaKIw\">talk</a> (with <a href=\"https://www.slideshare.net/wesm/apache-arrow-crosslanguage-development-platform-for-inmemory-data-105427919\">slides</a>) from SciPy 2018. For details about how Arrow will be integrated into pandas, I recommend watching Jeff Reback's <a href=\"https://www.youtube.com/watch?v=_-gJtO0XR48\">talk</a> (with <a href=\"https://www.slideshare.net/JeffReback/future-of-pandas-82901487\">slides</a>) from PyData NYC 2017.</p>\n<h2 id=\"extensionarrays\">Extension Arrays &#x1F44D;</h2>\n<p>Extension Arrays allow you to create <strong>custom data types</strong> for use with pandas. The <a href=\"http://pandas.pydata.org/pandas-docs/stable/whatsnew.html#extending-pandas-with-custom-types-experimental\">documentation</a> provides a nice summary:</p>\n<blockquote>\n<p>Pandas now supports storing array-like objects that aren&#x2019;t necessarily 1-D NumPy arrays as columns in a DataFrame or values in a Series. This allows third-party libraries to implement extensions to NumPy&#x2019;s types, similar to how pandas implemented categoricals, datetimes with timezones, periods, and intervals.</p>\n</blockquote>\n<p>In other words, previously the pandas team had to write a lot of custom code to implement data types that were not natively supported by NumPy (such as <a href=\"http://pandas.pydata.org/pandas-docs/stable/categorical.html\">categoricals</a>). With the release of Extension Arrays, there is now a <strong>generalized interface for creating custom types</strong> that anyone can use.</p>\n<p>The pandas team has already used this interface to write an <strong>integer data type that supports missing values</strong>, also known as \"NA\" or \"NaN\" values. Previously, integer columns would be converted to floats if you marked any values as missing. The <a href=\"http://pandas-docs.github.io/pandas-docs-travis/whatsnew/v0.24.0.html#optional-integer-na-support\">development documentation</a> indicates that the \"Integer NA\" type will be available in the next release (version 0.24).</p>\n<p>Another compelling use for this interface would be a <strong>native string type</strong>, since strings in pandas are currently represented using NumPy's \"object\" data type. The <a href=\"https://github.com/xhochy/fletcher\">fletcher library</a> has already used the interface to enable a native string type in pandas, though the pandas team may eventually build its own string type <a href=\"https://gitter.im/pydata/pandas/archives/2018/12/07\">directly into pandas</a>.</p>\n<p>For a deeper look into this topic, check out the following resources:</p>\n<ul>\n<li><a href=\"https://tomaugspurger.github.io/pandas-extension-arrays.html\">Extension Arrays for pandas</a>: Blog post about the development of <a href=\"https://cyberpandas.readthedocs.io/en/latest/\">cyberpandas</a> using Extension Arrays.</li>\n<li><a href=\"https://www.youtube.com/watch?v=xx7H5EkzQH0\">Extending pandas with Custom Types</a>: Video (with <a href=\"https://www.slideshare.net/PyData/extending-pandas-with-custom-types-will-ayd\">slides</a>) about the development of the \"Integer NA\" type.</li>\n<li><a href=\"https://www.youtube.com/watch?v=tvmX8YAFK80\">Extending pandas using Apache Arrow and Numba</a>: Video (with <a href=\"https://www.slideshare.net/xhochy/extending-pandas-using-apache-arrow-and-numba\">slides</a>) about the development of a string type via fletcher, using Arrow for storage and Numba for better performance (as described <a href=\"https://pydata.org/berlin2018/schedule/presentation/36/\">here</a>).</li>\n</ul>\n<h2 id=\"otherdeprecations\">Other deprecations &#x1F44E;</h2>\n<p>Here are a few other deprecations which were discussed in the talk:</p>\n<ul>\n<li>The <strong><code>ix</code> accessor</strong> was already deprecated in version 0.20, in favor of <code>loc</code> (label-based access) and <code>iloc</code> (position-based access). Learn how to use <code>loc</code> and <code>iloc</code> in my <a href=\"https://www.youtube.com/watch?v=xvpNA7bC8cs&list=PL5-da3qGB5ICCsgW1MxlZ0Hq8LL5U3u9y&index=19\">video tutorial</a>.</li>\n<li>The <strong>Panel data structure</strong> for 3-dimensional data was also deprecated in version 0.20, in favor of a DataFrame with a MultiIndex. Learn how to use the MultiIndex in my <a href=\"https://www.youtube.com/watch?v=tcRGa2soc-c&list=PL5-da3qGB5ICCsgW1MxlZ0Hq8LL5U3u9y&index=31\">video tutorial</a>.</li>\n<li>The <strong>SparseDataFrame</strong>, useful when a DataFrame mostly contains missing values, may be deprecated in an upcoming release. (However, you should be able to store sparse data in a regular DataFrame instead.)</li>\n<li><strong>Python 2 support</strong> will be dropped from pandas in January 2019!</li>\n</ul>\n<h2 id=\"roadmap\">Roadmap</h2>\n<p>According to the talk, here's the <strong>roadmap to pandas 1.0:</strong></p>\n<ul>\n<li><strong>0.23.4</strong> was the most recent pandas release (August 2018).</li>\n<li><strong>0.24</strong> is targeted for the end of 2018, according to the <a href=\"https://github.com/pandas-dev/pandas/milestones\">GitHub milestone</a>.</li>\n<li><strong>0.25</strong> is targeted for early 2019, and it will warn about all of the deprecations coming in 1.0.</li>\n<li><strong>1.0</strong> will be the same as 0.25, except all the deprecated features will be removed.</li>\n</ul>\n<p>More details about the roadmap are available in the <a href=\"https://github.com/pandas-dev/pandas/wiki/Pandas-Sprint-(July,-2018)\">pandas sprint notes</a> from July 2018, though all of these plans are subject to change.</p>\n<h2 id=\"learningpandas\">Learning pandas?</h2>\n<p>If you're <strong>new to pandas</strong>, I recommend watching my video tutorial series, <a href=\"https://www.dataschool.io/easier-data-analysis-with-pandas/\">Easier data analysis in Python with pandas</a>.</p>\n<p>If you're an <strong>intermediate pandas user</strong>, I recommend watching my tutorial from PyCon 2019, <a href=\"https://www.dataschool.io/data-science-best-practices-with-pandas/\">Data science best practices with pandas</a>.</p>\n<!--\nWant to know when I release **new pandas tutorials**? Subscribe to my [email newsletter](https://www.dataschool.io/subscribe/).\n-->\n<p>Let me know your thoughts or questions in the comments section below! There is also a discussion of this post on <a href=\"https://www.reddit.com/r/Python/comments/a5lb39/whats_the_future_of_the_pandas_library/\">Reddit</a>.</p>\n<script async data-uid=\"d6d0f53c0f\" src=\"https://dataschool.ck.page/d6d0f53c0f/index.js\"></script>\n<!--\n<blockquote class=\"twitter-tweet\" data-cards=\"hidden\" data-lang=\"en\"><p lang=\"en\" dir=\"ltr\">NEW POST: What's the future of the pandas library?<br>üëâ <a href=\"https://t.co/AX4xzoS5u1\">https://t.co/AX4xzoS5u1</a><br><br>- Method chaining üëç<br>- inplace üëé<br>- <a href=\"https://twitter.com/ApacheArrow?ref_src=twsrc%5Etfw\">@ApacheArrow</a> & big data support üëç<br>- Extension Arrays & IntegerNA üëç<br>- Roadmap to v1.0<br><br>Featuring <a href=\"https://twitter.com/datapythonista?ref_src=twsrc%5Etfw\">@datapythonista</a> <a href=\"https://twitter.com/TomAugspurger?ref_src=twsrc%5Etfw\">@TomAugspurger</a> <a href=\"https://twitter.com/wesmckinn?ref_src=twsrc%5Etfw\">@wesmckinn</a> <a href=\"https://twitter.com/jreback?ref_src=twsrc%5Etfw\">@jreback</a> <a href=\"https://twitter.com/xhochy?ref_src=twsrc%5Etfw\">@xhochy</a><a href=\"https://twitter.com/hashtag/python?src=hash&ref_src=twsrc%5Etfw\">#python</a></p>&mdash; Kevin Markham (@justmarkham) <a href=\"https://twitter.com/justmarkham/status/1072902933849796608?ref_src=twsrc%5Etfw\">December 12, 2018</a></blockquote>\n<script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n--><!--kg-card-end: markdown-->"
}