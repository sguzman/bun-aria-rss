{
  "title": "Scala Coursera Highlights",
  "link": "https://wellecks.wordpress.com/2014/11/27/scala-coursera-highlights/",
  "comments": "https://wellecks.wordpress.com/2014/11/27/scala-coursera-highlights/#respond",
  "dc:creator": "wellecks",
  "pubDate": "Thu, 27 Nov 2014 21:05:25 +0000",
  "category": [
    "programming",
    "coursera",
    "functional programming",
    "scala"
  ],
  "guid": "http://wellecks.wordpress.com/?p=906",
  "description": "I recently completed the Functional Programming Principles in Scala course on Coursera. Along the way, I learned some interesting things ranging from small tidbits to major language features. I&#8217;m going to use this post as a chance to highlight and review my favorite things that I learned about Scala from the course. This is meant to [&#8230;]",
  "content:encoded": "<p>I recently completed the <a title=\"Functional Programming Principles in Scala\" href=\"https://www.coursera.org/course/progfun\" target=\"_blank\">Functional Programming Principles in Scala</a> course on Coursera. Along the way, I learned some interesting things ranging from small tidbits to major language features. I&#8217;m going to use this post as a chance to highlight and review my favorite things that I learned about Scala from the course. This is meant to be more of a quick review than a set of tutorials, so I&#8217;ll provide links to actual tutorials and further reading for each section.</p>\n<p style=\"text-align:center;\"><b>Variance</b></p>\n<p>One thing I liked was seeing abstract programming language concepts concretely being used in Scala. An example of this is the idea of variance, namely <a href=\"http://en.wikipedia.org/wiki/Covariance_and_contravariance_%28computer_science%29\">covariance and contravariance</a>. Covariance and contravariance appear when investigating whether one type is a subtype of another type. This question comes up concretely in several places, such as deciding whether a type is a valid argument parameter, or deciding which types can be held by a data structure.</p>\n<p><strong>Argument Parameters</strong></p>\n<p>Functions accept subtypes as arguments. For instance, a function requiring an <code>Animal</code> type will accept <code>Cat</code> or <code>Dog</code> subtypes as arguments. An interesting (and tricky) case is when a function takes a function as an argument, e.g.</p>\n<pre>def fun[T] (animal: Animal, paramFun: Animal => T) : T</pre>\n<p>What are valid arguments for <code>fun</code>? The <code>animal</code> argument is clear; it&#8217;s just any subtype of <code>Animal</code>. But which functions could we pass in for <code>paramFun</code>? This requires determining the subtype of a function.</p>\n<p>A natural guess may be that a function <img src=\"https://s0.wp.com/latex.php?latex=f1%3A+A+%3D%3E+B&#038;bg=ffffff&#038;fg=404040&#038;s=0&#038;c=20201002\" srcset=\"https://s0.wp.com/latex.php?latex=f1%3A+A+%3D%3E+B&#038;bg=ffffff&#038;fg=404040&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=f1%3A+A+%3D%3E+B&#038;bg=ffffff&#038;fg=404040&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x\" alt=\"f1: A => B\" class=\"latex\" /> is a subtype of a function <img src=\"https://s0.wp.com/latex.php?latex=f2%3A+C+%3D%3E+D&#038;bg=ffffff&#038;fg=404040&#038;s=0&#038;c=20201002\" srcset=\"https://s0.wp.com/latex.php?latex=f2%3A+C+%3D%3E+D&#038;bg=ffffff&#038;fg=404040&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=f2%3A+C+%3D%3E+D&#038;bg=ffffff&#038;fg=404040&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x\" alt=\"f2: C => D\" class=\"latex\" /> when <em>A</em> is a subtype of <em>C</em> and <em>B</em> is a subtype of <em>D</em>. However, this is incorrect!</p>\n<p>It turns out that we need to &#8216;reverse&#8217; the argument subtyping; <em>C</em> must be a subtype of <em>A. </em>Specifically, we have:</p>\n<p><img src=\"https://s0.wp.com/latex.php?latex=f1%3A+A+%3D%3E+B&#038;bg=ffffff&#038;fg=404040&#038;s=0&#038;c=20201002\" srcset=\"https://s0.wp.com/latex.php?latex=f1%3A+A+%3D%3E+B&#038;bg=ffffff&#038;fg=404040&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=f1%3A+A+%3D%3E+B&#038;bg=ffffff&#038;fg=404040&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x\" alt=\"f1: A => B\" class=\"latex\" /> is a subtype of <img src=\"https://s0.wp.com/latex.php?latex=f2%3A+C+%3D%3E+D&#038;bg=ffffff&#038;fg=404040&#038;s=0&#038;c=20201002\" srcset=\"https://s0.wp.com/latex.php?latex=f2%3A+C+%3D%3E+D&#038;bg=ffffff&#038;fg=404040&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=f2%3A+C+%3D%3E+D&#038;bg=ffffff&#038;fg=404040&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x\" alt=\"f2: C => D\" class=\"latex\" /> when:</p>\n<ul>\n<li><em>C</em> is a subtype of <em>A</em></li>\n<li><em>B</em> is a subtype of <em>D</em></li>\n</ul>\n<p>For instance, the function</p>\n<pre>def f1(animal: Animal) : Cat</pre>\n<p>is a subtype of</p>\n<pre>def f2(cat: Cat) : Animal</pre>\n<p>In terms of variances, we describe the above by saying that functions are <em>contravariant in their argument types</em>, and <em>covariant in their return types</em>.</p>\n<p>The intuition for this is derived from the <a href=\"http://en.wikipedia.org/wiki/Liskov_substitution_principle\">Liskov Substitution Principle</a>, which is (paraphrased) the idea that a subtype should be expected to do everything that its supertypes can do. We should be able to use <code>f1</code> in all of the ways that we can use <code>f2</code>.</p>\n<p>To connect it back with this post&#8217;s topic, it turns out that defining and enforcing variance rules is a language feature in Scala! Scala provides the <code>-</code> and <code>+</code> type annotations for contravariance and covariance, respectively. Thus we can implement, for instance, a one parameter function class, and bake the variance rules into the type parameters:</p>\n<pre>class Function1[-V, +W] { ... }</pre>\n<p>The type tells us that <code>Function1</code> is contravariant in <code>V</code> and covariant in <code>W</code>, as desired.</p>\n<p style=\"text-align:left;\"><strong>Type Bounds</strong></p>\n<p>Another type-related feature is type bounding. We can create a parameterized function and specify that its parameterized type is a subtype (or supertype) of another type, e.g:</p>\n<pre>def foo[T :> String] (t: T)</pre>\n<p>says that T must be a supertype of String, and</p>\n<pre>def foo[String <: T <: Object] (t: T)</pre>\n<p>says that T must be a supertype of String and a subtype of Object.</p>\n<p><strong>An Example</strong></p>\n<p>As an example of where we would use variance and type bounds, suppose we want to add a <code>prepend</code> function to the <code>List</code> class. Looking at Scala&#8217;s documentation, we can see that the <code>List</code> are parameterized by a covariant type <code>A</code>:</p>\n<pre id=\"signature\" class=\"signature\"><span class=\"modifier_kind\"><span class=\"modifier\">sealed abstract </span><span class=\"kind\">class </span></span><span class=\"symbol\"><span class=\"name\">List</span><span class=\"tparams\">[+A] ...</span></span></pre>\n<p style=\"text-align:left;\">Now, &#8220;`prepend&#8220;` will add an element to the front of the list; a first guess at its type signature might be:</p>\n<pre style=\"text-align:left;\">// compile error\ndef prepend[A] (a: A) : List[A]</pre>\n<p style=\"text-align:left;\">We are attempting to pass a covariant type as a function argument; since function arguments are contravariant this will result in a <a href=\"http://stackoverflow.com/questions/9619121/why-is-parameter-in-contravariant-position\">compile error</a>.</p>\n<p style=\"text-align:left;\">To fix this, we can use a type bound to tell the compiler that we&#8217;d like to be able to pass in any supertype B of A, and produce a new list of B&#8217;s:</p>\n<pre style=\"text-align:left;\">// compiles\ndef prepend[B >: A] (b: B) : List[B]</pre>\n<p style=\"text-align:center;\"><strong>For Comprehensions</strong></p>\n<p>The functions <code>map</code>, <code>flatMap</code>, and <code>filter</code> are used commonly in functional programming. A common pattern is to chain these functions together, which can lead to bloated and unreadable (albeit effective) code. A simple example:</p>\n<pre>(1 until 10).flatMap(x => \n   (1 until 20).filter(y => y >= 10)\n   .map(y => (x,y)))</pre>\n<p>Scala provides <code>for</code> comprehensions as a way of chaining <code>map</code>, <code>flatMap</code>, and <code>filter</code> operations together. Broadly stated, <code>for</code> comprehensions are syntactic sugar that map &#8216;arrow&#8217;, &#8216;if&#8217;, and &#8216;yield&#8217; to <code>map</code>, <code>filterWith</code>, and <code>flatMap</code>, leading to more concise and readable code:</p>\n<pre>for {\n  x <- (1 until 10)\n  y <- (1 until 20)\n  if y >= 10 \n} yield (x, y)</pre>\n<p>Any type that supports <code>map</code>,<code>filter</code>, and <code>flatMap</code> is eligible to be used in a <code>for</code> comprehension, such as <code>List</code>, <code>Future</code>, <code>Map</code>, and many many more. For those familiar with Haskell, Scala&#8217;s <code>for</code> comprehensions are analogous to Haskell&#8217;s <code>do</code> notation, which eliminates the clutter of explicitly writing binds.</p>\n<p style=\"text-align:center;\"><strong>Call by Optional</strong></p>\n<p>By default, Scala functions are call by value, meaning that function parameters will be reduced prior to evaluating the function body. However, Scala let&#8217;s you override this default by adding => before a parameter&#8217;s type:</p>\n<pre>// x is call by value\n// y is call by value\ndef fun1(x: Int, y: Int)\n\n// x is call by value\n// y is call by name\ndef fun2(x: Int, y: => Int)</pre>\n<p>The <code>y</code> parameter in <code>fun2</code> will be call by name, meaning that it will only be evaluated if and when it&#8217;s used in the function body.</p>\n<p>While this is a relatively minor feature, it speaks to a general theme that I&#8217;ve noticed with Scala: the language provides you with <em>many</em> tools, opening up multiple ways to solve a problem. While this flexibility can be misused or confusing, so far I&#8217;ve found that it contributes to Scala being a great practical language. Code can be structured using functional ideas, while still incorporating object-oriented ideas and allowing access to the extensive ecosystem of Java libraries.</p>\n<p>Here are some links with more details on these areas:</p>\n<p>Variance and Type Bounds:</p>\n<ul>\n<li><a href=\"http://en.wikipedia.org/wiki/Covariance_and_contravariance_%28computer_science%29\" target=\"_blank\">Wikipedia article</a></li>\n<li><a href=\"http://stackoverflow.com/questions/663254/scala-covariance-contravariance-question\" target=\"_blank\">Relevant Stack Overflow question</a></li>\n<li><a href=\"http://docs.scala-lang.org/tutorials/tour/lower-type-bounds.html\">Variances in the Scala Tour</a></li>\n<li><a href=\"https://twitter.github.io/scala_school/type-basics.html\" target=\"_blank\">A longer tutorial about Scala types</a></li>\n</ul>\n<p>For Comprehensions:</p>\n<ul>\n<li><a href=\"http://stackoverflow.com/questions/1052476/what-is-scalas-yield/1052510#1052510\">Relevant Stack Overflow post (specifically the top 2 answers)</a></li>\n</ul>\n<p>There are also some good general Scala resources that the course pointed to:</p>\n<ul>\n<li><a href=\"https://github.com/lampepfl/progfun-wiki/blob/gh-pages/CheatSheet.md\">Scala Cheat Sheet</a></li>\n<li><a href=\"http://stackoverflow.com/tags/scala/info\">List of Scala questions by Topic</a></li>\n<li><a href=\"http://twitter.github.io/scala_school/\">Twitter&#8217;s Scala School</a></li>\n<li>Scala&#8217;s <a href=\"http://docs.scala-lang.org/tutorials/\">Tutorials</a> and <a href=\"http://docs.scala-lang.org/overviews/\">Overviews</a></li>\n</ul>\n",
  "wfw:commentRss": "https://wellecks.wordpress.com/2014/11/27/scala-coursera-highlights/feed/",
  "slash:comments": 0,
  "media:content": {
    "media:title": "wellecks"
  }
}