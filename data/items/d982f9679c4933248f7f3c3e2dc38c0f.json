{
  "id": "tag:blogger.com,1999:blog-1176949257541686127.post-4063859688883354856",
  "published": "2022-04-07T09:00:00.002-04:00",
  "updated": "2022-04-07T11:33:30.120-04:00",
  "title": "Improving software supply chain security with tamper-proof builds",
  "content": "<span class=\"byline-author\">Posted by Asra Ali and Laurent Simon, Google Open Source Security Team (GOSST)</span><div><br /></div>Many of the recent high-profile software attacks that have alarmed open-source users globally were consequences of supply chain integrity vulnerabilities: attackers gained control of a build server to <a href=\"https://www.crowdstrike.com/blog/sunspot-malware-technical-analysis/\">use malicious source files</a>, <a href=\"https://www.crowdstrike.com/blog/sunspot-malware-technical-analysis/\">inject malicious artifacts</a> into a compromised build platform, and bypass trusted builders to <a href=\"https://about.codecov.io/apr-2021-post-mortem/\">upload malicious artifacts</a>. <br /><br />Each of these attacks could have been prevented if there were a way to detect that the delivered artifacts diverged from the expected origin of the software. But until now, generating verifiable information that described where, when, and how software artifacts were produced (information known as provenance) was difficult. This information allows users to trace artifacts verifiably back to the source and develop risk-based policies around what they consume. Currently, provenance generation is not widely supported, and solutions that do exist may require migrating build processes to services like <a href=\"https://github.com/tektoncd/chains\">Tekton Chains</a>.<br /><br />This blog post describes a new method of generating non-forgeable provenance using <a href=\"https://docs.github.com/en/actions/using-workflows\">GitHub Actions workflows</a> for isolation and <a href=\"https://www.sigstore.dev/\">Sigstore’s</a> signing tools for authenticity. Using this approach, projects building on GitHub runners can achieve <a href=\"https://slsa.dev/spec/v0.1/requirements\">SLSA 3</a> (the third of four progressive SLSA “levels”), which affirms to consumers that your artifacts are authentic and trustworthy. <br /><br /><div><h1 style=\"text-align: left;\"><b><span style=\"font-size: large;\">Provenance</span></b></h1><br /><a href=\"https://slsa.dev/\">SLSA</a> (\"Supply-chain Levels for Software Artifacts”) is a framework to help improve the integrity of your project throughout its development cycle, allowing consumers to trace the final piece of software you release all the way back to the source. Achieving a high SLSA level helps to improve the trust that your artifacts are what you say they are.<br /><br />This blog post focuses on build provenance, which gives users important information about the build: who performed the release process? Was the build artifact protected against malicious tampering? Source provenance describes how the source code was protected, which we’ll cover in future blog posts, so stay tuned.</div><div><br /><h1 style=\"text-align: left;\"><b><span style=\"font-size: large;\">Go prototype to generate non-forgeable build provenance</span></b></h1><br />To create tamperless evidence of the build and allow consumer verification, you need to:<br /><ol style=\"text-align: left;\"><li>Isolate the provenance generation from the build process;</li><li>Isolate against maintainers interfering in the workflow;</li><li>Provide a mechanism to identify the builder during provenance verification.</li></ol><br />The full isolation described in the first two points allows consumers to trust that the provenance was faithfully recorded; entities that provide this guarantee are called trusted builders.<br /><br />Our <a href=\"https://github.com/slsa-framework/slsa-github-generator-go\">Go prototype</a> solves all three challenges. It also includes running the build inside the trusted builder, which provides a strong guarantee that the build achieves SLSA 3’s <a href=\"https://slsa.dev/spec/v0.1/requirements#ephemeral-environment\">ephemeral</a> and <a href=\"https://slsa.dev/spec/v0.1/requirements#isolated\">isolated</a> requirement.<h2 style=\"text-align: left;\"></h2><h1 style=\"text-align: left;\"><b><span style=\"font-size: large;\">How does it work?</span></b></h1></div><div>The following steps create the trusted builder that is necessary to generate provenance in isolation from the build and maintainer’s interference.<br /><b><br /></b></div><div><b>Step One: Create a reusable workflow on GitHub runners<br /></b><br />Leveraging GitHub’s <a href=\"https://docs.github.com/en/actions/using-workflows/reusing-workflows\">reusable workflows</a> provides the isolation mechanism from both maintainers’ caller workflows and from the build process. Within the workflow, Github Actions creates <a href=\"https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions#the-components-of-github-actions\">fresh instances of virtual machines (VMs), called runners, for each job</a>. These separate VMs give the necessary isolation for a trusted builder, so that different VMs compile the project and generate and sign the SLSA provenance (see diagram below).<br /><br />Running the workflow on <a href=\"https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners\">GitHub-hosted runners</a> gives the guarantee that the code run is in fact the intended workflow, which <a href=\"https://docs.github.com/en/actions/hosting-your-own-runners/about-self-hosted-runners\">self-hosted runners</a> do not. This prototype relies on GitHub to run the exact code defined in the workflow.<br /><br />The reusable workflow also protects against possible interference from maintainers, who could otherwise try to define the workflow in a way that interferes with the builder. The only way to interact with a reusable workflow is through the input parameters it exposes to the calling workflow, which stops maintainers from altering information via <a href=\"https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#env\">environment variables</a>, <a href=\"https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idsteps\">steps</a>, <a href=\"https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idservices\">services</a> and <a href=\"https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#defaults\">defaults</a>. <br /><br />To protect against the possibility of one job (e.g. the build step) tampering with the other artifacts used by another job (the provenance step), this approach uses a trusted channel to protect the integrity of the data. We use <a href=\"https://docs.github.com/en/actions/using-jobs/defining-outputs-for-jobs\">job outputs</a> to send hashes (due to size limitations) and then use the hashes to verify the binary received via the untrusted artifact registry. <br /><br /></div><div><b>Step 2: Use OpenID Connect (OIDC) to prove the identity of the workflow to an external service (Sigstore)</b><br /><br />OpenID Connect (OIDC) is a standard used across the web for identity providers (e.g., Google) to attest to the identity of a user for a third party. GitHub now <a href=\"https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect\">supports</a> OIDC in their workflows. Each time a workflow is run, a runner can mint a unique <a href=\"https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect#understanding-the-oidc-token\">JWT token</a> from GitHub’s OIDC provider. The token contains verifiable information of the workflow identity, including the caller repository, commit hash, trigger, and the current (reuseable) workflow path and reference. <br /><br />Using OIDC, the workflow proves its identity to <a href=\"https://www.sigstore.dev/\">Sigstore's</a> Fulcio root Certificate Authority, which acts as an external verification service. Fulcio signs a short-lived certificate attesting to an ephemeral signing key generated in the runner and tying it to the workload identity. A record of signing the provenance is kept in Sigstore’s transparency log <a href=\"https://github.com/sigstore/rekor\">Rekor</a>. Users can use the signing certificate as a trust anchor to verify that the provenance was authenticated and non-forgeable; it must have been created inside the trusted builder.<h1 style=\"text-align: left;\"><span style=\"font-size: large;\"><b>Verification</b></span></h1></div><div><br />The consumer can verify the artifact and its signed provenance with these steps:<br /><ol style=\"text-align: left;\"><li>Look up the corresponding Rekor log entry and verify the signature;</li><li>Verify the trusted builder identity by extracting it from the signing certificate;</li><li>Check that the provenance information matches the expected source and build.</li></ol>See an <a href=\"https://github.com/slsa-framework/slsa-github-generator-go\">example in action</a> in the official repository.<br /><br />Performing these steps guarantees to the consumer that the binary was produced in the trusted builder at a given commit hash attested to in the provenance. They can trust that the information in the provenance was non-forgeable, allowing them to trust the build “recipe” and trace their artifact verifiably back to the source.<br /><br /></div><div><h1 style=\"text-align: left;\"><b><span style=\"font-size: large;\">Extra Bonus: Keyless signing</span></b></h1>One extra benefit of this method is that maintainers don’t need to manage or distribute cryptographic keys for signing, avoiding the <a href=\"https://caremad.io/posts/2013/07/packaging-signing-not-holy-grail/\">notoriously difficult problem</a> of key management. The OIDC protocol requires no hardcoded, long-term secrets be stored in GitHub's secrets, which sidesteps the potential problem of key mismanagement invalidating the SLSA provenance. Consumers simply use OIDC to verify that the binary artifact was built from a trusted builder that produced the expected provenance. <br /><h1 style=\"text-align: left;\"><b><span style=\"font-size: large;\">Next Steps</span></b></h1>Utilizing the SLSA framework is a proven way for ensuring software supply-chain integrity at scale. This prototype shows  that achieving high SLSA levels is easier than ever thanks to the newest features of popular CI/CD systems and open-source tooling. Increased adoption of tamper-safe (SLSA 3+) build services will contribute to a stronger open-source ecosystem and help close one easily exploited gap in the current supply chain.<br /><br />We encourage testing and adoption and welcome any improvements to the project. Please share feedback, comments and suggestions at <a href=\"https://github.com/slsa-framework/slsa-github-generator-go\">slsa-github-generator-go</a> and <a href=\"https://github.com/slsa-framework/slsa-verifier\">slsa-verifier</a> project repositories. We will officially release v1 in a few weeks!<br /><br />In follow-up posts, we will demonstrate adding non-forgeable source provenance attesting to secure repository settings, and showcase the same techniques for other build toolchains and package managers, etc. Stay tuned!</div>",
  "link": [
    "",
    "",
    "",
    "",
    ""
  ],
  "author": {
    "name": "Unknown",
    "email": "noreply@blogger.com",
    "gd:image": ""
  },
  "thr:total": 0
}