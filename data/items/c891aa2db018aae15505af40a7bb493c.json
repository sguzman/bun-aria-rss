{
  "title": "Image Dithering in R",
  "link": "",
  "updated": "2019-01-22T22:40:00+00:00",
  "id": "http://www.sumsar.net/blog/2019/01/image-dithering-in-r",
  "category": "",
  "content": "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\" \"http://www.w3.org/TR/REC-html40/loose.dtd\">\n<html><body>\n<p>This January I played the most intriguing computer game I’ve played in ages: <a href=\"https://obradinn.com/\">The Return of the Obra Dinn</a>. Except for being a masterpiece of murder-mystery storytelling it also has the most unique art-style as it only uses black and white pixels. To pull this off Obra Dinn makes use of <em>image dithering</em>: the arrangement of pixels of low color resolution to emulate the color shades in between. Since the game was over all too quickly I thought I instead would explore how basic image dithering can be implemented in R. If old school graphics piques your interest, read on! There will be some grainy looking ggplot charts at the end.</p>\n\n<p><a href=\"https://obradinn.com/\"><img src=\"http://www.sumsar.net/images/posts/2019-01-22-image-dithering-in-r/obra_dinn_title_cropped.gif\" alt=\"\"></a></p>\n\n<p>(<em>The image above is copyright Lucas Pope and is the title screen of <a href=\"https://obradinn.com/\">The Return of the Obra Dinn</a></em>)</p>\n\n<!-- more -->\n\n<h2 id=\"horatio-nelson-in-black-and-white\">Horatio Nelson in black and white</h2>\n\n<p>Image dithering tries to solve the problem that you want to show an image with many shades of color, but your device can only display a much smaller number of colors. This might sound like a silly problem now, but was a very real problem in the early days of computers. For example, <a href=\"https://en.wikipedia.org/wiki/Macintosh_128K\">the original Mac</a> could only display black and white pixels, not even any shades of grey!</p>\n\n<p>So let’s do some image dithering in R! The Return of Obra Dinn takes place on an early 19th century East Indiaman ship, so let’s use something related as an example image. Why not use <a href=\"https://upload.wikimedia.org/wikipedia/commons/thumb/7/72/HoratioNelson1.jpg/199px-HoratioNelson1.jpg\">a low-resolution painting of Vice Admiral Horatio Nelson</a> (1758 - 1805) the British officer who defeated the French and Spanish navies during the battle of Trafalgar. To read in the image I will use the <a href=\"http://dahtah.github.io/imager/\"><code>imager</code></a> package.</p>\n\n<pre><code><div class=\"highlight\" style=\"background: #f8f8f8\"><pre style=\"line-height: 125%\">library(imager)\nnelson <span style=\"color: #666666\"><-</span> load.image(<span style=\"color: #BA2121\">\"horatio_nelson.jpg\"</span>)\nnelson\n</pre></div></code></pre>\n\n<pre><code><div class=\"highlight\" style=\"background: #f8f8f8\"><pre style=\"line-height: 125%\"><span style=\"color: #408080; font-style: italic\">## Image. Width: 199 pix Height: 240 pix Depth: 1 Colour channels: 3</span>\n</pre></div></code></pre>\n\n<p>The <a href=\"http://dahtah.github.io/imager/\"><code>imager</code></a> package is a really useful package when you want to manipulate (and mess with) images directly in R. The <code>nelson</code> object is now a <code>cimg</code> object, which is basically an <code>array</code> with dimensions Width, Height, Depth (a time dimension, if you have a series of images), and Color channels. More importantly, <code>cimg</code> objects can be <code>plot</code>ted:</p>\n\n<pre><code><div class=\"highlight\" style=\"background: #f8f8f8\"><pre style=\"line-height: 125%\">plot(nelson)\n</pre></div></code></pre>\n\n<p><img src=\"http://www.sumsar.net/figures/2019-01-22-image-dithering-in-r/unnamed-chunk-3-1.png\" alt=\"\"><!-- --></p>\n\n<p>As an example, I’m going to do black-and-white dithering so let’s remove the color and any transparency (called “alpha” here) from the image.</p>\n\n<pre><code><div class=\"highlight\" style=\"background: #f8f8f8\"><pre style=\"line-height: 125%\">nelson_gray <span style=\"color: #666666\"><-</span> grayscale( rm.alpha(nelson) )\nplot(nelson_gray)\n</pre></div></code></pre>\n\n<p><img src=\"http://www.sumsar.net/figures/2019-01-22-image-dithering-in-r/unnamed-chunk-4-1.png\" alt=\"\"><!-- --></p>\n\n<p>Now let’s imagine that we would want to display this image using only black and white pixels. Before getting to the dithering, what would the simplest method be to achieve this? Well, we could just <em>threshold</em> the image. A pixel with value <code>0.0</code> (fully black) to <code>0.5</code> are made black, and pixels with values above <code>0.5</code> are set to white (<code>1.0</code>). This is easy to do as <code>nelson_gray</code> can be treated as a matrix:</p>\n\n<pre><code><div class=\"highlight\" style=\"background: #f8f8f8\"><pre style=\"line-height: 125%\">nelson_threshold <span style=\"color: #666666\"><-</span> nelson_gray <span style=\"color: #666666\">></span> <span style=\"color: #666666\">0.5</span>\nplot(nelson_threshold)\n</pre></div></code></pre>\n\n<p><img src=\"http://www.sumsar.net/figures/2019-01-22-image-dithering-in-r/unnamed-chunk-5-1.png\" alt=\"\"><!-- --></p>\n\n<p>So, while the image looks kind of cool, it has lost a lot of nuance as large parts of it are now completely black. So how to fake shades of gray using only black and white pixels? Well, you can <em>dither</em> the image, that is, add some noise to the image as you reduce the number of colors. Let’s start by trying out the most basic kind of noise: White noise, here created using the <code>runif</code> function: </p>\n\n<pre><code><div class=\"highlight\" style=\"background: #f8f8f8\"><pre style=\"line-height: 125%\">rand_matrix <span style=\"color: #666666\"><-</span> matrix(\n  data <span style=\"color: #666666\">=</span> runif(length(nelson_gray)),\n  ncol <span style=\"color: #666666\">=</span> ncol(nelson_gray), nrow<span style=\"color: #666666\">=</span>nrow(nelson_gray))\nrand_cimg <span style=\"color: #666666\"><-</span> as.cimg(rand_matrix)\nplot(rand_cimg)\n</pre></div></code></pre>\n\n<p><img src=\"http://www.sumsar.net/figures/2019-01-22-image-dithering-in-r/unnamed-chunk-6-1.png\" alt=\"\"><!-- --></p>\n\n<p>Each pixel in <code>rand_cimg</code> is a value from <code>0.0</code> to <code>1.0</code> and we can now use <code>rand_cimg</code> when thresholding instead of the static <code>0.5</code>. If you try out many different noise images then every black and white pixel will <em>on average</em> have the same value as the original grayscale pixel. This sounds like a good property, but let’s see how it looks with the current <code>rand_cimg</code>:</p>\n\n<pre><code><div class=\"highlight\" style=\"background: #f8f8f8\"><pre style=\"line-height: 125%\">nelson_rand <span style=\"color: #666666\"><-</span> nelson_gray <span style=\"color: #666666\">></span> rand_cimg\nplot(nelson_rand)\n</pre></div></code></pre>\n\n<p><img src=\"http://www.sumsar.net/figures/2019-01-22-image-dithering-in-r/unnamed-chunk-7-1.png\" alt=\"\"><!-- --></p>\n\n<p>To be correct <em>on average</em> doesn’t help much, <em>in practice</em>, we get a very noisy Nelson. But if you squint you can now see shades of gray in the picture, at least. Random noise is just too random, but maybe we can get better dithering by adding less random noise. What about a checker pattern?</p>\n\n<pre><code><div class=\"highlight\" style=\"background: #f8f8f8\"><pre style=\"line-height: 125%\">checker_pattern <span style=\"color: #666666\"><-</span> rbind(c(<span style=\"color: #666666\">1/3</span>, <span style=\"color: #666666\">2/3</span>),\n                         c(<span style=\"color: #666666\">2/3</span>, <span style=\"color: #666666\">1/3</span>))\nplot(as.cimg(checker_pattern))\n</pre></div></code></pre>\n\n<p><img src=\"http://www.sumsar.net/figures/2019-01-22-image-dithering-in-r/unnamed-chunk-8-1.png\" alt=\"\"><!-- --></p>\n\n<p>The pattern above uses cutoffs of 1/3 and 2/3, so Nelson-pixels that gets compared to a darker 1/3-pixel will be more likely to go white and Nelson-pixels that are compared to a lighter 2/3-pixel will tend to go black. Let’s scale this patter to Nelson-size.</p>\n\n<pre><code><div class=\"highlight\" style=\"background: #f8f8f8\"><pre style=\"line-height: 125%\"><span style=\"color: #408080; font-style: italic\"># rep_mat takes a matrix (mat) and tiles it so that the resulting</span>\n<span style=\"color: #408080; font-style: italic\"># matrix has size nrow_out x ncol_out.</span>\n<span style=\"color: #408080; font-style: italic\"># It's basically a 2d version of rep()</span>\nrep_mat <span style=\"color: #666666\"><-</span> <span style=\"color: #008000; font-weight: bold\">function</span>(mat, nrow_out, ncol_out) {\n  mat[rep(seq_len(nrow(mat)), length.out <span style=\"color: #666666\">=</span> nrow_out),\n      rep(seq_len(ncol(mat)), length.out <span style=\"color: #666666\">=</span> ncol_out)]\n}\n\nchecker_cimg <span style=\"color: #666666\"><-</span> as.cimg(rep_mat(checker_pattern, nrow(nelson_gray), ncol(nelson_gray)))\nplot(checker_cimg)\n</pre></div></code></pre>\n\n<p><img src=\"http://www.sumsar.net/figures/2019-01-22-image-dithering-in-r/unnamed-chunk-9-1.png\" alt=\"\"><!-- --></p>\n\n<p>And let’s do the thresholding with this new checker pattern:</p>\n\n<pre><code><div class=\"highlight\" style=\"background: #f8f8f8\"><pre style=\"line-height: 125%\">nelson_checker <span style=\"color: #666666\"><-</span> nelson_gray <span style=\"color: #666666\">></span> checker_cimg\nplot(nelson_checker)\n</pre></div></code></pre>\n\n<p><img src=\"http://www.sumsar.net/figures/2019-01-22-image-dithering-in-r/unnamed-chunk-10-1.png\" alt=\"\"><!-- --></p>\n\n<p>Well, it’s not good, but it kind of looks like we got at least one shade of gray now compared to using the static <code>0.5</code>. Actually, that’s exactly what we got! We can see that by taking a smooth gradient…</p>\n\n<pre><code><div class=\"highlight\" style=\"background: #f8f8f8\"><pre style=\"line-height: 125%\">gradient <span style=\"color: #666666\"><-</span> as.cimg( rep(seq(<span style=\"color: #666666\">0</span>, <span style=\"color: #666666\">1</span>, <span style=\"color: #666666\">0.01</span>), <span style=\"color: #666666\">101</span>), x<span style=\"color: #666666\">=101</span>, y<span style=\"color: #666666\">=101</span>)\nplot(gradient)\n</pre></div></code></pre>\n\n<p><img src=\"http://www.sumsar.net/figures/2019-01-22-image-dithering-in-r/unnamed-chunk-11-1.png\" alt=\"\"><!-- --></p>\n\n<p>… and thresholding with the checker pattern:</p>\n\n<pre><code><div class=\"highlight\" style=\"background: #f8f8f8\"><pre style=\"line-height: 125%\">checker_cimg <span style=\"color: #666666\"><-</span> as.cimg(rep_mat(checker_pattern,\n                                nrow(gradient), ncol(gradient)))\ngradient_checker <span style=\"color: #666666\"><-</span> gradient <span style=\"color: #666666\">></span> checker_cimg\nplot(gradient_checker)\n</pre></div></code></pre>\n\n<p><img src=\"http://www.sumsar.net/figures/2019-01-22-image-dithering-in-r/unnamed-chunk-12-1.png\" alt=\"\"><!-- --></p>\n\n<p>This gives us three columns: black, “checker-gray”, and white. So, using the checker pattern we can achieve some more nuance than with simple thresholding. Is there perhaps an even better pattern that allows for even more nuance?</p>\n\n<h2 id=\"better-patterns-bayer-patterns\">Better patterns, Bayer patterns</h2>\n\n<p>Yes, there is! The classical pattern used in many image dithering implementations is the <em>Bayer pattern</em> (or <em>Bayer matrix</em>) named after it’s inventor Bryce Bayer. It’s an evolution of the checker pattern defined for matrices of size 2×2, 4×4, 8×8, etc. The exact construction and properties of the Bayer matrix are well described in <a href=\"https://en.wikipedia.org/wiki/Ordered_dithering\">the Wikipedia article</a> but here is how to create it in R and how it looks:</p>\n\n<pre><code><div class=\"highlight\" style=\"background: #f8f8f8\"><pre style=\"line-height: 125%\"><span style=\"color: #408080; font-style: italic\"># Calculates a non-normalized Bayer pattern matrix of size 2^n</span>\nrecursive_bayer_pattern <span style=\"color: #666666\"><-</span> <span style=\"color: #008000; font-weight: bold\">function</span>(n) {\n  <span style=\"color: #008000; font-weight: bold\">if</span>(n <span style=\"color: #666666\"><=</span> <span style=\"color: #666666\">0</span>) {\n    <span style=\"color: #008000; font-weight: bold\">return</span>(matrix(<span style=\"color: #666666\">0</span>))\n  }\n  m <span style=\"color: #666666\"><-</span> recursive_bayer_pattern(n <span style=\"color: #666666\">-</span> <span style=\"color: #666666\">1</span>)\n  rbind(\n    cbind(<span style=\"color: #666666\">4</span> <span style=\"color: #666666\">*</span> m <span style=\"color: #666666\">+</span> <span style=\"color: #666666\">0</span>, <span style=\"color: #666666\">4</span> <span style=\"color: #666666\">*</span> m <span style=\"color: #666666\">+</span> <span style=\"color: #666666\">2</span>),\n    cbind(<span style=\"color: #666666\">4</span> <span style=\"color: #666666\">*</span> m <span style=\"color: #666666\">+</span> <span style=\"color: #666666\">3</span>, <span style=\"color: #666666\">4</span> <span style=\"color: #666666\">*</span> m <span style=\"color: #666666\">+</span> <span style=\"color: #666666\">1</span>))\n}\n\n<span style=\"color: #408080; font-style: italic\"># Returns a Bayer pattern of size 2^n normalized so all values</span>\n<span style=\"color: #408080; font-style: italic\"># are between 0.0 and 1.0.</span>\nnormalized_bayer_pattern <span style=\"color: #666666\"><-</span> <span style=\"color: #008000; font-weight: bold\">function</span>(n) {\n  pattern <span style=\"color: #666666\"><-</span> recursive_bayer_pattern(n)\n  (<span style=\"color: #666666\">1</span> <span style=\"color: #666666\">+</span> pattern) <span style=\"color: #666666\">/</span> ( <span style=\"color: #666666\">1</span> <span style=\"color: #666666\">+</span> length(pattern) )\n}\n\npar(mfcol <span style=\"color: #666666\">=</span> c(<span style=\"color: #666666\">1</span>, <span style=\"color: #666666\">3</span>), mar <span style=\"color: #666666\">=</span> c(<span style=\"color: #666666\">0</span>, <span style=\"color: #666666\">0</span>, <span style=\"color: #666666\">2</span>, <span style=\"color: #666666\">1</span>), ps <span style=\"color: #666666\">=</span> <span style=\"color: #666666\">18</span>)\nplot(as.cimg(normalized_bayer_pattern(<span style=\"color: #666666\">1</span>)), main <span style=\"color: #666666\">=</span> <span style=\"color: #BA2121\">\"Bayer 2×2\"</span>)\nplot(as.cimg(normalized_bayer_pattern(<span style=\"color: #666666\">2</span>)), main <span style=\"color: #666666\">=</span> <span style=\"color: #BA2121\">\"Bayer 4×4\"</span>)\nplot(as.cimg(normalized_bayer_pattern(<span style=\"color: #666666\">3</span>)), main <span style=\"color: #666666\">=</span> <span style=\"color: #BA2121\">\"Bayer 8×8\"</span>)\n</pre></div></code></pre>\n\n<p><img src=\"http://www.sumsar.net/figures/2019-01-22-image-dithering-in-r/unnamed-chunk-14-1.png\" alt=\"\"><!-- --></p>\n\n<p>Basically, a Bayer matrix contains as many shades of gray it’s possible to fit in there, and the shades are as spread out as possible. Let’s see how a 4x4 Bayer matrix transforms the smooth gradient: </p>\n\n<pre><code><div class=\"highlight\" style=\"background: #f8f8f8\"><pre style=\"line-height: 125%\">bayer_cimg <span style=\"color: #666666\"><-</span> as.cimg(rep_mat(normalized_bayer_pattern(<span style=\"color: #666666\">2</span>),\n                              nrow(gradient), ncol(gradient)))\ngradient_bayer <span style=\"color: #666666\"><-</span> gradient <span style=\"color: #666666\">></span> bayer_cimg\nplot(gradient_bayer)\n</pre></div></code></pre>\n\n<p><img src=\"http://www.sumsar.net/figures/2019-01-22-image-dithering-in-r/unnamed-chunk-16-1.png\" alt=\"\"><!-- --></p>\n\n<p>Pretty smooth! We get the classical “crosshatch” patterns reminiscent of last-century computer graphics. Let’s give Admiral Nelson the same treatment:</p>\n\n<pre><code><div class=\"highlight\" style=\"background: #f8f8f8\"><pre style=\"line-height: 125%\">bayer_matrix <span style=\"color: #666666\"><-</span> rep_mat(normalized_bayer_pattern(<span style=\"color: #666666\">2</span>),\n                        nrow(nelson_gray), ncol(nelson_gray))\nbayer_cimg <span style=\"color: #666666\"><-</span> as.cimg(bayer_matrix)\nnelson_bayer <span style=\"color: #666666\"><-</span> nelson_gray <span style=\"color: #666666\">></span> bayer_cimg\nplot(nelson_bayer)\n</pre></div></code></pre>\n\n<p><img src=\"http://www.sumsar.net/figures/2019-01-22-image-dithering-in-r/unnamed-chunk-17-1.png\" alt=\"\"><!-- --></p>\n\n<p>Now he looks doubly old-school. So far I’ve only worked with grayscale images and black-and-white dithering, but we can quickly hack together some color dithering by just performing the dither thresholding on one color channel at a time.</p>\n\n<pre><code><div class=\"highlight\" style=\"background: #f8f8f8\"><pre style=\"line-height: 125%\">nelson_bayer_color <span style=\"color: #666666\"><-</span> nelson\n<span style=\"color: #008000; font-weight: bold\">for</span>(rgb_i <span style=\"color: #008000; font-weight: bold\">in</span> <span style=\"color: #666666\">1:3</span>) {\n  color_channel <span style=\"color: #666666\"><-</span> nelson_bayer_color[ , , <span style=\"color: #666666\">1</span>, rgb_i, drop <span style=\"color: #666666\">=</span> <span style=\"color: #008000; font-weight: bold\">FALSE</span>]\n  nelson_bayer_color[ , , <span style=\"color: #666666\">1</span>, rgb_i] <span style=\"color: #666666\"><-</span> color_channel <span style=\"color: #666666\">></span> bayer_cimg\n}\nplot(nelson_bayer_color)\n</pre></div></code></pre>\n\n<p><img src=\"http://www.sumsar.net/figures/2019-01-22-image-dithering-in-r/unnamed-chunk-18-1.png\" alt=\"\"><!-- --></p>\n\n<p>This method does not generalize to arbitrary color scales, but I still think it looks pretty cool!</p>\n\n<h2 id=\"image-dithering-ggplots-in-r\">Image dithering ggplots in R</h2>\n\n<p>Finally, I’ll show you how to dither some ggplots. Below is most of the code above wrapped up into functions:</p>\n\n<pre><code><div class=\"highlight\" style=\"background: #f8f8f8\"><pre style=\"line-height: 125%\"><span style=\"color: #408080; font-style: italic\"># rep_mat takes a matrix (mat) and tiles it so that the resulting</span>\n<span style=\"color: #408080; font-style: italic\"># matrix has size nrow_out × ncol_out.</span>\n<span style=\"color: #408080; font-style: italic\"># It's basically a 2d version of rep()</span>\nrep_mat <span style=\"color: #666666\"><-</span> <span style=\"color: #008000; font-weight: bold\">function</span>(mat, nrow_out, ncol_out) {\n  mat[rep(seq_len(nrow(mat)), length.out <span style=\"color: #666666\">=</span> nrow_out),\n      rep(seq_len(ncol(mat)), length.out <span style=\"color: #666666\">=</span> ncol_out)]\n}\n\n<span style=\"color: #408080; font-style: italic\"># Calculates a Bayer pattern matrix of size 2^n</span>\n<span style=\"color: #408080; font-style: italic\"># Source: https://gist.github.com/MehdiNS/bd41bbc6db780c9409157d35d331ac80</span>\nrecursive_bayer_pattern <span style=\"color: #666666\"><-</span> <span style=\"color: #008000; font-weight: bold\">function</span>(n) {\n  <span style=\"color: #008000; font-weight: bold\">if</span>(n <span style=\"color: #666666\"><=</span> <span style=\"color: #666666\">0</span>) {\n    <span style=\"color: #008000; font-weight: bold\">return</span>(matrix(<span style=\"color: #666666\">0</span>))\n  }\n  m <span style=\"color: #666666\"><-</span> recursive_bayer_pattern(n <span style=\"color: #666666\">-</span> <span style=\"color: #666666\">1</span>)\n  rbind(\n    cbind(<span style=\"color: #666666\">4</span> <span style=\"color: #666666\">*</span> m <span style=\"color: #666666\">+</span> <span style=\"color: #666666\">0</span>, <span style=\"color: #666666\">4</span> <span style=\"color: #666666\">*</span> m <span style=\"color: #666666\">+</span> <span style=\"color: #666666\">2</span>),\n    cbind(<span style=\"color: #666666\">4</span> <span style=\"color: #666666\">*</span> m <span style=\"color: #666666\">+</span> <span style=\"color: #666666\">3</span>, <span style=\"color: #666666\">4</span> <span style=\"color: #666666\">*</span> m <span style=\"color: #666666\">+</span> <span style=\"color: #666666\">1</span>))\n}\n\n<span style=\"color: #408080; font-style: italic\"># Returns a Bayer pattern of size 2^n normalized so all values</span>\n<span style=\"color: #408080; font-style: italic\"># are between 1 / (m + 1) and m / (m + 1) where m is the number </span>\n<span style=\"color: #408080; font-style: italic\"># of elements in the 2^n × 2^n matrix.</span>\nnormalized_bayer_pattern <span style=\"color: #666666\"><-</span> <span style=\"color: #008000; font-weight: bold\">function</span>(n) {\n  pattern <span style=\"color: #666666\"><-</span> recursive_bayer_pattern(n)\n  (<span style=\"color: #666666\">1</span> <span style=\"color: #666666\">+</span> pattern) <span style=\"color: #666666\">/</span> ( <span style=\"color: #666666\">1</span> <span style=\"color: #666666\">+</span> length(pattern) )\n}\n\n<span style=\"color: #408080; font-style: italic\"># Returns a  nrow_out × ncol_out cimg image repeatig a 2×2 Bayer pattern</span>\nrep_bayer_cimg <span style=\"color: #666666\"><-</span> <span style=\"color: #008000; font-weight: bold\">function</span>(nrow_out, ncol_out) {\n  bayer_matrix <span style=\"color: #666666\"><-</span> rep_mat(normalized_bayer_pattern(<span style=\"color: #666666\">2</span>), nrow_out, ncol_out)\n  as.cimg(bayer_matrix)\n}\n\n<span style=\"color: #408080; font-style: italic\"># Transforms a cimg image into a dithered black and white image</span>\nimg_to_bayer_bw <span style=\"color: #666666\"><-</span> <span style=\"color: #008000; font-weight: bold\">function</span>(img) {\n  img <span style=\"color: #666666\"><-</span> grayscale(rm.alpha(img))\n  bayer_cimg <span style=\"color: #666666\"><-</span> rep_bayer_cimg(nrow(img), ncol(img))\n  img <span style=\"color: #666666\">>=</span> bayer_cimg\n}\n\n<span style=\"color: #408080; font-style: italic\"># Transforms a cimg image into a dithered color image with 8 colors.</span>\nimg_to_bayer_color <span style=\"color: #666666\"><-</span> <span style=\"color: #008000; font-weight: bold\">function</span>(img) {\n  img <span style=\"color: #666666\"><-</span> rm.alpha(img)\n  bayer_cimg <span style=\"color: #666666\"><-</span> rep_bayer_cimg(nrow(img), ncol(img))\n  <span style=\"color: #008000; font-weight: bold\">for</span>(rgb_i <span style=\"color: #008000; font-weight: bold\">in</span> <span style=\"color: #666666\">1:3</span>) {\n    color_channel <span style=\"color: #666666\"><-</span> img[ , , <span style=\"color: #666666\">1</span>, rgb_i, drop <span style=\"color: #666666\">=</span> <span style=\"color: #008000; font-weight: bold\">FALSE</span>]\n    img[ , , <span style=\"color: #666666\">1</span>, rgb_i] <span style=\"color: #666666\"><-</span> color_channel <span style=\"color: #666666\">>=</span> bayer_cimg\n  }\n  img\n}\n</pre></div></code></pre>\n\n<p>Let’s then create the ggplot we will transform.</p>\n\n<pre><code><div class=\"highlight\" style=\"background: #f8f8f8\"><pre style=\"line-height: 125%\">library(ggplot2)\nggplot(mtcars, aes(factor(cyl), mpg, fill <span style=\"color: #666666\">=</span> factor(cyl))) <span style=\"color: #666666\">+</span>\n  geom_violin(color <span style=\"color: #666666\">=</span> <span style=\"color: #BA2121\">\"black\"</span>) <span style=\"color: #666666\">+</span>\n  theme_classic() <span style=\"color: #666666\">+</span>\n  theme(axis.text<span style=\"color: #666666\">=</span> element_text(colour<span style=\"color: #666666\">=</span><span style=\"color: #BA2121\">\"black\"</span>))\n</pre></div></code></pre>\n\n<p><img src=\"http://www.sumsar.net/figures/2019-01-22-image-dithering-in-r/unnamed-chunk-20-1.png\" alt=\"\"><!-- --></p>\n\n<p>Then we’ll turn it into a low res <code>cimg</code> image.</p>\n\n<pre><code><div class=\"highlight\" style=\"background: #f8f8f8\"><pre style=\"line-height: 125%\"><span style=\"color: #408080; font-style: italic\"># This function is a hack to read in a ggplot2 plot as a cimg image </span>\n<span style=\"color: #408080; font-style: italic\"># by saving it as a png to disk and reading it back in.</span>\nggplot_to_cimg <span style=\"color: #666666\"><-</span> <span style=\"color: #008000; font-weight: bold\">function</span>(width, height, dpi) {\n  tmp_fname <span style=\"color: #666666\"><-</span> tempfile(fileext <span style=\"color: #666666\">=</span> <span style=\"color: #BA2121\">\".png\"</span>)\n  ggsave(tmp_fname, width <span style=\"color: #666666\">=</span> width, height <span style=\"color: #666666\">=</span> height, dpi <span style=\"color: #666666\">=</span> dpi, antialias <span style=\"color: #666666\">=</span> <span style=\"color: #BA2121\">\"none\"</span>)\n  load.image(tmp_fname)\n}\n\nplot_img <span style=\"color: #666666\"><-</span> ggplot_to_cimg( width <span style=\"color: #666666\">=</span> <span style=\"color: #666666\">3</span>, height <span style=\"color: #666666\">=</span> <span style=\"color: #666666\">2</span>, dpi <span style=\"color: #666666\">=</span> <span style=\"color: #666666\">140</span>)\nplot(plot_img)\n</pre></div></code></pre>\n\n<p><img src=\"http://www.sumsar.net/figures/2019-01-22-image-dithering-in-r/unnamed-chunk-21-1.png\" alt=\"\"><!-- --></p>\n\n<p>Finally, we can turn it into a retro-dithered black and white plot…</p>\n\n<pre><code><div class=\"highlight\" style=\"background: #f8f8f8\"><pre style=\"line-height: 125%\">plot( img_to_bayer_bw(plot_img) )\n</pre></div></code></pre>\n\n<p><img src=\"http://www.sumsar.net/figures/2019-01-22-image-dithering-in-r/unnamed-chunk-22-1.png\" alt=\"\"><!-- --></p>\n\n<p>…or a dithered eight-color plot. </p>\n\n<pre><code><div class=\"highlight\" style=\"background: #f8f8f8\"><pre style=\"line-height: 125%\">plot( img_to_bayer_color(plot_img) )\n</pre></div></code></pre>\n\n<p><img src=\"http://www.sumsar.net/figures/2019-01-22-image-dithering-in-r/unnamed-chunk-23-1.png\" alt=\"\"><!-- --></p>\n\n<p>Something for your next retro inspired presentation, maybe? If you want to have full control over your image dithering it would probably be more convenient to post-process your plots using an image editor, such as the free and open source <a href=\"https://www.gimp.org/\">GIMP</a> rather than to do it directly in R.</p>\n\n<p>This post has covered basic image dithering in R and, to be more specific, it has covered <a href=\"https://en.wikipedia.org/wiki/Ordered_dithering\">ordered dithering</a>. There is also <a href=\"https://en.wikipedia.org/wiki/Floyd%E2%80%93Steinberg_dithering\">error-diffusion dithering</a> which works in a rather different way. But that’s for another time. Now I’m going to go back to mourning that I’ve already finished <a href=\"https://obradinn.com/\">The Return of the Obra Dinn</a>.</p>\n\n</body></html>\n"
}