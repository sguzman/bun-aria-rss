{
  "title": "XOR Revisited: Keras and TensorFlow",
  "link": "https://aimatters.wordpress.com/2017/04/24/xor-revisited-keras-and-tensorflow/",
  "comments": "https://aimatters.wordpress.com/2017/04/24/xor-revisited-keras-and-tensorflow/#comments",
  "dc:creator": "Stephen Oman",
  "pubDate": "Mon, 24 Apr 2017 21:58:46 +0000",
  "category": [
    "Examples",
    "Machine Learning",
    "Programming",
    "Keras",
    "Python",
    "TensorFlow"
  ],
  "guid": "http://aimatters.wordpress.com/?p=1093",
  "description": "A few weeks ago, it was announced that Keras would be getting official Google support and would become part of the TensorFlow machine learning library. Keras is a collection of high-level APIs in Python for creating and training neural networks, using either Theano or TensorFlow as the underlying engine. Given my previous posts on implementing an [&#8230;]",
  "content:encoded": "<p>A few weeks ago, it was announced that <a href=\"https://keras.io\" target=\"_blank\" rel=\"noopener noreferrer\">Keras</a> would be <a href=\"https://www.reddit.com/r/MachineLearning/comments/5jg7b8/p_deep_learning_for_coders18_hours_of_lessons_for/dbhaizx/\" target=\"_blank\" rel=\"noopener noreferrer\">getting official Google</a> support and would become part of the <a href=\"https://www.tensorflow.org\" target=\"_blank\" rel=\"noopener noreferrer\">TensorFlow</a> machine learning library. Keras is a collection of high-level APIs in Python for creating and training neural networks, using either Theano or TensorFlow as the underlying engine.</p>\n<p>Given my previous posts on implementing an XOR-solving neural network in a variety of different languages and tools, I thought it was time to see what it would look like in Keras.</p>\n<p>XOR can be expressed as a classification problem that is best illustrated in a diagram. The goal is to create a neural network that will correctly predict the values 0 or 1, depending on the inputs <em>x1</em> and <em>x2</em> as shown.</p>\n<p><img loading=\"lazy\" data-attachment-id=\"560\" data-permalink=\"https://aimatters.wordpress.com/2015/12/19/a-simple-neural-network-in-octave-part-1/xor-graph/\" data-orig-file=\"https://aimatters.files.wordpress.com/2015/12/xor-graph.png\" data-orig-size=\"461,428\" data-comments-opened=\"1\" data-image-meta=\"{\"aperture\":\"0\",\"credit\":\"\",\"camera\":\"\",\"caption\":\"\",\"created_timestamp\":\"0\",\"copyright\":\"\",\"focal_length\":\"0\",\"iso\":\"0\",\"shutter_speed\":\"0\",\"title\":\"\",\"orientation\":\"0\"}\" data-image-title=\"xor graph\" data-image-description=\"\" data-image-caption=\"\" data-medium-file=\"https://aimatters.files.wordpress.com/2015/12/xor-graph.png?w=300\" data-large-file=\"https://aimatters.files.wordpress.com/2015/12/xor-graph.png?w=461\" class=\" size-full wp-image-560 aligncenter\" src=\"https://aimatters.files.wordpress.com/2015/12/xor-graph.png\" alt=\"xor graph\" width=\"461\" height=\"428\" srcset=\"https://aimatters.files.wordpress.com/2015/12/xor-graph.png 461w, https://aimatters.files.wordpress.com/2015/12/xor-graph.png?w=150&h=139 150w, https://aimatters.files.wordpress.com/2015/12/xor-graph.png?w=300&h=279 300w\" sizes=\"(max-width: 461px) 100vw, 461px\" /></p>\n<p>The neural network that is capable of being trained to solve that problem looks like this:</p>\n<p><img loading=\"lazy\" data-attachment-id=\"572\" data-permalink=\"https://aimatters.wordpress.com/2015/12/19/a-simple-neural-network-in-octave-part-1/network-2/\" data-orig-file=\"https://aimatters.files.wordpress.com/2015/12/network1.png\" data-orig-size=\"515,260\" data-comments-opened=\"1\" data-image-meta=\"{\"aperture\":\"0\",\"credit\":\"\",\"camera\":\"\",\"caption\":\"\",\"created_timestamp\":\"0\",\"copyright\":\"\",\"focal_length\":\"0\",\"iso\":\"0\",\"shutter_speed\":\"0\",\"title\":\"\",\"orientation\":\"0\"}\" data-image-title=\"network\" data-image-description=\"\" data-image-caption=\"\" data-medium-file=\"https://aimatters.files.wordpress.com/2015/12/network1.png?w=300\" data-large-file=\"https://aimatters.files.wordpress.com/2015/12/network1.png?w=515\" class=\" size-full wp-image-572 aligncenter\" src=\"https://aimatters.files.wordpress.com/2015/12/network1.png\" alt=\"network\" width=\"515\" height=\"260\" srcset=\"https://aimatters.files.wordpress.com/2015/12/network1.png 515w, https://aimatters.files.wordpress.com/2015/12/network1.png?w=150&h=76 150w, https://aimatters.files.wordpress.com/2015/12/network1.png?w=300&h=151 300w\" sizes=\"(max-width: 515px) 100vw, 515px\" /></p>\n<p>If you&#8217;d like to understand why this is the case, have a look at the detailed explanation in the <a href=\"https://aimatters.wordpress.com/2015/12/19/a-simple-neural-network-in-octave-part-1/\" target=\"_blank\" rel=\"noopener noreferrer\">posts implementing the solution in Octave</a>.</p>\n<p>So how does this look in Keras? Well it&#8217;s rather simple. Assuming you&#8217;ve already installed Keras, we&#8217;ll start with setting up the classification problem and the expected outputs:</p>\n<pre>import numpy as np\n\nx = np.array([[0,0], [0,1], [1,0], [1,1]])\ny = np.array([[0], [1], [1], [0]])</pre>\n<p>So far, so good. We&#8217;re using <a href=\"http://www.numpy.org\" target=\"_blank\" rel=\"noopener noreferrer\">numpy</a> arrays to store our inputs (x) and outputs (y). Now for the neural network definition:</p>\n<pre>from keras.models import Sequential\nfrom keras.layers import Dense, Activation\n\nmodel = Sequential()\nmodel.add(Dense(2, input_shape=(2,)))\nmodel.add(Activation('sigmoid'))\nmodel.add(Dense(1))\nmodel.add(Activation('sigmoid'))</pre>\n<p>The Sequential model is simply a sequence of layers making up the network. Our diagram above has a set of inputs being fed into two processing layers. We&#8217;ve already defined the inputs, so all we need to do is add the other two layers.</p>\n<p>In Keras, we&#8217;ll use Dense layers, which simply means they are is fully connected. The parameters indicate that the first layer has two nodes and the second layer has one node, corresponding to the diagram above.</p>\n<p>The first layer also has the shape of the inputs which in this case is a one-dimensional vector with 2 elements. The second layer&#8217;s inputs will be inferred from the first layer.</p>\n<p>We then add an Activation of type &#8216;sigmoid&#8217; to each layer, again matching our neural network definition.</p>\n<p>Note that Keras looks after the bias input without us having to explicitly code for it. In addition, Keras also looks after the weights (Θ1 and Θ2). This makes our neural network definition really straightforward and shows the benefits of using a high-level abstraction.</p>\n<p>Finally, we apply a loss function and learning mode for Keras to be able to adjust the neural network:</p>\n<pre>model.compile(loss='mean_squared_error', optimizer='sgd', metrics=['accuracy'])</pre>\n<p>In this example, we&#8217;ll use the standard Mean Squared Error loss function and Stochastic Gradient Descent optimiser. And that&#8217;s it for the network definition.</p>\n<p>If you want to see that the network looks like, use:</p>\n<pre>model.summary()</pre>\n<p>The network should look like this:</p>\n<pre>>> model.summary()\n_________________________________________________________________\nLayer (type)                  Output Shape         Param # \n=================================================================\ndense_1 (Dense)               (None, 2)            6 \n_________________________________________________________________\nactivation_1 (Activation)     (None, 2)            0 \n_________________________________________________________________\ndense_2 (Dense)               (None, 1)            3 \n_________________________________________________________________\nactivation_2 (Activation)     (None, 1)            0 \n=================================================================\nTotal params: 9\nTrainable params: 9\nNon-trainable params: 0\n_________________________________________________________________\n>>></pre>\n<p>Now we just need to kick off the training of the network.</p>\n<pre>model.fit(x,y, epochs=100000, batch_size=4)</pre>\n<p>All going well, the network weights will converge on a solution that can correctly classify the inputs (if not, you may need to up the number of epochs):</p>\n<pre>>>> model.predict(x, verbose=1)\n\n4/4 [==============================] - 0s\n\narray([[ 0.07856689],\n\n       [ 0.91362464],\n\n       [ 0.92543262],\n\n       [ 0.06886736]], dtype=float32)\n\n>>></pre>\n<p>Clearly this network is on it&#8217;s way to converging on the original expected outputs we defined above (y).</p>\n<p>So that&#8217;s all there is to a Keras version of the XOR-solving neural network. The fact that it is using TensorFlow as the engine is completely hidden and that makes implementing the network a lot simpler.</p>\n<p>&nbsp;</p>\n",
  "wfw:commentRss": "https://aimatters.wordpress.com/2017/04/24/xor-revisited-keras-and-tensorflow/feed/",
  "slash:comments": 5,
  "media:content": [
    {
      "media:title": "stephenoman"
    },
    {
      "media:title": "xor graph"
    },
    {
      "media:title": "network"
    }
  ]
}