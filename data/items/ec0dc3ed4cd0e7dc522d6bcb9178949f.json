{
  "title": "Getting Better at Machine Learning",
  "link": "https://medium.com/@rchang/getting-better-at-machine-learning-16b4dd913a1f?source=rss-c00b242128fe------2",
  "guid": "https://medium.com/p/16b4dd913a1f",
  "category": [
    "data-science",
    "machine-learning"
  ],
  "dc:creator": "Robert Chang",
  "pubDate": "Wed, 26 Sep 2018 02:53:41 GMT",
  "atom:updated": "2018-09-26T02:53:41.623Z",
  "content:encoded": "<h4>Moving Beyond model.fit(X, y)</h4><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*CA_RgxCdZz2ptWmzGaqdpg.png\" /><figcaption><a href=\"https://pixabay.com/en/spot-runs-start-la-stadion-862274/\">Image credit</a>: Getting better at machine learning takes time, effort, and practice!</figcaption></figure><h3><strong>Motivation</strong></h3><p>In <a href=\"https://medium.com/@rchang/a-beginners-guide-to-data-engineering-part-i-4227c5c457d7\">A Beginner’s Guide to Data Engineering</a> series, I argued that academic institutions typically do not teach students the proper <em>mental models</em><strong> </strong>when it comes to analytics workflows in real-life. Far too many classes only focus on the mechanics of data analysis without teaching concepts such as ETL or the importance of building robust data pipelines. Unfortunately, I see a similar pattern in machine learning education as well. Surely, studying the <a href=\"https://blog.ycombinator.com/learning-math-for-machine-learning/\">math behind ML</a> and learning <a href=\"http://scikit-learn.org/stable/tutorial/machine_learning_map/index.html\">different algorithms</a> are valuable. Yet, there exist crucial steps beyond model.fit(X, y) that are important in practice. In this post, I will share some of my learnings that I did not learn in school.</p><p>First, I will highlight the rise of Kaggle: why it has transformed our industry, what critical role it plays, but also where it fell short. In particular, I will contrast the workflow Kaggle reinforced with the typical development workflow of a real-life machine learning project. Throughout the post, I will give coloring examples around topics such as problem definition, feature engineering, model debugging, productionization, and feedback loops. By the end of this post, I hope readers will appreciate some of the complexity and challenges, but also joys, of real-life machine learning.</p><h3>The Rise of Kaggle Competition</h3><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*O2jevBVe3vpYGdryMDWEmA.png\" /><figcaption>Kaggle’s <a href=\"https://www.kaggle.com/challenge-yourself\">Competition Landing Page</a>: Fancy to Join one?</figcaption></figure><p>Ever since its inception in 2010, <a href=\"https://www.kaggle.com/\">Kaggle</a> has become the platform where data enthusiasts around the world compete to solve a wide variety of problems using machine learning. Over time, Kaggle has built an incredible repository of useful benchmark datasets and example notebooks (called <a href=\"https://www.kaggle.com/kernels\">kernels</a>), turned modeling into a sport, and made some practitioners into Kaggle <a href=\"https://www.wired.com/story/solve-these-tough-data-problems-and-watch-job-offers-roll-in/\">stars</a>.</p><h4>Common Task Framework</h4><p>The model that Kaggle follows, is what Professor David Donoho referred to as the <em>Common Task Framework</em> (CTF) in his paper “<a href=\"https://courses.csail.mit.edu/18.337/2015/docs/50YearsDataScience.pdf\">50 years of Data Science</a>”. Donoho argued that the secret sauce to machine learning’s success is partially driven by competitions:</p><blockquote>It is no exaggeration to say that the combination of a predictive modeling culture together with CTF is the ‘secret sauce’ of machine learning. This combination leads directly to a total focus on optimization of empirical performance, which […] allows large numbers of researchers to compete at any given common task challenge, and allows for efficient […] judging of challenge winners.</blockquote><p>Indeed, from DARPA’s machine translation research in the 1980s, the famous 2009 <a href=\"https://www.netflixprize.com/\">Netflix Prize</a>, to the recent success of deep learning due to <a href=\"http://www.image-net.org/challenges/LSVRC/\">ImageNet</a> challenge, the machine learning community continues to bring innovation to the mass under common task framework.</p><h4>Where Kaggle Competition Fall Short</h4><p>While Kaggle competitions have been tremendously educational, their workflows generally only reflect a small subset of what is involved in real-life machine learning projects. First of all, Kaggle hosts formulate the problems, not the participants. Not only are the loss functions and golden datasets used for evaluation pre-determined, but training labels / data are often handed to the participants on a silver platter. Furthermore, there is very little concern regarding how to integrate models into a decision process or a product. These are all conditions real projects are unlikely to meet in practice. As a result, a lot of the considerations in machine learning projects are lost in translation.</p><h3>Machine Learning Workflow</h3><p>When building a machine learning product, we are no longer developing <em>models </em>in isolation (what people sometimes called “<strong>Laptop Data Science</strong>”). Rather, we are building a <em>system </em>that interacts with real human beings. Not only do we need to think strategically about the problems we are solving for the end users, but we also need to ensure that the user experience is intuitive, predictions are accurate, and inference is efficient.</p><h4>Think and Build a System End-to-End</h4><p>These conditions mean that we almost never jump to modeling immediately, we have to think and build the <em>system</em> end-to-end. In Rachel Thomas’ fantastic post “<a href=\"http://www.fast.ai/2018/07/12/auto-ml-1/\">What do machine learning practitioners actually do?</a>”, she explains the typical workflow of a machine learning project:</p><blockquote>Building a machine learning product is a multi-faceted and complex task […] machine learning practitioners may need to do during the process: <strong>understanding the context, preparing the data, building the model, productionization, </strong>and<strong> monitoring. </strong>[…] Certainly, not every machine learning practitioner needs to do all of the above steps, but components of this process will be a part of many machine learning applications.</blockquote><p>Kaggle is an amazing platform that focuses on model building, but less so on the rest of the steps described above. To help readers to better understand these other topics, I will highlight them using a combination of my personal experience and illuminating examples from other companies that I find useful. Below, I will discuss:</p><ul><li><strong>Problem Definition</strong>: why thinking hard about your problem is crucial</li><li><strong>Data Collection: </strong>why setting up your {X, y} right is half of the job done</li><li><strong>Model Building:</strong> how to debug your model when it does not perform well</li><li><strong>Productionization:</strong> what “putting model into production” really means</li><li><strong>Feedback Loop: </strong>how unintended feedback loop can affect your system</li></ul><h3>1. Defining Problem Is Hard and Not Always Obvious</h3><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*VE8tyll3F_D__s0804H5_g.png\" /><figcaption><a href=\"https://pixabay.com/en/architecture-house-3d-design-1477041/\">Image source</a>: Do you think this house can be an Airbnb Plus Home?</figcaption></figure><p>Let’s start with a case study, <a href=\"https://www.airbnb.com/plus\">Airbnb Plus</a>, a product whose mission is to bring high-quality homes to the Airbnb marketplace. While many employees are passionate about finding homes suitable for Plus, doing this at scale can be challenging. On our team, we use a combination of human evaluation and machine learning to identify high potential homes. This type of problem, which involves human evaluations + machine predictions, are becoming increasingly <a href=\"https://www.slideshare.net/EricColson/blending-human-computing-and-recommender-systems-for-personalized-style-recommendations?ref=https://www.linkedin.com/in/ecolson/detail/treasury/position:283490153/?entityUrn=urn%3Ali%3Afs_treasuryMedia%3A(ACoAAAAgRpcBysMEEbZcn2KCJyUlezpKXYs2nYs%2C50371553)&section=position%3A283490153&treasuryCount=3\">common</a>.</p><h4>Your First Iteration of the Model Is Often Not Your Last</h4><p>As our human evaluators assess homes, training labels are generated as a by-product. Given that we already have a lot of features about a listing (price, bookings, reviews … etc), it was rather convenient to combine the two data sources (labels + features) to train our first home targeting model. At first, this approach worked well, and it brought enormous gains to our efficiency.</p><p>However, as the product continued to evolve, we started to experience the limitation of this simple approach. Specifically, as we evolved what <a href=\"https://www.airbnb.com/plus/host/requirements\">qualifies</a> a home to be “Plus” at the program level, the semantic meanings of our outcome labels had also changed. This business evolution posed non-trivial challenges to our learning task because our labels can become outdated rather quickly. We were essentially learning to predict a moving target!</p><h4>Decomposing the Learning Task Requires Thinking</h4><p>To de-risk our modeling effort, we had to re-think the problem formulation. Eventually, we decided to decompose our single, monolithic learning task into several independent modular tasks. This means that instead of directly classifying whether a listing is high potential or not, we focused on predicting more stable attributes that are indicative of high-quality. For example, instead of classifying the label is_home_high_potential directly, we framed the problem as is_home_high_potential = <strong>f</strong>(style, design, ...) , where <strong>f</strong> is our rule-based approach to codify how humans might use these modular predictions to make a final assessment.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Oe5ojwhM6-YH4BXpCqFXzA.png\" /><figcaption><a href=\"https://pixabay.com/en/hand-rubik-cube-puzzle-game-2208491/\">Image credit</a>: It’s useful to decompose a learning task into smaller tasks when the label is not straightforward</figcaption></figure><p>More often than not, problem formulation requires deep domain knowledge, the ability to decompose problems, and a lot of patience. The most convenient training dataset should not drive how we formulate the problem, rather it should be the other way around. This is an important first skill to becoming an effective problem solver in machine learning.</p><p><strong>Takeaway:</strong> <em>Like software engineering, the principle of decomposition can be very important in machine learning as well. It allows us to break a complex problem or system into parts that are easier to conceive, understand, and learn.</em></p><h3>2. Data Collection Is Often Non-trivial</h3><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*1BuvNymrXVgV6GC6MN6mTg.png\" /><figcaption><a href=\"https://pixabay.com/en/assortment-box-collection-container-1868297/\">Image source</a>: Data collection for machine learning is analogous to picking ingredients before cooking a great dish</figcaption></figure><p>At work, our data scientists and ML engineers often get together to talk about machine learning ideas passionately. While these discussions are always inspirational, they generally do not translate to project roadmaps immediately due to a common blocker — <em>lack of training labels and feature pipelines.</em></p><h4>Acquiring Quality Labels Is Challenging</h4><p>On Airbnb Plus, we are lucky to have training labels generated as a by-product from our home assessments, but dedicated labelings are often rare because collecting them comes with a hefty time and monetary cost. In the absence of actual training labels, we could use other data as proxies for training labels, but they are not always high fidelity.</p><p>For example, when Airbnb developed its <a href=\"https://medium.com/airbnb-engineering/categorizing-listing-photos-at-airbnb-f9483f3ab7e3\">room classification</a> model, we used image captions as our proxy label for the ground truth. While this approach gave us convenient labels as a head start, the label quality tends to be low for certain room types, especially for smaller spaces. For instance, scenes in a studio tend to be crammed together: a kitchen could be right next to a living room that is adjacent to a bedroom. This makes evaluation of ground truth hard to interpret, sometimes even in the eyes of human labelers.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*98FN1KxORE2kehrC_FgZ2w.png\" /><figcaption><a href=\"http://www.home-designing.com/5-beautiful-studio-apartments\">Image source</a>: Should we label the room type of this image as a kitchen or a bedroom?</figcaption></figure><p>In general, labeling in real-life is far trickier than simple tasks like telling apart hotdogs v.s. non-hotdogs. This nuance often makes <a href=\"https://en.wikipedia.org/wiki/Inter-rater_reliability\">inter-rater agreement</a> hard to achieve, and is rather universal for serious modeling pursuits across different domains. Andrej Karpathy, in his talk <a href=\"https://www.figure-eight.com/building-the-software-2-0-stack-by-andrej-karpathy-from-tesla/\">building the software 2.0 stack</a>, highlights some of Tesla’s labeling challenges for building self-driving cars. For example, he explains that labeling traffic lights and traffic lanes can sound simple but in reality difficult because the diversity of how different cities design the roads. More generally, he argues that in the <a href=\"https://medium.com/@karpathy/software-2-0-a64152b37c35\">software 2.0</a> world, we have not yet figure out the right IDEs or labeling tools to build software. These are all real data challenges that are not taught in school.</p><h4>Building Feature Pipelines Is Time Consuming</h4><p>Even when we have high quality labels, building feature pipelines can be a tedious and time-consuming process. For the model described in the previous section, we were lucky to re-use some of the listing-level features from another <a href=\"https://medium.com/airbnb-engineering/using-machine-learning-to-predict-value-of-homes-on-airbnb-9272d3d4739d\">existing project</a>. For problems that involved images as input, the feature engineering work is a lot more complex.</p><p>For example, before our room classification model, there was no image pipeline in place on our team that could be reused. A lot of data engineering work, from data ingestion, resizing images to size 224 x 224, using base64 encoding to storing thumbnails were required before we could build image models. Had this image pipeline not been in place, it would have slowed down a lot of our modeling work significantly. This is precisely why larger companies are building frameworks to make feature engineering easier (see Uber’s <a href=\"https://eng.uber.com/michelangelo/\">Michelangelo</a>, Netflix’s <a href=\"https://medium.com/netflix-techblog/distributed-time-travel-for-feature-generation-389cccdd3907\">Delorean</a>, and Airbnb’s <a href=\"https://vimeo.com/274397629\">Zipline</a>). When planning ML projects, it is always wise to budget time for feature engineering, because training data will not be handed to you on a silver platter.</p><p><strong>Takeaway:</strong> <em>You need to work hard to get your training data, it is often earned rather than given. Acquiring high-quality labels can be non-trivial, and building feature pipelines can be time-consuming. To the extent you can, reuse common features or even labels to solve similar problems in the same domain space.</em></p><h3>3. Debugging and Improving ML Models is Hard</h3><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*PsfnGDdDLrAKjSbpAlcfPg.png\" /><figcaption><a href=\"https://pixabay.com/en/hacking-cyber-blackandwhite-crime-2903156/\">Image source</a>: Debugging machine learning models can be a lonely pursuit</figcaption></figure><p>Suppose you have gone through the steps of defining a problem, acquiring labels and building a feature pipeline, you then moved on to build your first iteration of the model only to learn that the result is not so stellar. What would you do in this case to debug and improve your model?</p><h4>Debugging Machine Learning Is Hard</h4><p>The scenario described above is very common and is at the heart of any machine learning project. In his post “<a href=\"http://ai.stanford.edu/~zayd/why-is-machine-learning-hard.html\">Why is Machine Learning Hard?</a>”, Zayd Enam pointed out that machine learning is fundamentally a hard debugging problem because there are many possible paths of exploration and unfortunately the feedback loop is generally very slow.</p><blockquote>Debugging for machine learning happens in two cases: 1) <strong>your algorithm doesn’t work</strong>, or 2) <strong>your algorithm doesn’t work <em>well enough</em>.</strong></blockquote><blockquote>What is unique about machine learning is that it is ‘exponentially’ harder to figure out what is wrong […]. There is often a delay in debugging cycles between implementing a fix or upgrade and seeing the result. Very rarely does an algorithm work the first time and so this ends up being where the time is spent.</blockquote><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*2pP9xcrdl1iKXHvL2n7iqw.png\" /><figcaption><a href=\"http://ai.stanford.edu/~zayd/why-is-machine-learning-hard.html\">Image source</a>: Debugging ML models are often slow and convoluted</figcaption></figure><p>Debugging machine learning is a skill, and far too often we just try the most immediate, convenient, or “obvious” thing even though it might not be the right first thing to try. Of all the resources out there, I particularly appreciate Andrew Ng’s book <a href=\"http://www.mlyearning.org/\">Machine Learning Yearning</a>. This approachable reference is very practical and he talks about things that I wish I had known way earlier!</p><h4>Some Basic Debugging Skills</h4><p>While I highly recommend everyone to read Andrew’s book, for the impatient, I will highlight a few tricks that I personally found to be useful in practice:</p><ul><li><strong>Error Analysis: </strong>Learn from your model’s mistake. Specifically, hand picks 100 examples that your model got wrong from the development set and tally up the reasons why it got wrong. This can help you inspire new directions and prioritize improvement plans.</li></ul><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*H0YnmAehpVPMZZ8-IJepoA.png\" /><figcaption><a href=\"http://www.mlyearning.org/\">Image Source</a>: For a dog v.s. cat classifier, look at 100 misclassified examples and tally up the reasons</figcaption></figure><p>Error analysis is important because it gives you a very data-informed view of why your model is not performing well. This is something that I used to avoid doing because of its tedious nature, but over time have really come to embrace it as it gives me a lot of insight about the data and my models’ behavior.</p><ul><li><a href=\"http://scott.fortmann-roe.com/docs/BiasVariance.html\"><strong>Understand Bias-Variance</strong></a><strong>: </strong>There are two major sources of error in machine learning: bias and variance. High bias often means that your model is too simple to capture the complexity of the data, and high variance indicates that you have only learned the pattern at hand. To understand bias and variance in your models, the most effective debugging tool here is to plot the <a href=\"http://scikit-learn.org/stable/auto_examples/model_selection/plot_learning_curve.html\">learning curve</a>.</li></ul><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*E3fkaAqcZLuuxkwM7JQAmQ.png\" /><figcaption><a href=\"http://www.mlyearning.org/\">Image Source</a>: Use the learning curve to understand if you are overfitting or underfitting</figcaption></figure><p>When both your training error and development set error are way higher than the desired performance, you are suffering from a <strong>high bias</strong> problem (under-fitting). In such a case, increasing your model capacity or switching to a more complex algorithm is likely to help you to learn the patterns better.</p><p>On the other hand, when your development set error is way higher than the training error, while the training error is relatively close to the desired performance, you are suffering the <strong>high variance</strong> problem (over-fitting). In such a case, you might want to try a simpler model, or use <a href=\"https://en.wikipedia.org/wiki/Regularization_(mathematics)\">regularization</a>. Alternatively, if the gap between training and development error is closing with more training examples, you might consider adding more training data to your learning task.</p><p><strong>Takeaway: </strong><em>debugging machine learning is hard and the feedback loop is generally slow. Instead of tackling what you think is the next obvious thing, it’s important to be more principled about debugging. Error analysis, learning curve are all good starts, and I strongly encourage you to read Andrew’s </em><a href=\"http://www.mlyearning.org/\"><em>Machine Learning Yearnin</em></a><em>g to improve your debugging skill.</em></p><h3>4. Your Paths to Model Productionization Might Vary</h3><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*f0nBNfi-c86Rz9pTYT66nQ.png\" /><figcaption><a href=\"https://pixabay.com/en/industry-lost-places-factory-1801661/\">Image source</a>: Model productionization has been talked about a lot, but what exactly does it mean?</figcaption></figure><p>Assuming that you now have a satisfactory model to deploy, it is time to integrate your model into a decision process or product. This is what we refer to as model productionization. But what exactly does it mean? The answer depends on your use cases. Sometimes, the predictions will live outside of products completely and will be used only for strategic or business decisions. Other times, they will be an integrated part of a product experience.</p><h4>Not Everything is Low Latency & Context Sensitive</h4><p>The most useful framework I learned about this topic came from <a href=\"https://twitter.com/sharathrao?lang=en\">Sharath Rao</a>, who currently leads machine learning efforts for consumer products at Instacart. In his <a href=\"https://www.youtube.com/watch?v=wG5EyHYrJGE&t=854s\">DataEngConf</a> talk, Sharath explains that implementation of machine learning models can usually be considered from two<strong> </strong>dimensions:</p><ul><li><strong>Latency: </strong><em>How fast do the predictions need to be served to the end users?</em></li><li><strong>Context Sensitivity: </strong><em>Will we know the features ahead of inference time?</em></li></ul><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Kukn5JLFNZztpAjJOy2obg.png\" /><figcaption><a href=\"https://www.slideshare.net/SharathRao6/lessons-from-integrating-machine-learning-models-into-data-products/22\">Image source</a>: Sharath Rao’s talk, “lessons from integrating ML models into data products”</figcaption></figure><p>In the simplest case (bottom-left), for applications where predictions are mostly used for offline decisions, the model can be productionized simply as a batch scoring job. On the other hand, for models that are an integrated part of a product experience, e.g. search ranking, input features are generally not available until a user interacts with the product, and results often need to be returned really fast. In this case (top-right), online inference or real-time scoring is needed and <a href=\"https://en.wikipedia.org/wiki/Service-level_agreement\">SLA</a> requirements are generally higher. Knowing the profile of your ML model can directly inform your implementation strategy.</p><h4>Revenue Prediction Model, Illustrated in Multiple Use Cases</h4><p>Let’s use the listing LTV model that I introduced earlier as an illustrative example. Suppose we are interested in using this model to prioritize markets to go after next year. Such an application is not consumer-facing, and we are only using the predictions for offline decision making, not in an online product. For this use case, we only need to productionize the model as an offline training, offline scoring, batch job so other data scientists can easily query the predictions from a table.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Uwwzj9Xct-3T1y-iU9oCcA.png\" /><figcaption><a href=\"https://www.airbnb.com/host/homes\">Image source</a>: How should we productionize the ML model for such a product use case?</figcaption></figure><p>However, suppose we are now interested in showcasing the predicted host payouts in a consumer-facing product in order to inform users their financial potentials. One challenge we need to consider is how to surface the predictions within a product.</p><p>In the case where contextual data is not needed, one common strategy is to store the model results as key-value pairs in a key-value store, e.g. in the form of {key: dim_market, value: revenue prediction}. For this use case, the revenue prediction can be easily looked up based on the market in which the listing is located. A more involved product might allow users to specify their location, room size, and capacity so earning potentials can be personalized. In such a use case, we will not know the features until a user enters the information, so predictions need to be computed in real-time. Depending on the use cases, your path to productionization might vary.</p><p><strong>Takeaway: </strong><em>Taking models to production can mean different things depending on the context, use cases, and infrastructure at the company. Having basic familiarity with concepts such as latency and context sensitivity will greatly inform your implementation strategy.</em></p><h3>5. Feedback Loop Can Help You or Hurt You</h3><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*pGbHGnBVtzhWH_wqXgDJig.png\" /><figcaption><a href=\"https://pixabay.com/en/rollercoaster-looping-amusement-801833/\">Image source</a>: Creating and dealing with feedback loops is yet another important topic</figcaption></figure><p>Models that are an integrated part of a product experience, or what we referred to as data products, often involve feedback loops. When done right, feedback loops can help us to create better experiences. However, feedback loops can also create unintended negative consequences, such as bias or inaccurate model performance measurements.</p><h4>User Feedback Can Make Your Model Better</h4><p>One of the most unexpected skills that I learned about real-life machine learning is the ability to spot opportunities for users to provide model feedback via product interactions. These decisions might seem only relevant to UI/UX at first, but they can actually have a profound impact on the quality of the features that the data product offers.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*r0FP1iOEHherdYdbWFkicg.png\" /><figcaption><a href=\"https://chatbotnewsdaily.com/10-more-lessons-learned-from-building-real-life-ml-systems-part-i-b309cafc7b5e\">Image source</a>: From <a href=\"https://chatbotnewsdaily.com/@xamat?source=post_header_lockup\">Xavier Amatriain</a>’s post “10 more lessons learned from building real-life ML system”</figcaption></figure><p>For example, Netflix <a href=\"https://www.theatlantic.com/entertainment/archive/2017/03/netflix-believes-in-the-power-of-thumbs/520242/\">decided</a> last year to move away from the star-rating system to a thumbs up/down system, reportedly because its simplicity prompts more users to provide feedback, which in terms help Netflix to make their recommendations better. Similarly, Facebook, Twitter, Quora, and other social networks have long designed features such as likes, retweets, and comments which not only make the product more interactive, but also allow these companies to monetize better via personalization.</p><p>Creating feedback opportunities in product, instrumenting and capturing these feedback, and integrating it back into model development is important for both improving user experience as well as optimizing the companies’ business objectives and bottom lines.</p><h4>Feedback Loops Can Also Bias Model Performance</h4><p>While feedback loops can be powerful, they can also have unintended, negative consequences. One important topic is that models that are biased will amplify the bias the feedback loop introduces (see <a href=\"https://developers.google.com/machine-learning/fairness-overview/\">here</a>). Other times, feedback loop can affect our ability to measure model performance accurately.</p><p>This latter phenomenon is best illustrated by Michael Manapat, who explains this bias based on his experience building fraud models at Stripe. In his example, he pointed out that when a live fraud model enforces certain policy (e.g. block a transaction if its fraud score is above certain threshold), the system never gets to observe the ground truth for those blocked transactions, regardless of whether they are fraudulent or not. This blind spot can affect our ability to measure the effectiveness of a model running live in production.</p><iframe src=\"https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FQWCSxAKR-h0%3Ffeature%3Doembed&display_name=YouTube&url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DQWCSxAKR-h0&image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FQWCSxAKR-h0%2Fhqdefault.jpg&key=a19fcc184b9711e1b4764040d3dc5c07&type=text%2Fhtml&schema=youtube\" width=\"854\" height=\"480\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/f5fe8b056ddd1cb790ad18921d00ab33/href\">https://medium.com/media/f5fe8b056ddd1cb790ad18921d00ab33/href</a></iframe><p>Why? When obvious fraudulent transactions are blocked, the ones that remained with ground truth that we can observe are typically false negative transactions that are harder to get right. When we re-train our models on these “harder” examples, our model performance will necessarily be worse than what it really is performing in production.</p><p>Michael’s solution to this bias is to inject randomness in production traffic to understand the counterfactuals. Specifically, for transactions that are deemed fraudulent, we will let a small percentage of transactions pass, regardless of their scores, so we can observe the ground truth. Using these additional labels, we can then re-adjust the calculation for model performance. This approach is simple but not entirely obvious. In fact, it took me a long while before spotting the same feedback loop in my model, and it is not until I encountered Michael’s talk that I found a solution.</p><p><strong>Takeaway: </strong><em>Feedback loops in machine learning models are subtle. Knowing how to leverage feedback loops can help you to build a better user experience, and being aware of feedback loops can inform you to calculate the performance of your live system more accurately.</em></p><h3>Conclusion</h3><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*XsxocBbIzoQaqwdehmG3XQ.png\" /><figcaption><a href=\"https://papers.nips.cc/paper/5656-hidden-technical-debt-in-machine-learning-systems.pdf\">Source</a>: From the paper “Hidden Technical Debt in Machine Learning System” by D. Sculley et al</figcaption></figure><p>Throughout this post, I gave concrete examples around topics such as problem definition, feature engineering, model debugging, productionization, and dealing with feedback loops. The main underlying theme here is that building a machine learning system involves a lot more nuances than just fitting a model on a laptop. While the materials that I have covered here are only a <a href=\"https://github.com/robert8138/deep-learning-deliberate-practice#machine-learning-in-general\">subset</a> of the topics that one would encounter in practice, I hope that they have been informative in helping you to move beyond “<strong>Laptop Data Science</strong>”.</p><p>Happy Machine Learning!</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=16b4dd913a1f\" width=\"1\" height=\"1\" alt=\"\">"
}