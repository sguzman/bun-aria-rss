{
  "id": "tag:blogger.com,1999:blog-1176949257541686127.post-2456668474452167313",
  "published": "2022-04-14T13:28:00.008-04:00",
  "updated": "2022-04-14T13:34:54.614-04:00",
  "title": "How to SLSA Part 3 - Putting it all together",
  "content": "<span class=\"byline-author\">Posted by Tom Hennen, software engineer, BCID &amp; GOSST&nbsp;</span><div><span class=\"byline-author\"><br /></span></div><br />In our last two posts (<a href=\"https://security.googleblog.com/2022/04/how-to-slsa-part-1-basics.html\">1</a>,<a href=\"https://security.googleblog.com/2022/04/how-to-slsa-part-2-details.html\">2</a>) we introduced a fictional example of Squirrel, Oppy, and Acme learning to SLSA and covered the basics and details of how they’d use SLSA for their organizations. Today we’ll close out the series by exploring how each organization pulls together the various solutions into a heterogeneous supply chain. <br /><br />As a reminder, Acme is trying to produce a container image that contains three artifacts:<br /><ol style=\"text-align: left;\"><li>The Squirrel package ‘foo’</li><li>The Oppy package ‘baz’</li><li>A custom executable, ‘bar’, written by Acme employees.</li></ol>The process starts with ‘foo’ package authors triggering a build using GitHub Actions. This results in a new version of ‘foo’ (an artifact with hash ‘abc’) being pushed to the Squirrel repo along with its SLSA provenance (signed by Fulcio) and <a href=\"https://github.com/in-toto/attestation/issues/47\">source attestation</a>. When Squirrel gets this push request it verifies the artifact against the specific policy for ‘foo’ which checks that it was built by GitHub Actions from the expected source repository. After the artifact passes the policy check a VSA is created and the new package, its original SLSA provenance, and the VSA are made public in the Squirrel repo, available to all users of package ‘foo’.<br /><br />Next the maintainers of the Oppy ‘baz’ package trigger a new build using the Oppy Autobuilder. This results in a new version of ‘baz’ (an artifact with hash ‘def’) being pushed to a public Oppy repo with the SLSA provenance (signed by their org-specific keys) published to Rekor. When the repo gets the push request it makes the artifact available to the public. The repo does not perform any verification at this time.<br /><br />An Acme employee then makes a change to their Dockerfile, sending it for review by their co-worker, who approves the change and merges the PR. This then causes the Acme builder to trigger a build. During this build:<br /><ul style=\"text-align: left;\"><li>bar is compiled from source code stored in the same source repo as the Dockerfile.</li><li>acorn install downloads ‘foo’ from the Squirrel repo, verifying the VSA, and recording the use of acorn://foo@abc and its VSA in the build.</li><li>acme_oppy_get install (a custom script made by Acme) downloads the latest version of the Oppy ‘baz’ package and queries its SLSA provenance and other attestations from Rekor. It then performs a full verification checking that it was built by ‘https://oppy.example/slsa/builder/v1’ and the publicized key. Once verification is complete it records the use of oppy://baz@def and the associated attestations in the build.</li><li>The build process assembles the SLSA provenance for the container by:</li><ul><li>Recording the Acme git repo the bar source and Dockerfile came from, into <a href=\"https://slsa.dev/provenance/v0.2#materials\">materials</a>.</li><li>Copying the reported dependencies of acorn://foo@abc and oppy://baz@def into <a href=\"https://slsa.dev/provenance/v0.2#materials\">materials</a> and adding their attestations to the output <a href=\"https://github.com/in-toto/attestation/blob/main/spec/bundle.md\">in-toto bundle</a>.</li><li>Recording the CI/CD entrypoint as the <a href=\"https://slsa.dev/provenance/v0.2#invocation\">invocation</a>.</li><li>Creating a signed <a href=\"https://github.com/secure-systems-lab/dsse\">DSSE</a> with the SLSA provenance and adding it to the output <a href=\"https://github.com/in-toto/attestation/blob/main/spec/bundle.md\">in-toto bundle</a>.</li></ul></ul><br />Once the container is ready for release the Acme verifier checks the SLSA provenance (and other data in the in-toto bundle) using the policy from their own policy repo and issues a VSA. The VSA and all associated attestations are then published to an internal Rekor instance. Acme can then create an <a href=\"https://en.wikipedia.org/wiki/Software_bill_of_materials\">SBOM</a> for the container leveraging data about the build as stored in Rekor. Acme then publishes the container image, the VSA, and the SBOM on Dockerhub.<br /><br />Downstream users of this Acme container can then check the Acme issued VSA, and if there are any problems Acme can consult their internal Rekor instance to get more details on the build allowing Acme to trace all of their dependencies back to source code and the systems used to create them.<br />Conclusion<br /><br />With SLSA implemented in the ways described in this series, downstream users are protected from many of <a href=\"https://slsa.dev/spec/v0.1/threats\">the threats affecting the software supply chain today</a>. While users still need to trust certain parties, the number of systems requiring trust is much lower and users are in a much better position to investigate any issues that arise. <br /><br />We’d love to see the ideas in this series implemented, refuted, or used as a foundation to build even stronger solutions. We’d also love to hear some other methods on how to solve these issues. <a href=\"https://github.com/slsa-framework/slsa#get-involved\">Show us</a> how you like to SLSA.&nbsp;",
  "link": [
    "",
    "",
    "",
    "",
    ""
  ],
  "author": {
    "name": "Unknown",
    "email": "noreply@blogger.com",
    "gd:image": ""
  },
  "thr:total": 0
}