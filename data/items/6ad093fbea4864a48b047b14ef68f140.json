{
  "title": "Feather and Apache Arrow: Grokking file formats vs. in-memory representations",
  "link": "",
  "published": "2016-04-21T06:00:00-07:00",
  "updated": "2016-04-21T06:00:00-07:00",
  "author": {
    "name": "Wes McKinney"
  },
  "id": "tag:wesmckinney.com,2016-04-21:/blog/feather-and-apache-arrow/",
  "summary": "<p><strong>Summary</strong>: I explain the relationship between Feather and Apache Arrow in\nmore technical detail.</p>",
  "content": "<p><strong>Summary</strong>: I explain the relationship between Feather and Apache Arrow in\nmore technical detail.</p>\n\n\n<h2>Memory representation and file formats</h2>\n<p>I was <a href=\"https://github.com/wesm/feather/issues/127\">recently asked</a> to explain the difference between <a href=\"https://arrow.apache.org\">Apache Arrow</a>\n(providing a standard in-memory columnar memory representation) and\n<a href=\"https://github.com/wesm/feather\">Feather</a> (a file format using Apache Arrow).</p>\n<p>Before going deeper into Feather and Arrow, let's look at how memory\nrepresentations (these are also probably more commonly called <strong>data\nstructures</strong>) can lead to file formats.</p>\n<p>Let's take a simplified array data structure in C:</p>\n<div class=\"github\"><pre><span></span><code><span class=\"k\">typedef</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"cm\">/* the number of values in the array */</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kt\">int64_t</span><span class=\"w\"> </span><span class=\"n\">length</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">  </span><span class=\"cm\">/* the enum number indicating the data type of the array */</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">type_t</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">  </span><span class=\"cm\">/* a contiguous block of allocated memory with size at least equal to length</span>\n<span class=\"cm\">   * sizeof(type)</span>\n<span class=\"cm\">  */</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kt\">void</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">data</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"> </span><span class=\"n\">array_t</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n\n<p>This <code>array_t</code> is an <em>in-memory data structure</em>. I haven't told you how to put\nit in a file yet.</p>\n<p>Now suppose we have multiple arrays:</p>\n<div class=\"github\"><pre><span></span><code><span class=\"n\">array_t</span><span class=\"w\"> </span><span class=\"n\">my_data</span><span class=\"p\">[</span><span class=\"mi\">20</span><span class=\"p\">];</span><span class=\"w\"></span>\n\n<span class=\"cm\">/* populate my_data */</span><span class=\"w\"></span>\n</code></pre></div>\n\n<p>Now you want to write the data to a file. You have a memory representation for\nthis data, but no file format. So now you have a bunch of decisions to make:</p>\n<ul>\n<li>How do you lay out the bytes contained in the <code>array_t</code> structs in the file?</li>\n<li>How to you encode the <strong>metadata</strong> (a description that allows code to reconstruct <code>my_data</code>)?</li>\n<li>Where do you put the metadata in the file?</li>\n<li>How do you verify that you have a valid file?</li>\n<li>What happens when the metadata needs to evolve (file versioning)?</li>\n</ul>\n<p>So you have a bunch of work to do if you want to go from data structures to a\nfull blown file format.</p>\n<h2>Feather: the devil is in the metadata</h2>\n<p>From Feather's <a href=\"https://github.com/wesm/feather/blob/master/doc/FORMAT.md\">specification document</a>, the structure of a file currently\nlooks like this:</p>\n<div class=\"github\"><pre><span></span><code>&lt;4-byte magic number &quot;FEA1&quot;&gt;\n&lt;ARRAY 0&gt;\n&lt;ARRAY 1&gt;\n...\n&lt;ARRAY n - 1&gt;\n&lt;METADATA&gt;\n&lt;uint32: metadata size&gt;\n&lt;4-byte magic number &quot;FEA1&quot;&gt;\n</code></pre></div>\n\n<p>The <code>ARRAY</code> blobs are data that originated from in-memory Arrow data\nstructures. Here is what the data structure representing a single primitive\narray looks like. There's some C++ memory ownership stuff you can ignore for\nthis blog post.</p>\n<div class=\"github\"><pre><span></span><code><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">PrimitiveArray</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">PrimitiveType</span><span class=\"o\">::</span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kt\">int64_t</span><span class=\"w\"> </span><span class=\"n\">length</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kt\">int64_t</span><span class=\"w\"> </span><span class=\"n\">null_count</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">  </span><span class=\"c1\">// For ownership of any memory attached to this array</span>\n<span class=\"w\">  </span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">shared_ptr</span><span class=\"o\">&lt;</span><span class=\"n\">Buffer</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">buffers</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">  </span><span class=\"c1\">// If null_count == 0, treated as nullptr</span>\n<span class=\"w\">  </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">uint8_t</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">nulls</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">uint8_t</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">values</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">  </span><span class=\"c1\">// For UTF8 and BINARY, not used otherwise</span>\n<span class=\"w\">  </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">int32_t</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">offsets</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n\n<p>We made an arbitrary decision of how to arrange the raw data (the null and\nvalues buffers), but the bigger project was coming up with the metadata. We\nused an open source project from Google called <a href=\"https://github.com/google/flatbuffers\">Flatbuffers</a> to do this. In\nFlatbuffers, the information about <code>PrimitiveArray</code> looks like this:</p>\n<div class=\"github\"><pre><span></span><code><span class=\"n\">table</span><span class=\"w\"> </span><span class=\"n\">PrimitiveArray</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"nl\">type</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"n\">Type</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">  </span><span class=\"nl\">encoding</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"n\">Encoding</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">PLAIN</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">  </span><span class=\"c1\">/// Relative memory offset of the start of the array data excluding the size</span>\n<span class=\"w\">  </span><span class=\"c1\">/// of the metadata</span>\n<span class=\"w\">  </span><span class=\"nl\">offset</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kt\">long</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">  </span><span class=\"c1\">/// The number of logical values in the array</span>\n<span class=\"w\">  </span><span class=\"nl\">length</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kt\">long</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">  </span><span class=\"c1\">/// The number of observed nulls</span>\n<span class=\"w\">  </span><span class=\"nl\">null_count</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kt\">long</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">  </span><span class=\"c1\">/// The total size of the actual data in the file</span>\n<span class=\"w\">  </span><span class=\"nl\">total_bytes</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kt\">long</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n<p>When it comes down to it, most of the effort of creating Feather was in\ndefining a metadata specification that works for both Python and R, and\nimplementing code for reading and writing the metadata from in-memory data\nstructures. Copying bytes into R or Python in-memory arrays is one of the\nsimplest parts.</p>"
}