{
  "title": "Strategies",
  "link": "",
  "updated": "2012-11-07T00:00:00+00:00",
  "id": "https://mrocklin.github.io/blog/work/2012/11/07/Strategies",
  "content": "<p>In <a href=\"http://matthewrocklin.com/blog/work/2012/11/01/Unification/\">my last post</a> I showed how unification and rewrite rules allow us to express <em>what</em> we want without specifying <em>how</em> to compute it.  As an example we were able to turn the mathematical identity <code class=\"language-plaintext highlighter-rouge\">sin(x)**2 + cos(x)**2 -&gt; 1</code> into a function with relatively simple code</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"c1\"># Transformation : sin(x)**2 + cos(x)**2 -&gt; 1\n</span><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">sincos_to_one</span> <span class=\"o\">=</span> <span class=\"n\">rewriterule</span><span class=\"p\">(</span><span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"n\">cos</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">wilds</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">])</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">sincos_to_one</span><span class=\"p\">(</span><span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">+</span><span class=\"n\">b</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"n\">cos</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">+</span><span class=\"n\">b</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">).</span><span class=\"nb\">next</span><span class=\"p\">()</span>\n<span class=\"mi\">1</span></code></pre>\n</figure>\n\n<p>However we found that this function did not work deep within an expression tree</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">sincos_to_one</span><span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"n\">c</span><span class=\"o\">**</span><span class=\"p\">(</span><span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">+</span><span class=\"n\">b</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"n\">cos</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">+</span><span class=\"n\">b</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">)))</span> <span class=\"c1\"># no matches\n</span><span class=\"p\">[]</span></code></pre>\n</figure>\n\n<p><code class=\"language-plaintext highlighter-rouge\">sincos_to_one</code> does not know <em>how</em> to traverse a tree.  It is pure logic and has no knowledge of control.  We define traverals separately using strategies.</p>\n\n<p><em>Short version</em>: we give you a higher order function, <code class=\"language-plaintext highlighter-rouge\">top_down</code> which turns a\nexpression-wise function into a tree-wise function.  We provide a set of similar functions which can be composed to various effects.</p>\n\n<hr />\n\n<h2 id=\"a-toy-example\">A Toy Example</h2>\n\n<p>How do we express control programmatically?</p>\n\n<p>Traditional control flow is represented with constructs like <code class=\"language-plaintext highlighter-rouge\">if</code>, <code class=\"language-plaintext highlighter-rouge\">for</code>, <code class=\"language-plaintext highlighter-rouge\">while</code>, <code class=\"language-plaintext highlighter-rouge\">def</code>, <code class=\"language-plaintext highlighter-rouge\">return</code>, <code class=\"language-plaintext highlighter-rouge\">try</code>, etc….  These terms direct the flow of what computation occurs when.  Traditionally we mix control and logic.  Consider the following toy problem that reduces a number until it reaches a multiple of ten</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"k\">def</span> <span class=\"nf\">reduce_to_ten</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span>\n    <span class=\"s\">\"\"\" Reduce a number to the next lowest multiple of ten\n\n    &gt;&gt;&gt; reduce_ten(26)\n    20\n    \"\"\"</span>\n    <span class=\"n\">old</span> <span class=\"o\">=</span> <span class=\"bp\">None</span>\n    <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"n\">old</span> <span class=\"o\">!=</span> <span class=\"n\">x</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">%</span> <span class=\"mi\">10</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span><span class=\"p\">):</span>\n            <span class=\"n\">x</span> <span class=\"o\">-=</span> <span class=\"mi\">1</span>\n    <span class=\"k\">return</span> <span class=\"n\">x</span></code></pre>\n</figure>\n\n<p>While the logic in this function is somewhat trivial</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">%</span> <span class=\"mi\">10</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span><span class=\"p\">):</span>\n    <span class=\"n\">x</span> <span class=\"o\">-=</span> <span class=\"mi\">1</span></code></pre>\n</figure>\n\n<p>the control pattern is quite common in serious code</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"k\">while</span><span class=\"p\">(</span><span class=\"n\">old</span> <span class=\"o\">!=</span> <span class=\"n\">expr</span><span class=\"p\">):</span>\n    <span class=\"n\">old</span> <span class=\"o\">=</span> <span class=\"n\">expr</span>\n    <span class=\"n\">expr</span> <span class=\"o\">=</span> <span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">expr</span><span class=\"p\">)</span>\n<span class=\"k\">return</span> <span class=\"n\">expr</span></code></pre>\n</figure>\n\n<p>It is the “Exhaustively apply this function until there is no effect” control pattern. It occurs often in general programming and very often in the SymPy sourcecode.  We separate this control pattern into a higher order function named <code class=\"language-plaintext highlighter-rouge\">exhaust</code></p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"k\">def</span> <span class=\"nf\">exhaust</span><span class=\"p\">(</span><span class=\"n\">rule</span><span class=\"p\">):</span>\n    <span class=\"s\">\"\"\" Apply a rule repeatedly until it has no effect \"\"\"</span>\n    <span class=\"k\">def</span> <span class=\"nf\">exhaustive_rl</span><span class=\"p\">(</span><span class=\"n\">expr</span><span class=\"p\">):</span>\n        <span class=\"n\">old</span> <span class=\"o\">=</span> <span class=\"bp\">None</span>\n        <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"n\">expr</span> <span class=\"o\">!=</span> <span class=\"n\">old</span><span class=\"p\">):</span>\n            <span class=\"n\">expr</span><span class=\"p\">,</span> <span class=\"n\">old</span> <span class=\"o\">=</span> <span class=\"n\">rule</span><span class=\"p\">(</span><span class=\"n\">expr</span><span class=\"p\">),</span> <span class=\"n\">expr</span>\n        <span class=\"k\">return</span> <span class=\"n\">expr</span>\n    <span class=\"k\">return</span> <span class=\"n\">exhaustive_rl</span></code></pre>\n</figure>\n\n<p>We show how to use this function to achieve the previous result.</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"k\">def</span> <span class=\"nf\">dec_10</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span>                          <span class=\"c1\"># Close to pure logic\n</span>    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">%</span> <span class=\"mi\">10</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span><span class=\"p\">):</span>   <span class=\"k\">return</span> <span class=\"n\">x</span> <span class=\"o\">-</span> <span class=\"mi\">1</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>               <span class=\"k\">return</span> <span class=\"n\">x</span>\n\n<span class=\"n\">reduce_to_ten</span> <span class=\"o\">=</span> <span class=\"n\">exhaust</span><span class=\"p\">(</span><span class=\"n\">dec_10</span><span class=\"p\">)</span></code></pre>\n</figure>\n\n<p>By factoring out the control strategy we achieve several benefits</p>\n\n<ol>\n  <li>Code reuse of the <code class=\"language-plaintext highlighter-rouge\">while(old != new)</code> control pattern</li>\n  <li>Exposure of logic - we can use the <code class=\"language-plaintext highlighter-rouge\">dec_10</code> function in other contexts more easily. This version is more extensible.</li>\n  <li>Programmability of control - the control pattern is now first class.  We can manipulate and compose it as we would manipulate or compose a variable or function.</li>\n</ol>\n\n<h2 id=\"example---debug\">Example - Debug</h2>\n\n<p>When debugging code we often want to see the before and after effects of running a function.  We often do something like the following</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"n\">new</span> <span class=\"o\">=</span> <span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">old</span><span class=\"p\">)</span>\n<span class=\"k\">if</span> <span class=\"n\">new</span> <span class=\"o\">!=</span> <span class=\"n\">old</span><span class=\"p\">:</span>\n    <span class=\"k\">print</span> <span class=\"s\">\"Before: \"</span><span class=\"p\">,</span> <span class=\"n\">old</span>\n    <span class=\"k\">print</span> <span class=\"s\">\"After:  \"</span><span class=\"p\">,</span> <span class=\"n\">new</span></code></pre>\n</figure>\n\n<p>This common structure is encapsulated in the debug strategy</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"k\">def</span> <span class=\"nf\">debug</span><span class=\"p\">(</span><span class=\"n\">rule</span><span class=\"p\">):</span>\n    <span class=\"s\">\"\"\" Print out before and after expressions each time rule is used \"\"\"</span>\n    <span class=\"k\">def</span> <span class=\"nf\">debug_rl</span><span class=\"p\">(</span><span class=\"n\">expr</span><span class=\"p\">):</span>\n        <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">rule</span><span class=\"p\">(</span><span class=\"n\">expr</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"n\">result</span> <span class=\"o\">!=</span> <span class=\"n\">expr</span><span class=\"p\">:</span>\n            <span class=\"k\">print</span> <span class=\"s\">\"Rule: \"</span><span class=\"p\">,</span> <span class=\"n\">rule</span><span class=\"p\">.</span><span class=\"n\">func_name</span>\n            <span class=\"k\">print</span> <span class=\"s\">\"In:   \"</span><span class=\"p\">,</span> <span class=\"n\">expr</span>\n            <span class=\"k\">print</span> <span class=\"s\">\"Out:  \"</span><span class=\"p\">,</span> <span class=\"n\">result</span>\n        <span class=\"k\">return</span> <span class=\"n\">result</span>\n    <span class=\"k\">return</span> <span class=\"n\">debug_rl</span></code></pre>\n</figure>\n\n<p>Because control is separated we can inject this easily into our function</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">reduce_to_ten</span> <span class=\"o\">=</span> <span class=\"n\">exhaust</span><span class=\"p\">(</span><span class=\"n\">debug</span><span class=\"p\">(</span><span class=\"n\">dec_10</span><span class=\"p\">))</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">reduce_to_ten</span><span class=\"p\">(</span><span class=\"mi\">23</span><span class=\"p\">)</span>\n<span class=\"n\">Rule</span><span class=\"p\">:</span>  <span class=\"n\">dec_10</span>\n<span class=\"n\">In</span><span class=\"p\">:</span>    <span class=\"mi\">23</span>\n<span class=\"n\">Out</span><span class=\"p\">:</span>   <span class=\"mi\">22</span>\n<span class=\"n\">Rule</span><span class=\"p\">:</span>  <span class=\"n\">dec_10</span>\n<span class=\"n\">In</span><span class=\"p\">:</span>    <span class=\"mi\">22</span>\n<span class=\"n\">Out</span><span class=\"p\">:</span>   <span class=\"mi\">21</span>\n<span class=\"n\">Rule</span><span class=\"p\">:</span>  <span class=\"n\">dec_10</span>\n<span class=\"n\">In</span><span class=\"p\">:</span>    <span class=\"mi\">21</span>\n<span class=\"n\">Out</span><span class=\"p\">:</span>   <span class=\"mi\">20</span>\n<span class=\"mi\">20</span></code></pre>\n</figure>\n\n<h2 id=\"traversals\">Traversals</h2>\n\n<p>Finally we show off the use of a tree traversal strategy which applies a function at each node in an expression tree.  Here we use the <code class=\"language-plaintext highlighter-rouge\">Basic</code> type to denote a tree of generic nodes.</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"k\">def</span> <span class=\"nf\">top_down</span><span class=\"p\">(</span><span class=\"n\">rule</span><span class=\"p\">):</span>\n    <span class=\"s\">\"\"\" Apply a rule down a tree running it on the top nodes first \"\"\"</span>\n    <span class=\"k\">def</span> <span class=\"nf\">top_down_rl</span><span class=\"p\">(</span><span class=\"n\">expr</span><span class=\"p\">):</span>\n        <span class=\"n\">newexpr</span> <span class=\"o\">=</span> <span class=\"n\">rule</span><span class=\"p\">(</span><span class=\"n\">expr</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"n\">is_leaf</span><span class=\"p\">(</span><span class=\"n\">newexpr</span><span class=\"p\">):</span>\n            <span class=\"k\">return</span> <span class=\"n\">newexpr</span>\n        <span class=\"k\">return</span> <span class=\"n\">new</span><span class=\"p\">(</span><span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"n\">newexpr</span><span class=\"p\">),</span> <span class=\"o\">*</span><span class=\"nb\">map</span><span class=\"p\">(</span><span class=\"n\">top_down_rl</span><span class=\"p\">,</span> <span class=\"n\">newexpr</span><span class=\"p\">.</span><span class=\"n\">args</span><span class=\"p\">))</span>\n    <span class=\"k\">return</span> <span class=\"n\">top_down_rl</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">reduce_to_ten_tree</span> <span class=\"o\">=</span> <span class=\"n\">top_down</span><span class=\"p\">(</span><span class=\"n\">exhaust</span><span class=\"p\">(</span><span class=\"n\">tryit</span><span class=\"p\">(</span><span class=\"n\">dec_10</span><span class=\"p\">)))</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">expr</span> <span class=\"o\">=</span> <span class=\"n\">Basic</span><span class=\"p\">(</span><span class=\"mi\">23</span><span class=\"p\">,</span> <span class=\"mi\">35</span><span class=\"p\">,</span> <span class=\"n\">Basic</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">13</span><span class=\"p\">),</span> <span class=\"n\">Basic</span><span class=\"p\">(</span><span class=\"n\">Basic</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">)))</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">reduce_to_ten_tree</span><span class=\"p\">(</span><span class=\"n\">expr</span><span class=\"p\">)</span>\n<span class=\"n\">Basic</span><span class=\"p\">(</span><span class=\"mi\">20</span><span class=\"p\">,</span> <span class=\"mi\">30</span><span class=\"p\">,</span> <span class=\"n\">Basic</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">),</span> <span class=\"n\">Basic</span><span class=\"p\">(</span><span class=\"n\">Basic</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)))</span></code></pre>\n</figure>\n\n<h2 id=\"use-in-practice\">Use in Practice</h2>\n\n<p>We have rewritten the canonicalization code in the Matrix Expression module to use these strategies.  There are a number of small functions to represent atomic logical transformations of expressions.  We call these rules.  Rules are functions from expressions to expressions</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>rule :: expr -&gt; expr\n</code></pre></div></div>\n\n<p>And there are a number of strategies like <code class=\"language-plaintext highlighter-rouge\">exhaust</code> and <code class=\"language-plaintext highlighter-rouge\">top_down</code> which transform rules and parameters into larger rules</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>strategy :: parameters, rule -&gt; rule\n</code></pre></div></div>\n\n<p>For example there are general rules like <code class=\"language-plaintext highlighter-rouge\">flatten</code> that simplify nested expressions like</p>\n\n<p><code class=\"language-plaintext highlighter-rouge\">Add(1, 2, Add(3, 4)) -&gt; Add(1, 2, 3, 4)</code></p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"k\">def</span> <span class=\"nf\">flatten</span><span class=\"p\">(</span><span class=\"n\">expr</span><span class=\"p\">):</span>\n    <span class=\"s\">\"\"\" Flatten T(a, b, T(c, d), T2(e)) to T(a, b, c, d, T2(e)) \"\"\"</span>\n    <span class=\"n\">cls</span> <span class=\"o\">=</span> <span class=\"n\">expr</span><span class=\"p\">.</span><span class=\"n\">__class__</span>\n    <span class=\"n\">args</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n    <span class=\"k\">for</span> <span class=\"n\">arg</span> <span class=\"ow\">in</span> <span class=\"n\">expr</span><span class=\"p\">.</span><span class=\"n\">args</span><span class=\"p\">:</span>\n        <span class=\"k\">if</span> <span class=\"n\">arg</span><span class=\"p\">.</span><span class=\"n\">__class__</span> <span class=\"o\">==</span> <span class=\"n\">cls</span><span class=\"p\">:</span>\n            <span class=\"n\">args</span><span class=\"p\">.</span><span class=\"n\">extend</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">.</span><span class=\"n\">args</span><span class=\"p\">)</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"n\">args</span><span class=\"p\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">expr</span><span class=\"p\">.</span><span class=\"n\">__class__</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">)</span></code></pre>\n</figure>\n\n<p>We compose these general rules (e.g. ‘flatten’, ‘unpack’, ‘sort’, ‘glom’) with strategies to create large canonicalization functions</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"n\">rules</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">rm_identity</span><span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">x</span> <span class=\"o\">==</span> <span class=\"mi\">0</span> <span class=\"ow\">or</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">ZeroMatrix</span><span class=\"p\">)),</span>\n         <span class=\"n\">unpack</span><span class=\"p\">,</span>\n         <span class=\"n\">flatten</span><span class=\"p\">,</span>\n         <span class=\"n\">glom</span><span class=\"p\">(</span><span class=\"n\">matrix_of</span><span class=\"p\">,</span> <span class=\"n\">factor_of</span><span class=\"p\">,</span> <span class=\"n\">combine</span><span class=\"p\">),</span>\n         <span class=\"n\">sort</span><span class=\"p\">(</span><span class=\"nb\">str</span><span class=\"p\">))</span>\n\n<span class=\"n\">canonicalize</span> <span class=\"o\">=</span> <span class=\"n\">exhaust</span><span class=\"p\">(</span><span class=\"n\">top_down</span><span class=\"p\">(</span><span class=\"n\">typed</span><span class=\"p\">({</span><span class=\"n\">MatAdd</span><span class=\"p\">:</span> <span class=\"n\">do_one</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">rules</span><span class=\"p\">)})))</span></code></pre>\n</figure>\n\n<h2 id=\"going-farther\">Going Farther</h2>\n\n<p>We use strategies to build large rules out of small rules.  Can we build large strategies out of small strategies? The <code class=\"language-plaintext highlighter-rouge\">canonicalize</code> function above follows a common pattern “Apply a set of rules down a tree, repeat until they have no effect.” This is built into the <code class=\"language-plaintext highlighter-rouge\">canon</code> strategy.</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"k\">def</span> <span class=\"nf\">canon</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">rules</span><span class=\"p\">):</span>\n    <span class=\"s\">\"\"\" Strategy for canonicalization \"\"\"</span>\n    <span class=\"k\">return</span> <span class=\"n\">exhaust</span><span class=\"p\">(</span><span class=\"n\">top_down</span><span class=\"p\">(</span><span class=\"n\">do_one</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">rules</span><span class=\"p\">)))</span></code></pre>\n</figure>\n\n<h2 id=\"previous-work\">Previous Work</h2>\n\n<p>This implementation of strategies was inspired by the work in the language StrategoXT. Stratego is a language for control that takes these ideas much farther and implements them more cleanly.  It is a language where control structure are the primitives that can be built up, composed, and compiled down.  It is a language in which ideas like “breadth first search” and “dynamic programming” are natural expressions.</p>\n\n<h2 id=\"references\">References</h2>\n\n<ol>\n  <li>Ralf Lämmel , Eelco Visser , Joost Visser, <a href=\"http://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;ved=0CDMQFjAA&amp;url=http%3A%2F%2Fhomepages.cwi.nl%2F~ralf%2Feosp%2Fpaper.pdf&amp;ei=bJuaUNWwNuOc2AWQtICYCA&amp;usg=AFQjCNHG1lJTjP05tO1aElYQkXMYSmgNuw&amp;sig2=EwanltC52lXaC4gU4OtVvA\"><em>The Essence of Strategic Programming</em></a>, 2002</li>\n  <li>Eelco Visser, <a href=\"http://www.springerlink.com/content/my9we5tj86u2f59n/\"><em>Program Transformation with Stratego/XT</em></a></li>\n</ol>"
}