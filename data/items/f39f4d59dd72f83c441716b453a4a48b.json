{
  "title": "Reverse Search",
  "link": "",
  "published": "2015-08-07T21:30:00+01:00",
  "updated": "2015-08-07T21:30:00+01:00",
  "author": {
    "name": "Sebastian Nowozin"
  },
  "id": "tag:www.nowozin.net,2015-08-07:/sebastian/blog/reverse-search.html",
  "summary": "<p>One of my all-time favorite algorithms is <em>reverse search</em> proposed by\n<a href=\"http://cgm.cs.mcgill.ca/~avis/\">David Avis</a> and\n<a href=\"http://www.inf.ethz.ch/personal/fukudak/\">Komei Fukuda</a> in 1992,\n<a href=\"http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.26.4487&amp;rep=rep1&amp;type=pdf\">PDF</a>.</p>\n<p>Reverse search is an algorithm to solve enumeration problems, that is,\nproblems where you would like to list a finite set â€¦</p>",
  "content": "<p>One of my all-time favorite algorithms is <em>reverse search</em> proposed by\n<a href=\"http://cgm.cs.mcgill.ca/~avis/\">David Avis</a> and\n<a href=\"http://www.inf.ethz.ch/personal/fukudak/\">Komei Fukuda</a> in 1992,\n<a href=\"http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.26.4487&amp;rep=rep1&amp;type=pdf\">PDF</a>.</p>\n<p>Reverse search is an algorithm to solve enumeration problems, that is,\nproblems where you would like to list a finite set of typically\ncombinatorially related elements.\nReverse search is not quite an algorithm, rather it is a general construction\nprinciple that is applicable to a wide variety of problems and often leads to\noptimal algorithms for enumeration problems.</p>\n<p>Problems in which reverse search is applicable often have the flavour where\nthe elements have a <em>natural partial order</em> (such as sets, sequences, graphs\nwhere we can define subsets, subsequences, and subgraphs), or where there is a\nnatural neighborhood relation between elements which can be used to traverse\nfrom one element to the other (such as the linear programming bases considered\nin the Avis and Fukuda examples).</p>\n<p>The reverse search construction leads to a structured search space that is\nalso suitable for combinatorial search and optimization algorithms.  For\nexample, we can often readily use the resulting enumeration tree in\n<a href=\"http://en.wikipedia.org/wiki/Branch_and_bound\">branch-and-bound search</a>\nmethods.\nI made heavy use of this possibility during my PhD a few years ago during my\nwork with Koji Tsuda, and reverse search is the working horse in my CVPR 2007,\nICCV 2007, and ICDM 2008 papers.  (Needless to say, I have fond memories of\nit, but even now I regularly see applications of the reverse search idea.)\nIn the following, my presentation will differ quite a bit from the Avis and\nFukuda paper.</p>\n<h2>Basic Idea</h2>\n<p>At its core reverse search is a method to organize all elements to be\nenumerated into a tree where the nodes in the tree each represent a single\nelement.\nEach element appears exactly once in the tree and by traversing the tree from\nthe root we can enumerate all elements exactly once.</p>\n<p>Here is the <em>recipe</em>:</p>\n<ol>\n<li>Define a ``reduction'' operation which takes an enumeration element and\nreduces it to a simpler one.  This defines an enumeration tree.</li>\n<li>Invert the reduction operation.</li>\n<li>Enumerate all elements, starting from the root.</li>\n</ol>\n<p>Let us illustrate this recipe first on a simple example: enumerating subsets\nof a given set.  Say we are given the set <span class=\"math\">\\(\\{1,2,3\\}\\)</span> and would like to\nenumerate subsets.  To define the reduction operation we simply say ``remove\nthe largest integer from the set''.  Formally, this defines defines a function\n<span class=\"math\">\\(f\\)</span> from the set of sets to the set of sets.  Here is an illustration:</p>\n<p><img alt=\"Set of three integers and reduction operation\" src=\"http://www.nowozin.net/sebastian/blog/images/rsearch-123set-f.svg\"></p>\n<p>Now we consider the inverse map <span class=\"math\">\\(f^{-1}\\)</span>, from the set of sets to the set of\npowersets.  Here is an illustration:</p>\n<p><img alt=\"Inverse reduction operation\" src=\"http://www.nowozin.net/sebastian/blog/images/rsearch-123set-finv.svg\"></p>\n<p>The inverse defines an enumeration strategy: we start at <span class=\"math\">\\(\\emptyset\\)</span> and\nevaluate <span class=\"math\">\\(f^{-1}(\\emptyset) = \\{\\{1\\}, \\{2\\}, \\{3\\}\\}\\)</span>.  For each set element\nwe now recurse.  This enumerates all elements in the tree exactly once.</p>\n<p>The above recipe has the following practical advantages:</p>\n<ol>\n<li>Reverse search often yields a simple algorithm.</li>\n<li>Typically there is no additional memory or bookkeeping required beyond the\n   recursion call stack, so that the total memory required is <span class=\"math\">\\(O(r)\\)</span> where <span class=\"math\">\\(r\\)</span>\n   is the recursion depth.</li>\n<li>Yields a <em>output-linear</em> <em>polynomial-delay</em> enumeration algorithms, which\n   means that the total time complexity is linear in the number of items\n   enumerated and for each item only polynomial time is needed.  (This slightly\n   unconventional notion of complexity makes sense for enumeration problems\n   because the answer is often exponential in the size of the input.)</li>\n<li>Often yields optimal enumeration algorithms in terms of memory and runtime.</li>\n<li>The resulting algorithms are trivially parallelizable over the enumeration\n   tree.</li>\n</ol>\n<p>Ok, the above was a trivial example, let us look at a more complicated example.</p>\n<h2>Example: Enumerating all Connected Subgraphs</h2>\n<p>Let us consider a non-trivial application of the reverse search idea:\nenumerating all connected subgraphs of a given graph.</p>\n<p>To apply the recipe, how could the <em>reduction operation</em> look like?\nIntuitively, we are given a connected graph and we could remove a single\nvertex from the graph, thereby making it smaller.  By removing one vertex at a\ntime we would eventually arrive at the empty graph.</p>\n<p>But given a graph, how do we determine which vertex to remove?\nFor this, let us assume all vertices in the given graph have a unique integer\nindex.  Then, given such a graph we can then attempt to remove the highest\ninteger vertex, just as in the set example above.  Here we hit a complication:\nupon removal of the vertex the graph may become disconnected.\nFor example, consider the chain graph <span class=\"math\">\\(1-3-2\\)</span>.  Here the vertex labeled <span class=\"math\">\\(3\\)</span>\nwould be removed, yielding two disconnected components, which violates the\nrequirement of enumerating only connected subgraphs.  Therefore we simply say:\n``Remove the highest-index vertex such that the resulting graph remains\nconnected''.</p>\n<p>Here is an example of the reduction operation in action on the following\nsimple cycle graph:</p>\n<p><img alt=\"Cycle graph with four nodes\" src=\"http://www.nowozin.net/sebastian/blog/images/rsearch-1324.svg\"></p>\n<p>The enumeration tree of all fourteen connected subgraphs (counting the empty\ngraph as well) looks as follows.  Here each arrow is the application of one\nreduction operation.</p>\n<p><img alt=\"All connected subgraphs of the cycle graph with four nodes\" src=\"http://www.nowozin.net/sebastian/blog/images/rsearch-enumtree-1324.svg\"></p>\n<p>Looking at the above tree, you can note the following:</p>\n<ul>\n<li>The graph <span class=\"math\">\\(1-4-2\\)</span> has the highest vertex <span class=\"math\">\\(4\\)</span> but this cannot be removed\n  because it would yield a disconnected subgraph; therefore the reduction\n  operation removes <span class=\"math\">\\(2\\)</span> instead.</li>\n<li>By construction, there is a unique path from every graph to the root.</li>\n<li>By construction only connected subgraphs are present in the tree, and each\n  such graph is present exactly once.</li>\n</ul>\n<p>In order to enumerate all connected subgraphs, we have to <em>invert</em> the\narrows of this graph.  That is, we have to invert the reduction operation and\ngiven a graph we have to generate all child nodes in the reversed graph.\nThis reversion is what gives <em>reverse search</em> its name.</p>\n<p>The inverse operation is described as follows: ``given a connected subgraph,\nadd a vertex which will become the highest-index vertex and whose removal\nretains a connected graph.\"  This is quite a mouthful but luckily\nthe actual implementation is simple.</p>\n<p>Here is a <a href=\"http://julialang.org/\">Julia</a> implementation.</p>\n<div class=\"highlight\"><pre><span></span><code><span class=\"k\">using</span> <span class=\"n\">LightGraphs</span>\n\n<span class=\"n\">is_connected1</span><span class=\"p\">(</span><span class=\"n\">g</span><span class=\"o\">::</span><span class=\"n\">Graph</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"n\">nv</span><span class=\"p\">(</span><span class=\"n\">g</span><span class=\"p\">)</span> <span class=\"o\">&lt;=</span> <span class=\"mi\">1</span> <span class=\"o\">?</span> <span class=\"kc\">true</span> <span class=\"o\">:</span> <span class=\"n\">is_connected</span><span class=\"p\">(</span><span class=\"n\">g</span><span class=\"p\">)</span>\n<span class=\"n\">is_removable</span><span class=\"p\">(</span><span class=\"n\">g</span><span class=\"o\">::</span><span class=\"n\">Graph</span><span class=\"p\">,</span> <span class=\"n\">vset</span><span class=\"o\">::</span><span class=\"kt\">IntSet</span><span class=\"p\">,</span> <span class=\"n\">rmv</span><span class=\"p\">)</span> <span class=\"o\">=</span>\n    <span class=\"n\">is_connected1</span><span class=\"p\">(</span><span class=\"n\">induced_subgraph</span><span class=\"p\">(</span><span class=\"n\">g</span><span class=\"p\">,</span> <span class=\"n\">setdiff</span><span class=\"p\">(</span><span class=\"n\">vset</span><span class=\"p\">,</span> <span class=\"n\">rmv</span><span class=\"p\">)))</span>\n<span class=\"n\">rm_vertex</span><span class=\"p\">(</span><span class=\"n\">g</span><span class=\"o\">::</span><span class=\"n\">Graph</span><span class=\"p\">,</span> <span class=\"n\">vset</span><span class=\"o\">::</span><span class=\"kt\">IntSet</span><span class=\"p\">)</span> <span class=\"o\">=</span>\n    <span class=\"n\">maximum</span><span class=\"p\">(</span><span class=\"n\">filter</span><span class=\"p\">(</span><span class=\"n\">rmv</span> <span class=\"o\">-&gt;</span> <span class=\"n\">is_removable</span><span class=\"p\">(</span><span class=\"n\">g</span><span class=\"p\">,</span> <span class=\"n\">vset</span><span class=\"p\">,</span> <span class=\"n\">rmv</span><span class=\"p\">),</span> <span class=\"n\">vset</span><span class=\"p\">))</span>\n\n<span class=\"k\">function</span> <span class=\"n\">connsubgraphs</span><span class=\"p\">(</span><span class=\"n\">g</span><span class=\"o\">::</span><span class=\"n\">Graph</span><span class=\"p\">)</span>\n    <span class=\"k\">function</span> <span class=\"n\">_connsubgraphs</span><span class=\"p\">(</span><span class=\"n\">vset</span><span class=\"o\">::</span><span class=\"kt\">IntSet</span><span class=\"p\">)</span>\n        <span class=\"n\">produce</span><span class=\"p\">(</span><span class=\"n\">copy</span><span class=\"p\">(</span><span class=\"n\">vset</span><span class=\"p\">))</span>   <span class=\"c\"># output current subgraph vertex set</span>\n\n        <span class=\"c\"># Generate child nodes of the current subgraph.</span>\n        <span class=\"c\"># Consider all vertices not yet in graph</span>\n        <span class=\"k\">for</span> <span class=\"n\">add_vi</span> <span class=\"o\">=</span> <span class=\"n\">filter</span><span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">-&gt;</span> <span class=\"o\">!</span><span class=\"kp\">in</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">,</span> <span class=\"n\">vset</span><span class=\"p\">),</span> <span class=\"n\">vertices</span><span class=\"p\">(</span><span class=\"n\">g</span><span class=\"p\">))</span>\n            <span class=\"n\">push!</span><span class=\"p\">(</span><span class=\"n\">vset</span><span class=\"p\">,</span> <span class=\"n\">add_vi</span><span class=\"p\">)</span>     <span class=\"c\"># Add new vertex</span>\n            <span class=\"k\">if</span> <span class=\"n\">is_connected1</span><span class=\"p\">(</span><span class=\"n\">induced_subgraph</span><span class=\"p\">(</span><span class=\"n\">g</span><span class=\"p\">,</span> <span class=\"n\">vset</span><span class=\"p\">))</span> <span class=\"o\">&amp;&amp;</span>\n                <span class=\"n\">add_vi</span> <span class=\"o\">==</span> <span class=\"n\">rm_vertex</span><span class=\"p\">(</span><span class=\"n\">g</span><span class=\"p\">,</span> <span class=\"n\">vset</span><span class=\"p\">)</span>\n                <span class=\"c\"># Recurse</span>\n                <span class=\"n\">_connsubgraphs</span><span class=\"p\">(</span><span class=\"n\">vset</span><span class=\"p\">)</span>\n            <span class=\"k\">end</span>\n            <span class=\"n\">setdiff!</span><span class=\"p\">(</span><span class=\"n\">vset</span><span class=\"p\">,</span> <span class=\"n\">add_vi</span><span class=\"p\">)</span>  <span class=\"c\"># Remove new vertex</span>\n        <span class=\"k\">end</span>\n    <span class=\"k\">end</span>\n    <span class=\"k\">function</span> <span class=\"n\">_connsubgraphs</span><span class=\"p\">()</span>\n        <span class=\"n\">_connsubgraphs</span><span class=\"p\">(</span><span class=\"kt\">IntSet</span><span class=\"p\">())</span>\n    <span class=\"k\">end</span>\n    <span class=\"kt\">Task</span><span class=\"p\">(</span><span class=\"n\">_connsubgraphs</span><span class=\"p\">)</span>\n<span class=\"k\">end</span>\n\n<span class=\"n\">g</span> <span class=\"o\">=</span> <span class=\"n\">Graph</span><span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"p\">)</span>\n<span class=\"n\">add_edge!</span><span class=\"p\">(</span><span class=\"n\">g</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"n\">add_edge!</span><span class=\"p\">(</span><span class=\"n\">g</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"n\">add_edge!</span><span class=\"p\">(</span><span class=\"n\">g</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"n\">add_edge!</span><span class=\"p\">(</span><span class=\"n\">g</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">)</span>\n<span class=\"n\">S</span> <span class=\"o\">=</span> <span class=\"n\">collect</span><span class=\"p\">(</span><span class=\"n\">connsubgraphs</span><span class=\"p\">(</span><span class=\"n\">g</span><span class=\"p\">))</span>\n</code></pre></div>\n\n<p>Note the key statements between the <code>push!</code> and <code>setdiff!</code> lines that\ngovern the recursion.\nIn the if-condition we check that the new graph remains connected and the\nadded vertex would be the one that would be removed.</p>\n<p>The above code uses the Julia\n<a href=\"http://julia.readthedocs.org/en/latest/manual/control-flow/#tasks-aka-coroutines\">producer-consumer</a>\npattern.\nWhen run, it produces the following output, identical to the above diagram.</p>\n<div class=\"highlight\"><pre><span></span><code><span class=\"mi\">14</span><span class=\"o\">-</span><span class=\"n\">element</span> <span class=\"kt\">Array</span><span class=\"p\">{</span><span class=\"kt\">Any</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">}</span><span class=\"o\">:</span>\n <span class=\"kt\">IntSet</span><span class=\"p\">([])</span>          \n <span class=\"kt\">IntSet</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">])</span>         \n <span class=\"kt\">IntSet</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">])</span>      \n <span class=\"kt\">IntSet</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">])</span>   \n <span class=\"kt\">IntSet</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">])</span>\n <span class=\"kt\">IntSet</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">])</span>   \n <span class=\"kt\">IntSet</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">])</span>      \n <span class=\"kt\">IntSet</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">])</span>   \n <span class=\"kt\">IntSet</span><span class=\"p\">([</span><span class=\"mi\">2</span><span class=\"p\">])</span>         \n <span class=\"kt\">IntSet</span><span class=\"p\">([</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">])</span>      \n <span class=\"kt\">IntSet</span><span class=\"p\">([</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">])</span>   \n <span class=\"kt\">IntSet</span><span class=\"p\">([</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">])</span>      \n <span class=\"kt\">IntSet</span><span class=\"p\">([</span><span class=\"mi\">3</span><span class=\"p\">])</span>         \n <span class=\"kt\">IntSet</span><span class=\"p\">([</span><span class=\"mi\">4</span><span class=\"p\">])</span>         \n</code></pre></div>\n\n<h2>Conclusion</h2>\n<p>Reverse search is a general recipe to construct tree-structured enumeration\nmethods useful for enumerating combinatorial sets and optimization over them.</p>\n<p>In fact, it is so useful that some authors have reinvented reverse search\nwithout noticing.  For example, the popular <a href=\"http://cs.ucsb.edu/~xyan/papers/gSpan-short.pdf\">gSpan\nalgorithm</a> of Yan and Han\npublished in 2003 defines a clever total ordering on labeled graphs\nessentially in order to be able to define the reduction operation needed in\nreverse search.</p>\n<p>So, check it out, the <a href=\"http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.26.4487&amp;rep=rep1&amp;type=pdf\">Avis and Fukuda\npaper</a>\nis very rich and well worth a read!  (If you prefer a different presentation\nsimilar to the one above but more technical, have a look at my PhD thesis.)</p>\n<p><em>Acknowledgements</em>.  I thank <a href=\"http://tsudalab.org/en/member/koji_tsuda/\">Koji\nTsuda</a> for reading a draft version\nof the article and providing feedback.</p>\n<script type=\"text/javascript\">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {\n    var align = \"center\",\n        indent = \"0em\",\n        linebreak = \"false\";\n\n    if (false) {\n        align = (screen.width < 768) ? \"left\" : align;\n        indent = (screen.width < 768) ? \"0em\" : indent;\n        linebreak = (screen.width < 768) ? 'true' : linebreak;\n    }\n\n    var mathjaxscript = document.createElement('script');\n    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';\n    mathjaxscript.type = 'text/javascript';\n    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';\n\n    var configscript = document.createElement('script');\n    configscript.type = 'text/x-mathjax-config';\n    configscript[(window.opera ? \"innerHTML\" : \"text\")] =\n        \"MathJax.Hub.Config({\" +\n        \"    config: ['MMLorHTML.js'],\" +\n        \"    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } },\" +\n        \"    jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" +\n        \"    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" +\n        \"    displayAlign: '\"+ align +\"',\" +\n        \"    displayIndent: '\"+ indent +\"',\" +\n        \"    showMathMenu: true,\" +\n        \"    messageStyle: 'normal',\" +\n        \"    tex2jax: { \" +\n        \"        inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" +\n        \"        displayMath: [ ['$$','$$'] ],\" +\n        \"        processEscapes: true,\" +\n        \"        preview: 'TeX',\" +\n        \"    }, \" +\n        \"    'HTML-CSS': { \" +\n        \"        availableFonts: ['STIX', 'TeX'],\" +\n        \"        preferredFont: 'STIX',\" +\n        \"        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" +\n        \"        linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" +\n        \"    }, \" +\n        \"}); \" +\n        \"if ('default' !== 'default') {\" +\n            \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" +\n                \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" +\n                \"VARIANT['normal'].fonts.unshift('MathJax_default');\" +\n                \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" +\n                \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" +\n                \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" +\n            \"});\" +\n            \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" +\n                \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" +\n                \"VARIANT['normal'].fonts.unshift('MathJax_default');\" +\n                \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" +\n                \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" +\n                \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" +\n            \"});\" +\n        \"}\";\n\n    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);\n    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);\n}\n</script>",
  "category": ""
}