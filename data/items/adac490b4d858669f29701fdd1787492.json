{
  "title": "The Julia language for Scientific Computing",
  "link": "",
  "published": "2015-10-02T22:30:00+01:00",
  "updated": "2015-10-02T22:30:00+01:00",
  "author": {
    "name": "Sebastian Nowozin"
  },
  "id": "tag:www.nowozin.net,2015-10-02:/sebastian/blog/the-julia-language-for-scientific-computing.html",
  "summary": "<p><a href=\"http://julialang.org/\">Julia</a> is a relatively new programming language with\nthe <a href=\"http://julialang.org/blog/2012/02/why-we-created-julia/\">declared goal</a>\nto become the leading language for scientific computing.</p>\n<p>I have probably annoyed half of my colleagues by raving about how great the\nlanguage is and what it is good â€¦</p>",
  "content": "<p><a href=\"http://julialang.org/\">Julia</a> is a relatively new programming language with\nthe <a href=\"http://julialang.org/blog/2012/02/why-we-created-julia/\">declared goal</a>\nto become the leading language for scientific computing.</p>\n<p>I have probably annoyed half of my colleagues by raving about how great the\nlanguage is and what it is good at.\nBefore we get to this, and in my defense, let me provide some context.  I have\nbeen developing using C and C++ for 20 years now, and have been using Matlab\nand Python for over ten years now.  These are great languages and I can be\nproductive using each, infact I continue to use them regularly.</p>\n<p>Also, I tend to be quite conservative in terms of adopting new languages or\ndevelopment tools: while learning a new language and environment is fun\nit also takes a lot of effort and most languages/tools/libraries tend to come\nand go rather quickly and every developer carries with him a graveyard of\ntools and languages long gone.</p>\n<p>Because of this short-lived nature of software, when someone approaches me\nwith a new language or tool I am skeptical by default, and my litmus test\nquestion is usually how confident they are that this tool will still be around\nin five years time.  This is of course unfair, but I prefer to invest my time\nin learning things that have long term value.  Which brings me to the point\nthat I firmly believe Julia is here to stay and in fact may even become a\npopular language in scientific computing.</p>\n<p>Enough rambling, let's get to the good parts.</p>\n<p>I have been using Julia for the last 18 month now, both for work and pleasure.\nCounting all code I wrote at work (just counting .jl files, no notebooks) I\nsee that I wrote more than 15k lines of Julia code in that time, including\nseveral larger projects, ports of existing Matlab and C++ code, and interfaces\nto C libraries.\nGiven my experience Julia is ready for production in internal projects (as\nopposed to shipping executable code to a customer) and in particular is very\nwell suited to research-type projects.</p>\n<p><a href=\"http://julialang.org/\"><img src=\"images/julia.svg\" alt=\"Logo of the Julia language\" style=\"width: 240px; display: block; margin-left: auto; margin-right: auto;\"/></a></p>\n<h1>Julia</h1>\n<p>Developing code for research projects is in many ways similar to developing\nother software, but the key difference for me is that I need a quick\nturnaround time from idea to result not just once but in multiple iterations,\nsometimes changing the idea and implementation drastically.</p>\n<p>In a very real sense most research projects should fail to achieve their\noriginal goals; almost by definition research is beyond what is known to\nwork.  If you only attempt known-to-work ideas it is not research.\nIf your project fails it is important to learn as much as possible from the\nfailure, that is, increasing the understanding of the problem and finding\nsuitable new research ideas, and quick iterations make this process fun.\nThe new ideas are often variants of earlier ideas and thus can reuse code.  If\nthis code happens to be compact and flexible this translates directly into\nproductivity.</p>\n<p>Matlab, R, and Python achieve this tight cycle of iterations quite\nsuccessfully, but in all three languages there is a price towards the later\niterations in that for achieving a high performance implementation significant\nparts of the code needs to be rewritten in a more basic language\nsuch as C++, which then needs to be interfaced to the other code through some\ninterface specification.\nFor big high-value projects in industry with dedicated engineering support\nthe additional effort required is typically not a problem, but for individual\nresearchers it means hours and days spend writing additional code without\nadding functionality.</p>\n<p>This process is cumbersome, errorprone, and creates a strong coupling, making\nfurther iterations of changing ideas and implementations slower.\n(As an example, in my <a href=\"http://www.nowozin.net/sebastian/grante/\">grante</a>\nlibrary I prototyped many algorithms in Matlab, then programmed them in C++,\nthen wrote a Matlab interface which by itself is almost 2,000 lines of C++\ncode.)</p>\n<p><a href=\"http://julialang.org/\">Julia</a> also achieves this tight cycle, but does not\nrequire you to resort to compiled statically-typed languages such as C++ in\norder to achieve high performance.\nUsing a single language maintains productivity both at the very beginning\n(prototyping) and towards the later iterations (productization).</p>\n<p>Productivity in Julia (roughly \"scientific results per wallclock developer\ntime\") is achieved through a number of features:</p>\n<ul>\n<li><em>compact syntax</em>, for example I can declare a function using <code>f(x) = 2x+5</code>.\nAs mentioned above, I see the advantage of a compact syntax not in the\nkeystrokes saved initially, but in lowering the barrier to future\nunderstanding and modification as the code evolves.</li>\n<li><em>optional type annotation</em>, the above function will work for <code>x</code> being an\ninteger, or a float, or anything that has a multiplication and addition with\ninteger arguments defined; in fact, I could write <code>f(x::Float64) = 2x+5</code> to\nrequire that <code>x</code> is a float, but performance-wise they both yield the same\ncode.  This means that I can be strict about types when I need to be, but have\nthe feel of a <a href=\"https://en.wikipedia.org/wiki/Dynamic_programming_language\">dynamic programming\nlanguage</a>.</li>\n<li><a href=\"http://jupyter.org/\"><em>Jupyter notebook interface</em></a> for quick\nthink-implement-results cycles.</li>\n<li><em>excellent default choices of numerical libraries</em>, dense linear algebra,\nsparse linear algebra,\n<a href=\"http://juliaopt.org/\">numerical optimization libraries</a>,\n<a href=\"http://julia.readthedocs.org/en/latest/stdlib/numbers/#bigfloats\">arbitrary precision computation</a>,\n<a href=\"http://julia.readthedocs.org/en/latest/stdlib/math/?highlight=bessel#mathematical-functions\">special functions</a>,\n<a href=\"http://julia.readthedocs.org/en/latest/stdlib/math/?highlight=fft#signal-processing\">FFT</a>, etcetera, most of what you can wish for\nin a technical computing environment is already there by default or in the\nmany numerical packages available.  In terms of numerical optimization codes\nJulia is probably one of the <a href=\"http://www.juliaopt.org/\">best environments</a>\navailable.  All these libraries are carefully chosen to be the best-in-class\nfor the functions that they implement.</li>\n<li><a href=\"https://en.wikipedia.org/wiki/Foreign_function_interface\"><em>foreign function interfaces</em></a>\nto a number of languages:\n<a href=\"http://docs.julialang.org/en/release-0.3/stdlib/c/\">C and Fortran</a>,\n<a href=\"https://github.com/Keno/Cxx.jl\">C++</a> (unfortunately planned only for Julia 0.5),\n<a href=\"https://github.com/stevengj/PyCall.jl\">Python</a>,\n<a href=\"https://github.com/lgautier/Rif.jl\">R</a>,\n<a href=\"https://github.com/JuliaLang/MATLAB.jl\">Matlab</a>.  This makes it relatively\neasy to use code in any of these languages and I have used several Python\nlibraries without issues.</li>\n<li><a href=\"http://julialang.org/benchmarks/\"><em>high performance</em></a>, I regularly find my\nfirst-attempt Julia code for a problem to be an order of magnitude faster\nthan the equivalent Matlab code.  Infact, I <em>unlearned</em> a number of bad Matlab\nprogramming patterns such as using <code>bsxfun</code> and vectorizing all code.  Last\nyear I wrote Julia code for a <a href=\"https://en.wikipedia.org/wiki/R-tree\">R-tree data\nstructure</a> to maintain a dynamic spatial\nindex.  Doing this in Matlab/R/Python in a reasonably performant way would be\nunthinkable!  Instead you have to resort to <a href=\"https://pypi.python.org/pypi/Rtree/\">wrapping native\nlibraries</a>.\nIn Julia it was fun to write and it is fast, and I could add the required\nmethods I needed for my application easily, including fancy filtering\niterators.</li>\n<li><em>no separation between user and developer</em>, almost all of the base library\nis implemented in Julia itself, and it is easy to find where things are.  For\nexample, if you want to find out how two complex numbers are multiplied in\nJulia's base library? Enter <code>methods(*)</code> and <a href=\"https://github.com/JuliaLang/julia/blob/c8ceeefcc1dc25953a644622a895a3adcbc80dad/base/complex.jl#L112\">have a\nlook!</a>\nThis transparency makes it easy to learn good Julian style and extends further\nto how code is run:\nWant to see what machine code is executed when you call the <code>sqrt</code> function on\na single precision float?\nEnter <code>code_native(sqrt, (Float32,))</code> and see</li>\n</ul>\n<div class=\"highlight\"><pre><span></span><code><span class=\"na\">.text</span>\n    <span class=\"nl\">Filename:</span> <span class=\"nf\">math.jl</span>\n<span class=\"nf\">Source</span> <span class=\"no\">line</span><span class=\"p\">:</span> <span class=\"mi\">132</span>\n    <span class=\"nf\">push</span>    <span class=\"no\">RBP</span>\n    <span class=\"nf\">mov</span> <span class=\"no\">RBP</span><span class=\"p\">,</span> <span class=\"no\">RSP</span>\n    <span class=\"nf\">xorps</span>   <span class=\"no\">XMM1</span><span class=\"p\">,</span> <span class=\"no\">XMM1</span>\n    <span class=\"nf\">ucomiss</span> <span class=\"no\">XMM1</span><span class=\"p\">,</span> <span class=\"no\">XMM0</span>\n<span class=\"nf\">Source</span> <span class=\"no\">line</span><span class=\"p\">:</span> <span class=\"mi\">132</span>\n    <span class=\"nf\">ja</span>  <span class=\"mi\">6</span>\n    <span class=\"nf\">sqrtss</span>  <span class=\"no\">XMM0</span><span class=\"p\">,</span> <span class=\"no\">XMM0</span>\n    <span class=\"nf\">pop</span> <span class=\"no\">RBP</span>\n    <span class=\"nf\">ret</span>\n    <span class=\"nf\">movabs</span>  <span class=\"no\">RAX</span><span class=\"p\">,</span> <span class=\"mi\">140269793784104</span>\n    <span class=\"nf\">mov</span> <span class=\"no\">RDI</span><span class=\"p\">,</span> <span class=\"no\">QWORD</span> <span class=\"no\">PTR</span> <span class=\"p\">[</span><span class=\"no\">RAX</span><span class=\"p\">]</span>\n    <span class=\"nf\">movabs</span>  <span class=\"no\">RAX</span><span class=\"p\">,</span> <span class=\"mi\">140269778958624</span>\n    <span class=\"nf\">mov</span> <span class=\"no\">ESI</span><span class=\"p\">,</span> <span class=\"mi\">132</span>\n    <span class=\"nf\">call</span>    <span class=\"no\">RAX</span>\n</code></pre></div>\n\n<p>Almost nothing is hidden from the eyes of the user and this makes it easy and\nfun to look into the implementation.</p>\n<h2>Weak parts</h2>\n<p>Julia, while ready for serious use, is not yet at version 1.0 and lacks\nseveral important features.\nIn my work, I found the following pieces missing (as of version 0.4).</p>\n<ul>\n<li><em>Simple single machine parallelism</em>.  In C/C++/Fortran this would be\n<a href=\"http://openmp.org/wp/\">OpenMP</a> and in Matlab it is <code>parfor</code>.\nWhile Julia does have good support for <a href=\"http://julia.readthedocs.org/en/latest/manual/parallel-computing/\">distributed parallel\ncomputing</a>,\nit currently does not have simple single-machine parallelism.\nIn my experience using the distributed computing abstractions for single\nmachine parallelism has severe performance overheads because all data is\nserialized and remote method invocations are used to execute code.\n(Also, I found the use of <code>@everywhere</code> macros cumbersome.)\nApparently a simpler single machine parallelism is difficult to implement but\nin the works, as shown in this <a href=\"https://www.youtube.com/watch?v=GvLhseZ4D8M\">recent work by\nIntel</a> presented at JuliaCon\n2015.</li>\n<li><em>Debugger</em>.  Quite simply, a debugger is essential for larger projects where\nerrors can arise that are difficult to understand and debug without being able\nto interactively inspect the context in which the error appeared.\nCurrently Julia has <a href=\"https://github.com/toivoh/Debug.jl\">Debug.jl</a> which\nprovides debugging at <a href=\"http://www.gnu.org/software/gdb/\">gdb</a> level in terms\nof functionality.\nBut Julia lacks an interactive debugging capability on par with what is\navailable in Matlab or most C/C++ environments (actually, I am not sure about\n<a href=\"https://wiki.python.org/moin/PythonDebuggingTools\">Python debuggers</a> here, is\nthere a single popular tool?).\nAs far as I understand, this is planned for the 0.5 version of Julia.</li>\n<li><em>Shipping/productization/static-compilation</em>.  With this I mean the ability\nto select the distribution mechanism for the software, in particular to select\nwhether all dependencies are included so that the software \"will just run\" on\nthe target system, and whether binaries or source code is delivered.\nFor most researchers and open-source programmers this is not an issue and the\nJulia package system caters for all their needs, but I found it relevant in a\ncompany environment because explaining to someone how they install Julia and a\npiece of code takes a while, whereas for C++ I can typically easily send an\nexecutable file and some library dependencies.\nAs far as I understand, static compilation is planned for a future version of\nJulia.</li>\n</ul>\n<h1>Further Reading</h1>\n<p>If you want to give Julia a spin, here are a few links:</p>\n<ul>\n<li><a href=\"http://julialang.org/downloads/\">Official installer</a>, go for the 0.4\nrelease (or the release candidates until the final release is available).</li>\n<li><a href=\"https://github.com/stevengj/julia-mit/\">Julia at MIT</a> helpful\n  getting-started information, including the best way to install it on Windows.</li>\n<li><a href=\"http://tinyurl.com/JuliaLang\">Julia cheat sheet</a>, courtesy of Ian\n  Hellstroem.</li>\n<li><a href=\"https://gist.github.com/gizmaa/7214002\">Basic plotting examples</a></li>\n<li><a href=\"https://www.youtube.com/playlist?list=PLP8iPy9hna6Sdx4soiGrSefrmOPdUWixM\">JuliaCon 2015 talk recordings</a></li>\n</ul>\n<p>Packages which I use frequently and can recommend:</p>\n<ul>\n<li><a href=\"https://github.com/stevengj/PyPlot.jl\">PyPlot.jl</a>, wrapper around\n<a href=\"http://matplotlib.org/\">matplotlib</a> for all your plotting needs.</li>\n<li><a href=\"https://github.com/JuliaStats/Distributions.jl\">Distributions.jl</a>, common\nprobability distributions.</li>\n<li><a href=\"https://github.com/JuliaLang/IJulia.jl\">IJulia.jl</a> for interactive\nbrowser notebooks.</li>\n<li><a href=\"https://github.com/JuliaStats/DataFrames.jl\">DataFrames.jl</a> for processing\ntabular data.</li>\n<li><a href=\"https://github.com/goedman/Stan.jl\">Stan.jl</a>, an interface for the <a href=\"http://mc-stan.org/\">Stan\nprobabilistic programming language</a>.</li>\n<li><a href=\"https://github.com/JuliaOpt/JuMP.jl\">JuMP.jl</a> a high-performance\nmathematical modeling language with excellent solver integration.</li>\n<li><a href=\"https://github.com/JuliaOpt/NLopt.jl\">NLopt.jl</a> state-of-the-art\noptimization solvers for non-linear minimization (L-BFGS and gradient-free\nmethods).</li>\n<li><a href=\"https://github.com/JuliaGPU/OpenCL.jl\">OpenCL.jl</a> an interface for\n<a href=\"https://www.khronos.org/opencl/\">OpenCL</a> similar to PyOpenCL.  Not\nfeature-complete yet (e.g. images are missing).</li>\n</ul>\n<p>The <a href=\"http://pkg.julialang.org/pulse.html\">Julia package ecosystem</a> has a lot\nmore packages, so if you are looking for a particular thing, have a look\nthere.</p>",
  "category": ""
}