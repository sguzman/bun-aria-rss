{
  "title": "Distributed NumPy on a Cluster with Dask Arrays",
  "link": "",
  "updated": "2017-01-17T00:00:00+00:00",
  "id": "https://mrocklin.github.io/blog/work/2017/01/17/dask-images",
  "content": "<p><em>This work is supported by <a href=\"http://continuum.io\">Continuum Analytics</a>\nthe <a href=\"http://www.darpa.mil/program/XDATA\">XDATA Program</a>\nand the Data Driven Discovery Initiative from the <a href=\"https://www.moore.org/\">Moore\nFoundation</a></em></p>\n\n<p><em>This page includes embedded large profiles.  It may look better on the <a href=\"http://matthewrocklin.com/blog/work/2017/01/17/dask-images\">actual\nsite</a> rather than\nthrough syndicated pages like planet.python and it may take a while to load on\nnon-broadband connections (total size is around 20MB)</em></p>\n\n<h2 id=\"summary\">Summary</h2>\n\n<p>We analyze a stack of images in parallel with NumPy arrays distributed across a\ncluster of machines on Amazon’s EC2 with Dask array.  This is a model\napplication shared among many image analysis groups ranging from satellite\nimagery to bio-medical applications.  We go through a series of common\noperations:</p>\n\n<ol>\n  <li>Inspect a sample of images locally with Scikit Image</li>\n  <li>Construct a distributed Dask.array around all of our images</li>\n  <li>Process and re-center images with Numba</li>\n  <li>Transpose data to get a time-series for every pixel, compute FFTs</li>\n</ol>\n\n<p>This last step is quite fun.  Even if you skim through the rest of this article\nI recommend checking out the last section.</p>\n\n<h2 id=\"inspect-dataset\">Inspect Dataset</h2>\n\n<p>I asked a colleague at the US National Institutes for Health (NIH) for a\nbiggish imaging dataset.  He came back with the following message:</p>\n\n<p>*Electron microscopy may be generating the biggest ndarray datasets in the field - terabytes regularly. Neuroscience needs EM to see connections between neurons, because the critical features of neural synapses (connections) are below the diffraction limit of light microscopes. This type of research has been called “connectomics”.  Many groups are looking at machine vision approaches to follow small neuron parts from one slice to the next. *</p>\n\n<p>This data is from drosophila: <a href=\"http://emdata.janelia.org/\">http://emdata.janelia.org/</a>. Here is an example 2d slice of the data <a href=\"http://emdata.janelia.org/api/node/bf1/grayscale/raw/xy/2000_2000/1800_2300_5000\">http://emdata.janelia.org/api/node/bf1/grayscale/raw/xy/2000_2000/1800_2300_5000</a>.</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">import</span> <span class=\"nn\">skimage.io</span>\n<span class=\"kn\">import</span> <span class=\"nn\">matplotlib.pyplot</span> <span class=\"k\">as</span> <span class=\"n\">plt</span>\n\n<span class=\"n\">sample</span> <span class=\"o\">=</span> <span class=\"n\">skimage</span><span class=\"p\">.</span><span class=\"n\">io</span><span class=\"p\">.</span><span class=\"n\">imread</span><span class=\"p\">(</span><span class=\"s\">'http://emdata.janelia.org/api/node/bf1/grayscale/raw/xy/2000_2000/1800_2300_5000'</span>\n<span class=\"n\">skimage</span><span class=\"p\">.</span><span class=\"n\">io</span><span class=\"p\">.</span><span class=\"n\">imshow</span><span class=\"p\">(</span><span class=\"n\">sample</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<p><a href=\"https://mrocklin.github.io/blog/images/dask-imaging-sample.png\">\n  <img src=\"https://mrocklin.github.io/blog/images/dask-imaging-sample.png\" alt=\"Sample electron microscopy image from stack\" width=\"60%\" /></a></p>\n\n<p>The last number in the URL is an index into a large stack of about 10000 images.  We can change that number to get different slices through our 3D dataset.</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">samples</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">skimage</span><span class=\"p\">.</span><span class=\"n\">io</span><span class=\"p\">.</span><span class=\"n\">imread</span><span class=\"p\">(</span><span class=\"s\">'http://emdata.janelia.org/api/node/bf1/grayscale/raw/xy/2000_2000/1800_2300_%d'</span> <span class=\"o\">%</span> <span class=\"n\">i</span><span class=\"p\">)</span>\n    <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"p\">[</span><span class=\"mi\">1000</span><span class=\"p\">,</span> <span class=\"mi\">2000</span><span class=\"p\">,</span> <span class=\"mi\">3000</span><span class=\"p\">,</span> <span class=\"mi\">4000</span><span class=\"p\">,</span> <span class=\"mi\">5000</span><span class=\"p\">,</span> <span class=\"mi\">6000</span><span class=\"p\">,</span> <span class=\"mi\">7000</span><span class=\"p\">,</span> <span class=\"mi\">8000</span><span class=\"p\">,</span> <span class=\"mi\">9000</span><span class=\"p\">]]</span>\n\n<span class=\"n\">fig</span><span class=\"p\">,</span> <span class=\"n\">axarr</span> <span class=\"o\">=</span> <span class=\"n\">plt</span><span class=\"p\">.</span><span class=\"n\">subplots</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">9</span><span class=\"p\">,</span> <span class=\"n\">sharex</span><span class=\"o\">=</span><span class=\"bp\">True</span><span class=\"p\">,</span> <span class=\"n\">sharey</span><span class=\"o\">=</span><span class=\"bp\">True</span><span class=\"p\">,</span> <span class=\"n\">figsize</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">24</span><span class=\"p\">,</span> <span class=\"mf\">2.5</span><span class=\"p\">))</span>\n<span class=\"k\">for</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">sample</span> <span class=\"ow\">in</span> <span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"n\">samples</span><span class=\"p\">):</span>\n    <span class=\"n\">axarr</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">imshow</span><span class=\"p\">(</span><span class=\"n\">sample</span><span class=\"p\">,</span> <span class=\"n\">cmap</span><span class=\"o\">=</span><span class=\"s\">'gray'</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<p><a href=\"https://mrocklin.github.io/blog/images/dask-imaging-row.png\">\n  <img src=\"https://mrocklin.github.io/blog/images/dask-imaging-row.png\" alt=\"Sample electron microscopy images over time\" width=\"100%\" /></a></p>\n\n<p>We see that our field of interest wanders across the frame over time and drops\noff in the beginning and at the end.</p>\n\n<h2 id=\"create-a-distributed-array\">Create a Distributed Array</h2>\n\n<p>Even though our data is spread across many files, we still want to think of it\nas a single logical 3D array.  We know how to get any particular 2D slice of\nthat array using Scikit-image.  Now we’re going to use Dask.array to stitch\nall of those Scikit-image calls into a single distributed array.</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">import</span> <span class=\"nn\">dask.array</span> <span class=\"k\">as</span> <span class=\"n\">da</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dask</span> <span class=\"kn\">import</span> <span class=\"n\">delayed</span>\n\n<span class=\"n\">imread</span> <span class=\"o\">=</span> <span class=\"n\">delayed</span><span class=\"p\">(</span><span class=\"n\">skimage</span><span class=\"p\">.</span><span class=\"n\">io</span><span class=\"p\">.</span><span class=\"n\">imread</span><span class=\"p\">,</span> <span class=\"n\">pure</span><span class=\"o\">=</span><span class=\"bp\">True</span><span class=\"p\">)</span>  <span class=\"c1\"># Lazy version of imread\n</span>\n<span class=\"n\">urls</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s\">'http://emdata.janelia.org/api/node/bf1/grayscale/raw/xy/2000_2000/1800_2300_%d'</span> <span class=\"o\">%</span> <span class=\"n\">i</span>\n        <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">10000</span><span class=\"p\">)]</span>  <span class=\"c1\"># A list of our URLs\n</span>\n<span class=\"n\">lazy_values</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">imread</span><span class=\"p\">(</span><span class=\"n\">url</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">url</span> <span class=\"ow\">in</span> <span class=\"n\">urls</span><span class=\"p\">]</span>     <span class=\"c1\"># Lazily evaluate imread on each url\n</span>\n<span class=\"n\">arrays</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">da</span><span class=\"p\">.</span><span class=\"n\">from_delayed</span><span class=\"p\">(</span><span class=\"n\">lazy_value</span><span class=\"p\">,</span>           <span class=\"c1\"># Construct a small Dask array\n</span>                          <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"n\">sample</span><span class=\"p\">.</span><span class=\"n\">dtype</span><span class=\"p\">,</span>   <span class=\"c1\"># for every lazy value\n</span>                          <span class=\"n\">shape</span><span class=\"o\">=</span><span class=\"n\">sample</span><span class=\"p\">.</span><span class=\"n\">shape</span><span class=\"p\">)</span>\n          <span class=\"k\">for</span> <span class=\"n\">lazy_value</span> <span class=\"ow\">in</span> <span class=\"n\">lazy_values</span><span class=\"p\">]</span>\n\n<span class=\"n\">stack</span> <span class=\"o\">=</span> <span class=\"n\">da</span><span class=\"p\">.</span><span class=\"n\">stack</span><span class=\"p\">(</span><span class=\"n\">arrays</span><span class=\"p\">,</span> <span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>                <span class=\"c1\"># Stack all small Dask arrays into one\n</span></code></pre></div></div>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">stack</span>\n<span class=\"n\">dask</span><span class=\"p\">.</span><span class=\"n\">array</span><span class=\"o\">&lt;</span><span class=\"n\">shape</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">10000</span><span class=\"p\">,</span> <span class=\"mi\">2000</span><span class=\"p\">,</span> <span class=\"mi\">2000</span><span class=\"p\">),</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"n\">uint8</span><span class=\"p\">,</span> <span class=\"n\">chunksize</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2000</span><span class=\"p\">,</span> <span class=\"mi\">2000</span><span class=\"p\">)</span><span class=\"o\">&gt;</span>\n</code></pre></div></div>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">stack</span> <span class=\"o\">=</span> <span class=\"n\">stack</span><span class=\"p\">.</span><span class=\"n\">rechunk</span><span class=\"p\">((</span><span class=\"mi\">20</span><span class=\"p\">,</span> <span class=\"mi\">2000</span><span class=\"p\">,</span> <span class=\"mi\">2000</span><span class=\"p\">))</span>     <span class=\"c1\"># combine chunks to reduce overhead\n</span><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">stack</span>\n<span class=\"n\">dask</span><span class=\"p\">.</span><span class=\"n\">array</span><span class=\"o\">&lt;</span><span class=\"n\">shape</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">10000</span><span class=\"p\">,</span> <span class=\"mi\">2000</span><span class=\"p\">,</span> <span class=\"mi\">2000</span><span class=\"p\">),</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"n\">uint8</span><span class=\"p\">,</span> <span class=\"n\">chunksize</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">20</span><span class=\"p\">,</span> <span class=\"mi\">2000</span><span class=\"p\">,</span> <span class=\"mi\">2000</span><span class=\"p\">)</span><span class=\"o\">&gt;</span>\n</code></pre></div></div>\n\n<p>So here we’ve constructed a lazy Dask.array from 10 000 delayed calls to\n<code class=\"language-plaintext highlighter-rouge\">skimage.io.imread</code>.  We haven’t done any actual work yet, we’ve just\nconstructed a parallel array that knows how to get any particular slice of data\nby downloading the right image if necessary.  This gives us a full NumPy-like\nabstraction on top of all of these remote images.  For example we can now\ndownload a particular image just by slicing our Dask array.</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">stack</span><span class=\"p\">[</span><span class=\"mi\">5000</span><span class=\"p\">,</span> <span class=\"p\">:,</span> <span class=\"p\">:].</span><span class=\"n\">compute</span><span class=\"p\">()</span>\n<span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"p\">...,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span>\n       <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"p\">...,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span>\n       <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"p\">...,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span>\n       <span class=\"p\">...,</span>\n       <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"p\">...,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span>\n       <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"p\">...,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span>\n       <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"p\">...,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"n\">uint8</span><span class=\"p\">)</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">stack</span><span class=\"p\">[</span><span class=\"mi\">5000</span><span class=\"p\">,</span> <span class=\"p\">:,</span> <span class=\"p\">:].</span><span class=\"n\">mean</span><span class=\"p\">().</span><span class=\"n\">compute</span><span class=\"p\">()</span>\n<span class=\"mf\">11.49902425</span>\n</code></pre></div></div>\n\n<p>However we probably don’t want to operate too much further without connecting\nto a cluster.  That way we can just download all of the images once into\ndistributed RAM and start doing some real computations.  I happen to have ten\n<code class=\"language-plaintext highlighter-rouge\">m4.2xlarges</code> on Amazon’s EC2 (8 cores, 30GB RAM each) running Dask workers.\nSo we’ll connect to those.</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">from</span> <span class=\"nn\">dask.distributed</span> <span class=\"kn\">import</span> <span class=\"n\">Client</span><span class=\"p\">,</span> <span class=\"n\">progress</span>\n<span class=\"n\">client</span> <span class=\"o\">=</span> <span class=\"n\">Client</span><span class=\"p\">(</span><span class=\"s\">'schdeduler-address:8786'</span><span class=\"p\">)</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">client</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Client</span><span class=\"p\">:</span> <span class=\"n\">scheduler</span><span class=\"o\">=</span><span class=\"s\">\"scheduler-address:8786\"</span> <span class=\"n\">processes</span><span class=\"o\">=</span><span class=\"mi\">10</span> <span class=\"n\">cores</span><span class=\"o\">=</span><span class=\"mi\">80</span><span class=\"o\">&gt;</span>\n</code></pre></div></div>\n\n<p>I’ve replaced the actual address of my scheduler (something like\n<code class=\"language-plaintext highlighter-rouge\">54.183.180.153</code> with `scheduler-address.  Let’s go ahead and bring in all of\nour images, persisting the array into concrete data in memory.</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">stack</span> <span class=\"o\">=</span> <span class=\"n\">client</span><span class=\"p\">.</span><span class=\"n\">persist</span><span class=\"p\">(</span><span class=\"n\">stack</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<p>This starts downloads of our 10 000 images across our 10 workers.  When this\ncompletes we have 10 000 NumPy arrays spread around on our cluster, coordinated\nby our single logical Dask array.  This takes a while, about five minutes.\nWe’re mostly network bound here (Janelia’s servers are not co-located with our\ncompute nodes).  Here is a parallel profile of the computation as an\ninteractive <a href=\"http://bokeh.pydata.org/en/latest/\">Bokeh</a> plot.</p>\n\n<p>There will be a few of these profile plots throughout the blogpost, so you\nmight want to familiarize yoursel with them now.  Every horizontal rectangle in\nthis plot corresponds to a single Python function running somewhere in our\ncluster over time.  Because we called <code class=\"language-plaintext highlighter-rouge\">skimage.io.imread</code> 10 000 times there\nare 10 000 purple rectangles.  Their position along the y-axis denotes which of\nthe 80 cores in our cluster that they ran on and their position along the\nx-axis denotes their start and stop times.  You can hover over each rectangle\n(function) for more information on what kind of task it was, how long it took,\netc..  In the image below, purple rectangles are <code class=\"language-plaintext highlighter-rouge\">skimage.io.imread</code> calls and\nred rectangles are data transfer between workers in our cluster.  Click the\nmagnifying glass icons in the upper right of the image to enable zooming tools.</p>\n\n<iframe src=\"https://cdn.rawgit.com/mrocklin/e09cad939ff7a85a06f3b387f65dc2fc/raw/fa5e20ca674cf5554aa4cab5141019465ef02ce9/task-stream-image-load.html\" width=\"800\" height=\"400\"></iframe>\n\n<p>Now that we have persisted our Dask array in memory our data is based on\nhundreds of concrete in-memory NumPy arrays across the cluster, rather than\nbased on hundreds of lazy scikit-image calls.  Now we can do all sorts of fun\ndistributed array computations more quickly.</p>\n\n<p>For example we can easily see our field of interest move across the frame by\naveraging across time:</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">skimage</span><span class=\"p\">.</span><span class=\"n\">io</span><span class=\"p\">.</span><span class=\"n\">imshow</span><span class=\"p\">(</span><span class=\"n\">stack</span><span class=\"p\">.</span><span class=\"n\">mean</span><span class=\"p\">(</span><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">).</span><span class=\"n\">compute</span><span class=\"p\">())</span>\n</code></pre></div></div>\n\n<p><a href=\"https://mrocklin.github.io/blog/images/dask-imaging-time-mean.png\">\n  <img src=\"https://mrocklin.github.io/blog/images/dask-imaging-time-mean.png\" alt=\"Avergage image over time\" width=\"100%\" /></a></p>\n\n<iframe src=\"https://cdn.rawgit.com/mrocklin/e09cad939ff7a85a06f3b387f65dc2fc/raw/fa5e20ca674cf5554aa4cab5141019465ef02ce9/task-stream-image-mean-time.html\" width=\"700\" height=\"300\"></iframe>\n\n<p>Or we can see when the field of interest is actually present within the frame\nby averaging across x and y</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">plt</span><span class=\"p\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">stack</span><span class=\"p\">.</span><span class=\"n\">mean</span><span class=\"p\">(</span><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">]).</span><span class=\"n\">compute</span><span class=\"p\">())</span>\n</code></pre></div></div>\n\n<p><a href=\"https://mrocklin.github.io/blog/images/dask-imaging-spatial-mean.png\">\n  <img src=\"https://mrocklin.github.io/blog/images/dask-imaging-spatial-mean.png\" alt=\"Image brightness over time\" width=\"100%\" /></a></p>\n\n<iframe src=\"https://cdn.rawgit.com/mrocklin/e09cad939ff7a85a06f3b387f65dc2fc/raw/fa5e20ca674cf5554aa4cab5141019465ef02ce9/task-stream-image-mean-spatial.html\" width=\"700\" height=\"300\"></iframe>\n\n<p>By looking at the profile plots for each case we can see that averaging over\ntime involves much more inter-node communication, which can be quite expensive\nin this case.</p>\n\n<h2 id=\"recenter-images-with-numba\">Recenter Images with Numba</h2>\n\n<p>In order to remove the spatial offset across time we’re going to compute a\ncentroid for each slice and then crop the image around that center.  I looked\nup centroids in the Scikit-Image docs and came across a function that did <em>way</em>\nmore than what I was looking for, so I just quickly coded up a solution in Pure\nPython and then JIT-ed it with <a href=\"http://numba.pydata.org/\">Numba</a> (which makes\nthis run at C-speeds).</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">from</span> <span class=\"nn\">numba</span> <span class=\"kn\">import</span> <span class=\"n\">jit</span>\n\n<span class=\"o\">@</span><span class=\"n\">jit</span><span class=\"p\">(</span><span class=\"n\">nogil</span><span class=\"o\">=</span><span class=\"bp\">True</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">centroid</span><span class=\"p\">(</span><span class=\"n\">im</span><span class=\"p\">):</span>\n    <span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">m</span> <span class=\"o\">=</span> <span class=\"n\">im</span><span class=\"p\">.</span><span class=\"n\">shape</span>\n    <span class=\"n\">total_x</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n    <span class=\"n\">total_y</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n    <span class=\"n\">total</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n    <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">):</span>\n        <span class=\"k\">for</span> <span class=\"n\">j</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"p\">):</span>\n            <span class=\"n\">total</span> <span class=\"o\">+=</span> <span class=\"n\">im</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">j</span><span class=\"p\">]</span>\n            <span class=\"n\">total_x</span> <span class=\"o\">+=</span> <span class=\"n\">i</span> <span class=\"o\">*</span> <span class=\"n\">im</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">j</span><span class=\"p\">]</span>\n            <span class=\"n\">total_y</span> <span class=\"o\">+=</span> <span class=\"n\">j</span> <span class=\"o\">*</span> <span class=\"n\">im</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">j</span><span class=\"p\">]</span>\n\n    <span class=\"k\">if</span> <span class=\"n\">total</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n        <span class=\"n\">total_x</span> <span class=\"o\">/=</span> <span class=\"n\">total</span>\n        <span class=\"n\">total_y</span> <span class=\"o\">/=</span> <span class=\"n\">total</span>\n    <span class=\"k\">return</span> <span class=\"n\">total_x</span><span class=\"p\">,</span> <span class=\"n\">total_y</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">centroid</span><span class=\"p\">(</span><span class=\"n\">sample</span><span class=\"p\">)</span>  <span class=\"c1\"># this takes around 9ms\n</span><span class=\"p\">(</span><span class=\"mf\">748.7325324581344</span><span class=\"p\">,</span> <span class=\"mf\">802.4893005160851</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">recenter</span><span class=\"p\">(</span><span class=\"n\">im</span><span class=\"p\">):</span>\n    <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">centroid</span><span class=\"p\">(</span><span class=\"n\">im</span><span class=\"p\">.</span><span class=\"n\">squeeze</span><span class=\"p\">())</span>\n    <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"nb\">int</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">),</span> <span class=\"nb\">int</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"o\">&lt;</span> <span class=\"mi\">500</span><span class=\"p\">:</span>\n        <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"mi\">500</span>\n    <span class=\"k\">if</span> <span class=\"n\">y</span> <span class=\"o\">&lt;</span> <span class=\"mi\">500</span><span class=\"p\">:</span>\n        <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"mi\">500</span>\n    <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"o\">&gt;</span> <span class=\"mi\">1500</span><span class=\"p\">:</span>\n        <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"mi\">1500</span>\n    <span class=\"k\">if</span> <span class=\"n\">y</span> <span class=\"o\">&gt;</span> <span class=\"mi\">1500</span><span class=\"p\">:</span>\n        <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"mi\">1500</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">im</span><span class=\"p\">[...,</span> <span class=\"n\">x</span><span class=\"o\">-</span><span class=\"mi\">500</span><span class=\"p\">:</span><span class=\"n\">x</span><span class=\"o\">+</span><span class=\"mi\">500</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"o\">-</span><span class=\"mi\">500</span><span class=\"p\">:</span><span class=\"n\">y</span><span class=\"o\">+</span><span class=\"mi\">500</span><span class=\"p\">]</span>\n\n<span class=\"n\">plt</span><span class=\"p\">.</span><span class=\"n\">figure</span><span class=\"p\">(</span><span class=\"n\">figsize</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"mi\">8</span><span class=\"p\">))</span>\n<span class=\"n\">skimage</span><span class=\"p\">.</span><span class=\"n\">io</span><span class=\"p\">.</span><span class=\"n\">imshow</span><span class=\"p\">(</span><span class=\"n\">recenter</span><span class=\"p\">(</span><span class=\"n\">sample</span><span class=\"p\">))</span>\n</code></pre></div></div>\n\n<p><a href=\"https://mrocklin.github.io/blog/images/dask-imaging-recentered-sample.png\">\n  <img src=\"https://mrocklin.github.io/blog/images/dask-imaging-recentered-sample.png\" alt=\"Recentered image\" width=\"40%\" /></a></p>\n\n<p>Now we map this function across our distributed array.</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"n\">np</span>\n<span class=\"k\">def</span> <span class=\"nf\">recenter_block</span><span class=\"p\">(</span><span class=\"n\">block</span><span class=\"p\">):</span>\n    <span class=\"s\">\"\"\" Recenter a short stack of images \"\"\"</span>\n    <span class=\"k\">return</span> <span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">stack</span><span class=\"p\">([</span><span class=\"n\">recenter</span><span class=\"p\">(</span><span class=\"n\">block</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">])</span> <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">block</span><span class=\"p\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])])</span>\n\n<span class=\"n\">recentered</span> <span class=\"o\">=</span> <span class=\"n\">stack</span><span class=\"p\">.</span><span class=\"n\">map_blocks</span><span class=\"p\">(</span><span class=\"n\">recenter</span><span class=\"p\">,</span>\n                              <span class=\"n\">chunks</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">20</span><span class=\"p\">,</span> <span class=\"mi\">1000</span><span class=\"p\">,</span> <span class=\"mi\">1000</span><span class=\"p\">),</span>  <span class=\"c1\"># chunk size changes\n</span>                              <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">dtype</span><span class=\"p\">)</span>\n<span class=\"n\">recentered</span> <span class=\"o\">=</span> <span class=\"n\">client</span><span class=\"p\">.</span><span class=\"n\">persist</span><span class=\"p\">(</span><span class=\"n\">recentered</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<iframe src=\"https://cdn.rawgit.com/mrocklin/e09cad939ff7a85a06f3b387f65dc2fc/raw/fa5e20ca674cf5554aa4cab5141019465ef02ce9/task-stream-image-recentering.html\" width=\"800\" height=\"400\"></iframe>\n\n<p>This profile provides a good opportunity to talk about a scheduling <em>failure</em>;\nthings went a bit wrong here.  Towards the beginning we quickly recenter\nseveral images (Numba is fast), taking around 300-400ms for each block of\ntwenty images.  However as some workers finish all of their allotted tasks, the\nscheduler erroneously starts to load balance, moving images from busy workers\nto idle workers.  Unfortunately the network at this time appeared to be much\nslower than expected and so the move + compute elsewhere strategy ended up\nbeing much slower than just letting the busy workers finish their work.  The\nscheduler keeps track of expected compute times and transfer times precisely to\navoid mistakes like this one.  These sorts of issues are rare, but do occur on\noccasion.</p>\n\n<p>We check our work by averaging our re-centered images across time and displaying\nthat to the screen. We see that our images are better centered with each other\nas expected.</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">skimage</span><span class=\"p\">.</span><span class=\"n\">io</span><span class=\"p\">.</span><span class=\"n\">imshow</span><span class=\"p\">(</span><span class=\"n\">recentered</span><span class=\"p\">.</span><span class=\"n\">mean</span><span class=\"p\">(</span><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">))</span>\n</code></pre></div></div>\n\n<p><a href=\"https://mrocklin.github.io/blog/images/dask-imaging-recentered-time-mean.png\">\n  <img src=\"https://mrocklin.github.io/blog/images/dask-imaging-recentered-time-mean.png\" alt=\"Recentered time average\" width=\"40%\" /></a></p>\n\n<p>This shows how easy it is to create fast in-memory code with Numba and then\nscale it out with Dask.array.  The two projects complement each other nicely,\ngiving us near-optimal performance with intuitive code across a cluster.</p>\n\n<iframe src=\"https://cdn.rawgit.com/mrocklin/e09cad939ff7a85a06f3b387f65dc2fc/raw/fa5e20ca674cf5554aa4cab5141019465ef02ce9/task-stream-image-recenter-mean-time.html\" width=\"800\" height=\"400\"></iframe>\n\n<h2 id=\"rechunk-to-time-series-by-pixel\">Rechunk to Time Series by Pixel</h2>\n\n<p>We’re now going to rearrange our data from being partitioned by time slice, to\nbeing partitioned by pixel.  This will allow us to run computations like Fast\nFourier Transforms (FFTs) on each time series efficiently.  Switching the chunk\npattern back and forth like this is generally a very difficult operation for\ndistributed arrays because every slice of the array contributes to every\ntime-series.  We have N-squared communication.</p>\n\n<p>This analysis may not be appropriate for this data (we won’t learn any useful\nscience from doing this), but it represents a very frequently asked question,\nso I wanted to include it.</p>\n\n<p>Currently our Dask array has chunkshape (20, 1000, 1000), meaning that our data\nis collected into 500 NumPy arrays across the cluster, each of size <code class=\"language-plaintext highlighter-rouge\">(20, 1000,\n1000)</code>.</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">recentered</span>\n<span class=\"n\">dask</span><span class=\"p\">.</span><span class=\"n\">array</span><span class=\"o\">&lt;</span><span class=\"n\">shape</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">10000</span><span class=\"p\">,</span> <span class=\"mi\">1000</span><span class=\"p\">,</span> <span class=\"mi\">1000</span><span class=\"p\">),</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"n\">uint8</span><span class=\"p\">,</span> <span class=\"n\">chunksize</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">20</span><span class=\"p\">,</span> <span class=\"mi\">1000</span><span class=\"p\">,</span> <span class=\"mi\">1000</span><span class=\"p\">)</span><span class=\"o\">&gt;</span>\n</code></pre></div></div>\n\n<p>But we want to change this shape so that the chunks cover the entire first\naxis.  We want all data for any particular pixel to be in the same NumPy array,\nnot spread across hundreds of different NumPy arrays.  We could solve this by\nrechunking so that each pixel is its own block like the following:</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">rechunked</span> <span class=\"o\">=</span> <span class=\"n\">recentered</span><span class=\"p\">.</span><span class=\"n\">rechunk</span><span class=\"p\">((</span><span class=\"mi\">10000</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">))</span>\n</code></pre></div></div>\n\n<p>However this would result in one million chunks (there are one million pixels)\nwhich will result in a bit of scheduling overhead.  Instead we’ll collect our\ntime-series into <code class=\"language-plaintext highlighter-rouge\">10 x 10</code> groups of one hundred pixels.  This will help us to\nreduce overhead.</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># rechunked = recentered.rechunk((10000, 1, 1))  # Too many chunks\n</span><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">rechunked</span> <span class=\"o\">=</span> <span class=\"n\">recentered</span><span class=\"p\">.</span><span class=\"n\">rechunk</span><span class=\"p\">((</span><span class=\"mi\">10000</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">))</span>  <span class=\"c1\"># Use larger chunks\n</span></code></pre></div></div>\n\n<p>Now we compute the FFT of each pixel, take the absolute value and square to\nget the power spectrum.  Finally to conserve space we’ll down-grade the dtype\nto float32 (our original data is only 8-bit anyway).</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">da</span><span class=\"p\">.</span><span class=\"n\">fft</span><span class=\"p\">.</span><span class=\"n\">fft</span><span class=\"p\">(</span><span class=\"n\">rechunked</span><span class=\"p\">,</span> <span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"n\">power</span> <span class=\"o\">=</span> <span class=\"nb\">abs</span><span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">**</span> <span class=\"mi\">2</span><span class=\"p\">).</span><span class=\"n\">astype</span><span class=\"p\">(</span><span class=\"s\">'float32'</span><span class=\"p\">)</span>\n\n<span class=\"n\">power</span> <span class=\"o\">=</span> <span class=\"n\">client</span><span class=\"p\">.</span><span class=\"n\">persist</span><span class=\"p\">(</span><span class=\"n\">power</span><span class=\"p\">,</span> <span class=\"n\">optimize_graph</span><span class=\"o\">=</span><span class=\"bp\">False</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<p>This is a fun profile to inspect; it includes both the rechunking and the\nsubsequent FFTs.  We’ve included a real-time trace during execution, the full\nprofile, as well as some diagnostics plots from a single worker.  These plots\ntotal up to around 20MB.  I sincerely apologize to those without broadband\naccess.</p>\n\n<p>Here is a real time plot of the computation finishing over time:</p>\n\n<p><a href=\"https://mrocklin.github.io/blog/images/task-stream-fft.gif\">\n  <img src=\"https://mrocklin.github.io/blog/images/task-stream-fft.gif\" alt=\"Dask task stream of rechunk + fft\" width=\"100%\" /></a></p>\n\n<p>And here is a single interactive plot of the entire computation after it\ncompletes.  Zoom with the tools in the upper right.  Hover over rectangles to\nget more information.  Remember that red is communication.</p>\n\n<iframe src=\"https://cdn.rawgit.com/mrocklin/e09cad939ff7a85a06f3b387f65dc2fc/raw/fa5e20ca674cf5554aa4cab5141019465ef02ce9/task-stream-image-fft.html\" width=\"800\" height=\"400\"></iframe>\n\n<p>Screenshots of the diagnostic dashboard of a single worker during this\ncomputation.</p>\n\n<p><a href=\"https://mrocklin.github.io/blog/images/worker-state-fft.png\">\n  <img src=\"https://mrocklin.github.io/blog/images/worker-state-fft.png\" alt=\"Worker communications during FFT\" width=\"45%\" /></a>\n<a href=\"https://mrocklin.github.io/blog/images/worker-communications-fft.png\">\n  <img src=\"https://mrocklin.github.io/blog/images/worker-communications-fft.png\" alt=\"Worker communications during FFT\" width=\"45%\" /></a></p>\n\n<p>This computation starts with a lot of communication while we rechunk and\nrealign our data (recent optimizations here by <a href=\"https://github.com/pitrou\">Antoine\nPitrou</a> in <a href=\"https://github.com/dask/dask/pull/1737\">dask #417</a>).\nThen we transition into doing thousands of small FFTs and other arithmetic\noperations.  All of the plots above show a nice transition from heavy\ncommunication to heavy processing with some overlap each way (once some complex\nblocks are available we get to start overlapping communication and\ncomputation).  Inter-worker communication was around 100-300 MB/s (typical for\nAmazon’s EC2) and CPU load remained high.  We’re <em>using</em> our hardware.</p>\n\n<p>Finally we can inspect the results.  We see that the power spectrum is very\nboring in the corner, and has typical activity towards the center of the image.</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">plt</span><span class=\"p\">.</span><span class=\"n\">semilogy</span><span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">+</span> <span class=\"n\">power</span><span class=\"p\">[:,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"n\">compute</span><span class=\"p\">())</span>\n</code></pre></div></div>\n\n<p><a href=\"https://mrocklin.github.io/blog/images/dask-imaging-fft-0.png\">\n  <img src=\"https://mrocklin.github.io/blog/images/dask-imaging-fft-0.png\" alt=\"Power spectrum near edge\" width=\"70%\" /></a></p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">plt</span><span class=\"p\">.</span><span class=\"n\">semilogy</span><span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">+</span> <span class=\"n\">power</span><span class=\"p\">[:,</span> <span class=\"mi\">500</span><span class=\"p\">,</span> <span class=\"mi\">500</span><span class=\"p\">].</span><span class=\"n\">compute</span><span class=\"p\">())</span>\n</code></pre></div></div>\n\n<p><a href=\"https://mrocklin.github.io/blog/images/dask-imaging-fft-center.png\">\n  <img src=\"https://mrocklin.github.io/blog/images/dask-imaging-fft-center.png\" alt=\"Power spectrum at center\" width=\"70%\" /></a></p>\n\n<h2 id=\"final-thoughts\">Final Thoughts</h2>\n\n<p>This blogpost showed a non-trivial image processing workflow, emphasizing the\nfollowing points:</p>\n\n<ol>\n  <li>Construct a Dask array from lazy SKImage calls.</li>\n  <li>Use NumPy syntax with Dask.array to aggregate distributed data across a\ncluster.</li>\n  <li>Build a centroid function with Numba.  Use Numba and Dask together to\nclean up an image stack.</li>\n  <li>Rechunk to facilitate time-series operations.  Perform FFTs.</li>\n</ol>\n\n<p>Hopefully this example has components that look similar to what you want to do\nwith your data on your hardware.  We would love to see more applications like\nthis out there in the wild.</p>\n\n<h2 id=\"what-we-could-have-done-better\">What we could have done better</h2>\n\n<p>As always with all computationally focused blogposts we’ll include a section on\nwhat went wrong and what we could have done better with more time.</p>\n\n<ol>\n  <li><strong>Communication is too expensive</strong>:  Interworker communications that should\nbe taking 200ms are taking up to 10 or 20 seconds.  We need to take a\ncloser look at our communications pipeline (which normally performs just\nfine on other computations) to see if something is acting up.\nDisucssion here <a href=\"https://github.com/dask/distributed/issues/776\">dask/distributed #776</a>\nand early work here <a href=\"https://github.com/dask/distributed/pull/810\">dask/distributed #810</a>.</li>\n  <li><strong>Faulty Load balancing</strong>: We discovered a case where our load-balancing\nheuristics misbehaved, incorrectly moving data between workers when it\nwould have been better to let everything alone.  This is likely due to the\noddly low bandwidth issues observed above.</li>\n  <li><strong>Loading from disk blocks network I/O</strong>: While doing this we discovered an\nissue where loading large amounts of data from disk can block workers from\nresponding to network requests (<a href=\"https://github.com/dask/distributed/issues/774\">dask/distributed\n#774</a>)</li>\n  <li><strong>Larger datasets</strong>: It would be fun to try this on a much larger dataset\nto see how the solutions here scale.</li>\n</ol>"
}