{
  "title": "Topological Data Analysis - Persistent Homology",
  "link": "",
  "published": "2017-02-22T00:10:00-06:00",
  "updated": "2017-02-22T00:10:00-06:00",
  "author": {
    "name": "Brandon Brown"
  },
  "id": "tag:outlace.com,2017-02-22:/TDApart1.html",
  "summary": "<p>(Part 1) In this multi-part series we will go through the fundamental mathematics and algorithms of a powerful new tool for analysis of complex data.</p>",
  "content": "<h2>Topological Data Analysis - Part 1 - Persistent Homology</h2>\n<p>This is Part 1 in a series on topological data analysis.\nSee <a href=\"TDApart2.html\">Part 2</a> | <a href=\"TDApart3.html\">Part 3</a> | <a href=\"TDApart4.html\">Part 4</a> | <a href=\"TDApart5.html\">Part 5</a></p>\n<h4>Introduction</h4>\n<p>I find Topological Data Analysis (TDA) to be one of the most exciting (yet under-rated) developments in data analysis and thus I want to do my part to spread the knowledge. So what's it all about? Well there are two major flavors of TDA: persistent homology and mapper. Both are useful, and can be used to supplement each other. In this post (and the next couple of posts) we will cover persistent homology. TDA in general is very mathematical (it was born out the \"lab\" of a mathematics group at Stanford, particularly Gunnar Carlsson and his graduate student Gurjeet Singh, although the foundations had been developed for years before by others) and thus we cannot really study it without learning a lot of math. Hence, this post is going to be just as much a tutorial on various topics in higher math as it is TDA, so if you're not that interested in TDA but want to learn about topology, group theory, linear algebra, graph theory and abstract algebra, then this might be useful just in that regard. Of course, I will not cover these math topics in as much detail or with as much rigor as a textbook would, but my hope is if you understand what I present here, reading a textbook (or math papers) will make a whole lot more sense.</p>\n<h5>What is persistent homology and why should I care?</h5>\n<p>Think of a typical data set being a big Excel file with columns being various parameters and the rows being individual data points. Say there are 100 columns and 900 rows. If we think of the rows as being data points, then we can think of them as being 100-dimensional data points. Obviously, helplessly constrained to our 3-dimensional universe, we have no way of seeing what are data <em>looks</em> like. Well, of course there are numerous methods for projecting high-dimensional data down to a lower dimensional space that we <em>can</em> see. Usually we want to see our data so we can easily identify patterns, particularly clusters. The most well-known of these visualization methods is probably principal component analysis (PCA).  But all of these methods involve transforming our original data in a way that loses some potentially valuable information. There's no free lunch here, if you use PCA to project 100-dimensional data to a 2-dimensional plot, you're going to be missing something.</p>\n<p>Persistent homology (henceforth just <strong>PH</strong>) gives us a way to find interesting patterns in data without having to \"downgrade\" the data in anyway so we can see it. PH let's us leave our data in it's original, ultra-high dimensional space and tells us how many clusters there are, and how many loop-like structures there are in the data, all without being able to actually see it.</p>\n<p>As an example, consider a biologist studying some genes in cells. She uses fancy equipment to measure the expression levels of 100 genes in 900 different cells. She's interested in genes that might play a role in cell division. Being the cutting-edge biologist she is, she utilizes persistent homology to analyze her data and PH reports her data has a prominent <em>cycle</em>, which she further analyzes and is able to confirm that a subset of her 100 genes seem to have a cyclical expression pattern.</p>\n<p>The field of topology in mathematics studies properties of spaces where all we care about is the relationship of points to one another, unlike geometry, where exact distances and angles are important. Thus PH let's us ask topological questions of our data in a reliable way without having to adulterate the data in anyway. The conventional output from persistent homology is a \"barcode\" graph that looks like this:\n<img src=\"images/TDAimages/PHbarcodeExample.png\" width=\"600px\" />\nThis graph encodes all the topological features we're interested in a compact and visual way.</p>\n<h4>Intended audience</h4>\n<p>As usual, my intended audience is people like me. I'm a programmer with an interest in TDA. I majored in Neuroscience in college so I have no formal mathematics training beyond high school. Everything else has been self-taught. If you have a degree in mathematics, this is not the post for you, but you can take a look at my extensive reference list.</p>\n<h4>Assumptions</h4>\n<p>While I always attempt to make my posts as accessible to a general audience with a programming background and some basic math knowledge, I do make a few knowledge assumptions here. I assume you have a foundational understanding of the following:\n- High-school algebra\n- Set theory\n- Python and Numpy</p>\n<p>but I will try to explain as much as possible along the way. If you've followed my previous posts then you can probably follow this one.</p>\n<h3>Set Theory Review</h3>\n<p>We will just very quickly review basics of set theory, but I am assuming you already have the necessary background knowledge of set theory, this is just a refresher and guide for the notation we'll be using.</p>\n<p>Recall a <strong>set</strong> is an abstract mathematical structure that is an unordered collection of abstract objects, typically denoted by curly braces, e.g. the set <span class=\"math\">\\(S = \\{a,b,c\\}\\)</span>. The objects contained in a set are called its <em>elements</em>. If an element <span class=\"math\">\\(a\\)</span> is contained in a set <span class=\"math\">\\(S\\)</span>, then we denote this relationship as <span class=\"math\">\\(a \\in S\\)</span> where the symbol <span class=\"math\">\\(\\in\\)</span> is read \"in\" (<span class=\"math\">\\(a\\)</span> in <span class=\"math\">\\(S\\)</span>). Or if an element <span class=\"math\">\\(d\\)</span> is <em>not</em> in a set <span class=\"math\">\\(S\\)</span> then we denote it as <span class=\"math\">\\(d \\not\\in S\\)</span>. Intuitively, one can think of a set as a box or container and you can add various objects into the box (including other boxes).</p>\n<p>A <strong>subset</strong> <span class=\"math\">\\(Z\\)</span> of a set <span class=\"math\">\\(S\\)</span> is a set with all elements also in <span class=\"math\">\\(S\\)</span>. A strict subset is denoted <span class=\"math\">\\(Z \\subset S\\)</span>, which means there is at least one element in <span class=\"math\">\\(S\\)</span> that is not in <span class=\"math\">\\(Z\\)</span>, whereas <span class=\"math\">\\(Z \\subseteq S\\)</span> means <span class=\"math\">\\(Z\\)</span> could be a strict subset of <span class=\"math\">\\(S\\)</span> or it could be identical to <span class=\"math\">\\(S\\)</span>. For every set, the empty set (denoted <span class=\"math\">\\(\\emptyset\\)</span>), and the set itself are (non-strict) subsets, i.e. for a set <span class=\"math\">\\(S\\)</span>, <span class=\"math\">\\(\\emptyset \\subseteq S\\)</span> and <span class=\"math\">\\(S \\subseteq S\\)</span>.</p>\n<p>The symbol <span class=\"math\">\\(\\forall\\)</span> means \"for all\" and the symbol <span class=\"math\">\\(\\exists\\)</span> means \"there exists\". For example, we can say something like <span class=\"math\">\\(\\forall x \\in S\\)</span> which means \"for all elements <span class=\"math\">\\(x\\)</span> in <span class=\"math\">\\(S\\)</span>\". Or we can say, <span class=\"math\">\\(\\exists x \\in S, x = a\\)</span>, which means \"there exists an element x in the set <span class=\"math\">\\(S\\)</span> for which <span class=\"math\">\\(x = a\\)</span>\".</p>\n<p>There are logical operators we use called <strong>AND</strong> (denoted <span class=\"math\">\\(\\land\\)</span>) and <strong>OR</strong> (denoted <span class=\"math\">\\(\\lor\\)</span>). For example, suppose we have two sets <span class=\"math\">\\(S_1 = \\{a,b,c\\}, S_2 = \\{d,e\\}\\)</span>, we can propose <span class=\"math\">\\(a \\in S_1 \\land a \\in S_2\\)</span>, which we can evaluate to be a false proposition since <span class=\"math\">\\(a\\)</span> is <em>not</em> in <span class=\"math\">\\(S_2\\)</span>. The proposition <span class=\"math\">\\(a \\in S_1 \\lor a \\in S_2\\)</span> is evaluated to be true since the element <span class=\"math\">\\(a\\)</span> is one or both of the two sets in the proposition.</p>\n<p>The <strong>union</strong> (denoted <span class=\"math\">\\(\\cup\\)</span>) of two sets <span class=\"math\">\\(S_1, S_2\\)</span> is a new set <span class=\"math\">\\(S_3\\)</span> that contains all the elements from <span class=\"math\">\\(S_1\\)</span> and <span class=\"math\">\\(S_2\\)</span>. For example, if <span class=\"math\">\\(S_1 = \\{a,b,c\\}, S_2 = \\{d,e\\}\\)</span> then <span class=\"math\">\\(S_1 \\cup S_2 = \\{a,b,c,d,e\\}\\)</span>.</p>\n<p>We can use <em>set-builder notation</em> to describe this as <span class=\"math\">\\(S_1 \\cup S_2 = \\{x \\mid \\forall x \\in S_1, \\forall x \\in S_2\\}\\)</span> or equivalently <span class=\"math\">\\(S_1 \\cup S_2 = \\{x \\mid x \\in S_1 \\lor x \\in S_2\\}\\)</span>. The part before the vertical pipe | describes the elements that compose the set whereas the part after the pipe describe the conditions those elements must meet to be included in the set. For example, if we want to build the set of points that form a two-dimensional circle, <span class=\"math\">\\(C = \\{(a,b) \\mid a^2 + b^2 = 1\\}\\)</span>. This brings up <em>ordered sets</em> or <em>sequences</em> where the order of the elements does matter and we denote these by using parentheses, e.g. <span class=\"math\">\\((a,b,c) \\neq (c,b,a)\\)</span> whereas <span class=\"math\">\\(\\{a,b,c\\} = \\{c,b,a\\}\\)</span>.</p>\n<p>The <strong>intersection</strong> (denoted <span class=\"math\">\\(\\cap\\)</span>) of two sets <span class=\"math\">\\(S_1, S_2\\)</span> is a new set <span class=\"math\">\\(S_3\\)</span> that contains the elements that are shared between <span class=\"math\">\\(S_1\\)</span> and <span class=\"math\">\\(S_2\\)</span>, that is, <span class=\"math\">\\(S_1 \\cap S_2 = \\{x \\mid x\\in S_1 \\land x\\in S_2\\}\\)</span>. For example, if <span class=\"math\">\\(S_1 = \\{a,b,c\\}, S_2 = \\{a,b,d,e\\}\\)</span> then <span class=\"math\">\\(S_1 \\cap S_2 = \\{a,b\\}\\)</span>.</p>\n<p>The size or <strong>cardinality</strong> of a set is the number of elements in that set. For example, if <span class=\"math\">\\(S = \\{a,b,c\\}\\)</span> then the cardinality of <span class=\"math\">\\(S\\)</span>, denoted <span class=\"math\">\\(\\vert{S}\\vert = 3\\)</span>.</p>\n<p>A <strong>function</strong> is a relation between the elements in one set to another set. We can visualize a function as so:\n<img src=\"images/TDAimages/setFuncExWiki.png\" width=\"150px\" />\n(source: &lt; https://en.wikipedia.org/wiki/Function_(mathematics) &gt;)</p>\n<p>Here we have two sets <span class=\"math\">\\(X = \\{1,2,3\\}\\)</span> and <span class=\"math\">\\(Y = \\{A,B,C,D\\}\\)</span> and a function <span class=\"math\">\\(f\\)</span> that maps each element in <span class=\"math\">\\(X\\)</span> (called the domain) to an element in <span class=\"math\">\\(Y\\)</span> (the codomain). We denote <span class=\"math\">\\(f(1) = D\\)</span> to mean that the function <span class=\"math\">\\(f\\)</span> is mapping the element <span class=\"math\">\\(1 \\in X\\)</span> to <span class=\"math\">\\(D \\in Y\\)</span>.</p>\n<p>A generic mapping or relation can be any mapping of elements in one set to another set, however, a <em>function</em> must only have one output for each input, i.e. each element in the domain can only be mapped to a single element in the codomain.</p>\n<p>We define a function by building a new set of ordered pairs. For two sets <span class=\"math\">\\(X\\)</span> and <span class=\"math\">\\(Y\\)</span>, we denote a function <span class=\"math\">\\(f : X \\rightarrow Y\\)</span> to be a subset of the Cartesian product <span class=\"math\">\\(X \\times Y\\)</span> (i.e., <span class=\"math\">\\(f \\subseteq X \\times Y\\)</span>). A <strong>Cartesian product</strong> is the set of all possible ordered pairs between elements in the two sets. </p>\n<p>For example, the set that defines the function <span class=\"math\">\\(f\\)</span> from the picture above is <span class=\"math\">\\(f = \\{(1,D), (2,C), (3,C)\\})\\)</span>. So if we want to know the result of <span class=\"math\">\\(f(1)\\)</span> then we just find the ordered pair where <span class=\"math\">\\(1\\)</span> is in the first position, and the second position element is the result (in this case its <span class=\"math\">\\(D\\)</span>).</p>\n<p>The <strong>image</strong> of a function <span class=\"math\">\\(f : X \\rightarrow Y\\)</span> is the subset of <span class=\"math\">\\(Y\\)</span> whose elements are mapped to elements in <span class=\"math\">\\(X\\)</span>. For example, for the function depicted above, the image of the function is <span class=\"math\">\\(\\{C,D\\}\\)</span> since only those elements are mapped to elements in <span class=\"math\">\\(X\\)</span>.</p>\n<p>Given a function <span class=\"math\">\\(f : X \\rightarrow Y\\)</span>, the <strong>preimage</strong> of a subset <span class=\"math\">\\(K \\subseteq Y\\)</span> is the set of elements in <span class=\"math\">\\(X\\)</span> that are mapped to elements in <span class=\"math\">\\(K\\)</span>. For example, the preimage of the subset <span class=\"math\">\\(K = \\{C\\}\\)</span> from the depicted function above is the set <span class=\"math\">\\(\\{2,3\\}\\)</span>.</p>\n<h3>Topology Primer</h3>\n<p>As you might have guessed, TDA involves the mathematical field of topology. I'm far from a mathematician, but we have to have a basic context so I'll do my best to explain the relevant aspects of topology in the least jargon-y and most computational (that's how I tend to think) way possible.</p>\n<p>So mathematics in general is broken up into many fields of study, such as geometry, topology, linear algebra, etc. Each field is essentially defined by the mathematical objects under study. In linear algebra, the mathematical objects of interest are <em>vector spaces</em>. In topology, the mathematical objects are <em>topological spaces</em>. And since set theory is taken as a foundation of mathematics, all these mathematical objects are simply sets (collections of abstract things) with specific rules about what form the sets must be in and how they can be transformed or operated on.</p>\n<p>Let's define what a topological space is now. This is one of several equivalent definitions of a topology (taken from wikipedia):</p>\n<blockquote>\n<p><strong>Definition (Topological Space)</strong> <br />\n A topological space is an ordered pair <span class=\"math\">\\((X, \\tau)\\)</span>, where <span class=\"math\">\\(X\\)</span> is a set and <span class=\"math\">\\(\\tau\\)</span> is a collection of subsets (subset  symbol: <span class=\"math\">\\(\\subseteq\\)</span> ) of <span class=\"math\">\\(X\\)</span>, satisfying the following axioms:\n - The empty set (symbol: <span class=\"math\">\\(\\emptyset\\)</span>) and <span class=\"math\">\\(X\\)</span> itself belong to <span class=\"math\">\\(\\tau\\)</span>.\n - Any (finite or infinite) union (symbol: <span class=\"math\">\\(\\cup\\)</span> ) of members of <span class=\"math\">\\(\\tau\\)</span> still belongs to <span class=\"math\">\\(\\tau\\)</span>.\n - The intersection (symbol: <span class=\"math\">\\(\\cap\\)</span> ) of any finite number of members of <span class=\"math\">\\(\\tau\\)</span> still belongs to <span class=\"math\">\\(\\tau\\)</span>.</p>\n<p>The elements of <span class=\"math\">\\(\\tau\\)</span> are called <strong>open sets</strong> and the collection <span class=\"math\">\\(\\tau\\)</span> is called a topology on <span class=\"math\">\\(X\\)</span>.</p>\n</blockquote>\n<p>Okay so what the hell does that even mean and who cares? Let's give a really simple example.\nSo let's just make up an abstract set of objects that happen to be some of the English alphabet letters. Here's our set, <span class=\"math\">\\(X = \\{a,b,c\\}\\)</span>. So we have a collection of 3 distinct objects and we want to define a topology on that set. Our topology τ (tau) is simply going to be a set of sets, it's a collection of subsets from X that satisfy the axioms of topology.</p>\n<p>Let's give it a try, maybe our topology τ should be this: <span class=\"math\">\\(\\{\\{a\\},\\{b\\},\\{c\\}\\}\\)</span>. So our topology τ is a collection of single element subsets from X. Notice the difference in notation. If I had simply written <span class=\"math\">\\(\\tau = \\{a,b,c\\}\\)</span> that would merely be the same as <span class=\"math\">\\(X\\)</span>, just an ordinary set with 3 elements. No, <span class=\"math\">\\(\\tau\\)</span> is a set whose elements are also sets (even if those sets contain one element). </p>\n<p>Ok, anyway, does our <span class=\"math\">\\(\\tau\\)</span> satisfy the axioms? Does the empty set and <span class=\"math\">\\(X\\)</span> itself belong to <span class=\"math\">\\(\\tau\\)</span>? Uh no. The empty set is <span class=\"math\">\\(\\{\\}\\)</span> (or <span class=\"math\">\\(\\emptyset\\)</span>) and <span class=\"math\">\\(X\\)</span> itself is <span class=\"math\">\\(\\{a,b,c\\}\\)</span>, our <span class=\"math\">\\(\\tau\\)</span> did not have those two sets as members, so already our attempted topology failed. Let's try again. How about <span class=\"math\">\\(\\tau = \\{\\emptyset,\\{a\\},\\{b\\},\\{c\\}, \\{a,b,c\\}\\}\\)</span>. Now at least this τ satisfies the first axiom. The second axiom is less obvious, but take for example the union of <span class=\"math\">\\(\\{a\\}\\)</span> and <span class=\"math\">\\(\\{b\\}\\)</span>, which yields <span class=\"math\">\\(\\{a,b\\}\\)</span>. Is <span class=\"math\">\\(\\{a,b\\}\\)</span> in <span class=\"math\">\\(\\tau\\)</span>? No it's not, so this attempted topology also fails.</p>\n<p>Alright here's a legitimate topology on <span class=\"math\">\\(X\\)</span>... <span class=\"math\">\\(\\tau = \\{\\emptyset, \\{a\\}, \\{a,b,c\\}\\}\\)</span>. It satisfies the first axiom, it has the empty set <span class=\"math\">\\(\\{\\}\\)</span> and the full <span class=\"math\">\\(X\\)</span> set as members of <span class=\"math\">\\(\\tau\\)</span>, and if you take the union of any combination of members of <span class=\"math\">\\(\\tau\\)</span>, the resulting set is also a member of <span class=\"math\">\\(\\tau\\)</span>.</p>\n<p>For example,\n<span class=\"math\">\\( \\{ \\} \\cup \\{ a \\} = \\{ a \\} $ (read: the empty set union the set $\\{a\\}\\)</span> produces the set <span class=\"math\">\\(\\{a\\}\\)</span>). Obviously the union of the empty set and <span class=\"math\">\\(\\{a\\}\\)</span> must produce <span class=\"math\">\\(\\{a\\}\\)</span> which is in <span class=\"math\">\\(\\tau\\)</span>. We must verify for all possible unions and intersections that the results are still in <span class=\"math\">\\(\\tau\\)</span>.</p>\n<p><span class=\"math\">\\( \\{a\\} \\cup \\{a,b,c\\} = \\{a,b,c\\} $, which is also in $\\tau\\)</span>.\n<span class=\"math\">\\( \\{a\\} \\cap \\{a,b,c\\} = \\{a\\}\\)</span>, which is also in <span class=\"math\">\\(\\tau\\)</span>.</p>\n<p>Hence, the union or intersection of any elements in <span class=\"math\">\\(\\tau\\)</span> is also in <span class=\"math\">\\(\\tau\\)</span>, thus we have ourselves a valid topology on <span class=\"math\">\\(X\\)</span>.</p>\n<p>I know this all seems rather academic at this point, but keep with me and we will eventually get to a point of using this new knowledge for practical purposes.</p>\n<h5>Closeness</h5>\n<p>What is important about topological spaces as opposed to any other mathematical abstraction? Well, one important aspect is that topological spaces end up defining a notion of <em>closeness</em> between elements in a set that has a defined topology. In a \"raw\" set that has no structure defined, e.g. <span class=\"math\">\\(Y = \\{c,d,e\\}\\)</span>, it's just a collection of abstract objects. That's it, there's nothing more we say about this set or it's elements. But once we define a topology on <span class=\"math\">\\(Y\\)</span>, then we can answer questions like \"is the element <span class=\"math\">\\(c \\in Y\\)</span> closer to <span class=\"math\">\\(d\\)</span> than <span class=\"math\">\\(e\\)</span> is to <span class=\"math\">\\(d\\)</span>?\"</p>\n<p>One of the fascinating things about mathematics is how so many things relate to each other and how there are almost always several ways of defining mathematical relationships, some of which are easier to grasp than others. So far we've been considering <strong>finite</strong> topological spaces, that is, the set <span class=\"math\">\\(X\\)</span> for which we've defined a topology has a finite number of elements. Of course topological spaces do not have to be finite, and we'll eventually spend most of our time considering infinite topological spaces such as those defined on the set of real numbers. When we start to consider those types of spaces, visualizing them tends to be easier as we can often draw diagrams. As you've probably noticed, all this abstract non-sense about open sets defining a topological space seems really hard to grasp intuitively. As it turns out, however, there is another way to represent <em>finite</em> topological spaces, and that is by using <strong>directed graphs</strong>.</p>\n<h5>A little bit of graph theory</h5>\n<blockquote>\n<p><strong>Definition (Graph)</strong> <br />\nA simple graph <span class=\"math\">\\(G\\)</span> is a set of vertices (or nodes) <span class=\"math\">\\(V\\)</span> paired with a set of edges (i.e. connections between vertices) <span class=\"math\">\\(E\\)</span>, whose elements are 2-element subsets of <span class=\"math\">\\(V\\)</span>. Hence, <span class=\"math\">\\(G = (V,E)\\)</span>.</p>\n</blockquote>\n<p>Example: G(V,E) where <span class=\"math\">\\(V = \\{a,b,c,d\\}, E = \\{\\{a,b\\},\\{a,d\\},\\{a,c\\},\\{c,d\\}\\}\\)</span>\n<img src=\"images/TDAimages/Graph1.svg\"  width=\"250px\" /></p>\n<blockquote>\n<p><strong>Definition (Directed Graph)</strong> <br />\nA <strong>directed</strong> graph (or digraph) <span class=\"math\">\\(G(V,E)\\)</span> is a graph whose edges are ordered pairs of vertices from <span class=\"math\">\\(V\\)</span>. Thus the \"connections\" between vertices/nodes have direction. The first vertex in an ordered pair is the start and the second vertex is the end. When drawing the graph, the edges are arrows with the arrowhead facing toward and contacting the end vertex.</p>\n</blockquote>\n<p>Example: G(V,E) where <span class=\"math\">\\(V = \\{a,b,c,d\\}, E = \\{(b,a), (a,d), (a,c), (c,d)\\}\\)</span>\n<img src=\"images/TDAimages/Graph2.svg\"  width=\"250px\" /></p>\n<p>Just for completeness sake, I want to mention a couple other properties we can impose on graph structures. We've already noted how graphs can have a direction property to the edges, but edges can also have a <strong>weight</strong> property, i.e. different edges can have different weights or strengths, implying that some connections are stronger than others. When drawing graphs with weighted edges, one way to depict this would be to simply make edges with bigger weights as proportionally thicker lines. Mathematically, a graph with vertices, edges, and weights is defined as a graph <span class=\"math\">\\(G(V,E,w)\\)</span> where <span class=\"math\">\\(w : E \\rightarrow \\mathbb R\\)</span> (<span class=\"math\">\\(w\\)</span> is a function that maps each edge in E to a real number, it's weight). Similarly, one can have a function that endows each vertex with a weight. One might depict this where nodes (vertices) are of different sizes reflecting their respective weights. </p>\n<h4>Visualizing Finite Topology</h4>\n<p>It turns out that one can build a set of binary relations called <strong>preorders</strong> between elements in a set <span class=\"math\">\\(X\\)</span> with topology <span class=\"math\">\\(\\tau\\)</span>. The binary relation preorder is both reflexive (every element is related to itself, <span class=\"math\">\\(a \\sim a\\)</span>) and transitive (if <span class=\"math\">\\(a\\)</span> is related to <span class=\"math\">\\(b\\)</span>, and <span class=\"math\">\\(b\\)</span> is related to <span class=\"math\">\\(c\\)</span>, it implies <span class=\"math\">\\(a\\)</span> is related to <span class=\"math\">\\(c\\)</span>, i.e. <span class=\"math\">\\(a \\sim b \\land b \\sim c \\Rightarrow a \\sim c\\)</span>). [The symbol ~ is used generically to denote the relation of interest]. This preorder relation (more precisely called a <em>specialization preorder</em> on <span class=\"math\">\\(X\\)</span>) can be determined by examining pair-wise relationships of elements in <span class=\"math\">\\(X\\)</span> one at a time. The specialization preorder relation is generally denoted by the symbol <span class=\"math\">\\(\\leq\\)</span> (but it is not the same as the less-than-or-equal-to sign that you're used to; there are only so many convenient symbols so things tend to get re-used).</p>\n<p>Here's the definition of a specialization pre-order on a topological space <span class=\"math\">\\((X, \\tau)\\)</span> (note there are other equivalent definitions).</p>\n<blockquote>\n<p><strong>Definition (Specialization Pre-order)</strong> <br />\n<span class=\"math\">\\( \\text{ $x \\leq y\\)</span>, if and only if <span class=\"math\">\\(y\\)</span> is contained in all the open sets containing <span class=\"math\">\\(x\\)</span> } $</p>\n</blockquote>\n<p>And remember that open sets are the elements of the topology <span class=\"math\">\\(\\tau\\)</span>. Once we've determined that <span class=\"math\">\\(x \\leq y,\\ \\forall x,y \\in X\\)</span>, then we can say that <span class=\"math\">\\(x\\)</span> is a <em>specialization</em> of <span class=\"math\">\\(y\\)</span>. This kind of means that <span class=\"math\">\\(y\\)</span> is more general than <span class=\"math\">\\(x\\)</span> since it appears in more open sets.</p>\n<blockquote>\n<p><strong>Example (Topology)</strong> <br />\nTo illustrate a graphic represention of our previous finite topological space, let's expand our topology on <span class=\"math\">\\(X = \\{a,b,c\\}\\)</span>.\nNow, <span class=\"math\">\\(\\tau = \\{\\{\\}, \\{a\\}, \\{b\\}, \\{a,b\\}, \\{b,c\\}, \\{a,b,c\\}\\}\\)</span></p>\n</blockquote>\n<p>To define the specialization preorder on this topological space, we need to enumerate all the possible pairings of points in the topology and figure out if the preorder relation <span class=\"math\">\\(\\leq\\)</span> is satisfied for each pair. Let's just focus on one pair, <span class=\"math\">\\((c,b)\\)</span>, so we want to ask if <span class=\"math\">\\(c \\leq b\\)</span> is true. According to our definition of specialization preorder, if <span class=\"math\">\\(c\\)</span> is in fact <span class=\"math\">\\(\\leq b\\)</span>, then <span class=\"math\">\\(b\\)</span> will be contained in all of the open sets that contain <span class=\"math\">\\(c\\)</span>. So let's list out all the open sets that contain <span class=\"math\">\\(c: \\{b,c\\}, \\{a,b,c\\}\\)</span>. As you can see, both of these open sets that contain <span class=\"math\">\\(c\\)</span> also contain <span class=\"math\">\\(b\\)</span>, therefore, <span class=\"math\">\\(c \\leq b\\)</span> is true. An important note is that the preorder relation does not imply equality when two elements are specializations of each other, i.e. if <span class=\"math\">\\(x \\leq y \\land y \\leq x \\not \\Rightarrow x = y\\)</span></p>\n<p>I will list all the true and untrue preorderings on <span class=\"math\">\\(X\\)</span> and then we can build the topological space into a visualization graph.</p>\n<p><span class=\"math\">\\( \na \\not\\leq b \\\\\na \\not\\leq c \\\\\nb \\not\\leq a \\\\\nb \\not\\leq c \\\\\nc \\not\\leq a \\\\\nc \\leq b \\\\\n$\n&lt;br /&gt;\nThere is only one true preorder relation between all pairs of points in $X\\)</span>. In order to make a directed graph from a preorder on a topological space <span class=\"math\">\\((X,\\tau)\\)</span>, you simply take the points in <span class=\"math\">\\(X\\)</span> as vertices of the graph and create a directed edge between two vertices that have a preorder relation, where the arrow points from the specialization point to the more general point (i.e. if <span class=\"math\">\\(x \\leq y\\)</span> then our graph will have an edge starting from <span class=\"math\">\\(x\\)</span> and pointing to <span class=\"math\">\\(y\\)</span>). Any points without relations to other points are just disconnected nodes. Here's the visualized graph of our example preorder on <span class=\"math\">\\(X\\)</span>.</p>\n<p><img src=\"images/TDAimages/Graph3.svg\"  width=\"250px\" /></p>\n<blockquote>\n<p><strong>Example (Specialization preorder graph)</strong> <br />\nHere's another example on a different topological space. Let <span class=\"math\">\\(Z = \\{a, b, c, d\\}\\)</span> be a set with the topology\n<span class=\"math\">\\(\\tau_Z = \\{Z, \\emptyset, \\{b\\}, \\{a, b\\}, \\{b, c, d\\}\\}\\)</span>. Listing the specialization preorder on <span class=\"math\">\\(Z\\)</span> is left as an exercise for the reader. The graph of this topological space resulting from its specialization preorder is shown.\n<img src=\"images/TDAimages/Graph4.svg\"  width=\"250px\" /></p>\n</blockquote>\n<p>Just like you can take any finite topological space, generate a specialization preorder on it and build a graph, you can also take a graph built by a preordering and generate its topology. In fact, by just looking at the graph you can determine a lot of the topological properties of the space. With this view, you can interpret a finite topology as a set of points with paths between them.</p>\n<h5>Connectedness</h5>\n<p>I'll digress here to define another property of topological spaces called connectedness. If you draw two separated circles on a sheet of paper those two shapes represent a topological space that is <em>disconnected</em> since there is no line or path connecting the circles. In this case we would say there are two <em>components</em> in the space. The intuiton captures the sense of how many \"whole pieces\" are in the space. The definition of connectedness in topology abstracts and generalizes the intuitive notion of \"pieces\" in a space.</p>\n<blockquote>\n<p><strong>Definition (Connectedness)</strong> <br />\nA topological space <span class=\"math\">\\((X,\\tau)\\)</span> is said to be <em>connected</em> if <span class=\"math\">\\(X\\)</span> is not the union of two disjoint nonempty open sets. Consequently, a topological space is <em>disconnected</em> if the union of any two disjoint nonempty subsets in <span class=\"math\">\\(\\tau\\)</span> produces <span class=\"math\">\\(X\\)</span>. </p>\n</blockquote>\n<p>Looking back at the previous example, with <span class=\"math\">\\(X = \\{a,b,c\\}, \\tau = \\{\\{\\}, \\{a\\}, \\{b\\}, \\{a,b\\}, \\{b,c\\}, \\{a,b,c\\}\\}\\)</span>, we can determine that this topological space is disconnected because the union of the disjoint (they dont share any common elements) open sets <span class=\"math\">\\(\\{a\\} \\cup \\{b,c\\} = X\\)</span>. Alternatively, if we look at the graph that we generated from our preordering on <span class=\"math\">\\(X\\)</span>, we can visually see that <span class=\"math\">\\(c\\)</span> and <span class=\"math\">\\(b\\)</span> are connected by an edge but <span class=\"math\">\\(a\\)</span> is a disconnected point. The graph for the example with set <span class=\"math\">\\(Z\\)</span>, however, demonstrates that this topological space is connected, all the vertices are connected in some way.</p>\n<p>With these types of general \"pure\" topological spaces, we can't say anymore than \"closeness\", we don't have a notion of distance. We know <span class=\"math\">\\(b\\)</span> is close to <span class=\"math\">\\(c\\)</span> but we can't say <em>how</em> close. All we know is closeness in terms of relations between elements, e.g. this element is closer to that element than this other element, and so on.</p>\n<h4>Metric Spaces</h4>\n<p>As you've probably noticed, the general \"pure\" topological spaces we've been studying are fairly abstract. We're going to move to studying <em>metric spaces</em>, which are a type of topological space with a definite notion distance, not merely an abstract notion of \"closeness.\" That is, all metric spaces are topological spaces but not all topological spaces are metric spaces. Being in the land of metric spaces makes things a lot easier, and fortunately topological data analysis is really dealing with metric spaces not \"pure\" topological spaces.</p>\n<blockquote>\n<p><strong>Definition (Metric Space):</strong> <br />\n<span class=\"math\">\\( \\text{A metric space is an ordered pair $(M,d)\\)</span> where <span class=\"math\">\\(M\\)</span> is a set and <span class=\"math\">\\(d\\)</span> is a metric on <span class=\"math\">\\(M\\)</span>, that is, a function}\n\\\nd: M\\times M \\rightarrow \\mathbb{R}$</p>\n<p>(this defines a function <span class=\"math\">\\(d\\)</span> mapping every ordered pair of elements in <span class=\"math\">\\(M\\)</span> to an element in the set of real numbers  <span class=\"math\">\\(\\mathbb R\\)</span>) <br /><br />\n<span class=\"math\">\\(  \\text {\nsuch that for any elements $x,y,z\\)</span> in <span class=\"math\">\\(M\\)</span>, the following conditions are met: <span class=\"math\">\\(\\\\\\)</span>\n1. <span class=\"math\">\\(d(x,y)\\geq 0\\)</span> (all distances are non-negative) <span class=\"math\">\\(\\\\\\)</span>\n2. <span class=\"math\">\\(d(x,y) = 0\\)</span> if and only if (iff) x = y <span class=\"math\">\\(\\\\\\)</span>\n3. <span class=\"math\">\\(d(x,y) = d(y,x)\\)</span> (distance is symmetrical) <span class=\"math\">\\(\\\\\\)</span>\n4. <span class=\"math\">\\(d(x,z) \\leq d(x,y) + d(y,z)\\)</span> (going from x to z directly must be shorter than stopping at a another point along  the way)\n} \n$</p>\n</blockquote>\n<p>This should be fairly straightforward. A metric space is simply a set paired with a distance function that accepts any two elements from that set and returns the metric distance between those two elements. The most familiar metric spaces would be the real number line, where the set is the set of real numbers and the metric is taken to be the absolute value of the difference between any two numbers on the line (for any <span class=\"math\">\\(x,y\\)</span> in <span class=\"math\">\\(\\mathbb R\\)</span>, <span class=\"math\">\\(d = |x-y|\\)</span>). Another familiar one is the 2-dimensional Euclidian space in <span class=\"math\">\\(\\mathbb R^2\\)</span>, where the distance function between any two points <span class=\"math\">\\((x_1,y_1)\\)</span> and <span class=\"math\">\\((x_2,y_2)\\)</span> is defined as <span class=\"math\">\\(d = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}\\)</span>.</p>\n<p>The Euclidian metric basically defines a topological space in which the shortest path between any two points is a straight line. One could define a different metric where all the points lie on the surface of a sphere and thus only a curved line is the shortest path between two points. One mustn't be constrained to the real numbers, however. You can have a matric space where the set is a bunch of images, or text blobs, or whatever type of data, as long as you can define a function that computes the distance between any two elements in the set, it's a valid metric space.</p>\n<h5>Continuity</h5>\n<p>An important concept in topology is the notion of continuity. Imagine a flat sheet of gold (or some other pliable metal) in the shape of a square. You could very carefully transform this flat sheet into a circle by smashing at the edges until the hard edges become curved. From a topology standpoint, the square and the circle are equivalent topological spaces because you can apply a continuous transformation from the square to the circle. And since a topology is all about defining the closeness relationships between points, if you've continuously deformed a square into a circle, then any two points that were \"close\" before the deformation are still \"close\" after the deformation. All the closeness relations between points have been preserved even if the shape looks different from a geometric perspective (in geometry you care about the actual distance between points not just their abstract and relative closeness).</p>\n<blockquote>\n<p><strong>Definition (Homomorphism)</strong>\nThere is a <strong>homomorphism</strong> (i.e. an equivalence relation) between two topological spaces if there exists a function \n<span class=\"math\">\\( f: X \\rightarrow Y \\text{, where X and Y are topological spaces } (X,\\tau_X) \\text{ and } (Y, \\tau_Y) $\nwith the following properties:\n- $f\\)</span> maps the elements of <span class=\"math\">\\(X\\)</span> to <span class=\"math\">\\(Y\\)</span> in a one-to-one relationship (bijective).\n- <span class=\"math\">\\(f\\)</span> is continuous\n- The inverse function <span class=\"math\">\\(f^-1\\)</span> is continuous</p>\n</blockquote>\n<p>What does continuous mean? We'll state the precise mathematical definition then try to find an intuitive meaning. </p>\n<blockquote>\n<p><strong>Definition (Continuous Function)</strong> <br />\nFor two topological spaces <span class=\"math\">\\((X,\\tau_X) \\text{ and } (Y, \\tau_Y)\\)</span>, a function <span class=\"math\">\\(f\\)</span> is continuous if for every element in <span class=\"math\">\\(V \\in \\tau_Y\\)</span>  (i.e. open subsets of Y), the preimage (inverse image) <span class=\"math\">\\(f^{−1}(V)\\)</span> is open in <span class=\"math\">\\(X\\)</span>.</p>\n</blockquote>\n<p>Here's an equivalent definition of a continuous function that employs an understanding of specialization preorders on a topological space.<br /></p>\n<blockquote>\n<p><strong>Definition (Continuous Function)</strong> <br />\nA function <span class=\"math\">\\(f : X \\rightarrow Y\\)</span> is continuous if and only if it is order preserving: <span class=\"math\">\\(x \\leq y\\)</span> in <span class=\"math\">\\(X\\)</span> implies <span class=\"math\">\\(f(x) \\leq f(y)\\)</span> in <span class=\"math\">\\(Y\\)</span> .</p>\n</blockquote>\n<p>We must remember that a function is a mapping where each element in a set <span class=\"math\">\\(X\\)</span> is mapped to elements in another set <span class=\"math\">\\(Y\\)</span> (it's a mapping between elements of the sets <span class=\"math\">\\(X\\)</span> and <span class=\"math\">\\(Y\\)</span> not a mapping between their topologies <span class=\"math\">\\(\\tau_X\\)</span> and <span class=\"math\">\\(\\tau_Y\\)</span> ). We also need to recall the definitions of preimage (or inverse image) from set theory. Recall that the domain of a function <span class=\"math\">\\(f: X \\rightarrow Y\\)</span> is <span class=\"math\">\\(X\\)</span> and it's codomain is <span class=\"math\">\\(Y\\)</span>. The <em>image</em> of <span class=\"math\">\\(f\\)</span> is the subset of <span class=\"math\">\\(Y\\)</span> for which there is a mapping between each element <span class=\"math\">\\(x \\in X\\)</span> and elements <span class=\"math\">\\(y \\in Y\\)</span>. That is, the image of <span class=\"math\">\\(f\\)</span> is <span class=\"math\">\\(\\{f(x) \\mid x \\in X\\}\\)</span>.  We can also speak of the image of a subset <span class=\"math\">\\(U \\subset X\\)</span> being the set <span class=\"math\">\\(\\{f(x) \\mid x \\in U\\}\\)</span>. The preimage (aka inverse image) of <span class=\"math\">\\(f\\)</span> is equal to the domain of <span class=\"math\">\\(f\\)</span>, therefore we really only refer to the preimage of individual elements or subsets of <span class=\"math\">\\(Y\\)</span></p>\n<blockquote>\n<p>The preimage or inverse image of a set <span class=\"math\">\\(B \\subseteq Y\\)</span> under <span class=\"math\">\\(f\\)</span> is the subset of <span class=\"math\">\\(X\\)</span> defined by\n<span class=\"math\">\\(f^{-1}(B) = \\{ x \\in X \\mid f(x) \\in B\\}\\)</span></p>\n<p><strong>Example (Continuous function)</strong> <br />\nLet <span class=\"math\">\\(X = \\{a,b,c\\}\\)</span> and its topology <span class=\"math\">\\(\\tau_X = \\{\\emptyset, \\{a\\}, X\\}\\)</span>. <span class=\"math\">\\(Y = \\{d\\}\\)</span> and its topology <span class=\"math\">\\(\\tau_Y = \\{\\emptyset, Y\\}\\)</span>. A continuous function <span class=\"math\">\\(f: X \\rightarrow Y\\)</span> is depicted below.\n<img src=\"images/TDAimages/function1.svg\" /></p>\n</blockquote>\n<p>We can see that the preimage <span class=\"math\">\\(f^{-1}(\\{d\\}) = \\{a,b,c\\}\\)</span> is an open set in <span class=\"math\">\\(X\\)</span>, thus this function is continuous. Yes, it is a pretty unimpressive function called a constant function since it maps all <span class=\"math\">\\(X\\)</span> to a single element. The intuitive idea of a continuous function in <span class=\"math\">\\(\\mathbb R^2\\)</span> is one that can be drawn without lifting one's pencil.</p>\n<h4>Simplices and Simplicial Complexes</h4>\n<p>Topological data analysis employs the use of simplicial complexes, which are complexes of geometric structures called simplices (singular: simplex). TDA uses simplicial complexes because they can approximate more complicated shapes and are much more mathematically and computationally tractable than the original shapes that they approximate.</p>\n<p>In words, a simplex is a generalization of a triangle to arbitrary dimensions. For example, we call a 2-simplex an ordinary 3-sided triangle in two-dimensions (or could be embedded in higher-dimensional spaces), and a 3-simplex is a tetrahedron (with triangles as faces) in 3-dimensions, and a 4-simplex is beyond our visualization, but it has tetrahedrons as faces and so on.</p>\n<p><img src=\"images/TDAimages/simplices2.svg\" /></p>\n<p>A simplicial complex is formed when we \"glue\" together different simplices. For example, we can connect a 2-simplex (triangle) to another 2-simplex via a 1-simplex (line segment).</p>\n<blockquote>\n<p><strong>Example (Simplicial Complex)</strong>\n<img src=\"images/TDAimages/simplicialcomplex2.svg\" />\nThis depicts two triangles connected along one side, which are connected via a 1-simplex (line segment) to a third triangle. We call this a 2-complex because the highest-dimensional simplex in the complex is a 2-simplex (triangle). </p>\n</blockquote>\n<p>The <strong>faces</strong> of a simplex are its boundaries. For a 1-simplex (line segment) the faces are points (0-simplices), for a 2-simplex (triangle) the faces are line segments, and for a 3-simplex (tetrahedron) the faces are triangles (2-simplices) and so on. When depicting a simplex or complex, it is conventional to \"color in\" the faces of a simplex to make it clear that the simplex is a \"solid object.\" For example, it is possible to draw a graph with three connected points that is actually a simplicial complex (1-complex) of line segments even though it looks like a triangle (but the middle is \"empty\"). If we color in the face, then we are indicating that it is actually a filled-in 2-simplex.</p>\n<blockquote>\n<p>A simplex versus a simplicial complex. Importance of \"coloring in\" simplices.\n<img src=\"images/TDAimages/simplexVScomplex1.svg\" /></p>\n</blockquote>\n<p>Okay, so we have an intuition for what simplices and simplicial complexes are, but now we need a precise mathematical definition.</p>\n<blockquote>\n<p><strong>Definition (Abstract Simplex)</strong> <br />\nAn <em>abstract</em> simplex is any finite set of vertices. For example, the simplex <span class=\"math\">\\(J = \\{a,b\\}\\)</span> and <span class=\"math\">\\(K = \\{a,b,c\\}\\)</span> represent a 1-simplex (line segment) and a 2-simplex (triangle), respectively.</p>\n</blockquote>\n<p>Notice this defines an <em>abstract</em> simplex. An abstract simplex and abstract simplicial complexes are abstract because we haven't given them any specific geometric realization. They're \"graph-like\" objects since we could technically draw the simplices in any number of arbitrary ways (e.g. line segments become curvy lines). A <em>geometric</em> 2-simplex, for example, could be the triangle formed by connecting the points <span class=\"math\">\\(\\{(0,0),(0,1),(1,1)\\}\\)</span> in <span class=\"math\">\\(\\mathbb R^2\\)</span> (the ordinary 2-dimensional Euclidian plane) and filling in the middle. The definition for a geometric simplex would be different (and more complicated) since it would need to include all points within some boundary.</p>\n<blockquote>\n<p><strong>Definition (Simplicial Complex)</strong> <br />\n<span class=\"math\">\\( \\text{ A simplicial complex $\\mathcal {K} $ is a set of simplices that satisfies the following conditions: }\\)</span></p>\n<ol>\n<li><span class=\"math\">\\( \\text {Any face of a simplex in $\\mathcal {K}\\)</span> is also in <span class=\"math\">\\(\\mathcal {K}\\)</span> }$.</li>\n<li><span class=\"math\">\\( \\text {The intersection of any two simplices $\\sigma _{1}, \\sigma _{2}\\in \\mathcal {K}\\)</span> is either <span class=\"math\">\\( \\emptyset $ or a face of both $\\sigma _{1}\\)</span> and <span class=\"math\">\\(\\sigma _{2}\\)</span> }$</li>\n</ol>\n</blockquote>\n<p>As an example, here is a simplicial complex depicted graphically with vertex labels and then we'll define it mathematically.\n<img src=\"images/TDAimages/simplicialcomplex4.svg\" /></p>\n<p>This simplicial complex is defined as a set: <span class=\"math\">\\(K = \\text{{{a},{b},{c},{d},{e},{f},{a,b},{a,c},{b,c},{c,d},{d,f},{d,e},{e,f},{a,b,c},{d,e,f}}}\\)</span>\nNotice that we first list all the 0-simplices (vertices), then we list all the 1-simplices (line segments), then we list the 2-simplices (triangles). If we had any higher-dimensional simplices then those would come next and so on. Thus we meet the conditions set in Definition 8.2 because any face of a higher-dimensional simplex will be listed before and so on all the way down to individual vertices. Of course since this is a set (of sets), order does not matter, however, it is conventional to list the complex in this way for readability.</p>\n<p>The second condition set in the definition for a simplicial complex means that structures such as this are <em>not</em> valid simplices or complexes:\n<img src=\"images/TDAimages/notacomplex1.svg\" />\nThis is invalid since the line segment is connected to the triangle along its edge and not at one of its vertices.</p>\n<p>When we analyze data, our data is generally in the form of a finite metric space, i.e. we have discrete points (e.g. from a database of rows and columns of data) with a metric function defined (which places them in some metric space, like Euclidian space), and this gives us a \"point cloud.\" A point cloud is just a bunch of points placed in our space with no obvious relationship.</p>\n<p>Here's a point cloud in <span class=\"math\">\\(\\mathbb R^2\\)</span> that kind of looks like a circle, or we could say the points look as if they were <em>sampled</em> from a circle.\n<img src=\"images/TDAimages/pointcloud1.svg\" />\nHere's a similar point cloud in <span class=\"math\">\\(\\mathbb R^2\\)</span> but it's smaller and more elliptical than circular. \n<img src=\"images/TDAimages/pointcloud2.svg\" />\nA geometrician who builds a simplicial complex from these two point clouds would say they are quite different shapes geometrically, however, the topologist would say they are topologically identical since they both have a single \"loop\" feature and only exhibit one component (\"piece\"). Topologists don't care about differences in size/scale or mere stretching of edges, they care about <strong>topological invariants</strong> (properties of topological spaces that do not vary with certain types of continous deformations) such as holes, loops, and connected components.</p>\n<p>So just how <em>do</em> we construct a simplicial complex from data? And how do we calculate these topological invariants?\nWell, there are actually many different types of simplicial complex constructions that have differing properties. Some are easier to describe mathematically, some are easier to compute algorithmically, others are simple but computationally inefficient. The most common simplicial complexes go by names such as the Čech complex, Vietoris-Rips complex, alpha complex, and witness complex.</p>\n<p>We will focus on just one, the <strong>Vietoris-Rips (VR) complex</strong>, as it is fairly easy to describe and reasonably practical from a computational standpoint. I will briefly describe other complexes as appropriate.</p>\n<h5>Constructing a Vietoris-Rips Complex</h5>\n<p>Intuitively, we construct a Vietoris-Rips (VR) complex from a point cloud <span class=\"math\">\\(P \\subseteq \\mathbb R^d\\)</span> (a subset <span class=\"math\">\\(P\\)</span> of some <span class=\"math\">\\(d\\)</span>-dimensional space) by initially connecting points in <span class=\"math\">\\(P\\)</span> with edges that are less than some arbitrarily defined distance <span class=\"math\">\\(\\epsilon\\)</span> from each other. This will construct a 1-complex, which is essentially just a graph as described above (a set of vertices and a set of edges between those vertices). Next we need to fill in the higher-dimensional simplices, e.g. any triangles, tetrahedrons, etc. so we won't have a bunch of empty holes.</p>\n<p>Here's a visualization of the major steps (from left to right) of constructing a VR complex on a small point cloud in <span class=\"math\">\\(\\mathbb R^2\\)</span> that was sampled from a circular structure:</p>\n<div>\n    <div style=\"width:20%; float:left; margin:10px 35px 25px 10px;\"><img src=\"images/TDAimages/pointcloud3.svg\" /></div>\n    <div style=\"width:20%; float:left; margin:10px 35px 25px 10px;\"><img src=\"images/TDAimages/VRcomplex1.svg\" /></div>\n    <div style=\"width:20%; float:left; margin:10px 35px 25px 10px;\"><img src=\"images/TDAimages/VRcomplex2.svg\" /></div>\n    <div style=\"width:20%; float:left; margin:10px 0px 25px 0px;\"><img src=\"images/TDAimages/VRcomplex3.svg\" /></div>\n</div>\n<div style=\"clear: both;\"></div>\n\n<p>As you can see, we take what are called the <strong><span class=\"math\">\\(\\epsilon\\)</span>-balls</strong> around each point in <span class=\"math\">\\(P\\)</span> (the dotted circles of radius <span class=\"math\">\\(\\epsilon\\)</span>) and build edges between that point and all other points within its ball. I only drew in the balls for a few of the points on the left because it would get too hard to see if I drew them all. More generally, a <strong>ball</strong> around a d-dimensional point is the (d-1)-dimensional generalization of a sphere around that point. So the ball of a point in <span class=\"math\">\\(\\mathbb R\\)</span> (the real number line) is simply a line segment around that point, the ball of a point in <span class=\"math\">\\(\\mathbb R^2\\)</span> is a circle, a ball around a point in <span class=\"math\">\\(\\mathbb R^3\\)</span> is a sphere, and so on. It is important to realize that a particular VR construction depends not only on the point cloud data but also on a parameter <span class=\"math\">\\(\\epsilon\\)</span> that is arbitrarily chosen. </p>\n<blockquote>\n<p><strong>Note</strong> (How to choose <span class=\"math\">\\(\\epsilon\\)</span>) <br />\nSo how does one know what to make <span class=\"math\">\\(\\epsilon\\)</span>? Excellent question, and the answer is simple: you just play around with various levels for <span class=\"math\">\\(\\epsilon\\)</span> and see what seems to result in a meaningful VR complex. If you set <span class=\"math\">\\(\\epsilon\\)</span> too  small, then your complex may just consist of the original point cloud, or only a few edges between points. If you set <span class=\"math\">\\(\\epsilon\\)</span> too big, then the point cloud will just become one massive ultradimensional simplex. As we will learn later, the key to actually discovering meaningful patterns in a simplicial complex is to continuously vary the <span class=\"math\">\\(\\epsilon\\)</span> parameter (and continually re-build complexes) from 0 to a maximum that results in a single massive simplex. Then you generate a diagram that shows what topological features are born and die as <span class=\"math\">\\(\\epsilon\\)</span> continuously increases. We assume that features that persist for long intervals over <span class=\"math\">\\(\\epsilon\\)</span> are meaningful features whereas features that are very short-lived are likely noise. This procedure is called <strong>persistent homology</strong> as it finds the  homological features of a topological space (specifically a simplicial complex) that persist while you vary <span class=\"math\">\\(\\epsilon\\)</span>. We will delve deeper in persistent homology after we've learned how to build simplicial complexes from data.</p>\n</blockquote>\n<p>Let's make the VR construction mathematically precise...</p>\n<blockquote>\n<p><strong>Definition (Vietoris-Rips Complex)</strong> <br />\nIf we have a set of points <span class=\"math\">\\(P\\)</span> of dimension <span class=\"math\">\\(d\\)</span>, and <span class=\"math\">\\(P\\)</span> is a subset of <span class=\"math\">\\(\\mathbb R^d\\)</span>, then the Vietoris-Rips (VR) complex <span class=\"math\">\\(V_{\\epsilon}(P)\\)</span> at scale <span class=\"math\">\\(\\epsilon\\)</span>  (the VR complex over the point cloud <span class=\"math\">\\(P\\)</span> with parameter <span class=\"math\">\\(\\epsilon\\)</span>) is defined as:</p>\n<p><span class=\"math\">\\(V_{\\epsilon}(P) = \\{ \\sigma \\subseteq P \\mid d(u,v) \\le \\epsilon, \\forall u \\neq v \\in \\sigma \\}\\)</span></p>\n</blockquote>\n<p>Okay let's translate that into English. It reads as follows: The VR complex at scale <span class=\"math\">\\(\\epsilon\\)</span> is the set <span class=\"math\">\\(V_{\\epsilon}(P)\\)</span> of all subsets <span class=\"math\">\\(\\sigma\\)</span> of <span class=\"math\">\\(P\\)</span> such that the pair-wise distance between any non-identical points in <span class=\"math\">\\(\\sigma\\)</span> is less than or equal to a parameter <span class=\"math\">\\(\\epsilon\\)</span>.</p>\n<p>So basically, if we have a data set <span class=\"math\">\\(P\\)</span> with a bunch of points, we add a simplex <span class=\"math\">\\(\\sigma\\)</span> (which is a subset of <span class=\"math\">\\(P\\)</span>) if the points in <span class=\"math\">\\(\\sigma\\)</span> are all within <span class=\"math\">\\(\\epsilon\\)</span> distance of each other. Thus we get a set of subsets of <span class=\"math\">\\(P\\)</span> that are all simplices, and hence we get a simplicial complex of <span class=\"math\">\\(P\\)</span>.</p>\n<h6>Next time...</h6>\n<p>We're going to end this post here for now but we'll pick up right where we left off in Part 2 where we'll actually start writing some code to build a Vietoris-Rips complex on some data.</p>\n<h4>References (Websites):</h4>\n<ol>\n<li>http://dyinglovegrape.com/math/topology_data_1.php</li>\n<li>http://www.math.uiuc.edu/~r-ash/Algebra/Chapter4.pdf</li>\n<li>https://en.wikipedia.org/wiki/Group_(mathematics)</li>\n<li>https://jeremykun.com/2013/04/03/homology-theory-a-primer/</li>\n<li>http://suess.sdf-eu.org/website/lang/de/algtop/notes4.pdf</li>\n<li>http://www.mit.edu/~evanchen/napkin.html</li>\n</ol>\n<h4>References (Academic Publications):</h4>\n<ol>\n<li>\n<p>Basher, M. (2012). On the Folding of Finite Topological Space. International Mathematical Forum, 7(15), 745–752. Retrieved from http://www.m-hikari.com/imf/imf-2012/13-16-2012/basherIMF13-16-2012.pdf</p>\n</li>\n<li>\n<p>Day, M. (2012). Notes on Cayley Graphs for Math 5123 Cayley graphs, 1–6.</p>\n</li>\n<li>\n<p>Doktorova, M. (2012). CONSTRUCTING SIMPLICIAL COMPLEXES OVER by, (June).</p>\n</li>\n<li>\n<p>Edelsbrunner, H. (2006). IV.1 Homology. Computational Topology, 81–87. Retrieved from http://www.cs.duke.edu/courses/fall06/cps296.1/</p>\n</li>\n<li>\n<p>Erickson, J. (1908). Homology. Computational Topology, 1–11.</p>\n</li>\n<li>\n<p>Evan Chen. (2016). An Infinitely Large Napkin.</p>\n</li>\n<li>\n<p>Grigor’yan, A., Muranov, Y. V., &amp; Yau, S. T. (2014). Graphs associated with simplicial complexes. Homology, Homotopy and Applications, 16(1), 295–311. http://doi.org/10.4310/HHA.2014.v16.n1.a16</p>\n</li>\n<li>\n<p>Kaczynski, T., Mischaikow, K., &amp; Mrozek, M. (2003). Computing homology. Homology, Homotopy and Applications, 5(2), 233–256. http://doi.org/10.4310/HHA.2003.v5.n2.a8</p>\n</li>\n<li>\n<p>Kerber, M. (2016). Persistent Homology – State of the art and challenges 1 Motivation for multi-scale topology. Internat. Math. Nachrichten Nr, 231(231), 15–33.</p>\n</li>\n<li>\n<p>Khoury, M. (n.d.). Lecture 6 : Introduction to Simplicial Homology Topics in Computational Topology : An Algorithmic View, 1–6.</p>\n</li>\n<li>\n<p>Kraft, R. (2016). Illustrations of Data Analysis Using the Mapper Algorithm and Persistent Homology.</p>\n</li>\n<li>\n<p>Lakshmivarahan, S., &amp; Sivakumar, L. (2016). Cayley Graphs, (1), 1–9.</p>\n</li>\n<li>\n<p>Liu, X., Xie, Z., &amp; Yi, D. (2012). A fast algorithm for constructing topological structure in large data. Homology, Homotopy and Applications, 14(1), 221–238. http://doi.org/10.4310/HHA.2012.v14.n1.a11</p>\n</li>\n<li>\n<p>Naik, V. (2006). Group theory : a first journey, 1–21.</p>\n</li>\n<li>\n<p>Otter, N., Porter, M. A., Tillmann, U., Grindrod, P., &amp; Harrington, H. A. (2015). A roadmap for the computation of persistent homology. Preprint ArXiv, (June), 17. Retrieved from http://arxiv.org/abs/1506.08903</p>\n</li>\n<li>\n<p>Semester, A. (2017). § 4 . Simplicial Complexes and Simplicial Homology, 1–13.</p>\n</li>\n<li>\n<p>Singh, G. (2007). Algorithms for Topological Analysis of Data, (November).</p>\n</li>\n<li>\n<p>Zomorodian, A. (2009). Computational Topology Notes. Advances in Discrete and Computational Geometry, 2, 109–143. Retrieved from http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.50.7483</p>\n</li>\n<li>\n<p>Zomorodian, A. (2010). Fast construction of the Vietoris-Rips complex. Computers and Graphics (Pergamon), 34(3), 263–271. http://doi.org/10.1016/j.cag.2010.03.007</p>\n</li>\n<li>\n<p>Symmetry and Group Theory 1. (2016), 1–18. http://doi.org/10.1016/B978-0-444-53786-7.00026-5</p>\n</li>\n</ol>\n<div class=\"highlight\"><pre><span></span><code>\n</code></pre></div>\n\n<script type=\"text/javascript\">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {\n    var align = \"center\",\n        indent = \"0em\",\n        linebreak = \"false\";\n\n    if (false) {\n        align = (screen.width < 768) ? \"left\" : align;\n        indent = (screen.width < 768) ? \"0em\" : indent;\n        linebreak = (screen.width < 768) ? 'true' : linebreak;\n    }\n\n    var mathjaxscript = document.createElement('script');\n    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';\n    mathjaxscript.type = 'text/javascript';\n    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';\n\n    var configscript = document.createElement('script');\n    configscript.type = 'text/x-mathjax-config';\n    configscript[(window.opera ? \"innerHTML\" : \"text\")] =\n        \"MathJax.Hub.Config({\" +\n        \"    config: ['MMLorHTML.js'],\" +\n        \"    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } },\" +\n        \"    jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" +\n        \"    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" +\n        \"    displayAlign: '\"+ align +\"',\" +\n        \"    displayIndent: '\"+ indent +\"',\" +\n        \"    showMathMenu: true,\" +\n        \"    messageStyle: 'normal',\" +\n        \"    tex2jax: { \" +\n        \"        inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" +\n        \"        displayMath: [ ['$$','$$'] ],\" +\n        \"        processEscapes: true,\" +\n        \"        preview: 'TeX',\" +\n        \"    }, \" +\n        \"    'HTML-CSS': { \" +\n        \"        availableFonts: ['STIX', 'TeX'],\" +\n        \"        preferredFont: 'STIX',\" +\n        \"        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" +\n        \"        linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" +\n        \"    }, \" +\n        \"}); \" +\n        \"if ('default' !== 'default') {\" +\n            \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" +\n                \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" +\n                \"VARIANT['normal'].fonts.unshift('MathJax_default');\" +\n                \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" +\n                \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" +\n                \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" +\n            \"});\" +\n            \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" +\n                \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" +\n                \"VARIANT['normal'].fonts.unshift('MathJax_default');\" +\n                \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" +\n                \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" +\n                \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" +\n            \"});\" +\n        \"}\";\n\n    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);\n    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);\n}\n</script>",
  "category": [
    "",
    "",
    ""
  ]
}