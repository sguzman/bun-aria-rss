{
  "title": "Computations",
  "link": "",
  "updated": "2012-11-21T00:00:00+00:00",
  "id": "https://mrocklin.github.io/blog/work/2012/11/21/Computations",
  "content": "<p>How can we symbolically represent computations? In SymPy we normally represent expressions as trees.  Each node in the graph is an expression; it depends on some operation like <code class=\"language-plaintext highlighter-rouge\">Add</code> or <code class=\"language-plaintext highlighter-rouge\">Mul</code> and a sequence of arguments/children.</p>\n\n<p><img src=\"https://mrocklin.github.io/blog/images/add-mul-tree.png\" alt=\"\" /></p>\n\n<p>While trees are a convenient data structure they are also very restrictive. Consider the following operation</p>\n\n<p><img src=\"https://mrocklin.github.io/blog/images/min-max-dag.png\" alt=\"\" /></p>\n\n<p>This <code class=\"language-plaintext highlighter-rouge\">MinMax</code> operation takes two inputs variables, <code class=\"language-plaintext highlighter-rouge\">x</code>, and <code class=\"language-plaintext highlighter-rouge\">y</code>, and produces two outputs <code class=\"language-plaintext highlighter-rouge\">Min(x, y)</code>, <code class=\"language-plaintext highlighter-rouge\">Max(x, y)</code>.  Computationally you might prefer this over two separate trees because both outputs can be produced at once with a single comparison.  This also supports natural grouping of common sub-expressions.  If <code class=\"language-plaintext highlighter-rouge\">x</code> and <code class=\"language-plaintext highlighter-rouge\">y</code> were large trees we would not want two have copies of each in separate <code class=\"language-plaintext highlighter-rouge\">Min</code> and <code class=\"language-plaintext highlighter-rouge\">Max</code> trees.</p>\n\n<p><img src=\"https://mrocklin.github.io/blog/images/min-tree.png\" alt=\"\" />\n<img src=\"https://mrocklin.github.io/blog/images/max-tree.png\" alt=\"\" /></p>\n\n<p>Because the <code class=\"language-plaintext highlighter-rouge\">MinMax</code> operation has two outputs we can no longer represent its graph with a single tree, we need a more general data structure.  This graph can be described as a bipartite directed acyclic graph (BiDAG).  It is bipartite because there are two types of nodes, variables (circles) and operations [boxes].  It is directed and acyclic by the dependence of data (e.g. if <code class=\"language-plaintext highlighter-rouge\">Min(x, y)</code> depends on <code class=\"language-plaintext highlighter-rouge\">x</code> then <code class=\"language-plaintext highlighter-rouge\">x</code> can not depend on <code class=\"language-plaintext highlighter-rouge\">Min(x, y)</code>).</p>\n\n<p>A DAG is the next most restrictive graph subtype.  In some sense this is the smallest generalization we can make.</p>\n\n<h2 id=\"computation-type\">Computation Type</h2>\n\n<p>Enter the <code class=\"language-plaintext highlighter-rouge\">Computation</code> base type.  This is an interface that must provide tuples of <code class=\"language-plaintext highlighter-rouge\">inputs</code> and <code class=\"language-plaintext highlighter-rouge\">outputs</code> instead of the standard <code class=\"language-plaintext highlighter-rouge\">args</code> we use for trees.</p>\n\n<p>We also add a <code class=\"language-plaintext highlighter-rouge\">CompositeComputation</code> type which collects many computations together.  Consider the collection of the following computations.</p>\n\n<p><img src=\"https://mrocklin.github.io/blog/images/min-max-dag.png\" alt=\"\" />\n<img src=\"https://mrocklin.github.io/blog/images/op.png\" alt=\"\" /></p>\n\n<p>Note that <code class=\"language-plaintext highlighter-rouge\">A</code> produces <code class=\"language-plaintext highlighter-rouge\">x</code> which is used by <code class=\"language-plaintext highlighter-rouge\">MinMax</code>.  This computation has inputs (<code class=\"language-plaintext highlighter-rouge\">w</code>, <code class=\"language-plaintext highlighter-rouge\">y</code>) and outputs (<code class=\"language-plaintext highlighter-rouge\">Min(x, y)</code>, <code class=\"language-plaintext highlighter-rouge\">Max(x, y)</code>).  The data dependencies infer an ordering; the <code class=\"language-plaintext highlighter-rouge\">A</code> computation must occur before the <code class=\"language-plaintext highlighter-rouge\">MinMax</code> computation.</p>\n\n<h2 id=\"internal-representation\">Internal Representation</h2>\n\n<p>My current implementation of <code class=\"language-plaintext highlighter-rouge\">CompositeComputation</code> is represented internally as an immutable set of computations.  Inter-computation interactions are inferred as needed by their variables.  We provide methods to form an alternative dict-based data structure with fast access and traversal should performance become necessary.</p>\n\n<p>All variables are assumed immutable and unique.  The intention is that variables should be entirely defined by their mathematical meaning.  The expectation is that the variables are SymPy expressions.</p>\n\n<p>This approach has a focus on immutability and mathematical attributes rather than performance and computational attributes.  For example it is impossible to represent a <code class=\"language-plaintext highlighter-rouge\">Copy</code> operation within this framework because mathematical meanings of the input and output variable would be identical.  Similarily inplace operations are not checkable in this framework.</p>\n\n<h2 id=\"inplace\">Inplace</h2>\n\n<p>And yet copies and inplace operations are important parts of real computation.  We make an explicit separation between mathematics-based optimizations and infrastructure-based optimizations (like inplace).  We perform this transition by replacing each variable with a pair that contains a purely mathematical expression (left)  and a purely computational variable (right).</p>\n\n<p><img src=\"https://mrocklin.github.io/blog/images/min-max-dag-pure.png\" alt=\"\" /></p>\n\n<p>In the example above we see the <code class=\"language-plaintext highlighter-rouge\">MinMax</code> computation where the <code class=\"language-plaintext highlighter-rouge\">x</code> and <code class=\"language-plaintext highlighter-rouge\">y</code> expressions are stored in variables <code class=\"language-plaintext highlighter-rouge\">\"x\"</code> and <code class=\"language-plaintext highlighter-rouge\">\"y\"</code> and the outputs are stored in dummy variables <code class=\"language-plaintext highlighter-rouge\">\"_1\"</code> and <code class=\"language-plaintext highlighter-rouge\">\"_2\"</code>.  For performance reasons a computation may write the outputs back into the memory for the inputs as follows (note that the two outputs are stored in the same variables as the inputs.)</p>\n\n<p><img src=\"https://mrocklin.github.io/blog/images/min-max-dag-inplace.png\" alt=\"\" /></p>\n\n<p>Inplace computations provide higher performance at the cost of memory safety.  We must avoid situations like the following where the <code class=\"language-plaintext highlighter-rouge\">x</code> variable may be overwritten (for example by <code class=\"language-plaintext highlighter-rouge\">B</code>) before it is read (by <code class=\"language-plaintext highlighter-rouge\">C</code>).</p>\n\n<p><img src=\"https://mrocklin.github.io/blog/images/dangerous-inplace.png\" alt=\"\" /></p>\n\n<h2 id=\"motivation\">Motivation</h2>\n\n<p>I am working to translate matrix expressions (tree) into a computation (DAG) of BLAS/LAPACK operations.  I do this through setting up and matching mathematical patterns like the following</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>alpha*X*Y + beta*Z -&gt; GEMM(alpha, X, Y, beta, Z)\n</code></pre></div></div>\n\n<p>However the available operations (like <code class=\"language-plaintext highlighter-rouge\">GEMM</code>) are inplace by default.  These two goals of mathematical pattern matching and inplace computations are challenging to solve simultaneously for non-trivial expressions.  My solution has been to consider the mathematical pattern matching problem first and then switch to ‘inplace mode’ and resolve the inplace issues separately.</p>\n\n<h2 id=\"question\">Question</h2>\n\n<p>Should this be a part of SymPy?</p>"
}