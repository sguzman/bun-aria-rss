{
  "title": "Don't write command-line interfaces (generate them)",
  "description": "<p style=\"color: #666677\">\n(a friendly reminder that reading post before commenting is a great idea. \nSome people see this as an argument for GUI, but it's completely misleading)\n</p>\n\n<p>A favourite activity of fresh github-bers is writing CLI (command-line interfaces) for anything.</p>\n\n<p>Every programmer uses CLI <strong>(true)</strong>, so writing CLI makes you more professional <strong>(false)</strong>.</p>\n\n<p>CLIs are required in everyday maintenance, env/pipeline/db management, and checking this and that.\nIt is a glue to keep different subsystems together, but hardly CLI is a reliable programming interface.\nProgress in software engineering left bash calls far behind in terms of reliability and flexibility.</p>\n\n<h3 id=\"whats-wrong-with-writing-cli-as-an-interface\">What’s wrong with writing CLI as an ‘interface’?</h3>\n\n<ul>\n  <li>CLI support is an additional logic in your program that makes <strong>no real work</strong></li>\n  <li>While typically being dumb, CLI logic is frequently <strong>filled with <a href=\"https://github.com/search?q=bug+command+line&amp;type=Issues\">mistakes</a></strong>;\nthus it requires constant maintenance and an additional testing</li>\n  <li><strong>Error (exception) handling</strong> with CLI is very poor.\nAnother layer of (bad faulty) code is required to make it possible</li>\n  <li><strong>Scaling/extending</strong> is not as easy compared to programming language APIs \n(see example in the end)</li>\n  <li>CLIs are detached from essential code, which in most cases is a disadvantage.\n    <details>\n      <summary>more on this</summary>\n      <p>Forcing users to use CLI means: stay away from my code, you’d better not work with it.\n  Maybe that’s ok — but if users can code a bit (otherwise why do they use CLI?), \n  that’s not an optimal way — if something went wrong, \n  do you want to directly see the code+calls that failed or do you want to add \n  several minutes/hours walking thru command args parsing machinery someone else wrote? \n  <br />\n  While being questionable in small projects, a virtual fence becomes more and more obvious when parsing logic\n  (validation, transformation, routing)  grows.</p>\n    </details>\n  </li>\n</ul>\n\n<h3 id=\"writing-command-line-interfaces-the-right-way\">Writing command-line interfaces the right way</h3>\n\n<ul>\n  <li>write functions</li>\n  <li>leave CLI-fication to a special package</li>\n</ul>\n\n<h3 id=\"which-tool-to-use-for-writing-command-line-interfaces-in-python\">Which tool to use for writing command-line interfaces in Python?</h3>\n\n<p>Here are the options that you should consider …</p>\n\n<ul>\n  <li><a href=\"https://docs.python.org/3/library/argparse.html\">argparse</a> (or ancient optparse)</li>\n  <li><a href=\"https://click.palletsprojects.com/en/7.x/\">click</a></li>\n  <li><a href=\"http://docopt.org/\">docopt</a></li>\n  <li><a href=\"https://github.com/google/python-fire\">python-fire</a></li>\n</ul>\n\n<p>… <strong>deprecated</strong>. Yes, consider them deprecated.</p>\n\n<p>Prefer <a href=\"https://hugapi.github.io/hug/\">hug</a> and <a href=\"https://github.com/tiangolo/typer\">typer</a>.\nExample for the latter:</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">import</span> <span class=\"nn\">typer</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pathlib</span> <span class=\"kn\">import</span> <span class=\"n\">Path</span>\n\n<span class=\"n\">app</span> <span class=\"o\">=</span> <span class=\"n\">typer</span><span class=\"p\">.</span><span class=\"n\">Typer</span><span class=\"p\">()</span>\n\n<span class=\"o\">@</span><span class=\"n\">app</span><span class=\"p\">.</span><span class=\"n\">command</span><span class=\"p\">()</span>\n<span class=\"k\">def</span> <span class=\"nf\">find_dragon</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"n\">Path</span><span class=\"p\">,</span> <span class=\"n\">min_age_years</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">200</span><span class=\"p\">):</span>\n    <span class=\"o\">&lt;</span><span class=\"n\">implementation</span> <span class=\"n\">goes</span> <span class=\"n\">here</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">@</span><span class=\"n\">app</span><span class=\"p\">.</span><span class=\"n\">command</span><span class=\"p\">()</span>\n<span class=\"k\">def</span> <span class=\"nf\">feed_dragon</span><span class=\"p\">(</span><span class=\"n\">dragon_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">n_humans</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">3</span><span class=\"p\">):</span>\n    <span class=\"o\">&lt;</span><span class=\"n\">implementation</span> <span class=\"n\">goes</span> <span class=\"n\">here</span><span class=\"o\">&gt;</span>\n\n<span class=\"k\">if</span> <span class=\"n\">__name__</span> <span class=\"o\">==</span> <span class=\"s\">\"__main__\"</span><span class=\"p\">:</span>\n    <span class=\"n\">app</span><span class=\"p\">()</span>\n</code></pre></div></div>\n\n<p>Now it’s ready to be invoked from shell</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>python example.py find_dragon 'Drake' --path /on/my/planet\n</code></pre></div></div>\n<p>That’s it! Types are parsed, checked and converted. \nDefaults and description are picked from function itself. \nEven provides bash completions you can install. \nBest part is you wrote no code for that!</p>\n\n<h3 id=\"-i-need-to-invoke-my-code-from-bash-with-complex-parameterization\">— I need to invoke my code from bash with complex parameterization</h3>\n\n<p>Exact wording of this question may also include job schedulers, calls on remote machines \nand docker run/exec — common reasons that force people to write CLI.</p>\n\n<p>Previous recipe may not work in this case, you have two options:</p>\n\n<p><strong>Option A.</strong></p>\n\n<p>Read documentation for <em>deprecated</em> packages, \nwrite a ton of code for conversion, validation, testing and mocking.\nAdd documentation, make presentations about CLI logic and neat places of using bash, \nget promoted to Senior CLI architect, give talks and interviews. \nSome junior in your company discovers <em>option B</em> and ruins your career.</p>\n\n<p><strong>Option B</strong>.</p>\n\n<p>When there is much to configure, \ndon’t try to build a large parsing machinery to handle all cases, \njust <strong>use code</strong> to parameterize calls:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>python <span class=\"nt\">-c</span> <span class=\"s2\">\"\nfrom mymodule import set_dragon_feeding_schedule, Creatures, Date\nset_dragon_feeding_schedule(\n    feeding_times=['10:00', '14:00', '18:00'],\n    dishes={Creatures.Tiger: 2, Creatures.Human: 1},\n    start_day=Date('1020-03-01'),\n)\n\"</span>\n</code></pre></div></div>\n\n<p>Instead of</p>\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>python <span class=\"nt\">-m</span> mymodule <span class=\"se\">\\</span>\n    set_dragon_feeding_schedule <span class=\"se\">\\</span>\n    <span class=\"nt\">--feeding-times</span> <span class=\"o\">[</span><span class=\"s1\">'10:00'</span>,<span class=\"s1\">'14:00'</span>,<span class=\"s1\">'18:00'</span><span class=\"o\">]</span> <span class=\"c\"># hopefully this way it gets recognized \\</span>\n    <span class=\"c\"># how will you define parsing a dict with enum to integer mapping? </span>\n    <span class=\"nt\">--dishes</span><span class=\"o\">=</span>Creatures.Tiger:2 <span class=\"se\">\\</span>\n    <span class=\"nt\">--dishes</span><span class=\"o\">=</span>Creatures.Human:1 <span class=\"se\">\\</span>\n    <span class=\"nt\">--start-day</span><span class=\"o\">=</span>1020-03-21 <span class=\"c\"># BTW bash allows no comments in multiline calls</span>\n</code></pre></div></div>\n\n<ul>\n  <li>How many lines of code you need to cover parsing logic in previous example?\n    <ul>\n      <li>Try to be reasonable, not optimistic. Don’t forget documentation.</li>\n      <li>Add testing, mocking, … have you <em>ever</em> seen that part done properly for CLIs?</li>\n    </ul>\n  </li>\n  <li>Is there anything that you win after writing an explicit CLI parsing? Double quote maybe?</li>\n  <li>Exception handling — simple to add in one case, very tough in the other</li>\n</ul>\n\n<h3 id=\"-never-realized-that-cli-command-can-be-replaced-by-python-command\">— Never realized that CLI command can be replaced by python command</h3>\n\n<p>You’re welcome! This can save you weeks of time and sleepless nights.</p>\n\n<p>Here is definitive guide:</p>\n\n<ol>\n  <li>Don’t write yet-another-parser — python can parse all you need</li>\n  <li>Don’t reinvent representing lists, dicts, enums, objects, etc in text — every programming language has it already solved</li>\n  <li>Don’t create new <em>types</em> of interfaces — functions <em>are</em> interfaces</li>\n  <li>Don’t write parsing logic/validation — check parameters instead</li>\n</ol>\n\n<p>Focus on writing useful and friendly functional interface, not CLI.</p>\n\n<h3 id=\"-how-about-an-example-for-dealing-with-more-complex-parameterization\">— How about an example for dealing with more complex parameterization?</h3>\n\n<p>Sure! Here is an example from machine learning.</p>\n\n<p>Common headache is supporting multiple optimization algorithms (each having it’s own set of parameters)\nand allowing a number of architectures (each also having different parameters).</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>python <span class=\"nt\">-c</span> <span class=\"s2\">\"\nfrom yourpackage import ResidualNetwork, AdamOptimizer, train, activations\ntrain(\n    optimizer=AdamOptimizer(lr=0.0001, some_param=42, converge=True),\n    model=ResidualNetwork(n_layers_in_each_group=[3,4,5,6], act=activations.ReLU, n_classes=1234),\n    save_path='/research/my_experiment_number9999',\n)\n\"</span>\n</code></pre></div></div>\n\n<p>Compare this piece of clarity and versatility to a parsing nightmare happening in some popular packages.</p>\n\n<p>Why it becomes such a nightmare? That’s a great question!</p>\n\n<ul>\n  <li>parameters depend on each other in a non-trivial way.\nDifferent model → different parameters. Added a model — update CLI.</li>\n  <li>there should be a way to associate parameters with an entity they come from\n    <ul>\n      <li>is this parameter for an architecture? for an optimizer? for a dataset?</li>\n      <li>entities that appear naturally in programming interfaces are not in the style of bash calls</li>\n    </ul>\n  </li>\n  <li>at some point second model appears (hi GANs!), and possibly a second optimizer, \nseveral types of datasets… now you need to support all of that in CLI and avoid flag collisions\n    <ul>\n      <li>unlikely you want to frequently drop previous interface, so backward-compatibility will multiply your problems</li>\n    </ul>\n  </li>\n  <li>validation logic that is capable of handling all these scenarios would be huge, buggy \nand not helpful at all</li>\n</ul>\n\n<p><strong>CLIs don’t scale up well</strong>.<br />\nThey work well only when you can decompose things into simpler components ‘each doing one job’.\nBefore writing CLI, it is thus important to know what is the functionality \nyour project provides and how it may change in a year or two.\nIt is very easy to add CLI when the project is in it’s initial stage — \nbut as functionality grows, you’ll find it exponentially harder to fit all knobs into CLI.</p>\n\n<p>Other programming interfaces survive growth quite easily.</p>\n\n<h2 id=\"looking-forward\">Looking forward</h2>\n\n<p>In the bright future of programming there will be more natural bridges between different languages.\nWith growing capabilities for <a href=\"https://en.wikipedia.org/wiki/Reflection_(computer_programming)\">reflection</a>, \nit will be easier to invoke particular functions from other languages without intermediate bash calls.\n<a href=\"https://pyo3.rs/\">Python&lt;&gt;rust</a> is a good example of going in this direction.</p>\n\n<p>By not writing CLI logic and focusing on programming interface you make code future-proof.\n<a href=\"https://fastapi.tiangolo.com/\">Different</a> <a href=\"https://fastapi.tiangolo.com/alternatives/\">utilities</a> already can convert functions to REST API \n(we may later use some other network APIs like gRCP, and you’ll be able to add it with a couple of lines).\nMore to come, maybe we should expect utilities to auto-wrap your functions for calling from other languages/hosts/universes.</p>\n\n<p>Code should be designed to be used by other code first.\nConvenience ‘temporary’ command-line utilities sooner or later become part of bigger automated pipelines \nif no other API proposed.</p>\n\n<h2 id=\"tldr\">TL;DR</h2>\n\n<ul>\n  <li>simple CLIs should be auto-generated today, don’t write it yourself\n    <ul>\n      <li>other types of APIs can be auto-generated as well</li>\n    </ul>\n  </li>\n  <li>complex CLIs are a problem and think twice (better, 5 times) before trying to replace programming API with CLI\n    <ul>\n      <li>convenient command-line calls are available without writing a single line of CLI code</li>\n    </ul>\n  </li>\n</ul>\n\n<p><br /></p>\n\n<p><br /></p>\n\n<details>\n  <summary>\n<span style=\"font-size: 1.5em;\"> Additional comments </span>\n</summary>\n  <ul>\n    <li>I use python as an example because 1) need to show some code 2) it is popular 3) I know it well enough. <br />\nHowever, the points made should be valid for all modern languages (C++ is not a modern language just in case).</li>\n  </ul>\n</details>\n\n<details>\n  <summary>\n<span style=\"font-size: 1.5em;\"> Possible objections </span> \n</summary>\n  <ul>\n    <li>CLI allows abstracting out from implementation\n      <ul>\n        <li>Exposed functions can be detached from an actual implementation</li>\n      </ul>\n    </li>\n    <li>User may not know programming language I use\n      <ul>\n        <li>Unlikely import and a function call can be misleading. By hiding details you leave user clueless in case something doesn’t work</li>\n        <li>Actual choice is whether user should learn a bit of your language or yet-another-CLI system. Hard to find argument for the latter</li>\n        <li>If your tool requires detailed configuration, \nyou shouldn’t be afraid to say: you need to write several lines of code, here is an example</li>\n      </ul>\n    </li>\n    <li>My application heavily uses bash/shell features: pipes, process substitutions and filename expansions\n      <ul>\n        <li>In this case when you want to keep using and supporting CLI</li>\n      </ul>\n    </li>\n  </ul>\n</details>\n\n<details>\n  <summary>\n<span style=\"font-size: 1.5em;\"> Comments on packages </span>\n</summary>\n\n  <p><strong>What’s wrong with <code class=\"language-plaintext highlighter-rouge\">python-fire</code>?</strong></p>\n\n  <p>While it builds CLI on the top of exposing functions/methods,\n<code class=\"language-plaintext highlighter-rouge\">fire</code> ignores annotations and tries to guess types based on input.</p>\n\n  <p>An example from an official documentation to confirm:</p>\n  <div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nv\">$ </span>python example.py 10\nint\n<span class=\"nv\">$ </span>python example.py <span class=\"s2\">\"10\"</span>\nint\n<span class=\"nv\">$ </span>python example.py <span class=\"s1\">'\"10\"'</span>\nstr\n</code></pre></div>  </div>\n  <p>So 1) no types guaranteed 2) convolved logic 3) to make sure argument is not converted to int,\nwrap in both single and double quotes. \nNow wrap it in a bash call (e.g. during building docker).\nHave fun with escaping quotes for every string argument.</p>\n\n  <p><strong><code class=\"language-plaintext highlighter-rouge\">Hug</code> has a poor support for CLIs (as of now)</strong></p>\n\n  <p>Be warned, it ignores flag names. \nThough it has right direction of thought and directly supports <code class=\"language-plaintext highlighter-rouge\">marshmallow</code> types.\nBut in the meantime (Oct 2020) <code class=\"language-plaintext highlighter-rouge\">typer</code> is a safer choice.</p>\n\n  <p>Interface package of a dream is not released yet — it should support both CLI and web APIs and include some elements from python-fire.\nHowever, this should not stop you, as switches between these packages is almost painless as long as you write no custom logic.</p>\n\n</details>\n\n<details>\n  <summary>\n<span style=\"font-size: 1.5em;\"> Acknowledgements </span>\n</summary>\n  <p>Thanks to <a href=\"https://github.com/tlikhomanenko\">Tatiana</a> for proof-reading an initial version of this post.</p>\n</details>",
  "pubDate": "Thu, 01 Oct 2020 12:00:00 +0000",
  "link": "https://arogozhnikov.github.io/2020/10/01/dont-write-cli.html",
  "guid": "https://arogozhnikov.github.io/2020/10/01/dont-write-cli.html",
  "category": [
    "Programming",
    "Python",
    "Command-line interfaces"
  ]
}