{
  "title": "Feature Selection Methods and How to Choose Them",
  "link": "https://neptune.ai/blog/feature-selection-methods",
  "dc:creator": "Michał Oleszak",
  "pubDate": "Fri, 09 Sep 2022 09:23:07 +0000",
  "category": [
    "ML Model Development",
    "mlops"
  ],
  "guid": "https://neptune.ai/?p=71265",
  "description": "<p>Have you ever found yourself sitting in front of the screen wondering what kind of features will help your machine learning model learn its task best? I bet you have. Data preparation tends to consume vast amounts of data scientists’ and machine learning engineers’ time and energy, and making the data ready to be fed [&#8230;]</p>\n<p>The post <a rel=\"nofollow\" href=\"https://neptune.ai/blog/feature-selection-methods\">Feature Selection Methods and How to Choose Them</a> appeared first on <a rel=\"nofollow\" href=\"https://neptune.ai\">neptune.ai</a>.</p>\n",
  "content:encoded": "\n<p>Have you ever found yourself sitting in front of the screen wondering what kind of features will help your machine learning model learn its task best? I bet you have. Data preparation tends to consume vast amounts of data scientists’ and machine learning engineers’ time and energy, and making the data ready to be fed to the learning algorithms is no small feat.&nbsp;</p>\n\n\n\n<p>One of the crucial steps in the data preparation pipeline is <strong>feature selection</strong>. You might know the popular adage: garbage in, garbage out. What you feed your models with is at least as important as the models themselves, if not more so.</p>\n\n\n\n<p>In this article, we will:</p>\n\n\n<div class=\"custom-point-list\">\n<ul><li>look at the place of feature selection among other feature-related tasks in the data preparation pipeline </li><li>and discuss the multiple reasons why it is so crucial for any machine learning project’s success. </li><li>Next, we will go over different approaches to feature selection and discuss some tricks and tips to improve their results. </li><li>Then, we will take a glimpse behind the hood of Boruta, the state-of-the-art feature selection algorithm, to check out a clever way to combine different feature selection methods</li><li>And we&#8217;ll look into how feature selection is leveraged in the industry. </li></ul>\n</div>\n\n\n<p>Let’s dive in!</p>\n\n\n\n<h2>What is feature selection, and what is it not?</h2>\n\n\n\n<p>Let’s kick off by defining our object of interest.&nbsp;</p>\n\n\n\n<p>What is feature selection? In a nutshell, it is the process of selecting the subset of features to be used for training a machine learning model.&nbsp;</p>\n\n\n\n<p>This is what feature selection is, but it is equally important to understand what feature selection is not – it is neither feature extraction/feature engineering nor it is dimensionality reduction.</p>\n\n\n\n<p>Feature extraction and feature engineering are two terms describing the same process of creating new features from the existing ones based on domain knowledge. This yields more features than were originally there, and it should be performed before feature selection. First, we can do feature extraction to come up with many potentially useful features, and then we can perform feature selection in order to pick the best subset that will indeed improve the model’s performance.</p>\n\n\n\n<p><a href=\"/blog/dimensionality-reduction\" target=\"_blank\" rel=\"noreferrer noopener\">Dimensionality reduction</a> is yet another concept. It is somewhat similar to feature selection as both aim at reducing the number of features. However, they differ significantly in how they achieve this goal. While feature selection chooses a subset of original features to keep and discards others, dimensionality reduction techniques create projections of original features onto a fewer-dimensional space, thus creating a completely new set of features. Dimensionality reduction, if desired, should be run after feature selection, but in practice, it is either one or the other.</p>\n\n\n\n<p>Now we know what feature selection is and how it corresponds to other feature-related data preparation tasks. But why do we even need it?</p>\n\n\n\n<h2>7 reasons why we need feature selection</h2>\n\n\n\n<p>A popular claim is that modern machine learning techniques do well without feature selection. After all, a model should be able to learn that particular features are useless, and it should focus on the others, right?&nbsp;</p>\n\n\n\n<p>Well, this reasoning makes sense to some extent. Linear models could, in theory, assign a weight of zero to useless features, and tree-based models should learn quickly not to make splits on them. In practice, however, many things can go wrong with training when the inputs are irrelevant or redundant &#8211; more on these two terms later. On top of this, there are many other reasons why simply dumping all the available features into the model might not be a good idea. Let’s look at the seven most prominent ones.</p>\n\n\n\n<p><strong>1. Irrelevant and redundant features</strong></p>\n\n\n\n<p>Some features might be irrelevant to the problem at hand. This means they have no relation with the target variable and are completely unrelated to the task the model is designed to solve. Discarding irrelevant features will prevent the model from picking up on spurious correlations it might carry, thus fending off overfitting.</p>\n\n\n\n<p>Redundant features are a different animal, though. Redundancy implies that two or more features share the same information, and all but one can be safely discarded without information loss. Note that an important feature can also be redundant in the presence of another relevant feature. Redundant features should be dropped, as they might pose many problems during training, such as multicollinearity in linear models.</p>\n\n\n\n<p><strong>2. Curse of dimensionality</strong></p>\n\n\n\n<p>Feature selection techniques are especially indispensable in scenarios with many features but few training examples. Such cases suffer from what is known as the curse of dimensionality: in a very high-dimensional space, each training example is so far from all the other examples that the model cannot learn any useful patterns. The solution is to decrease the dimensionality of the features space, for instance, via feature selection.</p>\n\n\n\n<p><strong>3. Training time</strong></p>\n\n\n\n<p>The more features, the more training time. The specifics of this trade-off depend on the particular learning algorithm being used, but in situations where retraining needs to happen in real-time, one might need to limit oneself to a couple of best features.</p>\n\n\n\n<p><strong>4. Deployment effort</strong></p>\n\n\n\n<p>The more features, the more complex the machine learning system becomes in production. This poses multiple risks, including but not limited to high maintenance effort, <a href=\"https://towardsdatascience.com/8-hazards-menacing-machine-learning-systems-in-production-5c470baa0163\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">entanglement, undeclared consumers, or correction cascades</a>.</p>\n\n\n\n<p><strong>5. Interpretability</strong></p>\n\n\n\n<p>With too many features, we lose the <a href=\"/blog/explainability-auditability-ml-definitions-techniques-tools\" target=\"_blank\" rel=\"noreferrer noopener\">explainability of the model</a>. While not always the primary modeling goal, interpreting and explaining the model’s results are often important and, in some regulated domains, might even constitute a legal requirement. </p>\n\n\n\n<p><strong>6. Occam’s Razor</strong></p>\n\n\n\n<p>According to this so-called law of parsimony, simpler models should be preferred over the more complex ones as long as their performance is the same. This also has to do with the machine learning engineer’s nemesis, overfitting. Less complex models are less likely to overfit the data.</p>\n\n\n\n<p><strong>7. Data-model compatibility</strong></p>\n\n\n\n<p>Finally, there is the issue of data-model compatibility. While, in principle, the approach should be data-first, which means collecting and preparing high-quality data and then choosing a model which works well on this data, real life may have it the other way around.&nbsp;</p>\n\n\n\n<p>You might be trying to reproduce a particular research paper, or your boss might have suggested using a particular model. In this model-first approach, you might be forced to select features that are compatible with the model you set out to train. For instance, many models don’t work with missing values in the data. Unless you <a href=\"https://towardsdatascience.com/handling-missing-data-5be11eddbdd\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">know your imputation methods well</a>, you might need to drop the incomplete features.</p>\n\n\n\n<h2>Different approaches to feature selection</h2>\n\n\n\n<p>All the different approaches to feature selection can be grouped into four families of methods, each coming with its pros and cons. There are unsupervised and supervised methods. The latter can be further divided into the wrapper, filter, and embedded methods. Let’s discuss them one by one.</p>\n\n\n<div class=\"wp-block-image\">\n<figure class=\"aligncenter size-large is-resized\"><img data-attachment-id=\"71268\" data-permalink=\"https://neptune.ai/feature-selection-methods-1\" data-orig-file=\"https://i0.wp.com/neptune.ai/wp-content/uploads/feature-selection-methods-1.png?fit=1999%2C1176&ssl=1\" data-orig-size=\"1999,1176\" data-comments-opened=\"0\" data-image-meta=\"{\"aperture\":\"0\",\"credit\":\"\",\"camera\":\"\",\"caption\":\"\",\"created_timestamp\":\"0\",\"copyright\":\"\",\"focal_length\":\"0\",\"iso\":\"0\",\"shutter_speed\":\"0\",\"title\":\"\",\"orientation\":\"0\"}\" data-image-title=\"feature-selection-methods-1\" data-image-description=\"\" data-image-caption=\"\" data-medium-file=\"https://i0.wp.com/neptune.ai/wp-content/uploads/feature-selection-methods-1.png?fit=300%2C176&ssl=1\" data-large-file=\"https://i0.wp.com/neptune.ai/wp-content/uploads/feature-selection-methods-1.png?fit=1024%2C602&ssl=1\" decoding=\"async\" src=\"https://i0.wp.com/neptune.ai/wp-content/uploads/feature-selection-methods-1.png?resize=767%2C452&#038;ssl=1\" alt=\"Different approaches to feature selection\" class=\"wp-image-71268\" width=\"767\" height=\"452\" data-recalc-dims=\"1\" /><figcaption><em>Feature selection methods | Source: author </em></figcaption></figure></div>\n\n\n<h3>Unsupervised feature selection methods</h3>\n\n\n\n<p>Just like unsupervised learning is the type of learning that looks for patterns in unlabeled data, similarly, unsupervised feature selection methods are such methods that do not make use of any labels. In other words, they don’t need access to the target variable of the machine learning model.&nbsp;</p>\n\n\n\n<p>How can we claim a feature to be unimportant for the model without analyzing its relation to the model’s target, you might ask. Well, in some cases, this is possible. We might want to discard the features with:</p>\n\n\n<div class=\"custom-point-list\">\n<ul><li>Zero or near-zero variance. Features that are (almost) constant provide little information to learn from and thus are irrelevant.</li><li>Many missing values. While dropping incomplete features <a href=\"https://towardsdatascience.com/handling-missing-data-5be11eddbdd\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">is not the prefer</a>red way to handle missing data, it is often a good start, and if too many entries are missing, it might be the only sensible thing to do since such features are likely inconsequential.</li><li>High multicollinearity; multicollinearity means a strong correlation between different features, which might signal redundancy issues.</li></ul>\n</div>\n\n\n<h4>Unsupervised methods in practice</h4>\n\n\n\n<p>Let’s now discuss the practical implementation of unsupervised feature selection methods. Just like most other machine learning tasks, feature selection is served very well by the scikit-learn package, and in particular by its `sklearn.feature_selection` module. However, in some cases, one needs to reach out to other places. Here, as well as for the remainder of the article, let’s denote an array or data frame by `X` with all potential features as columns and observation in rows and the targets vector by `y`.</p>\n\n\n<div class=\"custom-point-list\">\n<ul><li>Th<em>e </em>`sklearn.feature_selection.VarianceThreshold` transformer will by default remove all zero-variance features. We can also pass a threshold as an argument to make it remove features whose variance is lower than the threshold.</li></ul>\n</div>\n\n\n<pre class=\"hljs\" style=\"display: block; overflow-x: auto; padding: 0.5em; color: rgb(51, 51, 51); background: rgb(248, 248, 248);\"><span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">from</span> sklearn.feature_selection <span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">import</span> VarianceThreshold\n\n\nsel = VarianceThreshold(threshold=<span class=\"hljs-number\" style=\"color: teal;\">0.05</span>)\nX_selection = sel.fit_transform(X)\n</pre>\n\n\n<div class=\"custom-point-list\">\n<ul><li>In order to drop the columns with missing values, pandas’ `.dropna(axis=1)` method can be used on the data frame.</li></ul>\n</div>\n\n\n<pre class=\"hljs\" style=\"display: block; overflow-x: auto; padding: 0.5em; color: rgb(51, 51, 51); background: rgb(248, 248, 248);\">X_selection = X.dropna(axis=<span class=\"hljs-number\" style=\"color: teal;\">1</span>)</pre>\n\n\n<div class=\"custom-point-list\">\n<ul><li>To remove features with high multicollinearity, we first need to measure it. A popular multicollinearity measure is the Variance Inflation Factor or VIF. It is implemented in the statsmodels package.</li></ul>\n</div>\n\n\n<pre class=\"hljs\" style=\"display: block; overflow-x: auto; padding: 0.5em; color: rgb(51, 51, 51); background: rgb(248, 248, 248);\"><span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">from</span> statsmodels.stats.outliers_influence <span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">import</span> variance_inflation_factor\n\n\nvif_scores = [variance_inflation_factor(X.values, feature)<span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">for</span> feature <span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">in</span> range(len(X.columns))]\n</pre>\n\n\n\n<p>By convention, columns with a VIF larger than 10 are considered as suffering from multicollinearity, but another threshold may be chosen if it seems more reasonable.</p>\n\n\n\n<h3>Wrapper feature selection methods</h3>\n\n\n\n<p>Wrapper methods refer to a family of supervised feature selection methods which uses a model to score different subsets of features to finally select the best one. Each new subset is used to train a model whose performance is then evaluated on a hold-out set. The features subset which yields the best model performance is selected. A major advantage of wrapper methods is the fact that they tend to provide the best-performing feature set for the particular chosen type of model.&nbsp;</p>\n\n\n\n<p>At the same time, however, it has a limitation. Wrapper methods are likely to overfit to the model type, and the feature subsets they produce might not generalize should one want to try them with a different model.</p>\n\n\n\n<p>Another significant disadvantage of wrapper methods is their large computational needs. They require training a large number of models, which might require some time and computing power.&nbsp;</p>\n\n\n\n<p>Popular wrapper methods include:</p>\n\n\n<div class=\"custom-point-list\">\n<ul><li><strong>Backward selection</strong>, in which we start with a full model comprising all available features. In subsequent iterations, we remove one feature at a time, always the one that yields the largest gain in a model performance metric, until we reach the desired number of features.</li><li><strong>Forward selection</strong>, which works in the opposite direction: we start from a null model with zero features and add them greedily one at a time to maximize the model’s performance.</li><li><strong>Recursive Feature Elimination</strong>, or RFE, which is similar in spirit to backward selection. It also starts with a full model and iteratively eliminates the features one by one. The difference is in the way the features to discard are chosen. Instead of relying on a model performance metric from a hold-out set, RFE makes its decision based on feature importance extracted from the model. This could be feature weights in linear models, impurity decrease in tree-based models, or permutation importance (which is applicable to any model type).</li></ul>\n</div>\n\n\n<h4>Wrapper methods in practice</h4>\n\n\n\n<p>When it comes to wrapper methods, scikit-learn has got us covered:</p>\n\n\n<div class=\"custom-point-list\">\n<ul><li>Backward and forward feature selection can be implemented with the SequentialFeatureSelector transformer. For instance, in order to use the k-Nearest-Neighbor classifier as the scoring model in forward selection, we could use the following code snippet:</li></ul>\n</div>\n\n\n<pre class=\"hljs\" style=\"display: block; overflow-x: auto; padding: 0.5em; color: rgb(51, 51, 51); background: rgb(248, 248, 248);\"><span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">from</span> sklearn.feature_selection <span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">import</span> SequentialFeatureSelector\n\nknn = KNeighborsClassifier(n_neighbors=<span class=\"hljs-number\" style=\"color: teal;\">3</span>)\nsfs = SequentialFeatureSelector(knn, n_features_to_select=<span class=\"hljs-number\" style=\"color: teal;\">3</span>, direction=”forward”)\nsfs.fit(X, y)\nX_selection = sfs.transform(X)\n</pre>\n\n\n<div class=\"custom-point-list\">\n<ul><li>Recursive Feature Elimination is implemented in a very similar fashion. Here is a snippet implementing RFE based on feature importance from a Support Vector Classifier.</li></ul>\n</div>\n\n\n<pre class=\"hljs\" style=\"display: block; overflow-x: auto; padding: 0.5em; color: rgb(51, 51, 51); background: rgb(248, 248, 248);\"><span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">from</span> sklearn.feature_selection <span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">import</span> RFE\n\nsvc = SVC(kernel=<span class=\"hljs-string\" style=\"color: rgb(221, 17, 68);\">\"linear\"</span>)\nrfe = RFE(svc, n_features_to_select=<span class=\"hljs-number\" style=\"color: teal;\">3</span>)\nrfe.fit(X, y)\nX_selection = rfe.transform(X)\n</pre>\n\n\n\n<h3>Filter feature selection methods</h3>\n\n\n\n<p>Another member of the supervised family is filter methods. They can be thought of as a simpler and faster alternative to wrappers. In order to evaluate the usefulness of each feature, they simply analyze its statistical relation with the model’s target, using measures such as correlation or mutual information as a proxy for the model performance metric.</p>\n\n\n\n<p>Not only filter methods faster than wrappers, but they are also more general since they are model-agnostic; they won’t overfit to any particular algorithm. They are also pretty easy to interpret: a feature is discarded if it has no statistical relationship to the target.</p>\n\n\n\n<p>On the other hand, however, filter methods have one major drawback. They look at each feature in isolation, evaluating its relation to the target. This makes them prone to discarding useful features that are weak predictors of the target on their own but add a lot of value to the model when combined with other features.</p>\n\n\n\n<h4>Filter methods in practice</h4>\n\n\n\n<p>Let’s now take a look at implementing various filter methods. These will need some more glue code to implement. First, we need to compute the desired correlation measure between each feature and the target. Then, we would sort all features according to the results and keep the desired number (top-K or top-30%) of the ones with the strongest correlation. Luckily, scikit-learn provides some utilities to help in this endeavour.</p>\n\n\n<div class=\"custom-point-list\">\n<ul><li>To keep the top 2 features with the strongest Pearson correlation with the target, we can run:</li></ul>\n</div>\n\n\n<pre class=\"hljs\" style=\"display: block; overflow-x: auto; padding: 0.5em; color: rgb(51, 51, 51); background: rgb(248, 248, 248);\"><span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">from</span> sklearn.feature_selection <span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">import</span> r_regression, SelectKBest\n\nX_selection = SelectKBest(r_regression, k=<span class=\"hljs-number\" style=\"color: teal;\">2</span>).fit_transform(X, y)</pre>\n\n\n<div class=\"custom-point-list\">\n<ul><li>Similarly, to keep the top 30% of features, we would run:</li></ul>\n</div>\n\n\n<pre class=\"hljs\" style=\"display: block; overflow-x: auto; padding: 0.5em; color: rgb(51, 51, 51); background: rgb(248, 248, 248);\">\t<span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">from</span> sklearn.feature_selection <span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">import</span> r_regression, SelectPercentile\n\n\tX_selection = SelectPercentile(r_regression, percentile=<span class=\"hljs-number\" style=\"color: teal;\">30</span>).fit_transform(X, y)</pre>\n\n\n\n<p>The `SelectKBest` and `SelectPercentile` methods will also work with custom or non-scikit-learn correlation measures, as long as they return a vector of length equal to the number of features, with a number for each feature denoting the strength of its association with the target. Let’s now take a look at how to calculate all the different correlation measures out there (we will discuss what they mean and when to choose which later).</p>\n\n\n<div class=\"custom-point-list\">\n<ul><li>Spearman’s Rho, Kendall Tau, and point-biserial correlation are all available in the scipy package. This is how to get their values for each feature in X.</li></ul>\n</div>\n\n\n<pre class=\"hljs\" style=\"display: block; overflow-x: auto; padding: 0.5em; color: rgb(51, 51, 51); background: rgb(248, 248, 248);\"><span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">from</span> scipy <span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">import</span> stats\n\nrho_corr = [stats.spearmanr(X[:, f], y).correlation <span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">for</span> f <span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">in</span> range(X.shape[<span class=\"hljs-number\" style=\"color: teal;\">1</span>])]\n\ntau_corr = [stats.kendalltau(X[:, f], y).correlation <span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">for</span> f <span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">in</span> range(X.shape[<span class=\"hljs-number\" style=\"color: teal;\">1</span>])]\n\npbs_corr = [stats.pointbiserialr(X[:, f], y).correlation <span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">for</span> f <span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">in</span> range(X.shape[<span class=\"hljs-number\" style=\"color: teal;\">1</span>])]\n</pre>\n\n\n<div class=\"custom-point-list\">\n<ul><li>Chi-Squared, Mutual Information, and ANOVA F-score are all in scikit-learn. Note that mutual information has a separate implementation, depending on whether the target is nominal or not.</li></ul>\n</div>\n\n\n<pre class=\"hljs\" style=\"display: block; overflow-x: auto; padding: 0.5em; color: rgb(51, 51, 51); background: rgb(248, 248, 248);\"><span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">from</span> sklearn.feature_selection <span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">import</span> chi2\n<span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">from</span> sklearn.feature_selection <span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">import</span> mutual_info_regression\n<span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">from</span> sklearn.feature_selection <span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">import</span> mutual_info_classif\n<span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">from</span> sklearn.feature_selection <span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">import</span> f_classif\n\nchi2_corr = chi2(X, y)[<span class=\"hljs-number\" style=\"color: teal;\">0</span>]\nf_corr = f_classif(X, y)[<span class=\"hljs-number\" style=\"color: teal;\">0</span>]\nmi_reg_corr = mutual_info_regression(X, y)\nmi_class_corr = mutual_info_classif(X, y)\n</pre>\n\n\n<div class=\"custom-point-list\">\n<ul><li>Cramer’s V can be obtained from a recent scipy version (1.7.0 or higher).</li></ul>\n</div>\n\n\n<pre class=\"hljs\" style=\"display: block; overflow-x: auto; padding: 0.5em; color: rgb(51, 51, 51); background: rgb(248, 248, 248);\"><span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">from</span> scipy.stats.contingency <span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">import</span> association\n\nv_corr = [association(np.hstack([X[:, f].reshape(<span class=\"hljs-number\" style=\"color: teal;\">-1</span>, <span class=\"hljs-number\" style=\"color: teal;\">1</span>), y.reshape(<span class=\"hljs-number\" style=\"color: teal;\">-1</span>, <span class=\"hljs-number\" style=\"color: teal;\">1</span>)]), method=<span class=\"hljs-string\" style=\"color: rgb(221, 17, 68);\">\"cramer\"</span>) <span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">for</span> f <span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">in</span> range(X.shape[<span class=\"hljs-number\" style=\"color: teal;\">1</span>])]\n</pre>\n\n\n\n<h3>Embedded feature selection methods</h3>\n\n\n\n<p>The final approach to feature selection we will discuss is to embed it into the learning algorithm itself. The idea is to combine the best of both worlds: speed of the filters, while getting the best subset for the particular model just like from a wrapper.</p>\n\n\n\n<h4>Embedded methods in practice</h4>\n\n\n\n<p>The flagship example is the LASSO regression. It is basically just regularized linear regression, in which feature weights are shrunk towards zero in the loss function. As a result, many features end up with weights of zero, meaning they are discarded from the model, while the rest with non-zero weights are included.</p>\n\n\n\n<p>The problem with embedded methods is that there are not that many algorithms out there with feature selection built-in. Another example next to LASSO comes from computer vision: <a href=\"https://towardsdatascience.com/autoencoders-from-vanilla-to-variational-6f5bb5537e4a\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">auto-encoders</a> with a bottleneck layer force the network to disregard some of the least useful features of the image and focus on the most important ones. Other than that, there aren’t many useful examples.</p>\n\n\n\n<h2>Filter feature selection methods: useful tricks & tips</h2>\n\n\n\n<p>As we have seen, wrapper methods are slow, computationally heavy, and model-specific, and there are not many embedded methods. As a result, filters are often the go-to family of feature selection methods.&nbsp;</p>\n\n\n\n<p>At the same time, they require the most expertise and attention to detail. While embedded methods work out of the box and wrappers are fairly simple to implement (especially when one just calls scikit-learn functions), filters ask for a pinch of statistical sophistication. Let us now turn our attention to filter methods and discuss them in more detail.</p>\n\n\n\n<p>Filter methods need to evaluate the statistical relationship between each feature and the target. As simple as it may sound, there’s more to it than meets the eye. There are many statistical methods to measure the relationship between two variables. To know which one to choose in a particular case, we need to think back to our first STATS101 class and brush up on <a href=\"https://towardsdatascience.com/data-measurement-levels-dfa9a4564176\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">data measurement levels</a>.</p>\n\n\n\n<h3>Data measurement levels</h3>\n\n\n\n<p>In a nutshell, a variable’s measurement level describes the true meaning of the data and the types of mathematical operations that make sense for these data. There are four measurement levels: nominal, ordinal, interval, and ratio.</p>\n\n\n<div class=\"wp-block-image\">\n<figure class=\"aligncenter size-full is-resized\"><img data-attachment-id=\"71269\" data-permalink=\"https://neptune.ai/feature-selection-methods-2\" data-orig-file=\"https://i0.wp.com/neptune.ai/wp-content/uploads/feature-selection-methods-2.png?fit=610%2C198&ssl=1\" data-orig-size=\"610,198\" data-comments-opened=\"0\" data-image-meta=\"{\"aperture\":\"0\",\"credit\":\"\",\"camera\":\"\",\"caption\":\"\",\"created_timestamp\":\"0\",\"copyright\":\"\",\"focal_length\":\"0\",\"iso\":\"0\",\"shutter_speed\":\"0\",\"title\":\"\",\"orientation\":\"0\"}\" data-image-title=\"feature-selection-methods-2\" data-image-description=\"\" data-image-caption=\"\" data-medium-file=\"https://i0.wp.com/neptune.ai/wp-content/uploads/feature-selection-methods-2.png?fit=300%2C97&ssl=1\" data-large-file=\"https://i0.wp.com/neptune.ai/wp-content/uploads/feature-selection-methods-2.png?fit=610%2C198&ssl=1\" decoding=\"async\" src=\"https://i0.wp.com/neptune.ai/wp-content/uploads/feature-selection-methods-2.png?resize=693%2C225&#038;ssl=1\" alt=\"Tabel with data measurement levels\" class=\"wp-image-71269\" width=\"693\" height=\"225\" data-recalc-dims=\"1\" /><figcaption><em>Data measurement levels | <a href=\"https://towardsdatascience.com/data-measurement-levels-dfa9a4564176\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">Source</a></em></figcaption></figure></div>\n\n<div class=\"custom-point-list\">\n<ul><li>Nominal features, such as color (“red”, “green” or “blue”) have no ordering between the values; they simply group<em> </em>observations based on them.&nbsp;</li></ul>\n</div>\n\n<div class=\"custom-point-list\">\n<ul><li>Ordinal features, such as education level (“primary”, “secondary”, “tertiary”) denote order, but not the differences between particular levels (we cannot say that the difference between “primary” and “secondary” is the same as the one between “secondary” and “tertiary”).&nbsp;</li></ul>\n</div>\n\n<div class=\"custom-point-list\">\n<ul><li>Interval features, such as temperature in degrees Celsius, keep the intervals equal (the difference between 25 and 20 degrees is the same as between 30 and 25).&nbsp;</li></ul>\n</div>\n\n<div class=\"custom-point-list\">\n<ul><li>Finally, ratio features, such as price in USD, are characterized by a meaningful zero, which allows us to calculate ratios between two data points: we can say that $4 is twice as much as $2.</li></ul>\n</div>\n\n\n<p>In order to choose the right statistical tool to measure the relation between two variables, we need to think about their measurement levels.</p>\n\n\n\n<h3>Measuring correlations for various data types</h3>\n\n\n\n<p>When the two variables we compare, i.e., the feature and the target, are both either interval or ratio, we are allowed to use the most popular correlation measure out there: the <strong>Pearson correlation</strong>, also known as <strong>Pearson’s r</strong>.&nbsp;</p>\n\n\n\n<p>This is great, but Pearson correlation comes with two drawbacks: it assumes both variables are normally distributed, and it only measures the linear correlation between them. When the correlation is non-linear, Pearson’s r won’t detect it, even if it’s really strong.&nbsp;</p>\n\n\n\n<p>You might have heard about the <em>Datasaurus</em> dataset compiled by Alberto Cairo. It consists of 13 pairs of variables, each with the same very weak Pearson correlation of -0.06. As it quickly becomes obvious once we plot them, the pairs are actually correlated pretty strongly, albeit in a non-linear way.</p>\n\n\n<div class=\"wp-block-image\">\n<figure class=\"aligncenter size-full is-resized\"><img data-attachment-id=\"71270\" data-permalink=\"https://neptune.ai/feature-selection-methods-3\" data-orig-file=\"https://i0.wp.com/neptune.ai/wp-content/uploads/feature-selection-methods-3.png?fit=597%2C426&ssl=1\" data-orig-size=\"597,426\" data-comments-opened=\"0\" data-image-meta=\"{\"aperture\":\"0\",\"credit\":\"\",\"camera\":\"\",\"caption\":\"\",\"created_timestamp\":\"0\",\"copyright\":\"\",\"focal_length\":\"0\",\"iso\":\"0\",\"shutter_speed\":\"0\",\"title\":\"\",\"orientation\":\"0\"}\" data-image-title=\"feature-selection-methods-3\" data-image-description=\"\" data-image-caption=\"\" data-medium-file=\"https://i0.wp.com/neptune.ai/wp-content/uploads/feature-selection-methods-3.png?fit=300%2C214&ssl=1\" data-large-file=\"https://i0.wp.com/neptune.ai/wp-content/uploads/feature-selection-methods-3.png?fit=597%2C426&ssl=1\" decoding=\"async\" src=\"https://i0.wp.com/neptune.ai/wp-content/uploads/feature-selection-methods-3.png?resize=597%2C426&#038;ssl=1\" alt=\"The Datasaurus dataset\" class=\"wp-image-71270\" width=\"597\" height=\"426\" data-recalc-dims=\"1\" /><figcaption><em>The Datasaurus dataset by Alberto Cairo | <a href=\"https://www.autodesk.com/research/publications/same-stats-different-graphs\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">Source</a></em></figcaption></figure></div>\n\n\n<p>When non-linear relations are to be expected, one of the alternatives to Pearson&#8217;s correlation should be taken into account. The two most popular ones are:</p>\n\n\n<div class=\"custom-point-list\">\n<ol><li><strong>Spearman’s rank correlation (Spearman’s Rho),</strong></li></ol>\n</div>\n\n\n<p>Spearman’s rank correlation is an alternative to Pearson correlation for ratio/interval variables. As the name suggests, it only looks at the rank values, i.e. it compares the two variables in terms of the relative positions of particular data points within the variables. It is able to capture non-linear relations, but there are no free lunches: we lose some information due to only considering the rank instead of the exact data points.</p>\n\n\n<div class=\"custom-point-list\">\n<ol start=\"2\"><li><strong>Kendall rank correlation (Kendall Tau).</strong></li></ol>\n</div>\n\n\n<p>Another rank-based correlation measure is the Kendall rank correlation.<strong> </strong>It is similar in spirit to Spearman’s correlation but formulated in a slightly different way (Kendall&#8217;s calculations are based on concordant and discordant pairs of values, as opposed to Spearman’s calculations based on deviations). Kendall is often regarded as more robust to outliers in the data.</p>\n\n\n\n<p>If at least one of the compared variables is of ordinal type, Spearman’s or Kendall rank correlation is the way to go. Due to the fact that ordinal data contains only the information on the ranks, they are both a perfect fit, while Pearson’s linear correlation is of little use.</p>\n\n\n\n<p>Another scenario is when both variables are nominal. In this case, we can choose from a couple of different correlation measures:</p>\n\n\n<div class=\"custom-point-list\">\n<ul><li><strong>Cramer’s V</strong>, which captures the association between the two variables into a number ranging from zero (no association) to one (one variable completely determined by the other).</li><li><strong>Chi-Squared statistic</strong> commonly used for testing for dependence between two variables. Lack of dependence suggests the particular feature is not useful.</li><li><strong>Mutual information</strong> a measure of mutual dependence between two variables that seeks to quantify the amount of information that one can extract from one variable about the other.</li></ul>\n</div>\n\n\n<p>Which one to choose? There is no one-size-fits-all answer. As usual, each method comes with some pros and cons. Cramer’s V is known to overestimate the association’s strength. Mutual information, being a non-parametric method, requires larger data samples to yield reliable results. Finally, the Chi-Squared does not provide information about the strength of the relationship, but rather only whether it exists or not.</p>\n\n\n\n<p>We have discussed scenarios in which the two variables we compare are both interval or ratio, when at least one of them is ordinal, and when we compare two nominal variables. The final possible encounter is to compare a nominal variable with a non-nominal one.</p>\n\n\n\n<p>In such cases, the two most widely-used correlation measures are:</p>\n\n\n<div class=\"custom-point-list\">\n<ul><li><strong>ANOVA F-score</strong>, a chi-squared equivalent for the case when one of the variables is continuous while the other is nominal,</li><li><strong>Point-biserial correlation</strong> a correlation measure especially designed to evaluate the relationship between a binary and a continuous variable.</li></ul>\n</div>\n\n\n<p>Once again, there is no silver bullet. The F-score only captures linear relations, while point-biserial correlation makes some strong normality assumption that might not hold in practice, undermining its results.</p>\n\n\n\n<p>Having said all that, which method should one choose in a particular case? The table below will hopefully provide some guidance in this matter.</p>\n\n\n<div id=\"block_631894b437194\" class=\"separator separator-20\"></div>\n\n\n<div class=\"medium-table\">\n        <div class=\"mt-row heading\">\n            <div class=\"mt-col\" style=\"width: 17.5%\">\n            Variable 1        </div>\n            <div class=\"mt-col\" style=\"width: 17.5%\">\n            Variable 2        </div>\n            <div class=\"mt-col\" style=\"width: 20%\">\n            Method        </div>\n            <div class=\"mt-col\" style=\"width: 45%\">\n            Comments        </div>\n        </div>\n    \n            <div class=\"mt-row\">\n                            <div class=\"mt-col\" style=\"width: 17.5%\">\n                                                                <table>\n<tbody>\n<tr>\n<td rowspan=\"3\"><span style=\"font-weight: 400;\">Interval / ratio</span></td>\n</tr>\n</tbody>\n</table>\n                                    </div>\n                            <div class=\"mt-col\" style=\"width: 17.5%\">\n                                        <span class=\"column-name\">\n                        Variable 2:\n                    </span>\n                                                                <table>\n<tbody>\n<tr>\n<td rowspan=\"3\"><span style=\"font-weight: 400;\">Interval / ratio</span></td>\n</tr>\n</tbody>\n</table>\n                                    </div>\n                            <div class=\"mt-col\" style=\"width: 20%\">\n                                        <span class=\"column-name\">\n                        Method:\n                    </span>\n                                                                <table>\n<tbody>\n<tr>\n<td><span style=\"font-weight: 400;\">Pearson’s r</span></td>\n</tr>\n</tbody>\n</table>\n                                    </div>\n                            <div class=\"mt-col\" style=\"width: 45%\">\n                                        <span class=\"column-name\">\n                        Comments:\n                    </span>\n                                                                <table>\n<tbody>\n<tr>\n<td><span style=\"font-weight: 400;\">Only captures linear relations, assumes normality</span></td>\n</tr>\n</tbody>\n</table>\n                                    </div>\n                    </div>\n            <div class=\"mt-row\">\n                            <div class=\"mt-col\" style=\"width: 17.5%\">\n                                                                                                    </div>\n                            <div class=\"mt-col\" style=\"width: 17.5%\">\n                                        <span class=\"column-name\">\n                        Variable 2:\n                    </span>\n                                                                                                    </div>\n                            <div class=\"mt-col\" style=\"width: 20%\">\n                                        <span class=\"column-name\">\n                        Method:\n                    </span>\n                                                                <table>\n<tbody>\n<tr>\n<td><span style=\"font-weight: 400;\">Spearman’s Rho</span></td>\n</tr>\n</tbody>\n</table>\n                                    </div>\n                            <div class=\"mt-col\" style=\"width: 45%\">\n                                        <span class=\"column-name\">\n                        Comments:\n                    </span>\n                                                                <table>\n<tbody>\n<tr>\n<td><span style=\"font-weight: 400;\">When nonlinear relations are expected</span></td>\n</tr>\n</tbody>\n</table>\n                                    </div>\n                    </div>\n            <div class=\"mt-row\">\n                            <div class=\"mt-col\" style=\"width: 17.5%\">\n                                                                                                    </div>\n                            <div class=\"mt-col\" style=\"width: 17.5%\">\n                                        <span class=\"column-name\">\n                        Variable 2:\n                    </span>\n                                                                                                    </div>\n                            <div class=\"mt-col\" style=\"width: 20%\">\n                                        <span class=\"column-name\">\n                        Method:\n                    </span>\n                                                                <table>\n<tbody>\n<tr>\n<td><span style=\"font-weight: 400;\">Kendall Tau</span></td>\n</tr>\n</tbody>\n</table>\n                                    </div>\n                            <div class=\"mt-col\" style=\"width: 45%\">\n                                        <span class=\"column-name\">\n                        Comments:\n                    </span>\n                                                                <p><span style=\"font-weight: 400;\">When nonlinear relations are expected</span></p>\n                                    </div>\n                    </div>\n            <div class=\"mt-row\">\n                            <div class=\"mt-col\" style=\"width: 17.5%\">\n                                                                <table>\n<tbody>\n<tr>\n<td rowspan=\"2\"><span style=\"font-weight: 400;\">Interval / ratio</span></td>\n</tr>\n</tbody>\n</table>\n                                    </div>\n                            <div class=\"mt-col\" style=\"width: 17.5%\">\n                                        <span class=\"column-name\">\n                        Variable 2:\n                    </span>\n                                                                <p><span style=\"font-weight: 400;\">Ordinal</span></p>\n                                    </div>\n                            <div class=\"mt-col\" style=\"width: 20%\">\n                                        <span class=\"column-name\">\n                        Method:\n                    </span>\n                                                                <table>\n<tbody>\n<tr>\n<td><span style=\"font-weight: 400;\">Spearman’s Rho</span></td>\n</tr>\n</tbody>\n</table>\n                                    </div>\n                            <div class=\"mt-col\" style=\"width: 45%\">\n                                        <span class=\"column-name\">\n                        Comments:\n                    </span>\n                                                                <table>\n<tbody>\n<tr>\n<td><span style=\"font-weight: 400;\">Based on ranks only, captures nonlinearities</span></td>\n</tr>\n</tbody>\n</table>\n                                    </div>\n                    </div>\n            <div class=\"mt-row\">\n                            <div class=\"mt-col\" style=\"width: 17.5%\">\n                                                                                                    </div>\n                            <div class=\"mt-col\" style=\"width: 17.5%\">\n                                        <span class=\"column-name\">\n                        Variable 2:\n                    </span>\n                                                                                                    </div>\n                            <div class=\"mt-col\" style=\"width: 20%\">\n                                        <span class=\"column-name\">\n                        Method:\n                    </span>\n                                                                <table>\n<tbody>\n<tr>\n<td><span style=\"font-weight: 400;\">Kendall Tau</span></td>\n</tr>\n</tbody>\n</table>\n                                    </div>\n                            <div class=\"mt-col\" style=\"width: 45%\">\n                                        <span class=\"column-name\">\n                        Comments:\n                    </span>\n                                                                <p><span style=\"font-weight: 400;\">Like Rho, but more robust to outliers</span></p>\n                                    </div>\n                    </div>\n            <div class=\"mt-row\">\n                            <div class=\"mt-col\" style=\"width: 17.5%\">\n                                                                <p><span style=\"font-weight: 400;\">Nominal </span></p>\n                                    </div>\n                            <div class=\"mt-col\" style=\"width: 17.5%\">\n                                        <span class=\"column-name\">\n                        Variable 2:\n                    </span>\n                                                                <p><span style=\"font-weight: 400;\">Nominal </span></p>\n                                    </div>\n                            <div class=\"mt-col\" style=\"width: 20%\">\n                                        <span class=\"column-name\">\n                        Method:\n                    </span>\n                                                                <table>\n<tbody>\n<tr>\n<td><span style=\"font-weight: 400;\">Cramer’s V</span></td>\n</tr>\n</tbody>\n</table>\n                                    </div>\n                            <div class=\"mt-col\" style=\"width: 45%\">\n                                        <span class=\"column-name\">\n                        Comments:\n                    </span>\n                                                                <table>\n<tbody>\n<tr>\n<td><span style=\"font-weight: 400;\">May overestimate correlation strength</span></td>\n</tr>\n</tbody>\n</table>\n                                    </div>\n                    </div>\n            <div class=\"mt-row\">\n                            <div class=\"mt-col\" style=\"width: 17.5%\">\n                                                                                                    </div>\n                            <div class=\"mt-col\" style=\"width: 17.5%\">\n                                        <span class=\"column-name\">\n                        Variable 2:\n                    </span>\n                                                                                                    </div>\n                            <div class=\"mt-col\" style=\"width: 20%\">\n                                        <span class=\"column-name\">\n                        Method:\n                    </span>\n                                                                <p><span style=\"font-weight: 400;\">Chi-Squared</span></p>\n                                    </div>\n                            <div class=\"mt-col\" style=\"width: 45%\">\n                                        <span class=\"column-name\">\n                        Comments:\n                    </span>\n                                                                <table>\n<tbody>\n<tr>\n<td><span style=\"font-weight: 400;\">No info on correlation’s strength</span></td>\n</tr>\n</tbody>\n</table>\n                                    </div>\n                    </div>\n            <div class=\"mt-row\">\n                            <div class=\"mt-col\" style=\"width: 17.5%\">\n                                                                                                    </div>\n                            <div class=\"mt-col\" style=\"width: 17.5%\">\n                                        <span class=\"column-name\">\n                        Variable 2:\n                    </span>\n                                                                                                    </div>\n                            <div class=\"mt-col\" style=\"width: 20%\">\n                                        <span class=\"column-name\">\n                        Method:\n                    </span>\n                                                                <p><span style=\"font-weight: 400;\">Mutual Information</span></p>\n                                    </div>\n                            <div class=\"mt-col\" style=\"width: 45%\">\n                                        <span class=\"column-name\">\n                        Comments:\n                    </span>\n                                                                <table>\n<tbody>\n<tr>\n<td><span style=\"font-weight: 400;\">Requires many data samples.</span></td>\n</tr>\n</tbody>\n</table>\n                                    </div>\n                    </div>\n            <div class=\"mt-row\">\n                            <div class=\"mt-col\" style=\"width: 17.5%\">\n                                                                <table>\n<tbody>\n<tr>\n<td rowspan=\"2\"><span style=\"font-weight: 400;\">Nominal</span></td>\n</tr>\n</tbody>\n</table>\n                                    </div>\n                            <div class=\"mt-col\" style=\"width: 17.5%\">\n                                        <span class=\"column-name\">\n                        Variable 2:\n                    </span>\n                                                                <p><span style=\"font-weight: 400;\">Interval / ratio </span><span style=\"font-weight: 400;\">/ ordinal</span></p>\n                                    </div>\n                            <div class=\"mt-col\" style=\"width: 20%\">\n                                        <span class=\"column-name\">\n                        Method:\n                    </span>\n                                                                <table>\n<tbody>\n<tr>\n<td><span style=\"font-weight: 400;\">F-score</span></td>\n</tr>\n</tbody>\n</table>\n                                    </div>\n                            <div class=\"mt-col\" style=\"width: 45%\">\n                                        <span class=\"column-name\">\n                        Comments:\n                    </span>\n                                                                <table>\n<tbody>\n<tr>\n<td><span style=\"font-weight: 400;\">Only captures linear relations</span></td>\n</tr>\n</tbody>\n</table>\n                                    </div>\n                    </div>\n            <div class=\"mt-row\">\n                            <div class=\"mt-col\" style=\"width: 17.5%\">\n                                                                                                    </div>\n                            <div class=\"mt-col\" style=\"width: 17.5%\">\n                                        <span class=\"column-name\">\n                        Variable 2:\n                    </span>\n                                                                                                    </div>\n                            <div class=\"mt-col\" style=\"width: 20%\">\n                                        <span class=\"column-name\">\n                        Method:\n                    </span>\n                                                                <table>\n<tbody>\n<tr>\n<td><span style=\"font-weight: 400;\">Point-biserial</span></td>\n</tr>\n</tbody>\n</table>\n                                    </div>\n                            <div class=\"mt-col\" style=\"width: 45%\">\n                                        <span class=\"column-name\">\n                        Comments:\n                    </span>\n                                                                <table>\n<tbody>\n<tr>\n<td><span style=\"font-weight: 400;\">Makes strong normality assumptions</span></td>\n</tr>\n</tbody>\n</table>\n                                    </div>\n                    </div>\n    </div>\n\n\n<div id=\"block_6318949637193\" class=\"separator separator-15\"></div>\n\n\n\n<p class=\"has-text-align-center\"><em>Comparison of different methods</em></p>\n\n\n\n<h2>Take no prisoners: Boruta needs no human input</h2>\n\n\n\n<p>When talking about feature selection, we cannot fail to mention Boruta. Back in 2010, when it was <a href=\"https://www.jstatsoft.org/article/view/v036i11\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">first published</a> as an R package, it quickly became famous as a revolutionary feature selection algorithm.</p>\n\n\n\n<h3>Why is Boruta a game-changer?</h3>\n\n\n\n<p>All the other methods we have discussed so far require a human to make an arbitrary decision. Unsupervised methods need us to set the variance or VIF threshold for feature removal. Wrappers require us to decide on the number of features we want to keep upfront. Filters need us to choose the correlation measure and the number of features to keep as well. Embedded methods have us select regularization strength. Boruta needs none of these.</p>\n\n\n\n<p>Boruta is a simple yet statistically elegant algorithm. It uses feature importance measures from a random forest model to select the best subset of features, and it does so via introducing two clever ideas.</p>\n\n\n<div class=\"custom-point-list\">\n<ol><li>First, the importance scores of features are not compared to one another. Rather, the importance of each feature competes against the importance of its randomized version. To achieve this, Boruta randomly permutes each feature to construct its “shadow” version.&nbsp;</li></ol>\n</div>\n\n\n<p class=\"has-text-align-left\">Then, a random forest is trained on the whole feature set, including the new shadow features. The maximum feature importance among the shadow features serves as a threshold. Of the original features, only those whose importance is above this threshold score a point. In other words, only features that are more important than random vectors are awarded points.&nbsp;</p>\n\n\n\n<p>This process is repeated iteratively multiple times. Since each time the random permutation is different, the threshold also differs, and so different features might score points. After multiple iterations, each of the original features has some number of points to its name.&nbsp;</p>\n\n\n<div class=\"custom-point-list\">\n<ol start=\"2\"><li>The final step is to decide, based on the number of points each feature scored, whether it should be kept or discarded. Here enters the other of Boruta’s two clever ideas: we can model the scores using a <a href=\"https://towardsdatascience.com/6-useful-probability-distributions-with-applications-to-data-science-problems-2c0bee7cef28\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">binomial distribution</a>.</li></ol>\n</div>\n\n\n<p>Each iteration is assumed to be a separate trial. If the feature scored in a given iteration, it is a vote to keep it; if it did not, it’s a vote to discard it. A priori, we have no idea whatsoever whether a feature is important or not, so the expected percentage of trials in which the feature scores is 50%. Hence, we can model the number of points scored with a binomial distribution with p=0.5. If our feature scores significantly more times than this, it is deemed important and kept. If it scores significantly fewer times, it’s deemed unimportant and discarded. If it scores in around 50% of trials, its status is unresolved, but for the sake of being conservative, we can keep it.</p>\n\n\n\n<p>For example, if we let Boruta run for 100 trials, the expected score of each feature would be 50. If it’s closer to zero, we discard it, if it’s closer to 100, we keep it.</p>\n\n\n<div class=\"wp-block-image\">\n<figure class=\"aligncenter size-large is-resized\"><a href=\"https://i0.wp.com/neptune.ai/wp-content/uploads/feature-selection-methods-4.png?ssl=1\"><img data-attachment-id=\"71271\" data-permalink=\"https://neptune.ai/feature-selection-methods-4\" data-orig-file=\"https://i0.wp.com/neptune.ai/wp-content/uploads/feature-selection-methods-4.png?fit=1356%2C1110&ssl=1\" data-orig-size=\"1356,1110\" data-comments-opened=\"0\" data-image-meta=\"{\"aperture\":\"0\",\"credit\":\"\",\"camera\":\"\",\"caption\":\"\",\"created_timestamp\":\"0\",\"copyright\":\"\",\"focal_length\":\"0\",\"iso\":\"0\",\"shutter_speed\":\"0\",\"title\":\"\",\"orientation\":\"0\"}\" data-image-title=\"feature-selection-methods-4\" data-image-description=\"\" data-image-caption=\"\" data-medium-file=\"https://i0.wp.com/neptune.ai/wp-content/uploads/feature-selection-methods-4.png?fit=300%2C246&ssl=1\" data-large-file=\"https://i0.wp.com/neptune.ai/wp-content/uploads/feature-selection-methods-4.png?fit=1024%2C838&ssl=1\" decoding=\"async\" src=\"https://i0.wp.com/neptune.ai/wp-content/uploads/feature-selection-methods-4.png?resize=512%2C419&#038;ssl=1\" alt=\"Graph with example of Boruta\" class=\"wp-image-71271\" width=\"512\" height=\"419\" data-recalc-dims=\"1\" /></a><figcaption><em>Boruta example | Source: author&nbsp;</em></figcaption></figure></div>\n\n\n<p>Boruta has proven very successful in many Kaggle competitions and is always worth trying out. It has also been successfully used for <a href=\"https://www.mdpi.com/1996-1073/14/10/2779\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">predicting energy consumption for building heating</a> or <a href=\"https://www.researchgate.net/publication/353955153_An_application_of_Machine_learning_with_Boruta_Feature_selection_to_Improve_NO2_pollution_prediction\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">predicting air pollution</a>.</p>\n\n\n\n<p>There is a very intuitive Python package to implement Boruta, called <a href=\"https://github.com/scikit-learn-contrib/boruta_py\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">BorutaPy</a> (now part of scikit-learn-contrib). The package’s GitHub readme demonstrates how easy it is to run feature selection with Boruta.</p>\n\n\n\n<h2>Which feature selection method to choose? Build yourself a voting selector</h2>\n\n\n\n<p>We have discussed many different feature selection methods. Each of them has its own strengths and weaknesses, makes its own assumptions, and arrives at its conclusions in a different fashion. Which one to choose? Or do we have to choose? In many cases combining all these different methods together under one roof would make the resulting feature selector stronger than each of its subparts.</p>\n\n\n\n<h3>The inspiration</h3>\n\n\n\n<p>One way to do it is inspired by ensembled decision trees. In this class of models, which includes random forests and many popular gradients boosting algorithms, one trains multiple different models and lets them vote on the final prediction. In a similar spirit, we can build ourselves a voting selector.</p>\n\n\n\n<p>The idea is simple: implement a couple of feature selection methods we have discussed. Your choice could be guided by your time, computational resources, and data measurement levels. Just run as many different methods as you conveniently can afford. Then, for each feature, write down the percentage of selection methods that suggest keeping this feature in the data set. If more than 50% of the methods vote to keep the feature, keep it – otherwise, discard it.</p>\n\n\n\n<p>The idea behind this approach is that while some methods might make wrong judgments with regard to some of the features due to their intrinsic biases, the ensemble of methods should get the set of useful features right. Let’s see how to implement it in practice!</p>\n\n\n\n<h3>The implementation</h3>\n\n\n\n<p>Let’s build a simple voting selector that ensembles three different features selection methods:</p>\n\n\n<div class=\"case-study-numbered-list\">\n    <h2></h2>\n    <ul>\n                    <li><span>1</span>A filter method based on Pearson correlation.<br />\n</li>\n                    <li><span>2</span>An unsupervised method based on multicollinearity.<br />\n</li>\n                    <li><span>3</span>A wrapper, Recursive Feature Elimination. </li>\n            </ul>\n</div>\n\n\n\n<p>Let’s take a look at how such a voting selector might look like.&nbsp;</p>\n\n\n\n<p>Making the imports.</p>\n\n\n\n<pre class=\"hljs\" style=\"display: block; overflow-x: auto; padding: 0.5em; color: rgb(51, 51, 51); background: rgb(248, 248, 248);\"><span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">from</span> itertools <span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">import</span> compress\n\n<span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">import</span> pandas <span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">as</span> pd\n<span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">from</span> sklearn.feature_selection <span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">import</span> RFE, r_regression, SelectKBest\n<span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">from</span> sklearn.svm <span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">import</span> SVR\n<span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">from</span> statsmodels.stats.outliers_influence <span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">import</span> variance_inflation_factor</pre>\n\n\n\n<p>Next, Our VotingSelector class comprises four methods on top of the init constructor. Three of them implement the three feature selection techniques we would like to ensemble:</p>\n\n\n<div class=\"case-study-numbered-list\">\n    <h2></h2>\n    <ul>\n                    <li><span>1</span> _select_pearson() for Pearson correlation filtering<br />\n</li>\n                    <li><span>2</span> _select_vif() for Variance Inflation Factor-based unsupervised approach<br />\n</li>\n                    <li><span>3</span> _select_rbf() for the RBF wrapper</li>\n            </ul>\n</div>\n\n\n\n<p>Each of these methods takes the feature matrix X and the targets y as inputs. The VIF-based method will not use the targets, but we use this argument anyway to keep the interface consistent across all methods so that we can conveniently call them in a loop later. On top of that, each method accepts a keyword arguments dictionary which we will use to pass method-dependent parameters. Having parsed the inputs, each method calls the appropriate sklearn or statsmodels functions which we have discussed before, to return the list of feature names to keep.</p>\n\n\n\n<p>The voting magic happens in the select() method. There, we simply iterate over the three selection methods, and for each feature, we record whether it should be kept (1) or discarded (0) according to this method. Finally, we take the mean over these votes. For each feature, if this mean is greater than the voting threshold of 0.5 (which means that at least two out of three methods voted to keep a feature), we keep it.&nbsp;</p>\n\n\n\n<p>Here is the code for the entire class.</p>\n\n\n\n<pre class=\"hljs\" style=\"display: block; overflow-x: auto; padding: 0.5em; color: rgb(51, 51, 51); background: rgb(248, 248, 248);\"><span class=\"hljs-class\"><span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">class</span> <span class=\"hljs-title\" style=\"color: rgb(68, 85, 136); font-weight: 700;\">VotingSelector</span><span class=\"hljs-params\">()</span>:</span>\n   <span class=\"hljs-function\"><span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">def</span> <span class=\"hljs-title\" style=\"color: rgb(153, 0, 0); font-weight: 700;\">__init__</span><span class=\"hljs-params\">(self)</span>:</span>\n       self.selectors = {\n           <span class=\"hljs-string\" style=\"color: rgb(221, 17, 68);\">\"pearson\"</span>: self._select_pearson,\n           <span class=\"hljs-string\" style=\"color: rgb(221, 17, 68);\">\"vif\"</span>: self._select_vif,\n           <span class=\"hljs-string\" style=\"color: rgb(221, 17, 68);\">\"rfe\"</span>: self._select_rfe,\n       }\n       self.votes = <span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">None</span>\n\n<span class=\"hljs-meta\" style=\"font-weight: 700; color: rgb(153, 153, 153);\">   @staticmethod</span>\n   <span class=\"hljs-function\"><span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">def</span> <span class=\"hljs-title\" style=\"color: rgb(153, 0, 0); font-weight: 700;\">_select_pearson</span><span class=\"hljs-params\">(X, y, **kwargs)</span>:</span>\n       selector = SelectKBest(r_regression, k=kwargs.get(<span class=\"hljs-string\" style=\"color: rgb(221, 17, 68);\">\"n_features_to_select\"</span>, <span class=\"hljs-number\" style=\"color: teal;\">5</span>)).fit(X, y)\n       <span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">return</span> selector.get_feature_names_out()\n\n<span class=\"hljs-meta\" style=\"font-weight: 700; color: rgb(153, 153, 153);\">   @staticmethod</span>\n   <span class=\"hljs-function\"><span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">def</span> <span class=\"hljs-title\" style=\"color: rgb(153, 0, 0); font-weight: 700;\">_select_vif</span><span class=\"hljs-params\">(X, y, **kwargs)</span>:</span>\n       <span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">return</span> [\n           X.columns[feature_index]\n           <span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">for</span> feature_index <span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">in</span> range(len(X.columns))\n           <span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">if</span> variance_inflation_factor(X.values, feature_index) <= kwargs.get(<span class=\"hljs-string\" style=\"color: rgb(221, 17, 68);\">\"vif_threshold\"</span>, <span class=\"hljs-number\" style=\"color: teal;\">10</span>)\n       ]\n\n<span class=\"hljs-meta\" style=\"font-weight: 700; color: rgb(153, 153, 153);\">   @staticmethod</span>\n   <span class=\"hljs-function\"><span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">def</span> <span class=\"hljs-title\" style=\"color: rgb(153, 0, 0); font-weight: 700;\">_select_rfe</span><span class=\"hljs-params\">(X, y, **kwargs)</span>:</span>\n       svr = SVR(kernel=<span class=\"hljs-string\" style=\"color: rgb(221, 17, 68);\">\"linear\"</span>)\n       rfe = RFE(svr, n_features_to_select=kwargs.get(<span class=\"hljs-string\" style=\"color: rgb(221, 17, 68);\">\"n_features_to_select\"</span>, <span class=\"hljs-number\" style=\"color: teal;\">5</span>))\n       rfe.fit(X, y)\n       <span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">return</span> rfe.get_feature_names_out()\n\n   <span class=\"hljs-function\"><span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">def</span> <span class=\"hljs-title\" style=\"color: rgb(153, 0, 0); font-weight: 700;\">select</span><span class=\"hljs-params\">(self, X, y, voting_threshold=<span class=\"hljs-number\" style=\"color: teal;\">0.5</span>, **kwargs)</span>:</span>\n       votes = []\n       <span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">for</span> selector_name, selector_method <span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">in</span> self.selectors.items():\n           features_to_keep = selector_method(X, y, **kwargs)\n           votes.append(\n               pd.DataFrame([int(feature <span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">in</span> features_to_keep) <span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">for</span> feature <span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">in</span> X.columns]).T\n           )\n       self.votes = pd.concat(votes)\n       self.votes.columns = X.columns\n       self.votes.index = self.selectors.keys()\n       features_to_keep = list(compress(X.columns, self.votes.mean(axis=<span class=\"hljs-number\" style=\"color: teal;\">0</span>) > voting_threshold))\n       <span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">return</span> X[features_to_keep]\n\n</pre>\n\n\n\n<p>Let’s see it working in practice. We will load the infamous Boston Housing data, which comes built-in within scikit-learn.</p>\n\n\n\n<pre class=\"hljs\" style=\"display: block; overflow-x: auto; padding: 0.5em; color: rgb(51, 51, 51); background: rgb(248, 248, 248);\"><span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">from</span> sklearn.datasets <span class=\"hljs-keyword\" style=\"color: rgb(51, 51, 51); font-weight: 700;\">import</span> load_boston\nboston = load_boston()\nX = pd.DataFrame(boston[<span class=\"hljs-string\" style=\"color: rgb(221, 17, 68);\">\"data\"</span>], columns=boston[<span class=\"hljs-string\" style=\"color: rgb(221, 17, 68);\">\"feature_names\"</span>])\ny = boston[<span class=\"hljs-string\" style=\"color: rgb(221, 17, 68);\">\"target\"</span>]\n\n</pre>\n\n\n\n<p>Now, running feature selection is as easy as this:</p>\n\n\n\n<pre class=\"hljs\" style=\"display: block; overflow-x: auto; padding: 0.5em; color: rgb(51, 51, 51); background: rgb(248, 248, 248);\">vs = VotingSelector()\nX_selection = vs.select(X, y)</pre>\n\n\n\n<p>As a result, we get the feature matrix with only three features left.</p>\n\n\n\n<pre class=\"hljs\" style=\"display: block; overflow-x: auto; padding: 0.5em; color: rgb(51, 51, 51); background: rgb(248, 248, 248);\">      ZN  CHAS     RM\n<span class=\"hljs-number\" style=\"color: teal;\">0</span>    <span class=\"hljs-number\" style=\"color: teal;\">18.0</span>   <span class=\"hljs-number\" style=\"color: teal;\">0.0</span>  <span class=\"hljs-number\" style=\"color: teal;\">6.575</span>\n<span class=\"hljs-number\" style=\"color: teal;\">1</span>     <span class=\"hljs-number\" style=\"color: teal;\">0.0</span>   <span class=\"hljs-number\" style=\"color: teal;\">0.0</span>  <span class=\"hljs-number\" style=\"color: teal;\">6.421</span>\n<span class=\"hljs-number\" style=\"color: teal;\">2</span>     <span class=\"hljs-number\" style=\"color: teal;\">0.0</span>   <span class=\"hljs-number\" style=\"color: teal;\">0.0</span>  <span class=\"hljs-number\" style=\"color: teal;\">7.185</span>\n<span class=\"hljs-number\" style=\"color: teal;\">3</span>     <span class=\"hljs-number\" style=\"color: teal;\">0.0</span>   <span class=\"hljs-number\" style=\"color: teal;\">0.0</span>  <span class=\"hljs-number\" style=\"color: teal;\">6.998</span>\n<span class=\"hljs-number\" style=\"color: teal;\">4</span>     <span class=\"hljs-number\" style=\"color: teal;\">0.0</span>   <span class=\"hljs-number\" style=\"color: teal;\">0.0</span>  <span class=\"hljs-number\" style=\"color: teal;\">7.147</span>\n..    ...   ...    ...\n<span class=\"hljs-number\" style=\"color: teal;\">501</span>   <span class=\"hljs-number\" style=\"color: teal;\">0.0</span>   <span class=\"hljs-number\" style=\"color: teal;\">0.0</span>  <span class=\"hljs-number\" style=\"color: teal;\">6.593</span>\n<span class=\"hljs-number\" style=\"color: teal;\">502</span>   <span class=\"hljs-number\" style=\"color: teal;\">0.0</span>   <span class=\"hljs-number\" style=\"color: teal;\">0.0</span>  <span class=\"hljs-number\" style=\"color: teal;\">6.120</span>\n<span class=\"hljs-number\" style=\"color: teal;\">503</span>   <span class=\"hljs-number\" style=\"color: teal;\">0.0</span>   <span class=\"hljs-number\" style=\"color: teal;\">0.0</span>  <span class=\"hljs-number\" style=\"color: teal;\">6.976</span>\n<span class=\"hljs-number\" style=\"color: teal;\">504</span>   <span class=\"hljs-number\" style=\"color: teal;\">0.0</span>   <span class=\"hljs-number\" style=\"color: teal;\">0.0</span>  <span class=\"hljs-number\" style=\"color: teal;\">6.794</span>\n<span class=\"hljs-number\" style=\"color: teal;\">505</span>   <span class=\"hljs-number\" style=\"color: teal;\">0.0</span>   <span class=\"hljs-number\" style=\"color: teal;\">0.0</span>  <span class=\"hljs-number\" style=\"color: teal;\">6.030</span>\n[<span class=\"hljs-number\" style=\"color: teal;\">506</span> rows x <span class=\"hljs-number\" style=\"color: teal;\">3</span> columns]\n</pre>\n\n\n\n<p>We can also glimpse at how each of our methods has voted by printing <em>vs.votes.</em></p>\n\n\n\n<pre class=\"hljs\" style=\"display: block; overflow-x: auto; padding: 0.5em; color: rgb(51, 51, 51); background: rgb(248, 248, 248);\">        CRIM  ZN  INDUS  CHAS  NOX  RM  AGE  DIS  RAD  TAX  PTRATIO  B  LSTAT\npearson     <span class=\"hljs-number\" style=\"color: teal;\">0</span>   <span class=\"hljs-number\" style=\"color: teal;\">1</span>      <span class=\"hljs-number\" style=\"color: teal;\">0</span>     <span class=\"hljs-number\" style=\"color: teal;\">1</span>    <span class=\"hljs-number\" style=\"color: teal;\">0</span>   <span class=\"hljs-number\" style=\"color: teal;\">1</span>    <span class=\"hljs-number\" style=\"color: teal;\">0</span>    <span class=\"hljs-number\" style=\"color: teal;\">1</span>    <span class=\"hljs-number\" style=\"color: teal;\">0</span>    <span class=\"hljs-number\" style=\"color: teal;\">0</span>        <span class=\"hljs-number\" style=\"color: teal;\">0</span>  <span class=\"hljs-number\" style=\"color: teal;\">1</span>      <span class=\"hljs-number\" style=\"color: teal;\">0</span>\nvif         <span class=\"hljs-number\" style=\"color: teal;\">1</span>   <span class=\"hljs-number\" style=\"color: teal;\">1</span>      <span class=\"hljs-number\" style=\"color: teal;\">0</span>     <span class=\"hljs-number\" style=\"color: teal;\">1</span>    <span class=\"hljs-number\" style=\"color: teal;\">0</span>   <span class=\"hljs-number\" style=\"color: teal;\">0</span>    <span class=\"hljs-number\" style=\"color: teal;\">0</span>    <span class=\"hljs-number\" style=\"color: teal;\">0</span>    <span class=\"hljs-number\" style=\"color: teal;\">0</span>    <span class=\"hljs-number\" style=\"color: teal;\">0</span>        <span class=\"hljs-number\" style=\"color: teal;\">0</span>  <span class=\"hljs-number\" style=\"color: teal;\">0</span>      <span class=\"hljs-number\" style=\"color: teal;\">0</span>\nrfe         <span class=\"hljs-number\" style=\"color: teal;\">0</span>   <span class=\"hljs-number\" style=\"color: teal;\">0</span>      <span class=\"hljs-number\" style=\"color: teal;\">0</span>     <span class=\"hljs-number\" style=\"color: teal;\">1</span>    <span class=\"hljs-number\" style=\"color: teal;\">1</span>   <span class=\"hljs-number\" style=\"color: teal;\">1</span>    <span class=\"hljs-number\" style=\"color: teal;\">0</span>    <span class=\"hljs-number\" style=\"color: teal;\">0</span>    <span class=\"hljs-number\" style=\"color: teal;\">0</span>    <span class=\"hljs-number\" style=\"color: teal;\">0</span>        <span class=\"hljs-number\" style=\"color: teal;\">1</span>  <span class=\"hljs-number\" style=\"color: teal;\">0</span>      <span class=\"hljs-number\" style=\"color: teal;\">1</span></pre>\n\n\n\n<p>We might not be happy with only 3 out of the initial 13 columns left. Luckily, we can easily make the selection less restrictive by modifying the parameters of the particular methods. This can be done by simply adding appropriate arguments to the call to select, thanks to how we pass kwargs around.</p>\n\n\n\n<p>Pearson and RFE methods need a pre-defined number of features to keep. The default has been 5, but we might want to increase it to 8. We can also modify the VIF threshold, that is the value of the Variance Inflation Factor above which we discard a feature due to multicollinearity. By convention, this threshold is set at 10, but increasing it to, say, 15 will result in more features being kept.</p>\n\n\n\n<pre class=\"hljs\" style=\"display: block; overflow-x: auto; padding: 0.5em; color: rgb(51, 51, 51); background: rgb(248, 248, 248);\">vs = VotingSelector()\nX_selection = vs.select(X, y, n_features_to_select=<span class=\"hljs-number\" style=\"color: teal;\">8</span>, vif_threshold=<span class=\"hljs-number\" style=\"color: teal;\">15</span>)</pre>\n\n\n\n<p>This way, we have seven features left.</p>\n\n\n\n<pre class=\"hljs\" style=\"display: block; overflow-x: auto; padding: 0.5em; color: rgb(51, 51, 51); background: rgb(248, 248, 248);\">        CRIM  ZN  INDUS  CHAS  NOX  RM  AGE  DIS  RAD  TAX  PTRATIO  B  LSTAT\npearson     <span class=\"hljs-number\" style=\"color: teal;\">1</span>   <span class=\"hljs-number\" style=\"color: teal;\">1</span>      <span class=\"hljs-number\" style=\"color: teal;\">0</span>     <span class=\"hljs-number\" style=\"color: teal;\">1</span>    <span class=\"hljs-number\" style=\"color: teal;\">0</span>   <span class=\"hljs-number\" style=\"color: teal;\">1</span>    <span class=\"hljs-number\" style=\"color: teal;\">1</span>    <span class=\"hljs-number\" style=\"color: teal;\">1</span>    <span class=\"hljs-number\" style=\"color: teal;\">1</span>    <span class=\"hljs-number\" style=\"color: teal;\">0</span>        <span class=\"hljs-number\" style=\"color: teal;\">0</span>  <span class=\"hljs-number\" style=\"color: teal;\">1</span>      <span class=\"hljs-number\" style=\"color: teal;\">0</span>\nvif         <span class=\"hljs-number\" style=\"color: teal;\">1</span>   <span class=\"hljs-number\" style=\"color: teal;\">1</span>      <span class=\"hljs-number\" style=\"color: teal;\">1</span>     <span class=\"hljs-number\" style=\"color: teal;\">1</span>    <span class=\"hljs-number\" style=\"color: teal;\">0</span>   <span class=\"hljs-number\" style=\"color: teal;\">0</span>    <span class=\"hljs-number\" style=\"color: teal;\">0</span>    <span class=\"hljs-number\" style=\"color: teal;\">1</span>    <span class=\"hljs-number\" style=\"color: teal;\">0</span>    <span class=\"hljs-number\" style=\"color: teal;\">0</span>        <span class=\"hljs-number\" style=\"color: teal;\">0</span>  <span class=\"hljs-number\" style=\"color: teal;\">0</span>      <span class=\"hljs-number\" style=\"color: teal;\">1</span>\nrfe         <span class=\"hljs-number\" style=\"color: teal;\">1</span>   <span class=\"hljs-number\" style=\"color: teal;\">0</span>      <span class=\"hljs-number\" style=\"color: teal;\">1</span>     <span class=\"hljs-number\" style=\"color: teal;\">1</span>    <span class=\"hljs-number\" style=\"color: teal;\">1</span>   <span class=\"hljs-number\" style=\"color: teal;\">1</span>    <span class=\"hljs-number\" style=\"color: teal;\">0</span>    <span class=\"hljs-number\" style=\"color: teal;\">1</span>    <span class=\"hljs-number\" style=\"color: teal;\">0</span>    <span class=\"hljs-number\" style=\"color: teal;\">0</span>        <span class=\"hljs-number\" style=\"color: teal;\">1</span>  <span class=\"hljs-number\" style=\"color: teal;\">0</span>      <span class=\"hljs-number\" style=\"color: teal;\">1</span></pre>\n\n\n\n<p>Our VotingSelector class is a simple but generic template which you can extend to an arbitrary number of feature selection methods. As a possible extension, you could also treat all the arguments passed to select() as hyperparameters of your modeling pipeline and optimize them so as to maximize the performance of the downstream model.</p>\n\n\n\n<h2>Feature selection at Big Tech</h2>\n\n\n\n<p>Large technology companies such as GAFAM and the likes of it, with their thousands of machine learning models in production, are prime examples of how feature selection is operated in the wild. Let’s see what these tech giants have to say about it!</p>\n\n\n\n<h3>Google</h3>\n\n\n\n<p><a href=\"https://martin.zinkevich.org/rules_of_ml/rules_of_ml.pdf\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">Rules of ML</a> is a handy compilation of best practices in machine learning from around Google. In it, Google’s engineers point out that the number of parameters the model can learn is roughly</p>\n\n\n\n<p>proportional to the amount of data it has access to. Hence, the less data we have, the more features we need to discard. Their rough guidelines (derived from text-based models) are to use a dozen features with 1000 training examples or 100,000 features with 10 million training examples.&nbsp;</p>\n\n\n\n<p>Another crucial point in the document concerns model deployment issues, which can also affect feature selection.&nbsp;</p>\n\n\n<div class=\"custom-point-list\">\n<ul><li>First, your set of features to select from might be constrained by what will be available in production at inference time. You may be forced to drop a great feature from training if it isn’t there for the model when it goes live.&nbsp;</li></ul>\n</div>\n\n<div class=\"custom-point-list\">\n<ul><li>Second, some features might be prone to <a href=\"https://towardsdatascience.com/dont-let-your-model-s-quality-drift-away-53d2f7899c09\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">data drift</a>. While the topic of tackling drift is a complex one, sometimes the best solution might be to remove the problematic feature from the model altogether.</li></ul>\n</div>\n\n\n<h3>Facebook</h3>\n\n\n\n<p>A couple of years ago, in 2019, Facebook came up with its own Neural Network suitable Feature Selection algorithm in order to save computational resources while training large-scale models. They further tested this algorithm on their own Facebook News Feed dataset so as to rank relevant items as efficiently as possible while working with a fewer-dimensional input. You can read all about it <a href=\"https://research.facebook.com/publications/feature-selection-for-facebook-feed-ranking-system-via-a-group-sparsity-regularized-training-algorithm/\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">here</a>.</p>\n\n\n\n<h2>Parting words</h2>\n\n\n\n<p>Thanks for reading till the end! I hope this article convinced you that feature selection is a crucial step in the data preparation pipeline and gave you some guidance as to how to approach it.&nbsp;</p>\n\n\n\n<p>Don’t hesitate to hit me up on social media to discuss the topics covered here or any other machine learning topics, for that matter. Happy feature selection!</p>\n\n\n\n<h3>References</h3>\n\n\n<div class=\"custom-point-list\">\n<ol><li><a href=\"https://scikit-learn.org/stable/modules/feature_selection.html\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">Scikit-learn documentation on feature selection</a></li><li><a href=\"https://martin.zinkevich.org/rules_of_ml/rules_of_ml.pdf\">B</a><a href=\"https://github.com/scikit-learn-contrib/boruta_py/blob/master/README.md\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">oruta_py’s GitHub README</a></li><li><a href=\"https://martin.zinkevich.org/rules_of_ml/rules_of_ml.pdf\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">Rules of Machine Learning: Best Practices for ML Engineering</a></li></ol>\n</div>\n\n\n\n<div id=\"author-box-new-format-block_625956d8f9d5e\" class=\"article__footer article__author\">\n  <div class=\"article__authorImage\">\n          <img width=\"230\" height=\"202\" src=\"https://i0.wp.com/neptune.ai/wp-content/uploads/Michal_Oleszak.jpeg?fit=230%2C202&ssl=1\" class=\"article__authorImage-img\" alt=\"Michal_Oleszak\" decoding=\"async\" data-attachment-id=\"68367\" data-permalink=\"https://neptune.ai/blog-author-michal-oleszak/attachment/michal_oleszak\" data-orig-file=\"https://i0.wp.com/neptune.ai/wp-content/uploads/Michal_Oleszak.jpeg?fit=1599%2C1406&ssl=1\" data-orig-size=\"1599,1406\" data-comments-opened=\"0\" data-image-meta=\"{\"aperture\":\"0\",\"credit\":\"\",\"camera\":\"\",\"caption\":\"\",\"created_timestamp\":\"0\",\"copyright\":\"\",\"focal_length\":\"0\",\"iso\":\"0\",\"shutter_speed\":\"0\",\"title\":\"\",\"orientation\":\"1\"}\" data-image-title=\"Michal_Oleszak\" data-image-description=\"\" data-image-caption=\"\" data-medium-file=\"https://i0.wp.com/neptune.ai/wp-content/uploads/Michal_Oleszak.jpeg?fit=300%2C264&ssl=1\" data-large-file=\"https://i0.wp.com/neptune.ai/wp-content/uploads/Michal_Oleszak.jpeg?fit=1024%2C900&ssl=1\" />      </div>\n\n  <div class=\"article__authorContent\">\n          <h3 class=\"article__authorContent-name\">Michał Oleszak</h3>\n    \n          <p class=\"article__authorContent-text\">Machine Learning Engineer with a statistics background. Has worn all the hats, having worked for a consultancy, an AI startup, and a software house. A traveler, polyglot, data science blogger and instructor, and lifelong learner. Check out his website to find out more.\n</p>\n    \n          <ul class=\"article__authorSocial\">\n        <li class=\"article__authorSocial-single article__authorSocial-name\">Follow me on</li>\n                  <li class=\"article__authorSocial-single\"><a href=\"https://twitter.com/MichalOleszak\" class=\"article__authorSocial-tw\" target=\"_blank\"></a></li>\n        \n                  <li class=\"article__authorSocial-single\"><a href=\"https://www.linkedin.com/in/michal-oleszak/\" class=\"article__authorSocial-lk\" target=\"_blank\"></a></li>\n        \n                  <li class=\"article__authorSocial-single\"><a href=\"https://michaloleszak.com/\" class=\"article__authorSocial-www\" target=\"_blank\"></a></li>\n              </ul>\n    \n  </div>\n</div>\n\n\n<div class=\"is-layout-flow wp-block-group\"><div class=\"wp-block-group__inner-container\">\n<hr class=\"wp-block-separator has-css-opacity\"/>\n\n\n\n<p class=\"has-text-color\" style=\"color:#4455a6\"><strong>READ NEXT</strong></p>\n\n\n\n<h2>Real-World MLOps Examples: Model Development in Hypefactors</h2>\n\n\n\n<p class=\"has-small-font-size\">6 mins read | Author&nbsp;Stephen Oladele | Updated June 28th, 2022</p>\n\n\n<div id=\"block_5ffc75def9f8e\" class=\"separator separator-10\"></div>\n\n\n\n<p>In this first installment of the series “Real-world MLOps Examples,”&nbsp;<a href=\"https://www.linkedin.com/in/jules-belveze\" target=\"_blank\" rel=\"noreferrer noopener\">Jules Belveze</a>, an MLOps Engineer, will walk you through the model development process at&nbsp;<a href=\"https://hypefactors.com/\" target=\"_blank\" rel=\"noreferrer noopener\">Hypefactors</a>, including the types of models they build, how they design their training pipeline, and other details you may find valuable. Enjoy the chat!</p>\n\n\n\n<h3 id=\"company-profile\">Company profile</h3>\n\n\n\n<p><a href=\"https://hypefactors.com/\" target=\"_blank\" rel=\"noreferrer noopener\">Hypefactors</a>&nbsp;provides an all-in-one media intelligence solution for managing PR and communications, tracking trust, product launches, and market and financial intelligence. They operate large data pipelines that stream in the world’s media data ongoingly in real-time. AI is used for many automations that were previously performed manually.</p>\n\n\n\n<h3 id=\"guest-introduction\">Guest introduction</h3>\n\n\n\n<h4>Could you introduce yourself to our readers?</h4>\n\n\n\n<p>Hey Stephen, thanks for having me! My name is Jules. I am 26. I was born and raised in Paris, I am currently living in Copenhagen.</p>\n\n\n\n<h4>Hey Jules! Thanks for the intro. Walk me through your background and how you got to Hypefactors.</h4>\n\n\n\n<p>I hold a Bachelor’s in statistics and probabilities and a Master’s in general engineering from universities in France. On top of that, I also graduated in Data Science with a focus on deep learning from Danish Technical University, Denmark. I’m fascinated by multilingual natural language processing (and therefore specialized in it). I also researched anomaly detection on high-dimensional time series during my graduate studies with Microsoft.&nbsp;</p>\n\n\n\n<p>Today, I work for a media intelligence tech company called Hypefactors, where I develop NLP models to help our users gain insights from the media landscape. What currently works for me is having the opportunity to carry out models from prototyping all the way to production. I guess you could call me a nerd, at least that’s how my friend describes me, as I spent most of my free time either coding or listening to disco vinyl.</p>\n\n\n\n<h3 id=\"model-development-at-hypefactors\">Model development at Hypefactors</h3>\n\n\n\n<h4>Could you elaborate on the types of models you build at Hypefactors?</h4>\n\n\n\n<p>Even though we also have computer vision models running in production, we mainly build&nbsp;<a href=\"https://neptune.ai/blog/category/natural-language-processing\" target=\"_blank\" rel=\"noreferrer noopener\">NLP (Natural Language Processing)</a>&nbsp;models for various use cases. We need to cover multiple countries and handle many languages. The multilingual aspect makes developing with “classical machine learning” approaches hard. We craft deep learning models on top of the&nbsp;<a href=\"https://github.com/huggingface/transformers\" target=\"_blank\" rel=\"noreferrer noopener\">transformer library</a>.&nbsp;</p>\n\n\n\n<p>We run all sorts of models in production, varying from span extraction or sequence classification to text generation. Those models are designed to serve different use cases, like topic classification, sentiment analysis, or summarisation.</p>\n\n\n<a class=\"button continous-post blue-filled\" href=\"/blog/mlops\" target=\"_blank\">\n    Continue reading -></a>\n\n\n\n<hr class=\"wp-block-separator has-css-opacity\"/>\n</div></div>\n<p>The post <a rel=\"nofollow\" href=\"https://neptune.ai/blog/feature-selection-methods\">Feature Selection Methods and How to Choose Them</a> appeared first on <a rel=\"nofollow\" href=\"https://neptune.ai\">neptune.ai</a>.</p>\n",
  "post-id": 71265
}