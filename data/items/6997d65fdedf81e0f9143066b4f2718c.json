{
  "guid": "tag:blogger.com,1999:blog-6300367579216018061.post-7246453222913999813",
  "pubDate": "Thu, 10 Jul 2014 04:35:00 +0000",
  "atom:updated": "2015-12-08T00:15:27.827-08:00",
  "category": [
    "cypher",
    "declarative query language",
    "execution planning",
    "graph database",
    "graphs",
    "neo4j",
    "open source software"
  ],
  "title": "Understanding How Neo4j Cypher Queries are Evaluated",
  "description": "<script src=\"https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js\"></script>There are many ways to store and manage data within a <a href=\"http://www.neo4j.com/\" target=\"_blank\">Neo4j graph database</a>. When Neo4j 2.0 launched late last year we had an entirely new browser experience for interacting with graphs. The graph visualization from the return results of Cypher queries were at the core of the user experience enhancements to the platform.<br /><div><br /></div><div class=\"separator\" style=\"clear: both; text-align: center;\"></div><div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"http://4.bp.blogspot.com/-QgyjbOTkSo8/U72irZchIJI/AAAAAAAAA7E/QouCN-D8DX4/s1600/neo4j-browser.png\" imageanchor=\"1\" style=\"margin-left: 1em; margin-right: 1em;\"><img border=\"0\" src=\"http://4.bp.blogspot.com/-QgyjbOTkSo8/U72irZchIJI/AAAAAAAAA7E/QouCN-D8DX4/s1600/neo4j-browser.png\" height=\"496\" width=\"640\" /></a></div><a name='more'></a><div><br /></div><div>For most users that use the Neo4j browser, this is an ideal experience for learning and designing great graph data models for querying. For applications that require a deeper control over how graphs are stored and queried, the native&nbsp;<a href=\"http://docs.neo4j.org/chunked/stable/tutorials-java-embedded.html\" target=\"_blank\">Java API</a> provides a great deal of benefits. When using the Java API you gain a degree of freedom to tell Neo4j how to query your data.<br /><br />The <a href=\"http://docs.neo4j.org/chunked/stable/cypher-introduction.html\" target=\"_blank\">Cypher query language</a>, with an innovative SQL-like syntax for graphs, is a declarative query language. That means you tell Neo4j what you want and not how to get it. When you run a Cypher query you are expressing to the graph database what you want from it. In turn, Neo4j maintains a compiler that translates that query into&nbsp;an execution plan that describes a set of data operations, arranged such that data is obtained from the graph and processed sequentially through each operation until a result is generated for the user.</div><div><br /></div><h4>What does an execution plan look like?</h4><div><br /></div><div>The typical approach for interacting with Neo4j involves sending a Cypher query and parameters in a POST request to the Neo4j database server. We call the frameworks or libraries that manage wrappers around the REST API methods of Neo4j from an arbitrary programming language a \"<a href=\"http://neo4j.com/contrib/\" target=\"_blank\">driver</a>\". These drivers transport queries and results over the network and Neo4j further translates the declarative syntax of Cypher into an execution plan.</div><div><br /></div><div>Using the <a href=\"http://console.neo4j.org/\" target=\"_blank\">Neo4j web-based console</a>, we can get the results of each query in the detailed query results.</div><div><br /></div><div>I've setup a sample graph with 3 people: Kenny, Adam, and Greta. These 3 people are friends on a social network.</div><div><br /></div><div><br /></div><div><br /><iframe height=\"600\" src=\"http://console.neo4j.org/r/f71ux0\" width=\"900\"></iframe><br /><br /><br />If you run an \"All Nodes\" query in the console above:<br /><br /><pre data-lang=\"cypher\"><br />// All nodes query<br />MATCH (n)<br />RETURN n<br /></pre><br />You will be able to see the detailed results by clicking on the \"Result Details\" button, shown in the screenshot below.<br /><br /><div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"http://4.bp.blogspot.com/-rbz7DQ81v-A/U72nGjdB29I/AAAAAAAAA7Q/zgxcnjv_2_4/s1600/Neo4j_Console.png\" imageanchor=\"1\" style=\"margin-left: 1em; margin-right: 1em;\"><img border=\"0\" src=\"http://4.bp.blogspot.com/-rbz7DQ81v-A/U72nGjdB29I/AAAAAAAAA7Q/zgxcnjv_2_4/s1600/Neo4j_Console.png\" height=\"165\" width=\"400\" /></a></div><br /><br /></div><div><h3 style=\"color: #111111; font-family: 'Bitstream Vera Sans Mono', 'DejaVu Sans Mono', Consolas, Monaco, Courier, monospace; margin: 1px;\">Detailed Query Results</h3><pre id=\"stats-output\"><h4 style=\"color: #111111; font-family: 'Bitstream Vera Sans Mono', 'DejaVu Sans Mono', Consolas, Monaco, Courier, monospace !important; font-size: 12px;\"><br />Query Results</h4><br /><span style=\"color: #111111; font-family: Bitstream Vera Sans Mono, DejaVu Sans Mono, Consolas, Monaco, Courier, monospace;\"><span style=\"font-size: 12px;\">+-----------------------+<br />| n                     |<br />+-----------------------+<br />| Node[6]{name:\"Kenny\"} |<br />| Node[7]{name:\"Adam\"}  |<br />| Node[8]{name:\"Greta\"} |<br />+-----------------------+<br />3 rows<br />6 ms<br /></span></span><h4 style=\"color: #111111; font-family: 'Bitstream Vera Sans Mono', 'DejaVu Sans Mono', Consolas, Monaco, Courier, monospace !important; font-size: 12px;\"><br />Execution Plan</h4><br /><span style=\"color: #111111; font-family: Bitstream Vera Sans Mono, DejaVu Sans Mono, Consolas, Monaco, Courier, monospace;\"><span style=\"font-size: 12px;\">AllNodes<br /><br />+----------+------+--------+-------------+-------+<br />| Operator | Rows | DbHits | Identifiers | Other |<br />+----------+------+--------+-------------+-------+<br />| AllNodes |    3 |      4 |        n, n |       |<br />+----------+------+--------+-------------+-------+<br /></span></span><br /></pre>As the execution plan states, the Cypher query has been translated to the <i>AllNodes</i> operation.<br /><br />Now if we run a slightly more complex Cypher query, the execution plan shows the piping of operations.<br /><br /><pre data-lang=\"cypher\"><br />// Find Kenny's friends<br />MATCH (kenny:Person {name:\"Kenny\"})-[:FRIEND_OF]-(friends)<br />RETURN friends<br /></pre></div><h3 style=\"box-sizing: border-box; color: #111111; font-family: 'Bitstream Vera Sans Mono', 'DejaVu Sans Mono', Consolas, Monaco, Courier, monospace; font-size: 16px; font-weight: bold; line-height: normal; margin: 1px; white-space: normal;\">Detailed Query Results</h3><pre id=\"stats-output\" style=\"box-sizing: border-box; color: #111111; font-family: 'Bitstream Vera Sans Mono', 'DejaVu Sans Mono', Consolas, Monaco, Courier, monospace !important; font-size: 12px; font-weight: normal; line-height: normal;\"><h4><br />Query Results</h4><br />+-----------------------+<br />| friends               |<br />+-----------------------+<br />| Node[1]{name:\"Adam\"}  |<br />| Node[2]{name:\"Greta\"} |<br />+-----------------------+<br />2 rows<br />14 ms<br /><br /><h4><br />Execution Plan</h4><br />ColumnFilter<br />  |<br />  +Filter<br />    |<br />    +TraversalMatcher<br /><br />+------------------+------+--------+-------------+--------------------------------------------+<br />|         Operator | Rows | DbHits | Identifiers |                                      Other |<br />+------------------+------+--------+-------------+--------------------------------------------+<br />|     ColumnFilter |    2 |      0 |             |                       keep columns friends |<br />|           Filter |    2 |     12 |             | Property(kenny,name(0)) == {  AUTOSTRING0} |<br />| TraversalMatcher |    6 |     13 |             |              friends,   UNNAMED37, friends |<br />+------------------+------+--------+-------------+--------------------------------------------+</pre><div>The execution plan for the query shows 3 operators: <i>ColumnFilter</i>, <i>Filter</i>, and <i>TraversalMatcher</i>. The <i>ColumnFilter</i> operation receives a row of data from the <i>Filter</i> operation and processes it by keeping only the identifier \"<b><i>friends</i></b>\", which is in the RETURN statement. The <i>Filter</i> operation also receives rows of data from its preceding operation, the <i>TraversalMatcher</i>, and applies a predicate to decide whether to pass that data row along to the next operation (the <i>ColumnFilter</i>) or to discard it. In the case of our query, the predicate is to filter nodes by applying the criteria for the identifier \"<b><i>kenny</i></b>\" with the property \"<b><i>name</i></b>\" that equals <i><b>AUTOSTRING0</b></i>, which will resolve to the token \"<b><i>Kenny</i></b>\" when the plan is executed. Finally the <i>TraversalMatcher</i> doesn't receive any rows of data, due to being the first operation, but generates new rows of data by searching the graph for the pattern specified in the MATCH clause.<br /><br />So you can see that the execution plan, as constructed from the Cypher query, operates <u>bottom up</u>. Patterns are found in the <i>TraversalMatcher</i> (a total of 6 rows), and then passed through the <i>Filter</i>, which only allows 2 through, and finally to the <i>ColumnFilter</i>, which only keeps the \"<i><b>friends</b></i>\" column specified in the RETURN clause.<br /><br />Knowing how the data is generated, filtered, and processed is tremendously helpful for understanding how to optimize queries for the best performance. The compiler does what it can to generate the most optimal plan. It is constantly being made smarter with each release, yet its still extremely relevant for us developers to understand what the result is&nbsp;<em style=\"background-color: white; border: none; box-sizing: border-box; color: #5f5f5f; font-family: Arial, Helvetica, sans-serif; font-size: 16px; line-height: 25.600000381469727px; margin: 0px; padding: 0px;\"><span style=\"border: none; box-sizing: border-box; font-size: x-small; margin: 0px; padding: 0px;\">â€”</span></em>&nbsp;and to consider how we can adjust the query we're asking to obtain a more optimal result.</div></br><a href=\"https://news.ycombinator.com/submit\" class=\"hn-button\" data-title=\"Understanding How Neo4j Cypher Queries are Evaluated \" data-url=\"http://www.kennybastani.com/2014/07/understanding-how-neo4j-cypher-queries.html\" data-count=\"horizontal\">Vote on Hacker News</a><script type=\"text/javascript\">var HN=[];HN.factory=function(e){return function(){HN.push([e].concat(Array.prototype.slice.call(arguments,0)))};},HN.on=HN.factory(\"on\"),HN.once=HN.factory(\"once\"),HN.off=HN.factory(\"off\"),HN.emit=HN.factory(\"emit\"),HN.load=function(){var e=\"hn-button.js\";if(document.getElementById(e))return;var t=document.createElement(\"script\");t.id=e,t.src=\"//hn-button.herokuapp.com/hn-button.js\";var n=document.getElementsByTagName(\"script\")[0];n.parentNode.insertBefore(t,n)},HN.load();</script>",
  "link": "https://www.kennybastani.com/2014/07/understanding-how-neo4j-cypher-queries.html",
  "author": "noreply@blogger.com (Kenny Bastani)",
  "media:thumbnail": "",
  "thr:total": 0
}