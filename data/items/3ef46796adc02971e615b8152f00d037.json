{
  "title": "High performance database joins with pandas DataFrame, more benchmarks",
  "link": "",
  "published": "2012-01-05T00:00:00-08:00",
  "updated": "2012-01-05T00:00:00-08:00",
  "author": {
    "name": "Wes McKinney"
  },
  "id": "tag:wesmckinney.com,2012-01-05:/blog/high-performance-database-joins-with-pandas-dataframe-more-benchmarks/",
  "summary": "<p>I posted a <a href=\"http://wesmckinney.com/blog/?p=395\" title=\"Blog post\" target=\"_blank\">brief article</a> with some preliminary benchmarks for the new merge/join infrastructure that I've built in pandas. I compared the performance with <code>base::merge</code> in R which, as various <a href=\"http://twitter.com/#!/hadleywickham\" title=\"Hadley\" target=\"_blank\">folks</a> in the R community have pointed out, is fairly slow. There are a few other more intelligently-implemented â€¦</p>",
  "content": "<p>I posted a <a href=\"http://wesmckinney.com/blog/?p=395\" title=\"Blog post\" target=\"_blank\">brief article</a> with some preliminary benchmarks for the new merge/join infrastructure that I've built in pandas. I compared the performance with <code>base::merge</code> in R which, as various <a href=\"http://twitter.com/#!/hadleywickham\" title=\"Hadley\" target=\"_blank\">folks</a> in the R community have pointed out, is fairly slow. There are a few other more intelligently-implemented functions available in CRAN, in particular <code>plyr::join</code> in <a href=\"http://plyr.had.co.nz/\" title=\"plyr\" target=\"_blank\">plyr</a> and the merge implemented for <code>data.table</code> objects in the <a href=\"http://cran.r-project.org/web/packages/data.table/index.html\" title=\"data.table\" target=\"_blank\">data.table</a> package.</p>\n<p>Lastly, <a href=\"http://twitter.com/#!/seanjtaylor\" title=\"Sean Taylor\" target=\"_blank\">Sean Taylor</a> contributed a <a href=\"http://twitter.com/#!/seanjtaylor/status/154248028113477632\" title=\"SQLite3\" target=\"_blank\">benchmark for SQLite3</a>, by accounts the most widely deployed SQL engine.</p>\n<p>So anyway, here are the two benchmarks I'm interested in to get a sense of the large-ish data runtime of these algorithms:</p>\n<ul>\n<li>\n<p>Many-to-one joins. In these benchmarks I have a 80,000 row table with 10 copies of 8,000 key pairs and an 8,000 row table with a single copy of another 8,000 key pairs, only 6,000 of which are found in the larger table. The result of a left join between these tables should have 80,000 rows, an inner join 60,000, and an outer join 82,000.</p>\n</li>\n<li>\n<p>Many-to-many joins. To keep things simple I use the same tables as above except the right able is the table above stacked on itself. You can do the combinatorics here, but the outer join between these two tables has 144,000 rows.\n<strong>Note:</strong> that <code>plyr::join</code> does not implement (or least I've been told to avoid) many-to-many joins so I only run the many-to-one benchmarks for that.</p>\n</li>\n</ul>\n<p>I've normalized the results by the minimum runtime (which is pandas in all cases):</p>\n<p><strong>UPDATE (1/6/2012):</strong> <a href=\"https://twitter.com/#!/jaredlander\" title=\"Jared Lander\" target=\"_blank\">Jared Lander</a> pointed out that <code>data.table</code> is capable of much faster left and right joins by using the syntax <code>left[right]</code> instead of <code>merge(left, right, all.y=True)</code>. I updated the benchmarks below and added the right join results which shows <code>data.table</code> performing very admirably.</p>\n<p><center></p>\n<table border=\"0\">\n<thead>\n<tr>\n<th><center>pandas vs R merge benchmarks</center></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><center><strong>Many-to-one</strong></td></tr>\n<tr>\n<td>\n<center>\n<table border=\"1\">\n  <thead>\n    <tr>\n      <th></th>\n      <th>pandas</th>\n      <th>data.table</th>\n      <th>plyr</th>\n      <th>base::merge</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n      <td><strong>inner</strong></td>\n      <td> 1</td>\n      <td> 5.905</td>\n      <td> 6.35</td>\n      <td> 13.29</td>\n    </tr>\n    <tr>\n      <td><strong>outer</strong></td>\n      <td> 1</td>\n      <td> 10.05</td>\n      <td> 9.209</td>\n      <td> 20.25</td>\n    </tr>\n    <tr>\n      <td><strong>left</strong></td>\n      <td> 1</td>\n      <td> 2.849</td>\n      <td> 5.918</td>\n      <td> 14.93</td>\n    </tr>\n    <tr>\n      <td><strong>right</strong></td>\n      <td> 1</td>\n      <td> 2.05</td>\n      <td> 2.923</td>\n      <td> 16.91</td>\n    </tr>\n  </tbody>\n</table>\n</center>\n</td></tr>\n<tr>\n<td><center><strong>Many-to-many</strong></td></tr>\n<tr>\n<tr>\n<td><center><table border=\"1\">\n  <thead>\n    <tr>\n      <th></th>\n      <th>pandas</th>\n      <th>data.table</th>\n      <th>plyr</th>\n      <th>base::merge</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n      <td><strong>inner</strong></td>\n      <td> 1</td>\n      <td> 5.194</td>\n      <td> 5.223</td>\n      <td> 18.87</td>\n    </tr>\n    <tr>\n      <td><strong>outer</strong></td>\n      <td> 1</td>\n      <td> 10</td>\n      <td> 6.903</td>\n      <td> 33.75</td>\n    </tr>\n    <tr>\n      <td><strong>left</strong></td>\n      <td> 1</td>\n      <td> 2.528</td>\n      <td> 4.688</td>\n      <td> 24.46</td>\n    </tr>\n    <tr>\n      <td><strong>right</strong></td>\n      <td> 1</td>\n      <td> 1.681</td>\n      <td> 2.05</td>\n      <td> 25.24</td>\n    </tr>\n  </tbody>\n</table></center>\n</td></tr>\n</tbody>\n</table>\n<p></center></p>\n<p>SQLite3 Benchmarks</p>\n<p>A bit of care needs to be taken with SQLite3 benchmarks because the time to fetch the table from the database cursor (even though this is an <i>in-memory</i> SQLite database) is <strong>very</strong> significant. The performance as you can imagine is also quite different with and without indexes.</p>\n<p>Here is the basic code to insert the data into SQLite:</p>\n<div class=\"github\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"nn\">sqlite3</span>\n<span class=\"n\">create_sql_indexes</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>\n<span class=\"n\">conn</span> <span class=\"o\">=</span> <span class=\"n\">sqlite3</span><span class=\"o\">.</span><span class=\"n\">connect</span><span class=\"p\">(</span><span class=\"s1\">&#39;:memory:&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">execute</span><span class=\"p\">(</span><span class=\"s1\">&#39;create table left( key varchar(10), key2 varchar(10), value int);&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">execute</span><span class=\"p\">(</span><span class=\"s1\">&#39;create table right( key varchar(10), key2 varchar(10), value2 int);&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">executemany</span><span class=\"p\">(</span><span class=\"s1\">&#39;insert into left values (?, ?, ?)&#39;</span><span class=\"p\">,</span>\n                 <span class=\"nb\">zip</span><span class=\"p\">(</span><span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"n\">key2</span><span class=\"p\">,</span> <span class=\"n\">left</span><span class=\"p\">[</span><span class=\"s1\">&#39;value&#39;</span><span class=\"p\">]))</span>\n<span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">executemany</span><span class=\"p\">(</span><span class=\"s1\">&#39;insert into right values (?, ?, ?)&#39;</span><span class=\"p\">,</span>\n                 <span class=\"nb\">zip</span><span class=\"p\">(</span><span class=\"n\">right</span><span class=\"p\">[</span><span class=\"s1\">&#39;key&#39;</span><span class=\"p\">],</span> <span class=\"n\">right</span><span class=\"p\">[</span><span class=\"s1\">&#39;key2&#39;</span><span class=\"p\">],</span> <span class=\"n\">right</span><span class=\"p\">[</span><span class=\"s1\">&#39;value2&#39;</span><span class=\"p\">]))</span>\n<span class=\"c1\"># Create Indices</span>\n<span class=\"k\">if</span> <span class=\"n\">create_sql_indexes</span><span class=\"p\">:</span>\n    <span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">execute</span><span class=\"p\">(</span><span class=\"s1\">&#39;create index left_ix on left(key, key2)&#39;</span><span class=\"p\">)</span>\n    <span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">execute</span><span class=\"p\">(</span><span class=\"s1\">&#39;create index right_ix on right(key, key2)&#39;</span><span class=\"p\">)</span>\n</code></pre></div>\n\n<p>With no indexes, here is a comparison of <strong>just</strong> the SQL execution time vs. the total pandas execution time for the many-to-one case described above:</p>\n<p><center></p>\n<table border=\"1\">\n  <thead>\n    <tr>\n      <th></th>\n      <th>sqlite3</th>\n      <th>pandas</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n      <td>inner</td>\n      <td> 0.02328</td>\n      <td> 0.01799</td>\n    </tr>\n    <tr>\n      <td>outer</td>\n      <td> 0.02324</td>\n      <td> 0.01943</td>\n    </tr>\n    <tr>\n      <td>left</td>\n      <td> 0.02324</td>\n      <td> 0.01923</td>\n    </tr>\n  </body>\n</table>\n<p></center></p>\n<p>So pandas very slightly edges out SQLite with no indexes. Note that it takes <strong>~300ms</strong> (on my machine) to fetch the data out of the database into a list of tuples, so if you consider that, pandas is really crushing it by doing everything in memory.</p>\n<p>The results after adding indexes are pretty indistinguishable as far as I can tell because the fetch time (which involves creating and populating a large number of Python tuples) dwarfs the join time it appears. The execute + fetch time varies between 310-340 ms for all three join types, with an without indexes, for the many-to-one case. The many-to-many case varies between 420-490 ms, whereas pandas is <strong>22-25ms</strong>!</p>\n<p><strong>UPDATE:</strong> After some thought and discussions with people, these benchmarks are not fair to SQLite. A more appropriate benchmark would be to create the joined table inside the database using a statement like</p>\n<div class=\"github\"><pre><span></span><code><span class=\"k\">CREATE</span><span class=\"w\"> </span><span class=\"k\">TABLE</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"k\">AS</span><span class=\"w\"></span>\n<span class=\"k\">SELECT</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"k\">FROM</span><span class=\"w\"> </span><span class=\"k\">left</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"k\">INNER</span><span class=\"w\"> </span><span class=\"k\">JOIN</span><span class=\"w\"> </span><span class=\"k\">right</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"k\">ON</span><span class=\"w\"> </span><span class=\"k\">left</span><span class=\"p\">.</span><span class=\"k\">key</span><span class=\"o\">=</span><span class=\"k\">right</span><span class=\"p\">.</span><span class=\"k\">key</span><span class=\"w\"></span>\n<span class=\"w\">       </span><span class=\"k\">AND</span><span class=\"w\"> </span><span class=\"k\">left</span><span class=\"p\">.</span><span class=\"n\">key2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">right</span><span class=\"p\">.</span><span class=\"n\">key2</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n\n<p>Here are new benchmarks using this SQL statement:</p>\n<p><center></p>\n<table border=\"0\">\n<thead>\n<tr>\n<th>Many-to-one</th>\n<th>Many-to-many</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n<table border=\"1\">\n  <thead>\n    <tr>\n      <th></th>\n      <th>pandas</th>\n      <th>sqlite3</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n      <td>inner</td>\n      <td> 0.01674</td>\n      <td> 0.04187</td>\n    </tr>\n    <tr>\n      <td>outer</td>\n      <td> 0.01882</td>\n      <td> 0.04534</td>\n    </tr>\n    <tr>\n      <td>left</td>\n      <td> 0.01851</td>\n      <td> 0.04514</td>\n    </tr>\n  </body>\n</table>\n</td>\n<td><table border=\"1\">\n  <thead>\n    <tr>\n      <th></th>\n      <th>pandas</th>\n      <th>sqlite3</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n      <td>inner</td>\n      <td> 0.02091</td>\n      <td> 0.06733</td>\n    </tr>\n    <tr>\n      <td>outer</td>\n      <td> 0.02266</td>\n      <td> 0.06968</td>\n    </tr>\n    <tr>\n      <td>left</td>\n      <td> 0.02203</td>\n      <td> 0.06882</td>\n    </tr>\n  </body>\n</table>\n</td></tr>\n</tbody>\n</table>\n<p></center></p>\n<p>So pandas still significantly outperforms SQLite3 (even with SQL indexes as in these benchmarks). But it's not totally apples-to-apples as SQLite3 is able to perform joins on extremely large data sets on disk.</p>\n<h2>Conclusions</h2>\n<p>As far as I can tell, pandas now has one of the fastest in-memory database join operators out there. If you're using Python to do relational algebra, you'd be crazy to pick SQLite3 over pandas due to the high cost of reading and writing large data sets (in the form of Python tuples) to SQL format.</p>\n<h2>Code links</h2>\n<ul>\n<li><a href=\"https://github.com/wesm/pandas/blob/master/bench/bench_merge.R\" title=\"bench_merge.R\" target=\"_blank\">R code</a></li>\n<li><a href=\"https://github.com/wesm/pandas/blob/master/bench/bench_merge.py\" title=\"bench_merge.py\" target=\"_blank\">pandas code</a></li>\n<li><a href=\"https://github.com/wesm/pandas/blob/23669822819808bbaeb6ea36a6b2ef98026884db/bench/bench_merge_sqlite.py\" title=\"bench_merge_sqlite.py\" target=\"_blank\">SQLite3 (Python) code</a></li>\n</ul>"
}