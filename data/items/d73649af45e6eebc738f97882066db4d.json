{
  "title": "conda-forge and PyData's CentOS moment",
  "link": "",
  "published": "2016-04-20T09:00:00-07:00",
  "updated": "2016-04-20T09:00:00-07:00",
  "author": {
    "name": "Wes McKinney"
  },
  "id": "tag:wesmckinney.com,2016-04-20:/blog/conda-forge-centos-moment/",
  "summary": "<p><strong>Summary</strong>: It's finally time we worked as a community to create a reliable,\ncommunity-governed repository of trusted Python binary package artifacts, just\nlike Linux, R, Java, and many other open source tool ecosystems have already\ndone. Enterprise-friendly platform distributions do play an important role,\nthough. I examine the various nuances within. I also talk about the new\n<a href=\"https://conda-forge.github.io\">conda-forge</a> project which may offer the way forward.</p>",
  "content": "<p><strong>Summary</strong>: It's finally time we worked as a community to create a reliable,\ncommunity-governed repository of trusted Python binary package artifacts, just\nlike Linux, R, Java, and many other open source tool ecosystems have already\ndone. Enterprise-friendly platform distributions do play an important role,\nthough. I examine the various nuances within. I also talk about the new\n<a href=\"https://conda-forge.github.io\">conda-forge</a> project which may offer the way forward.</p>\n\n\n<h2>Python environment management hell: a personal story</h2>\n<p>When I needed to get Python code using \"primordial pandas\" into production at\nAQR in 2008, the hardest part by far was the \"installation problem\". At that\ntime we didn't have a centralized cluster framework for running all production\njobs; many processes where Python needed to run were on Windows desktops\nsitting under people's desks. Later, in 2009, we bought a rack of machines and\nwe wrote a distributed task queue and scheduler (similar to Celery) that ran on\nthese systems, but they were still Windows.</p>\n<p>I didn't want to have my efforts to use more Python to be stymied, so I engaged\non a stressful tango with our IT staff to get consistent Python environments\nwith NumPy, SciPy, matplotlib, and other heavy packages deployed on dozens of\nWindows desktops. Part of the difficulty was Windows, but the bigger issue was\nthat installing a \"blessed\" Python environment was not as simple as \"hey, run\nthis one weird batch script\". It required a lot of typing, clicking and\nsometimes force-quitting <code>python.exe</code> (and a large helping of tears and\nsadness).</p>\n<p>R, where I had also done a lot of work, comparatively had its act completely\ntogether. Install R, then run <code>install.packages(c(...))</code> and you were\ndone. Like magic. By comparison, especially on Windows, installing anything\ncontaining C extensions or depending on 3rd-party libraries using <code>pip</code> was\nunreliable.</p>\n<h2>Binary package installers: apt, brew, yum, conda, enstaller, brew, and friends</h2>\n<p>One of the ways to solve the packaging hell is to have a tool that can analyze\npackage dependency graphs and download and install the appropriate binary\nartifacts from one or more trusted channels. Strong emphasis here must be put\non the word <strong>trusted</strong>.</p>\n<p>Installing any software, whether open source or proprietary, is a risky\nproposition because you are purposefully executing code written by someone\nelse. You may be giving that software access to your networks, data, secrets\n(security credentials, SSH keys), or even existing production processes. If you\nare a business working with sensitive data, it is justifiable to be extremely\nparanoid about the provenance of any x86 instruction executed on hardware under\nyour control. The most sensitive of businesses (e.g. 3-letter US government\nagencies) may use air-gapping to protect against hackers or malicious code run\nfrom within their walls.</p>\n<p>The way around the trust issue is to use a packaging tool, like <code>apt</code> or <code>yum</code>,\nalong with a trusted binary artifact repository. Often the binary artifacts are\nprovided by a company you trust not to modify the code maliciously\n(e.g. inserting telemetry or malware code) in binary builds of otherwise open\nsource software. The packaging tool verifies a MD5 or SHA1 hash of the\nartifacts to make sure that a man-in-the-middle has not tampered with the\ncompiled code inside. Turns out this is not that unrealistic, <a href=\"http://arstechnica.com/security/2016/03/first-mac-targeting-ransomware-hits-transmission-users-researchers-say/\">as recently\nhappened with Transmission</a>.</p>\n<h2>Platform distributions: making open source work for the enterprise</h2>\n<p>As soon as a collection of related open source projects becomes viable as a\nsolution to a major business problem (obvious examples: Hadoop, Linux, R,\nPython, Kafka, etc.), a common business strategy is to create a <strong>platform\ndistribution</strong>, a big bundle of code, with the intent of making using open\nsource software more palatable for use by large companies.</p>\n<p>The notion of a platform distribution is appealing to enterprise users for many\nreasons. The distribution provider is handling a bunch of annoying problems for\nyou:</p>\n<ul>\n<li>Assembling components and all of the correct versions which are known to\n  <strong>work well together</strong>.</li>\n<li>Packaging components together and making them <strong>easy to install</strong>.</li>\n<li><strong>Compiling binaries</strong> for multiple platforms and running the test suites for\n  individual components to verify a valid build.</li>\n<li>Performing <strong>integration testing</strong> to verify that the components work well\n  together.</li>\n<li>Providing tools for <strong>upgrading components</strong> over time</li>\n</ul>\n<p>Usually, the distribution gets its own umbrella version number, like \"Red Hat\nEnterprise Linux 5\" to indicate the \"blessed\" collection of software.</p>\n<p>Making money from 100% open-source platforms is very difficult. One of the more\nsuccessful models used is known as \"<strong>open core</strong>\" or (increasingly) \"<strong>hybrid\nopen source</strong>\", where anyone (individuals or businesses) can download and use\nthe open source components for free, but you can buy services, support,\nindemnity, and valuable add-on proprietary software from the platform vendor.</p>\n<p>One of the most important aspects of paid support for open source is having\npriority bug fixes and patched builds when something goes wrong in\nproduction. All software has bugs, and by the inherently anarchic nature of\nopen source software, paying for peace of mind is something many big companies\nare willing to do.</p>\n<h2>The importance of community-governed package channels</h2>\n<p>In the late 1990s and early 2000s, there were many efforts to create\ncommunity-led Linux distributions. Red Hat was founded in 1993, and as Red Hat\nand other enterprise vendors worked to commercialize open source Linux in the\nenterprise, I suspect the push for community-governed distributions became all\nthe stronger. I won't present a revisionist history for what motivated the\ncreators of Debian, CentOS, and others, but the commercialization of Linux\nlikely played some significant role.</p>\n<p>In Linux, like other open source ecosystems, one of the most important\ncomponents outside of the Linux kernel itself is the package repository. From a\nminimal kernel installation with networking and a package manager, you can\ninstall a complete system. Thus, the stewardship of the source and binary\npackages is extremely important, including:</p>\n<ul>\n<li><strong>Governance</strong>: in general, no single commercial entity can decide what\n  packages can be installed or not installed</li>\n<li><strong>Quality standards</strong>: Packages are deemed of acceptable quality and suitable\n  in a production environment</li>\n<li><strong>Build verification</strong>: a binary's build has been tested as appropriate for\n  that package</li>\n<li><strong>Trusted distribution</strong>: Packages are signed so that package managers and\n  users can trust the provenance of a binary build</li>\n<li><strong>Dependency management</strong>: Installing a package also installs its\n  dependencies, which have been similarly verified and known to work together</li>\n</ul>\n<p>Each distribution may have different goals. CentOS, for example, aims for\ncompatibility with Red Hat Enterprise Linux and accordingly uses the <code>yum</code>\npackage management tool. Debian and Ubuntu, by contrast, don't target\ncompatibility with any enterprise distributions, but provide multiple flavors\nfocusing respectively on long-term stability versus bleeding-edge innovation.</p>\n<p>Community-led packaging and distribution is not unique to Linux: R, for\nexample, has <a href=\"http://cran.r-project.org\">CRAN</a> and the <a href=\"https://cran.r-project.org/web/packages/policies.html\">CRAN submission policy</a>. It also has\n<a href=\"https://r-forge.r-project.org/\">R-Forge</a> to provide a community-governed service for posting project\nbuilds.</p>\n<h2>Python: Enterprise distributions and <code>conda</code></h2>\n<p>Anaconda is a freely-available Python platform distribution created by the\n<a href=\"https://www.crunchbase.com/organization/continuum-analytics\">venture-backed start-up Continuum Analytics</a> (folks I know quite well!),\nthat has grown extremely popular in recent years. It plays a similar role as\nany other enterprise platform distribution based on open source software, just\nlike Red Hat (Linux), Revolution Analytics (R), or Cloudera\n(Hadoop. Disclaimer: this where I work) have done.</p>\n<p>Anaconda is not the only Python platform distribution, nor the first. Canopy\n(formerly EPD: Enthought Python Distribution) preceded it, and many of the\nsame people have worked on both projects.</p>\n<p>One of the sources of Anaconda's success is that it makes cross-platform Python\nenvironment management much easier than it used to be, and Continuum provides\ntrusted builds of multiple Python versions and all of the Python and non-Python\nlibrary dependencies needed to assemble a complete Python data analysis\nenvironment.</p>\n<p>At the heart of Anaconda is a new packaging tool <code>conda</code>. I won't go into the\ntechnical or open-source-politics reasons why Continuum created a new binary\npackaging tool for installation and dependency management for Anaconda. The\nbottom line is that it:</p>\n<ul>\n<li>Provides an alternative to the pip / distribute / setuptools / virtualenv\n  stack: use one command-line for everything and in general it <em>just works</em>.</li>\n<li>Works well for managing both Python and non-Python (e.g. C/C++) library\n  dependencies</li>\n<li>Works consistently on all major platforms (Windows, OS X, Linux)</li>\n<li>Is freely available (the conda tool)</li>\n</ul>\n<p>In practice, conda works extremely well. It's the packaging tool I wish existed\nin 2008, and I'm glad we got it eventually!</p>\n<p>The downside of the Anaconda distribution itself is that ultimately, just like\nother enterprise platform companies, Continuum will inevitably be faced with\ndecisions that pit the needs of enterprise customers (valuing stability and\nlong-term support) with the community (valuing innovation and community\ngovernance). The most obvious source of conflict would be getting new packages\nincluded in Anaconda requiring a lot of work (from Continuum employees) to\nbuild, test, and package. Another would be providing updated builds for\nprojects that only matter to a small, but passionate subset of users (which may\nnot be paying customers).</p>\n<p>Community governance of the <strong>code</strong> is typically handled through organizations\nlike the Apache Software Foundation. This is a whole different beast of a\nproblem, and I'll write about my thoughts on open source project governance\nsome other time.</p>\n<h2>conda-forge: Community-led packaging using conda</h2>\n<p>The point of this is not to say \"Anaconda is bad for the Python\ncommunity\". Quite the contrary: Anaconda has been and continues to be good for\nthe community, and <code>conda</code> is an excellent packaging tool. Bigger picture:\nacceptance of the Python data stack in the enterprise is <strong>existentially\nimportant</strong> for the continued succcess and growth of the ecosystem. Just like\nLinux needed RHEL and Hadoop needed CDH, PyData needed Anaconda to get where it\nhas gotten now. High quality projects like pandas and scikit-learn were not\nenough by themselves.</p>\n<p>Having a community-governed package channel for conda and a community process\nfor submitting, verifying, and storing signed project releases would be\nideal. Additionally, there would need to be shared build and continuous\nintegration infrastructure so that we aren't all having to install Visual\nStudio on our desktops to be able to create reliable Windows builds.</p>\n<p>Some will note that there is the <a href=\"https://anaconda.org\">anaconda.org</a>, a product created by\nContinuum for free and paid use (for private builds). The problem with\nanaconda.org is that it is mainly a place to put binary artifacts.</p>\n<p>Given all this, I was incredibly excited when I learned about\n<a href=\"https://conda-forge.github.io\">conda-forge</a>. If we all as a community can throw our weight behind this\neffort, I believe we can achieve:</p>\n<ul>\n<li>A community-led process for posting trusted binary builds of projects, like\n  CRAN has worked for many years for R.</li>\n<li>Easier integration testing amongst groups of projects, especially on Windows</li>\n<li>Someday, a community-governed Anaconda-like Python distribution</li>\n</ul>\n<p>It's complicated, though. Doing this well will require a lot of money and\npeople's time. The R community has sustained itself through the support of\nacademic institutions over the years which the Python data stack doesn't have\nas much of. <a href=\"https://numfocus.org\">NumFOCUS</a> may be able to provide a fiscal conduit for\ntax-deductible support of conda-forge.</p>\n<h2>Summary</h2>\n<p>I've long been envious of the community package management infrastructure that\nthe R community has, But many enterprises prefer to use \"blessed\" platform\ndistributions, e.g. R has Revolution R (now Microsoft R Open). So, we need\nboth, and I encourage readers to help where possible, either through\ndevelopment or money, to help the nascent community effort (i.e. conda-forge)\ngrow.</p>"
}