{
  "title": "Fitting faces",
  "description": "<h2>An explanation of clmtrackr</h2>\n\n<img src=\"http://auduno.github.io/clmtrackr/docs/media/header3.jpg\" alt=\"image\"/><p>A while ago I put out a semi-finished version of <a href=\"https://github.com/auduno/clmtrackr\">CLMtrackr</a>, which is a javascript library for fitting a facial model to faces in images or video. Fitting a facial model is useful in cases where you need precise positions of facial features, such as for instance emotion detection, face masking and person identification. Though the tracking is pretty processor-intensive, we manage to reach real-time tracking in modern browsers, even though it&rsquo;s implemented in javascript. If you&rsquo;re interested in seeing some applications of CLMtrackr, check out the demos of <a href=\"http://auduno.github.io/clmtrackr/examples/facesubstitution.html\">face substitution</a>, <a href=\"http://auduno.github.com/clmtrackr/face_deformation_video.html\">face deformation</a>, or <a href=\"http://auduno.github.io/clmtrackr/examples/clm_emotiondetection.html\">emotion detection</a>.</p>\n\n<p>In this post, I&rsquo;ll explain a few details about how CLMtrackr is put together.</p> \n\n<!-- more -->\n<br/><p>First off, here&rsquo;s an example of CLMtrackr tracking a face real-time:</p>\n\n<figure><iframe src=\"http://player.vimeo.com/video/75659453\" width=\"360\" height=\"281\" frameborder=\"0\" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>\n\t<figcaption>An example of fitting/tracking a face in the canonical <a href=\"http://www-prima.inrialpes.fr/FGnet/data/01-TalkingFace/talking_face.html\">talking face</a> video</figcaption></figure><h4>How does CLMtrackr work:</h4>\n\n<p>CLMtrackr is based on the algorithms described in <a href=\"http://www.ri.cmu.edu/pub_files/2009/9/CameraReady-6.pdf\">this paper</a> by Jason Saragih &amp; Simon Lucey, more precisely &ldquo;Face Alignment through Subspace Constrained Mean-Shifts&rdquo;. The explanation in the paper is pretty dense, so I&rsquo;ll try to do a simpler explanation here.</p>\n\n<p>Our aim is to fit a facial model to a face in an image or video from an approximate initialization. In our case the facial model consists of 70 points, see below.</p>\n\n<figure><img src=\"http://auduno.github.io/clmtrackr/docs/media/facemodel.png\" alt=\"the face model\"/><figcaption>The facial model</figcaption></figure><p>The algorithm fits the facial model by using 70 small classifiers, i.e. one classifier for each point in the model. Given an initial approximate position, the classifiers search a small region (thus the name &lsquo;local&rsquo;) around each point for a better fit, and the model is then moved incrementally in the direction giving the best fit, gradually converging on the optimal fit.</p>\n\n<figure><img src=\"http://auduno.github.io/clmtrackr/docs/media/facemodel_w_filters_crop1.jpg\" alt=\"image\"/><figcaption>The model with some of the SVM kernels used for classification</figcaption></figure><p>I&rsquo;ll go on to describe the facial model and classifiers and how we create/train them.</p>\n\n<h4>Model</h4>\n\n<p>A face is relatively easy to model, since it doesn&rsquo;t really vary that much from person to person apart from posture and expression. Such a model <em>could</em> be manually built, but it is far easier to learn from annotated data, in our case faces where the feature points have been marked (annotated). Since annotating faces takes a surprisingly long time, we used some existing annotation from <a href=\"http://www.milbo.org/muct/\">the MUCT database</a> (with slight modifications), plus some faces we manually annotated ourselves.</p>\n\n<figure><img src=\"http://auduno.github.io/clmtrackr/docs/media/annotated2_small.jpg\" alt=\"annotated face\"/><figcaption>An annotated face from the MUCT database</figcaption></figure><p>To build a model from these annotations, we use Principal Component Analysis, or PCA for short. We first calculate the mean points of all the annotations, and then use PCA to extract the variations of the faces as linear combinations of vectors, or <strong>components</strong>. Very roughly explained, PCA will extract these <strong>components</strong> in order of importance, i.e. how much of the variation in face can be accounted for by each component. Since the first handful of these components manage to cover most of the variation in face postures, we can toss away the rest without any loss in model precision.</p>\n\n<p>The first components that PCA extract will usually cover basic variations from posture, such as yaw, pitch, then followed by opening and closing mouth, smile, etc.</p>\n\n<figure><iframe src=\"http://auduno.github.io/clmtrackr/docs/param_model/clm_pca.html\" width=\"500\" height=\"300\" style=\"border:0px;\"></iframe>\n\t<figcaption>The first of the extracted components</figcaption></figure><p>Any facial pose can then be modelled as the mean points plus weighted combinations of these components, and the weights can be thought of as &ldquo;parameters&rdquo; for the facial model. Check out the complete model <a href=\"http://auduno.github.com/clmtrackr/examples/modelviewer_pca.html\">here</a></p>\n\n<p>From the PCA, we also store the eigenvalues of each component, which tells us the standard deviation of the weights of each component according to the facial poses in our annotated data <a href=\"#footnote1\"><sup>[1]</sup></a>, which is very useful when we want to regularize the weights in the optimization step.</p>\n\n<p><em>Note</em> : PCA is not the only method you can use to extract a parametric face model. You could also use for instance Sparse PCA which will lead to &ldquo;sparse&rdquo; transformations. Sparse PCA doesn&rsquo;t give us any significant improvements in fitting/tracking, but often gives us components which seem more natural, which is useful for adjusting the regularization of each components weights manually. Test out a parametric face model based on <a href=\"http://auduno.github.com/clmtrackr/examples/modelviewer_spca.html\">Sparse PCA</a>.</p>\n\n<br/><p class=\"footnote\" id=\"footnote1\">[1] : this also means that it is important that the faces used for training the model is a good selection of faces in a variety of different poses and expressions, otherwise we end up with a model which is too strictly regularized and doesn&rsquo;t manage to model &ldquo;extreme&rdquo; poses</p>\n\n<h4>Patches</h4>\n\n<p>As I mentioned, we have one classifier for each each point in the model, so 70 classifiers altogether for our model. To train these classifiers, say for instance the classifier for point 27 (the left pupil), we crop a X by X patch centered on the marked position of point 27 in each of our annotated facial images. This set of patches are then used as input for training a classifier.</p>\n\n<figure><img src=\"http://auduno.github.io/clmtrackr/docs/media/training_patches.png\" alt=\"training\"/><figcaption>Training a classifier on patches from the annotated faces</figcaption></figure><p>The classifier we use could be any classifier suited for image classification, such as Logistic Regression, SVM, regular Correlation Filters and even Random Forests, but in our case we implemented a logistic regression classifier with an SVM kernel (which is what the original paper suggests), and also a MOSSE filter. More about implementation issues of these below.</p>\n\n<p>When using these classifiers in fitting the model, we crop a searchwindow around each of our initial approximate positions, and apply the respective classifier to a grid of Y by Y pixels within the searchwindow. We thus get a Y * Y &ldquo;response&rdquo; output which maps the probability of each of these pixels being the &ldquo;aligned&rdquo; feature point.</p>\n\n<figure><img src=\"http://auduno.github.io/clmtrackr/docs/media/response_fig2b.jpg\" alt=\"the response from the patch\"/><figcaption>The cropped patch and &ldquo;response&rdquo; for the left pupil</figcaption></figure><h4>Optimization</h4>\n\n<p>So, given that we have the responses from our classifiers, how do we apply this information to fit the facial model in the best possible way? </p>\n\n<p>For each of the responses, we calculate the way the model should move in order to go to the region with highest likelihood. This is calculated by mean-shift (which is roughly equivalent to gradient descent). We then regularize this movement by constraining the &ldquo;new positions&rdquo; to the coordinate space spanned by the facial model. In this way we ensure that the points of the model does not move in a manner that is inconsistent with the model overall. This process is done iteratively, which means the facial model will gradually converge towards the optimal fit [2].</p>\n\n<br/><p class=\"footnote\">[2] : this happens to be a case of expectation-maximization, where finding the best movement according to responses is the expectation step and regularization to model is the maximization step</p>\n\n<h4>Initalization &amp; checking</h4>\n\n<p>One thing that has to be noted is that since the searchwindows we use are pretty small, the model is not able to fit to a face if is outside the &ldquo;reach&rdquo; of these searchwindows [3]. Therefore it is critical that we initialize the model in a place not too far from it&rsquo;s &ldquo;true&rdquo; position. To do so, we first use a face detector to find the rough bounding box of the face, and then identify the approximate positions of eyes and nose via a correlation filter. We then use procrustes analysis to roughly fit the mean facial model to the found positions of the eyes and nose, and use this as the initial placement of the model.</p>\n\n<p>Altogether, this is what initialization and fitting looks like when slowed down:</p>\n\n<figure><img src=\"http://auduno.github.io/clmtrackr/docs/media/anim1.gif\" alt=\"fitting the face model\"/><figcaption>The initialization and fitting of the face model</figcaption></figure><p>While we&rsquo;re tracking and fitting the face, we also need to check that the model hasn&rsquo;t drifted too far away from the &ldquo;true&rdquo; position of the face. A way to do this, is to check once every second or so that the approximate region that the face model covers, seems to resemble a face. We do this using the same classifiers as on the patches, logistic regression, only trained on the entire face. If the face model does not seem to be on top of a face, we reinitialize the face detection.</p>\n\n<br/><p class=\"footnote\">[3] : we could of course just make the searchwindows bigger, but every pixel we widen the searchwindow increases the time to fit exponentially, so we prefer to use small windows</p>\n\n<h4>Performance/implementation issues</h4>\n\n<p>The straightforward implementation of this algorithm in javascript is pretty slow. The main bottleneck is the classifiers which are called several times for each point in the model on every iteration. Depending on the size of the searchwindow (n) and the size of the classifier patches (m), the straightforward implementation is an O(m^2 * n^2) operation. Using convolution via FFT we can bring it down to O(n log(n)), but this is still slower than what we want. Fortunately, the SVM kernels lends itself excellently to fast computation via the GPU, which we can do via WebGL, available on most browsers these days. Of course, webGL was never meant to be used for scientifical computing, only graphical rendering, so we have to jump through some hoops to get it to work.</p>\n\n<p>The main problem we have is that while most graphic cards support floating point calculations and we can easily <em>import</em> floating points to the GPU, there is no way to <em>export</em> floating point numbers back to javascript in WebGL. We are only able to <em>read</em> the pixels (which only support 8-bit ints) rendered by the GPU to the canvas. To get around this, we have to use a trick : we &ldquo;pack&rdquo; our 32-bit floats into four 8-bit ints, &ldquo;export&rdquo; them by drawing them to canvas, then read the pixels and &ldquo;unpack&rdquo; them back into 32-bit floats again on the javascript side. In our case we split the floats across each of the four channels (R,G,B,A), which means that each rendered pixel holds one float. Though this seems like a lot of hassle for some performance tweaks, it&rsquo;s worth it, since the WebGL implementation is twice as fast as the javascript implementation.</p>\n\n<figure><img src=\"http://auduno.github.io/clmtrackr/docs/media/packing.png\" alt=\"packing and unpacking floats in the GPU\"/><figcaption>Packing and unpacking the floats from the GPU</figcaption></figure><p>Once we get the responses, we have to deal with the matrix math in order to do regularization. This is another bottleneck, and really exposes the huge differences in speed of numerical computing between the javascript engines of the different browsers. I used the excellent library &ldquo;numeric.js&rdquo; to do these calculations - it currently seems to be the fastest and most full-featured matrix library out there for javascript, and I highly recommend it to anyone thinking of doing matrix math in javascript.</p>\n\n<p>In our final benchmark, we managed to run around 70 iterations of the algorithm (with default settings) per second in Chrome, which is good enough to fit and track a face in real-time.</p>\n\n<h4>Improvements</h4>\n\n<p>CLMtrackr is by no means perfect, and you may notice that it doesn&rsquo;t fit postures that deviates from the mean shape all that well. This is due to the classifiers not being discriminate enough. We tried training the classifiers on the gradient of the patches, but this is slower and not all that much better overall. Optimally each response would be an ensemble of SVM, gradient and local binary filters (which I never got around to implementing), but for the current being, this would probably run too slow. If you have some ideas to fix this, let me know!</p>\n\n<p>Another improvement which might improve tracking is using a 3D model instead of a 2D model. Creating a 3D model is however a more difficult task, since it involves inferring a 3D model from 2D images, and I could never get around to implementing it.</p>\n\n<p>Oh, and there&rsquo;s also things such as structured SVM learning, but that will have to wait until another time.</p>\n\n<br/><p>Have you used CLMtrackr for anything cool? Let me know! If you liked this article, you should <a href=\"http://www.twitter.com/matsiyatzy\">follow me on twitter</a>.</p>",
  "link": "https://auduno.tumblr.com/post/61888277175",
  "guid": "https://auduno.tumblr.com/post/61888277175",
  "pubDate": "Sun, 05 Jan 2014 16:24:32 +0100"
}