{
  "title": "Crazy Expression Parsing",
  "link": "http://artem.sobolev.name/posts/2013-03-30-crazy-expression-parsing.html",
  "description": "<p>Suppose we have an expression like <code>(5+5 * (x^x-5 | y && 3))</code> and we’d like to get some computer-understandable representation of that expression, like:</p>\n<p><code>ADD Token[5] (MUL Token[5] (AND (BIT_OR (XOR Token[x] (SUB Token[x] Token[5])) Token[y]) Token[3])</code></p>\n<p>In case if you don’t know how to do that or are looking for the solutin right now, you should know that I’m not going to present a correct solution. This post is just a joke. You should use either a <a href=\"http://en.wikipedia.org/wiki/Shunting-yard_algorithm\" title=\"Shunting-yard algorithm — Wikipedia\">Shunting-yard algorithm</a> or a <a href=\"http://en.wikipedia.org/wiki/Recursive_descent_parser\">recursive descent parser</a>.</p>\n<p>So if you’re ready for madness… Let’s go! <!--more--></p>\n<p>Let’s take <a href=\"http://en.wikipedia.org/wiki/Don%27t_repeat_yourself\">Don’t repeat yourself</a> principle as a justification. Moreover, let’s take it to extreme “Don’t repeat”. Indeed, why do we need to repeat what compiler’s developers already did?</p>\nHere we go\n<script src=\"https://gist.github.com/artsobolev/5273716.js\"></script>\n<p>In case you’re wondering what the heck is going on: all constants are converted to instances of <code>Token</code> class, for which I overloaded all the operators. Overloading is done in a way to preserve structure of an expression. The only thing we have to do then is to extract that information. In case you’re not familiar with C++, I recommend you to read something about operator overloading.</p>\n<p>As you can see, g++ and python are required for that “parser”. Unfortunatelly, priority of a bitwise xor is too low to serve as a power operator.</p>",
  "pubDate": "Sat, 30 Mar 2013 00:00:00 UT",
  "guid": "http://artem.sobolev.name/posts/2013-03-30-crazy-expression-parsing.html",
  "dc:creator": "Artem"
}