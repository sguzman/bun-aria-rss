{
  "id": "tag:blogger.com,1999:blog-15045980.post-2773198969790210790",
  "published": "2021-06-15T08:04:00.001-07:00",
  "updated": "2021-07-22T08:29:55.484-07:00",
  "category": "",
  "title": "How Much Testing is Enough?",
  "content": "<h2 style=\"text-align: left;\">By George Pirocanac</h2><div><br /></div><div><div><br /></div><div>A familiar question every software developer and team grapples with is, “How much testing is enough to qualify a software release?” A lot depends on the type of software, its purpose, and its target audience. One would expect a far more rigorous approach to testing commercial search engine than a simple smartphone flashlight application. Yet no matter what the application, the question of how much testing is sufficient can be hard to answer in definitive terms. A better approach is to provide considerations or rules of thumb that can be used to define a qualification process and testing strategy best suited for the case at hand. The following tips provide a helpful rubric:</div></div><div><br /></div><div><br /><ul style=\"text-align: left;\"><li>Document your process or strategy.</li><li>Have a solid base of unit tests.</li><li>Don’t skimp on integration testing.</li><li>Perform end-to-end testing for Critical User Journeys.</li><li>Understand and implement the other tiers of testing.</li><li>Understand your coverage of code and functionality.</li><li>Use feedback from the field to improve your process.</li></ul><div><br /></div></div><h2 style=\"text-align: left;\">Document your process or strategy</h2><div><br /></div><div>If you are already testing your product, document the entire process. This is essential for being able to both repeat the test for a later release and to analyze it for further improvement. If this is your first release, it’s a good idea to have a written test plan or strategy. In fact, having a written test plan or strategy is something that should accompany any product design.</div><div><br /></div><div><br /></div><h2 style=\"text-align: left;\">Have a solid base of unit tests</h2><div><br /></div><div><br /></div><div><div>A great place to start is writing unit tests that accompany the code. Unit tests test the code as it is written at the functional unit level. Dependencies on external services are either mocked or faked.&nbsp;</div></div><div><br /></div><div>A <i>mock</i> has the same interface as the production dependency, but only checks that the object is used according to set expectations and/or returns test-controlled values, rather than having a full implementation of its normal functionality.</div><div><br /></div><div>A <i>fake</i>, on the other hand, is a shallow implementation of the dependency but should ideally have no dependencies of it’s own. Fakes provide a wider range of functionality than mocks and should be maintained by the team providing the production version of the dependency. That way, as the dependency evolves so does the fake and the unit-test writer can be confident that the fake mirrors the functionality of the production dependency.</div><div><br /></div><div>At many companies, including Google, there are best practices of requiring any code change to have corresponding unit test cases that pass. As the code base expands, having a body of such tests that is executed before code is submitted is an important part of catching bugs before they creep into the code base. This saves time later both in writing integration tests, debugging, and verifying fixes to existing code.</div><div><br /></div><div><br /></div><h2 style=\"text-align: left;\">Don’t skimp on integration testing</h2><div><br /></div><div><br /></div><div>As the codebase grows and reaches a point where numbers of functional units are available to test as a group, it’s time to have a solid base of integration tests. An integration test takes a small group of units, often only two units, and tests their behavior as a whole, verifying that they coherently work together.</div><div><br /></div><div>Often developers think that integration tests can be deprioritized or even skipped in favor of full end-to-end tests. After all, the latter really tests the product as the user would exercise it. Yet, having a comprehensive set of integration tests is just as important as having a solid unit-test base (see the earlier Google Blog article, <a href=\"https://testing.googleblog.com/2020/11/fixing-test-hourglass.html\">Fixing a test hourglass</a>).</div><div><br /></div><div>The reason lies in the fact that integration tests have less dependencies than full end-to-end tests. As a result, integration tests, with smaller environments to bring up, will be faster and more reliable than the full end-to-end tests with their full set of dependencies (see the earlier Google Blog article, <a href=\"https://testing.googleblog.com/2020/12/test-flakiness-one-of-main-challenges.html\">Test Flakiness - One of the Main Challenges of Automated Testing</a>).</div><div><br /></div><div><br /></div><h2 style=\"text-align: left;\">Perform end-to-end testing for Critical User Journeys</h2><div><br /></div><div><br /></div><div>The discussion thus far covers testing the product at its component level, first as individual components (unit-testing), then as groups of components and dependencies (integration testing). Now it’s time to test the product end to end as a user would use it. This is quite important because it’s not just independent features that should be tested but entire workflows incorporating a variety of features. At Google these workflows - the combination of a critical goal and the journey of tasks a user undertakes to achieve that goal - are called Critical User Journeys (CUJs). Understanding CUJs, documenting them, and then verifying them using end-to-end testing (hopefully in an automated fashion) completes the <a href=\"https://docs.google.com/presentation/d/15gNk21rjer3xo-b1ZqyQVGebOp_aPvHU3YH7YnOMxtE/edit#slide=id.g437663ce1_53_98\">Testing Pyramid</a>.</div><div><br /></div><div><br /></div><h2 style=\"text-align: left;\">Understand and implement the other tiers of testing</h2><div><br /></div><div><br /></div><div>Unit, integration, and end-to-end testing address the functional level of your product. It is important to understand the other tiers of testing, including:</div><div><br /><ul style=\"text-align: left;\"><li>Performance testing - Measuring the latency or throughput of your application or service.</li><li>Load and scalability testing - Testing your application or service under higher and higher load.</li><li>Fault-tolerance testing - Testing your application’s behavior as different dependencies either fail or go down entirely.</li><li>Security testing - Testing for known vulnerabilities in your service or application.</li><li>Accessibility testing - Making sure the product is accessible and usable for everyone, including people with a wide range of disabilities.</li><li>Localization testing - Making sure the product can be used in a particular language or region.</li><li>Globalization testing - Making sure the product can be used by people all over the world.</li><li>Privacy testing - Assessing and mitigating privacy risks in the product.</li><li>Usability testing - Testing for user friendliness.</li></ul><br /></div><div>Again, it is important to have these testing processes occur as early as possible in your review cycle. Smaller performance tests can detect regressions earlier and save debugging time during the end-to-end tests.</div><div><br /></div><div><br /></div><h2 style=\"text-align: left;\">Understand your coverage of code and functionality</h2><div><br /></div><div><br /></div><div>So far, the question of how much testing is enough, from a qualitative perspective, has been examined. Different types of tests were reviewed and the argument made that smaller and earlier is better than larger or later. Now the problem will be examined from a quantitative perspective, taking code coverage techniques into account.</div><div><br /></div><div>Wikipedia has a great article on <a href=\"https://en.wikipedia.org/wiki/Code_coverage\">code coverage</a> that outlines and discusses different types of coverage, including statement, edge, branch, and condition coverage. There are several open source tools available for measuring coverage for most of the popular programming languages such as Java, C++, Go and Python. A partial list is included in the table below:</div><div><br /></div><div><br /></div><div><div><br /></div>   <style>  table.coverage-tools {     width: 100%;     border-collapse: collapse;   }   table.coverage-tools th,   table.coverage-tools td {     width: 50%;     border: 1px solid black;   }   table.coverage-tools td {     padding: 5px;   }   </style><table class=\"coverage-tools\">  <tbody><tr>    <th>Language</th>    <th>Tool</th>  </tr>  <tr>    <td>    </td>    <td>    </td>  </tr>  <tr>    <td>Java     </td>    <td>JaCoCo     </td>  </tr>  <tr>    <td>Java     </td>    <td>JCov     </td>  </tr>  <tr>    <td>Java     </td>    <td>OpenClover     </td>  </tr>  <tr>    <td>Python     </td>    <td>Coverage.py     </td>  </tr>  <tr>    <td>C++     </td>    <td>Bullseye     </td>  </tr>  <tr>    <td>Go     </td>    <td>Built in coverage support (go -cover)     </td>  </tr></tbody></table>      <div>Table 1 - Open source coverage tools for different languages</div></div><div><br /></div><div><br /></div><div>Most of these tools provide a summary in percentage terms. For example, 80% code coverage means <i>about</i> 80% of the code is covered and <i>about</i> 20% of the code is uncovered. At the same time, It is important to understand that, just because you have coverage for a particular area of code, this code can still have bugs.</div><div><br /></div><div><br /></div><div><div>Another concept in coverage is called changelist coverage. Changelist coverage measures the coverage in changed or added lines. It is useful for teams that have accumulated technical debt and have low coverage in their entire codebase. These teams can institute a policy where an increase in their incremental coverage will lead to overall improvement.</div></div><div><br /></div><div><br /></div><div><div>So far the coverage discussion has centered around coverage of the code by tests (functions, lines, etc.). Another type of coverage is feature coverage or behavior coverage. For feature coverage, the emphasis is on identifying the committed features in a particular release and creating tests for their implementation. For behavior coverage, the emphasis is on identifying the CUJs and creating the appropriate tests to track them. Again, understanding your “uncovered” features and behaviors can be a useful metric in your understanding of the risks.</div></div><div><br /></div><div><br /></div><div><br /></div><h2 style=\"text-align: left;\">Use feedback from the field to improve your process</h2><div><br /></div><div><br /></div><div>A very important part of understanding and improving your qualification process is the feedback received from the field once the software has been released. Having a process that tracks outages and bugs and other issues, in the form of action items to improve qualification, is critical for minimizing the risks of regressions in subsequent releases. Moreover, the action items should be such that they (1) emphasize filling the testing gap as early as possible in the qualification process and (2) address strategic issues such as the lack of testing of a particular type such as load or fault tolerance testing. And again, this is why it is important to document your qualification process so that you can reevaluate it in light of the data you obtain from the field.</div><div><br /></div><div><br /></div><h2 style=\"text-align: left;\">Summary</h2><div><br /></div><div><br /></div><div>Creating a comprehensive qualification process and testing strategy to answer the question “How much testing is enough?” can be a complex task. Hopefully the tips given here can help you with this. In summary:</div><div><br /></div><div><ul style=\"text-align: left;\"><li>Document your process or strategy.</li><li>Have a solid base of unit tests.</li><li>Don’t skimp on integration testing.</li><li>Perform end-to-end testing for Critical User Journeys.</li><li>Understand and implement the other tiers of testing.</li><li>Understand your coverage of code and functionality.</li><li>Use feedback from the field to improve your process.</li></ul><br /></div><div><br /></div><h2 style=\"text-align: left;\">References</h2><div><ul style=\"text-align: left;\"><li><a href=\"https://testing.googleblog.com/2020/11/fixing-test-hourglass.html\">Fixing a test hourglass</a></li><li><a href=\"https://docs.google.com/presentation/d/15gNk21rjer3xo-b1ZqyQVGebOp_aPvHU3YH7YnOMxtE/edit#slide=id.g437663ce1_53_98\">Testing Pyramid</a></li><li><a href=\"https://testing.googleblog.com/2016/06/the-inquiry-method-for-test-planning.html\">The Inquiry Method for test Planning</a></li><li><a href=\"https://testing.googleblog.com/2020/12/test-flakiness-one-of-main-challenges.html\">Test Flakiness - One of the Main Challenges of Automated Testing</a></li><li><a href=\"https://testing.googleblog.com/2013/07/testing-on-toilet-know-your-test-doubles.html\">Testing on the Toilet: Know Your Test Doubles</a></li><li><a href=\"https://testing.googleblog.com/2013/06/testing-on-toilet-fake-your-way-to.html\">Testing on the Toilet: Fake Your Way to Better Tests</a></li></ul><br /></div>",
  "link": [
    "",
    "",
    "",
    "",
    ""
  ],
  "author": {
    "name": "Google Testing Bloggers",
    "uri": "http://www.blogger.com/profile/03153388556673050910",
    "email": "noreply@blogger.com",
    "gd:image": ""
  },
  "thr:total": 4
}