{
  "id": "tag:blogger.com,1999:blog-5825758052688213474.post-3311282216595193329",
  "published": "2017-03-13T13:54:00.000-07:00",
  "updated": "2017-03-16T11:35:33.881-07:00",
  "title": "Attributing a deep network’s prediction to its input features",
  "content": "By MUKUND SUNDARARAJAN, ANKUR TALY, QIQI YAN<i><br /><br /></i><br /><div><i><i><b><u>Editor's note:</u> </b>Causal inference is central to answering questions in science, engineering and business and hence the topic has received particular attention on this blog. Typically, causal inference in data science is framed in probabilistic terms, where there is statistical uncertainty in the outcomes as well as model uncertainty about the true causal mechanism connecting inputs and outputs. And yet even when the relationship between inputs and outputs is fully known and entirely deterministic, causal inference is far from obvious for a complex system. In this post, we explore causal inference in this setting via the problem of attribution in deep networks. This investigation has practical as well as philosophical implications for causal inference. On the other hand, if you just care about understanding what a deep network is doing, this post is for you too.</i></i><br /><i><br /></i><i><br /></i>Deep networks have had remarkable success in variety of tasks. For instance, they identify objects in images, perform language translation, enable web search — all with surprising accuracy. Can we improve our understanding of these methods? Deep networks are the latest instrument in our large toolbox of modeling techniques, and it is natural to wonder about their limits and capabilities. Based on&nbsp;<a href=\"https://arxiv.org/abs/1703.01365\">our paper</a>&nbsp;[4],&nbsp;this post is motivated primarily by intellectual curiosity.<br /><div><br />Of course, there is benefit to an improved understanding of deep networks beyond the satisfaction of curiosity — developers can use this to debug and improve models; end-users can understand the cause of a model’s prediction, and develop trust in the model. As an example of the latter, suppose that a deep network was used to predict an illness based on an image (from an X-ray, or an MRI, or some other imaging technology). It would be very helpful for a doctor to examine which pixels led to a positive prediction, and cross-check this with her intuition.</div><div><br />We are all familiar with linear and logistic regression models. If we were curious about such a model’s prediction for a given input, we would simply inspect the weights (model coefficients) of the features present in the input. The top few features with the largest weight (i.e., coefficient times feature value) would be indicative of what the model deemed noteworthy.<br /><br />The goal of this post is to mimic this inspection process for deep models. <b>Can we identify what parts of the input the deep network finds noteworthy?</b> As we soon discuss, the nonlinearity of deep networks makes this problem challenging. The outline of this post is as follows:</div><div><ul><li>we introduce a natural approach to attribution based on gradients</li><li>use failures of the gradient approach to guide the design of our method</li><li>present our method more formally and discuss its properties</li><li>describe applications to networks other than Inception/ImageNet (our running example)&nbsp;</li></ul></div><div>We&nbsp;conclude&nbsp;with some areas for future work.</div><div><br /></div><div><h2>Feature Importance via Gradients</h2><h4>Feature attribution for (generalized) linear models</h4>Suppose that our model is linear. Then, there is a simple, commonly followed practice to identify the importance of features — examine the coefficients of the features present in the input, weighted by the values of these features in the input. (One can think of categorical features as having values in $\\{0,1\\}$.) A summation of the resulting vector would equal the prediction score less the intercept term and so this process accounts for the entire prediction. If instead of summing, we sorted this vector in decreasing sequence of magnitude, we would identify the features that the model finds important. Occasionally, we may find that the coefficients don’t match our intuition of what is important. We may then check for overfitting, or for biases in the training data, and fix these issues. Or we find may that some of the features are correlated, and the strange coefficients are an artifact thereof. In either case, this process is integral to improving the network or trusting its prediction. Let us now attempt to mimic this process for deep networks.</div><div><h4>The Inception architecture and ImageNet</h4>For concreteness, let us focus on a network that performs object recognition. We consider a deep network using the <a href=\"https://arxiv.org/abs/1602.07261\">Inception</a>&nbsp;[1] architecture trained on the <a href=\"http://www.image-net.org/\">ImageNet</a> dataset. It takes an image as input and assigns scores for 1000 different <a href=\"http://image-net.org/challenges/LSVRC/2014/browse-synsets\">ImageNet categories</a>. The input is specified via the R,G,B values of the pixels of the image. At the output, the network produces a score (probability) for each label using a multinomial logit (Softmax) function. The network “thinks” that objects with large output scores are probably present in the image. For instance, here is an image and its top few labels:</div><div><br /></div><div><img height=\"289\" src=\"https://lh3.googleusercontent.com/OdmC9gir5TIFrk39uuxI92pK4FaXzLyAAi6PO1sLdTJTaR-mPdbdB6owk2IaTfCN3MWHhK7HVAIaVyXZ2Gyzm75bN8QukZFTEA7EZpb20oP9B-M4AeMTY1E3PWsuMDKnTPq3QkJ6\" width=\"640\" /></div><div><br /></div><div>Notice that the score for the top label, “fireboat”, is very close to 1.0, indicating that the network is very sure that there is a “fireboat” somewhere in the image. The network is absolutely right in this case — a fireboat is a special boat used to fight fires on shorelines and aboard ships.</div><div><h4>Applying Gradients to Inception</h4>Which pixels made the network think of this as a fireboat? We cannot just examine the coefficients of the model as we do with linear models.&nbsp;<a href=\"https://en.wikipedia.org/wiki/Deep_learning\">Deep networks</a> have multiple layers of  logic and coefficients, combined using nonlinear <a href=\"https://en.wikipedia.org/wiki/Activation_function\">activation functions</a>. For instance, the Inception architecture has 22 layers. The coefficients of the input layer do not adequately cover the logic of the network. In contrast, the coefficients of the hidden layers aren’t in any human intelligible space. <br /><br />Instead, we could use the gradients of the output with respect to the input — if our deep network were linear, this would coincide exactly with the process for linear models, because the gradients correspond to the model coefficients. In effect, we are using a local linear approximation of the (nonlinear) deep network. This approach has been applied to deep networks in previous literature.</div><div><br />Let us see how this does. We are going to inspect the  gradient of the score for the object “fireboat” with respect to the input, multiplied point-wise by the input itself (essentially, a Taylor approximation of the prediction function at the input). The result is a matrix that has three dimensions. Two of these correspond to the height and width of the image, and the third is for the primary color (R, G, or B).<br /><h4>A note on visualization</h4>The most convenient way to inspect our feature importances (attributions) is to visualize them. We do this by using the attributions as a (soft) window over the image itself. We construct the window by first removing the primary color dimension from the attributions, by taking the sum of  absolute value of the R, G, B values. To window the image, we take an element-wise product of the window with the pixel values and visualize the resulting image. The result is that unimportant pixels are dimmed. Our <a href=\"https://github.com/ankurtaly/Attributions/blob/master/attributions.ipynb\">code</a> has details (there are probably other reasonable visualization approaches that work just as well). The visualization of the gradients for the “fireboat” image looks like this:<br /><br /><img height=\"320\" src=\"https://lh6.googleusercontent.com/J09LPNlCY3zp4cR3dTtKIf9YWv5honnvpu9GvZy7l6jodrTmLLm8Hg0WQBVqL-kOXRA-kTFXso_WqGE8Z1yWFn25A1dHWM0UFkzifOqYfIkkOuiEYJfg09z0scLuzDJKHhrzKiWp\" width=\"320\" /><br /><br />Unfortunately, gradients highlight pixels below the bridge which seem completely irrelevant to the “fireboat” prediction. This is unlikely to be a model bug — recall that the prediction was  correct. So what is happening?</div><div><br />It turns out that our local linear approximation does a poor job of indicating what the network thinks is important. The prediction function flattens in the vicinity of the input, and consequently, the gradient of the prediction function with respect to the input is tiny in the vicinity of the input vector. The dot product of the gradient with the image, which represents a first-order Taylor approximation of the prediction function at the input, adds up to only $4.6 \\times 10^{-5}$ (while the actual value of the prediction is $0.999961$ — gradients aren’t accounting for a large portion of the score.<br /><br />A simple analysis substantiates this. We construct a series of images by scaling down the pixel intensities from the actual image to zero (black). Call this scaling parameter $\\alpha$. One can see that the prediction function flattens after $\\alpha$ crosses $0.2$.<img height=\"275\" src=\"https://lh5.googleusercontent.com/faUu3mDx2KZqUVunkHrJSSpwD1koGOd6j9ll64gYCw3bGOyymufRpoXYXAJQtcjFBDumnJMBsq3LUTePHC-VynH_TAKTm__qFbTSI4tglOGZMA8aht7Kw_Y3Edw5bUKlgfgCIxkT\" width=\"400\" /><br /><br />This phenomenon of flattening is specific neither to this label (“fireboat”), this image, the output neuron, or nor even to this network. It has been observed by other work [2] and our previous paper [3].</div><div><br /></div><div><h2>Our method: Integrated Gradients</h2>The same plot that demonstrates why gradients don’t work also tells us how to fix the issue. Notice that there is a large jump in the prediction score at low intensities. Perhaps it is useful to inspect the gradients of those images. The figure below visualizes these gradients, visualized with the same logic as in the previous section;  these are just the gradients of the original image at different levels of brightness.<br /><br /><img height=\"212\" src=\"https://lh3.googleusercontent.com/zivMJ35RijWrGFQIjitWZo_TguhcoYxSVdhyB0gZpRE0R8x0MZ7-XSIEdz0lGiKdOcwM8Q9WgruqvxEfrwzNoYWvLBfN3LjIGkw6qBvaDk8QT1TrQvoVjCtXlPuRVvbKftoZU3Og\" width=\"640\" /><br /><br /><br /><img height=\"148\" src=\"https://lh3.googleusercontent.com/rUxCx7wNiVbcgLjLGl-4uZzwx41sKtMCpfNHuy7rT9PSOlhVEhjqjyWQ-JkV74YPPS8KZVJZgpGX0oP78Jss-LazUmf7KYiNuVWDV8XMi-9S8HlHlZ_wJvaThkXdXO-jIaoYwKwc\" width=\"640\" /><br /><img height=\"148\" src=\"https://lh4.googleusercontent.com/I7hEI-cCfB7Ck81tSUsN4itQeX3N06R1PoS_ziwYMCo6uxEfhrS_uu3leWv331McByaKoQfJPibT4KfiWuClkb6pelHH3lVZw_CfEH8qtdNCyjyQlRAvP4Kp3V3J4kWP-k7yKPef\" width=\"640\" /><img height=\"149\" src=\"https://lh3.googleusercontent.com/W6hWPcQg-cgJRehxMPQldqa5wh57W5qHT_rSjNeCivdLnci-1kSvMYoV_1pFjlsMZiLr-aSDLH0rPzzcnWETx28jqBy13LBFIHLjyMbfjmAnS0eTLEk5KojVxZh4XX5xtGdnR0EC\" width=\"640\" /><br /><br />The visualizations show that at lower values of the scaling parameter $\\alpha$, the pixels constituting the fireboat and spout of water are most important. But as $\\alpha$ increases, the region around the fireboat (rather than the fireboat itself) gains relative importance. As the plot shows, the visualizations corresponding to lower values of the scale parameter are more important to the score because they have higher gradient magnitudes. This does not come through in our visualizations because they are each normalized for brightness; if they weren’t, the last few images would look nearly black. By summing the gradients across the images, and then visualizing this, we get a more realistic picture of what is going on.<br /><br /><img height=\"320\" src=\"https://lh4.googleusercontent.com/QNKn83Z1Aa2-CSIUmklDdWxJvN56gMKGAz3v-FXoQbxZ1gc9Mq930vLwTjxiaAG6nEKRUbjSZpvxkFePTki3s9YMB96tgcG2uB31sikwOV0W3GyeZJxSv-pYRvxHxNVrszrgW4WM\" width=\"320\" /><br /><br />This is the essence of our method. We call this method \"integrated gradients\". Informally, we average the gradients of the set of scaled images and then take the element-wise product of this with the original image. Formally, this approximates a certain integral as we will see later.<br /><br />The complete code for loading the Inception model and visualizing the attributions is available from&nbsp;<a href=\"https://github.com/ankurtaly/Attributions\">GitHub repository</a>. The code is packaged as a single IPython notebook with less than 70 lines of Python TensorFlow code. Instructions for running the notebook are provided in our <a href=\"https://github.com/ankurtaly/Attributions/blob/master/README.md\">README</a>. Below is the key method for generating integrated gradients for a given image and label. It involves scaling the image and invoking the gradient operation on the scaled images:</div><div><i><br /></i></div><div><i><span id=\"docs-internal-guid-e64e2514-c8b3-5fd8-df5e-cc715b393176\"></span></i><br /><div dir=\"ltr\" style=\"line-height: 1.2; margin-bottom: 0pt; margin-top: 0pt;\"><i><span id=\"docs-internal-guid-e64e2514-c8b3-5fd8-df5e-cc715b393176\"><span style=\"background-color: transparent; color: #38761d; font-family: &quot;courier new&quot;; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 700; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\">def</span><span style=\"background-color: transparent; color: black; font-family: &quot;courier new&quot;; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\"> </span><span style=\"background-color: transparent; color: blue; font-family: &quot;courier new&quot;; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\">integrated_gradients</span><span style=\"background-color: transparent; color: black; font-family: &quot;courier new&quot;; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\">(img, label, steps=50):</span></span></i></div><span id=\"docs-internal-guid-e64e2514-c8b3-5fd8-df5e-cc715b393176\"></span><div dir=\"ltr\" style=\"font-style: italic; line-height: 1.2; margin-bottom: 0pt; margin-top: 0pt;\"><span id=\"docs-internal-guid-e64e2514-c8b3-5fd8-df5e-cc715b393176\"><span style=\"background-color: transparent; color: black; font-family: &quot;courier new&quot;; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\"> &nbsp;'''</span><span style=\"background-color: transparent; color: #cc0000; font-family: &quot;courier new&quot;; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\">Returns attributions for the prediction label based</span></span></div><span id=\"docs-internal-guid-e64e2514-c8b3-5fd8-df5e-cc715b393176\"><div dir=\"ltr\" style=\"font-style: italic; line-height: 1.2; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"background-color: transparent; color: #cc0000; font-family: &quot;courier new&quot;; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\"> &nbsp;&nbsp;&nbsp;&nbsp;on integrated gradients at the image.</span></div><div dir=\"ltr\" style=\"font-style: italic; line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><b id=\"docs-internal-guid-e64e2514-c8b4-1971-8674-4c1aac33a82d\" style=\"font-weight: normal;\"><br /></b></div><div dir=\"ltr\" style=\"font-style: italic; line-height: 1.2; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"background-color: transparent; color: #cc0000; font-family: &quot;courier new&quot;; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\"> &nbsp;&nbsp;&nbsp;&nbsp;Specifically, the method returns the dot product of the image</span></div><div dir=\"ltr\" style=\"font-style: italic; line-height: 1.2; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"background-color: transparent; color: #cc0000; font-family: &quot;courier new&quot;; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\"> &nbsp;&nbsp;&nbsp;&nbsp;and the average of the gradients of the prediction label (w.r.t.</span></div><div dir=\"ltr\" style=\"font-style: italic; line-height: 1.2; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"background-color: transparent; color: #cc0000; font-family: &quot;courier new&quot;; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\"> &nbsp;&nbsp;&nbsp;&nbsp;the image) at uniformly spaced scalings of the provided image.</span></div><div dir=\"ltr\" style=\"font-style: italic; line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><b style=\"font-weight: normal;\"><br /></b></div><div dir=\"ltr\" style=\"font-style: italic; line-height: 1.2; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"background-color: transparent; color: #cc0000; font-family: &quot;courier new&quot;; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\"> &nbsp;&nbsp;&nbsp;&nbsp;The provided image must of shape (224, 224, 3), which is </span></div><div dir=\"ltr\" style=\"font-style: italic; line-height: 1.2; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"background-color: transparent; color: #cc0000; font-family: &quot;courier new&quot;; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\"> &nbsp;&nbsp;&nbsp;&nbsp;also the shape of the returned attributions tensor.</span></div><div dir=\"ltr\" style=\"font-style: italic; line-height: 1.2; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"background-color: transparent; color: black; font-family: &quot;courier new&quot;; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\"> &nbsp;'''</span></div><div dir=\"ltr\" style=\"font-style: italic; line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><b style=\"font-weight: normal;\"><br /></b></div><div dir=\"ltr\" style=\"font-style: italic; line-height: 1.2; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"background-color: transparent; color: #e69138; font-family: &quot;courier new&quot;; font-size: 10pt; font-style: italic; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\"> &nbsp;# Obtain the tensor representing the softmax output of the provided label.</span></div><div dir=\"ltr\" style=\"font-style: italic; line-height: 1.2; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"background-color: transparent; color: black; font-family: &quot;courier new&quot;; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\"> &nbsp;t_output = output_label_tensor(label) </span><span style=\"background-color: transparent; color: #e69138; font-family: &quot;courier new&quot;; font-size: 10pt; font-style: italic; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\"># shape: scalar</span></div><div dir=\"ltr\" style=\"font-style: italic; line-height: 1.2; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"background-color: transparent; color: black; font-family: &quot;courier new&quot;; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\"> &nbsp;t_grad = tf.gradients(t_output, T('</span><span style=\"background-color: transparent; color: #cc0000; font-family: &quot;courier new&quot;; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\">input</span><span style=\"background-color: transparent; color: black; font-family: &quot;courier new&quot;; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\">'))[0]</span></div><div dir=\"ltr\" style=\"font-style: italic; line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><b style=\"font-weight: normal;\"><br /></b></div><div dir=\"ltr\" style=\"font-style: italic; line-height: 1.2; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"background-color: transparent; color: black; font-family: &quot;courier new&quot;; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\"> &nbsp;scaled_images = [(float(i)/steps)*img </span><span style=\"background-color: transparent; color: #38761d; font-family: &quot;courier new&quot;; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 700; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\">for</span><span style=\"background-color: transparent; color: black; font-family: &quot;courier new&quot;; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\"> i </span><span style=\"background-color: transparent; color: #38761d; font-family: &quot;courier new&quot;; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 700; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\">in</span><span style=\"background-color: transparent; color: black; font-family: &quot;courier new&quot;; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\"> range(1, steps+1)]</span></div><div dir=\"ltr\" style=\"font-style: italic; line-height: 1.2; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"background-color: transparent; color: #e69138; font-family: &quot;courier new&quot;; font-size: 10pt; font-style: italic; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\"> &nbsp;# Compute the gradients of the scaled images</span></div><div dir=\"ltr\" style=\"font-style: italic; line-height: 1.2; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"background-color: transparent; color: black; font-family: &quot;courier new&quot;; font-size: 10pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\"> &nbsp;grads = run_network(sess, t_grad, scaled_images)</span></div><div dir=\"ltr\" style=\"font-style: italic; line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><b style=\"font-weight: normal;\"><br /></b></div><div dir=\"ltr\" style=\"font-style: italic; line-height: 1.2; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"background-color: transparent; color: #e69138; font-family: &quot;courier new&quot;; font-size: 10pt; font-style: italic; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\"> &nbsp;# Average the gradients of the scaled images and dot product with the original</span></div><div dir=\"ltr\" style=\"font-style: italic; line-height: 1.2; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"background-color: transparent; color: #e69138; font-family: &quot;courier new&quot;; font-size: 10pt; font-style: italic; font-variant: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\"> &nbsp;# image</span></div><div dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"font-family: &quot;courier new&quot;; font-size: 10pt; vertical-align: baseline; white-space: pre-wrap;\"> &nbsp;</span><span style=\"color: #38761d; font-family: &quot;courier new&quot;; font-size: 10pt; font-weight: 700; vertical-align: baseline; white-space: pre-wrap;\">return</span><span style=\"font-family: &quot;courier new&quot;; font-size: 10pt; vertical-align: baseline; white-space: pre-wrap;\"> img*np.average(grads, axis=0)</span></div></span></div><div><br /></div>The following figure shows some more visualizations of integrated gradients. Our visualization logic is identical to that of the gradient approach. For comparison, we also show the visualization for the gradient approach. From the visualizations, it is evident that the integrated gradients are better at capturing important features.<br /><br /><br /><div><div dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"background-color: white; color: #212121; font-family: &quot;roboto&quot;; font-size: 10pt; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\"><img height=\"19\" src=\"https://lh5.googleusercontent.com/no8tjBZXv-aC8vigd7tCuA8L5dp9EXAnQzzm3vZsfMRoetOa89ZOq9E1gYEqcx1DLGwJbzmPuU7oYVmBFzEJtiFFip6SykW1QnK7BVjaPaa99q-ftsrY5ZeIXzXs8vAS9nB5B7-2\" style=\"-webkit-transform: rotate(0.00rad); border: none; transform: rotate(0.00rad);\" width=\"624\" /></span></div><div dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"background-color: white; color: #212121; font-family: &quot;roboto&quot;; font-size: 10pt; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\"><img height=\"140\" src=\"https://lh3.googleusercontent.com/6-GtG3lq4YRSX195jv8_Kh_Rj393iHNJhVdOUp5G7EfsN7gNvCYeAne1tnXjsNmbz82jEMU-KsM-YsoypfuQQ6o94DtE6ViJ4uw_cmvTzcXogWgWTHwAyQsqJRTo5kHvJUmC9vGl\" style=\"border: none; transform: rotate(0rad);\" width=\"640\" /></span></div><div dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"background-color: white; color: #212121; font-family: &quot;roboto&quot;; font-size: 10pt; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\"><img height=\"140\" src=\"https://lh5.googleusercontent.com/y55rBOVNg9s0fD3J66yLyZWRtv4AdAqbWYJibD6rVY9YYJ1e3d8h_rco7OyEnIfvvkJaX9wtkXmskgMI89P-Vgzy4e7eOQqm4S3c8-dcROP-p6MQR19zxP9bgqKS3lGwAtLWZwyG\" style=\"border: none; transform: rotate(0rad);\" width=\"640\" /></span></div><div dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"background-color: white; color: #212121; font-family: &quot;roboto&quot;; font-size: 10pt; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\"><img height=\"140\" src=\"https://lh3.googleusercontent.com/nzWquJGwQ4t2dyCROSUWc6srv4Z5SdLsWB8xt-1-dj7r4cMuaBnC2Eixm3WavO08N3YwWPvvsvOqRediQTSbQn8DL382hlJmavGY0POzz4TGXu_VZs67xDs9RiThMexhrahiA96m\" style=\"border: none; transform: rotate(0rad);\" width=\"640\" /></span></div><div dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"background-color: white; color: #212121; font-family: &quot;roboto&quot;; font-size: 10pt; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\"><img height=\"140\" src=\"https://lh4.googleusercontent.com/5zKe8_4wRB1V-3uVTy-dCwhZD2iTJL1w-gAaOD7JxsShZRHCURuJPwBjsm46A-3oOpER1toCWApaYFTQEfnYK1-fbgOkl-nuWgTlBaKg9wfzxqb4_E1wMmLCJz_5RbAAGg78FXfm\" style=\"border: none; transform: rotate(0rad);\" width=\"640\" /></span></div><br /><h4>Misclassifications</h4></div><div>We now turn to images that are misclassified by the Inception network, i.e., where the top five labels assigned by the Inception network are different from the ground truth label provided by the ImageNet dataset. The goal is understand <b>what made the network choose the wrong label</b>? To understand this we visualize the integrated gradients with respect to the top label assigned by the Inception network (i.e., the wrong label).<br /><b style=\"font-weight: normal;\"><br /></b><br /><div dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"background-color: transparent; color: black; font-family: &quot;arial&quot;; font-size: 11pt; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\"><img alt=\"title.jpg\" height=\"25\" src=\"https://lh5.googleusercontent.com/RGxV4TwEzNySNJ3sAOKj0cA5_YVjSQrw5TLJ3V70Q38PrJ2eQZ0yAsGo-YiwQRTu4ywWUOqFM6M6TagwuxeUndDTdP4Aru6l-ma_ToEQouQrNiOK9Rd5tpaKr-b9vC-79GO_1y2o\" style=\"-webkit-transform: rotate(0.00rad); border: none; transform: rotate(0.00rad);\" width=\"624\" /></span></div><div dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"background-color: transparent; color: black; font-family: &quot;arial&quot;; font-size: 20pt; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\"><img alt=\"861e9130da1f0c34.jpg\" height=\"196\" src=\"https://lh5.googleusercontent.com/LQzvirMd2-MGT91nu-xuafHrZ2zg3z9ps99BSdoLTE2OG9F479Z7FcJDt6sNuPONVa1c7Pdg68oH4OkkMaVF2webiCK10dxmTGgr-ZyYghqpVAjEJoVPFXdC5J4yp6LamJvPQrDN\" style=\"border: none; transform: rotate(0rad);\" width=\"640\" /></span><span style=\"background-color: transparent; color: black; font-family: &quot;arial&quot;; font-size: 11pt; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\"><img alt=\"152ce04bb42aed36.jpg\" height=\"196\" src=\"https://lh6.googleusercontent.com/aNGC9YxtdWopPoMz9LpGBx1n3jG6CJ0LMNZi0TNYXpOdVJb5-fzzRpgaowoRXzPv5KMlFW2q1LNM-2_GRO5BqSH-_7W5UfnHVmGcdrMDfk7sIrePDDgzJ_76bWd_Go0Z-QGPZPX0\" style=\"border: none; transform: rotate(0rad);\" width=\"640\" /></span></div><b style=\"font-weight: normal;\"><br /></b><br /><div dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"background-color: transparent; color: black; font-family: &quot;arial&quot;; font-size: 11pt; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\"><img alt=\"8cb79ab87da08e55.jpg\" height=\"196\" src=\"https://lh5.googleusercontent.com/_3ygmBdP2SoDFgTylEWfd3iIaXXDykKLjETHAXeVKZUkbSOxe8vYFDB1fIajbYmupnl4XhqNCr9bBfDeRt_KkQSWs8Uv7UicickYZWyhe9gg4RbirU8r7whIxZ_7jfM4bsvGqmcN\" style=\"border: none; transform: rotate(0rad);\" width=\"640\" /></span></div><br /><br />With the first image, it is clear what went wrong even without examining the integrated gradients. The image does have a strainer, but the ground truth label is about a different object within the image (cabbage butterfly).  In contrast, the second and third images are more mysterious. Inspecting the images alone do not tell us anything about the source of the error. The integrated gradient visualization is clarifying — it identifies blurry shapes within the image that seem to resemble a walking stick and a vacuum cleaner. Perhaps a fix for these misclassifications is to feed these images as negative examples for the incorrect labels.</div><div><br /><h2>Properties of Integrated Gradients</h2>We use this section to be precise about our problem statement, our method, and its properties. Part of the reason for the rigor is to argue why our method does not introduce artifacts into the attributions, and faithfully reflects the workings of the deep network.<br /><h4>Attribution Problem</h4><div>Formally, suppose we have a function $F: \\mathbb{R}^n \\rightarrow [0,1]$ that represents a deep network, and an input $x = (x_1,\\ldots,x_n) \\in \\mathbb{R}^n$.  An attribution of the prediction at input $x$ relative to a baseline input $x'$ is a vector $A_F(x, x') = (a_1,\\ldots,a_n) \\in \\mathbb{R}^n$ where $a_i$ is the contribution of $x_i$ to the function $F(x)$.</div><br />In our ImageNet example, the function $F$ represents the Inception deep network (for a given output class). The input vector $x$ is simply the image — if one represents the image in grayscale, the indices of $x$ correspond to the pixels. The attribution vector $a$ is exactly what we visualize in the previous sections.</div><div><br />Let us briefly examine the need for the baseline in the definition of the attribution problem.  A common way for humans to perform attribution relies on counterfactual intuition.  When we assign blame to a certain cause we implicitly consider the absence of the cause as a baseline — would the outcome change if the supposed cause were not present?&nbsp;</div><div><br />The attribution scheme for linear models that inspects the weights of the input features has an implicit baseline of an input with no features. The gradient based approach uses a baseline that is a slight perturbation of the original input. Of course, gradients, as we argued earlier, are a poor attribution scheme. Intuitively, the baseline is “too close” to the input. For integrated gradients, we will use baselines that are far enough away from the input that they don’t just focus on the flat region in the sense of the saturation plot shown in the earlier section. We will also ensure that baseline is fairly “neutral”, i.e., the predictions for this input are nearly zero. For instance, the black image for an object recognition network. This will allow us to interpret the attributions independent of the baseline as a property of the input alone.</div><h4>Integrated Gradients</h4>We are now ready to define our method formally. The integrated gradient along the $i^{th}$ dimension for an input $x$ and baseline $x'$ is defined as follows:<br /><div>$$<br />\\mathrm{IntegratedGrads}_i(x) ::= (x-x')\\times\\int_{\\alpha=0}^{1}<br />\\frac{\\partial F(x' + \\alpha \\times(x-x'))}{\\partial x_i<br />}~d\\alpha<br />$$</div><div>where $\\frac{\\partial F(x)}{\\partial x_i}$ is the gradient of $F$ along the $i^{th}$ dimension at $x$.&nbsp;</div><div><br /></div><div>Below we list a number of properties that our method satisfies:</div><div><br /><b>Completeness:</b> The attributions from integrated gradients sum to the difference between the prediction scores of the input and the baseline. The proof follows from the famous <a href=\"https://en.wikipedia.org/wiki/Gradient_theorem\">gradient theorem</a>. This property is desirable because we can be sure that the prediction is entirely accounted for. <br /><br /><b>Linearity preservation:</b> If a network $F$ is a linear combination $a*F_1 + b*F_2$ of two networks $F_1$ and $F_2$, then a linear combination of the attributions for $F_1$ and $F_2$, with weights $a$ and $b$ respectively, is the attribution for the network $F$. The property is desirable because the attribution method preserves any linear logic present within a network. <br /><b><br />Symmetry preservation:</b> Integrated gradients preserve symmetry. That is, if the network behaves symmetrically with respect to two input features, then the attributions are symmetric as well. For instance, suppose $F$ is a function of three variables $x_1, x_2, x_3$, and $F(x_1,x_2, x_3) = F(x_2,x_1, x_3)$ for all values of $x_1, x_2, x_3$. Then $F$ is symmetric in the two variables $x_1$ and $x_2$. If the variables have identical values in the input and baseline, i.e., $x_1 = x_2$, and $x'_1 =x'_2$, then symmetry preservation requires that&nbsp;$a_1 = a_2$. This property seems desirable because of the connotation of attributions as blame assignment. Why should two symmetric variables be blamed differently?</div><div><br /><b>Sensitivity: </b>We define two aspects of sensitivity.<br /><ul><li>(A) If the baseline and the input differ only in one feature, but have different predictions, then this feature gets non-zero attribution.</li><li>(B) If a feature does not play any role in the network, it receives no attributions.</li></ul>It is self-evident why we’d like Sensitivity to hold. Further, notice that the failure of gradients discussed earlier  was essentially a failure to satisfy Sensitivity(A). For instance, suppose we have a simple function $\\min(x, 5)$. If the input is $x = 8$ and the baseline is $x'=0$, then difference between the function value at the input and the baseline is $5$, but the gradient at $x=8$ is zero, and therefore the gradient-based attribution is zero. This is a one-variable caricature of what we saw with the object recognition network earlier.<br /><br />At first glance, these requirements above seem quite basic and we may expect that many methods ought to provably satisfy them. Unfortunately, other methods in literature fall into classes — they either violate Sensitivity(A) or  they violate an even more basic property, namely they depend on the implementation of the network in an undesirable way. That is, we can find examples where two networks have identical input-output behavior, but the method yields different attributions (due to a difference in the underlying structure of the two networks). In contrast, our method relies only on the functional representation of the network, and not its implementation, i.e., we say that it satisfies \"implementation invariance\".</div><div><br />In contrast, we can show that our method is essentially the unique method to satisfy all the properties listed above (up to certain convex combinations). We invite the interested reader to read <a href=\"https://arxiv.org/abs/1703.01365\">our paper</a>&nbsp;[4], where we have formal descriptions of these properties, the uniqueness result, and comparisons with other methods.</div><div><br /><h2>Application to other networks</h2>Our paper also includes application of integrated gradients to other networks (none of these networks were trained by us). One network is an image network that predicts diabetic retinopathy — we demonstrate the use of attributions in a user-facing context to help doctors gain some transparency into the network’s prediction. The second network is a chemistry network that performs virtual screening of drug molecules — we show how attributions help identify degenerate model features.  A third network categorizes queries in the context of a question-answering system — we demonstrate the use of attribution to extract human-intelligible rules.</div><div><br />A quick checklist on applying our method to your favorite deep network. You will have to resolve three issues:<br /><ol><li>Identify a good baseline, i.e., the analog of the black image in our example. This should be treated as neutral by the network, i.e., the prediction score for this input should be nearly zero.</li><li>Identify the right variables to attribute to. This step is trivial for ImageNet. But in a text network the input is usually represented as embeddings. The attributions are then naturally produced in the space of embeddings and some simple processing is needed to map them to the space of terms.</li><li>Find a convenient visualization technique. Our paper&nbsp;[4] has some ideas.</li></ol><br /><h2>Concluding thoughts</h2>This post discusses the problem of identifying input feature importance for a deep network. We present a very simple method, called \"integrated gradients\", to do this. All it involves is a few calls to a gradient operator. It yields insightful results for a variety of deep networks.<br /><br />Of course, our problem formulation has limitations. It says nothing about the logic that is employed by the network to combine features. This is an interesting direction for future work. <br /><br />Our method and our problem statement are also restricted to providing insight into the behavior of the network on a single input. It does not directly offer any global understanding of the network. Other work has made progress in this direction via clustering inputs using the pattern of neuron activations, for instance, [5] or [6]. There is also work (such as <a href=\"http://gabgoh.github.io/ThoughtVectors/\">this</a>)&nbsp;on architecting deep networks in ways that allow us to understand the internal representations of these networks. These are all very insightful. It is interesting to ask if there is a way to turn these insights into guarantees of some form as we do for the problem of feature attribution.</div><div><br />Overall, we hope that deep networks lose their reputation for being impenetrable black-boxes which perform black magic. Though they are harder to debug than other models, there are ways to analyze them. And the process can be enlightening and fun!</div><div><div><br /></div><div><br /><h3>References</h3></div><div><br /></div><div>[1] Szegedy, Christian, Liu, Wei, Jia, Yangqing, Sermanet, Pierre, Reed, Scott E., Anguelov, Dragomir, Erhan, Dumitru, Vanhoucke, Vincent, and Rabinovich, Andrew. Going deeper with convolutions. CoRR, 2014.</div><div><br />[2] Shrikumar, Avanti, Greenside, Peyton, Shcherbina, Anna, and Kundaje, Anshul. Not just a black box: Learning important features through propagating activation differences. CoRR, 2016.</div><div><br /></div>[3] Mukund Sundararajan, Ankur Taly, Qiqi Yan, 2016, \"Gradients of Counterfactuals\", &nbsp;<a href=\"https://arxiv.org/abs/1611.02639\">arXiv:1611.02639</a></div><div></div><br />[4] Mukund Sundararajan, Ankur Taly, Qiqi Yan, 2017, \"Axiomatic Attribution for Deep Networks\", &nbsp;<a href=\"https://arxiv.org/abs/1703.01365\">arXiv:1703.01365</a><br /><br />[5]&nbsp;Ian J. Goodfellow, Quoc V. Le, Andrew M. Saxe, Honglak Lee, and Andrew Y. Ng. 2009, \"<a href=\"http://ai.stanford.edu/~hllee/nips09-MeasuringInvariancesDeepNetworks.pdf\">Measuring invariances in deep networks</a>\". In Proceedings of the 22nd International Conference on Neural Information Processing Systems (NIPS'09), USA, 646-654<br /><div><br /></div><div>[6] Erhan, Dumitru, Bengio, Yoshua, Courville, Aaron, and Vincent, Pascal. \"<a href=\"http://igva2012.wikispaces.asu.edu/file/view/Erhan+2009+Visualizing+higher+layer+features+of+a+deep+network.pdf\">Visualizing higher-layer features of a deep network</a>\". Technical Report 1341, University of Montreal, 2009.</div><div><i><br /></i></div><div><i><br /></i></div><div><i><br /></i></div></div>",
  "link": [
    "",
    "",
    "",
    "",
    ""
  ],
  "author": {
    "name": "Amir Najmi",
    "uri": "http://www.blogger.com/profile/18174523203317227640",
    "email": "noreply@blogger.com",
    "gd:image": ""
  },
  "media:thumbnail": "",
  "thr:total": 3
}