{
  "title": "Picaroons Contract Review",
  "link": "https://streamhacker.com/2022/04/22/picaroons-contract-review/#utm_source=feed&#038;utm_medium=feed&#038;utm_campaign=feed",
  "comments": "https://streamhacker.com/2022/04/22/picaroons-contract-review/#respond",
  "dc:creator": "Jacob",
  "pubDate": "Sat, 23 Apr 2022 05:51:40 +0000",
  "category": [
    "contracts",
    "bots",
    "erc721",
    "eth",
    "hashing",
    "mint",
    "nft",
    "provenance",
    "signatures",
    "signing",
    "slither",
    "solidity",
    "token"
  ],
  "guid": "https://streamhacker.com/?p=2307",
  "description": "Contract review of The Picaroons and how they secured the mint against bots.",
  "content:encoded": "\n<p>The <a href=\"https://thepicaroons.com/\">Picaroons</a> is a new NFT collection by <a href=\"https://twitter.com/LucasAntics\">Alex Lucas</a>, with support from <a href=\"https://twitter.com/pranksy\">Pranksy</a>. Holders of certain NFTs by Alex were able to mint up to 2 tokens, then during public mint anyone could mint 2 tokens (and previous minters could mint 2 more). The 10k collection quickly sold out during public mint, and is now only available on <a href=\"https://opensea.io/collection/the-picaroons\">secondary marketplaces</a>.</p>\n\n\n\n<p>An interesting thing about this contract is the extra effort into preventing bots from minting directly from the contract. They maintained an allow list of addresses in their web app instead of putting the snapshot into the contract, and minting required a signature generated by their web app. Let&#8217;s dig into the <a href=\"https://etherscan.io/address/0x545f0a45Ba06C7C5b1a5Fb0b29008462ceEA07b7#code\">contract code</a>&#8230;</p>\n\n\n\n<h2>Mint</h2>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-solidity\">    function mint(bytes32 hash, bytes memory signature, uint256 tokenQuantity, uint256 maxAmountAllowed) external payable {\n        require(saleLive, \"SALE_CLOSED\");\n        // Is the signature valid\n        require(matchAddresSigner(hash, signature), \"DIRECT_MINT_DISALLOWED\");\n        // Verify if the keccak256 hash matches the hash generated by the hashTransaction function\n        require(hashTransaction(msg.sender, tokenQuantity, maxAmountAllowed) == hash, \"HASH_FAIL\");\n        // Out of stock check\n        require(totalSupply() + tokenQuantity <= TOTAL_SUPPLY, \"OUT_OF_STOCK\");\n        // Is the address allow more mint more tokens?\n        require(amountMintedList[msg.sender] + tokenQuantity <= maxAmountAllowed, \"EXCEED_ALLOC\");\n        require(PRICE * tokenQuantity <= msg.value, \"INSUFFICIENT_ETH\");\n\n        for(uint256 i = 0; i < tokenQuantity; i++) {\n            amountMintedList[msg.sender]++;\n            _safeMint(msg.sender, totalSupply() + 1);\n        }\n       \n    }</code></pre>\n\n\n\n<p>The mint function requires the following:</p>\n\n\n\n<ol><li>Sale isn&#8217;t closed</li><li>The <code>hash</code> argument was signed (<code>signature</code>) by a known signing address</li><li>The <code>hash</code> argument can be verified with the other function arguments</li><li>There are tokens available to mint</li><li>You have not minted too much</li><li>You sent enough ETH </li></ol>\n\n\n\n<p>Once those checks pass, it&#8217;s a simple mint loop, incrementing a counter for how many you have minted. The interesting parts are requirements 2 & 3.</p>\n\n\n\n<h2>Match Address Signer</h2>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-solidity\">    address private _signerAddress = 0xF5F6C1B8F13F2A41Ce8474AAD3Dd5050364eef1f;\n\n    ...\n        \n    function matchAddresSigner(bytes32 hash, bytes memory signature) private view returns(bool) {\n        return _signerAddress == hash.recover(signature);\n    }</code></pre>\n\n\n\n<p>The <code>_signerAddress</code> is defined as a static variable. In order to generate a verifiable <code>signature</code> for the <code>hash</code>, the private key associated with this signing address must exist in their web app. Because this  address is static, with no way to change it, they hopefully had some good app and server security to prevent any leaking of the private key. Assuming no one else has access to the private key, the <code>signature</code> can only be generated by their web app, and therefore no one, including bots, could mint directly from the contract. All minting actions had to go through their web app, which can be protected from bots using more traditional methods.</p>\n\n\n\n<h3>How did they secure their web app from bots?</h3>\n\n\n\n<ul><li>They required a captcha before a signature was generated, which prevents most web bots.</li><li>Before the public mint, only addresses on an allow list based on NFT ownership were able to mint.</li></ul>\n\n\n\n<p>This allow list was generated from a snapshot ~2 weeks before minting was enabled. But unlike many allow list snapshots, it wasn&#8217;t put into the contract. Instead they must have made a database for their web app to check against, which was only used during the pre-sale.</p>\n\n\n\n<h3>How did they make a signature in a web app that could be verified within the contract?</h3>\n\n\n\n<p>Libraries like <a href=\"https://github.com/ChainSafe/web3.js\">web3.js</a> provide a way to <a href=\"https://web3js.readthedocs.io/en/v1.7.3/web3-eth-accounts.html#sign\">sign</a> data in javascript using a private key. The library also provides <a href=\"https://web3js.readthedocs.io/en/v1.7.3/web3-eth-accounts.html#hashmessage\">message hashing</a>. So by using a library like web3.js in a server-side web app, you can do the following:</p>\n\n\n\n<ol><li>Encode function arguments into a message</li><li>Hash that message</li><li>Sign the hash</li></ol>\n\n\n\n<p>The hash and signature can then be returned from the web app to the browser, then passed to the contract, thereby preventing direct contract minting.</p>\n\n\n\n<h2>Hash Transaction</h2>\n\n\n\n<p>This function reconstructs the hashed message that was signed. It does this by encoding the arguments, then hashing them with solidity&#8217;s standard hashing algorithm, <a href=\"https://cryptomarketpool.com/keccak256/\">keccak256</a>.</p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-solidity\">    function hashTransaction(address sender, uint256 qty, uint256 maxAmountAllowed) private pure returns(bytes32) {\n          bytes32 hash = keccak256(abi.encodePacked(\n            \"\\x19Ethereum Signed Message:\\n32\",\n            keccak256(abi.encodePacked(sender, qty, maxAmountAllowed)))\n          );\n          return hash;\n    }</code></pre>\n\n\n\n<p>That&#8217;s about it for the minting. Let&#8217;s see what Slither says&#8230;</p>\n\n\n\n<h2>Slither Analysis</h2>\n\n\n\n<p><a href=\"https://github.com/crytic/slither\">Slither</a> is a python tool for static analysis of Solidity contracts. You can use it to get a quick summary of the contract code, and then look for any deeper issues.</p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-bash\">$ slither 0x545f0a45Ba06C7C5b1a5Fb0b29008462ceEA07b7 --print human-summary</code></pre>\n\n\n\n<figure class=\"wp-block-image size-large\"><a href=\"https://i0.wp.com/streamhacker.com/wp-content/uploads/2022/04/Screen-Shot-2022-04-20-at-10.36.02-PM.png?ssl=1\"><img decoding=\"async\" loading=\"lazy\" width=\"474\" height=\"361\" src=\"https://i0.wp.com/streamhacker.com/wp-content/uploads/2022/04/Screen-Shot-2022-04-20-at-10.36.02-PM.png?resize=474%2C361&#038;ssl=1\" alt=\"\" class=\"wp-image-2311\" srcset=\"https://i0.wp.com/streamhacker.com/wp-content/uploads/2022/04/Screen-Shot-2022-04-20-at-10.36.02-PM.png?resize=1024%2C779&ssl=1 1024w, https://i0.wp.com/streamhacker.com/wp-content/uploads/2022/04/Screen-Shot-2022-04-20-at-10.36.02-PM.png?resize=300%2C228&ssl=1 300w, https://i0.wp.com/streamhacker.com/wp-content/uploads/2022/04/Screen-Shot-2022-04-20-at-10.36.02-PM.png?resize=768%2C584&ssl=1 768w, https://i0.wp.com/streamhacker.com/wp-content/uploads/2022/04/Screen-Shot-2022-04-20-at-10.36.02-PM.png?w=1304&ssl=1 1304w, https://i0.wp.com/streamhacker.com/wp-content/uploads/2022/04/Screen-Shot-2022-04-20-at-10.36.02-PM.png?w=948&ssl=1 948w\" sizes=\"(max-width: 474px) 100vw, 474px\" data-recalc-dims=\"1\" /></a></figure>\n\n\n\n<p>No significant issues found. Nearly all the issues are in the dependency contracts, which are pretty standard, and the only issues Slither finds for <code>ThePicaroons</code> contract are cosmetic.</p>\n\n\n\n<h2>Gas Efficiency</h2>\n\n\n\n<p>The contract uses <a href=\"https://docs.openzeppelin.com/contracts/4.x/api/token/erc721#ERC721Enumerable\">ERC721Enumerable</a>. While it&#8217;s a somewhat common extension to ERC721, and it adds some useful functionality, it definitely increases gas costs for minting and transfers. <a href=\"https://www.azuki.com/erc721a\">Azuki did a deep analysis</a> of this and created <a href=\"https://github.com/chiru-labs/ERC721A\">ERC721A</a> to solve this gas issue without losing key functionality. Using ERC721A would have been a nice improvement to the Picaroons contract, but the contract is otherwise very simple and efficient.</p>\n\n\n\n<h2>Provenance Hash</h2>\n\n\n\n<p>One final detail in the contract is the use of a <a href=\"https://medium.com/coinmonks/the-elegance-of-the-nft-provenance-hash-solution-823b39f99473\">NFT Provenance Hash</a>. This can be used to verify that the reveal after mint was defined before minting began, and not manipulated after mint but before reveal. The fourth transaction on the contract, right after public mint was enabled, was to <a href=\"https://etherscan.io/tx/0xa7b9d5a67e71bd6adc1594fab66007d9574fe7c0d95eeba653b63fd7d7e15b07\">set the provenance hash</a> to <code>e4b58ca66f8bf42902acff422cb634ff8c6d012627a71f195071c725558670b9</code>. While they don&#8217;t give a nice breakdown on their <a href=\"https://thepicaroons.com/\">website</a> for verifying the metadata of the tokens, like <a href=\"https://boredapeyachtclub.com/#/provenance\">BAYC</a> does, it&#8217;s still a good thing to do and provides that verification capability to anyone that wants to do the work.</p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-\">    /// Set the smart-contract proof as an hash of all NFT metadata hashes\n    /// @param hash of all NFTs metadata hashes\n    function setProvenanceHash(string calldata hash) external onlyOwner notLocked {\n        proof = hash;\n    }</code></pre>\n",
  "wfw:commentRss": "https://streamhacker.com/2022/04/22/picaroons-contract-review/feed/",
  "slash:comments": 0,
  "post-id": 2307
}