{
  "title": "Migrating Spark from EMR on EC2 to EMR on EKS.",
  "description": "<p>Data scientists write tasks that transform data, train models, do queries over large datasets, and deploy these models into production. We have championed autonomy for our data scientists and given them the ability to go end-to-end without needing direct support from engineering.</p>\n\n<p>Since our last post on<a href=\"https://multithreaded.stitchfix.com/blog/2018/02/22/flotilla/\"> Flotilla</a>, we’ve continued to modify it to support Kubernetes and Spark. This post summarizes the changes we made to Flotilla to help support Spark and some generalizable lessons that others in the Kubernetes/EKS community can benefit from.</p>\n\n<h1 id=\"our-usage-of-spark\">Our usage of Spark</h1>\n\n<p>We run about 8,000 Spark jobs/day; most read and write from the data warehouse. Some of them are doing model training or scoring. About 100 Data Scientists own the individual Spark jobs. The jobs get triggered via scheduled workflows, external triggers, or human action. We also use Spark for data exploration via notebooks and internal abstractions that simplify use and provide a programmatic interface.</p>\n\n<h1 id=\"our-challenges-with-emr-on-ec2\">Our challenges with EMR on EC2</h1>\n\n<p>EMR on EC2 has served our production Spark workloads for over five years, it has served us well. However, there are some limitations we experienced.</p>\n\n<h3 id=\"non-adaptive-provisioning\">Non-adaptive Provisioning</h3>\n\n<p>We face some operational and business challenges while running Spark on EMR. Our scheduled workloads tend to have some seasonality. However, the ad-hoc exploration of the researchers tends to be unpredictable, with bursts of high usage. While it is always a challenge to predict compute resources needed at a given time, we were either over-provisioning or under-provisioning. In turn, this led to suboptimal outcomes (e.g., wasted resources or queued jobs).</p>\n\n<h3 id=\"lack-of-spark-version-agility\">Lack of Spark version agility</h3>\n\n<p>A given EMR cluster couldn’t run multiple versions of Spark simultaneously. The consequence of this was a burden for migration and testing. We were routinely creating new EMR clusters to test out against new dependencies. The added infrastructure burden delayed upgrades and increased the accumulation of technical debt.</p>\n\n<h3 id=\"scattered-visibility\">Scattered Visibility</h3>\n\n<p>We have internal abstractions for issuing the Spark jobs. However, some of the underlying infrastructure bubbled through (e.g., the YARN resource manager, links to s3 log files, etc.). This created a leaky abstraction where there wasn’t a single place to visualize Spark job metrics, Executor/Driver Logs, and the Application UI.</p>\n\n<p>The user experience was suboptimal for debugging (e.g., examining why a job failed). Also, data scientists had to hop between services to get to the root cause. For instance - debugging executor failures due to out-of-memory was often tricky. Data scientists often needed to look through a separate dashboard to cross-reference their memory consumption. Since Spark is a distributed computational framework - failure stack traces wouldn’t always be informative about the root cause since it maybe a red herring.</p>\n\n<h3 id=\"lack-of-configuration-agility\">Lack of configuration agility</h3>\n\n<p>Spark jobs can fail for many reasons: code flaws, data issues, insufficient resources (especially executor or driver memory), dependency failures, node failures, or spot terminations. There is a lot of complexity in orchestrating distributed tasks that execute over multiple nodes and even across Availability Zones.</p>\n\n<p>We wanted container metrics, near-immediate access to logs, job exit reason(s), and the ability to change the underlying execution environment to remediate the failure reason(s) automatically.</p>\n\n<h2 id=\"our-approach--migration-to-eks\">Our Approach:  Migration to EKS</h2>\n\n<p>The driving goal was to provide our data scientists’ the best user experience and reliability of job execution to our data scientists’. What if we made it easier for users to know what went wrong so they could adjust and if we could automatically adapt to their resource usage patterns?</p>\n\n<p>We already use AWS EKS to run our batch computation. From that perspective, we were faced with the decision to either use Spark’s integration with Kubernetes or use EMR on EKS. Our choice was EMR on EKS since it offered a simpler integration path and good binding for IAM, EMRFS, and S3, and AWS-provided integrations and container images.</p>\n\n<h3 id=\"autoscaling-and-custom-scheduler\">Autoscaling and Custom Scheduler</h3>\n\n<p>We use <a href=\"https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler\">Cluster Autoscaler</a> on our EKS clusters and, as Spark pods are scheduled, EKS cluster nodes are added or removed based on load. We use an aggressive Cluster Autoscaler configuration to cull nodes after an unused interval of 5 minutes and a scanning interval of 1 minute.</p>\n\n<figure style=\"margin-bottom: 1rem;margin-left: 2rem;margin-right: 2rem;\">\n<img src=\"/assets/posts/2022-03-14-spark-eks/image1.png\" />\n<figcaption style=\"text-align:center\"><i>Nodes are scaled up and down based on load on the cluster.</i></figcaption>\n</figure>\n<p>We also use a custom scheduler on our EKS clusters to efficiently pack our nodes. Below is the scheduling policy used. The custom scheduler policy ensures nodes are well utilized, and the cluster autoscaler culls those unused nodes. The priority “MostRequestedPriority” favors nodes with the most requested resources.</p>\n\n<p>This policy will fit the scheduled Pods onto the smallest number of Nodes needed to run your overall set of workloads. The default scheduler favors LeastRequestedPriority. This result favors the even distribution of load across the cluster.</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>{\n  \"kind\":\"Policy\",\n  \"apiVersion\":\"v1\",\n  \"priorities\":[\n    {\n      \"name\":\"MostRequestedPriority\",\n      \"weight\":25\n    },\n    {\n      \"name\":\"BalancedResourceAllocation\",\n      \"weight\":20\n    },\n    {\n      \"name\":\"ImageLocalityPriority\",\n      \"weight\":5\n    },\n    {\n      \"name\":\"ServiceSpreadingPriority\",\n      \"weight\":1\n    },\n    {\n      \"name\":\"NodePreferAvoidPodsPriority\",\n      \"weight\":1\n    },\n    {\n      \"name\":\"NodeAffinityPriority\",\n      \"weight\":1\n    },\n    {\n      \"name\":\"TaintTolerationPriority\",\n      \"weight\":1\n    },\n    {\n      \"name\":\"SelectorSpreadPriority\",\n      \"weight\":1\n    },\n    {\n      \"name\":\"InterPodAffinityPriority\",\n      \"weight\":1\n    },\n    {\n      \"name\":\"EqualPriority\",\n      \"weight\":1\n    }\n  ]\n}\n</code></pre></div></div>\n\n<h3 id=\"container-images\">Container Images</h3>\n\n<p>Our container images derive from the official EMR on EKS images. We compose our binaries and dependencies with these official images. In the end, we have separate images for different versions of Spark and Python.</p>\n\n<p>Meanwhile, the same cluster can run multiple versions of Spark. This significantly simplifies the testing and validation process. Testing a new version only requires producing a new container image base and running an ad hoc testing job.</p>\n\n<p>Also, we install commonly used dependencies (gcc, boto3, numpy, pandas etc.) into our container images, which reduces the startup time. Further, each cluster node uses the <a href=\"http://blog.itaysk.com/2017/12/26/the-single-use-daemonset-pattern-and-prepulling-images-in-kubernetes\">image pre-puller</a> pattern to cache the Spark images to improve job startup time.</p>\n\n<h3 id=\"job-and-pod-events\">Job and Pod Events</h3>\n\n<p>We combined EKS pod events and <a href=\"https://docs.aws.amazon.com/emr/latest/EMR-on-EKS-DevelopmentGuide/monitoring.html#monitoring-cloudwatch-events\">EMR on EKS CloudWatch events</a> to get a complete picture of a Spark job. The pod events are very granular and provide visibility into the setup, execution, and tear down of a job. The EMR events give a high-level overview of the job state (i.e., queued, started, or finished).</p>\n\n<p>Currently, EKS doesn’t provide a way to set a TTL on Kubernetes events. Under heavy load, the large number of event objects have the potential of <a href=\"https://openai.com/blog/scaling-kubernetes-to-2500-nodes/\">overwhelming the etcd cluster</a>. Monitoring object counts and etcd request latency has been essential in preventing etcd failures.</p>\n\n<figure style=\"margin-bottom: 1rem;margin-left: 2rem;margin-right: 2rem;\">\n<img src=\"/assets/posts/2022-03-14-spark-eks/image2.png\" />\n<figcaption style=\"text-align:center\"><i>ETCD event counts</i></figcaption>\n</figure>\n\n<h3 id=\"logging\">Logging</h3>\n\n<p>The Flotilla user interface streams the logs from S3 log locations created by the Spark job execution. Each of the container logs comes from the driver, executor, and controller pods.</p>\n\n<figure style=\"margin-bottom: 1rem;margin-left: 2rem;margin-right: 2rem;\">\n<img src=\"/assets/posts/2022-03-14-spark-eks/image3.png\" />\n<figcaption style=\"text-align:center\"><i>Flotilla UI provides an integrated experience to surface driver, executor, and controller logs.</i></figcaption>\n</figure>\n\n<p>A data scientist sometimes needs to dig into the Spark job logs to get a better understanding of the failures or performance issues. We surface all the jobs logs in a unified user experience to make tracing and debugging easier for the data scientist. Also, we extract and highlight errors and exceptions for quicker resolution.</p>\n\n<figure style=\"margin-bottom: 1rem;margin-left: 2rem;margin-right: 2rem;\">\n<img src=\"/assets/posts/2022-03-14-spark-eks/image4.png\" />\n<figcaption style=\"text-align:center\"><i>Flotilla UI also surfaces and extracts errors and exceptions in the logs.</i></figcaption>\n</figure>\n\n<h3 id=\"metrics\">Metrics</h3>\n\n<p>As the containers are running on EKS, we have the cluster instrumented with <a href=\"https://victoriametrics.com/\">Victoria Metrics </a>to collect detailed container metrics. These metrics are visualized via Grafana. With these tools, we can diagnose difficult shuffles, disk spills, needed or unneeded caching, mis-sized executors, poor concurrency, CPU throttling, memory usage, network throttling, and many other job execution details.</p>\n\n<figure style=\"margin-bottom: 1rem;margin-left: 2rem;margin-right: 2rem;\">\n<img src=\"/assets/posts/2022-03-14-spark-eks/image5.png\" />\n<figcaption style=\"text-align:center\"><i>Grafana dashboard provides visibility into the job and container metrics.</i></figcaption>\n</figure>\n\n<h3 id=\"spark-application-ui\">Spark Application UI</h3>\n\n<h4 id=\"active-jobs\">Active Jobs</h4>\n\n<p>By default, the Spark driver pods establish an internal Cluster IP-based service for the Spark drivers and expose the Application UI on port 4040. Our users of Spark are outside of this cluster. To mitigate this, we implemented a proxy that exposes the Application UI without setting up an ingress or externally facing service. Due to the high volume of jobs, setting up LoadBalancers or Ingress would have been expensive (and potentially run into API limits). Instead, the proxy runs on a persistent DNS and uses job id to the path to locate the appropriate Spark Driver service within the cluster.</p>\n\n<h4 id=\"completed-jobs\">Completed Jobs</h4>\n\n<p>We use the JSON event log file saved on S3 and a <a href=\"https://docs.aws.amazon.com/glue/latest/dg/monitor-spark-ui-history.html#monitor-spark-ui-history-local\">persistent history</a> server to serve the UI for completed applications on job completion.</p>\n\n<h3 id=\"adaptive-behaviors\">Adaptive Behaviors</h3>\n\n<p>The other side of the coin to observability is remediation and resolution. We have tried to solve some of the common failure reasons for Spark jobs through automatic adaptation of the configuration.</p>\n\n<h4 id=\"executor-and-driver-memory\">Executor and Driver Memory</h4>\n\n<p>If a job failed due to Executor or Driver running out of memory (<a href=\"https://komodor.com/learn/how-to-fix-oomkilled-exit-code-137/\">exit code 137</a>). We automatically schedule the next run with more memory.</p>\n\n<figure style=\"margin-bottom: 1rem;margin-left: 2rem;margin-right: 2rem;\">\n<img src=\"/assets/posts/2022-03-14-spark-eks/image6.png\" />\n</figure>\n\n<figure style=\"margin-bottom: 1rem;margin-left: 2rem;margin-right: 2rem;\">\n<img src=\"/assets/posts/2022-03-14-spark-eks/image7.png\" />\n<figcaption style=\"text-align:center\"><i>Shows the reduction of failures in Spark jobs due to OOM of driver or executors.</i></figcaption>\n</figure>\n\n<h4 id=\"executor-counts\">Executor Counts</h4>\n\n<p>When a job is retried, we progressively increase executor counts (until a max limit is reached). This helps us smoothen out failures that may have been caused by data seasonality or failures due to data partitioning. The progression also helps start at a lower number of default executor counts. This helps with trying to strike a balance between the total number of executor pods versus the size of the EKS cluster.</p>\n\n<h4 id=\"exception-extraction\">Exception Extraction</h4>\n\n<p>The exception and stack traces that are extracted from the logs helps us identify retryable errors, like downstream 5xy errors or transient errors.</p>\n\n<h4 id=\"node-affinity-selection\">Node Affinity Selection</h4>\n\n<p>Spot nodes offer a significant cost advantage over on-demand instances. However, they can suffer from sudden terminations. We always run the driver pods on on-demand instances, and the executors can be scheduled on spot or on-demand instances. If a job is business-critical or we deem that the current climate is prone to a high likelihood of spot termination, we also schedule the executors on on-demand instances.</p>\n\n<p>Flotilla assigns job retries on on-demand instances. The node selector optimizations help us keep a high SLA and minimize the infrastructure costs. We can make a runtime decision on where and how a job runs without needing to provision new clusters.</p>\n\n<h2 id=\"outcomes-from-the-migration-to-eks\">Outcomes from the migration to EKS</h2>\n\n<h3 id=\"more-predictable-job-execution\">More predictable job execution</h3>\n\n<p>We are seeing about a 25% reduction in job failures due to timeouts and a 90% reduction in job failures due to out-of-memory errors. Scheduling delay with a p99 of around 5 minutes (when resources need provisioning). Job execution improvements translate to fewer alerts and pages for our data teams to diagnose in more direct terms.</p>\n\n<h3 id=\"reduction-in-infrastructure-cost\">Reduction in infrastructure cost</h3>\n\n<p>We are seeing about a 45-55% reduction in infrastructure cost for all our Spark-based compute. We can spin up resources faster and react to incoming demand. Also, aggressive node packing and culling strategies help reduce waste.</p>\n\n<h3 id=\"reduction-in-operational-burden\">Reduction in operational burden</h3>\n\n<p>The EKS cluster scales up and down as per the demands of the pods, and we have guardrails in place to prevent runoffs. We monitor and alert on cluster and service metrics. However, we utilize the elasticity of the cloud to meet our internal SLAs.</p>\n\n<h3 id=\"improved-ability-to-fix-failing-spark-jobs\">Improved ability to fix failing Spark jobs</h3>\n\n<p>We have better visibility into job state via a unified view into logging, metrics, and events. The enhanced visibility has helped our Data Scientists resolve problems more quickly and easily and thus become more productive.</p>\n\n<h2 id=\"convergence-on-kubernetes\">Convergence on Kubernetes</h2>\n\n<p>The migration to running Spark on EKS has helped reduce our technology skew and converge on a standard set of tooling. The use of containerized workloads also offers the benefits of utilization of clusters for disparate workloads while providing a common pattern of deployment and auditing.</p>\n\n<p>Flotilla initially started as an abstraction layer on AWS ECS. Over time we have adapted it to use Kubernetes as the backend. Refactoring Flotilla as a <a href=\"https://kubernetes.io/docs/concepts/extend-kubernetes/operator/\">Kubernetes Operator</a> presents some advantages. It simplifies the job reconciliation loop and opens up possibilities for more native integration with Kubernetes.</p>",
  "pubDate": "Mon, 14 Mar 2022 09:00:00 +0000",
  "link": "https://multithreaded.stitchfix.com/blog/2022/03/14/spark-eks/",
  "guid": "https://multithreaded.stitchfix.com/blog/2022/03/14/spark-eks/"
}