{
  "title": "How to Implement a B-Tree Data Structure (2022 Version)",
  "link": "https://www.dataquest.io/blog/b-tree-data-structure/",
  "comments": "https://www.dataquest.io/blog/b-tree-data-structure/#respond",
  "dc:creator": "Mehdi Lotfinejad",
  "pubDate": "Wed, 19 Oct 2022 08:00:06 +0000",
  "category": [
    "Data Science Tutorials",
    "b-tree data structure",
    "Data Science",
    "Tutorials"
  ],
  "guid": "https://www.dataquest.io/?p=41385",
  "description": "Rudolf Bayer and Edward M. McCreight coined the term B-tree data structure at the Boeing Research Labs in 1971. They published a scientific paper titled \"Organization and maintenance of large ordered indices\" and introduced a new data structure for fast data retrieval from disks. Although the B-tree data structure has evolved over the decades, understanding [&#8230;]",
  "content:encoded": "<p>Rudolf Bayer and Edward M. McCreight coined the term <strong>B-tree</strong> data structure at the Boeing Research Labs in 1971. They published a scientific paper titled \"Organization and maintenance of large ordered indices\" and introduced a new data structure for fast data retrieval from disks. Although the B-tree data structure has evolved over the decades, understanding its concepts is still valuable.</p>\n<p>Here&#8217;s what we&#8217;ll cover in this tutorial:</p>\n<ul>\n<li>B-tree data structures</li>\n<li>B-tree properties</li>\n<li>Traversing in a B-tree</li>\n<li>Searching in a B-tree</li>\n<li>Inserting a key in a B-tree</li>\n<li>Deleting a key in a B-tree</li>\n</ul>\n<p>Let&#8217;s get started!</p>\n<h2>What Is a B-Tree Data Structure?</h2>\n<p>A B-tree is a self-balanced tree data structure that is a generalized form of the Binary Search Tree (BST). However, unlike a binary tree, each node can have more than two children. In other words, each node can have up to <em>m</em> children and <em>m-1</em> keys; also, each node must have at least $\\lceil \\frac{m}{2} \\rceil$ children to keep the tree balanced. These features keep the tree’s height relatively small. </p>\n<p>A B-tree data structure keeps the data sorted and allows searching, inserting, and deleting operations performed in amortized logarithmic time. To be more specific, the time complexity for accomplishing the mentioned operations is $O(log {n})$, where <em>n</em> is the number of keys stored in the tree.</p>\n<p>Let’s assume we have to store a tremendous amount of data in a computer system. In this common situation, we&#8217;re definitely unable to store the whole data in the main memory (RAM), and most of the data should be kept on disks. We also know that the secondary storage (various types of disks) is much slower than RAM. So, when we have to retrieve the data from the secondary storage, we need optimized algorithms to reduce the number of disk access.</p>\n<p>The B-Tree data structure tries to minimize the number of disk access using advanced techniques and optimized algorithms for searching, inserting, and deleting, all of which allow the B-tree to stay balanced and, therefore, ensure finding data in logarithmic time. </p>\n<p>To reveal how powerful B-tree is in minimizing disk access, let’s refer to the book <em>Introduction to Algorithms</em>, which proves that a B-tree with a height of two and 1001 children is able to store more than one billion keys. Still, only a disk access of two is required to find any key (Cormen et al., 2009).</p>\n<p>We&#8217;ll discuss the properties of B-tree and how it works in the following sections.</p>\n<h2>B-Tree Properties</h2>\n<p>There are three types of nodes in a B-tree of order m, and each of them has the following properties:</p>\n<ul>\n<li>Root Node\n<ul>\n<li>A root node has between $2$ and $m$ children.</li>\n</ul>\n</li>\n<li>Internal Nodes\n<ul>\n<li>Each internal node has between $\\lceil \\frac{m}{2} \\rceil$ and $m$ children — both ends are included.</li>\n<li>Each internal node may contain up to $m-1$ keys.</li>\n</ul>\n</li>\n<li>Leaf Nodes\n<ul>\n<li>All leaf nodes are at the same level.</li>\n<li>Each leaf node stores between  $\\lceil \\frac{m-1}{2} \\rceil$ and $m-1$ keys — both ends are included.</li>\n</ul>\n</li>\n<li>\n<p>The height of a B-Tree can be yielded via the following equation:</p>\n<p>$h \\leq log _{m}{\\frac{n+1}{2}}$, where <em>m</em> is the minimum degree and <em>n</em> is the number of keys.</p>\n</li>\n</ul>\n<p>The illustration below shows a B-tree data structure.</p>\n<p><img src=\"https://www.dataquest.io/wp-content/uploads/2022/10/s000.png\" alt=\"s000.png\" /></p>\n<h2>Traversing in a B-Tree</h2>\n<p>To traverse a B-Tree, the traversal program starts from the leftmost child and prints its keys recursively. It repeats the same process for the remaining children and keys until the rightmost child.</p>\n<h2>Searching in a B-Tree</h2>\n<p>Searching for a specific key in a B-Tree is a generalized form of searching in a Binary Search Tree (BST). The only difference is that the BST performs a binary decision, but in the B-tree, the number of decisions at each node is equal to the number of the node&#8217;s children.</p>\n<p>Let&#8217;s search key 102 in the B-tree above:</p>\n<ol>\n<li>The root&#8217;s key is not equal to 102, so since k > 100, go to the leftmost node of the right branch.</li>\n</ol>\n<p><img src=\"https://www.dataquest.io/wp-content/uploads/2022/10/s001.png\" alt=\"s001.png\" /></p>\n<ol start=\"2\">\n<li>\n<p>Compare k with 103; since k < 103, go to the left branch of the current node.</p>\n</li>\n<li>\n<p>Compare k with the leaf&#8217;s key; k exists there.</p>\n</li>\n</ol>\n<p><img src=\"https://www.dataquest.io/wp-content/uploads/2022/10/s002.png\" alt=\"s002.png\" /></p>\n<p>As shown, if the key we&#8217;re looking for isn&#8217;t in the range of the parent node, then most likely the key is in another branch. The algorithm will keep doing this to reach a leaf node. If it doesn&#8217;t find the key, the algorithm returns NULL.</p>\n<h2>Inserting a Key in a B-Tree</h2>\n<p>So far, we&#8217;ve discussed traversing a B-tree and searching for a specific key in a B-tree data structure. This section will discuss how we can insert a new key into a B-Tree.</p>\n<p>Inserting a new node into a B-tree includes two steps: finding the correct node to insert the key and splitting the node if the node is full (the number of the node’s keys is greater than m-1).</p>\n<ol>\n<li><strong>If the B-Tree is empty:</strong> \n<ol>\n<li>Allocate a root node, and insert the key.</li>\n</ol>\n</li>\n<li><strong>If the B-Tree is not empty:</strong>\n<ol>\n<li>Find the proper node for insertion.</li>\n<li><strong>If the node is not full:</strong> \n<ol>\n<li>Insert the key in ascending order.</li>\n</ol>\n</li>\n<li><strong>If the node is full:</strong> \n<ol>\n<li>Split the node at the median. </li>\n<li>Push the median key upward, and make the left keys a left child node and the right keys a right child node.</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h2>Deleting a Key in a B-Tree</h2>\n<p>Deletion is one of the operations we can perform on a B-tree. We can perform the deletion at the leaf or internal node levels. To delete a node from a B-tree, we need to follow the algorithm below:</p>\n<ol>\n<li>\n<p><strong>If the node to delete is a leaf node:</strong></p>\n<ol>\n<li>Locate the leaf node containing the desired key.</li>\n<li>If the node has at least $\\lfloor \\frac{m}{2} \\rfloor$ keys, delete the key from the leaf node.</li>\n<li>If the node has less than $\\lfloor \\frac{m}{2} \\rfloor$ keys, take a key from its right or left immediate sibling nodes. To do so, do the following:\n<ol>\n<li>If the left sibling has at least $\\lfloor \\frac{m}{2} \\rfloor$ keys, push up the in-order predecessor, the largest key on the left child, to its parent, and move a proper key from the parent node down to the node containing the key; then, we can delete the key from the node.</li>\n<li>If the right sibling has at least $\\lfloor \\frac{m}{2} \\rfloor$ keys, push up the in-order successor, the smallest key on the right child, to its parent and move a proper key from the parent node down to the node containing the key; then, we can delete the key from the node.</li>\n<li>If the immediate siblings don&#8217;t contain at least $\\lfloor \\frac{m}{2} \\rfloor$ keys, create a new leaf node by joining two leaf nodes and the parent node&#8217;s key.</li>\n<li>If the parent is left with less than $\\lfloor \\frac{m}{2} \\rfloor$ keys, apply the above process to the parent until the tree becomes a valid B-Tree.</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p><strong>If the node to delete is an internal node:</strong></p>\n<ol>\n<li>Replace it with its in-order successor or predecessor. Since the successor or predecessor will always be on the leaf node, the process will be similar as the node is being deleted from the leaf node.</li>\n</ol>\n</li>\n</ol>\n<h2>Conclusion</h2>\n<p>This tutorial discussed B-trees and the application of B-trees for storing a large amount of data on disks. We also discussed four primary operations in B-trees: traversing, searching, inserting, and deleting. If you&#8217;re interested in learning more about the actual implementation of a B-tree in Python, this <a href=\"https://gist.github.com/teepark/572734\">GitHub repo</a> shares the implementation of the B-tree data structure in Python.</p>\n<p>I hope that you have learned something new today. Feel free to connect with me on <a href=\"https://www.linkedin.com/in/lotfinejad/\">LinkedIn</a> or <a href=\"https://twitter.com/lotfinejad\">Twitter</a>.</p>\n<pre><code class=\"language-python\"></code></pre>\n",
  "wfw:commentRss": "https://www.dataquest.io/blog/b-tree-data-structure/feed/",
  "slash:comments": 0
}