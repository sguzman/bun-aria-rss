{
  "title": "Deployment for Free -- A Machine Learning Platform for Stitch Fix's Data Scientists",
  "description": "<style>\ntable.deployment-for-free {\n  margin: 0 auto calc(0.5rem + 15px);\n  width: 100%;\n}\ntable.deployment-for-free th {\n  font-weight: normal;\n  text-align: right;\n}\ntable.deployment-for-free th div.MathJax_Display {\n  text-align: right !important;\n}\ntable.deployment-for-free tr:nth-child(even) {\n  background-color: #F2EFEA;\n}\ntable.deployment-for-free td {\n    border-bottom: 1px solid #cdcac8;\n    padding: 0.5em;\n    text-align: left;\n}\n\nfigure figcaption {\n    text-align: center;\n}\n</style>\n\n<p>Our team’s favorite interview question to ask potential platform engineers is <em>what defines your ideal Machine Learning platform, and how would you build it?</em> By asking this, we aim to dive into the applicant’s thought process around the abstraction they would build to represent a model. Would they exert control over the type, shape, and approach of the model in exchange for a more operationally simple system? Or would they let data scientists run wild, creating any kind of model one can dream up?</p>\n\n<p>At Stitch Fix, data scientist autonomy and quick iteration are paramount to our operational capabilities—above all, we value flexibility. If we can’t quickly iterate on a good idea, we’re doing our clients (and ourselves) a disservice. Aside from requiring production models to be written in Python, anything goes.</p>\n\n<p>Our question often turns into a lively debate on the merits of different platform architectures. At Stitch Fix, we’ve concluded that what we initially perceived as a trade-off is not one at all: a machine learning platform can be <strong>operationally simple</strong>, <strong>framework-agnostic</strong>, and <strong>intuitive</strong> at the same time. We know because we’ve implemented such a platform at Stitch Fix and have achieved widespread adoption and success.</p>\n\n<p>In this blog post, we’re going to share our initial design considerations for the platform we built, present the API data scientists use to interact with it, and detail its capabilities.</p>\n\n<h1 id=\"designing-for-stitch-fix\">Designing for Stitch Fix</h1>\n\n<h2 id=\"requirements\">Requirements</h2>\n<p>What does it mean for a tool to be <strong>operationally simple</strong>, <strong>framework-agnostic</strong>, and <strong>intuitive</strong>? We required the following:</p>\n\n<ol>\n  <li><strong>Self-service management:</strong> It should be operationally simple for a data scientist to do anything they want with their models. They should not have to go through the platform team to productionalize a model; instead, the platform should present an intuitive, straightforward way to plug their models back into the business and track their performance.</li>\n  <li><strong>Separation of concerns:</strong> It should be intuitive for a data scientist to manage their models in production. We want them to achieve scalability and reliability for free while spending the bulk of their time and efforts on the methodology and implementation of their models.</li>\n  <li><strong>Models as a black box:</strong>  We have no intention of dictating the methodology of a data scientist’s workflow. Thus, we aim to be framework-agnostic for both model inference and training.</li>\n  <li><strong>Less-is-more API:</strong> The more we can automagically derive from the environment, code, etc. about a model, the less a data scientist has to handle when deploying that model. While this can be controversial (the wrong magic is worse than none at all), too many degrees of freedom will make the product less appetizing to adopt.</li>\n</ol>\n\n<h2 id=\"build-or-buy\">Build or Buy?</h2>\n\n<p>We’re not the first people to build a high-caliber ML platform, and we certainly won’t be the last. In fact, we met the maintainers of various open-source products (MLFlow and ModelDB in particular) and were quite impressed. However, we ultimately decided to build our own for several reasons.</p>\n\n<p><strong><em>Leveraging Valuable Infrastructure</em></strong></p>\n\n<p>The Stitch Fix data platform is sophisticated and highly-tailored toward the use-cases of our data scientists. Over the years, data scientists at Stitch Fix have gotten comfortable running batch jobs, writing and maintaining microservices, and storing and managing large quantities of data, all with a few simple commands. Building on top of our current infrastructure gave us a leg up. Instead of adopting an entirely new set of tools, we can easily migrate and tap into existing testing and monitoring ecosystems.</p>\n\n<p><strong><em>Customizing Model Indices</em></strong></p>\n\n<p>The majority of platforms we considered assumed a specific shape for storing models. This took the form of experiments—each model was the next in a series. In Stitch Fix’s case, our models do not follow a linear targeting pattern. They could be applicable to specific regions, business lines, experiments, etc., and all be somewhat interchangeable with each other. Easy management of these dimensions was paramount in how data scientists needed to access their models.</p>\n\n<p><strong><em>Pivoting Towards our Use-Cases</em></strong></p>\n\n<p>When we started drafting our requirements, we had a rough sense of how the platform was going to be used in the future. That said, with a rapidly evolving business, we had limited foresight as to how our requirements would change over time. We needed to be able to pivot as we explored our space of users, so locking in to a specific platform product was not advantageous.</p>\n\n<p>Building our own platform did not, however, preclude taking advantage of external tooling. By investing in the right abstractions, we could easily plug into and test out other tools (monitoring/visibility, metrics/analysis, scalable inference, etc.), gradually replacing pieces that we’ve built with industry standards as they mature.</p>\n\n<p>Taking this all into consideration, we chose the difficult (but ultimately rewarding) path of building it ourselves! We’ve named our platform the <em>Model Envelope</em>. The data scientist puts the model in an envelope, gives it to the platform, and we handle the rest.</p>\n\n<h1 id=\"the-api\">The API</h1>\n\n<p>We designed our API to be as intuitive as possible. We did this by reducing degrees of freedom for data scientists while making it easier to do what they want. This helped (a) lower the cognitive burden on users and (b) enable higher levels of abstraction. Within the platform we designed, we chose to limit what the data scientist needed to get started to two initial actions:</p>\n\n<ol>\n  <li>Write and save a model as a simple Python function</li>\n  <li>Specify a set of tags for the model</li>\n</ol>\n\n<p>The tags take the form of string key/value pairs, allowing a data scientist to index the model and query for it later on.</p>\n\n<p>This is easy to see with the following bare-bones example:</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">import</span> <span class=\"nn\">model_envelope</span> <span class=\"k\">as</span> <span class=\"n\">me</span>\n<span class=\"kn\">import</span> <span class=\"nn\">pandas</span> <span class=\"k\">as</span> <span class=\"n\">pd</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">predict_ltv</span><span class=\"p\">(</span><span class=\"n\">features</span><span class=\"p\">:</span> <span class=\"n\">pd</span><span class=\"p\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">float</span><span class=\"p\">:</span>\n    <span class=\"c1\"># DS code to predict client lifetime revenue from a set of features\n</span>    <span class=\"c1\"># Some DS code, perhaps storing state, perhaps part of a class\n</span>    <span class=\"k\">pass</span>\n    \n\n<span class=\"n\">me</span><span class=\"p\">.</span><span class=\"n\">save_model</span><span class=\"p\">(</span>\n    <span class=\"n\">query_function</span><span class=\"o\">=</span><span class=\"n\">predict_ltv</span><span class=\"p\">,</span>\n    <span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s\">\"client_ltv_model\"</span><span class=\"p\">,</span>\n    <span class=\"n\">description</span><span class=\"o\">=</span><span class=\"s\">\"Predicts client LTV from a set of features\"</span><span class=\"p\">,</span> \n    <span class=\"n\">tags</span><span class=\"o\">=</span><span class=\"p\">{</span>\n        <span class=\"s\">\"business_line\"</span> <span class=\"p\">:</span> <span class=\"s\">\"womens\"</span><span class=\"p\">,</span>\n        <span class=\"s\">\"region\"</span> <span class=\"p\">:</span> <span class=\"s\">\"US\"</span><span class=\"p\">,</span>\n        <span class=\"s\">\"canonical_name\"</span> <span class=\"p\">:</span> <span class=\"s\">\"client_ltv\"</span>\n    <span class=\"p\">},</span>\n    <span class=\"n\">api_input</span><span class=\"o\">=</span><span class=\"n\">training_data</span> <span class=\"c1\"># Loaded earlier, a pd.DataFrame\n</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<p>And it’s as simple as that! In this case, the data scientist also specifies sample input data (e.g., the training data), so the <em>Model Envelope</em> can learn the shape of the function.</p>\n\n<p>While data scientists only need to provide a few pieces of information, we have the capability to store and derive a lot more. In particular:</p>\n\n<div style=\"width: 100%;\">\n<table class=\"deployment-for-free\">\n  <tr>\n   <td class=\"sf-td\">The environment (Python dependencies)\n   </td>\n   <td class=\"sf-td\">\n    Derived from the Python environment on which the model was trained\n   </td>\n  </tr>\n  \n  <tr>\n   <td>Training data/output stats\n   </td>\n   <td class=\"sf-td\">\n    Derived from the specified API input/output\n   </td>\n  </tr>\n  \n  <tr>\n   <td>Non-standard Python dependencies (custom modules)\n   </td>\n   <td class=\"sf-td\">\n    Passed in if needed\n   </td>\n  </tr>\n  \n  <tr>\n   <td class=\"sf-td\">Additional query functions\n   </td>\n   <td class=\"sf-td\">\n    Logged through an API call with the client\n   </td>\n  </tr>\n  \n  <tr>\n   <td>Metrics\n   </td>\n   <td class=\"sf-td\">\n    Logged through an API call with the client\n   </td>\n  </tr>\n  \n</table>\n</div>\n\n<p>This is the essence of the <em>less-is-more</em> API. Data scientists focus on the minimal components they need to get a model out the door, making it easy to iterate on and reason about their model management workflow. The platform can then derive enough information to fill out an expressive interface for a model. This is the <em>hub</em> of what we built—a model artifact database and metastore that enables the platform to handle the rest. Let’s dive into some of the spokes.</p>\n\n<h1 id=\"capabilities\">Capabilities</h1>\n\n<p>The representation of a model we described above enables easy deployment, tracking, and iteration in production. Throughout the next sections, keep in mind that capitalizing upon the following capabilities requires minimal additional code to be written—the majority is configuration and UI-driven.</p>\n\n<h2 id=\"online-inference\">Online Inference</h2>\n\n<p>As Stitch Fix developed a personalized direct-buy shopping experience, the importance of online inference grew significantly. When a client logs into Stitch Fix’s website (or app), every aspect of their <a href=\"https://algorithms-tour.stitchfix.com/\">experience</a> is now optimized by algorithms. They are served by dozens of models, all powered by microservices. The platform we built ensures these services can deploy and scale reliably with the push of a button.</p>\n\n<p>To deploy a model to production with the Model Envelope, a data scientist can do one of two things:</p>\n\n<ol>\n  <li>For iteration or ad-hoc development, click the <em>deploy</em> button in the UI</li>\n  <li>For continuous delivery (CD) of models, set up automatic deployment</li>\n</ol>\n\n<p>The vast majority of models at Stitch Fix are retrained weekly, if not nightly. Thus, option (2) is the preferred choice (after an initial iteration period). To set up a CD routine for their models, a data scientist specifies a set of rules, primarily consisting of a <em>tag query</em>. When a model with tags matching this query is created or updated, the platform deploys that model to a specified URL. The convenience and simplicity of this ensures that the vast majority of Stitch Fix’s models utilize CD—removing the human from the model deployment process entirely. Furthermore, this makes Continuous Integration easy. A deployment rule can require a model to have a tag (say <code class=\"language-plaintext highlighter-rouge\">passes_tests</code>) to be set to <code class=\"language-plaintext highlighter-rouge\">\"true\"</code>, allowing a data scientist to decouple the saving, testing, and shipping of a model to production with a simple configuration.</p>\n\n<p>While the interface is straightforward, it hides a plethora of infrastructure under the hood. Behind the scenes, the platform does the following:</p>\n\n<ol>\n  <li>Listens for model updates to the database on all tag queries</li>\n  <li>Launches a job to deploy a model service. This job:\n    <ul>\n      <li>generates the code for a microservice to execute a model</li>\n      <li>builds a docker image (using the model’s specified Python dependencies)</li>\n      <li>deploys within our internal microservice infrastructure</li>\n      <li>sets up monitoring and alerting, enabling the platform team to manage this service</li>\n    </ul>\n  </li>\n</ol>\n\n<p>As the platform team has control over the shape of the service, each looks effectively the same as any other. We manage hundreds of automatically generated production services, with almost no additional effort. Each has its own API, a unique set of Python dependencies, and runs the specified model artifact. All services automatically scale up to meet traffic demands and are closely monitored by the platform team’s on-call rotation. The result is operational simplicity for both parties. The data scientists cede production support to the platform team, which in turn manages a tranche of reliable and highly homogenous services.</p>\n\n<h2 id=\"batch-inference\">Batch Inference</h2>\n\n<p>While Stitch Fix functions largely as an online shop, batch inference plays a critical role in our workflows. We use it to:</p>\n\n<ol>\n  <li>Snapshot a model’s predictions for debugging/downstream use</li>\n  <li>Run analysis over a model’s predictions (backtests, etc.)</li>\n  <li>Serve cached predictions as an optimization</li>\n</ol>\n\n<p>Executing batch predictions efficiently at scale is a challenging technical problem. It requires in-depth knowledge of (in our case) Spark, broadcasting of a potentially large model, and management of the results. While our data scientists are up to the task, they’d all be doing essentially the same thing: running a large map operation over a set of input data. Since we have all the information we need to run a model, we offer this capability for free.</p>\n\n<p>To do this, we provide a set of batch job operators that work with Stitch Fix’s in-house job-orchestration system (built on top of Airflow). In order to run one of these operators, data scientists have to provide:</p>\n\n<ol>\n  <li>A tag query to determine which model to run</li>\n  <li>Input tables with features in the data warehouse</li>\n  <li>A table to write to in the data warehouse</li>\n  <li>The standard parameters for a batch job (chron specs, dependencies, etc.).</li>\n</ol>\n\n<p>Behind the scenes, the platform handles:</p>\n\n<ol>\n  <li>Downloading and deserializing the latest model that matches the tag query</li>\n  <li>Setting up a Spark driver/cluster</li>\n  <li>Broadcasting the model artifact to the Spark executors</li>\n  <li>Loading the input data, running the model, and saving the output data</li>\n</ol>\n\n<p>And, again, it’s as simple as that! Data scientists only have to think about the <em>where</em> and <em>when</em> to deploy a model in a batch, but not the <em>how</em>. The platform handles that.</p>\n\n<h2 id=\"metrics-tracking\">Metrics Tracking</h2>\n\n<p>Data scientists use metrics/hyperparameters to answer a wide variety of questions. Some of these include:</p>\n\n<ol>\n  <li>How has my model’s training/validation performance varied over time?</li>\n  <li>How has the input data changed over time?</li>\n  <li>What happens to metric <em>a</em> if I modify parameter <em>b</em>?</li>\n  <li>How does the distribution of results for one model compare to the other?</li>\n</ol>\n\n<p>Prior to the introduction of the <em>Model Envelope</em>, any tracking of models was done on an ad-hoc basis. Data scientists utilized custom dashboards, bespoke metrics storage, and <em>ex post facto</em> reports to gain visibility into the performance of their models. With the unifying index of model tags, it is much easier for a data scientist to slice and dice model data to answer all of these questions. All they have to do is log a metric:</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">import</span> <span class=\"nn\">model_envelope</span> <span class=\"k\">as</span> <span class=\"n\">me</span>\n<span class=\"n\">training_data</span> <span class=\"o\">=</span> <span class=\"n\">load_training_data</span><span class=\"p\">(...)</span>\n<span class=\"n\">actuals</span> <span class=\"o\">=</span> <span class=\"n\">load_actuals</span><span class=\"p\">(...)</span>\n<span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">train_model</span><span class=\"p\">(...)</span>\n<span class=\"n\">envelope</span> <span class=\"o\">=</span> <span class=\"n\">me</span><span class=\"p\">.</span><span class=\"n\">save_model</span><span class=\"p\">(...)</span>\n<span class=\"n\">predictions</span> <span class=\"o\">=</span> <span class=\"n\">model</span><span class=\"p\">.</span><span class=\"n\">predict</span><span class=\"p\">(</span><span class=\"n\">training_data</span><span class=\"p\">)</span>\n<span class=\"n\">envelope</span><span class=\"p\">.</span><span class=\"n\">log_metrics</span><span class=\"p\">(</span>\n    <span class=\"c1\"># Log a scalar metric named training_loss\n</span>    <span class=\"n\">training_loss</span><span class=\"o\">=</span><span class=\"n\">calculate_training_loss</span><span class=\"p\">(</span><span class=\"n\">predictions</span><span class=\"p\">,</span> <span class=\"n\">actuals</span><span class=\"p\">),</span>\n    <span class=\"c1\"># Log a more structured metric named roc_curve\n</span>    <span class=\"n\">roc_curve</span><span class=\"o\">=</span><span class=\"n\">calculate_roc_curve</span><span class=\"p\">(</span><span class=\"n\">predictions</span><span class=\"p\">,</span> <span class=\"n\">actuals</span><span class=\"p\">)</span>\n<span class=\"p\">)</span>\n</code></pre></div></div>\n\n<p>Note that they’re not required to do this during training; they can do it in a completely decoupled process.</p>\n\n<p>Data scientists then log onto a tool we call the <em>model operations dashboard</em>, select a set of tags to query, and select a method of visualization, one of…</p>\n\n<h3 id=\"time-series\"><strong>Time Series</strong></h3>\n\n<figure style=\"margin-bottom: 1rem;\">\n  <img aria-describedby=\"time-series\" src=\"/assets/posts/2022-07-14-deployment-for-free/time_series.png\" style=\"width: 100%\" />\n  <figcaption>Visualize a time-series of scalar/vector metrics</figcaption>\n</figure>\n\n<h3 id=\"compare-metrics\"><strong>Compare Metrics</strong></h3>\n\n<figure style=\"margin-bottom: 1rem;\">\n  <img aria-describedby=\"compare-metrics\" src=\"/assets/posts/2022-07-14-deployment-for-free/compare_metrics.png\" style=\"width: 100%\" />\n  <figcaption> Visualize a scatter plot of metric values for a wide array of models that match a tag query </figcaption>\n</figure>\n\n<h3 id=\"compare-models\"><strong>Compare Models</strong></h3>\n\n<figure style=\"margin-bottom: 1rem;\">\n  <img aria-describedby=\"compare-models\" src=\"/assets/posts/2022-07-14-deployment-for-free/compare_models.png\" style=\"width: 100%\" />\n  <figcaption> Compare more structured metrics across a few different models</figcaption>\n</figure>\n\n<p>The tags add a powerful selecting capability, allowing data scientists to filter for specific values and split models into series. The types of metrics are pluggable, with a metrics structuring library we built to allow for easy specification of new metric types.</p>\n\n<p>The dashboard we built, while comprehensive, does not solve every problem. That’s OK! An API and a Python client for querying metrics allows power users to retrieve metrics in bulk and analyze them in their own way.</p>\n\n<h1 id=\"adoption\">Adoption</h1>\n\n<p>We’re thrilled to say that the majority of the Stitch Fix experience is powered by models built with the Model Envelope. Using the tooling laid out in <em><a href=\"https://multithreaded.stitchfix.com/blog/2021/02/09/aggressively-helpful-platform-teams/\">aggressively helpful platform teams</a></em>, we track users of the product. The platform we built powers 50+ production services, has been used by 90 unique users since the beginning of the year, and powers some components of tooling for nearly every data science team. It runs behind the scenes in every critical component of Stitch Fix’s recommendations stack, including Freestyle, the Stitch Fix home feed, and outfit generation. By providing the right high-level tooling, we’ve managed to transform the data scientist experience from thinking about microservices, batch jobs, and notebooks toward thinking about models, datasets, and dashboards.</p>\n\n<h1 id=\"looking-forward\">Looking Forward</h1>\n\n<p>We’ve been able to create a platform that requires few trade offs and allows us to have it all. It makes use of a simple, intuitive API, yet empowers our data scientists to do meaningful work. This has massively benefited the business, allowing us to serve our customers in unique and innovative ways. That said, we still have a ways to go. In particular, we’ve already built the following related products:</p>\n\n<ul>\n  <li>Configuration-driven training pipelines (blog post to come!)</li>\n  <li>Framework-specific plugins for training</li>\n</ul>\n\n<p>And are thinking through some exciting new possibilities:</p>\n\n<ul>\n  <li>Ways to optimize certain common tasks (e.g., productionalizing PyTorch models)</li>\n  <li>Ways to integrate feature fetching seamlessly with our models</li>\n  <li>Monitoring for model drift between training and production</li>\n  <li>Live monitoring of model performance</li>\n</ul>\n\n<p>We are also considering open-sourcing components of the platform, although that could take some time. In the meanwhile, if you’re interested in getting involved with the work the ML platform team does, check out <a href=\"https://github.com/stitchfix/hamilton\">hamilton</a>, Stitch Fix’s open-source framework for building scalable dataflows.</p>\n\n<p>Developing our ML platform has been a transformative process that involves building trust with data scientists and digging deep to understand their approaches. Doing so successfully is a challenging journey, but when we succeed, we greatly improve the data scientist and client experience.</p>",
  "pubDate": "Thu, 14 Jul 2022 09:00:00 +0000",
  "link": "https://multithreaded.stitchfix.com/blog/2022/07/14/deployment-for-free/",
  "guid": "https://multithreaded.stitchfix.com/blog/2022/07/14/deployment-for-free/"
}