{
  "title": "e020: Putting code in its place",
  "link": "https://newrustacean.com/show_notes/e020/",
  "description": "<p>How do we organize code in Rust? Where do we break it apart into modules or crates, and why?</p>\n<h2 id=\"notes\">Notes</h2>\n<p>Structuring code in a language like Rust can seem a bit more ambiguous than doing the same in a language with classes to attach all our functionality to, but in practice, the concerns are much the same: modules are namespaces, and we group by <em>responsibility</em>. In today's episode, I talk through that philosophy (and give some comparisons to other languages), and then look at what it looks like in practice!</p>\n<h2 id=\"links\">Links</h2>\n<ul>\n<li><a href=\"http://walkercoderanger.com/blog/2015/08/learning-rust-modules/\">Learning Rust Modules</a>, by Jeff Walker, has a nice comparison of C# namespaces and Rust modules.</li>\n<li><a href=\"https://github.com/chriskrycho/lightning-rs/commit/fac341d1c1b4872d62ec05253ee33f056e67d6ce\">The commit on Lightning inspired by this episode</a>.</li>\n</ul>\n<h2 id=\"sponsors\">Sponsors</h2>\n<ul>\n<li>Aleksey Pirogov</li>\n<li>Andreas Fischer</li>\n<li>Andrew Thompson</li>\n<li>Austin LeSure</li>\n<li>Ben Whitley</li>\n<li><a href=\"https://charlieegan3.com\">Charlie Egan</a></li>\n<li>Chris Jones</li>\n<li><a href=\"http://red-oxide.org/\">Chris Palmer</a></li>\n<li><a href=\"http://blog.cgiffard.com\">Christopher Giffard</a></li>\n<li>Dan Abrams</li>\n<li><a href=\"https://twitter.com/daniel_collin\">Daniel Collin</a></li>\n<li><a href=\"https://twitter.com/derekmorr\">Derek Morr</a></li>\n<li>Eugene Bulkin</li>\n<li><a href=\"https://github.com/Limeth\">Jakub \"Limeth\" Hlusička</a></li>\n<li>Jordan Henderson</li>\n<li><a href=\"https://de.linkedin.com/in/juppm\">Jupp Müller</a></li>\n<li>Justin Ossevoort</li>\n<li><a href=\"https://github.com/kaedroho/\">Karl Hobley</a></li>\n<li>Keith Gray</li>\n<li>Lachlan Collins</li>\n<li>Luca Schmid</li>\n<li>Matt Rudder</li>\n<li>Matthew Piziak</li>\n<li><a href=\"https://twitter.com/maxjacobson\">Max Jacobson</a></li>\n<li>Micael Bergeron</li>\n<li>Ovidiu Curcan</li>\n<li><a href=\"https://pascalhertleif.de/\">Pascal Hertleif</a></li>\n<li><a href=\"https://twitter.com/patrickod\">Patrick O'Doherty</a></li>\n<li>Peter Tillemans</li>\n<li>Philipp Keller</li>\n<li>Ralph Giles (\"rillian\")</li>\n<li>Raph Levien</li>\n<li>reddraggone9</li>\n<li>Steven Murawski</li>\n<li><a href=\"http://stuarth.github.io/\">Stuart Hinson</a></li>\n<li>Tyler Harper</li>\n<li>Vesa Kaihlavirta</li>\n<li>Vlad Bezden</li>\n<li>Warren Harper</li>\n<li><a href=\"http://willroe.me\">William Roe</a></li>\n<li>Zaki</li>\n</ul>\n<p>(Thanks to the couple people donating who opted out of the reward tier, as well. You know who you are!)</p>\n<h3 id=\"become-a-sponsor\">Become a sponsor</h3>\n<ul>\n<li><a href=\"https://www.patreon.com/newrustacean\" rel=\"payment\">Patreon</a></li>\n<li><a href=\"https://venmo.com/chriskrycho\">Venmo</a></li>\n<li><a href=\"https://www.dwolla.com/hub/chriskrycho\">Dwolla</a></li>\n<li><a href=\"https://cash.me/$chriskrycho\">Cash.me</a></li>\n<li><a href=\"https://flattr.com/profile/chriskrycho\">Flattr</a></li>\n<li><a href=\"https://paypal.me/chriskrycho\">PayPal.me</a></li>\n</ul>\n<h2 id=\"contact\">Contact</h2>\n<ul>\n<li>New Rustacean:\n<ul>\n<li>Twitter: <a href=\"https://www.twitter.com/newrustacean\">@newrustacean</a></li>\n<li>Email: <a href=\"mailto:hello@newrustacean.com\">hello@newrustacean.com</a></li>\n</ul></li>\n<li>Chris Krycho\n<ul>\n<li>GitHub: <a href=\"https://github.com/chriskrycho\">chriskrycho</a></li>\n<li>Twitter: <a href=\"https://www.twitter.com/chriskrycho\">@chriskrycho</a></li>\n</ul></li>\n</ul>\n",
  "pubDate": "Sat, 01 Apr 2017 12:38:33 -0600",
  "enclosure": "",
  "guid": "44A092E9-78BE-4760-87E2-E94A15DCF5C4",
  "itunes:author": "Chris Krycho",
  "itunes:summary": "How do we organize code in Rust? Where do we break it apart into modules or crates, and why? Structuring code in a language like Rust can seem a bit more ambiguous than doing the same in a language with classes to attach all our functionality to, but in practice, the concerns are much the same: modules are namespaces, and we group by *responsibility*. In today's episode, I talk through that philosophy (and give some comparisons to other languages), and then look at what it looks like in practice!",
  "itunes:duration": "20:20",
  "itunes:episodeType": "full"
}