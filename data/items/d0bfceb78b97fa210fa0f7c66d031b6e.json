{
  "title": "Visualizing GoogLeNet Classes",
  "description": "<img src=\"http://auduno.github.io/deepdraw/images/deepdraw_example_0013.png\" alt=\"birds\" style=\"margin-top:30px;margin-bottom:50px\"/><p>Ever wondered what a deep neural network thinks a Dalmatian should look like? Well, wonder no more.</p>\n\n<!-- more -->\n<br/><p>Recently Google <a href=\"http://googleresearch.blogspot.no/2015/06/inceptionism-going-deeper-into-neural.html\">published a post</a> describing how they managed to use deep neural networks to generate class visualizations and modify images through the so called “inceptionism” method. They later published the code to modify images via the inceptionism method yourself, however, they didn&rsquo;t publish code to generate the class visualizations they show in the same post.</p>\n\n<p>While I never figured out <em>exactly</em> how Google generated their class visualizations, after butchering the <a href=\"https://github.com/google/deepdream\">deepdream code</a> and <a href=\"https://github.com/kylemcdonald/deepdream/blob/master/dream.ipynb\">this</a> ipython notebook from Kyle McDonald, I managed to coach GoogLeNet into drawing these:</p>\n\n<figure style=\"margin-left:-20px;margin-right:-20px;text-align:center\"><img src=\"http://auduno.github.io/deepdraw/images/deepdraw_example_33.jpg\" alt=\"Loggerhead turtle\" style=\"width:300px;display:inline-block;padding-left:15px;padding-right:15px\"/><img src=\"http://auduno.github.io/deepdraw/images/deepdraw_example_0783.png\" alt=\"Screws\" style=\"width:300px;display:inline-block;padding-left:15px;padding-right:15px\"/><figcaption>Generated images from class &ldquo;Loggerhead turtle&rdquo; (left), &ldquo;Screws&rdquo; (right)</figcaption></figure><figure style=\"margin-left:-20px;margin-right:-20px;text-align:center\"><img src=\"http://auduno.github.io/deepdraw/images/deepdraw_example_260.jpg\" alt=\"Chow chow\" style=\"width:300px;display:inline-block;padding-left:15px;padding-right:15px\"/><img src=\"http://auduno.github.io/deepdraw/images/deepdraw_example_0281.png\" alt=\"Tabby cat\" style=\"width:300px;display:inline-block;padding-left:15px;padding-right:15px\"/><figcaption>Generated images from class &ldquo;Chow chow&rdquo; (left), &ldquo;Tabby cat&rdquo; (right)</figcaption></figure><figure style=\"margin-left:-20px;margin-right:-20px;text-align:center\"><img src=\"http://auduno.github.io/deepdraw/images/deepdraw_example_0294.png\" alt=\"Brown bear\" style=\"width:300px;display:inline-block;padding-left:15px;padding-right:15px\"/><img src=\"http://auduno.github.io/deepdraw/images/deepdraw_example_254.jpg\" alt=\"Pug\" style=\"width:300px;display:inline-block;padding-left:15px;padding-right:15px\"/><figcaption>Generated images from class &ldquo;Brown bear&rdquo; (left), &ldquo;Pug&rdquo; (right)</figcaption></figure><figure style=\"margin-left:-20px;margin-right:-20px;text-align:center\"><img src=\"http://auduno.github.io/deepdraw/images/deepdraw_example_bee_309.jpg\" alt=\"Bee\" style=\"width:300px;display:inline-block;padding-left:15px;padding-right:15px\"/><img src=\"http://auduno.github.io/deepdraw/images/deepdraw_examples_76.jpg\" alt=\"Tarantula\" style=\"width:300px;display:inline-block;padding-left:15px;padding-right:15px\"/><figcaption>Generated images from class &ldquo;Bee&rdquo; (left), &ldquo;Tarantula&rdquo; (right)</figcaption></figure><figure style=\"margin-left:-20px;margin-right:-20px;text-align:center;margin-bottom:15px\"><img src=\"http://auduno.github.io/deepdraw/images/deepdraw_examples_0850.png\" alt=\"Teddybear\" style=\"width:300px;display:inline-block;padding-left:15px;padding-right:15px\"/><img src=\"http://auduno.github.io/deepdraw/images/deepdraw_example_0251.png\" alt=\"Dalmatians\" style=\"width:300px;display:inline-block;padding-left:15px;padding-right:15px\"/><figcaption>Generated images from class &ldquo;Teddybear&rdquo; (left), &ldquo;Dalmatian&rdquo; (right)</figcaption></figure><p>It should be mentioned that all of these images are generated completely from noise, so all information is from the deep neural network, see an example of the gradual generation process below:</p>\n\n<figure style=\"margin-bottom:15px\"><img src=\"http://auduno.github.io/deepdraw/images/anim_230_1437687161.GIF\" alt=\"gradual learning process\"/><figcaption>Generation of image example for class &ldquo;Shetland sheepdog&rdquo;</figcaption></figure><p>In this post I&rsquo;ll describe a bit more details on how I generated these images from GoogLeNet, but for those eager to try this out yourself, jump over to <a href=\"https://github.com/auduno/deepdraw\">github</a> where I&rsquo;ve published ipython notebooks to do this yourself. For more examples of generated images, see some highlights <a href=\"https://goo.gl/photos/8qcvjnYBQVSGG2eN6\">here</a>, or visualization of all 1000 imagenet classes <a href=\"https://goo.gl/photos/FfsZZektqpZkdDnKA\">here</a>.</p>\n\n<br/><p>Aside from the fact that our network seems to be drawing with rainbow crayons, it&rsquo;s remarkable to see how detailed the images are. They&rsquo;re far from perfect representations of the objects, but they give us valuable insight into what information the network thinks is essential for an object, and what isn&rsquo;t. For instance, the tabby cats seem to lack faces while the dalmatians are mostly dots. Presumably this doesn&rsquo;t mean that the network hasn&rsquo;t learned the rest of the details of these objects, but simply that the rest of the details are not very discriminate characteristics of that class, so they&rsquo;re ignored when generating the image.</p>\n\n<p>As google also noted in their post, there are often also details that actually aren’t part of the object. For instance, in this visualization of the &ldquo;Saxophone&rdquo; class there&rsquo;s a vague saxophone player holding the instrument:</p>\n\n<figure style=\"margin-bottom:15px\"><img src=\"http://auduno.github.io/deepdraw/images/sax_777.jpg\" alt=\"saxophone player\"/><figcaption>Visualization of class &ldquo;Saxophone&rdquo;</figcaption></figure><p>This is presumably because most of the example images used for training had a saxophone player in them, so the network sees them as relevant parts of the object.</p>\n\n<p>In the next part I&rsquo;ll go a bit into details on how the gradient ascent is done. Note : this is for specially interested, with some knowledge of deep neural networks being necessary.</p>\n\n<h4>Generating class visualizations with GoogLeNet</h4>\n\n<p>In order to make a deep neural network generate images, we use a simple trick. Instead of using backpropagation to optimize the weights, which we do during training, we keep the weights fixed and instead optimize the input pixels. However, trying to use unconstrained gradient ascent to get a feasible class visualization works poorly, giving us images such as the one below.</p>\n\n<figure style=\"margin-bottom:15px\"><img src=\"http://auduno.github.io/deepdraw/images/unblurred_opt_161.jpg\" alt=\"unconstrained optimization\"/><figcaption>Unconstrained gradient ascent on class &ldquo;Basset hound&rdquo;</figcaption></figure><p>The reason for this is that our unconstrained gradient ascent quickly runs into local maximums that are hard to get out of, with high frequency and low frequency information competing and creating noise. To get around this, we can choose to just optimize the low-frequency information first, which will give us the general structure of the image, and then gradually introduce high-frequency details as we continue gradient ascent, in effect &ldquo;washing out&rdquo; an image. Doing this in a slow way, we manage to ensure that optimization converges with a feasible image. There are two possible routes for doing this:</p>\n\n<ul><li>applying gaussian blur to the image after we&rsquo;ve applied the gradient step, starting with a large sigma and slowly decreasing it as we iterate</li>\n\t<li>applying gaussian blur to the gradient, starting with a large sigma and slowly decreasing it as we iterate (note that in this case we also have to use L2-regularization of the pixels to gradually decrease irrelevant noise from previous iterations)</li>\n</ul><p>I&rsquo;ve had best results with the former approach, which is the approach I used to generate the images above, but it might be that someone might get better results with blurring the gradient via messing about with the parameters some more.</p>\n\n<p>While this approach works okayish for relatively shallow networks like Alexnet, a problem you&rsquo;ll quickly run into when doing this with GoogLeNet, is that as you gradually reduce the amount of blurring applied, the image gets saturated with high-frequency noise like this:</p>\n\n<figure style=\"margin-bottom:15px\"><img src=\"http://auduno.github.io/deepdraw/images/loss3_161_3.jpg\" alt=\"unconstrained optimization\"/><figcaption>Gradient ascent on class &ldquo;Basset hound&rdquo; with gradually decreasing blurring</figcaption></figure><p>The reason for this problem is a bit uncertain, but might have to do with the depth of the network. In the <a href=\"http://arxiv.org/abs/1409.4842\">original paper</a> describing the GoogLeNet architecture, the authors mention that since the network is very deep, with 22 layers, they had to add two auxiliary classifiers at earlier points in the network to efficiently propagate gradients from the loss all the way back to the first layers. These classifiers, which were only used during training, ensured proper gradient flow and made sure that early layers were getting trained as well.</p>\n\n<p>In our case, the pixels of the image are even further ahead in the network than first layer, so it might not seem so surprising that we have some problems with gradients and recovering a feasible image. Exactly why this affects high-frequency information more than low-frequency information is a bit hard to understand, but it might have to do with gradients for high-frequency information being more sensitive and unstable, due to larger weights for high-frequency information, as mentioned by Yosinski in the appendix to <a href=\"http://arxiv.org/abs/1506.06579\">this paper</a>.</p>\n\n<p>While the auxiliary classifiers in GoogleNet are only used during training, there&rsquo;s nothing stopping us from using them for generating images. Doing gradient ascent on the first auxiliary classifier, we get this:</p>\n\n<figure style=\"margin-bottom:15px\"><img src=\"http://auduno.github.io/deepdraw/images/loss1_161_2.jpg\" alt=\"auxiliary classifier 1 optimization\"/><figcaption>Gradient ascent on class &ldquo;Basset hound&rdquo; with auxiliary classifier 1</figcaption></figure><p>while the second auxiliary classifier gives us this:</p>\n\n<figure style=\"margin-bottom:15px\"><img src=\"http://auduno.github.io/deepdraw/images/loss2_161_2.jpg\" alt=\"auxiliary classifier 2 optimization\"/><figcaption>Gradient ascent on class &ldquo;Basset hound&rdquo; with auxiliary classifier 2</figcaption></figure><p>As can be seen, the first classifier easily manages to generate an image without high-frequency noise , probably because it&rsquo;s &ldquo;closer&rdquo; to the early layers. However, it does not retain the overall structure of the object, and peppers the image with unnecessary details. The reason for the lack of structure is that the deeper a network is, the more structure the network is able to learn. Since the first classifier is so early in the network, it has not yet learned all of the structures deeper layers has. We can similarly see that the second classifier has learned some more structure, but has slightly more problems with high-frequency noise (though not as bad as the final classifier).</p>\n\n<p>So, is there any way to combine the gradients from these classifiers in order to ensure both structure and high-frequency information is retained? Doing gradient ascent on all three classifiers at the same time unfortunately does not help us much, as we get both poor structure and noisy high-frequency information. Instead, what we can do is to first do gradient ascent from the final classifier, as far as we can before we run into noise, then switch to doing gradient ascent from the second classifier for a while to &ldquo;fill in&rdquo; details, then finally switching to doing gradient ascent from the first classifier to get the final fine-grained details.</p>\n\n<p>Another trick we used, both to get larger images and better details, was to scale up the image at certain intervals, similar to the &ldquo;octaves&rdquo; used in the deepdream code. Since the input image the network optimizes is restricted to 224x224 pixels, we randomly crop a part of the scaled up image to optimize at each step. Altogether, this gives us this result:</p>\n\n<figure style=\"margin-bottom:15px\"><img src=\"http://auduno.github.io/deepdraw/images/anim_161_1437760444.GIF\" alt=\"optimization\"/><figcaption>Gradual generation of image from class &ldquo;Basset hound&rdquo; with scaling and switching between classifiers</figcaption></figure><p>Though this approach gives us nicely detailed images, note that both the scaling and the auxiliary classifiers tend to degrade the overall structure of the image, and particularly larger objects often tend to be &ldquo;torn apart&rdquo;, such as this dog gradually turning into multiple dogs.</p>\n\n<figure><img src=\"http://auduno.github.io/deepdraw/images/anim_161_1437685108.GIF\" alt=\"optimization\"/></figure><p>Since the network actually seems to be capable of creating more coherent objects, it&rsquo;s possible that we could generate better images with clever priors and proper learning rates, though I didn&rsquo;t have any luck with it so far. Purely hypothetically, deep networks with better gradient flow might also be able to recover more detailed and structured images. I&rsquo;ve been curious to see if networks with batch normalization or Parametric ReLUs are better at generating images since they seem to have better gradient flow, so if anyone has a pretrained caffe model with PReLUs or batch normalization, let me know!</p>\n\n<p>Another detail that’s worthy to note is that we did not optimize directly the loss layer, as the softmax denominator makes the gradient ascent put too much weight on reducing other class probabilities. Instead, we optimize the next to last layer, where we can make the gradient ascent focus exclusively on optimizing a likely image from our class.</p>\n\n<p>As a final side note it&rsquo;s very interesting to compare the images AlexNet and GoogLeNet generate. While the comparison might not be entirely representative, it certainly looks like Googlenet has learned a lot more details and structure than AlexNet.</p>\n\n<figure style=\"margin-left:-20px;margin-right:-20px;text-align:center;margin-bottom:15px\"><img src=\"http://auduno.github.io/deepdraw/images/alexnet_382.jpg\" alt=\"alexnet-monkeys\" style=\"width:300px;display:inline-block;padding-left:15px;padding-right:15px\"/><img src=\"http://auduno.github.io/deepdraw/images/deepdraw_example_382.jpg\" alt=\"googlenet-monkeys\" style=\"width:300px;display:inline-block;padding-left:15px;padding-right:15px\"/><figcaption>Generated images from class &ldquo;Squirrel monkey&rdquo; with AlexNet (left) and GoogLeNet (right).</figcaption></figure><p>Now go ahead and <a href=\"https://github.com/auduno/deepdraw\">try it yourself</a>! If you figure out other tricks or better choices of parameters for the gradient ascent (there almost certainly are), or just create some cool visualizations, let <a href=\"https://twitter.com/matsiyatzy\">me know via twitter</a>!</p>\n\n<p>A big hat tip to google and their original deepdream code, as well as <a href=\"https://twitter.com/kcimc\">Kyle McDonald</a>, which had the original idea of gradually reducing sigma of gaussian blurring to &ldquo;wash out&rdquo; the image, and kindly shared his code.</p>",
  "link": "https://auduno.tumblr.com/post/125362849838",
  "guid": "https://auduno.tumblr.com/post/125362849838",
  "pubDate": "Wed, 29 Jul 2015 20:59:42 +0200"
}