{
  "title": "Creyzies Contract Review",
  "link": "https://streamhacker.com/2022/04/23/creyzies-contract-review/#utm_source=feed&#038;utm_medium=feed&#038;utm_campaign=feed",
  "comments": "https://streamhacker.com/2022/04/23/creyzies-contract-review/#respond",
  "dc:creator": "Jacob",
  "pubDate": "Sun, 24 Apr 2022 06:38:27 +0000",
  "category": [
    "contracts",
    "airdrop",
    "azuki",
    "erc2981",
    "erc721",
    "erc721a",
    "eth",
    "ipfs",
    "json",
    "metadata",
    "mfers",
    "nft",
    "provenance",
    "royalties",
    "slither",
    "solidity",
    "token"
  ],
  "guid": "https://streamhacker.com/?p=2321",
  "description": "Contract review of Creyzies the official companion collection for mfers. Includes an overview of the airdrop mechanics and token metadata URI.",
  "content:encoded": "\n<p><a href=\"https://opensea.io/collection/creyzies\">Creyzies</a> is the official companion collect to <a href=\"https://opensea.io/collection/mfers\">mfers</a>, by <a href=\"https://twitter.com/reylarsdam\">Reylarsdam</a>. Every mfers holder received an equivalent amount of Creyzies in a <a href=\"https://twitter.com/sartoshi_nft/status/1516680193842294787\">surprise airdrop on 4/20/2022</a>, with all expenses paid by <a href=\"https://linktr.ee/sartoshi\">Sartoshi</a>, the creator of mfers.</p>\n\n\n\n<p>The contract was written by <a href=\"https://www.westcoastnft.com/\">West Coast NFT</a>, who also wrote the mfers contract. Let&#8217;s take a look at the <a href=\"https://etherscan.io/address/0x19bb64b80cbf61e61965b0e5c2560cc7364c6546#code\">code</a>, which begins with a giant ascii creyzie.</p>\n\n\n\n<figure class=\"wp-block-image size-large\"><a href=\"https://i0.wp.com/streamhacker.com/wp-content/uploads/2022/04/Screen-Shot-2022-04-23-at-10.34.51-PM.png?ssl=1\"><img decoding=\"async\" loading=\"lazy\" width=\"474\" height=\"506\" src=\"https://i0.wp.com/streamhacker.com/wp-content/uploads/2022/04/Screen-Shot-2022-04-23-at-10.34.51-PM.png?resize=474%2C506&#038;ssl=1\" alt=\"\" class=\"wp-image-2322\" srcset=\"https://i0.wp.com/streamhacker.com/wp-content/uploads/2022/04/Screen-Shot-2022-04-23-at-10.34.51-PM.png?resize=959%2C1024&ssl=1 959w, https://i0.wp.com/streamhacker.com/wp-content/uploads/2022/04/Screen-Shot-2022-04-23-at-10.34.51-PM.png?resize=281%2C300&ssl=1 281w, https://i0.wp.com/streamhacker.com/wp-content/uploads/2022/04/Screen-Shot-2022-04-23-at-10.34.51-PM.png?resize=768%2C820&ssl=1 768w, https://i0.wp.com/streamhacker.com/wp-content/uploads/2022/04/Screen-Shot-2022-04-23-at-10.34.51-PM.png?w=1202&ssl=1 1202w\" sizes=\"(max-width: 474px) 100vw, 474px\" data-recalc-dims=\"1\" /></a></figure>\n\n\n\n<h2>Airdrop</h2>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-solidity\">    struct SendData {\n        address receiver;\n        uint256 amount;\n    }\n\n ...\n\n    function airdrop(SendData[] calldata sendData) external onlyRole(SUPPORT_ROLE) nonReentrant {\n        uint256 ts = baseContractAddress.totalSupply();\n\n        // loop through all addresses\n        for (uint256 index = 0; index < sendData.length; index++) {\n            require(totalSupply() + sendData[index].amount <= ts, &#039;Exceeds original supply&#039;);\n            _safeMint(sendData[index].receiver, sendData[index].amount);\n        }\n    }</code></pre>\n\n\n\n<p>The <code>airdrop</code> function receives an array of <code>SendData</code> structs, each of which specifies a <code>receiver</code> address and an <code>amount</code> of tokens to airdrop. Before this function was called, the devs did a snapshot of all mfers owner addresses, and counted how many mfers were owned by each address, to create this <code>SendData</code> array. Then they called this function 14 times to perform the airdrop, for a total gas cost of ~15 ETH. Sartoshi <a href=\"https://etherscan.io/tx/0xcd90ca898d65ea601d11a00e599b041e9206134383a13974d1f57b93f31b3d3f\">deposited 20 ETH</a> to fund the airdrop, then <a href=\"https://etherscan.io/tx/0x26dff5930b5337c0c38139254f82ebef51f85db38ba983a9a9b86130537bedb4\">withdrew 5 ETH</a> when the airdrop was complete.</p>\n\n\n\n<p>The <code>baseContractAddress</code> is the <a href=\"https://etherscan.io/address/0x79fcdef22feed20eddacbb2587640e45491b757f\">mfers contract address</a>, which you can see in the <strong>Constructor Arguments</strong> below the <a href=\"https://etherscan.io/address/0x19bb64b80cbf61e61965b0e5c2560cc7364c6546#code\">code</a>. So the first line of the function gets the total number of mfers from the mfers contract. Then, looping through the array of <code>SendData</code>, there&#8217;s a requirement that the current supply + the amount to be minted is less than or equal to the total mfers supply. The amounts should have been calculated correctly during the snapshot, but this is a good way to enforce the supply limit. Finally, the <code>amount</code> of tokens is minted to the <code>receiver</code> address. The Creyzies contract uses <a href=\"https://www.erc721a.org/\">ERC721A</a>, so minting multiple tokens at a time is very efficient.</p>\n\n\n\n<p>There&#8217;s no token ownership checks at mint time, so this does all assume that the <code>SendData</code> was calculated correctly from a snapshot. Some addresses were explicitly left out of the airdrop &#8211; these were known smart contract addresses such as a <a href=\"https://gnosis-safe.io/\">Gnosis Safe</a> or <a href=\"https://niftygateway.com/\">NiftyGateway</a>. The devs knew the airdrop may not work for them, so they setup a claim site and implemented a redeem function.</p>\n\n\n\n<h2>Redeem</h2>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-solidity\">    function setUnclaimedTokenIds(uint256[] calldata tokenIds) external onlyRole(SUPPORT_ROLE) {\n        for (uint256 index = 0; index < tokenIds.length; index++) {\n            unclaimedTokenIds[tokenIds[index]] = true;\n        }\n    }\n\n    function redeem(uint256[] calldata tokenIds) external nonReentrant {\n        uint256 numberOfTokens = tokenIds.length;\n\n        for (uint256 index = 0; index < numberOfTokens; index++) {\n            require(unclaimedTokenIds[tokenIds[index]], &#039;Token has already been claimed&#039;);\n\n            try baseContractAddress.ownerOf(tokenIds[index]) returns (address ownerOfAddress) {\n                require(ownerOfAddress == msg.sender, &#039;Caller must own NFTs&#039;);\n            } catch (bytes memory) {\n                revert(&#039;Bad token contract&#039;);\n            }\n\n            unclaimedTokenIds[tokenIds[index]] = false;\n        }\n\n        uint256 ts = baseContractAddress.totalSupply();\n        require(totalSupply() + numberOfTokens <= ts, &#039;Exceeds original supply&#039;);\n\n        _safeMint(msg.sender, numberOfTokens);\n    }</code></pre>\n\n\n\n<p>Sartoshi posted <a href=\"https://twitter.com/sartoshi_nft/status/1517667081470283779\">claim instructions</a> to redeem unclaimed tokens that were not airdropped. <code>setUnclaimedTokenIds</code> was <a href=\"https://etherscan.io/tx/0x33a009d8db4dae3d1d1e01064f61b28a1952cde43a770f82c74647f6596ee1c6\">called immediately after the airdrop</a>, and sets a flag to true in <code>unclaimedTokenIds</code>. Then, when an owner goes to <a href=\"https://creyzies.art/\">creyzies.art</a> to claim their token(s), the <code>redeem</code> function is called. For each token attempting to be redeem, the function checks that</p>\n\n\n\n<ol><li>The token hasn&#8217;t been claimed already</li><li>The redeemer (<code>msg.sender</code>) owns the corresponding mfers token.</li></ol>\n\n\n\n<p>If those checks pass, the token is marked as claimed. But before it is minted, there is one final check that minting these tokens won&#8217;t exceed the total mfers supply. The devs definitely put some extra effort into the contract to double check their work, to ensure that Creyzies tokens went to the right addresses and never exceeded mfers supply.</p>\n\n\n\n<h2>Royalties</h2>\n\n\n\n<p>Often, royalties from sales are handled by secondary marketplaces, using info from <a href=\"https://royaltyregistry.xyz\">royaltyregistry.xyz</a>. However, this contract implements ERC2981, which defines a royalty standard specified in the contract. Like with mfers, the <a href=\"https://etherscan.io/tx/0xf8ecfa354700d48ba53a10945962f4c80b60219a67f4d5eb67e8209048ce7559\">default royalties are set</a> fairly low, to 2.5%. The royalties are sent to <a href=\"https://etherscan.io/address/0x750314177EF0a319DCdC959599C76D63964729f1\">0x750314177EF0a319DCdC959599C76D63964729f1</a>, which appears to be another contract that splits the royalties automatically.</p>\n\n\n\n<h2>Provenance</h2>\n\n\n\n<p>Like with The Picaroons, a provenance hash was <a href=\"https://etherscan.io/tx/0x983ee40a98e53a665edb84102107cabf01b4fdabcc0524ad847c54abd00fc421\">set before minting</a>, to <code>3307bc0bd06029bba4a826856f2e19db62d6df5b7f70d447fa5262117256c46c</code>. They also published a page <a href=\"https://west-curio-ff4.notion.site/Creyzies-10k-PFP-Provable-Fairness-42da9ba63f6e4db9bbb91d81c67f6b2d\">proving the fairness</a> of the drop.</p>\n\n\n\n<h2>Token URI</h2>\n\n\n\n<p>While some NFTs exist fully on chain, most are token numbers in a contract that point to a URI. This URI points to <a href=\"https://editorial.mintable.app/2021/08/09/nft-metadata-whats-all-this/\">metadata</a>, which is where to find the NFT image and properties. For mfers, the token URI is on <a href=\"https://ipfs.io/\">ipfs</a>, a distributed filesystem, where the <a href=\"https://medium.com/scrappy-squirrels/tutorial-nft-metadata-ipfs-and-pinata-9ab1948669a3\">JSON metadata</a> for each mfers token is stored. Creyzies, though, currently points to a web app on heroku.</p>\n\n\n\n<figure class=\"wp-block-image size-full\"><a href=\"https://i0.wp.com/streamhacker.com/wp-content/uploads/2022/04/Screen-Shot-2022-04-28-at-10.26.17-PM.png?ssl=1\"><img decoding=\"async\" loading=\"lazy\" width=\"474\" height=\"323\" src=\"https://i0.wp.com/streamhacker.com/wp-content/uploads/2022/04/Screen-Shot-2022-04-28-at-10.26.17-PM.png?resize=474%2C323&#038;ssl=1\" alt=\"\" class=\"wp-image-2329\" srcset=\"https://i0.wp.com/streamhacker.com/wp-content/uploads/2022/04/Screen-Shot-2022-04-28-at-10.26.17-PM.png?w=816&ssl=1 816w, https://i0.wp.com/streamhacker.com/wp-content/uploads/2022/04/Screen-Shot-2022-04-28-at-10.26.17-PM.png?resize=300%2C204&ssl=1 300w, https://i0.wp.com/streamhacker.com/wp-content/uploads/2022/04/Screen-Shot-2022-04-28-at-10.26.17-PM.png?resize=768%2C523&ssl=1 768w\" sizes=\"(max-width: 474px) 100vw, 474px\" data-recalc-dims=\"1\" /></a><figcaption>The token URI for Creyzies #1 is https://minting-pipeline-10.herokuapp.com/1</figcaption></figure>\n\n\n\n<p>This is not great, because it means that the Creyzies metadata depends on a Heroku app running correctly and being available. ipfs, being distributed, is a more decentralized and resilient location, and any files stored there can&#8217;t be changed without changing the URI. Metadata being served from a web app can be changed very easily. Hopefully there&#8217;s a plan to put all the metadata into ipfs as well; the images are there already. If that is done correctly, then the devs can call <code>setBaseURI</code> with the new ipfs URI, just like they did to <a href=\"https://etherscan.io/tx/0xeee920d6185c7e8b081653746eb563bd20a50d94c79576e641b795546266c76b\">set the heroku base URI</a>. However, if there is some other surprise planned that requires changing the metadata, then keeping the token URIs pointing to a web app make sense.</p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-solidity\">    function setBaseURI(string memory baseURI_) external onlyRole(SUPPORT_ROLE) {\n        _baseURIextended = baseURI_;\n    }\n\n    /**\n     * @dev See {ERC721-_baseURI}.\n     */\n    function _baseURI() internal view virtual override returns (string memory) {\n        return _baseURIextended;\n    }</code></pre>\n\n\n\n<h2>Slither Analysis</h2>\n\n\n\n<p>In order to make slither work this time, I had to <a href=\"https://github.com/crytic/crytic-compile/pull/261\">tweak the code</a> for one of the dependencies, <a href=\"https://github.com/crytic/crytic-compile\">crytic-compile</a>. Using my branch, you can run slither to analyze the contract.</p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-bash\">$ slither 0x19bb64b80cbf61e61965b0e5c2560cc7364c6546 --print human-summary</code></pre>\n\n\n\n<figure class=\"wp-block-image size-large\"><a href=\"https://i0.wp.com/streamhacker.com/wp-content/uploads/2022/04/Screen-Shot-2022-04-28-at-10.32.43-PM.png?ssl=1\"><img decoding=\"async\" loading=\"lazy\" width=\"474\" height=\"299\" src=\"https://i0.wp.com/streamhacker.com/wp-content/uploads/2022/04/Screen-Shot-2022-04-28-at-10.32.43-PM.png?resize=474%2C299&#038;ssl=1\" alt=\"\" class=\"wp-image-2332\" srcset=\"https://i0.wp.com/streamhacker.com/wp-content/uploads/2022/04/Screen-Shot-2022-04-28-at-10.32.43-PM.png?resize=1024%2C645&ssl=1 1024w, https://i0.wp.com/streamhacker.com/wp-content/uploads/2022/04/Screen-Shot-2022-04-28-at-10.32.43-PM.png?resize=300%2C189&ssl=1 300w, https://i0.wp.com/streamhacker.com/wp-content/uploads/2022/04/Screen-Shot-2022-04-28-at-10.32.43-PM.png?resize=768%2C484&ssl=1 768w, https://i0.wp.com/streamhacker.com/wp-content/uploads/2022/04/Screen-Shot-2022-04-28-at-10.32.43-PM.png?w=1422&ssl=1 1422w, https://i0.wp.com/streamhacker.com/wp-content/uploads/2022/04/Screen-Shot-2022-04-28-at-10.32.43-PM.png?w=948&ssl=1 948w\" sizes=\"(max-width: 474px) 100vw, 474px\" data-recalc-dims=\"1\" /></a></figure>\n\n\n\n<p>The issues can all be seen by running <code>slither 0x19bb64b80cbf61e61965b0e5c2560cc7364c6546</code>. I think the way this contract calls <code>baseContractAddress.ownerOf</code> within a try-catch block might be a little unusual, since slither says the return value is unused, when that&#8217;s not really the case. The other medium issues are within <code>ERC721A._mint</code>, and look ignorable. However there is an issue about <a href=\"https://github.com/crytic/slither/wiki/Detector-Documentation#costly-operations-inside-a-loop\">costly operations inside a loop</a> within <code>ERC721A._mint</code>, for <code>_currentIndex = updatedIndex</code>. This is within an <code>unchecked</code> block, which is the same thing that the <a href=\"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Counters.sol\">Counters</a> library does. The <a href=\"https://www.azuki.com/erc721a\">Azuki gas optimization analysis</a> was pretty extensive, so there may not be any more that can be done to optimize gas in this case.</p>\n\n\n\n<h2>Conclusion</h2>\n\n\n\n<p>This is a very nice & unexpected gift to all mfers holders, and it looks like the devs did excellent work to ensure accuracy and minimize airdrop costs. The Crezies art is <a href=\"https://creativecommons.org/share-your-work/public-domain/cc0/\">cc0</a> just like mfers, and it&#8217;s definitely worth checking out more of <a href=\"https://linktr.ee/reylarsdam\">Rey&#8217;s work</a>.</p>\n",
  "wfw:commentRss": "https://streamhacker.com/2022/04/23/creyzies-contract-review/feed/",
  "slash:comments": 0,
  "post-id": 2321
}