{
  "title": "Some nice ML-libraries",
  "description": "<h2> </h2>\n\n<img src=\"http://auduno.github.com/Kaggle-Acquire-Valued-Shoppers-Challenge/images/header1.png\" alt=\"image\"/><p>I recently had a go at the Kaggle <a href=\"http://www.kaggle.com/c/acquire-valued-shoppers-challenge\">Acquire Valued Shoppers Challenge</a>. This competition was a bit special in that the dataset was 22 GB, one of the biggest datasets they&rsquo;ve had in a competition. While 22 GB may not quite qualify as <em>big data</em>, it&rsquo;s certainly something that your average laptop will choke on when using standard methods. Ordinarily I&rsquo;d reach for <a href=\"http://scikit-learn.org/\">scikit-learn</a> for these tasks, but in this case some of the methods in scikit-learn were a bit slow, and some other libraries had nice methods that scikit-learn didn&rsquo;t have, so I decided to try out some other libraries. In this post I&rsquo;ll give a brief look at some of the alternative machine learning libraries that I used during the competition.</p>\n\n<!-- more -->\n<br/><p>In the Kaggle challenge, the intention was to predict whether a customer would become a &ldquo;repeat buyer&rdquo; of a product after trying the product. To give some examples of usage of the libraries I&rsquo;m going through, I&rsquo;ll use the features I created for the challenge, and predict probabilities of whether the customer was a &ldquo;repeat buyer&rdquo;. To follow the examples, you can download the features <a href=\"https://github.com/auduno/Kaggle-Acquire-Valued-Shoppers-Challenge\">here</a> and set up the training data for the examples like this:</p>\n\n<pre class=\"prettyprint lang-py\" style=\"overflow-x:scroll\">import pandas as pd\ntrain_data = pd.io.parsers.read_csv(\"./features/train/all_features.csv.gz\", sep=\" \", compression=\"gzip\")\ntrain_label = train_data['label']\ndel train_data['label']\ndel train_data['repeattrips']\ntest_data = pd.io.parsers.read_csv(\"./features/test/all_features.csv.gz\", sep=\" \", compression=\"gzip\")\ndel test_data['label']\ndel test_data['repeattrips']\n</pre>\n\n<h4>XGBoost</h4>\n\n<p><a href=\"https://github.com/tqchen/xgboost\">XGBoost</a> (short for &lsquo;extreme gradient boosting&rsquo;) is a library solely devoted to, you guessed it, <a href=\"http://en.wikipedia.org/wiki/Gradient_boosting\">gradient boosting</a>. Gradient boosting tends to be a frustrating affair, since it usually performs extremely well, but can also be very slow to train. Usually you would solve this by throwing several cores at the problem and use parallelization to speed it up, but neither scikit-learn or R&rsquo;s implementation is parallellizable, and so there doesn&rsquo;t seem to be much we can do. Fortunately there does exist alternative implementations that <em>do</em> support parallelization, and one of these is XGBoost.</p>\n\n<p>XGBoost has a python API, so it is very easy to integrate into a python workflow. An advantage XGBoost has compared to scikit-learn, is that while scikit-learn only has support for gradient boosting with decision trees as &ldquo;base learners&rdquo;, XGBoost also has support for linear models as base learners. In our cross-validation tests, this gave us a nice improvement in predictions.</p>\n\n<p>Another nice feature XGBoost has is that it will print out prediction error on a given test set for every 10 iterations over the training set, which allows you to monitor approximately when it starts to overfit. This can be used to tune how many rounds of training you want to do (in scikit-learn this is called <em>n_estimators</em>). On the other hand, XGBoost does not have support for feature-importances calculation, but they might implement this soon (see <a href=\"https://github.com/tqchen/xgboost/issues/11\">this issue</a>).</p>\n\n<p>In our example we first we create XGBoost train and test datasets, using the custom XGBoost DMatrix objects. We next set up our parameters: in the &ldquo;param&rdquo; dictionary, we set the <em>max_depth</em> of the decision trees, the <em>learning rate</em> of the boosting, here called <em>eta</em>, the objective of the learning (in our case logistic, since this is classification) and the number of threads we&rsquo;d like to use. Since we had four cores when running this example, we set this to four threads. The number of rounds to do is set directly when we call the train method. We train via calling <em>xgb.train()</em>, and we can then call <em>predict</em> on our returned train object to get our predictions. Simple!</p>\n\n<pre class=\"prettyprint lang-py\" style=\"overflow-x:scroll\"># import the xgboost library from wherever you built it\nimport sys\nsys.path.append('/home/audun/xgboost-master/python/')\nimport xgboost as xgb\n\ndtrain = xgb.DMatrix( train_data.values, label=train_label.values)\ndtest = xgb.DMatrix(test_data.values)\nparam = {'bst:max_depth':3, 'bst:eta':0.1, 'silent':1, 'objective':'binary:logistic', 'nthread':4, 'eval_metric':'auc'}\nnum_round = 100\nbst = xgb.train( param, dtrain, num_round )\npred_prob = bst.predict( dtest )\n</pre>\n\n<figure><img src=\"http://auduno.github.com/Kaggle-Acquire-Valued-Shoppers-Challenge/images/barchart1.jpg\" alt=\"Timing\"/><figcaption>Comparison of training time (seconds) of Scikit-learn&rsquo;s GradientBoostingClassifier versus XGBoost</figcaption></figure><p>In our tests with four cores, it ran around four times as fast as scikit-learn&rsquo;s GradientBoostingClassifier, which probably reflects the parallellization. With more cores, this would probably allow us to speed up the training even more. For some more detailed tutorials on how to use XGBoost, take a look at the <a href=\"https://github.com/tqchen/xgboost/wiki\">documentation here</a>.</p>\n\n<br/><p>A common problem with large data sets, is that usually you need to have the training data in memory to train on it. When the data set is big, this is obviously not going to work. A solution to this is so-called out-of-core algorithms, which commonly means only looking at one example from the training set at a time, in other words keeping the training data &ldquo;out of core&rdquo;. Scikit-learn has support for out-of-core/online learning via <a href=\"http://scikit-learn.org/stable/modules/generated/sklearn.linear_model.SGDClassifier.html\">SGDClassifier</a>, but in addition there also exists some other libraries that are pretty speedy:</p>\n\n<h4>Sofia-ml</h4>\n\n<p><a href=\"https://code.google.com/p/sofia-ml/\">Sofia-ml</a> currently supports SVM, logistic regression or perceptron methods and uses some speedy fitting algorithms known as &ldquo;Pegasos&rdquo; (short for &ldquo;primal estimatimated sub-gradient solver for SVM&rdquo;). &ldquo;Pegasos&rdquo; has an advantage in that you do not need to define pesky parameters such as learning rate (see <a href=\"http://lingpipe-blog.com/2009/04/08/convergence-relative-sgd-pegasos-liblinear-svmlight-svmper/\">this article</a>). Another nice feature in sofia-ml is that it supposedly also can optimize ROC area via selecting smart choices of samples when iterating over the dataset. &ldquo;ROC area&rdquo; is also known as AUC, which happened to be the score measure in our competition (and numerous other Kaggle competitions).</p>\n\n<p>Using sofia-ml is pretty straightforward, but since it is a command-line tool, it easily seems a bit esoteric for those used to scikit-learn. Before we call the training, we have to write out the data to an input format called &ldquo;SVMlight sparse data format&rdquo; which originally comes from the library <a href=\"http://svmlight.joachims.org\">SMVlight</a>, but has since been adopted by a number of other machine learning libraries. In our tests, what took the longest time was actually writing out the data, so we found it very helpful to use Mathieu Blondel&rsquo;s library <a href=\"https://github.com/mblondel/svmlight-loader\">svmlight-loader</a>, which does the writing out in C++. Note that there are also <a href=\"http://scikit-learn.org/stable/modules/generated/sklearn.datasets.dump_svmlight_file.html\">tools for handling SVMlight formats</a> in scikit-learn, but they&rsquo;re not quite as fast as this one.</p>\n\n<p>There is no python wrapper for sofia-ml, but it&rsquo;s quite easy to do everything from python:</p>\n\n<pre class=\"prettyprint lang-py\" style=\"overflow-x:scroll\">from svmlight_loader import dump_svmlight_file\nfrom subprocess import call\nimport numpy as np\nfrom sklearn.preprocessing import StandardScaler\n\n# normalize data\nss = StandardScaler()\ntrain_data_norm = ss.fit_transform(train_data)\ntest_data_norm = ss.transform(test_data)\n\n# change these filenames to reflect your system!\nmodel_file = \"/home/audun/data/sofml.model\"\ntraining_file = \"/home/audun/data/train_data.dat\"\ntest_file = \"/home/audun/data/test_data.dat\"\npred_file = \"/home/audun/data/pred.csv\"\n\n# note that for sofia-ml (and vowpal wabbit), labels need to be {-1,1}, not {0,1}, so we change them\ntrain_label.values[np.where(train_label == 0)] = -1\n\n# export data\ndump_svmlight_file(train_data_norm, train_label, training_file, zero_based=False)\ndump_svmlight_file(test_data_norm, np.zeros((test_data.shape[0],)), test_file, zero_based=False)\n</pre>\n\n<p>We call the training and prediction with a python subprocess. In our first line, we specify via command-line parameters that the learner type is SVM fitted with stochastic gradient descent, use loop type ROC (to optimize for AUC), set prediction type &ldquo;logistic&rdquo; in order to get classifications, and do 200000 gradient descent updates. Many more possible command-line parameters are listed <a href=\"https://code.google.com/p/sofia-ml/\">here</a>. In the second line we create predictions on our test data from our model file, and we then read it in again via <em>pandas</em>. Note that in the case of logistic predictions, sofia-ml returns untransformed predictions, so we need to transform the predictions via the logistic transformation to get probabilities.</p>\n\n<pre class=\"prettyprint lang-py\" style=\"overflow-x:scroll\"># train via subprocess call\ncall(\"~/sofia-ml/sofia-ml --learner_type sgd-svm --loop_type roc --prediction_type logistic --iterations 200000 --training_file \"+training_file+\" --model_out \"+model_file, shell = True)\n\n# create test data via subprocess call\ncall(\"~/sofia-ml/sofia-ml --model_in \"+model_file+\" --test_file \"+test_file+\" --results_file \"+pred_file, shell = True)\n\n# read in test data\npred_prob = pd.io.parsers.read_csv(pred_file, sep=\"\\t\", names=[\"pred\",\"true\"])['pred']\n# do logistic transformation to get probabilities\npred_prob = 1./(1.+np.exp(-pred_prob))\n</pre>\n\n<p>In our tests, fitting using Sofia-ml was extremely speedy, around 3 seconds!</p>\n\n<h4>Vowpal Wabbit</h4>\n\n<p>This is probably the most well-known library to do fast out-of-core learning, and operates pretty similarly to sofia-ml. Vowpal Wabbit has support for doing SVM, logistic regression, linear regression and quantile regression via optimizing for respectively hinge loss, logit loss, squared loss and quantile loss. Since Vowpal Wabbit is written in C++, carefully optimized and has some tricks up it&rsquo;s sleeve, it&rsquo;s very fast and performs very competitively on a lot of tasks.</p>\n\n<p>Vowpal Wabbit, like sofia-ml, is a command line program, and uses a <a href=\"https://github.com/JohnLangford/vowpal_wabbit/wiki/Input-format\">slight modification</a> of the SVMlight sparse data format for input. Since the differences between SVMlight and Vowpal Wabbits format were pretty small, we used the svmlight-loader library here as well, and modified the files to suit Vowpal Wabbit afterwards.</p>\n\n<p>At the time of the competition, I didn&rsquo;t find any python wrappers, but it seems there is now a python wrapper <a href=\"https://github.com/JohnLangford/vowpal_wabbit/blob/master/python/pyvw.py\">under development here</a>. It&rsquo;s not documented yet, so I&rsquo;ll just use regular python methods to call Vowpal Wabbit in this example. First we have to write out training and test data:</p>\n\n<pre class=\"prettyprint lang-py\" style=\"overflow-x:scroll\">training_file = \"/home/audun/data/vw_trainset.csv\"\ntraining2_file = \"/home/audun/data/vw_trainset2.csv\"\ntest_file = \"/home/audun/data/vw_testset.csv\"\ntest2_file = \"/home/audun/data/vw_testset2.csv\"\npred_file = \"/home/audun/data/pred.csv\"\nmodel_file = \"/home/audun/data/vw_trainset_model.vw\"\n\ndump_svmlight_file(train_data, train_label, training_file, zero_based=False)\ndump_svmlight_file(test_data, np.zeros((test_data.shape[0],)), test_file, zero_based=False)\n\n# add specifics for vowpal wabbit format\nimport string\nfi = open(training_file,\"r\")\nof = open(training2_file,\"w\")\nfor lines in fi:\n\tli = lines.strip().split()\n\tof.write( li[0] )\n\tof.write(\" | \")\n\tof.write( string.join(li[1:],\" \") + \"\\n\")\nof.close()\nfi.close()\nfi = open(test_file,\"r\")\nof = open(test2_file,\"w\")\nfor lines in fi:\n\tli = lines.strip().split()\n\tof.write( li[0] )\n\tof.write(\" | \")\n\tof.write( string.join(li[1:],\" \") + \"\\n\")\nof.close()\nfi.close()\n</pre>\n\n<p>We then do a subprocess call to run Vowpal Wabbit from the command line. There are a lot of possible parameters to the command line, but all of them are listed <a href=\"https://github.com/JohnLangford/vowpal_wabbit/wiki/Command-line-arguments\">here</a>. The first line trains a model with logistic loss (i.e. for classification) on our training set, doing 40 passes over the data. The second line predicts data from our testset, based on our trained model, and writes the predictions out to a file.</p>\n\n<pre class=\"prettyprint lang-py\" style=\"overflow-x:scroll\"># train\ncall(\"~/vowpalwabbit/vw \"+training2_file+\" -c -k --passes 40 -f \"+model_file+\" --loss_function logistic\", shell=True)\n\n# predict\ncall(\"~/vowpalwabbit/vw \"+test2_file+\" -t -i \"+model_file+\" -r \"+pred_file, shell=True)\n</pre>\n\n<p>Next, we load the predictions from the output file. Note that like with sofia-ml the predictions need to be logistic transformed to get probabilities.</p>\n\n<pre class=\"prettyprint lang-py\" style=\"overflow-x:scroll\">pred_prob = pd.io.parsers.read_csv(pred_file, names=[\"pred\"])['pred']\npred_prob = 1./(1.+np.exp(-pred_prob))\n</pre>\n\n<p>Training is very fast, around 9 secs, even though the dataset is sizable. For a more in-depth tutorial on how to use Vowpal Wabbit take a look at <a href=\"https://github.com/JohnLangford/vowpal_wabbit/wiki/Tutorial\">the tutorial</a> in their github repo.</p>\n\n<br/><p>So there you go, some nice, not-so-well-known machine learning libraries! In the competition overall, with the help of these libraries, I managed to end up in the top 10%, and together with my 4th place in the earlier loan default prediction competition, this earned me a &ldquo;kaggle master&rdquo; badge.</p>\n\n<figure><img src=\"http://auduno.github.com/Kaggle-Acquire-Valued-Shoppers-Challenge/images/badge_crop.jpg\" alt=\"Kaggle master badge\"/><figcaption>Kaggle master badge.</figcaption></figure><p>If you know of any other unknown but great libraries, let me know. And If you liked this blogpost, you should <a href=\"https://twitter.com/matsiyatzy\">follow me on twitter!</a></p>\n\n<script>\n\t$(document).ready( function(){\n\t    prettyPrint();\n\t});\n</script>",
  "link": "https://auduno.tumblr.com/post/96084011658",
  "guid": "https://auduno.tumblr.com/post/96084011658",
  "pubDate": "Fri, 29 Aug 2014 15:21:00 +0200"
}