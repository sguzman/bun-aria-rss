{
  "title": "Bot or Not: an end-to-end data analysis in Python",
  "link": "http://www.erinshellman.com/bot-or-not/",
  "comments": "http://www.erinshellman.com/bot-or-not/#comments",
  "dc:creator": "erinshellman",
  "pubDate": "Tue, 18 Aug 2015 04:20:24 +0000",
  "category": [
    "data science",
    "programming",
    "pandas",
    "python",
    "twitter"
  ],
  "guid": "http://www.erinshellman.com/?p=327",
  "description": " <a class=\"read-more\" href=\"http://www.erinshellman.com/bot-or-not/\"></a>",
  "content:encoded": "<section class=\"stag-section stag-intro-text\"><p>For those who didn&#8217;t make it to my PyData talk&#8230; how dare you? Aww, I can&#8217;t stay mad at you. Here&#8217;s the written version of my talk about building a classifier with <em>pandas, NLTK,</em> and <em>scikit-learn</em> to identify Twitter bots. You can also watch it <a href=\"https://youtu.be/ic4SagX5RFM\" target=\"_blank\">here</a>.</p>\n</section>\n<p><span class=\"stag-dropcap stag-dropcap--normal\" style=\"font-size:50px;line-height:50px;width:50px;height:50px;\">I</span>n this post I want to discuss an Internets phenomena knows as bots, specifically Twitter bots. I&#8217;m focusing on Twitter bots primarily because they&#8217;re fun and funny, but also because Twitter happens to provide a rich and comprehensive API that allows users to access information about the platform and how it&#8217;s used. In short, it makes for a compelling demonstration of Python&#8217;s prowess for data analysis work, and also areas of relative weakness.</p>\n<p>For those unfamiliar with Twitter (who are you monsters?), it&#8217;s a social media platform on which users can post 140 character fart jokes called &#8220;tweets&#8221; (that joke bombed at PyData btw, but I can&#8217;t let it go). Twitter is distinct from other social media in that by default tweets are public and there&#8217;s no expectation that followers actually know one another. You can think of Twitter less as a stream of personal news, and more as a marketplace of ideas where the currency is favs and retweets.</p>\n<blockquote class=\"twitter-tweet\" width=\"550\">\n<p lang=\"en\" dir=\"ltr\">After my death I'd like my remains to be vaped by everyone in my dance crew except for Li'l Sherbet. He knows why</p>\n<p>&mdash; Andy Richter (@AndyRichter) <a href=\"https://twitter.com/AndyRichter/status/627165392616591360\">July 31, 2015</a></p></blockquote>\n<p><script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script></p>\n<p>Another distinguishing feature of Twitter is the &#8220;embed-ability&#8221; of its content (hilarious example above). It&#8217;s commonplace nowadays to see tweets included as part of news media. This is due in no small part to the openness of their APIs, which allow developers to programmatically tweet and view timelines. But the same openness that makes twitter pervasive across the internet, also opens the door for unwelcome users, like bots.</p>\n<p>Twitter bots are programs that compose and post tweets without human intervention, and they range widely in complexity. Some are relatively inert, living mostly to follow people and fav things, while others use sophisticated algorithms to create, at times, very convincing speech. All bots can be a nuisance because their participation in the Twittersphere undermines the credibility of Twitter&#8217;s analytics and marketing attribution, and ultimately their bottom line.</p>\n<p>So what can Twitter do about them? Well, the first step is to identify them. Here&#8217;s how I did it.</p>\n<h4>Creating labels</h4>\n<p>The objective is to build a classifier to identify accounts likely belonging to bots, and I took a supervised learning approach. &#8220;Supervised&#8221; means we need labeled data, <em>i.e. </em>we need to know at the outset which accounts belong to bots and which belong to humans. In past work this thankless task had been accomplished through the use (and abuse) of grad students. For example<i>, </i><a href=\"http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=6280553\" target=\"_blank\">Jajodia </a><em><a href=\"http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=6280553\" target=\"_blank\">et al</a> </em>manually inspected accounts and applied a Twitter version of the Turing test&#8211;if it looks like a bot, and tweets like a bot, then it&#8217;s a bot. The trouble is, I&#8217;m not a grad student anymore and my time has value (<em>that</em> joke killed). I solved this problem thanks to a hot tip from friend and co-worker <a href=\"http://vallandingham.me/vis/\" target=\"_blank\">Jim Vallandingham</a>, who introduced me to <a href=\"https://www.fiverr.com/\" target=\"_blank\">fiverr</a>, a website offering dubious services for $5.</p>\n<figure class=\"stag-section stag-image stag-image--no-filter stag-image--center\"><img src=\"http://www.erinshellman.com/blog/wp-content/uploads/2015/08/fiverr_small.png\" alt=\"\"></figure>\n<p>Five dollars and 24 hours later, I had 5,500 new followers. Since I knew who followed me prior to the bot swarm, I could positively identify them as humans and all my overnight followers as bots.</p>\n<h4>Creating features</h4>\n<p>Due to the richness of the Twitter REST API, creating the feature set required significantly less terms-of-service-violating behavior. I used the <a href=\"https://github.com/bear/python-twitter\" target=\"_blank\">python-twitter</a> module to query two endpoints: <a href=\"https://dev.twitter.com/rest/reference/get/users/lookup\" target=\"_blank\">GET users/lookup</a> and <a href=\"https://dev.twitter.com/rest/reference/get/statuses/user_timeline\" target=\"_blank\">GET statuses/user_timeline</a>. The users/lookup endpoint returns a JSON blob containing information you could expect to find on a user&#8217;s profile page, <em>e.g.</em> indicators of whether they&#8217;re using default profile settings, follower/following counts, and tweet count. From GET/user_time I grabbed the last 200 tweets of everyone in my dataset.</p>\n<p>The trouble is, Twitter isn&#8217;t going to let you just roll in and request all the data you want. They enforce rate limits on the API, which means you&#8217;re going to have to take a little cat nap in between requests. I accomplished this in part with the charming method, <em>blow_chunks</em>:</p>\n<pre id=\"code_snippet_24\" style=\"position:relative;width:100%;border:0;padding:0;\"># don’t exceed API limits\ndef blow_chunks(self, data, max_chunk_size):\n  for i in range(0, len(data), max_chunk_size):\n    yield data[i:i + max_chunk_size]</pre>\n<p><em>blow_chunks</em> takes as input a list of your queries, for example user ids, and breaks it into chunks of a maximum size. But it doesn&#8217;t return those chunks, it returns a generator, which can be used thusly:</p>\n<pre id=\"code_snippet_26\" style=\"position:relative;width:100%;border:0;padding:0;\">if len(user_ids) > max_query_size:\n  chunks = self.blow_chunks(user_ids, max_chunk_size = max_query_size)\n  while True:\n    try:\n      current_chunk = chunks.next()\n      for user in current_chunk:\n        try:\n          user_data = self.api.GetUser(user_id = str(user))\n          results.append(user_data.AsDict())\n        except:\n          print \"got a twitter error! D:\"\n          pass\n      print \"nap time. ZzZzZzzzzz...\"\n      time.sleep(60 * 16)\n      continue\n    except StopIteration:\n      break</pre>\n<p>If the query size is bigger than the maximum allowed, then break it into chunks. Call the <em>.next()</em> method of generators to grab the first chunk and send that request to the API. Then grab a beer because, there&#8217;s 16 minutes until the next request is sent. When there aren&#8217;t anymore chunks left, the generator will throw a StopIteration and break out of the loop.</p>\n<h5>These bots are weird</h5>\n<p>Fast-forward to clean, well-formatted data and it doesn&#8217;t take long to find fishiness. On average, bots follow 1400 people whereas humans follow 500. Bots are similarly strange in their distribution of followers. Humans have a fairly uniform distribution of followers. Some people are popular, some not so much, and many in between. Conversely, these bots are extremely unpopular with an average of a measly 28 followers.</p>\n<p><img loading=\"lazy\" class=\"alignnone wp-image-388 size-full\" src=\"http://www.erinshellman.com/blog/wp-content/uploads/2015/08/friends.png\" alt=\"friends\" width=\"915\" height=\"439\" srcset=\"http://www.erinshellman.com/blog/wp-content/uploads/2015/08/friends.png 915w, http://www.erinshellman.com/blog/wp-content/uploads/2015/08/friends-300x144.png 300w\" sizes=\"(max-width: 915px) 100vw, 915px\" /><img loading=\"lazy\" class=\"aligncenter wp-image-389 size-full\" src=\"http://www.erinshellman.com/blog/wp-content/uploads/2015/08/followers.png\" alt=\"followers\" width=\"915\" height=\"438\" srcset=\"http://www.erinshellman.com/blog/wp-content/uploads/2015/08/followers.png 915w, http://www.erinshellman.com/blog/wp-content/uploads/2015/08/followers-300x144.png 300w\" sizes=\"(max-width: 915px) 100vw, 915px\" /></p>\n<h5>Tweets into data</h5>\n<p>Sure, these bots look weird at the profile level, but lots of humans are unpopular and have the Twitter egg for a profile picture. How about what they&#8217;re saying? To incorporate the tweet data in the classifier, it needed to be summarized into one row per account. One such summary metric is lexical diversity, which is the ratio of unique tokens to total tokens in a document. Lexical diversity ranges from 0 to 1 where 0 indicates no words in a document, and 1 indicates that each word was used exactly once. You can think of it as a measure of lexical sophistication.</p>\n<p>I used <a href=\"http://pandas.pydata.org/\" target=\"_blank\">Pandas</a> to quickly and elegantly apply summary functions like lexical diversity to the tweets. First I combined all the tweets per user into one document and tokenized it, so I was left with a list of words. Then I removed punctuation and stopwords with <a href=\"http://www.nltk.org/\" target=\"_blank\">NLTK</a>.</p>\n<p>Pandas makes it super simple to apply custom functions over groups of data. With <em>groupby </em>I grouped the tweets by screen name and then applied the lexical diversity function to my groups of tweets. I love the simplicity and flexibility of this syntax, which makes it a breeze to group over any category and apply custom summary functions. For example, I could group by location or predicted gender, and compute the lexical diversity of all those slices just by modifying the grouping variable.</p>\n<pre id=\"code_snippet_25\" style=\"position:relative;width:100%;border:0;padding:0;\">def lexical_diversity(text):\n  if len(text) == 0:\n    diversity = 0\n  else: \n   diversity = float(len(set(text))) / len(text)\n  return diversity\n  \n# Easily compute summaries for each user!\ngrouped = tweets.groupby('screen_name')\ndiversity = grouped.apply(lexical_diversity)</pre>\n<p>Again these bots look strange. Humans have a beautiful, almost textbook normal distribution of diversities centered at 0.70. Bots on the other hand have more mass at the extremes, especially towards one. A lexical diversity of one means that every word in the document is unique, implying that bots are either not tweeting much, or are tweeting random strings of text.</p>\n<p><img loading=\"lazy\" class=\"aligncenter wp-image-390 size-full\" src=\"http://www.erinshellman.com/blog/wp-content/uploads/2015/08/diversity.png\" alt=\"diversity\" width=\"884\" height=\"439\" srcset=\"http://www.erinshellman.com/blog/wp-content/uploads/2015/08/diversity.png 884w, http://www.erinshellman.com/blog/wp-content/uploads/2015/08/diversity-300x149.png 300w\" sizes=\"(max-width: 884px) 100vw, 884px\" /></p>\n<h5>Model Development</h5>\n<p>I used <em><a href=\"http://scikit-learn.org/stable/\" target=\"_blank\">scikit-learn</a></em>, the premier machine learning module in Python, for model development and validation. My analysis plan went something like this: since I&#8217;m primarily interested in predictive accuracy, why not just try a couple classification methods and see which one performs the best. One of the strengths of <em>scikit-learn</em> is a clean and consistent API for constructing models and pipelines that makes trying out a couple models simple.</p>\n<pre id=\"code_snippet_27\" style=\"position:relative;width:100%;border:0;padding:0;\"># Naive Bayes\nbayes = GaussianNB().fit(train[features], y)\nbayes_predict = bayes.predict(test[features])\n\n# Logistic regression\nlogistic = LogisticRegression().fit(train[features], y)\nlogistic_predict = logistic.predict(test[features])\n\n# Random Forest\nrf = RandomForestClassifier().fit(train[features], y)\nrf_predict = rf.predict(test[features])</pre>\n<p>I fit three classifiers, a naive Bayes, logistic regression and random forest classifier. You can see that the syntax for each classification method is identical. In the first line I&#8217;m fitting the classifier, providing the features from the training set and the labels, <em>y</em>. Then it&#8217;s simple to generate predictions from the model fit by passing in the features from the test set and view accuracy measures from the classification report.</p>\n<pre id=\"code_snippet_28\" style=\"position:relative;width:100%;border:0;padding:0;\"># Classification Metrics\nprint(metrics.classification_report(test.bot, bayes_predict))\nprint(metrics.classification_report(test.bot, logistic_predict))\nprint(metrics.classification_report(test.bot, rf_predict))</pre>\n<p>Not surprisingly random forest performed the best with an overall precision of 0.90 versus 0.84 for Naive Bayes and 0.87 for logistic regression. Amazingly with an out-of-the-box classifier, we are able to correctly identify bots 90% of the time, but can we do better? Yes, yes we can. It&#8217;s actually really easy to tune classifiers using <em>GridSearchCV</em>. <em>GridSearchCV</em> takes a classification method and a grid of parameter settings to explore. The &#8220;grid&#8221; is just a dictionary keyed off of the model&#8217;s configurable parameters. What&#8217;s rad about <em>GridSearchCV</em> is that you can treat it just like the classification methods we saw previously. That is, we can use .fit() and .predict().</p>\n<pre id=\"code_snippet_29\" style=\"position:relative;width:100%;border:0;padding:0;\"># construct parameter grid\nparam_grid = {'max_depth': [1, 3, 6, 9, 12, 15, None],\n              'max_features': [1, 3, 6, 9, 12],\n              'min_samples_split': [1, 3, 6, 9, 12, 15],\n              'min_samples_leaf': [1, 3, 6, 9, 12, 15],\n              'bootstrap': [True, False],\n              'criterion': ['gini', 'entropy']}\n\n# fit best classifier\ngrid_search = GridSearchCV(RandomForestClassifier(), param_grid = param_grid).fit(train[features], y)\n\n# assess predictive accuracy\npredict = grid_search.predict(test[features])\nprint(metrics.classification_report(test.bot, predict))</pre>\n<p>Aha, better precision! The simple tuning step resulted in a configuration that yielded a 2% increase in precision. Inspecting the variable importance plot for the tuned random forest yields few surprises. The number of friends and followers are the most important variables for predicting bot-status.</p>\n<p><img loading=\"lazy\" class=\"aligncenter wp-image-387 size-full\" src=\"http://www.erinshellman.com/blog/wp-content/uploads/2015/08/variable_importance.png\" alt=\"variable_importance\" width=\"509\" height=\"268\" srcset=\"http://www.erinshellman.com/blog/wp-content/uploads/2015/08/variable_importance.png 509w, http://www.erinshellman.com/blog/wp-content/uploads/2015/08/variable_importance-300x158.png 300w\" sizes=\"(max-width: 509px) 100vw, 509px\" /></p>\n<h5>Still, we need better tools for iterative model development</h5>\n<p>There&#8217;s still a lot of room for growth in <em>scikit-learn</em>, particularly in functions for generating model diagnostics and utilities for model comparison. As an illustrative example of what I mean, I want to take you away to another world where the language isn&#8217;t Python, it&#8217;s R. And there&#8217;s no <em>scikit-learn</em>, there&#8217;s only <a href=\"http://topepo.github.io/caret/\" target=\"_blank\">caret</a>. Let me show you some of the strengths of <em>caret </em>that could be replicated in <em>scikit-learn</em>.</p>\n<p>Below is the output from the <em>confusionMatrix</em> function, the conceptual equivalent of <em>scikit-learn</em>&#8216;s <em>classification_report</em>. What you&#8217;ll notice about the output of <em>confusionMatrix</em> is the depth of accuracy reporting. There&#8217;s the confusion matrix and lots of accuracy measures that use the confusion matrix as input. Most of the time you&#8217;ll probably only use one or two of the measures, but it&#8217;s nice to have them all available so that you can use what works best in your situation without having to write extra code.</p>\n<pre id=\"code_snippet_31\" style=\"position:relative;width:100%;border:0;padding:0;\">> confusionMatrix(logistic_predictions, test$bot)\nConfusion Matrix and Statistics\n\n          Reference\nPrediction   0   1\n         0 394  22\n         1 144  70\n                                          \n               Accuracy : 0.7365          \n                 95% CI : (0.7003, 0.7705)\n    No Information Rate : 0.854           \n    P-Value [Acc > NIR] : 1               \n                                          \n                  Kappa : 0.3183          \n Mcnemars Test P-Value : <2e-16          \n                                          \n            Sensitivity : 0.7323          \n            Specificity : 0.7609          \n         Pos Pred Value : 0.9471          \n         Neg Pred Value : 0.3271          \n             Prevalence : 0.8540          \n         Detection Rate : 0.6254          \n   Detection Prevalence : 0.6603          \n      Balanced Accuracy : 0.7466          \n                                          \n       'Positive' Class : 0 </pre>\n<p>One of the biggest strengths of <em>caret</em> is the ability to extract inferential model diagnostics, something that&#8217;s virtually impossible to do with <em>scikit-learn</em>. When fitting a regression method for example, you&#8217;ll naturally want to view coefficients, test statistics, p-values and goodness-of-fit metrics. Even if you&#8217;re only interested in predictive accuracy, there&#8217;s value to understanding what the model is actually saying and knowing whether the assumptions of the method are met. To replicate this type of output in Python would require refitting the model in something like <em>statsmodels, </em>which makes the model development process wasteful and tedious.</p>\n<pre id=\"code_snippet_32\" style=\"position:relative;width:100%;border:0;padding:0;\">summary(logistic_model)\n\nCall:\nNULL\n\nDeviance Residuals: \n    Min       1Q   Median       3Q      Max  \n-1.2620  -0.6323  -0.4834  -0.0610   6.0228  \n\nCoefficients:\n                Estimate Std. Error z value Pr(>|z|)    \n(Intercept)      -5.7136     0.7293  -7.835 4.71e-15 ***\nstatuses_count   -2.4120     0.5026  -4.799 1.59e-06 ***\nfriends_count    30.8238     3.2536   9.474  < 2e-16 ***\nfollowers_count -69.4496    10.7190  -6.479 9.22e-11 ***\n---\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 2172.3  on 2521  degrees of freedom\nResidual deviance: 1858.3  on 2518  degrees of freedom\nAIC: 1866.3\n\nNumber of Fisher Scoring iterations: 13</pre>\n<p>But I think the best feature of R&#8217;s <em>caret</em> package is the ease with which you can compare models. Using the <em>resamples</em> function I can quickly generate visualizations to compare model performance on metrics of my choosing. These type of utility functions are super useful during model development, but also in communication of early results where you don&#8217;t want to spend a ton of time making finalized figures.</p>\n<pre id=\"code_snippet_33\" style=\"position:relative;width:100%;border:0;padding:0;\"># compare models\nresults = resamples(list(tree_model = tree_model, \n                         bagged_model = bagged_model,\n                         boost_model = boost_model))\n# plot results\ndotplot(results)</pre>\n<figure class=\"stag-section stag-image stag-image--no-filter stag-image--center\"><img src=\"http://www.erinshellman.com/blog/wp-content/uploads/2015/08/dotplot.png\" alt=\"\"></figure>\n<p>For me, these features make all the difference and are a huge part of why R is still my preferred language for model development.</p>\n<h3>Conclusion</h3>\n<p>If you learned anything from this read, I hope it&#8217;s that Python is an extremely powerful tool for data tasks. We were able to retrieve data through an API, clean and process the data, develop, and test a classifier all with Python. We&#8217;ve also seen that there&#8217;s room for improvement. Utilities for fast, iterative model development are rich in R&#8217;s <em>caret </em>package, and <em>caret</em> serves as a great model for future development in <em>scikit-learn</em>.</p>\n",
  "wfw:commentRss": "http://www.erinshellman.com/bot-or-not/feed/",
  "slash:comments": 3
}