{
  "id": "tag:blogger.com,1999:blog-6894866515532737257.post-8689953612197441213",
  "published": "2018-02-23T05:27:00.002-08:00",
  "updated": "2018-02-23T05:27:36.725-08:00",
  "title": "The six stages of computational science",
  "content": "This is the second in a series of articles related to computational science and education.&nbsp; <a href=\"http://allendowney.blogspot.com/2018/02/learning-to-program-is-getting-harder.html\">The first article is here.</a><br /><br /><h3>The Six Stages of Computational Science</h3>When I was in grad school, I collaborated with a research group working on computational fluid dynamics.&nbsp; They had accumulated a large, complex code base, and it was starting to show signs of strain.&nbsp; Parts of the system, written by students who had graduated, had become black magic: no one knew how they worked, and everyone was afraid to touch them.&nbsp; When new students joined the group, it took longer and longer for them to get oriented.&nbsp; And everyone was spending more time debugging than developing new features or generating results.<br /><br />When I inspected the code, I found what you might expect: low readability, missing documentation, large functions with complex interfaces, poor organization, minimal error checking, and no automated tests.&nbsp; In the absence of version control, they had many versions of every file, scattered across several machines.<br /><br />I'm not sure if anyone could have helped them, but I am sure I didn't.&nbsp; To be honest, my own coding practices were not much better than theirs, at the time.<br /><br />The problem, as I see it now, is that we were caught in a transitional form of evolution: the nature of scientific computing was changing quickly; professional practice, and the skills of the practitioners, weren't keeping up.<br /><br />To explain what I mean, I propose a series of stages describing practices for scientific computing.<br /><ul><li>Stage 1, Calculating:&nbsp; Mostly plugging numbers into into formulas, using a computer as a glorified calculator.</li></ul><ul><li>Stage 2, Scripting: Short programs using built in functions, mostly straight line code, few user-defined functions.</li></ul><ul><li>Stage 3, Hacking: Longer programs with poor code quality, usually lacking documentation.</li></ul><ul><li>Stage 4, Coding: Good quality code which is readable, demonstrably correct, and well documented.</li></ul><ul><li>Stage 5, Architecting: Code organized in functions, classes (maybe), and libraries with well designed APIs.</li></ul><ul><li>Stage 6, Engineering: Code under version control, with automated tests, build automation, and configuration management.</li></ul><div>These stages are, very roughly, historical.&nbsp; In the earliest days of computational science, most projects were at Stages 1 and 2.&nbsp; In the last 10 years, more projects are moving into Stages 4, 5, and 6.&nbsp; But that project I worked on in grad school was stuck at Stage 3.</div><div><br /></div><h4>The Valley of Unreliable Science</h4>These stages trace a U-shaped curve of reliability:<br /><br /><div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"https://2.bp.blogspot.com/-JXqpWL6P_MQ/WpAVrIiOJuI/AAAAAAAAEy8/0hAtcl0IWfcc9d-gZjRtkmL8PWvOtUHcACLcBGAs/s1600/valley_of_unreliable_science.png\" imageanchor=\"1\" style=\"margin-left: 1em; margin-right: 1em;\"><img border=\"0\" data-original-height=\"384\" data-original-width=\"528\" src=\"https://2.bp.blogspot.com/-JXqpWL6P_MQ/WpAVrIiOJuI/AAAAAAAAEy8/0hAtcl0IWfcc9d-gZjRtkmL8PWvOtUHcACLcBGAs/s1600/valley_of_unreliable_science.png\" /></a></div><div class=\"separator\" style=\"clear: both; text-align: center;\"><br /></div><div dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"background-color: transparent; color: black; font-style: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\"><span style=\"font-family: inherit;\">By \"reliable\", I mean science that provides valid explanations, correct predictions, and designs that work.</span></span></div><b id=\"docs-internal-guid-1b112f2b-ba01-78cf-3962-dd58e28b2344\" style=\"font-weight: normal;\"><span style=\"font-family: inherit;\"><br /></span></b><br /><div dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"background-color: transparent; color: black; font-style: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\"><span style=\"font-family: inherit;\">At Stage 1, Calculating, the primary scientific result is usually analytic. &nbsp;The correctness of the result is demonstrated in the form of a proof, using math notation along with natural and technical language. &nbsp;Reviewers and future researchers are expected to review the proof, but no one checks the calculation. &nbsp;Fundamentally, Stage 1 is no different from pre-computational, analysis-based science; we should expect it to be as reliable as our ability to read and check proofs, and to press the right buttons on a calculator.</span></span></div><b style=\"font-weight: normal;\"><span style=\"font-family: inherit;\"><br /></span></b><br /><div dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"background-color: transparent; color: black; font-style: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\"><span style=\"font-family: inherit;\">At Stage 2, Scripting, the primary result is still analytic, the supporting scripts are simple enough to be demonstrably correct, and the libraries they use are presumed to be correct.</span></span><br /><br /></div><div dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"background-color: transparent; color: black; font-style: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\"><span style=\"font-family: inherit;\">But Stage 2 scripts are not always made available for review, making it hard to check their correctness or reproduce their results. &nbsp;Nevertheless, Stage 2 was considered acceptable practice for a long time; and in some fields, it still is.</span></span></div><b style=\"font-weight: normal;\"><span style=\"font-family: inherit;\"><br /></span></b><br /><div dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"background-color: transparent; color: black; font-style: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\"><span style=\"font-family: inherit;\">Stage 3, Hacking, has the same hazards as Stage 2, but at a level that's no longer acceptable. &nbsp;Small, simple scripts tend to grow into large, complex programs. &nbsp;Often, they contain implementation details that are not documented anywhere, and there is no practical way to check their correctness.</span></span></div><b style=\"font-weight: normal;\"><span style=\"font-family: inherit;\"><br /></span></b><br /><div dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"background-color: transparent; color: black; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\"><span style=\"font-family: inherit;\">Stage 3 is not <i>reliable</i> because it is not <i>reproducible</i>. </span></span><span style=\"font-family: inherit; vertical-align: baseline; white-space: pre-wrap;\"> </span><span style=\"color: #1155cc; font-family: inherit; vertical-align: baseline; white-space: pre-wrap;\"><a href=\"http://www.pnas.org/content/112/6/1645.full\" style=\"font-family: inherit; text-decoration-line: none;\">Leek and Peng</a> </span><span style=\"font-weight: normal;\"><span style=\"font-family: inherit;\">define </span></span><span style=\"font-family: inherit; white-space: pre-wrap;\">reproducibility as \"the ability to recompute data analytic results given an observed dataset and knowledge of the data analysis pipeline.\"</span></div><span style=\"font-family: inherit;\"><br /></span><br /><div dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;\"><span style=\"background-color: transparent; color: black; font-style: normal; font-weight: 400; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\"><span style=\"font-family: inherit;\">Reproducibility does not guarantee reliability, as Leek and Peng acknowledge in the title of their article, \"Reproducible research can still be wrong\".   But without reproducibility as a requirement of published research, there is no way to be confident of its reliability.</span></span></div><span style=\"font-family: inherit;\"><br /></span><br /><h4><span style=\"font-family: inherit;\">Climbing out of the valley</span></h4>Stages 4, 5, and 6 are the antidote to Stage 3.&nbsp; They describe what's needed to make computational science reproducible, and therefore more likely to be reliable.<br /><br />At a minimum, reviewers of a publication and future researchers should be able to:<br /><br />1) Download all data and software used to generate the results.<br /><br />2) Run tests and review source code to verify correctness.<br /><br />3) Run a build process to execute the computation.<br /><br />To achieve these goals, we need the tools of software engineering:<br /><br />1) <b>Version control</b> makes it possible to maintain an archived version of the code used to produce a particular result.&nbsp; Examples include Git and Subversion.<br /><br />2) During development, <b>automated tests</b> make programs more likely to be correct; they also tend to improve code quality.&nbsp; During review, they provide evidence of correctness, and for future researchers they provide what is often the most useful form of documentation.&nbsp; Examples include unittest and nose for Python and JUnit for Java.<br /><br />3) <b>Automated build systems</b> document the high-level structure of a computation: which programs process which data, what outputs they produce, etc.&nbsp; Examples include Make and Ant.<br /><br />4) <b>Configuration&nbsp;management</b>&nbsp;tools document the details of the computational environment where the result was produced, including the programming languages, libraries, and system-level software the results depend on.&nbsp; Examples include package managers like Conda that document a set of packages, containers like Docker that also document system software, and virtual machines that actually contain the entire environment needed to run a computation.<br /><br />These are the ropes and grappling hooks we need to climb out of the Valley of Unreliable Science.<br /><br />Unfortunately, most people working in computational science did not learn these tools in school, and they are not easy to learn.&nbsp; For example, Git, which has emerged as the dominant version control system, is notoriously hard to use.&nbsp; Even with GitHub and graphical clients, it's still hard.&nbsp; We have a lot of work to do to make these tools better.<br /><br />Nevertheless, it is possible to learn basic use of these tools with a reasonable investment of time.&nbsp; Software Carpentry offers&nbsp;<a href=\"http://swcarpentry.github.io/git-novice/\">a three hour workshop on Git</a>&nbsp;and a&nbsp;<a href=\"http://swcarpentry.github.io/make-novice/\">4.5 hour workshop on automated build systems</a>.&nbsp; You could do both in a day (although I'm not sure I'd recommend it).<br /><br /><h4>Implications for practitioners</h4>There are two ways to avoid getting stuck in the Valley of Unreliable Science:<br /><br />1) <b>Navigate Through It</b>: One common strategy is to start with simple scripts; if they grow and get too complex, you can improve code quality as needed, add tests and documentation, and put the code under version control when it is ready to be released.<br /><br />2) <b>Jump Over It</b>: The alternative strategy is to maintain good quality code, write documentation and tests along with the code (<a href=\"https://en.wikipedia.org/wiki/Test-driven_development\">or before</a>), and keep all code under version control.<br /><br />Naively, it seems like Navigating is better for agility: when you start a new project, you can avoid the costs of over-engineering and test ideas quickly.&nbsp; If they fail, they fail fast; and if they succeed, you can add elements of Stages 4, 5, and 6 on demand.<br /><br />Based on that thinking, I used to be a Navigator, but now I am a Jumper.&nbsp; Here's what changed my mind:<br /><br />1) The dangers of over-engineering during the early stages of a project are overstated.&nbsp; If you are in the habit of creating a new repository for each project (or creating a directory in an existing repository), and you start with a template project that includes a testing framework, the initial investment is pretty minimal.&nbsp; It's like starting every program with a copy of \"Hello, World\".<br /><br />2) The dangers of engineering too late are much greater: if you don't have tests, it's hard to refactor code; if you can't refactor, it's hard to maintain code quality; when code quality degrades, debugging time goes up; and if you don't have version control, you can't revert to a previous working (?) version.<br /><br />3) Writing documentation saves time you would otherwise spend trying to understand code.<br /><br />4) Writing tests saves time you would otherwise spend debugging.<br /><br />5) Writing documentation and tests as you go along also improves software architecture, which makes code more reusable, and that saves time you (and other researchers) would otherwise spend reimplementing the wheel.<br /><br />6) Version control makes collaboration more efficient.&nbsp; It provides a record of who changed what and when, which facilitates code and data integrity.&nbsp; It provides mechanisms for developing new code without breaking the old.&nbsp; And it provides a better form of file backup, organized in coherent changes, rather than by date.<br /><br />Maybe surprisingly, using software engineering tools early in a project doesn't hurt agility; it actually facilitates it.<br /><br /><h4>Implications for education</h4>For computational scientists, I think it's better to jump over the Valley of Unreliable Science than try to navigate through it.&nbsp; So what does that imply for education?&nbsp; Should we teach the tools and practices of software engineering right from the beginning?&nbsp; Or do students have to spend time navigating the Valley before they learn to jump over it?<br /><br />I'll address these questions in the next article.<br /><br />",
  "link": [
    "",
    "",
    "",
    "",
    ""
  ],
  "author": {
    "name": "Allen Downey",
    "uri": "http://www.blogger.com/profile/01633071333405221858",
    "email": "noreply@blogger.com",
    "gd:image": ""
  },
  "media:thumbnail": "",
  "thr:total": 0
}