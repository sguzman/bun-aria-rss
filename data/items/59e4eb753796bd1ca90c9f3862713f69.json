{
  "title": "Recommender Systems: Lessons From Building and Deployment",
  "link": "https://neptune.ai/blog/recommender-systems-lessons-from-building-and-deployment",
  "dc:creator": "Dhruvil Karani",
  "pubDate": "Thu, 25 Aug 2022 16:15:27 +0000",
  "category": [
    "ML Model Development",
    "MLOps",
    "mlops"
  ],
  "guid": "https://neptune.ai/?p=70885",
  "description": "<p>If you look at recommender systems papers, a large number of them come from the industry instead of academia. This is because RecSys is actually a practical problem. RecSys for e-commerce could be considerably different than RecSys for social media, as the business objectives differ. In addition, every novel idea needs to be tested in [&#8230;]</p>\n<p>The post <a rel=\"nofollow\" href=\"https://neptune.ai/blog/recommender-systems-lessons-from-building-and-deployment\">Recommender Systems: Lessons From Building and Deployment</a> appeared first on <a rel=\"nofollow\" href=\"https://neptune.ai\">neptune.ai</a>.</p>\n",
  "content:encoded": "\n<p>If you look at recommender systems papers, a large number of them come from the industry instead of academia. This is because RecSys is actually a practical problem. RecSys for e-commerce could be considerably different than RecSys for social media, as the business objectives differ. In addition, every novel idea needs to be tested in the real world to gain credibility. As a result, learning the practicalities of RecSys is as essential as learning about novel architectures. </p>\n\n\n<div class=\"wp-block-image\">\n<figure class=\"aligncenter size-full is-resized\"><img data-attachment-id=\"71023\" data-permalink=\"https://neptune.ai/lessons-from-building-and-deploying-recommender-systems/attachment/structure-of-a-recommender-system\" data-orig-file=\"https://i0.wp.com/neptune.ai/wp-content/uploads/Structure-of-a-recommender-system.png?fit=850%2C477&ssl=1\" data-orig-size=\"850,477\" data-comments-opened=\"0\" data-image-meta=\"{\"aperture\":\"0\",\"credit\":\"\",\"camera\":\"\",\"caption\":\"\",\"created_timestamp\":\"0\",\"copyright\":\"\",\"focal_length\":\"0\",\"iso\":\"0\",\"shutter_speed\":\"0\",\"title\":\"\",\"orientation\":\"0\"}\" data-image-title=\"Structure-of-a-recommender-system\" data-image-description=\"\" data-image-caption=\"\" data-medium-file=\"https://i0.wp.com/neptune.ai/wp-content/uploads/Structure-of-a-recommender-system.png?fit=300%2C168&ssl=1\" data-large-file=\"https://i0.wp.com/neptune.ai/wp-content/uploads/Structure-of-a-recommender-system.png?fit=850%2C477&ssl=1\" decoding=\"async\" src=\"https://i0.wp.com/neptune.ai/wp-content/uploads/Structure-of-a-recommender-system.png?resize=840%2C471&#038;ssl=1\" alt=\"Structure of a recommender system\" class=\"wp-image-71023\" width=\"840\" height=\"471\" data-recalc-dims=\"1\" /><figcaption><em>Structure of a recommender system | <a href=\"https://www.researchgate.net/figure/Structure-of-a-recommender-system_fig2_220827211\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">Source</a></em></figcaption></figure></div>\n\n\n<p>This article discusses practical considerations while building a recommender system. Specifically, we are going to talk about my learnings regarding recommender systems in the following areas:</p>\n\n\n<div class=\"custom-point-list\">\n<ul><li>Dataset creation</li><li>Objective-design</li><li>Model training</li><li>Model evaluation<ul><li>Offline evaluation</li><li>Detecting and mitigating bias</li></ul></li><li>Checklist for checking model correctness</li><li>RecSys architecture</li><li>Online MLOps</li><li>A/B testing</li></ul>\n</div>\n\n\n<p><em>Note: All views in the article are the author’s own and do not represent the author’s current or past employers.</em></p>\n\n\n\n<h2>Recommender systems: dataset creation</h2>\n\n\n\n<p>This step for RecSys is not as straightforward as text or image classification. For example, consider that we are creating a RecSys, which predicts clicks for an e-commerce website. We might train our model on all the data if we have a small number of users and items.&nbsp;</p>\n\n\n\n<p>However, if we are working at an Amazon or Walmart scale, we have millions of daily active users and items in the catalog. Training a simple collaborative filtering model on the entire historical interactions will cost us a lot – Reading the data (in TBs if not PBs) from the data warehouse, spinning up a high-capacity VM (that will run for weeks). <strong>We must question if it is worth the cost and what is the correct way of going about this.</strong></p>\n\n\n\n<p>If we have a billion users in your database and a few million daily active users, then we must only train for these active users since the inactive users have fewer chances of showing up. One can select this subset of users by putting a threshold on activity in the last N days, like select users who clicked on >=10 items in the last 10 days. If a few users we have not included in training show up, we can fall back to a custom logic, like a content-based or popularity-based retrieval. Since RecSys models are trained periodically, this subset of users will keep changing. Once we select this subset of users, we can train our model on interactions with these users.</p>\n\n\n\n<p><strong>The next question is, how much data is enough?</strong> If we have five years of data, we don’t need all of it. Yes, a model benefits from more data. But in RecSys, the main idea is to best capture a user’s interest, which changes over time. So it makes more sense to have fresh training data. In addition, a simple collaborative filtering model cannot capture too much complexity. One can verify this by plotting a metric vs. number of training steps, which will most likely show diminishing gains.</p>\n\n\n\n<p>Next,<strong> detecting duplicates in your dataset is helpful</strong>, like the same video/item posted two times with different Ids. Besides, <a href=\"/blog/category/natural-language-processing\" target=\"_blank\" rel=\"noreferrer noopener\">NLP</a> and <a href=\"/blog/category/computer-vision\" target=\"_blank\" rel=\"noreferrer noopener\">CV </a>models can help remove the dataset&#8217;s NSFW, harmful, and illegal content.</p>\n\n\n\n<p>Following these steps can reduce the dataset size considerably. This will help us save costs with minimal loss of quality.</p>\n\n\n\n<h2>Recommender systems: designing optimal objective</h2>\n\n\n\n<p>The ultimate goal of RecSys is to give people what they want. Although this is a broad and rather philosophical question, we must narrow it down to a specific signal for which the model must optimize – predicting clicks, likes, shares, etc. <strong>When we train a model to predict clicks and use it to serve recommendations, our underlying assumption is that if you click on an item, it is relevant to you. More often than not, it is not completely true.&nbsp;</strong></p>\n\n\n\n<p>To understand this better, let’s use a different example. Say you are building a RecSys for YouTube, which predicts whether a user will click a particular video. This model is used to serve recommendations based on the click probability. However, this model resulted in lesser user time spent on the platform. <strong>The reason is that clicks are not equivalent to relevance</strong>. Most clickbait videos have a high click rate, but viewers stop watching them after a few seconds. A model that is 100% accurate would serve a high number of videos that are clicked but not watched.</p>\n\n\n\n<p>Learning from the above, you decide to train a model that predicts if the user will watch at least 75% of the video. So the training examples will include (user, video, label) triplets, where label=1 if >=75% of the video is watched else 0. This is better than the click model because now we consider that the user has done more than just click a video. However, even this has a major problem.</p>\n\n\n\n<p>Consider two videos, A and B. A is an entertaining 20 seconds long video, and B is a tutorial video of 60 minutes. To watch 75%, you need to watch 15 seconds of A and 45 seconds of B.</p>\n\n\n\n<p>Naturally, A will have a higher positive rate of this label than B. However, watching 15 seconds of A could mean that the user did not like A (as 15 seconds is too less of a time to decide if you prefer the content), and watching 30 minutes (50%) of B most likely means that B is relevant to the user. <strong>Even a highly accurate model would end up serving a disproportionately large number of shorter duration videos, which is not optimal.</strong></p>\n\n\n\n<p>The point is that one signal rarely defines complete relevance. Each signal has its own bias. <strong>It is a good practice to train multiple models on multiple signals, combine their individual scores (weighted addition, for example), and create the final score.</strong></p>\n\n\n\n<h2>Recommender systems: model training</h2>\n\n\n\n<p>Large NLP or Vision models have billions of parameters distributed among linear, convolution, recurrent, or attention layers. Each of these parameters is involved in the computation of the output. However, in recommendation models, model sizes are much larger than most NLP or CV models.&nbsp;</p>\n\n\n\n<p>Consider matrix factorization, where the model learns a user and an item embedding (in the case of <a href=\"https://developers.google.com/machine-learning/recommendation/collaborative/basics\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">collaborative filtering</a>). If the embedding dimension is 100, you have 100 million users and 10 million items. The total number of embeddings is 110 million. Each embedding has 100 learnable parameters. Hence the model has 110*100 million or ~11 billion parameters. However, to compute scores for a user, you need to access just one of the 100 million user embeddings at a time. This particular user embedding is used along with all the item embeddings to score all the items. Hence, recommendation models are memory intensive but compute light.</p>\n\n\n\n<p>This is a different challenge because now you can’t and don’t need to load the entire embedding table on a GPU/TPU for a batch of data. However, writing such models on traditional frameworks like <a href=\"https://www.tensorflow.org/\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">TensorFlow </a>or <a href=\"https://pytorch.org/\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">PyTorch</a> is hard because their default behaviour is to load the entire model on GPU/TPUs. Fortunately, many frameworks have built functionality for this very purpose.</p>\n\n\n\n<p>Tensorflow has built a framework called <a href=\"https://www.tensorflow.org/recommenders\" target=\"_blank\" rel=\"noreferrer noopener nofollow\"><strong>tensorflow_recommenders</strong></a><strong> </strong>with a special embedding table called <a href=\"https://www.tensorflow.org/recommenders/api_docs/python/tfrs/layers/embedding/TPUEmbedding\">TPUEmbedding</a>. Besides, it has implemented versions of many common tasks in RecSys like <a href=\"https://www.tensorflow.org/recommenders/api_docs/python/tfrs/tasks/Retrieval\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">retrieval</a> and <a href=\"https://www.tensorflow.org/recommenders/api_docs/python/tfrs/tasks/Ranking\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">ranking</a> and popular architectures like <a href=\"https://www.tensorflow.org/recommenders/api_docs/python/tfrs/layers/dcn\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">DCN</a>.&nbsp;</p>\n\n\n\n<p>Recently, PyTorch announced <a href=\"https://pytorch.org/torchrec/\" target=\"_blank\" rel=\"noreferrer noopener nofollow\"><strong>torchrec</strong></a>. According to the team: </p>\n\n\n\n<p><em>“TorchRec is a PyTorch domain library built to provide common sparsity & parallelism primitives needed for large-scale recommender systems (RecSys). It allows authors to train models with large embedding tables sharded across many GPUs.” </em></p>\n\n\n\n<p>NVIDIA also has <a href=\"https://developer.nvidia.com/nvidia-merlin\" target=\"_blank\" rel=\"noreferrer noopener nofollow\"><strong>Merlin</strong></a>, which automates common processes in RecSys for faster production-grade systems. It supports Tensorflow and PyTorch and is built on top of cuDF (GPU equivalent of Pandas), RAPIDS (GPU-based analytics and data manipulation library), and Triton (high-performance inference server).</p>\n\n\n\n<h2>Recommender systems: model evaluation</h2>\n\n\n\n<h3>Offline evaluation</h3>\n\n\n\n<p>Typical classification task optimizes for metrics like accuracy, precision, recall, or F1-score. Evaluating RecSys using these metrics is deceptive. In RecSys, we are not interested in objective probabilities. We are more interested in ranking. For example, if predicted scores for videos A and B are 0.9 and 0.8, we will show video A first and then B while serving. Even if the probabilities for A and B were 0.5, 0.4, or 0.3,0.2, the outcome is still the same. It’s the ordering that matters, not the absolute numbers. Hence, metrics like ROC-AUC, PR-AUC, NDCG, recall@K, and precision@K are better suited.&nbsp;</p>\n\n\n\n<p>However, even then, this evaluation is can fall short. Recommender systems are notorious for compounding bias towards certain topics, demographics, or popularity. A recommender system trains on logs generated by itself. If popular content is promoted more by the system, then the incremental logs generated will have more triplets for this popular content. <strong>The next version of the model, trained on these new logs, will see a skewed distribution and will learn that recommending popular items is a safe choice. This is called popularity bias.&nbsp;</strong></p>\n\n\n\n<p>It is advisable to compute metrics on different levels &#8211; user attributes like age, gender, location, etc. This helps us understand if the model is performing better for a particular set of users and not performing well for the rest. Tools like <a href=\"https://github.com/jacopotagliabue/reclist\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">reclist</a> provide an easy interface to deep-dive into your recommender model.</p>\n\n\n\n<p>Another useful tool could be <a href=\"/experiment-tracking\" target=\"_blank\" rel=\"noreferrer noopener\">Neptune</a>, as it provides simple logging APIs for a much more organized, collaborative, and comprehensive analysis. One can <a href=\"https://docs.neptune.ai/you-should-know/displaying-metadata#creating-dashboards\" target=\"_blank\" rel=\"noreferrer noopener\">create custom dashboards</a> to visualize the logs through interactive visualizations. As discussed above, we are interested in metrics at multiple cuts based on attributes like demographic and location. We can plot ROC/PR AUC, loss curves, and log ranking metrics here and easily compare and determine if the model is really robust or not.</p>\n\n\n\n<div id=\"blog-cta-intext-block_63079ae6b8f14\" class=\"blog-cta-intext\">\n  <h3 class=\"blog-cta-intext__title\">Learn more</h3>\n  <div class=\"blog-cta-intext__content\"><p>Check what <a href=\"https://docs.neptune.ai/you-should-know/what-can-you-log-and-display\" target=\"_blank\" rel=\"noopener\">metadata you can log and display in Neptune</a>.</p>\n</div>\n  </div>\n\n<div class=\"wp-block-image\">\n<figure class=\"aligncenter size-full\"><img data-attachment-id=\"70888\" data-permalink=\"https://neptune.ai/lessons-from-building-recommender-system-1\" data-orig-file=\"https://i0.wp.com/neptune.ai/wp-content/uploads/lessons-from-building-recommender-system-1.png?fit=768%2C413&ssl=1\" data-orig-size=\"768,413\" data-comments-opened=\"0\" data-image-meta=\"{\"aperture\":\"0\",\"credit\":\"\",\"camera\":\"\",\"caption\":\"\",\"created_timestamp\":\"0\",\"copyright\":\"\",\"focal_length\":\"0\",\"iso\":\"0\",\"shutter_speed\":\"0\",\"title\":\"\",\"orientation\":\"0\"}\" data-image-title=\"lessons-from-building-recommender-system-1\" data-image-description=\"\" data-image-caption=\"\" data-medium-file=\"https://i0.wp.com/neptune.ai/wp-content/uploads/lessons-from-building-recommender-system-1.png?fit=300%2C161&ssl=1\" data-large-file=\"https://i0.wp.com/neptune.ai/wp-content/uploads/lessons-from-building-recommender-system-1.png?fit=768%2C413&ssl=1\" decoding=\"async\" width=\"768\" height=\"413\" src=\"https://i0.wp.com/neptune.ai/wp-content/uploads/lessons-from-building-recommender-system-1.png?resize=768%2C413&#038;ssl=1\" alt=\"Example dashboard in Neptune with  visualize logs through interactive visualizations\" class=\"wp-image-70888\" data-recalc-dims=\"1\"/><figcaption><em>Example dashboard in Neptune | <a href=\"/experiment-tracking\">Source</a></em></figcaption></figure></div>\n\n\n<h3>Detecting and mitigating bias</h3>\n\n\n\n<p>As explained earlier, biases like popularity bias can easily propagate through the system if not taken care of. But how do we measure bias before mitigating it?</p>\n\n\n<div class=\"wp-block-image\">\n<figure class=\"aligncenter size-full is-resized\"><img data-attachment-id=\"70889\" data-permalink=\"https://neptune.ai/lessons-from-building-recommender-system-2\" data-orig-file=\"https://i0.wp.com/neptune.ai/wp-content/uploads/lessons-from-building-recommender-system-2.png?fit=334%2C151&ssl=1\" data-orig-size=\"334,151\" data-comments-opened=\"0\" data-image-meta=\"{\"aperture\":\"0\",\"credit\":\"\",\"camera\":\"\",\"caption\":\"\",\"created_timestamp\":\"0\",\"copyright\":\"\",\"focal_length\":\"0\",\"iso\":\"0\",\"shutter_speed\":\"0\",\"title\":\"\",\"orientation\":\"0\"}\" data-image-title=\"lessons-from-building-recommender-system-2\" data-image-description=\"\" data-image-caption=\"\" data-medium-file=\"https://i0.wp.com/neptune.ai/wp-content/uploads/lessons-from-building-recommender-system-2.png?fit=300%2C136&ssl=1\" data-large-file=\"https://i0.wp.com/neptune.ai/wp-content/uploads/lessons-from-building-recommender-system-2.png?fit=334%2C151&ssl=1\" decoding=\"async\" src=\"https://i0.wp.com/neptune.ai/wp-content/uploads/lessons-from-building-recommender-system-2.png?resize=474%2C214&#038;ssl=1\" alt=\"Mitigating bias\" class=\"wp-image-70889\" width=\"474\" height=\"214\" data-recalc-dims=\"1\" /><figcaption><em>A loop of detecting and mitigating bias| <a href=\"https://people.engr.tamu.edu/caverlee/pubs/Ziwei_KDD_2021.pdf\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">Source</a></em></figcaption></figure></div>\n\n\n<p>One easy way to measure popularity bias is to check how many unique items make 10%, 20%, 50%, .. 100% of recommendations. In an ideal case, the number of items should increase with % of recommendations. However, for a biased model, the number of items will saturate after a certain % (usually on the lower end). This is because the model relies on only a certain subset of recommendable items to make predictions.&nbsp;</p>\n\n\n\n<p>But this approach does not take the user’s preference into account. For example, if a user U1 interacts with three items A, B, and C; and likes items A and B but not C. Similarly, user U2 interacts with A, B, and C; and likes only A. We know that A is a popular item while B and C are not.</p>\n\n\n<div class=\"medium-table\">\n        <div class=\"mt-row heading\">\n            <div class=\"mt-col\" style=\"width: 10%\">\n                    </div>\n            <div class=\"mt-col\" style=\"width: 30%\">\n            A (popular)        </div>\n            <div class=\"mt-col\" style=\"width: 30%\">\n            B (not-popular)        </div>\n            <div class=\"mt-col\" style=\"width: 30%\">\n            C (not-popular)        </div>\n        </div>\n    \n            <div class=\"mt-row\">\n                            <div class=\"mt-col\" style=\"width: 10%\">\n                                                                <p>U1</p>\n                                    </div>\n                            <div class=\"mt-col\" style=\"width: 30%\">\n                                        <span class=\"column-name\">\n                        A (popular):\n                    </span>\n                                                                <p>1</p>\n                                    </div>\n                            <div class=\"mt-col\" style=\"width: 30%\">\n                                        <span class=\"column-name\">\n                        B (not-popular):\n                    </span>\n                                                                <p>1</p>\n                                    </div>\n                            <div class=\"mt-col\" style=\"width: 30%\">\n                                        <span class=\"column-name\">\n                        C (not-popular):\n                    </span>\n                                                                0                                    </div>\n                    </div>\n            <div class=\"mt-row\">\n                            <div class=\"mt-col\" style=\"width: 10%\">\n                                                                <p>U2</p>\n                                    </div>\n                            <div class=\"mt-col\" style=\"width: 30%\">\n                                        <span class=\"column-name\">\n                        A (popular):\n                    </span>\n                                                                <p>1</p>\n                                    </div>\n                            <div class=\"mt-col\" style=\"width: 30%\">\n                                        <span class=\"column-name\">\n                        B (not-popular):\n                    </span>\n                                                                0                                    </div>\n                            <div class=\"mt-col\" style=\"width: 30%\">\n                                        <span class=\"column-name\">\n                        C (not-popular):\n                    </span>\n                                                                0                                    </div>\n                    </div>\n    </div>\n\n\n<div id=\"block_63073c43681ca\" class=\"separator separator-10\"></div>\n\n\n\n<p class=\"has-text-align-center\"><em>Example of a simple biased model</em></p>\n\n\n\n<p>For U1, if the model scores higher for A than B, then it may be biased. Because the user response to both of them is positive. Even if the model consistently favours the more popular item, we have a biased model. However, for U2, it makes sense to rank the popular item higher because U2 does not like the other two non-popular items. <strong>Although the examples we have used are very simplistic, there are measures like statistical parity that help you measure this.</strong></p>\n\n\n\n<p>There are a few simple ways to mitigate bias. <strong>One way is to introduce negative samples.</strong> Consider an e-commerce platform where users interact with a few items out of hundreds shown. We only know what items the user interacted with (positive examples). However, we have no idea about what happened to the other items. To balance this dataset, we introduce negative samples by randomly sampling an item for a user and assigning it a negative label (=0). The assumption is that a user will not like an item picked randomly. Since this assumption is most likely true, adding negative samples actually adds missing information to the dataset.</p>\n\n\n\n<div id=\"blog-cta-intext-block_630798d2b8f12\" class=\"blog-cta-intext\">\n  <h3 class=\"blog-cta-intext__title\">May interest you</h3>\n  <div class=\"blog-cta-intext__content\"><p><img src=\"https://s.w.org/images/core/emoji/14.0.0/72x72/1f4cc.png\" alt=\"📌\" class=\"wp-smiley\" style=\"height: 1em; max-height: 1em;\" /> <a href=\"/blog/recommender-systems-metrics\" target=\"_blank\" rel=\"noopener\">Recommender Systems: Machine Learning Metrics and Business Metrics</a></p>\n</div>\n  </div>\n\n\n<h2>Checklist for testing correctness of a recommender system model</h2>\n\n\n\n<p>Like any piece of software, one should ensure the correctness of the models by writing unit tests. Unfortunately, writing ML code unit tests is uncommon and tricky. However, for RecSys, let’s focus on a simple CF (collaborative filtering) model. As we know, the model is essentially the set of user embeddings and item embeddings. You can test this model for the following:</p>\n\n\n<div class=\"custom-point-list\">\n<ol><li><strong>Correct Scoring </strong>&#8211; The scoring operation consuming a user and item embedding should produce a score between 0 and 1.</li><li><strong>Correct versioning </strong>&#8211; Since the embeddings are retrained periodically, it is important to version them correctly so that the scores are consistent.</li><li><strong>Correct features </strong>&#8211; Some models, like two-tower models, use features like user activity in the last X hours. One needs to make sure that the feature pipeline that the model consumes does not produce leaky features.</li><li><strong>Correct training dataset </strong>&#8211; The dataset should not have duplicate user-item pairs, the labels should be correct, and the train-test-split should be random.</li></ol>\n</div>\n\n\n<div id=\"blog-cta-intext-block_630798a2b8f11\" class=\"blog-cta-intext\">\n  <h3 class=\"blog-cta-intext__title\">Read also </h3>\n  <div class=\"blog-cta-intext__content\"><p><img src=\"https://s.w.org/images/core/emoji/14.0.0/72x72/1f4cc.png\" alt=\"📌\" class=\"wp-smiley\" style=\"height: 1em; max-height: 1em;\" /> <a href=\"/blog/how-to-test-recommender-system\" target=\"_blank\" rel=\"noopener\">How to Test a Recommender System</a></p>\n<p><img src=\"https://s.w.org/images/core/emoji/14.0.0/72x72/1f4cc.png\" alt=\"📌\" class=\"wp-smiley\" style=\"height: 1em; max-height: 1em;\" /> <a href=\"https://github.com/jacopotagliabue/reclist\" target=\"_blank\" rel=\"noopener\">RecList &#8211; Behavioral &#8220;black-box&#8221; testing for recommender systems</a></p>\n</div>\n  </div>\n\n\n<h2>RecSys architecture</h2>\n\n\n\n<p>Recommender systems have to pick the best set for a user from a set of millions of items. However, this has to be done within strict latency requirements. As a result, the more complex model we train, the more time it takes to process one request. Hence, RecSys follows a multi-stage architecture. Think of it as a funnel that starts with a million items and ends with a handful of recommendations.</p>\n\n\n\n<p><strong>The idea is to use a simple, lightweight model at the top of this funnel, like a simple collaborative filtering model.</strong> This model should be able to pick a few thousand most relevant items, maybe not with the best ranking i.e., the relevant items should be present in this set of thousands of items, and it is okay if they are not at the top. Hence, this model optimizes recall and speed. This model is also called a candidate generator. Even in a simple collaborative filtering model, ensure the embedding dimensions are not too large. Using 100s of dimensions might give you a slight increment in the recall but affect your latencies.</p>\n\n\n\n<p><strong>Then, these thousands of items are sent to another model called light ranker. As the name suggests, the task of this model is to find the best ranking.</strong> The model is trained for high precision and is more complex than the candidate generator (for example, two-tower models). It also uses more features based on user activity, item metadata, and more. The outcome of this model is a ranked list top hundreds of items.</p>\n\n\n\n<p><strong>Finally, these hundreds of items are sent to heavy ranker. </strong>This ranker has a similar objective to the light ranker, except that it is heavier than the light ranker and uses even more features. Since it operates on hundreds of items only, the latencies involved with such complex architectures are manageable.&nbsp;</p>\n\n\n<div class=\"wp-block-image\">\n<figure class=\"aligncenter size-large\"><img data-attachment-id=\"70890\" data-permalink=\"https://neptune.ai/lessons-from-building-recommender-system-3\" data-orig-file=\"https://i0.wp.com/neptune.ai/wp-content/uploads/lessons-from-building-recommender-system-3.png?fit=1999%2C1068&ssl=1\" data-orig-size=\"1999,1068\" data-comments-opened=\"0\" data-image-meta=\"{\"aperture\":\"0\",\"credit\":\"\",\"camera\":\"\",\"caption\":\"\",\"created_timestamp\":\"0\",\"copyright\":\"\",\"focal_length\":\"0\",\"iso\":\"0\",\"shutter_speed\":\"0\",\"title\":\"\",\"orientation\":\"0\"}\" data-image-title=\"lessons-from-building-recommender-system-3\" data-image-description=\"\" data-image-caption=\"\" data-medium-file=\"https://i0.wp.com/neptune.ai/wp-content/uploads/lessons-from-building-recommender-system-3.png?fit=300%2C160&ssl=1\" data-large-file=\"https://i0.wp.com/neptune.ai/wp-content/uploads/lessons-from-building-recommender-system-3.png?fit=1024%2C547&ssl=1\" decoding=\"async\" width=\"1024\" height=\"547\" src=\"https://i0.wp.com/neptune.ai/wp-content/uploads/lessons-from-building-recommender-system-3.png?resize=1024%2C547&#038;ssl=1\" alt=\"RecSys architecture\" class=\"wp-image-70890\" data-recalc-dims=\"1\"/><figcaption><em>Recommender systems architecture | <a href=\"https://milvus.io/blog/2021-11-26-accelerating-candidate-generation-in-recommender-systems-using-milvus-paired-with-paddlepaddle.md\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">Source</a></em></figcaption></figure></div>\n\n\n<h2>Online MLOps for recommender systems</h2>\n\n\n\n<p>One good thing about recommendation models vs. a classification or regression model is that we get real-time feedback or “labels”. Hence, we can set up a comprehensive ML Ops pipeline to closely monitor your model performance.</p>\n\n\n\n<p>There are many metrics we can monitor.</p>\n\n\n<div class=\"case-study-numbered-list\">\n    <h2></h2>\n    <ul>\n                    <li><span>1</span>Time spent on the platform<br />\n</li>\n                    <li><span>2</span>Engagement</li>\n                    <li><span>3</span>Clicks</li>\n                    <li><span>4</span>Purchases<br />\n</li>\n                    <li><span>5</span>User churn</li>\n            </ul>\n</div>\n\n\n\n<p>Model performance on metrics like engagement is easy to measure in offline experiments. However, you can’t measure something like churn in an offline experiment. It is common to find such discrepancies in real-world RecSys. <strong>Usually, we analyze what online metrics that are measurable offline (like time spent, engagement, clicks) have a positive correlation with churn. This reduces the problem of improving a set of predictable metrics in offline experiments.</strong></p>\n\n\n\n<p><strong>Besides model quality and performance, we should monitor things like average, 95th percentile,</strong> and 99th percentile latencies, CPU, non-200 status code rates,<strong> and memory usage.</strong> Not so surprising, but improving these metrics also improves the time spent and reduces churn. Tools like <a href=\"https://grafana.com/\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">Grafana</a> help set up comprehensive observability dashboards.</p>\n\n\n\n<p>Retraining pipelines can also break down because of problems not related to bugs in code, like not enough pods available in your Kubernetes clusters or not enough GPU resources available. <strong>If you are using DAGs on Airflow, it has the option to set up a failure alert on Slack.</strong> Alternatively, tune the number of retries and timeout parameters so that the chances of automatic recovery improve.</p>\n\n\n\n<h2>Recommender systems: A/B testing</h2>\n\n\n\n<p>Improving recommender systems is a continuous process. However, this improvement should not worsen the user experience. If your team comes up with a novel model that shows amazing gains in offline evaluation, it is not obvious to roll out the model for all the users. This is where A/B testing comes into play.</p>\n\n\n\n<p>Any new target model must be evaluated against the control (existing production) model. In an A/B test, you would randomly select a small percentage of users and serve them using the target model, while the rest receive recommendations from the control model as before. After a few days/weeks, look at which model performed better and quantify it using hypothesis testing. If the test concludes that the new model gives gains over the control, you roll out the new model for all users.</p>\n\n\n\n<p><strong>However, it is a good practice to roll out the new model to only 98-99% of users and let the rest 1-2% be served by the control model.</strong> This 1-2% of users is called the holdout set. <strong>The idea here is to see if, at some point, the new model starts degrading, is it due to some change that impacts all models, or if something is wrong with this new model alone?</strong> In RecSys, a target model, when served to a small set of users, is still trained on logs majorly generated by the control model. However, it is possible that when the new model becomes the control, it starts learning from the logs majorly generated by itself and degrades.</p>\n\n\n\n<h2>Conclusion</h2>\n\n\n\n<p>RecSys has many moving parts, and each of these parts is a knob that can be tuned to make the system better. Personally, this is what makes RecSys really interesting to me. I hope the article was able to provide new directions of thinking. Each of these topics has a varying amount of literature for you to explore. I have linked some references below. Make sure to check them out!</p>\n\n\n\n<h3>References </h3>\n\n\n\n<p>[1] <a href=\"https://arxiv.org/abs/2202.05387\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">TwHIN: Embedding the Twitter Heterogeneous Information Network for Personalized Recommendation</a></p>\n\n\n\n<p>[2] <a href=\"https://dl.acm.org/doi/pdf/10.1145/3437963.3441820\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">Popularity-Opportunity Bias in Collaborative Filtering</a></p>\n\n\n\n<p>[3] <a href=\"https://arxiv.org/pdf/2105.09293.pdf\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">Lessons Learned Addressing Dataset Bias in Model-Based Candidate Generation at Twitter</a></p>\n\n\n\n\n<div id=\"author-box-new-format-block_60421833aff63\" class=\"article__footer article__author\">\n  <div class=\"article__authorImage\">\n          <img width=\"193\" height=\"193\" src=\"https://i0.wp.com/neptune.ai/wp-content/uploads/Dhruvil-Karani.png?fit=193%2C193&ssl=1\" class=\"article__authorImage-img\" alt=\"Dhruvil Karani\" decoding=\"async\" data-attachment-id=\"35458\" data-permalink=\"https://neptune.ai/blog/how-to-structure-and-manage-nlp-projects-templates/attachment/dhruvil-karani\" data-orig-file=\"https://i0.wp.com/neptune.ai/wp-content/uploads/Dhruvil-Karani.png?fit=193%2C193&ssl=1\" data-orig-size=\"193,193\" data-comments-opened=\"0\" data-image-meta=\"{\"aperture\":\"0\",\"credit\":\"\",\"camera\":\"\",\"caption\":\"\",\"created_timestamp\":\"0\",\"copyright\":\"\",\"focal_length\":\"0\",\"iso\":\"0\",\"shutter_speed\":\"0\",\"title\":\"\",\"orientation\":\"0\"}\" data-image-title=\"Dhruvil Karani\" data-image-description=\"\" data-image-caption=\"\" data-medium-file=\"https://i0.wp.com/neptune.ai/wp-content/uploads/Dhruvil-Karani.png?fit=193%2C193&ssl=1\" data-large-file=\"https://i0.wp.com/neptune.ai/wp-content/uploads/Dhruvil-Karani.png?fit=193%2C193&ssl=1\" />      </div>\n\n  <div class=\"article__authorContent\">\n          <h3 class=\"article__authorContent-name\">Dhruvil Karani</h3>\n    \n          <p class=\"article__authorContent-text\"><strong>Data Scientist at i3systems India</strong><br>A Data Scientist who loves math and programming equally. His previous experiences allowed him to work on large scale NLP problems like chatbots and document understanding. He believes that educating the masses about technology and its impact is as important as developing new ones.</p>\n    \n          <ul class=\"article__authorSocial\">\n        <li class=\"article__authorSocial-single article__authorSocial-name\">Follow me on</li>\n                  <li class=\"article__authorSocial-single\"><a href=\"https://twitter.com/dhruvil_karani\" class=\"article__authorSocial-tw\" target=\"_blank\"></a></li>\n        \n                  <li class=\"article__authorSocial-single\"><a href=\"https://www.linkedin.com/in/dhruvil-karani/\" class=\"article__authorSocial-lk\" target=\"_blank\"></a></li>\n        \n                  <li class=\"article__authorSocial-single\"><a href=\"https://thenlp.space/\" class=\"article__authorSocial-www\" target=\"_blank\"></a></li>\n              </ul>\n    \n  </div>\n</div>\n\n\n<div class=\"is-layout-flow wp-block-group\"><div class=\"wp-block-group__inner-container\">\n<hr class=\"wp-block-separator has-css-opacity\"/>\n\n\n\n<p class=\"has-text-color\" style=\"color:#4455a6\"><strong>READ NEXT</strong></p>\n\n\n\n<h2>Real-World MLOps Examples: Model Development in Hypefactors</h2>\n\n\n\n<p class=\"has-small-font-size\">6 mins read | Author&nbsp;Stephen Oladele | Updated June 28th, 2022</p>\n\n\n<div id=\"block_5ffc75def9f8e\" class=\"separator separator-10\"></div>\n\n\n\n<p>In this first installment of the series “Real-world MLOps Examples,”&nbsp;<a href=\"https://www.linkedin.com/in/jules-belveze\" target=\"_blank\" rel=\"noreferrer noopener\">Jules Belveze</a>, an MLOps Engineer, will walk you through the model development process at&nbsp;<a href=\"https://hypefactors.com/\" target=\"_blank\" rel=\"noreferrer noopener\">Hypefactors</a>, including the types of models they build, how they design their training pipeline, and other details you may find valuable. Enjoy the chat!</p>\n\n\n\n<h3 id=\"company-profile\">Company profile</h3>\n\n\n\n<p><a href=\"https://hypefactors.com/\" target=\"_blank\" rel=\"noreferrer noopener\">Hypefactors</a>&nbsp;provides an all-in-one media intelligence solution for managing PR and communications, tracking trust, product launches, and market and financial intelligence. They operate large data pipelines that stream in the world’s media data ongoingly in real-time. AI is used for many automations that were previously performed manually.</p>\n\n\n\n<h3 id=\"guest-introduction\">Guest introduction</h3>\n\n\n\n<h4>Could you introduce yourself to our readers?</h4>\n\n\n\n<p>Hey Stephen, thanks for having me! My name is Jules. I am 26. I was born and raised in Paris, I am currently living in Copenhagen.</p>\n\n\n\n<h4>Hey Jules! Thanks for the intro. Walk me through your background and how you got to Hypefactors.</h4>\n\n\n\n<p>I hold a Bachelor’s in statistics and probabilities and a Master’s in general engineering from universities in France. On top of that, I also graduated in Data Science with a focus on deep learning from Danish Technical University, Denmark. I’m fascinated by multilingual natural language processing (and therefore specialized in it). I also researched anomaly detection on high-dimensional time series during my graduate studies with Microsoft.&nbsp;</p>\n\n\n\n<p>Today, I work for a media intelligence tech company called Hypefactors, where I develop NLP models to help our users gain insights from the media landscape. What currently works for me is having the opportunity to carry out models from prototyping all the way to production. I guess you could call me a nerd, at least that’s how my friend describes me, as I spent most of my free time either coding or listening to disco vinyl.</p>\n\n\n\n<h3 id=\"model-development-at-hypefactors\">Model development at Hypefactors</h3>\n\n\n\n<h4>Could you elaborate on the types of models you build at Hypefactors?</h4>\n\n\n\n<p>Even though we also have computer vision models running in production, we mainly build&nbsp;<a href=\"https://neptune.ai/blog/category/natural-language-processing\" target=\"_blank\" rel=\"noreferrer noopener\">NLP (Natural Language Processing)</a>&nbsp;models for various use cases. We need to cover multiple countries and handle many languages. The multilingual aspect makes developing with “classical machine learning” approaches hard. We craft deep learning models on top of the&nbsp;<a href=\"https://github.com/huggingface/transformers\" target=\"_blank\" rel=\"noreferrer noopener\">transformer library</a>.&nbsp;</p>\n\n\n\n<p>We run all sorts of models in production, varying from span extraction or sequence classification to text generation. Those models are designed to serve different use cases, like topic classification, sentiment analysis, or summarisation.</p>\n\n\n<a class=\"button continous-post blue-filled\" href=\"/blog/mlops\" target=\"_blank\">\n    Continue reading -></a>\n\n\n\n<hr class=\"wp-block-separator has-css-opacity\"/>\n</div></div>\n<p>The post <a rel=\"nofollow\" href=\"https://neptune.ai/blog/recommender-systems-lessons-from-building-and-deployment\">Recommender Systems: Lessons From Building and Deployment</a> appeared first on <a rel=\"nofollow\" href=\"https://neptune.ai\">neptune.ai</a>.</p>\n",
  "post-id": 70885
}