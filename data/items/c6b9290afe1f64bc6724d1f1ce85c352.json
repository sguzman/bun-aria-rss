{
  "title": "Preliminary BLAS Results",
  "link": "",
  "updated": "2012-11-10T00:00:00+00:00",
  "id": "https://mrocklin.github.io/blog/work/2012/11/10/GeneratingBLAS-PreliminaryResults",
  "content": "<p>In the last few posts I’ve built up some independent technology.</p>\n\n<ol>\n  <li><a href=\"https://mrocklin.github.io/blog/work/2012/10/29/Matrix-Computations/\">BLAS and code generation</a> - a logical description</li>\n  <li><a href=\"https://mrocklin.github.io/blog/work/2012/11/01/Unification/\">Unification</a> - advanced pattern matching</li>\n  <li><a href=\"https://mrocklin.github.io/blog/work/2012/11/07/Strategies/\">Strategies</a> - programmatic control</li>\n  <li><a href=\"https://mrocklin.github.io/blog/work/2012/11/09/BranchingStrategies/\">Branching Strategies</a> - control with multiple possibilities</li>\n</ol>\n\n<p>In this post I’ll pull them all together for my first substantial results generating Fortran code to call BLAS/LAPACK. Lets go through a working example</p>\n\n<p>We set up a problem that we’d like to solve. We want to compute \\((4 X X^{T} + 2 Z)^{-1} X\\) where \\( X \\) is invertible and and \\(Z\\) is symmetric positive definite.</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># Set up a mathematical problem to solve\n</span><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">X</span> <span class=\"o\">=</span> <span class=\"n\">MatrixSymbol</span><span class=\"p\">(</span><span class=\"s\">'X'</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">Z</span> <span class=\"o\">=</span> <span class=\"n\">MatrixSymbol</span><span class=\"p\">(</span><span class=\"s\">'Z'</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">target</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"o\">*</span><span class=\"n\">X</span><span class=\"o\">*</span><span class=\"n\">X</span><span class=\"p\">.</span><span class=\"n\">T</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">Z</span><span class=\"p\">).</span><span class=\"n\">I</span><span class=\"o\">*</span><span class=\"n\">X</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">assumptions</span> <span class=\"o\">=</span> <span class=\"n\">Q</span><span class=\"p\">.</span><span class=\"n\">invertible</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">)</span> <span class=\"o\">&amp;</span> <span class=\"n\">Q</span><span class=\"p\">.</span><span class=\"n\">positive_definite</span><span class=\"p\">(</span><span class=\"n\">Z</span><span class=\"p\">)</span> <span class=\"o\">&amp;</span> <span class=\"n\">Q</span><span class=\"p\">.</span><span class=\"n\">symmetric</span><span class=\"p\">(</span><span class=\"n\">Z</span><span class=\"p\">)</span></code></pre>\n</figure>\n\n<p>We have described a set of BLAS/LAPACK operations to perform certain transformations when the right conditions are met.  Each BLAS operation is a single rewrite rule.</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">sympy.matrices.expressions.gen</span> <span class=\"kn\">import</span> <span class=\"n\">rr_from_blas</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">sympy.matrices.expressions.blas</span> <span class=\"kn\">import</span>   <span class=\"n\">GEMM</span><span class=\"p\">,</span> <span class=\"n\">SYMM</span><span class=\"p\">,</span> <span class=\"n\">TRMM</span><span class=\"p\">,</span> <span class=\"n\">TRSV</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">sympy.matrices.expressions.lapack</span> <span class=\"kn\">import</span> <span class=\"n\">POSV</span><span class=\"p\">,</span> <span class=\"n\">GESV</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">routines</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">TRSV</span><span class=\"p\">,</span> <span class=\"n\">POSV</span><span class=\"p\">,</span> <span class=\"n\">GESV</span><span class=\"p\">,</span> <span class=\"n\">TRMM</span><span class=\"p\">,</span> <span class=\"n\">SYMM</span><span class=\"p\">,</span> <span class=\"n\">GEMM</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">rules</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">rr_from_blas</span><span class=\"p\">(</span><span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">assumptions</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">r</span> <span class=\"ow\">in</span> <span class=\"n\">routines</span><span class=\"p\">]</span></code></pre>\n</figure>\n\n<p>Each of these rules can convert one kind of expression into a computation given\ncertain conditions. For example</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>SYMM:  alpha*A*B + beta*C -&gt; SYMM(alpha, A, B, beta, C) if A or B is symmetric\n</code></pre></div></div>\n\n<p>We need to combine them to turn the large target expression into a set of atomic inputs.  Some of the BLAS routines overlap so there are potentially many possibilities.</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">sympy.matrices.expressions.gen</span> <span class=\"kn\">import</span> <span class=\"n\">top_down</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">sympy.rules.branch</span> <span class=\"kn\">import</span> <span class=\"n\">multiplex</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">rule</span> <span class=\"o\">=</span> <span class=\"n\">top_down</span><span class=\"p\">(</span><span class=\"n\">multiplex</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">rules</span><span class=\"p\">))</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">computations</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">rule</span><span class=\"p\">(</span><span class=\"n\">target</span><span class=\"p\">))</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">computations</span><span class=\"p\">)</span>\n<span class=\"mi\">2</span></code></pre>\n</figure>\n\n<p>We generate Fortran code from the first computation</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">print</span> <span class=\"n\">computations</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"n\">print_Fortran</span><span class=\"p\">(</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">assumptions</span><span class=\"p\">)</span></code></pre>\n</figure>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-fortran\" data-lang=\"fortran\"><span class=\"k\">subroutine</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">INFO</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"kt\">real</span><span class=\"o\">*</span><span class=\"mi\">8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">intent</span><span class=\"p\">(</span><span class=\"k\">inout</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">::</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"kt\">real</span><span class=\"o\">*</span><span class=\"mi\">8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">intent</span><span class=\"p\">(</span><span class=\"k\">inout</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">::</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"kt\">integer</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">intent</span><span class=\"p\">(</span><span class=\"k\">out</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">::</span><span class=\"w\"> </span><span class=\"n\">INFO</span><span class=\"w\">\n</span><span class=\"kt\">integer</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">intent</span><span class=\"p\">(</span><span class=\"k\">in</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">::</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\">\n\n</span><span class=\"k\">call</span><span class=\"w\"> </span><span class=\"n\">dgemm</span><span class=\"p\">(</span><span class=\"s1\">'N'</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s1\">'T'</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"k\">call</span><span class=\"w\"> </span><span class=\"n\">dposv</span><span class=\"p\">(</span><span class=\"n\">U</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">INFO</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"k\">RETURN</span><span class=\"w\">\n</span><span class=\"k\">END</span></code></pre>\n</figure>\n\n<p>This solution first uses <code class=\"language-plaintext highlighter-rouge\">GEMM</code> to multiply \\(4X X^{T} + 2 Z\\). It then uses <code class=\"language-plaintext highlighter-rouge\">POSV</code> to perform the solve \\((4X X^{T} + 2Z)^{-1} X\\).  The <code class=\"language-plaintext highlighter-rouge\">POSV</code> routine solves systems of the form \\(A^{-1}B\\) where \\(A\\) is symmetric positive definite.  Internally we used a logical programming framework to infer that \\(4X X^{T} + 2Z\\) is symmetric positive definite given the original mathematical assumptions.</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">assumptions</span> <span class=\"o\">=</span> <span class=\"n\">Q</span><span class=\"p\">.</span><span class=\"n\">invertible</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">)</span> <span class=\"o\">&amp;</span> <span class=\"n\">Q</span><span class=\"p\">.</span><span class=\"n\">positive_definite</span><span class=\"p\">(</span><span class=\"n\">Z</span><span class=\"p\">)</span> <span class=\"o\">&amp;</span> <span class=\"n\">Q</span><span class=\"p\">.</span><span class=\"n\">symmetric</span><span class=\"p\">(</span><span class=\"n\">Z</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">expr</span> <span class=\"o\">=</span> <span class=\"mi\">4</span><span class=\"o\">*</span><span class=\"n\">X</span><span class=\"o\">*</span><span class=\"n\">X</span><span class=\"p\">.</span><span class=\"n\">T</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">Z</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">ask</span><span class=\"p\">(</span><span class=\"n\">Q</span><span class=\"p\">.</span><span class=\"n\">symmetric</span><span class=\"p\">(</span><span class=\"n\">expr</span><span class=\"p\">)</span> <span class=\"o\">&amp;</span> <span class=\"n\">Q</span><span class=\"p\">.</span><span class=\"n\">positive_definite</span><span class=\"p\">(</span><span class=\"n\">expr</span><span class=\"p\">),</span> <span class=\"n\">assumptions</span><span class=\"p\">)</span>\n<span class=\"bp\">True</span></code></pre>\n</figure>\n\n<p>This computation is in-place. <code class=\"language-plaintext highlighter-rouge\">GEMM</code> stores its result in the argument <code class=\"language-plaintext highlighter-rouge\">Z</code>. <code class=\"language-plaintext highlighter-rouge\">POSV</code> uses <code class=\"language-plaintext highlighter-rouge\">Z</code> and stores the output in <code class=\"language-plaintext highlighter-rouge\">X</code>. Note that both <code class=\"language-plaintext highlighter-rouge\">X</code> and <code class=\"language-plaintext highlighter-rouge\">Z</code> have been declared with <code class=\"language-plaintext highlighter-rouge\">inout</code> intents in the Fortran code.</p>\n\n<p>This Fortran code is independent of Python or SymPy and can be used in any project. However, if we prefer the Python environment we can bring it back into the Python session with F2PY.</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&gt;&gt;&gt; f = computations[0].build(str, assumptions)\n&gt;&gt;&gt; f?\nf - Function signature:\n  info = f(x,z,[n])\nRequired arguments:\n  x : in/output rank-2 array('d') with bounds (n,n)\n  z : in/output rank-2 array('d') with bounds (n,n)\nOptional arguments:\n  n := shape(x,0) input int\nReturn objects:\n  info : int\n</code></pre></div></div>\n\n<p>This function accepts numpy arrays and so integrates well into the Python scientific computing stack.</p>\n\n<h2 id=\"multiple-matches\">Multiple Matches</h2>\n\n<p>There were two computations. What was the other?</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">computations</span><span class=\"p\">)</span>\n<span class=\"mi\">2</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">print</span> <span class=\"n\">computations</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">].</span><span class=\"n\">print_Fortran</span><span class=\"p\">(</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">assumptions</span><span class=\"p\">)</span></code></pre>\n</figure>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-fortran\" data-lang=\"fortran\"><span class=\"k\">subroutine</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">INFO</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">IPIV</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"kt\">real</span><span class=\"o\">*</span><span class=\"mi\">8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">intent</span><span class=\"p\">(</span><span class=\"k\">inout</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">::</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"kt\">real</span><span class=\"o\">*</span><span class=\"mi\">8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">intent</span><span class=\"p\">(</span><span class=\"k\">inout</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">::</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"kt\">integer</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">intent</span><span class=\"p\">(</span><span class=\"k\">out</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">::</span><span class=\"w\"> </span><span class=\"n\">INFO</span><span class=\"w\">\n</span><span class=\"kt\">integer</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">intent</span><span class=\"p\">(</span><span class=\"k\">out</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">::</span><span class=\"w\"> </span><span class=\"n\">IPIV</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"kt\">integer</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">intent</span><span class=\"p\">(</span><span class=\"k\">in</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">::</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\">\n\n</span><span class=\"k\">call</span><span class=\"w\"> </span><span class=\"n\">dgemm</span><span class=\"p\">(</span><span class=\"s1\">'N'</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s1\">'T'</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"k\">call</span><span class=\"w\"> </span><span class=\"n\">dgesv</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">IPIV</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">INFO</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"k\">RETURN</span><span class=\"w\">\n</span><span class=\"k\">END</span></code></pre>\n</figure>\n\n<p>This solution uses the <code class=\"language-plaintext highlighter-rouge\">GESV</code> routine for general matrices in place of the specialized <code class=\"language-plaintext highlighter-rouge\">POSV</code> for symmetric positive definite matrices.  Which is best?  In this case <code class=\"language-plaintext highlighter-rouge\">POSV</code> is likely faster because it is able to use faster algorithms due to the symmetric positive definite assumption.  After looking at both possibilities we choose it.</p>\n\n<p>For large matrix expressions the number of possible computations may stop us from inspecting all possible solutions.  How can we ensure that the best solution is in the first few?</p>\n\n<h2 id=\"code-separation\">Code Separation</h2>\n\n<p>The definition of BLAS/LAPACK is separated from the pattern matching code and the branching control code. This allows me (or other people) to develop one without thinking about the other. It also allows for a declarative definition of BLAS and LAPACK routines. If anyone is interested I could use more routines than just the six used in this example.</p>\n\n<p>This project requires the technology from the previous four posts. While all of that technology (strategies, unification, code generation) is necessary to this project none of it is specific to this project. All of the pieces are general, composable, and applicable to other ends. I hope that others are able to find some use for them.</p>\n\n<h2 id=\"caveats\">Caveats</h2>\n\n<p>This code is still experimental. It is not yet merged into the SymPy master branch. The interface may change. Results are promising but there are stil big pieces missing before its ready for public use.</p>\n\n<h2 id=\"references\">References</h2>\n\n<ol>\n  <li><a href=\"http://cens.ioc.ee/projects/f2py2e/\">F2PY</a></li>\n  <li>D. Fabregat-Traver, P. Bientinesi, <a href=\"http://www.aices.rwth-aachen.de:8080/aices/preprint/documents/AICES-2012-01-02.pdf\"><em>A Domain-Specific Comiler for Linear Algebra Operations</em></a>, arXiv preprint arXiv:1205.5975 (2012).</li>\n  <li><a href=\"https://mrocklin.github.io/blog/scripts/2012-11-10-GeneratingBLAS-PreliminaryResults.py\">Example code</a> from this post</li>\n  <li><a href=\"https://github.com/mrocklin/sympy/tree/blas\">My development branch of SymPy</a></li>\n</ol>"
}