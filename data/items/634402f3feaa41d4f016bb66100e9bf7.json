{
  "title": "Memoization Using C++11",
  "link": "http://artem.sobolev.name/posts/2013-03-29-cpp-11-memoization.html",
  "description": "<p>Recently I’ve read an article <a href=\"http://john-ahlgren.blogspot.ru/2013/03/efficient-memoization-using-partial.html\" title=\"John Ahlgren: Efficient Memoization using Partial Function Application\">Efficient Memoization using Partial Function Application</a>. Author explains function memoization using partial application. When I was reading the article, I thought “Hmmm, can I come up with a more general solution?” And as suggested in comments, one can use variadic templates to achieve it. So here is my version.</p>\n<!--more-->\n<p>First let’s do it in a more object-oriented way: we define a template class <code>Memoizator</code> with 2 parameters: a return value type and a list of argument’s types. Also we incapsulate a lookup map and will use C++11’s <a href=\"http://en.cppreference.com/w/cpp/utility/tuple\" title=\"std::tuple - cppreference.com\">std::tuple</a> to represent an arguments set.</p>\nThe code is as follows:\n<script src=\"https://gist.github.com/artsobolev/5270779.js\"></script>\n<p>Good, but what about computing n-th Fibonacci number using memoization? It’s not possible with a current version of <code>Memoizator</code> since it uses a separate map for each instance even if function is the same. It looks inefficient to store a separate lookup map for each instance of the same function. We’ll fix it by creating a static storage for maps accessed by a function address:</p>\n<script src=\"https://gist.github.com/artsobolev/5271223.js\"></script>\n<p>Now let’s compare the memoized version against the regular one. If we compute the 42th fibonacci number using simple recursive version (with exponential time complexity), we’d get</p>\n<pre><strong>$ time ./a.out</strong> \n267914296\n\nreal    0m5.314s\nuser    0m5.220s\nsys     0m0.020s</pre>\nNow the memoized one (from the source above):\n<pre><strong>$ time ./a.out</strong> \n267914296\n\nreal    0m0.005s\nuser    0m0.004s\nsys     0m0.004s</pre>\n<p>Moreover, our memoization reduced time complexity from exponential to linear.</p>\n<p><strong>UPD</strong>: you can take a look at another implementation here: <a href=\"http://cpptruths.blogspot.ru/2012/01/general-purpose-automatic-memoization.html\" title=\"c++ truths: General-purpose Automatic Memoization for Recursive Functions in C++11\">General-purpose Automatic Memoization for Recursive Functions in C++11</a></p>",
  "pubDate": "Fri, 29 Mar 2013 00:00:00 UT",
  "guid": "http://artem.sobolev.name/posts/2013-03-29-cpp-11-memoization.html",
  "dc:creator": "Artem"
}