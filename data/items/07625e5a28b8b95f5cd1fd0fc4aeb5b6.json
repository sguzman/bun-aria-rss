{
  "title": "How to Convert Tabular Data to Trees Using Aggregation",
  "link": "https://northconcepts.com/blog/2017/10/11/convert-tabular-data-using-aggregation/",
  "comments": "https://northconcepts.com/blog/2017/10/11/convert-tabular-data-using-aggregation/#respond",
  "pubDate": "Wed, 11 Oct 2017 05:19:23 +0000",
  "dc:creator": "Dele Taylor",
  "category": [
    "Data Pipeline",
    "ETL"
  ],
  "guid": "https://northconcepts.com/blog/?p=1873",
  "description": "<p> [&#8230;]</p>\n<p>The post <a rel=\"nofollow\" href=\"https://northconcepts.com/blog/2017/10/11/convert-tabular-data-using-aggregation/\">How to Convert Tabular Data to Trees Using Aggregation</a> appeared first on <a rel=\"nofollow\" href=\"https://northconcepts.com/blog\">Data Pipeline</a>.</p>\n",
  "content:encoded": "<p><img class=\"aligncenter size-full wp-image-2036\" src=\"https://northconcepts.com/blog/wp-content/uploads/2017/10/convert-tabular-data-using-aggregation.jpg\" alt=\"How to Convert Tabular Data to Trees Using Aggregation\" width=\"710\" height=\"430\" srcset=\"https://northconcepts.com/blog/wp-content/uploads/2017/10/convert-tabular-data-using-aggregation.jpg 710w, https://northconcepts.com/blog/wp-content/uploads/2017/10/convert-tabular-data-using-aggregation-300x182.jpg 300w\" sizes=\"(max-width: 710px) 100vw, 710px\" /></p>\n<p>We recently received an email from a Java developer asking how to convert records in a table (like you get in a relational database, CSV, or Excel file) to a composite tree structure.  Normally, we&#8217;d point to one of Data Pipeline&#8217;s <a href=\"https://northconcepts.com/docs/examples/tag/xml/\">XML</a> or <a href=\"https://northconcepts.com/docs/examples/tag/json/\">JSON</a> data writers, but for good reasons those options didn&#8217;t apply here.  The developer emailing us needed the hierarchical structures in object form for use in his API calls.</p>\n<p>Since we didn&#8217;t have a general purpose, table-tree mapper, we built one.  We looked at several options, but ultimately decided to add a new operator to the <a href=\"https://northconcepts.com/docs/examples/find-the-minimum-maximum-average-sum-count/\">GroupByReader</a>.  This not only answered the immediate mapping question, but also allowed him to use the new operator with <a href=\"https://northconcepts.com/docs/user-guide/#sliding-window-aggregation\">sliding window aggregation</a> if the need ever arose.</p>\n<p>The rest of this blog will walk you through the implementation in case you ever need to add your own custom aggregate operator to Data Pipeline.</p>\n<p><span id=\"more-1873\"></span></p>\n<p>First let&#8217;s look at what this operator does.</p>\n<h2>Input CSV File</h2>\n<p>Let&#8217;s say you have the following CSV file.  It&#8217;s pretty straightforward: it has a transaction date, the account it applies to, the type of transaction, and the amount applied.</p>\n<p><a href=\"https://northconcepts.com/blog/wp-content/uploads/2017/10/how-to-convert-tabular-data-to-trees-using-aggregation-input.png\"><img class=\"aligncenter size-medium wp-image-1874\" src=\"https://northconcepts.com/blog/wp-content/uploads/2017/10/how-to-convert-tabular-data-to-trees-using-aggregation-input-300x262.png\" alt=\"Input CSV File\" width=\"300\" height=\"262\" srcset=\"https://northconcepts.com/blog/wp-content/uploads/2017/10/how-to-convert-tabular-data-to-trees-using-aggregation-input-300x262.png 300w, https://northconcepts.com/blog/wp-content/uploads/2017/10/how-to-convert-tabular-data-to-trees-using-aggregation-input.png 525w\" sizes=\"(max-width: 300px) 100vw, 300px\" /></a></p>\n<h2>Output Composite Structure</h2>\n<p>The goal is to take the input file and create a separate record for each account (123, 456, 789, and 147).  Each of the new account records will contain nested records for the different transaction types, dates, and amounts related to that account.  If the first record were converted to JSON, it would look structurally like the following.</p>\n<p><a href=\"https://northconcepts.com/blog/wp-content/uploads/2017/10/how-to-convert-tabular-data-to-trees-using-aggregation-output-json.png\"><img class=\"aligncenter size-medium wp-image-1876\" src=\"https://northconcepts.com/blog/wp-content/uploads/2017/10/how-to-convert-tabular-data-to-trees-using-aggregation-output-json-152x300.png\" alt=\"Output JSON Tree Structure\" width=\"152\" height=\"300\" srcset=\"https://northconcepts.com/blog/wp-content/uploads/2017/10/how-to-convert-tabular-data-to-trees-using-aggregation-output-json-152x300.png 152w, https://northconcepts.com/blog/wp-content/uploads/2017/10/how-to-convert-tabular-data-to-trees-using-aggregation-output-json.png 359w\" sizes=\"(max-width: 152px) 100vw, 152px\" /></a></p>\n<p>Since we&#8217;re not creating JSON, the actual Data Pipeline records will look very similar to JSON, but will contain rich types like BigDecimal and Date that JSON hasn’t traditionally supported.  Here&#8217;s the output of Recors.toString().</p>\n<p><a href=\"https://northconcepts.com/blog/wp-content/uploads/2017/10/how-to-convert-tabular-data-to-trees-using-aggregation-output.png\"><img class=\"aligncenter size-medium wp-image-1875\" src=\"https://northconcepts.com/blog/wp-content/uploads/2017/10/how-to-convert-tabular-data-to-trees-using-aggregation-output-169x300.png\" alt=\"Data Pipeline Output Record Structure\" width=\"169\" height=\"300\" srcset=\"https://northconcepts.com/blog/wp-content/uploads/2017/10/how-to-convert-tabular-data-to-trees-using-aggregation-output-169x300.png 169w, https://northconcepts.com/blog/wp-content/uploads/2017/10/how-to-convert-tabular-data-to-trees-using-aggregation-output.png 455w\" sizes=\"(max-width: 169px) 100vw, 169px\" /></a></p>\n<h2>The Data Pipeline Job</h2>\n<p>The work to read the CSV file, filter, transform, and aggregate it is seven steps.</p>\n<p>1. Read the CSV file.</p><pre class=\"crayon-plain-tag\">DataReader reader = new CSVReader(new File(\"financial-transactions.csv\"))\n\t.setFieldNamesInFirstRow(true)\n\t.setSkipEmptyRows(true);</pre><p>2. Filter credit and debit transactions.</p><pre class=\"crayon-plain-tag\">reader = new FilteringReader(reader)\n\t.add(new FieldFilter(\"Transaction Type\").valueMatches(\"Credit\", \"Debit\"));</pre><p>3. Select and arrange the output fields.</p><pre class=\"crayon-plain-tag\">reader = new TransformingReader(reader)\n\t.add(new SelectFields(\"Account\", \"Transaction Type\", \"Date\", \"Amount\"))</pre><p>4. Convert the fields from strings to their actual types</p><pre class=\"crayon-plain-tag\">.add(new BasicFieldTransformer(\"Date\").stringToDate(\"yyyy-MM-dd\"))\n\t.add(new BasicFieldTransformer(\"Amount\").stringToBigDecimal())</pre><p>5. Sort the data to ensure child branches are grouped together.</p><pre class=\"crayon-plain-tag\">reader = new SortingReader(reader).asc(\"Account\").asc(\"Transaction Type\").asc(\"Date\").asc(\"Amount\");</pre><p>6. Use the new GroupTree aggregate operator – that we&#8217;ll implement below – to build the new records grouped-by account as the root of each branch.</p><pre class=\"crayon-plain-tag\">reader = new GroupByReader(reader, \"Account\").add(new GroupTree(\"data\"));</pre><p>7. Write to the desired target.</p><pre class=\"crayon-plain-tag\">DataWriter writer = StreamWriter.newSystemOutWriter();\nJob.run(reader, writer);</pre><p>This example writes to the console (System.out), but the developer can implement his custom API calls as a new <a href=\"https://northconcepts.com/javadocs/index.html?com/northconcepts/datapipeline/core/DataWriter.html\">DataWriter</a> subclass.</p>\n<h2>Data Pipeline Aggregation API</h2>\n<p>Before we get into the GroupTree implementation, you need to understand the classes involved in aggregation and sliding windows.</p>\n<p><a href=\"https://northconcepts.com/blog/wp-content/uploads/2017/10/how-to-convert-tabular-data-to-trees-using-aggregation-api.png\"><img class=\"aligncenter size-medium wp-image-1877\" src=\"https://northconcepts.com/blog/wp-content/uploads/2017/10/how-to-convert-tabular-data-to-trees-using-aggregation-api-300x222.png\" alt=\"Data Pipeline Aggregation API\" width=\"300\" height=\"222\" srcset=\"https://northconcepts.com/blog/wp-content/uploads/2017/10/how-to-convert-tabular-data-to-trees-using-aggregation-api-300x222.png 300w, https://northconcepts.com/blog/wp-content/uploads/2017/10/how-to-convert-tabular-data-to-trees-using-aggregation-api.png 480w\" sizes=\"(max-width: 300px) 100vw, 300px\" /></a></p>\n<h3>GroupByReader</h3>\n<p>GroupByReader is the controlling class and is what we used in the example above.  GroupByReader holds a list of open windows and closed windows (while they still have data to emit).  It also holds the GroupOperations that will be applied in each window along with the window strategies.</p>\n<h3>Window Strategies</h3>\n<p>The CreateWindowStrategy classes is responsible for determining when new windows should be opened, while CloseWindowStrategy determines when open windows should be closed.  There are several built-in implementations based on time and data.  You can implement your own strategies or combine strategies together using Boolean logic.</p>\n<h3>Windows</h3>\n<p>Windows receive incoming data while they&#8217;re open and emit their results after they&#8217;re closed.  Open windows take the input records and apply GroupOperations (sum, count, etc.) to them via a GroupField instance.  Once a window is closed, the values in its GroupFields are collected into records and returned by GroupByReader.</p>\n<h3>Operators</h3>\n<p>You can think of GroupOperation as a factory that creates GroupOperationFields.  Whenever an open window determines that a new aggregate field needs to be created for a record in the output group, it calls GroupOperation.createField().  The window then calls GroupOperationField.apply(Record, Field) for each input record it sees.  Most of the operator&#8217;s logic is actually done inside each implementation of the field&#8217;s apply() method.</p>\n<h2>GroupTree Implementation</h2>\n<p>First the code.</p><pre class=\"crayon-plain-tag\">package com.northconcepts.datapipeline.group;\n\nimport com.northconcepts.datapipeline.core.ArrayValue;\nimport com.northconcepts.datapipeline.core.Field;\nimport com.northconcepts.datapipeline.core.Record;\nimport com.northconcepts.datapipeline.group.GroupOperation;\nimport com.northconcepts.datapipeline.group.GroupOperationField;\nimport com.northconcepts.datapipeline.internal.lang.Util;\n\n\npublic class GroupTree extends GroupOperation<ArrayValue> {\n    \n    public GroupTree(String targetFieldName) {\n        super(null, targetFieldName, false);\n    }\n\n    @Override\n    protected GroupOperationField<ArrayValue> createField() {\n        return new GroupOperationField<ArrayValue>(this) {\n            \n            private Record rootRecord = new Record();\n\n            @Override\n            protected void apply(Record record, Field field) {\n                Record parentDataRecord = rootRecord;\n                \n                FIELD_LOOP:\n                for (int i = 1; i < record.getFieldCount(); i++) {\n                    Field sourceField = record.getField(i);\n\n                    ArrayValue dataArray = parentDataRecord.getField(getTargetFieldName(), true).getValueAsArray(true);\n                    if (dataArray.size() > 0) {\n                        Record lastDataRecord = dataArray.getValueAsRecord(dataArray.size() - 1);\n                        Field lastDataRecordField = lastDataRecord.getField(sourceField.getName(), true);\n                        boolean sameTreeBranch = Util.equals(lastDataRecordField.getValue(), sourceField.getValue());\n                        if (sameTreeBranch) {\n                            parentDataRecord = lastDataRecord;\n                            continue FIELD_LOOP; \n                        }\n                    }\n                    \n                    Record lastDataRecord = new Record();\n                    lastDataRecord.setField(sourceField.getName(), sourceField.getValue());\n                    dataArray.addValue(lastDataRecord);\n                    parentDataRecord = lastDataRecord;\n                }\n            }\n            \n            @Override\n            protected ArrayValue getValue() {\n                return rootRecord.getField(0).getValueAsArray();\n            }\n        };\n    }\n}</pre><p></p>\n<h3>GroupTree</h3>\n<p>The new operator starts by extending the GroupOperation class and overriding its createField() factory method.  In our example, createField() will be called once for every new account and the resulting field&#8217;s apply() will be called once for every record related to that account.  The apply() method will be responsible for adding each tabular record to the appropriate place in the nested tree record that it will eventually return.  As an example, the simplest apply() method we have is in the GroupCount class and it just increments a counter.</p>\n<h3>Get Value</h3>\n<p>The created field&#8217;s getValue() method is called by closed windows whenever they are asked by GroupByReader for records.  In this case, it will return the first field in the root record as an array.</p>\n<h3>Next Release</h3>\n<p>The GroupTree operator will be available in the next release.  If you can&#8217;t wait, just use the code from this blog and get started.</p>\n<p>Happy Coding!</p>\n<p>The post <a rel=\"nofollow\" href=\"https://northconcepts.com/blog/2017/10/11/convert-tabular-data-using-aggregation/\">How to Convert Tabular Data to Trees Using Aggregation</a> appeared first on <a rel=\"nofollow\" href=\"https://northconcepts.com/blog\">Data Pipeline</a>.</p>\n",
  "wfw:commentRss": "https://northconcepts.com/blog/2017/10/11/convert-tabular-data-using-aggregation/feed/",
  "slash:comments": 0
}