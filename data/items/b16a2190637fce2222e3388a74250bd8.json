{
  "title": "Prediction intervals for Random Forests",
  "link": "http://blog.datadive.net/prediction-intervals-for-random-forests/",
  "comments": "http://blog.datadive.net/prediction-intervals-for-random-forests/#comments",
  "dc:creator": "ando",
  "pubDate": "Tue, 02 Jun 2015 13:25:41 +0000",
  "category": [
    "Confidence intervals",
    "Random forest"
  ],
  "guid": "http://blog.datadive.net/?p=2871",
  "description": "An aspect that is important but often overlooked in applied machine learning is intervals for predictions, be it confidence or prediction intervals. For classification tasks, beginning practitioners quite often conflate probability with confidence: probability of 0.5 is taken to mean &#8230; <a href=\"http://blog.datadive.net/prediction-intervals-for-random-forests/\">Continue reading <span class=\"meta-nav\">&#8594;</span></a>",
  "content:encoded": "<p>An aspect that is important but often overlooked in applied machine learning is intervals for predictions, be it confidence or prediction intervals. For classification tasks, beginning practitioners quite often conflate probability with confidence: probability of 0.5 is taken to mean that we are uncertain about the prediction, while a prediction of 1.0 means we are absolutely certain in the outcome. But there are two concepts being mixed up here. A prediction of 0.5 could mean that we have learned very little about a given instance, due to observing no or only a few data points about it. Or it could be that we have a lot of data, and the response is fundamentally uncertain, like flipping a coin.</p><p>For regression, a prediction returning a single value (typically meant to minimize the squared error) likewise does not relay any information about the underlying distribution of the data or the range of response values we might later see in the test data.  </p><p>Looking at the following plots, both the left and right plot represent similar, learned models for predicting Y from X. But while the model predictions would be similar, confidence in them would be quite different for obvious reasons: we have much less and more spread out data in the second case.</p><p><a href=\"http://blog.datadive.net/wp-content/uploads/2015/05/scatters.png\"><img loading=\"lazy\" src=\"http://blog.datadive.net/wp-content/uploads/2015/05/scatters.png\" alt=\"scatters\" width=\"720\" height=\"360\" class=\"alignnone size-full wp-image-3061\" srcset=\"http://blog.datadive.net/wp-content/uploads/2015/05/scatters.png 720w, http://blog.datadive.net/wp-content/uploads/2015/05/scatters-300x150.png 300w\" sizes=\"(max-width: 720px) 100vw, 720px\" /></a></p><p>A useful concept for quantifying the latter issue is  <strong>prediction intervals</strong>.  A prediction interval is an estimate of an interval into which the future observations will fall with a given probability. In other words, it can quantify our confidence or certainty in the prediction. Unlike confidence intervals from classical statistics, which are about a parameter of population (such as the mean), prediction intervals are about individual predictions. </p><p>For linear regression, calculating the predictions intervals is straightforward (under certain assumptions like the normal distribution of the residuals) and included in most libraries, such as R&#8217;s <a href =\" https://stat.ethz.ch/R-manual/R-patched/library/stats/html/predict.lm.html\"> predict method</a> for linear models.</p><p>But how to calculate the intervals for tree based methods such as random forests? </p>\n<h3>Quantile regression forests</h3><p>A general method for finding confidence intervals for decision tree based methods is <a href=\"http://www.jmlr.org/papers/volume7/meinshausen06a/meinshausen06a.pdf\">Quantile Regression Forests</a>.<br />\nThe idea behind quantile regression forests is simple: instead of recording the mean value of response variables in each tree leaf in the forest, record all observed responses in the leaf. The prediction can then return not just the mean of the response variables, but the full conditional distribution \\(P(Y \\leq y \\mid X = x)\\) of response values for every \\(x\\). Using the distribution, it is trivial to create prediction intervals for new instances simply by using the appropriate percentiles of the distribution. For example, the 95% prediction intervals would be the range between 2.5 and 97.5 percentiles of the distribution of the response variables in the leaves. And of course one could calculate other estimates on the distribution, such as median, standard deviation etc. Unfortunately, quantile regression forests do not enjoy too wild of a popularity. While it is available in R&#8217;s <a href=\"http://cran.r-project.org/web/packages/quantreg/index.html\">quantreg </a>packages, most machine learning packages do not seem to include the method.</p>\n<h3>Random forests as  quantile regression forests</h3><p>But here&#8217;s a nice thing: one can use a random forest as quantile regression forest simply by expanding the tree fully so that each leaf has exactly one value. (And expanding the trees fully is in fact what Breiman suggested in his original random forest paper.) Then a prediction trivially returns individual response variables from which the distribution can be built if the forest is large enough. One caveat is that expanding the tree fully can overfit: if that does happen, the intervals will be useless, just as the predictions. The nice thing is that just like accuracy and precision, the intervals can be cross-validated.</p>\n<h3>Example</h3><p>Let&#8217;s look at the well-known Boston housing dataset and try to create prediction intervals using vanilla random forest from <a href=\"http://scikit-learn.org/\">scikit-learn</a>:</p>\n<pre class=\"brush: python; collapse: false; title: ; wrap-lines: false; notranslate\">\nfrom sklearn.ensemble import RandomForestRegressor\nimport numpy as np\nfrom sklearn.datasets import load_boston\n\nboston = load_boston()\nX = boston[\"data\"]\nY = boston[\"target\"]\nsize = len(boston[\"data\"])\n</pre><p>We&#8217;ll use 400 samples for training, leaving 106 samples for test. The size of the forest should be relatively large, so let&#8217;s use 1000 trees.</p>\n<pre class=\"brush: python; collapse: false; title: ; wrap-lines: false; notranslate\">\ntrainsize = 400\nidx = range(size)\n#shuffle the data\nnp.random.shuffle(idx)\nrf = RandomForestRegressor(n_estimators=1000, min_samples_leaf=1)\nrf.fit(X[idx[:trainsize]], Y[idx[:trainsize]])\n</pre><p>We can now define a function to calculate prediction intervals for every prediction:</p>\n<pre class=\"brush: python; collapse: false; title: ; wrap-lines: false; notranslate\">\ndef pred_ints(model, X, percentile=95):\n    err_down = []\n    err_up = []\n    for x in range(len(X)):\n        preds = []\n        for pred in model.estimators_:\n            preds.append(pred.predict(X[x])[0])\n        err_down.append(np.percentile(preds, (100 - percentile) / 2. ))\n        err_up.append(np.percentile(preds, 100 - (100 - percentile) / 2.))\n    return err_down, err_up\n</pre><p>Let&#8217;s compute 90% prediction intervals and test how many observations in the test set fall into the interval.</p>\n<pre class=\"brush: python; collapse: false; title: ; wrap-lines: false; notranslate\">\nerr_down, err_up = pred_ints(rf, X[idx[trainsize:]], percentile=90)\n\ntruth = Y[idx[trainsize:]]\ncorrect = 0.\nfor i, val in enumerate(truth):\n    if err_down[i] <= val <= err_up[i]:\n        correct += 1\nprint correct/len(truth)\n</pre>\n<blockquote><p><code><br />\n0.905660377358<br />\n</code></p></blockquote><p>This is pretty close to what we expected: 90.6% of observations fell into the prediction intervals. Plotting the true values and predictions together with error bars visualizes this nicely.</p><p><a href=\"http://blog.datadive.net/wp-content/uploads/2015/05/90interval.png\"><img loading=\"lazy\" class=\"alignnone size-full wp-image-2911\" src=\"http://blog.datadive.net/wp-content/uploads/2015/05/90interval.png\" alt=\"90interval\" width=\"753\" height=\"397\" /></a></p><p>If we set prediction interval to be 50% for the same model and test data, we see 51% of predictions fall into the interval, again very close to the expected value . Plotting the error bars again, we see that they are significantly smaller:</p><p><a href=\"http://blog.datadive.net/wp-content/uploads/2015/05/50interval.png\"><img loading=\"lazy\" class=\"alignnone size-full wp-image-2901\" src=\"http://blog.datadive.net/wp-content/uploads/2015/05/50interval.png\" alt=\"50interval\" width=\"736\" height=\"395\" /></a></p><p>What can also be observed on the plot that on average, predictions that are more accurate have smaller prediction intervals since these are usually &#8220;easier&#8221; predictions to make. The correlation between absolute prediction error and prediction interval size is ~0.6 for this dataset.</p><p>And again, just as one can and should use cross-validation for estimating the accuracy of the model, one should also cross-validate the intervals to make sure that they give unbiased results on the particular dataset at hand. And just like one can do <a href=\"http://scikit-learn.org/stable/auto_examples/calibration/plot_calibration.html\">probability calibration</a>, interval calbiration can also be done.</p>\n<h2>Caveats</h2><p>There are situations when the tree is not expanded fully, such that there is more than one data point per leaf. This can happen because either<br />\na) a node is already pure, so splitting further makes no sense, or<br />\nb) the node is not pure, but the feature vector is exactly the same for all responses, so there isnâ€™t anything to do a further split on.</p><p>In case of a), we know the response and node size, so we still know the distribution perfectly and can use it for calculating the intervals. If case b) happens, we are in trouble, since we don&#8217;t know the distribution of responses in the non-expanded leaf. Luckily, the latter very rarely happens with real world datasets and is easy to check for. </p>\n<h1>Conclusions</h1><p>Utilizing prediction intervals can be very beneficial in many machine learning and data science tasks, since they can tell a lot about the underlying data that we are learning about and provide a simple way to sanity check our results. While they seem to enjoy relatively widespread use for linear models due to the ease of access with these methods, they tend to be underutilized for tree-based methods such as random forests. But actually they are relatively straightforward to use (keeping the caveats in mind) by utilizing the fact that a random forest can return a conditional distribution instead of just the conditional mean. In fact, estimating the intervals this way can be more robust than prediction intervals for linear methods, since it does not rely on the assumption of normally distributed residuals.</p>\n<div style=\"padding-top:0px;\t\npadding-right:0px;\npadding-bottom:0px;\npadding-left:0px;\nmargin-top:0px;\nmargin-right:0px;\nmargin-bottom:0px;\nmargin-left:0px;\"><a href=\"https://twitter.com/crossentropy\" class=\"twitter-follow-button\" \n\t\t\t\t\t\tdata-show-count=\"false\"\n\t\t\t\t\t\tdata-lang=\"autoLANGauto\"\n\t\t\t\t\t\tdata-width=\"250px\"\n\t\t\t\t\t\tdata-align=\"left\"\n\t\t\t\t\t\tdata-show-screen-name=\"true\"\n\t\t\t\t\t\tdata-size=\"medium\"\n\t\t\t\t\t\tdata-dnt=\"false\">\n\t\t\t\t\t\tFollow @crossentropy </a> </div>\n\t\t\t\t\t\t<script>\n\t\t\t\t\t\t!function(d,s,id) {\n\t\t\t\t\t\t  var js,fjs=d.getElementsByTagName(s)[0];\n\t\t\t\t\t\t  if(!d.getElementById(id)) {\n\t\t\t\t\t\t   js=d.createElement(s);\n\t\t\t\t\t\t   js.id=id;js.src=\"//platform.twitter.com/widgets.js\";\n\t\t\t\t\t\t   fjs.parentNode.insertBefore(js,fjs);\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t}\n\t\t\t\t\t\t(document,\"script\",\"twitter-wjs\");\n\t\t\t\t\t\t</script><div style=\"padding-top:0px;\t\npadding-right:0px;\npadding-bottom:0px;\npadding-left:0px;\nmargin-top:0px;\nmargin-right:0px;\nmargin-bottom:0px;\nmargin-left:0px;\"><a href=\"https://twitter.com/share\" class=\"twitter-share-button\" \n\t\t\t\t        data-url=\"http://blog.datadive.net/prediction-intervals-for-random-forests/\" \n\t\t\t\t        data-via=\"crossentropy\"\n\t\t\t\t\t    data-text=\"Prediction intervals for Random Forests\"\n\t\t\t\t\t    data-related=\"\"\n\t\t\t\t\t    data-count=\"horizontal\"\n\t\t\t\t\t    data-hashtags=\"\"\n\t\t\t\t\t    data-lang=\"autoLANGauto\"\n\t\t\t\t\t    data-counturl=\"\"\n\t\t\t\t\t    data-size=\"medium\"\n\t\t\t\t\t    data-dnt=\"false\"\t> Tweet </a> </div>\n\t\t                <script>\n\t\t\t\t\t    !function(d,s,id) {\n\t\t\t\t\t      var js,fjs=d.getElementsByTagName(s)[0];\n\t\t\t\t\t      if(!d.getElementById(id)) {\n\t\t\t\t\t       js=d.createElement(s);js.id=id;js.src=\"https://platform.twitter.com/widgets.js\";fjs.parentNode.insertBefore(js,fjs);\n\t\t\t\t\t      }\n\t\t\t\t\t    }\n\t\t\t\t\t   (document,\"script\",\"twitter-wjs\");\n\t\t\t\t\t    </script>",
  "wfw:commentRss": "http://blog.datadive.net/prediction-intervals-for-random-forests/feed/",
  "slash:comments": 35
}