{
  "title": "Sample pooling to reduce needed disease screening test counts",
  "link": "",
  "published": "2020-03-29T00:00:00-07:00",
  "updated": "2020-03-29T00:00:00-07:00",
  "author": {
    "name": "Jonathan Landy"
  },
  "id": "tag:efavdb.com,2020-03-29:/pooling",
  "summary": "<p>Pooling of test samples can be used to reduce the mean number of test counts\nrequired to determine who in a set of subjects carries a disease. E.g., if the\nblood samples of a set of office workers are combined and tested, and the test\ncomes back negative, then …</p>",
  "content": "<p>Pooling of test samples can be used to reduce the mean number of test counts\nrequired to determine who in a set of subjects carries a disease. E.g., if the\nblood samples of a set of office workers are combined and tested, and the test\ncomes back negative, then the full office can be ruled out as disease carriers\nusing just a single test (whereas the naive approach would require testing each\nseparately).  However, if the test comes back positive, then a refined search\nthrough the workers must be carried out to decide which have the disease and\nwhich do&nbsp;not.</p>\n<p>Here, we consider two methods for refined search when a group is flagged\npositive, and provide python code that can be used to find the optimal pooling\nstrategy.  This depends on the frequency of disease within the testing\npopulation, <span class=\"math\">\\(p\\)</span>.</p>\n<p>Impact summary of pooling&nbsp;concept: </p>\n<ul>\n<li>If <span class=\"math\">\\(p = O(1)\\)</span>, so that many people have the illness, pooling doesn&#8217;t&nbsp;help. </li>\n<li>If <span class=\"math\">\\(p = 0.1\\)</span>, perhaps typical of people being screened with symptoms, we can\n   reduce the test count needed by about <span class=\"math\">\\(\\sim 0.6\\)</span> using pooling, and the two refined\nsearch methods we consider perform similarly&nbsp;here.</li>\n<li>If <span class=\"math\">\\(p = 0.001\\)</span>, so that positive cases are rare &#8212; perhaps useful for\n   screening an office of workers expected to be healthy, then we can cut the\nmean test count by a factor of <span class=\"math\">\\(50\\)</span>, and the bisection method for refined search performs best here (details&nbsp;below).</li>\n</ul>\n<p>Code for this analysis can be found at our github (<a href=\"https://github.com/EFavDB/pooling/blob/master/pooling_samples.ipynb\">link</a>).</p>\n<h4><strong><span class=\"caps\">COVID19</span> background, strategies considered&nbsp;here</strong></h4>\n<p>The idea of pooling is an old one, but I happened on the idea when an article\nwas posted about it to the statistics subreddit this past week (<a\nhref=\"https://www.reddit.com/r/statistics/comments/fl3dlw/q_if_you_could_test_batches_of_64_samples_for/\">link</a>).\nThere the question was posed what the optimal pooling count would be,\nmotivating this&nbsp;post.</p>\n<p>I imagine pooling may be useful for <span class=\"caps\">COVID19</span> under two conditions:  (1)\nsituations where testing capactity is the limiting factor (as opposed to speed\nof diagnosis, say), and (2) Situations where a great many people need to be\nscreened and it is unlikely that any of them have it &#8212; e.g., daily tests\nwithin a large office&nbsp;buiding.</p>\n<p>We consider two pooling methods here:  (1) A simple method where if the test\non the group comes back positive, we immediately screen each individual.  (2) A\nbisection method, where if a group comes back positive, we split it in two and\nrun the test on each subgroup, repeating from there recursively.  E.g., in a\ngroup of size 16 with one positive, the recursive approach generates the following\nset of test subsets (see notebook on our github linked above for&nbsp;code)</p>\n<div class=\"highlight\"><pre><span></span><span class=\"n\">seq</span> <span class=\"o\">=</span> <span class=\"n\">generate_random_seq</span><span class=\"p\">()</span>\n<span class=\"n\">test_counts_needed</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">test_count</span><span class=\"p\">(</span><span class=\"n\">seq</span><span class=\"p\">))</span>\n<span class=\"n\">total</span> <span class=\"n\">size</span> <span class=\"o\">=</span> <span class=\"mi\">16</span>\n<span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n<span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]</span>\n</pre></div>\n\n\n<p>Here, the 13th individual had the disease, and the bisection method required a\ntotal of 9 tests (one for each row above) to determine the full set of diagnoses.  Note that\n9 is less than 16, the number needed when we screen everyone from the&nbsp;start.</p>\n<p>Our purpose is to provide code and equations that can be used to select from these two\nmethods should anyone want to apply this idea.  Caveat:  We currently ignore\nany possibility of error in the tests.  This may make the approach invalid for\nsome or all of the current covid19 tests.  Error rates should be studied next\nwhere&nbsp;appropriate.</p>\n<h4><strong>Model and&nbsp;results</strong></h4>\n<p>We posit that we have a pool&nbsp;of\n</p>\n<div class=\"math\">\\begin{eqnarray}\nN = 2^{\\mathbb{K}} \\tag{1} \\label{count_pop}\n\\end{eqnarray}</div>\n<p> \npeople to be tested.  In the first round, we pool all their samples and test the\ngroup.  If the group comes back positive, we then run one of the refined methods to\nfigure out which people exactly have the illness.  Each person is supposed to have a probability <span class=\"math\">\\(p\\)</span> of having the disease.\nBelow, we ask how to set <span class=\"math\">\\(\\mathbb{K}\\)</span> &#8212; which determines the pooling size &#8212;\nso as to minimize the mean number of tests needed divided by <span class=\"math\">\\(N\\)</span>, which can be\nconsidered the pooling reduction&nbsp;factor.</p>\n<p>The mean number of tests needed from the simple strategy&nbsp;is\n</p>\n<div class=\"math\">\\begin{eqnarray}\\tag{2} \\label{simple_result}\n\\overline{N}_{simple} = (1 - p)^N\\times 1 + \\left [1 - (1-p)^N \\right] \\times (1 + N)\n\\end{eqnarray}</div>\n<p>\nThe mean number needed in the bisection strategy&nbsp;is\n</p>\n<div class=\"math\">\\begin{eqnarray} \\tag{3} \\label{bisection_result}\n\\overline{N}_{bisection} = 1 +  2 \\sum_{k=0}^{\\mathbb{K}} 2^k \\left (1 - (1 -p)^{2^{\\mathbb{K}-k}} \\right)\n\\end{eqnarray}</div>\n<p>\nThe proof of (\\ref{simple_result}) is straightforward and we give an argument for\n(\\ref{bisection_result}) in an appendix. A cell of our notebook checks this\nand confirms its&nbsp;accuracy.</p>\n<p>Using the above results, our code produces plots of the mean number of tests\nneeded to screen a population vs <span class=\"math\">\\(\\mathbb{K}\\)</span>.  This then finds the optimal\nnumber for each type.  The plots below give the results for the three <span class=\"math\">\\(p\\)</span> values\nnoted in the&nbsp;abstract.</p>\n<ul>\n<li>\n<p>Case 1: <span class=\"math\">\\(p = 0.5\\)</span>, large fraction of disease carriers.  Main result: The\npooling strategies both cause the mean number of tests to be larger than if\nwe just screened each individual from the start (seen here because the y-axis\nvalues are always bigger than 1).  The approach is not useful here.\n<img alt=\"![parameter study]({static}/images/pooling_05.png)\" src=\"https://efavdb.com/images/pooling_05.png\"></p>\n</li>\n<li>\n<p>Case 2: <span class=\"math\">\\(p = 0.1\\)</span>, modest fraction of disease carriers.  Main result: The two\nmethods both give comparable benefits.  It is optimal to pool using\n<span class=\"math\">\\(\\mathbb{K}=2\\)</span>, which gives groups of <span class=\"math\">\\(N = 4\\)</span> patients. This cuts the number of\nneeded tests by a factor of <span class=\"math\">\\(0.6\\)</span>.\n<img alt=\"![parameter study]({static}/images/pooling_01.png)\" src=\"https://efavdb.com/images/pooling_01.png\"></p>\n</li>\n<li>\n<p>Case 3: <span class=\"math\">\\(p = 0.001\\)</span>, small fraction of disease carriers.  Main result:\nBisection wins, the optimal <span class=\"math\">\\(\\mathbb{K} = 9\\)</span> here, which gives a pooling\ngroup of size <span class=\"math\">\\(512\\)</span>.  We cut the test count needed by a factor of <span class=\"math\">\\(50\\)</span>.  Note:\nWe also show here a histogram showing the number of tests needed when we run a\nsimulated system like this.  We see that we often only need one test, and there\nis another peak around <span class=\"math\">\\(20\\)</span> tests, with a long tail after that. \n<img alt=\"![parameter study]({static}/images/pooling_01.png)\" src=\"https://efavdb.com/images/pooling_0001.png\">\n<img alt=\"![parameter study]({static}/images/pooling_hist.png)\" src=\"https://efavdb.com/images/pooling_hist.png\"></p>\n</li>\n</ul>\n<p>The code to generate the optimal <span class=\"math\">\\(\\mathbb{K}\\)</span> plots above is given below.  This\ncan be used to generate generalized plots like those above for any <span class=\"math\">\\(p\\)</span>. The\nhistogram plot is contained in our github repo, linked in our abstract.  Our\nappendix&nbsp;follows.</p>\n<div class=\"highlight\"><pre><span></span><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"o\">%</span><span class=\"n\">pylab</span> <span class=\"n\">inline</span>\n\n<span class=\"n\">K</span> <span class=\"o\">=</span> <span class=\"mi\">5</span>\n<span class=\"n\">P_POSITIVE</span> <span class=\"o\">=</span> <span class=\"mf\">0.05</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">theory_bisection</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"o\">=</span><span class=\"n\">P_POSITIVE</span><span class=\"p\">,</span> <span class=\"n\">K</span><span class=\"o\">=</span><span class=\"n\">K</span><span class=\"p\">):</span>\n    <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"mi\">1</span> <span class=\"o\">+</span> <span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sum</span><span class=\"p\">([</span><span class=\"mi\">2</span> <span class=\"o\">**</span> <span class=\"n\">k</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">-</span> <span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">-</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"o\">**</span> <span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"o\">**</span> <span class=\"p\">(</span><span class=\"n\">K</span> <span class=\"o\">-</span> <span class=\"n\">k</span><span class=\"p\">)))</span> <span class=\"k\">for</span> <span class=\"n\">k</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">K</span><span class=\"p\">)]</span> <span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">count</span> <span class=\"o\">/</span> <span class=\"mi\">2</span> <span class=\"o\">**</span> <span class=\"n\">K</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">theory_simple</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"o\">=</span><span class=\"n\">P_POSITIVE</span><span class=\"p\">,</span> <span class=\"n\">K</span><span class=\"o\">=</span><span class=\"n\">K</span><span class=\"p\">):</span>\n    <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"mi\">2</span> <span class=\"o\">**</span> <span class=\"n\">K</span>\n    <span class=\"n\">p0</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">-</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"o\">**</span> <span class=\"n\">n</span>\n    <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"mi\">1</span> <span class=\"o\">*</span> <span class=\"n\">p0</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">+</span> <span class=\"n\">n</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">-</span> <span class=\"n\">p0</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">count</span> <span class=\"o\">/</span> <span class=\"n\">n</span>\n\n<span class=\"nb\">print</span> <span class=\"s1\">&#39;Bisection: fraction of full testing: </span><span class=\"si\">%2.2f</span><span class=\"s1\">&#39;</span> <span class=\"o\">%</span> <span class=\"p\">(</span><span class=\"n\">theory_bisection</span><span class=\"p\">())</span>\n<span class=\"nb\">print</span> <span class=\"s1\">&#39;Simple: fraction of full testing: </span><span class=\"si\">%2.2f</span><span class=\"s1\">&#39;</span> <span class=\"o\">%</span> <span class=\"p\">(</span><span class=\"n\">theory_simple</span><span class=\"p\">())</span>\n\n<span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"mf\">0.1</span>\n<span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">theory_bisection</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">k</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">15</span><span class=\"p\">)]</span>\n<span class=\"n\">min_index</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">argmin</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">)</span>\n<span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"s1\">&#39;o--&#39;</span><span class=\"p\">,</span> <span class=\"n\">label</span><span class=\"o\">=</span><span class=\"s1\">&#39;bisection (min = </span><span class=\"si\">%2.2f</span><span class=\"s1\">)&#39;</span><span class=\"o\">%</span><span class=\"n\">data</span><span class=\"p\">[</span><span class=\"n\">min_index</span><span class=\"p\">],</span> <span class=\"n\">alpha</span><span class=\"o\">=</span><span class=\"mf\">0.5</span><span class=\"p\">)</span>\n<span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">min_index</span><span class=\"p\">,</span> <span class=\"n\">data</span><span class=\"p\">[</span><span class=\"n\">min_index</span><span class=\"p\">],</span> <span class=\"s1\">&#39;ro&#39;</span><span class=\"p\">,</span><span class=\"n\">alpha</span><span class=\"o\">=</span><span class=\"mf\">0.5</span><span class=\"p\">)</span>\n\n<span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">theory_simple</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">k</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">15</span><span class=\"p\">)]</span>\n<span class=\"n\">min_index</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">argmin</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">)</span>\n<span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"s1\">&#39;o--&#39;</span><span class=\"p\">,</span> <span class=\"n\">label</span><span class=\"o\">=</span><span class=\"s1\">&#39;simple (min = </span><span class=\"si\">%2.2f</span><span class=\"s1\">)&#39;</span><span class=\"o\">%</span><span class=\"n\">data</span><span class=\"p\">[</span><span class=\"n\">min_index</span><span class=\"p\">],</span><span class=\"n\">alpha</span><span class=\"o\">=</span><span class=\"mf\">0.5</span><span class=\"p\">)</span>\n<span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">min_index</span><span class=\"p\">,</span> <span class=\"n\">data</span><span class=\"p\">[</span><span class=\"n\">min_index</span><span class=\"p\">],</span> <span class=\"s1\">&#39;go&#39;</span><span class=\"p\">,</span><span class=\"n\">alpha</span><span class=\"o\">=</span><span class=\"mf\">0.5</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">legend</span><span class=\"p\">()</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">title</span><span class=\"p\">(</span><span class=\"s1\">&#39;Test count reduction vs log_2 pooling size, p = </span><span class=\"si\">%0.3f</span><span class=\"s1\">&#39;</span> <span class=\"o\">%</span><span class=\"n\">p</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">xlabel</span><span class=\"p\">(</span><span class=\"s1\">&#39;log_2 pooling size&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">ylabel</span><span class=\"p\">(</span><span class=\"s1\">&#39;mean tests / pooling size&#39;</span><span class=\"p\">)</span>\n</pre></div>\n\n\n<h4><strong>Appendix: Derivation of&nbsp;(\\ref{bisection_result})</strong></h4>\n<p>Consider a binary tree with the root node being the initial test. Each node\nhas two children that correspond to the tests of the two subgroups for a given\ntest.  We must test these if the parent is positive.  Level <span class=\"math\">\\(0\\)</span> is the initial\ntest and <span class=\"math\">\\(k\\)</span> rows down we call the level <span class=\"math\">\\(k\\)</span> of tests.  There are total of <span class=\"math\">\\(2^k\\)</span>\nposible tests to run at this level, and there are a total of <span class=\"math\">\\(\\mathbb{K}\\)</span>&nbsp;levels.</p>\n<p>The number of tests that need to be run at level <span class=\"math\">\\(k\\)</span> is set by the number of\npositive tests at level <span class=\"math\">\\(k-1\\)</span>.  We&nbsp;have\n</p>\n<div class=\"math\">\\begin{eqnarray}\n\\text{Number of tests} = 1 + \\sum_{k=0}^{\\mathbb{K} - 1} \\text{number positive level k}\n\\end{eqnarray}</div>\n<p>\nAveraging this equation&nbsp;gives\n</p>\n<div class=\"math\">\\begin{eqnarray}\n\\overline{\\text{Number of tests}} &amp;=&amp; 1 + \\sum_{k=0}^{\\mathbb{K} - 1} 2^k \\times prob(\\text{test at level k positive}) \\\\\n&amp;=&amp; 1 +  \\sum_{k=0}^{\\mathbb{K} - 1} 2^k \\times [ 1- (1 - p)^{2^{\\mathbb{K} - k}}]. \n\\end{eqnarray}</div>\n<p>\nThe inner factor here is the probability that a given test of the size being\nconsidered comes back positive &#8212; this has <span class=\"math\">\\(N / 2^k = 2^{\\mathbb{K} - k}\\)</span> people\nin it.  This is the result shown above in&nbsp;(\\ref{bisection_result}).</p>\n<script type=\"text/javascript\">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {\n    var align = \"center\",\n        indent = \"0em\",\n        linebreak = \"false\";\n\n    if (false) {\n        align = (screen.width < 768) ? \"left\" : align;\n        indent = (screen.width < 768) ? \"0em\" : indent;\n        linebreak = (screen.width < 768) ? 'true' : linebreak;\n    }\n\n    var mathjaxscript = document.createElement('script');\n    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';\n    mathjaxscript.type = 'text/javascript';\n    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';\n\n    var configscript = document.createElement('script');\n    configscript.type = 'text/x-mathjax-config';\n    configscript[(window.opera ? \"innerHTML\" : \"text\")] =\n        \"MathJax.Hub.Config({\" +\n        \"    config: ['MMLorHTML.js'],\" +\n        \"    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } },\" +\n        \"    jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" +\n        \"    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" +\n        \"    displayAlign: '\"+ align +\"',\" +\n        \"    displayIndent: '\"+ indent +\"',\" +\n        \"    showMathMenu: true,\" +\n        \"    messageStyle: 'normal',\" +\n        \"    tex2jax: { \" +\n        \"        inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" +\n        \"        displayMath: [ ['$$','$$'] ],\" +\n        \"        processEscapes: true,\" +\n        \"        preview: 'TeX',\" +\n        \"    }, \" +\n        \"    'HTML-CSS': { \" +\n        \"        availableFonts: ['STIX', 'TeX'],\" +\n        \"        preferredFont: 'STIX',\" +\n        \"        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" +\n        \"        linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" +\n        \"    }, \" +\n        \"}); \" +\n        \"if ('default' !== 'default') {\" +\n            \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" +\n                \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" +\n                \"VARIANT['normal'].fonts.unshift('MathJax_default');\" +\n                \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" +\n                \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" +\n                \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" +\n            \"});\" +\n            \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" +\n                \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" +\n                \"VARIANT['normal'].fonts.unshift('MathJax_default');\" +\n                \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" +\n                \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" +\n                \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" +\n            \"});\" +\n        \"}\";\n\n    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);\n    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);\n}\n</script>",
  "category": ""
}