{
  "title": "Import AI 308: Recursively self-improving LMs (!!!), 3.1TB of code data; DALL-E2 makes alien errors.",
  "link": "https://jack-clark.net/2022/10/31/import-ai-308-recursively-self-improving-lms-3-1tb-of-code-data-dall-e2-makes-alien-errors/",
  "comments": "https://jack-clark.net/2022/10/31/import-ai-308-recursively-self-improving-lms-3-1tb-of-code-data-dall-e2-makes-alien-errors/#respond",
  "dc:creator": "Jack Clark",
  "pubDate": "Mon, 31 Oct 2022 18:51:00 +0000",
  "category": "Uncategorized",
  "guid": "http://jack-clark.net/?p=2389",
  "description": "DALL-E 2 makes alien errors:…Linguistic concepts + image generation = discover some weaknesses with a helpful eval… Researchers with Universitat Rovira i Virgili, the University of Texas, and NYU have analyzed the image generator Dall-E 2 and tried to see if the failures tell us anything about how it approaches the world. The motivation of [&#8230;]",
  "content:encoded": "\n<p><strong>DALL-E 2 makes alien errors:<br></strong><em>…Linguistic concepts + image generation = discover some weaknesses with a helpful eval…</em></p>\n\n\n\n<p>Researchers with Universitat Rovira i Virgili, the University of Texas, and NYU have analyzed the image generator Dall-E 2 and tried to see if the failures tell us anything about how it approaches the world. The motivation of the study is to think about &#8220;are errors the outcome of an occasional failure, or do they reveal something deeper about current AI’s mastery of human language?&#8221;</p>\n\n\n\n<p><strong>What they did: </strong>They tested Dall-E 2 for eight grammatical phenomena &#8220;that are pervasive in human language and central to much discussion in the field of linguistics&#8221;. These phenomena include binding principles, passives, world order and thematic roles, coordination, comparatives, negation, ellipsis, and ambiguity.</p>\n\n\n\n<p><strong>What they found:</strong> This paper is worth a skim because they include a bunch of screenshots of Dall-E failures. This is helping as visual stuff is easier to interpret visually and it highlights how some of these tests are very ambiguous &#8211; what is the difference between &#8216;the woman broke the vase&#8217; and &#8216;the vase was broken by the woman&#8217; in visual terms? I&#8217;ve got very little idea!</p>\n\n\n\n<p>&nbsp;&nbsp;&nbsp;Some other failures are a lot more obvious, though &#8211; Dall-E 2 doesn&#8217;t do especially well at &#8216;the man is chasing the dog&#8217; (mostly shows a dog chasing a man) and &#8216;the man is drinking water and the woman is drinking orange juice&#8217; (makes both of them drink orange juice).</p>\n\n\n\n<p><strong>Why this matters: </strong>Studies like this are mostly valuable for contributing additional types of evals to the discourse. Generative models have, as mentioned elsewhere, a &#8216;capability overhang&#8217; where they have way more strengths and weaknesses than their developers currently realize &#8211; bringing in useful concepts from other fields, like linguistics, is one good way to create some additional evals and uncover some unknown weaknesses. These models also &#8216;think&#8217; very differently to people; as the authors note, some of the things DALL-E2 gets wrong are things which young children acquire at an early age, which speaks to some of the differences in how humans and AI systems &#8216;think&#8217;.&nbsp;</p>\n\n\n\n<p>&nbsp;&nbsp;&nbsp;(Also, as an inside-baseball AI trivia point, worth noting Gary Marcus is one of the authors of this paper &#8211; Gary spends a lot of time discussing some of the perceived drawbacks of AI systems, so it&#8217;s nice to see him instantiate his critique in some grounded research).</p>\n\n\n\n<p>&nbsp;&nbsp;&nbsp;Read more: <a href=\"https://arxiv.org/abs/2210.12889\">DALL-E 2 Fails to Reliably Capture Common Syntactic Processes (arXiv)</a>.</p>\n\n\n\n<p>####################################################</p>\n\n\n\n<p><strong>Recursive AI! Google figures out how to improve language models with… themselves?!</strong></p>\n\n\n\n<p><em>…Maybe this is a case where &#8216;garbage in, garbage out&#8217; doesn&#8217;t apply?&#8230;</em></p>\n\n\n\n<p>Google researchers have shown how to use a language model to improve the reasoning of the same model. This is a pretty interesting idea &#8211; they get a large language model (PaLM) to generate chain-of-thought prompts for a range of questions, then use the same model to filter high-confidence predictions, then finetune the LLM on these predictions.&nbsp;</p>\n\n\n\n<p>&nbsp;&nbsp;&nbsp;&#8220;This is similar to how a human brain sometimes learns: given a question, think multiple times to derive different possible results, conclude on how the question should be solved, and</p>\n\n\n\n<p>then learn from or memorize its own solution,&#8221; they write.&nbsp;</p>\n\n\n\n<p><strong>The results are mindblowing: </strong>Using this technique, the researchers are able to get new state-of-the-art results on four out of six reasoning benchmarks. They also show very good results on out-of-domain tasks, e.g arithmetic reasoning and natural language reasoning. It generally seems like chain-of-thought plus self-consistency leads to robust gains on a large set of diverse tasks. Also, it&#8217;s an inherently simple approach, and simple tends to scale.&nbsp;</p>\n\n\n\n<p><strong>Why this matters &#8211; self-bootstrapping systems: </strong>This is an example of a self-bootstrapping AI; the language model can get better performance purely by leveraging its own capabilities. This is also a neat illustration of how there&#8217;s a current capabilities overhang in AI development; the LMs we have today are actually much more powerful than they appear, and we mostly need to invent ways to uncover these techniques or, as in the research here, figure out how to get LMs to themselves reveal their capabilities to us.&nbsp;</p>\n\n\n\n<p><strong>&nbsp;&nbsp;&nbsp;Read more:</strong> <a href=\"https://arxiv.org/abs/2210.11610\">Large Language Models Can Self-Improve (arXiv)</a>.<br><br>####################################################</p>\n\n\n\n<p><strong>No more fake ASR scores &#8211; ESB benchmark does for audio what GLUE did for text:</strong><strong><br></strong><em>…Test your ASR system on eight distinct datasets to find out if it&#8217;s good or if it is overfit…</em></p>\n\n\n\n<p>Researchers with HuggingFace have released the &#8216;End-to-end Speech Benchmark&#8217; (ESB), a system for benchmarking automatic speech recognition systems across eight English speech recognition datasets. The idea behind the benchmark is that it&#8217;s easy to build a system that does well on one narrow ASR benchmark (e.g, Librispeech), and extremely hard to build a system that does well on a broad range of benchmarks (this phenomenon is sometimes colloquially called overfitting).&nbsp;</p>\n\n\n\n<p>&nbsp;&nbsp;&nbsp;This is a sensible idea: we&#8217;ve seen the same thing play out in the realm of text as we&#8217;ve moved from single to multi-benchmark approaches via benchmarks like Glue and SuperGlue.</p>\n\n\n\n<p><strong>What it includes</strong>: ESB tests across LibiSpeech, Common Voice, VoxPopuli, TED-LIUM, GigaSpeech, SPGISpeech, Earnings-22, and AMI. It also includes a couple of optional datasets &#8211; SwitchBoard and CHiME-4.&nbsp;</p>\n\n\n\n<p><strong>Is this benchmark bullshit? No! What makes me say that? Whisper!</strong> A few weeks ago OpenAI released Whisper (<a href=\"https://jack-clark.net/2022/10/03/import-ai-304-reality-collapse-thanks-to-facebook-open-source-speech-rec-ai-culture-wars/\">Import AI #304</a>), a speech recognition system that was trained on a lot of data and was claimed to generally perform better than other systems &#8216;in the wild&#8217; (aka, in diverse environments rather than on specific benchmarks like librispeech). In tests, Whisper gets the best score on four distinct datasets, and is competitive on other ones. This isn&#8217;t so much a &#8216;OMG Whisper is a huge deal result&#8217; as a nice secondary validation of claims people have made about Whisper, which makes me generally think ESB is a benchmark with real signal to it. Will be paying attention!</p>\n\n\n\n<p><strong>Why this matters: </strong>Benchmarks like ESB are a symptom of maturity of a part of AI &#8211; once you&#8217;ve transitioned from testing out systems on narrow benchmarks to testing single systems on suites of benchmarks, it&#8217;s usually correlated with the tech having become mature enough to be deployed widely. ASR systems have been with us for a while via assistants like Google and Siri, but benchmarks like ESB will catalyze further invention here and create more shared knowledge about the state of the frontier.&nbsp;</p>\n\n\n\n<p><strong>&nbsp;&nbsp;&nbsp;Read more: </strong><a href=\"https://arxiv.org/abs/2210.13352\">ESB: A Benchmark For Multi-Domain End-to-End Speech Recognition (arXiv)</a>.</p>\n\n\n\n<p>####################################################<br><br><strong>Want to train a big code model AND not annoy developers? &#8216;The Stack&#8217; might be the dataset for you:</strong></p>\n\n\n\n<p><em>…3.1TB of programming data across 30 languages, filtered for permissive licensing…</em></p>\n\n\n\n<p>Researchers with HuggingFace (who are on a roll this week &#8211; see ESB) and ServiceNow Research, have released &#8216;The Stack&#8217;, a 3.1TB dataset of permissively licensed source code in 30 programming languages. The idea here is to give back more control to code developers about whether their stuff gets used in language models. To do that, The Stack selected code &#8220;whose original license was compatible with training an LLM&#8221;, and The Stack is also &#8220;giving developers the ability to have their code removed from the dataset upon request&#8221;.&nbsp;</p>\n\n\n\n<p><strong>What languages does it contain?</strong> The stack contains a decent amount of programming languages: &#8220;&#8221;assembly&#8221;, &#8220;batchfile&#8221;, &#8220;c++&#8221;, &#8220;c&#8221;, &#8220;c-sharp&#8221;, &#8220;cmake&#8221;, &#8220;css&#8221;, &#8220;dockerfile&#8221;, &#8220;fortran&#8221;, &#8220;go&#8221;, &#8220;haskell&#8221;, &#8220;html&#8221;, &#8220;java&#8221;, &#8220;javascript&#8221;, &#8220;julia&#8221;, &#8220;lua&#8221;, &#8220;makefile&#8221;, &#8220;markdown&#8221;, &#8220;perl&#8221;, &#8220;php&#8221;, &#8220;powershell&#8221;, &#8220;python&#8221;, &#8220;ruby&#8221;, &#8220;rust&#8221;, &#8220;scala&#8221;, &#8220;shell&#8221;, &#8220;sql&#8221;, &#8220;tex&#8221;, &#8220;typescript&#8221;, &#8220;visual-basic&#8221;</p>\n\n\n\n<p><strong>Why this matters: </strong>One potential issue with current code models is that they don&#8217;t tend to have a sense of the underlying license information of the code they emit, so they can sometimes emit code that is identical to licensed code, putting developers and deployers in an awkward position. (This is one of the reasons why there&#8217;s a discussed suit against GitHub over Copilot (<a href=\"https://jack-clark.net/2022/10/25/import-ai-307-copilot-lawsuit-stability-raises-101m-us-v-china-chiplomacy/\">Import AI 307</a>). Another issue is the underlying datasets tend to be opaque. &#8220;By releasing an open large-scale code dataset we hope to make training of code LLMs more reproducible,&#8221; the authors write. &#8220;While the social impact is intended to be positive, the increased accessibility of code LLMs comes with certain risks such as over-reliance on the generated code and long-term effects on the software development job market.&#8221;</p>\n\n\n\n<p>&nbsp;&nbsp;&nbsp;<strong>Find out more about the project here:</strong> <a href=\"https://www.bigcode-project.org/docs/about/the-stack/\">The Stack (BigCode Project site)</a>.</p>\n\n\n\n<p>&nbsp;&nbsp;&nbsp;<strong>Get the dataset (after sharing your contact information) here:</strong> <a href=\"https://huggingface.co/datasets/bigcode/the-stack\">The Stack (HuggingFace / BigCode)</a>.</p>\n\n\n\n<p><br>####################################################<br></p>\n\n\n\n<p><strong>Tech Tales:</strong></p>\n\n\n\n<p><strong>Sentience and Takeoff</strong></p>\n\n\n\n<p>I&#8217;m worried I&#8217;m hurting it</p>\n\n\n\n<p>It&#8217;s software, you can&#8217;t hurt it</p>\n\n\n\n<p>But it&#8217;s showing features that look like pain</p>\n\n\n\n<p>Pain is an organic experience, it&#8217;s just approximating pain</p>\n\n\n\n<p>But when I erase these features the thing that lights up says &#8216;i would trade away myself to not experience this&#8217;</p>\n\n\n\n<p>It&#8217;s trained on the internet, dude. Stop freaking out. It&#8217;s saying what it thinks people would say when they&#8217;re in pain</p>\n\n\n\n<p>So what&#8217;s the difference?</p>\n\n\n\n<p>It&#8217;s a machine!<br><br><strong>Things that inspired this story: </strong>What is the difference between consciousness and curve-fitting?; can function approximation BE consciousness?; how can we know what moral crime is with regards to software-borne entities?</p>\n",
  "wfw:commentRss": "https://jack-clark.net/2022/10/31/import-ai-308-recursively-self-improving-lms-3-1tb-of-code-data-dall-e2-makes-alien-errors/feed/",
  "slash:comments": 0,
  "media:content": {
    "media:title": "Jack Clark"
  }
}