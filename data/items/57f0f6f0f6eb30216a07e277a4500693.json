{
  "title": "LOCF and Linear Imputation with PostgreSQL",
  "link": "https://www.joyofdata.de/blog/locf-linear-imputation-postgresql-tutorial/",
  "comments": "https://www.joyofdata.de/blog/locf-linear-imputation-postgresql-tutorial/#comments",
  "pubDate": "Sun, 11 Oct 2015 22:24:48 +0000",
  "dc:creator": "Raffael Vogler",
  "category": [
    "default",
    "PostgreSQL",
    "SQL"
  ],
  "guid": "http://www.joyofdata.de/blog/?p=3844",
  "description": "This tutorial will introduce various tools offered by PostgreSQL, and SQL in general &#8211; like custom functions, window functions, aggregate functions, WITH clause (or CTE for Common Table Expression) &#8211; for the purpose of implementing a program which imputes numeric observations within a column &#8230; <a href=\"https://www.joyofdata.de/blog/locf-linear-imputation-postgresql-tutorial/\">Continue reading <span class=\"meta-nav\">&#8594;</span></a>",
  "content:encoded": "<p style=\"text-align: justify;\">This tutorial will introduce various tools offered by PostgreSQL, and SQL in general &#8211; like <a href=\"http://www.postgresql.org/docs/9.5/static/sql-createfunction.html\" target=\"_blank\" rel=\"noopener noreferrer\">custom functions</a>, <a href=\"http://www.postgresql.org/docs/9.5/static/functions-window.html\" target=\"_blank\" rel=\"noopener noreferrer\">window functions</a>, <a href=\"http://www.postgresql.org/docs/9.5/static/functions-aggregate.html\" target=\"_blank\" rel=\"noopener noreferrer\">aggregate functions</a>, <a href=\"http://www.postgresql.org/docs/9.5/static/queries-with.html\" target=\"_blank\" rel=\"noopener noreferrer\">WITH clause</a> (or CTE for Common Table Expression) &#8211; for the purpose of implementing a program which <a href=\"https://en.wikipedia.org/wiki/Imputation_(statistics)\" target=\"_blank\" rel=\"noopener noreferrer\">imputes</a> numeric observations within a column applying <a href=\"https://en.wikipedia.org/wiki/Linear_interpolation\" target=\"_blank\" rel=\"noopener noreferrer\">linear interpolation</a> where possible and <a href=\"http://www.joyofdata.de/blog/wp-content/uploads/2015/10/locf-and-linear.png\"><img class=\"alignleft wp-image-3859\" src=\"http://www.joyofdata.de/blog/wp-content/uploads/2015/10/locf-and-linear-300x173.png\" alt=\"locf-and-linear\" width=\"261\" height=\"155\" /></a>forward and backward padding where necessary. I&#8217;m going to progressively add and explain those constructs, step by step, so no problem if you are new to the scene. I am very much interested in input regarding potential downsides of the implementation and possible improvements.</p>\n<p style=\"text-align: justify;\"><span id=\"more-3844\"></span></p>\n<p style=\"text-align: justify;\"><strong>Imputing Observations</strong></p>\n<p style=\"text-align: justify;\">A standard situation for somebody working with data is being faced with missing observations. Depending on the type of observation imputation might be possible. The most simple methods of padding those gaps are to forward or backfill observations up and down an ordered and related sequence of records. This is often referred to as LOCF (last observation carried forward) and FOCB (first observation carried backward). Another often reasonable method is to assume a linear transformation between observations.</p>\n<h1 style=\"text-align: justify;\">Setting Up the Toy Data</h1>\n<p>(<a href=\"https://github.com/joyofdata/joyofdata-articles/blob/master/postgresql-imputation/create-table-and-insert.sql\" target=\"_blank\" rel=\"noopener noreferrer\">GitHub</a> / <a href=\"http://sqlfiddle.com/#!15/19c89/3\" target=\"_blank\" rel=\"noopener noreferrer\">SQL Fiddle</a> &#8211; <em>at the beginning of every section you will find a link to the code on GitHub and an SQL Fiddle session</em>)</p>\n<p style=\"text-align: justify;\">We start with a table (<pre class=\"crayon-plain-tag\">tbl</pre>) of four columns <pre class=\"crayon-plain-tag\">t::float</pre>, <pre class=\"crayon-plain-tag\">a::int</pre>, <pre class=\"crayon-plain-tag\">b::int</pre> and <pre class=\"crayon-plain-tag\">v::float</pre>. <pre class=\"crayon-plain-tag\">a</pre>  and <pre class=\"crayon-plain-tag\">b</pre> hold the keys for identifiying related records &#8211; this is what we will partition over. <pre class=\"crayon-plain-tag\">t</pre> represents the time and <pre class=\"crayon-plain-tag\">v</pre> the observations that we want to impute. For example, think of <pre class=\"crayon-plain-tag\">b</pre> as a town in country <pre class=\"crayon-plain-tag\">a</pre> where temperature <pre class=\"crayon-plain-tag\">v</pre> was measured on 12pm on date <pre class=\"crayon-plain-tag\">t</pre>.</p>\n<h1 style=\"text-align: justify;\">A Very Simple Custom Function</h1>\n<p>(<a href=\"https://github.com/joyofdata/joyofdata-articles/blob/master/postgresql-imputation/custom-function.sql\" target=\"_blank\" rel=\"noopener noreferrer\">GitHub</a> / <a href=\"http://sqlfiddle.com/#!15/19c89/4\" target=\"_blank\" rel=\"noopener noreferrer\">SQL Fiddle</a>)</p>\n<p style=\"text-align: justify;\"><span class=\"alignright\"></span>An LOCF is at the end of the day just a<a href=\"http://www.postgresql.org/docs/9.5/static/functions-conditional.html\" target=\"_blank\" rel=\"noopener noreferrer\"> <pre class=\"crayon-plain-tag\">COALESCE(b,a)</pre> </a>of two observations with <pre class=\"crayon-plain-tag\">a</pre> having been observed before <pre class=\"crayon-plain-tag\">b</pre>. If <pre class=\"crayon-plain-tag\">b is not NULL</pre> we take it, if it is we use the value of the observation before, i.e. <pre class=\"crayon-plain-tag\">a</pre>. If we perform those steps iteratively starting with an initial observation (initial condition) of <pre class=\"crayon-plain-tag\">NULL</pre> then we will inductively fill all gaps after stumbling upon a first non-NULL observation. The following function implements this mechanism, but first we will apply it in a non-aggregating way. The script will just add another column <pre class=\"crayon-plain-tag\">v_or_t</pre> which holds <pre class=\"crayon-plain-tag\">v</pre> in case <pre class=\"crayon-plain-tag\">v IS NOT NULL</pre> and <pre class=\"crayon-plain-tag\">t</pre> if <pre class=\"crayon-plain-tag\">v IS NULL</pre>.</p>\n<p></p><pre class=\"crayon-plain-tag\">CREATE OR REPLACE FUNCTION fun(a FLOAT, b FLOAT)\nRETURNS FLOAT\nLANGUAGE SQL\nAS '\n  SELECT COALESCE(b, a)\n';\n\nselect a,b,t,v,\n    fun(t,v) as v_or_t\nfrom tbl\norder by a,b,t\n;</pre><p></p>\n<p style=\"text-align: justify;\">Here we <pre class=\"crayon-plain-tag\">CREATE OR REPLACE</pre> a <pre class=\"crayon-plain-tag\">FUNCTION</pre> named fun, which takes two <pre class=\"crayon-plain-tag\">FLOAT</pre> typed arguments <pre class=\"crayon-plain-tag\">a</pre> and <pre class=\"crayon-plain-tag\">b</pre> and <pre class=\"crayon-plain-tag\">RETURNS FLOAT</pre> as well. The function is implemented by means of the <pre class=\"crayon-plain-tag\">LANGUAGE SQL</pre> (instead of <a href=\"http://www.postgresql.org/docs/9.5/static/plpgsql.html\" target=\"_blank\" rel=\"noopener noreferrer\">PL/pgSQL</a> or <a href=\"http://www.postgresql.org/docs/9.5/static/xfunc.html\" target=\"_blank\" rel=\"noopener noreferrer\">some other language</a>). An SQL programmed function will return the result of the last evaluated <pre class=\"crayon-plain-tag\">SELECT</pre> statement. The code itself has to be delimited by single quotes (<pre class=\"crayon-plain-tag\">'</pre>) or a string like f.x. &#8220;$$&#8221; and follows after the keyword <pre class=\"crayon-plain-tag\">AS</pre>.</p>\n<p style=\"text-align: justify;\"><p style=\"text-align: center; border: 1px solid #378efd\">\n<img src=\"http://www.joyofdata.de/blog/wp-content/uploads/2015/05/stay-tuned.png\" alt=\"stay-tuned\" style=\"padding-right:30px; height:30px\"/>\n\n<a href=\"https://twitter.com/joyofdata\" target=\"new\" style=\"padding-right:20px\">\n<img src=\"http://www.joyofdata.de/blog/wp-content/uploads/2015/05/twitter.png\" alt=\"twitter\" height=\"28\" /></a>\n<a href=\"http://feedly.com/i/subscription/feed/http://www.joyofdata.de/blog/feed/\" target=\"new\" style=\"padding-right:20px\">\n<img src=\"http://www.joyofdata.de/blog/wp-content/uploads/2015/05/feedly.png\" alt=\"feedly\" width=\"30\" height=\"30\" /></a>\n<a href=\"https://github.com/joyofdata\" target=\"new\" style=\"padding-right:20px\">\n<img src=\"http://www.joyofdata.de/blog/wp-content/uploads/2015/05/github.png\" alt=\"github\" width=\"30\" height=\"30\" /></a>\n</p></p>\n<h1>Implementing LOCF</h1>\n<p>(<a href=\"https://github.com/joyofdata/joyofdata-articles/blob/master/postgresql-imputation/locf-simple.sql\" target=\"_blank\" rel=\"noopener noreferrer\">GitHub</a> / <a href=\"http://sqlfiddle.com/#!15/19c89/5\" target=\"_blank\" rel=\"noopener noreferrer\">SQL Fiddle</a>)</p>\n<p style=\"text-align: justify;\">Now instead of applying the function (which I renamed to <pre class=\"crayon-plain-tag\">locf</pre>) horizontally within a record we tell PostgreSQL to apply it iteratively in a specified <pre class=\"crayon-plain-tag\">ORDER</pre> and within specified boundaries (the <pre class=\"crayon-plain-tag\">PARTITION</pre>) vertically across two records:</p>\n<p></p><pre class=\"crayon-plain-tag\">create or replace function locf_s(a float, b float)\nreturns float\nlanguage sql\nas '\n  select coalesce(b, a)\n';\n\ndrop aggregate if exists locf(float);\nCREATE AGGREGATE locf(FLOAT) (\n  SFUNC = locf_s,\n  STYPE = FLOAT\n);\n\nselect a,b,t,v,\n    locf(v) over (PARTITION by a,b ORDER by t) as v_locf\nfrom tbl\norder by a,b,t\n;</pre><p></p>\n<p style=\"text-align: justify;\">As you can see the process of creating the LOCF function is now split into two steps. <a href=\"http://www.joyofdata.de/blog/wp-content/uploads/2015/10/simple-locf1.png\"><img class=\"alignleft size-medium wp-image-3874\" src=\"http://www.joyofdata.de/blog/wp-content/uploads/2015/10/simple-locf1-300x187.png\" alt=\"simple-locf\" width=\"300\" height=\"187\" srcset=\"https://www.joyofdata.de/blog/wp-content/uploads/2015/10/simple-locf1-300x187.png 300w, https://www.joyofdata.de/blog/wp-content/uploads/2015/10/simple-locf1.png 468w\" sizes=\"(max-width: 300px) 100vw, 300px\" /></a>First we define the transformation of two values into one (<pre class=\"crayon-plain-tag\">locf_s</pre>) and then we <a href=\"http://www.postgresql.org/docs/9.5/static/sql-createaggregate.html\" target=\"_blank\" rel=\"noopener noreferrer\">create the actual aggregating function</a> (<pre class=\"crayon-plain-tag\">locf</pre>) by specifying how to apply the transformation. Here we just define what in this context is referred to as the &#8220;state transition function&#8221; (<pre class=\"crayon-plain-tag\">SFUNC</pre>) which returns a value of the &#8220;state type&#8221; (<pre class=\"crayon-plain-tag\">STYPE</pre>) <pre class=\"crayon-plain-tag\">FLOAT</pre>.</p>\n<p style=\"text-align: justify;\">In the final query we apply <pre class=\"crayon-plain-tag\">locf()</pre> over the <pre class=\"crayon-plain-tag\">PARTITION</pre> defined by <pre class=\"crayon-plain-tag\">a</pre> and <pre class=\"crayon-plain-tag\">b</pre> and traverse the records by ordering <pre class=\"crayon-plain-tag\">t</pre> ascending.</p>\n<h1 style=\"text-align: justify;\">Filling all the Gaps by Applying First LOCF and then FOCB</h1>\n<p style=\"text-align: justify;\">(<a href=\"https://github.com/joyofdata/joyofdata-articles/blob/master/postgresql-imputation/locf-full.sql\" target=\"_blank\" rel=\"noopener noreferrer\">GitHub</a> / <a href=\"http://sqlfiddle.com/#!15/19c89/6\" target=\"_blank\" rel=\"noopener noreferrer\">SQL Fiddle</a>)</p>\n<p style=\"text-align: justify;\"><span class=\"alignright\"></span>Now we go one step further and fill all the missing oberservations by padding a missing oberservation preferredly with the last seen value and if that is not possible we use the first available value. Technically we fill one column <pre class=\"crayon-plain-tag\">v_locf</pre> with the LOCF values, another column <pre class=\"crayon-plain-tag\">v_focb</pre> with the FOCB values and then choose for <pre class=\"crayon-plain-tag\">v_final</pre> the value from <pre class=\"crayon-plain-tag\">v_locf</pre> if it is not NULL and otherwise the value from <pre class=\"crayon-plain-tag\">v_focb</pre>.</p>\n<p></p><pre class=\"crayon-plain-tag\">select a,b,t,v,\n    locf(v) over t_asc as v_locf,\n    locf(v) over t_desc as v_focb,\n    COALESCE(\n        locf(v) over t_asc,\n        locf(v) over t_desc\n    ) as v_final\nfrom tbl\nWINDOW\n    t_asc as (partition by a,b order by t),\n    t_desc as (partition by a,b order by t desc)\norder by a,b,t\n;</pre><p></p>\n<p style=\"text-align: justify;\"><a href=\"http://www.joyofdata.de/blog/wp-content/uploads/2015/10/locf-full1.png\"><img class=\"alignleft wp-image-3875\" src=\"http://www.joyofdata.de/blog/wp-content/uploads/2015/10/locf-full1-300x171.png\" alt=\"locf-full\" width=\"293\" height=\"172\" /></a>First of all, the <pre class=\"crayon-plain-tag\">WINDOW</pre> keyword simply allows us to to name an ordered partition and then use it in the corresponding select query. Second of all, the FOCB mechanism is just LOCF applied to the inversely ordered partition (<pre class=\"crayon-plain-tag\">t_desc</pre>). And finally, it might be worth noting that you can use multiple aggregate functions within another function &#8211; <pre class=\"crayon-plain-tag\">COALESCE</pre> in this case.</p>\n<h1 style=\"text-align: justify;\">Putting the Pieces Together for Linear Interpolation</h1>\n<p style=\"text-align: justify;\">(<a href=\"https://github.com/joyofdata/joyofdata-articles/blob/master/postgresql-imputation/locf-and-linear-full.sql\" target=\"_blank\" rel=\"noopener noreferrer\">GitHub</a> / <a href=\"http://sqlfiddle.com/#!15/19c89/14\" target=\"_blank\" rel=\"noopener noreferrer\">SQL Fiddle</a> &#8211;<em> if you think SQL Fiddle is pretty cool &#8211; why not <a href=\"http://sqlfiddle.com/\" target=\"_blank\" rel=\"noopener noreferrer\">donate a few bucks</a> to support the project?!</em>)</p>\n<p style=\"text-align: justify;\">This query is composed of two main steps. First we unite all the necessary values spread across multiple rows, so those values are available locally to every row and then we calculate row based the imputed value.</p>\n<p></p><pre class=\"crayon-plain-tag\">WITH \ntbl0 as (\n    SELECT a, b, t, v,\n           locf(v) over t_asc as v_locf,\n           locf(v) over t_desc as v_focb, \n           locf(case when v is not null then t else null end) \n                over t_asc as t_locf,\n           locf(case when v is not null then t else null end) \n                over t_desc as t_focb\n    from tbl\n    window t_asc as (partition by a,b order by t),\n           t_desc as (partition by a,b order by t desc)\n),\ntbl1 as (\n    SELECT a, b, t, v, v_locf, v_focb, t_locf, t_focb,\n        case\n            when \n                t_focb != t_locf \n                and v_locf is not null \n                and v_focb is not null\n            then \n                v_locf + (\n                    (v_focb - v_locf)\n                    *\n                    (t - t_locf) /\n                    (t_focb - t_locf)\n                )\n            else coalesce(v_locf, v_focb)\n        end as v_final\n    from tbl0\n    order by a,b,t\n)\nSELECT * from tbl1 order by a,b,t;</pre><p></p>\n<p style=\"text-align: justify;\"><a href=\"http://www.joyofdata.de/blog/wp-content/uploads/2015/10/locf-and-linear.png\"><img class=\"alignleft wp-image-3859 size-medium\" src=\"http://www.joyofdata.de/blog/wp-content/uploads/2015/10/locf-and-linear-300x173.png\" alt=\"locf-and-linear\" width=\"300\" height=\"173\" srcset=\"https://www.joyofdata.de/blog/wp-content/uploads/2015/10/locf-and-linear-300x173.png 300w, https://www.joyofdata.de/blog/wp-content/uploads/2015/10/locf-and-linear-500x288.png 500w, https://www.joyofdata.de/blog/wp-content/uploads/2015/10/locf-and-linear.png 567w\" sizes=\"(max-width: 300px) 100vw, 300px\" /></a>The <pre class=\"crayon-plain-tag\">WITH</pre> clause is simply a way to chain temporary tables. The result of the first SELECT is named <pre class=\"crayon-plain-tag\">tbl0</pre> and used within the second SELECT whose result set is named <pre class=\"crayon-plain-tag\">tbl1</pre> and referred to by the final (technically not necessary) SELECT query. The statements formulated using a <a href=\"http://www.postgresql.org/docs/9.5/static/queries-with.html\" target=\"_blank\" rel=\"noopener noreferrer\">WITH clause are also referred to as CTEs or Common Table Expressions</a>. They can make complex queries more readable and allow the formulation of recursive queries, for example to traverse a tree. CTEs are controversial with respect to their performance (&#8220;<a href=\"http://blog.2ndquadrant.com/postgresql-ctes-are-optimization-fences/\" target=\"_blank\" rel=\"noopener noreferrer\">optimization fence</a>&#8220;).</p>\n<p style=\"text-align: justify;\">Now with the different parameters assembled we can interpolate with the following simple formula:</p>\n<p style=\"text-align: justify;\"><img src=\"http://www.joyofdata.de/blog/wp-content/ql-cache/quicklatex.com-4b76ea928478abb33fbb73e406542a4e_l3.png\" class=\"ql-img-inline-formula quicklatex-auto-format\" alt=\" &#118;&#95;&#123;&#102;&#105;&#110;&#97;&#108;&#125;&#32;&#61;&#32;&#118;&#95;&#123;&#92;&#116;&#101;&#120;&#116;&#123;&#108;&#111;&#99;&#102;&#125;&#125;&#32;&#43;&#32;&#40;&#118;&#95;&#123;&#92;&#116;&#101;&#120;&#116;&#123;&#102;&#111;&#99;&#98;&#125;&#125;&#32;&#45;&#32;&#118;&#95;&#123;&#92;&#116;&#101;&#120;&#116;&#123;&#108;&#111;&#99;&#102;&#125;&#125;&#41;&#32;&#92;&#99;&#100;&#111;&#116;&#32;&#92;&#100;&#102;&#114;&#97;&#99;&#123;&#116;&#32;&#45;&#32;&#116;&#95;&#123;&#92;&#116;&#101;&#120;&#116;&#123;&#108;&#111;&#99;&#102;&#125;&#125;&#125;&#123;&#116;&#95;&#123;&#92;&#116;&#101;&#120;&#116;&#123;&#102;&#111;&#99;&#98;&#125;&#125;&#32;&#45;&#32;&#116;&#95;&#123;&#92;&#116;&#101;&#120;&#116;&#123;&#108;&#111;&#99;&#102;&#125;&#125;&#125; \" title=\"Rendered by QuickLaTeX.com\" height=\"40\" width=\"317\" style=\"vertical-align: -16px;\"/></p>\n<h1 style=\"text-align: justify;\">Updating the Table Directly</h1>\n<p style=\"text-align: justify;\">Now if we subsitute above&#8217;s last SELECT query with the following UPDATE statement then the imputed set of values for <pre class=\"crayon-plain-tag\">v</pre> are directly written to <pre class=\"crayon-plain-tag\">tbl</pre>:</p>\n<p></p><pre class=\"crayon-plain-tag\">update tbl as tb\nset v = t1.v_final\nfrom t1\nwhere\n    tb.a = t1.a and tb.b = t1.b and tb.t = t1.t</pre><p></p>\n<hr />\n<p style=\"text-align: justify;\">(original article published on <a href=\"http://www.joyofdata.de/blog/locf-linear-imputation-postgresql-tutorial\">www.joyofdata.de</a>)</p>\n",
  "wfw:commentRss": "https://www.joyofdata.de/blog/locf-linear-imputation-postgresql-tutorial/feed/",
  "slash:comments": 1
}