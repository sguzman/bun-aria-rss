{
  "guid": "tag:blogger.com,1999:blog-6300367579216018061.post-8368851254535781851",
  "pubDate": "Mon, 13 Jul 2015 01:50:00 +0000",
  "atom:updated": "2015-09-08T19:44:03.211-07:00",
  "category": [
    "api gateway",
    "discovery service",
    "docker",
    "docker compose",
    "microservices",
    "spring boot",
    "spring cloud"
  ],
  "title": "Building Microservices with Spring Cloud and Docker",
  "description": "<style>/* BASICS */  .CodeMirror {   /* Set height, width, borders, and global font properties here */   font-family: monospace;   color: black; }  /* PADDING */  .CodeMirror-lines {   padding: 4px 0; /* Vertical padding around content */ } .CodeMirror pre {   padding: 0 4px; /* Horizontal padding of content */ }  .CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {   background-color: white; /* The little square between H and V scrollbars */ }  /* GUTTER */  .CodeMirror-gutters {   border-right: 1px solid #ddd;   background-color: #f7f7f7;   white-space: nowrap; } .CodeMirror-linenumbers {} .CodeMirror-linenumber {   padding: 0 3px 0 5px;   min-width: 20px;   text-align: right;   color: #999;   white-space: nowrap; }  .CodeMirror-guttermarker { color: black; } .CodeMirror-guttermarker-subtle { color: #999; }  /* CURSOR */  .CodeMirror div.CodeMirror-cursor {   border-left: 1px solid black; } /* Shown when moving in bi-directional text */ .CodeMirror div.CodeMirror-secondarycursor {   border-left: 1px solid silver; } .CodeMirror.cm-fat-cursor div.CodeMirror-cursor {   width: auto;   border: 0;   background: #7e7; } .CodeMirror.cm-fat-cursor div.CodeMirror-cursors {   z-index: 1; }  .cm-animate-fat-cursor {   width: auto;   border: 0;   -webkit-animation: blink 1.06s steps(1) infinite;   -moz-animation: blink 1.06s steps(1) infinite;   animation: blink 1.06s steps(1) infinite; } @-moz-keyframes blink {   0% { background: #7e7; }   50% { background: none; }   100% { background: #7e7; } } @-webkit-keyframes blink {   0% { background: #7e7; }   50% { background: none; }   100% { background: #7e7; } } @keyframes blink {   0% { background: #7e7; }   50% { background: none; }   100% { background: #7e7; } }  /* Can style cursor different in overwrite (non-insert) mode */ div.CodeMirror-overwrite div.CodeMirror-cursor {}  .cm-tab { display: inline-block; text-decoration: inherit; }  .CodeMirror-ruler {   border-left: 1px solid #ccc;   position: absolute; }  /* DEFAULT THEME */  .cm-s-default .cm-header {color: blue;} .cm-s-default .cm-quote {color: #090;} .cm-negative {color: #d44;} .cm-positive {color: #292;} .cm-header, .cm-strong {font-weight: bold;} .cm-em {font-style: italic;} .cm-link {text-decoration: underline;} .cm-strikethrough {text-decoration: line-through;}  .cm-s-default .cm-keyword {color: #708;} .cm-s-default .cm-atom {color: #219;} .cm-s-default .cm-number {color: #164;} .cm-s-default .cm-def {color: #00f;} .cm-s-default .cm-variable, .cm-s-default .cm-punctuation, .cm-s-default .cm-property, .cm-s-default .cm-operator {} .cm-s-default .cm-variable-2 {color: #05a;} .cm-s-default .cm-variable-3 {color: #085;} .cm-s-default .cm-comment {color: #a50;} .cm-s-default .cm-string {color: #a11;} .cm-s-default .cm-string-2 {color: #f50;} .cm-s-default .cm-meta {color: #555;} .cm-s-default .cm-qualifier {color: #555;} .cm-s-default .cm-builtin {color: #30a;} .cm-s-default .cm-bracket {color: #997;} .cm-s-default .cm-tag {color: #170;} .cm-s-default .cm-attribute {color: #00c;} .cm-s-default .cm-hr {color: #999;} .cm-s-default .cm-link {color: #00c;}  .cm-s-default .cm-error {color: #f00;} .cm-invalidchar {color: #f00;}  .CodeMirror-composing { border-bottom: 2px solid; }  /* Default styles for common addons */  div.CodeMirror span.CodeMirror-matchingbracket {color: #0f0;} div.CodeMirror span.CodeMirror-nonmatchingbracket {color: #f22;} .CodeMirror-matchingtag { background: rgba(255, 150, 0, .3); } .CodeMirror-activeline-background {background: #e8f2ff;}  /* STOP */  /* The rest of this file contains styles related to the mechanics of    the editor. You probably shouldn't touch them. */  .CodeMirror {   position: relative;   overflow: hidden;   background: white; }  .CodeMirror-scroll {   overflow: scroll !important; /* Things will break if this is overridden */   /* 30px is the magic margin used to hide the element's real scrollbars */   /* See overflow: hidden in .CodeMirror */   margin-bottom: -30px; margin-right: -30px;   padding-bottom: 30px;   height: 100%;   outline: none; /* Prevent dragging from highlighting the element */   position: relative; } .CodeMirror-sizer {   position: relative;   border-right: 30px solid transparent; }  /* The fake, visible scrollbars. Used to force redraw during scrolling    before actuall scrolling happens, thus preventing shaking and    flickering artifacts. */ .CodeMirror-vscrollbar, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {   position: absolute;   z-index: 6;   display: none; } .CodeMirror-vscrollbar {   right: 0; top: 0;   overflow-x: hidden;   overflow-y: scroll; } .CodeMirror-hscrollbar {   bottom: 0; left: 0;   overflow-y: hidden;   overflow-x: scroll; } .CodeMirror-scrollbar-filler {   right: 0; bottom: 0; } .CodeMirror-gutter-filler {   left: 0; bottom: 0; }  .CodeMirror-gutters {   position: absolute; left: 0; top: 0;   z-index: 3; } .CodeMirror-gutter {   white-space: normal;   height: 100%;   display: inline-block;   margin-bottom: -30px;   /* Hack to make IE7 behave */   *zoom:1;   *display:inline; } .CodeMirror-gutter-wrapper {   position: absolute;   z-index: 4;   height: 100%; } .CodeMirror-gutter-elt {   position: absolute;   cursor: default;   z-index: 4; } .CodeMirror-gutter-wrapper {   -webkit-user-select: none;   -moz-user-select: none;   user-select: none; }  .CodeMirror-lines {   cursor: text;   min-height: 1px; /* prevents collapsing before first draw */ } .CodeMirror pre {   /* Reset some styles that the rest of the page might have set */   -moz-border-radius: 0; -webkit-border-radius: 0; border-radius: 0;   border-width: 0;   background: transparent;   font-family: inherit;   font-size: inherit;   margin: 0;   white-space: pre;   word-wrap: normal;   line-height: inherit;   color: inherit;   z-index: 2;   position: relative;   overflow: visible;   -webkit-tap-highlight-color: transparent; } .CodeMirror-wrap pre {   word-wrap: break-word;   white-space: pre-wrap;   word-break: normal; }  .CodeMirror-linebackground {   position: absolute;   left: 0; right: 0; top: 0; bottom: 0;   z-index: 0; }  .CodeMirror-linewidget {   position: relative;   z-index: 2;   overflow: auto; }  .CodeMirror-widget {}  .CodeMirror-code {   outline: none; }  /* Force content-box sizing for the elements where we expect it */ .CodeMirror-scroll, .CodeMirror-sizer, .CodeMirror-gutter, .CodeMirror-gutters, .CodeMirror-linenumber {   -moz-box-sizing: content-box;   box-sizing: content-box; }  .CodeMirror-measure {   position: absolute;   width: 100%;   height: 0;   overflow: hidden;   visibility: hidden; } .CodeMirror-measure pre { position: static; }  .CodeMirror div.CodeMirror-cursor {   position: absolute;   border-right: none;   width: 0; }  div.CodeMirror-cursors {   visibility: hidden;   position: relative;   z-index: 3; } .CodeMirror-focused div.CodeMirror-cursors {   visibility: visible; }  .CodeMirror-selected { background: #d9d9d9; } .CodeMirror-focused .CodeMirror-selected { background: #d7d4f0; } .CodeMirror-crosshair { cursor: crosshair; } .CodeMirror-line::selection, .CodeMirror-line > span::selection, .CodeMirror-line > span > span::selection { background: #d7d4f0; } .CodeMirror-line::-moz-selection, .CodeMirror-line > span::-moz-selection, .CodeMirror-line > span > span::-moz-selection { background: #d7d4f0; }  .cm-searching {   background: #ffa;   background: rgba(255, 255, 0, .4); }  /* IE7 hack to prevent it from returning funny offsetTops on the spans */ .CodeMirror span { *vertical-align: text-bottom; }  /* Used to force a border model for a node */ .cm-force-border { padding-right: .1px; }  @media print {   /* Hide the cursor when printing */   .CodeMirror div.CodeMirror-cursors {     visibility: hidden;   } }  /* See issue #2901 */ .cm-tab-wrap-hack:after { content: ''; }  /* Help users use markselection to safely style text background */ span.CodeMirror-selectedtext { background: none; } </style><div><div id=\"preamble\"><div class=\"sectionbody\"><div class=\"paragraph\"><p>This blog series will introduce you to some of the foundational concepts of building a microservice-based platform using Spring Cloud and Docker.</p></div></div></div><div class=\"sect1\"><h2 id=\"what-is-spring-cloud\"><a class=\"anchor\" href=\"#what-is-spring-cloud\"></a>What is Spring Cloud?</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p><a href=\"http://projects.spring.io/spring-cloud/\" target=\"_blank\">Spring Cloud</a> is a collection of tools from <a href=\"https://pivotal.io/\" target=\"_blank\">Pivotal</a> that provides solutions to some of the commonly encountered patterns when building distributed systems. If you&#8217;re familiar with building applications with <a href=\"https://en.wikipedia.org/wiki/Spring_Framework\" target=\"_blank\">Spring Framework</a>, Spring Cloud builds upon some of its common building blocks.</p></div><div class=\"paragraph\"><p>Among the solutions provided by Spring Cloud, you will find tools for the following problems:</p></div><div class=\"ulist\"><ul><li><p><a href=\"http://12factor.net/config\" target=\"_blank\">Configuration management</a></p></li><li><p><a href=\"https://en.wikipedia.org/wiki/Service_discovery\" target=\"_blank\">Service discovery</a></p></li><li><p><a href=\"http://martinfowler.com/bliki/CircuitBreaker.html\" target=\"_blank\">Circuit breakers</a></p></li><li><p><a href=\"https://en.wikipedia.org/wiki/Distributed_cache\" target=\"_blank\">Distributed sessions</a></p></li></ul></div></div></div><div class=\"sect1\"><h2 id=\"spring-boot\"><a class=\"anchor\" href=\"#spring-boot\"></a>Spring Boot</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p>The great part about working with Spring Cloud is that it builds on the concepts of <a href=\"http://projects.spring.io/spring-boot/\" target=\"_blank\">Spring Boot</a>.</p></div><div class=\"paragraph\"><p>For those of you who are new to Spring Boot, the name of the project means exactly what it says. You get all of the best things of the Spring Framework and ecosystem of projects, tuned to perfection, with minimal configuration, all ready for production.</p></div></div></div><div class=\"sect1\"><h2 id=\"service-discovery-and-intelligent-routing\"><a class=\"anchor\" href=\"#service-discovery-and-intelligent-routing\"></a>Service Discovery and Intelligent Routing</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p>Each service has a dedicated purpose in a microservices architecture. When building a microservices architecture on Spring Cloud, there are a few primary concerns to deal with first. The first two microservices you will want to create are the <strong>Configuration Service</strong>, and the <strong>Discovery Service</strong>.</p></div><div class=\"imageblock\"><div class=\"content\"><div class=\"paragraph\">  <p><span class=\"image\"><img src=\"http://i.imgur.com/Dc6xjwd.png\" alt=\"Microservice Configuration\" style=\"width:100%;max-width:600px;\"></span></p>  </div></div></div><div class=\"paragraph\"><p>The graphic above illustrates a 4-microservice setup, with the connections between them indicating a dependency.</p></div><div class=\"paragraph\"><p>The configuration service sits at the top, in yellow, and is depended on by the other microservices. The discovery service sits at the bottom, in blue, and also is depended upon by the other microservices.</p></div><div class=\"paragraph\"><p>In green, we have two microservices that deal with a part of the domain of the example application I will use throughout this blog series: movies and recommendations.</p></div><div class=\"sect2\"><h3 id=\"configuration-service\"><a class=\"anchor\" href=\"#configuration-service\"></a>Configuration Service</h3><div class=\"paragraph\"><p>The configuration service is a vital component of any microservices architecture. Based on the <a href=\"http://12factor.net/config\" target=\"_blank\"><strong>twelve-factor app</strong></a> methodology, configurations for your microservice applications should be stored in the environment and not in the project.</p></div><div class=\"paragraph\"><p>The configuration service is essential because it handles the configurations for all of the services through a simple point-to-point service call to retrieve those configurations. The advantages of this are multi-purpose.</p></div><div class=\"paragraph\"><p>Let's assume that we have multiple deployment environments. If we have a staging environment and a production environment, configurations for those environments will be different. A configuration service might have a dedicated Git repository for the configurations of that environment. None of the other environments will be able to access this configuration, it is available only to the configuration service running in that environment.</p></div><div class=\"imageblock\"><div class=\"content\"><div class=\"paragraph\">  <p><span class=\"image\"><img src=\"http://i.imgur.com/J7FazPH.png\" alt=\"Microservice Configuration 2\" style=\"width:100%;max-width:900px;\"></span></p>  </div></div></div><a name='more'></a><div class=\"paragraph\"><p>When the configuration service starts up, it will reference the path to those configuration files and begin to serve them up to the microservices that request those configurations. Each microservice can have their configuration file configured to the specifics of the environment that it is running in. In doing this, the configuration is both externalized and centralized in one place that can be version-controlled and revised without having to restart a service to change a configuration.</p></div><div class=\"paragraph\"><p>With management endpoints available from Spring Cloud, you can make a configuration change in the environment and signal a refresh to the discovery service that will force all consumers to fetch the new configurations.</p></div></div><div class=\"sect2\"><h3 id=\"discovery-service\"><a class=\"anchor\" href=\"#discovery-service\"></a>Discovery Service</h3><div class=\"paragraph\"><p>The discovery service is another vital component of our microservice architecture. The discovery service handles maintaining a list of service instances that are available for work within a cluster. Within applications, service-to-service calls are made using clients. For this example project, I used <a href=\"https://github.com/spring-cloud-samples/feign-eureka\" target=\"_blank\">Spring Cloud Feign</a>, a client-based API for RESTful microservices that originated from the <a href=\"https://github.com/spring-cloud-samples/feign-eureka\" target=\"_blank\">Netflix OSS project</a>.</p></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"CodeMirror\" data-lang=\"text/x-java\">@FeignClient(\"movie\")<br />public interface MovieClient {<br />    @RequestMapping(method = RequestMethod.GET, value = \"/movies\")<br />    PagedResources<User> findAll();<br /><br />    @RequestMapping(method = RequestMethod.GET, value = \"/movies/{id}\")<br />    Movie findById(@RequestParam(\"id\") String id);<br /><br />    @RequestMapping(method = RequestMethod.POST, value = \"/movies\",<br />      produces = MediaType.APPLICATION_JSON_VALUE)<br />    void createMovie(@RequestBody Movie movie);<br />}</pre></div></div><div class=\"paragraph\"><p>In the code example above, I am creating a Feign client that maps to the REST API methods that are exposed by the movie service. Using the <code>@FeignClient</code> annotation, I first specify that I want to create a client API for the <code>movie</code> microservice. Next I specify the mappings of the service that I want to consume. I do this by declaring a URL pattern over the methods that describes a route for a REST API.</p></div><div class=\"paragraph\"><p>The wonderfully easy part of creating Feign clients is that all I need to know is the ID of the service that I would like to create a client on. The URL of the service is automatically configured at runtime because each microservice in the cluster will register with the discovery service with its <code>serviceId</code> at startup.</p></div><div class=\"paragraph\"><p>The same is true for all other services of my microservice architecture. All I need to know is the <code>serviceId</code> of the service I want to communicate with, and everything else will be autowired by Spring.</p></div> </div><div class=\"sect2\"><h3 id=\"api-gateway\"><a class=\"anchor\" href=\"#api-gateway\"></a>API Gateway</h3><div class=\"paragraph\"><p>The API gateway service is another vital component if we are going to create a cluster of services managing their own domain entities. The green hexagons below are our data-driven services that manage their own domain entities and even their own databases. By adding an API gateway service, we can create a proxy of each API route that are exposed by the green services.</p></div><div class=\"imageblock\"><div class=\"content\"><div class=\"paragraph\">  <p><span class=\"image\"><img src=\"http://i.imgur.com/JVSGMfY.png\" alt=\"Microservice API Gateway\" style=\"width:100%;max-width:500px;\"></span></p>  </div></div></div><div class=\"paragraph\"><p>Let&#8217;s assume that both the recommendation service and the movie service expose their own REST API over the domain entities that they manage. The API gateway will discover these services through the discovery service and inject a proxy-based route of the API methods from the other services. In this way, both the recommendation and movie microservice will have a full definition of routes available locally from all the microservices that expose a REST API. The API Gateway will re-route the request to the service instances that own the route being requested through HTTP.</p></div></div></div></div><div class=\"sect1\"><h2 id=\"example-project\"><a class=\"anchor\" href=\"#example-project\"></a>Example Project</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p><a href=\"https://github.com/kbastani/spring-cloud-microservice-example\" target=\"_blank\">I&#8217;ve put together an example project</a> that demonstrates an end-to-end cloud-native platform using Spring Cloud for building a practical microservices architecture.</p></div><div class=\"paragraph\"><p>Demonstrated concepts:</p></div><div class=\"ulist\"><ul><li><p>Integration testing using Docker</p></li><li><p>Polyglot persistence</p></li><li><p>Microservice architecture</p></li><li><p>Service discovery</p></li><li><p>API gateway</p></li></ul></div><div class=\"sect2\"><h3 id=\"docker\"><a class=\"anchor\" href=\"#docker\"></a>Docker</h3><div class=\"paragraph\"><p>Each service is built and deployed using Docker. End-to-end integration testing can be done on a developer&#8217;s machine using Docker compose.</p></div></div><div class=\"sect2\"><h3 id=\"polyglot-persistence\"><a class=\"anchor\" href=\"#polyglot-persistence\"></a>Polyglot Persistence</h3><div class=\"paragraph\"><p>One of the core concepts of this example project is how polyglot persistence can be approached in practice. Microservices in the project use their own database while integrating with the data from other services through REST or a message bus. For example, you could have a microservice for each of the following databases.</p></div><div class=\"ulist\"><ul><li><p>Neo4j (graph)</p></li><li><p>MongoDB (document)</p></li><li><p>MySQL (relational)</p></li></ul></div></div><div class=\"sect2\"><h3 id=\"microservice-architecture\"><a class=\"anchor\" href=\"#microservice-architecture\"></a>Microservice architecture</h3><div class=\"paragraph\"><p>This example project demonstrates how to build a new application using microservices, as opposed to a monolith-first strategy. Since each microservice in the project is a module of a single parent project, developers have the advantage of being able to run and develop with each microservice running on their local machine. Adding a new microservice is easy, as the discovery microservice will automatically discover new services running on the cluster.</p></div></div><div class=\"sect2\"><h3 id=\"service-discovery\"><a class=\"anchor\" href=\"#service-discovery\"></a>Service discovery</h3><div class=\"paragraph\"><p>This project contains two discovery services, one on <a href=\"https://github.com/Netflix/eureka\" target=\"_blank\">Netflix Eureka</a>, and the other uses <a href=\"https://consul.io/\" target=\"_blank\">Consul from Hashicorp</a>. Having multiple discovery services provides the opportunity to use one (Consul) as a DNS provider for the cluster, and the other (Eureka) as a proxy-based API gateway.</p></div></div><div class=\"sect2\"><h3 id=\"api-gateway-2\"><a class=\"anchor\" href=\"#api-gateway-2\"></a>API gateway</h3><div class=\"paragraph\"><p>Each microservice will coordinate with Eureka to retrieve API routes for the entire cluster. Using this strategy each microservice in a cluster can be load balanced and exposed through one API gateway. Each service will automatically discover and route API requests to the service that owns the route. This proxying technique is equally helpful when developing user interfaces, as the full API of the platform is available through its own host as a proxy.</p></div></div></div></div><div class=\"sect1\"><h2 id=\"docker-demo\"><a class=\"anchor\" href=\"#docker-demo\"></a>Docker Demo</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p>The example project uses Docker to build a container image of each of our microservices as a part of the Maven build process. We can easily orchestrate the full microservice cluster on our own machine using Docker compose.</p></div><div class=\"sect2\"><h3 id=\"getting-started\"><a class=\"anchor\" href=\"#getting-started\"></a>Getting Started</h3><div class=\"paragraph\"><p>To get started, visit the GitHub repository for this example project.</p></div><div class=\"literalblock\"><div class=\"content\"><pre><a href=\"https://github.com/kbastani/spring-cloud-microservice-example\" target=\"_blank\">https://github.com/kbastani/spring-cloud-microservice-example</a></pre></div></div><div class=\"paragraph\"><p>Clone or fork the project and download the repository to your machine. After downloading, you will need to use both Maven and Docker to compile and build the images locally.</p></div><div class=\"sect3\"><h4 id=\"download-docker\"><a class=\"anchor\" href=\"#download-docker\"></a>Download Docker</h4><div class=\"paragraph\"><p>First, download Docker if you haven&#8217;t already. Follow the instructions <a href=\"https://docs.docker.com/installation/\" target=\"_blank\">found here</a>, to get Docker up and running on your development machine.</p></div><div class=\"paragraph\"><p>You will also need to install <a href=\"https://docs.docker.com/compose/\" target=\"_blank\">Docker Compose</a>, the installation guide can be <a href=\"https://docs.docker.com/compose/install/\" target=\"_blank\">found here</a>. If you are using Mac OSX and boot2docker, make sure that you provision the boot2docker-vm on VirtualBox with at least 5GB of memory. The following command will allow you to do this.</p></div><div class=\"literalblock\"><div class=\"content\"><pre class=\"CodeMirror\" data-lang=\"text/x-sh\">$ boot2docker init --memory=5000</pre></div></div></div><div class=\"sect3\"><h4 id=\"requirements\"><a class=\"anchor\" href=\"#requirements\"></a>Requirements</h4><div class=\"paragraph\"><p>The requirements for running this demo on your machine are found below.</p></div><div class=\"ulist\"><ul><li><p>Maven 3</p></li><li><p>Java 8</p></li><li><p>Docker</p></li><li><p>Docker Compose</p></li></ul></div></div></div><div class=\"sect2\"><h3 id=\"building-the-project\"><a class=\"anchor\" href=\"#building-the-project\"></a>Building the project</h3><div class=\"paragraph\"><p>To build the project, from the terminal, run the following command at the root of the project.</p></div><div class=\"literalblock\"><div class=\"content\"><pre class=\"CodeMirror\" data-lang=\"text/x-sh\">$ mvn clean install</pre></div></div><div class=\"paragraph\"><p>The project will then download all of the needed dependencies and compile each of the project artifacts. Each service will be built, and then a Maven Docker plugin will automatically build each of the images into your local Docker registry. Docker must be running and available from the command line where you run the <code>mvn clean install</code> command for the build to succeed.</p></div><div class=\"paragraph\"><p>After the project successfully builds, you&#8217;ll see the following output:</p></div><div class=\"literalblock\"><div class=\"content\"><pre class=\"CodeMirror\" style=\"     max-width: 50em;     text-overflow:auto;     min-width: 50em;     overflow: scroll;\" data-lang=\"text/x-sh\">[INFO] ------------------------------------------------------------------------<br />[INFO] Reactor Summary:<br />[INFO]<br />[INFO] spring-cloud-microservice-example-parent .......... SUCCESS [  0.268 s]<br />[INFO] users-microservice ................................ SUCCESS [ 11.929 s]<br />[INFO] discovery-microservice ............................ SUCCESS [  5.640 s]<br />[INFO] api-gateway-microservice .......................... SUCCESS [  5.156 s]<br />[INFO] recommendation-microservice ....................... SUCCESS [  7.732 s]<br />[INFO] config-microservice ............................... SUCCESS [  4.711 s]<br />[INFO] hystrix-dashboard ................................. SUCCESS [  4.251 s]<br />[INFO] consul-microservice ............................... SUCCESS [  6.763 s]<br />[INFO] movie-microservice ................................ SUCCESS [  8.359 s]<br />[INFO] movies-ui ......................................... SUCCESS [ 15.833 s]<br />[INFO] ------------------------------------------------------------------------<br />[INFO] BUILD SUCCESS<br />[INFO] ------------------------------------------------------------------------</pre></div></div></div><div class=\"sect2\"><h3 id=\"start-the-cluster-with-docker-compose\"><a class=\"anchor\" href=\"#start-the-cluster-with-docker-compose\"></a>Start the Cluster with Docker Compose</h3><div class=\"paragraph\"><p>Now that each of the images has been built successfully, we can using Docker Compose to spin up our cluster. I&#8217;ve included a pre-configured Docker Compose yaml file with the project.</p></div><div class=\"paragraph\"><p>From the project root, navigate to the <code>spring-cloud-microservice-example/docker</code> directory.</p></div><div class=\"paragraph\"><p>Now, to startup the microservice cluster, run the following command:</p></div><div class=\"literalblock\"><div class=\"content\"><pre class=\"CodeMirror\" data-lang=\"text/x-sh\">$ docker-compose up</pre></div></div><div class=\"paragraph\"><p>If everything is configured correctly, each of the container images we built earlier will be launched within their own VM container on Docker and networked for automatic service discovery. You will see a flurry of log output from each of the services as they begin their startup sequence. This might take a few minutes to complete, depending on the performance of the machine you&#8217;re running this demo on.</p></div><div class=\"paragraph\"><p>Once the startup sequence is completed, you can navigate to the Eureka host and see which services have registered with the discovery service.</p></div><div class=\"paragraph\"><p>Copy and paste the following command into the terminal where Docker can be accessed using the <code>$DOCKER_HOST</code> environment variable.</p></div><div class=\"literalblock\"><div class=\"content\"><pre class=\"CodeMirror\" data-lang=\"text/x-sh\">$ open $(echo \\\"$(echo $DOCKER_HOST)\\\"|<br />            \\sed 's/tcp:\\/\\//http:\\/\\//g'|<br />            \\sed 's/[0-9]\\{4,\\}/8761/g'|<br />            \\sed 's/\\\"//g')</pre></div></div><div class=\"paragraph\"><p>If Eureka correctly started up, a browser window will open to the location of the Eureka service&#8217;s dashboard, as shown below.</p></div><div class=\"paragraph\"><p><span class=\"image\"><img src=\"http://i.imgur.com/buABI3h.png\" alt=\"Eureka\" style=\"width:100%;max-width:600px;\"></span></p></div><div class=\"paragraph\"><p>We can see each of the service instances that are running and their status. We can then access one of the data-driven services, for example the <code>movie</code> service.</p></div><div class=\"literalblock\"><div class=\"content\"><pre class=\"CodeMirror\" data-lang=\"text/x-sh\">$ open $(echo \\\"$(echo $DOCKER_HOST)/movie\\\"|<br />            \\sed 's/tcp:\\/\\//http:\\/\\//g'|<br />            \\sed 's/[0-9]\\{4,\\}/10000/g'|<br />            \\sed 's/\\\"//g')</pre></div></div><div class=\"paragraph\"><p>This command will navigate to the API gateway&#8217;s endpoint and proxy to the movie service&#8217;s REST API endpoints. These REST APIs have been configured to use <a href=\"https://en.wikipedia.org/wiki/HATEOAS\" target=\"_blank\">HATEOAS</a>, which supports the auto-discovery of all of the service&#8217;s functionality as embedded links.</p></div><div class=\"literalblock\"><div class=\"content\"><pre class=\"CodeMirror\"  style=\"     max-width: 50em;     text-overflow:auto;     min-width: 50em;     overflow: scroll;\" data-lang=\"application/json\">{<br />  \"_links\" : {<br />    \"self\" : {<br />      \"href\" : \"http://192.168.59.103:10000/movie\"<br />    },<br />    \"resume\" : {<br />      \"href\" : \"http://192.168.59.103:10000/movie/resume\"<br />    },<br />    \"pause\" : {<br />      \"href\" : \"http://192.168.59.103:10000/movie/pause\"<br />    },<br />    \"restart\" : {<br />      \"href\" : \"http://192.168.59.103:10000/movie/restart\"<br />    },<br />    \"metrics\" : {<br />      \"href\" : \"http://192.168.59.103:10000/movie/metrics\"<br />    },<br />    \"env\" : [ {<br />      \"href\" : \"http://192.168.59.103:10000/movie/env\"<br />    }, {<br />      \"href\" : \"http://192.168.59.103:10000/movie/env\"<br />    } ],<br />    \"archaius\" : {<br />      \"href\" : \"http://192.168.59.103:10000/movie/archaius\"<br />    },<br />    \"beans\" : {<br />      \"href\" : \"http://192.168.59.103:10000/movie/beans\"<br />    },<br />    \"configprops\" : {<br />      \"href\" : \"http://192.168.59.103:10000/movie/configprops\"<br />    },<br />    \"trace\" : {<br />      \"href\" : \"http://192.168.59.103:10000/movie/trace\"<br />    },<br />    \"info\" : {<br />      \"href\" : \"http://192.168.59.103:10000/movie/info\"<br />    },<br />    \"health\" : {<br />      \"href\" : \"http://192.168.59.103:10000/movie/health\"<br />    },<br />    \"hystrix.stream\" : {<br />      \"href\" : \"http://192.168.59.103:10000/movie/hystrix.stream\"<br />    },<br />    \"routes\" : {<br />      \"href\" : \"http://192.168.59.103:10000/movie/routes\"<br />    },<br />    \"dump\" : {<br />      \"href\" : \"http://192.168.59.103:10000/movie/dump\"<br />    },<br />    \"refresh\" : {<br />      \"href\" : \"http://192.168.59.103:10000/movie/refresh\"<br />    },<br />    \"mappings\" : {<br />      \"href\" : \"http://192.168.59.103:10000/movie/mappings\"<br />    },<br />    \"autoconfig\" : {<br />      \"href\" : \"http://192.168.59.103:10000/movie/autoconfig\"<br />    }<br />  }<br />}</pre></div></div></div></div></div><div class=\"sect1\"><h2 id=\"conclusion\"><a class=\"anchor\" href=\"#conclusion\"></a>Conclusion</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p>This has been the first part in a multi-part series about building microservice architectures with Spring Cloud and Docker. In this blog post, we went over the following concepts:</p></div><div class=\"ulist\"><ul><li><p>Service Discovery</p></li><li><p>Externalized Configuration</p></li><li><p>API Gateway</p></li><li><p>Service Orchestration with Docker Compose</p></li></ul></div><div class=\"paragraph\"><p>In the next blog post, we will go over how to build application front-ends that integrate with our backend services. We will also take a look at a use case for <a href=\"http://martinfowler.com/bliki/PolyglotPersistence.html\" target=\"_blank\">polyglot persistence</a>, using both MySQL (relational) and Neo4j (graph).</p></div><h2>Special thanks</h2><div class=\"paragraph\"><p>I want to give special thanks to <a href=\"http://www.twitter.com/starbuxman\" target=\"_blank\">Josh Long</a> and the rest of the Spring team for giving me the chance to learn first-hand about the many wonderful things that the Spring Framework has to offer. Without Josh's mentorship I would not be able to put into words all of the amazing things that the Spring ecosystem has to offer.</p><p>Many of the great open source tools, like Spring Cloud, wouldn't be possible without the thought leadership from people like <a href=\"https://twitter.com/adrianco\" target=\"_blank\">Adrian Cockcroft</a> (Netflix OSS), <a href=\"https://twitter.com/martinfowler\" target=\"_blank\">Martin Fowler</a> (everything), <a href=\"https://twitter.com/samnewman\" target=\"_blank\">Sam Newman</a> (<a href=\"http://shop.oreilly.com/product/0636920033158.do\" target=\"_blank\">O'Reilly's Building Microservices</a>), <a href=\"https://twitter.com/iansrobinson\" target=\"_blank\">Ian Robinson</a> (consumer driven contracts), <a href=\"https://twitter.com/crichardson\" target=\"_blank\">Chris Richardson</a> (Cloud Foundry) and the many others who have helped to make the world of open source software what it is today.</p></div></div></div></div>",
  "enclosure": [
    "",
    "",
    ""
  ],
  "link": "https://www.kennybastani.com/2015/07/spring-cloud-docker-microservices.html",
  "author": "noreply@blogger.com (Kenny Bastani)",
  "thr:total": 0
}