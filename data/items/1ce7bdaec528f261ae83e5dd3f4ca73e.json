{
  "title": "Google F1 Server Reading Summary",
  "description": "<p>A summary of the Google published whitepaper: <a href=\"http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/41344.pdf\">F1 - A Distributed SQL Database That Scales</a>.</p>\n\n<ul>\n  <li>F1 is a distributed database built on top of <a href=\"http://research.google.com/archive/spanner.html\">Spanner</a> from Google. F1 was devised when MySQL was unable to service Google AdWords traffic. MySQL offers many functionalities that must still be supported by any replacements such as traditional SQL analysis, indexing, optimistic and pessimistic transactions, etc. Some of the required features are already supported by Spanner, but some other features such as optimistic transactions, automatic change history generation, transactionally consistent secondary indexes was not supported by Spanner. F1 builds on Spanner to provide those functionalities.</li>\n  <li>F1 offers consistency, scalability, high availability, and SQL-like syntax for traditional query analysis. F1 design choices offer many of the features (automatic change history generation, automatic indexing, consistency, etc) required in AdWords affected reads/writes latency.</li>\n  <li>Global consistency is backed by Spanner’s strongly consistent model.</li>\n  <li>F1 table are comprised of columns, which is a <a href=\"https://developers.google.com/protocol-buffers/\">protobuf</a>. Each row is an instance of data. This allows reads to be very granular and only get what is needed: some rows of some columns. For large tables, loading all columns by default means most data is not needed with read latency impact.</li>\n  <li>F1 supports row-level granularity locks by default, and has column-level lock granularity.</li>\n  <li>Read latency impact is mitigated by forcing the tables to be hierarchical so that data is clustered together explicitly. The implication is that this makes F1 less suitable for patterns that involves many tables that require joins but are not hierarchically related. Heavy batching, parallelism and asynchronous reads also helps. The F1 client library also systematically prevents common ORM library issues including serial reads, implicit traversals (load everything “just in case”).\n    <ul>\n      <li>For instance, this is an example from the paper and some hypothetical tables:\n        <ul>\n          <li>Customer\n            <ul>\n              <li>Campaign\n                <ul>\n                  <li>CampaignData</li>\n                  <li>CampaignOtherData</li>\n                </ul>\n              </li>\n              <li>Payment</li>\n            </ul>\n          </li>\n          <li>MyOtherData</li>\n          <li>SomeOtherData\n            <ul>\n              <li>DetailedInfo</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>Then, these queries should be fast: joining CampaignData with CampaignOtherData. Payment with Campaign. Payment and CampaignData (should still be fast).</li>\n      <li>However, these queries should be slow: MyOtherData with Payment. DetailedInfo with CampaignData. DetailedInfo with MyOtherData.</li>\n    </ul>\n  </li>\n  <li>There are 3 transaction types:\n    <ul>\n      <li>Snapshot: read-only transactions at a fixed Spanner snapshot timestamp ST. This means it only sees data up to ST, but will remain consistent. The default snapshot read timestamp is the F1 global safe timestamp which is 5-10 seconds old. F1 global safe timestamp is the timestamp where reads in any F1 cluster is consistent.</li>\n      <li>Pessmistic: <a href=\"https://en.wikipedia.org/wiki/Concurrency_control#Categories\">pessimistic transaction</a> as we know it. Directly mapped to Spanner transactions. Needs to maintain states to hold locks and handled by single F1 server. Bottleneck. This has high latency but can be useful if conflict writes are frequent.</li>\n      <li>Optimistic: <a href=\"https://en.wikipedia.org/wiki/Concurrency_control#Categories\">optimistic transaction</a> as we know it. No Spanner locks taken. To detect row level conflicts, each row has an associated last modification timestamp when returned to the client. When the write is passed to F1, F1 compares the last modification timestamps of these rows to the ones re-fetched from Spanner, if the last modification timestamps do not agree, return conflict.</li>\n    </ul>\n  </li>\n  <li>Read latency impact can be improved by co-locating F1 and Spanner instances. However, F1 servers and F1 slaves can talk to Spanner servers in other data centers (presumably when under load to load balance).</li>\n  <li>A read flow in code is:\n    <ul>\n      <li>Code uses the F1 client to issue a query to read data.</li>\n      <li>Load Balancer assigns query an F1 cluster.</li>\n      <li>Query hits F1 server. In distributed execution (see below), it is also the query coordinator.</li>\n      <li>F1 server decides whether centralized execution or distributed execution favours query processing latency. Distributed execution would mean queries will be distributed to F1 slaves, which handles joins and read requests.</li>\n      <li>If centralized execution:\n        <ul>\n          <li>F1 query is forwarded to Spanner, presumably converted to something that Spanner understands.</li>\n          <li>The “Spanner Query” gets served and Spanner returns a data stream back to F1 server.</li>\n          <li>F1 server streams the returned Spanner data stream to F1 client.</li>\n        </ul>\n      </li>\n      <li>If distributed execution:\n        <ul>\n          <li>F1 query is repartitioned and forwarded to N slaves, which handle joins and aggregations.</li>\n          <li>Each F1 slave will issue their part of the F1 query to Spanner.</li>\n          <li>The “Spanner Query” gets served and Spanner returns a data stream back to F1 slaves.</li>\n          <li>The query coordinator aggregates the streamed results from F1 slaves. The implication is that ordering properties of input data are lost. The query coordinator can be a bottleneck and F1 queries can be distributed to be consumed by more than one consumer in parallel.</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>For writes, latency is about 50-150ms due to using Paxos algorithm to finally determine between different F1 replicas, if a write is allowed to commit. Web application read latency averages 200ms after using F1 largely due to the use of explicit clustering, heavy data streaming, asynchronous reads and systematic prevention anti-ORM patterns (e.g. serial reads, implicit traversal).</li>\n</ul>\n\n<p> </p>\n\n<p>Meta points:</p>\n\n<ul>\n  <li>Know about more than just relational database, and how databases are designed. Most of us just use databases.</li>\n  <li>An Google-ish view on how distributed system works, and ideas on how to work on latency/bottlenecks.</li>\n  <li>Perspectives on how to deal with anti-ORM patterns that works in practice.</li>\n</ul>\n\n<p> </p>\n\n<p>Why I wrote this? On this Thanksgiving weekend, I was sick and in this nightmarish dream I was asked to explain F1 to my audience in some university lecture. So here I am, my I-don’t-know-who audience and what you asked, hopefully this answers your questions. Time to take meds and rest.</p>",
  "pubDate": "Sat, 26 Nov 2016 11:00:12 +0000",
  "link": "http://www.chioka.in/google-f1-server-reading-summary",
  "guid": "http://www.chioka.in/google-f1-server-reading-summary",
  "category": [
    "Google",
    "Database",
    "Scalability",
    "Distributed Systems",
    "Distributed Systems",
    "Reading Summary"
  ]
}