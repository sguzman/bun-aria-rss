{
  "title": "Sparse Networks from Scratch: Faster Training without Losing Performance",
  "link": "https://timdettmers.com/2019/07/11/sparse-networks-from-scratch/",
  "comments": "https://timdettmers.com/2019/07/11/sparse-networks-from-scratch/#comments",
  "dc:creator": "Tim Dettmers",
  "pubDate": "Thu, 11 Jul 2019 13:07:26 +0000",
  "category": [
    "Deep Learning",
    "Sparse Training"
  ],
  "guid": "https://timdettmers.com/?p=774",
  "description": "<p>This blog post is about my work with Luke Zettlemoyer on fast training of neural networks which we keep sparse throughout training. We show that by developing an algorithm, sparse momentum, we can initialize a neural network with sparse random weights and train it to dense performance levels — all while doing just a single training run. Furthermore, If we use optimized sparse convolution algorithms, we can speed up training between 3.5x for VGG to 12x for Wide Residual Networks. This stands in stark contrast to computationally expensive methods which require repetitive prune-and-retrain cycles as used by the Lottery Ticket Hypothesis (Frankle and Carbin, 2019) and other work. Thus we show that training sparse networks to dense performance levels does not require \"winning the initialization lottery\" but can be done reliably from random weights if combined with a method that moves weights around the network in a smart way. We call the paradigm that maintains sparsity throughout training while maintaining dense performance levels sparse learning. While this work shows that sparse learning is possible, future work holds the promise to train larger and deep networks on more data while requiring the same or less computational resources as current dense networks.</p>\n<p>The post <a rel=\"nofollow\" href=\"https://timdettmers.com/2019/07/11/sparse-networks-from-scratch/\">Sparse Networks from Scratch: Faster Training without Losing Performance</a> appeared first on <a rel=\"nofollow\" href=\"https://timdettmers.com\">Tim Dettmers</a>.</p>\n",
  "content:encoded": "<p>This blog post is about my work, <a href=\"https://arxiv.org/abs/1907.04840\">Sparse Networks from Scratch: Faster Training without Losing Performance</a>, with <a href=\"https://www.cs.washington.edu/people/faculty/lsz\">Luke Zettlemoyer</a>&nbsp;on fast training of neural networks which we keep sparse throughout training. We show that by developing an algorithm, sparse momentum, we can initialize a neural network with sparse random weights and train it to dense performance levels — all while doing just a single training run. Furthermore, If we use optimized sparse convolution algorithms, we can speed up training between 3.5x for VGG to 12x for Wide Residual Networks. This stands in stark contrast to computationally expensive methods which require repetitive prune-and-retrain cycles as used by the Lottery Ticket Hypothesis (Frankle and Carbin, 2019) and other work. Thus we show that training sparse networks to dense performance levels does not require &#8220;winning the initialization lottery&#8221; but can be done reliably from random weights if combined with a method that moves weights around the network in a smart way. We call the paradigm that maintains sparsity throughout training while maintaining dense performance levels <em>sparse learning</em>. While this work shows that sparse learning is possible, future work holds the promise to train larger and deep networks on more data while requiring the same or less computational resources as current dense networks.</p>\n<p><span id=\"more-774\"></span></p>\n<h2>Why Sparse Learning?</h2>\n<p>A significant driver of progress in deep learning has been advances in computational resources. From 2010 to 2018 we saw an increase of 9700% in computational GPU performance. However, we can expect increases of just little more than 80% GPU performance in the next 5-8 years due to reaching the physical limits of semiconductor technology. What does a research world look like where we cannot make further improvements in computational power?</p>\n<p>A glimpse of this comes from the natural language processing (NLP) community where pretrained language models like ELMO, GPT, BERT, GPT-2, Grover, and XL-Net dominate the entire field by outperforming other methods on most NLP tasks. These models are often rather simple: You train them on lots of documents, and the task is mainly to predict a word given a sequence of other words&nbsp;— a bit like doing a fill-in-the-blank puzzle. The catch? These models are so big that they take well in excess of 100 GPUs hours to train. This is particularly frustrating for academic researchers that want to understand these models but are unable to do so because they lack the computational resources that big companies have. To truly understand these massive pretrained language models, a primary goal should be to democratize the training of these models by developing more resourceful training procedures.</p>\n<p>One way to achieve this is to look at the human brain for inspiration. The human brain consumes 1/10th of the energy of a GPU but is 10^9 times more powerful. What makes the brain so computational efficient? <a href=\"https://timdettmers.com/2015/07/27/brain-vs-deep-learning-singularity/\">There are many reasons</a>, but one reason is<em> sparsity</em>.</p>\n<p>It has been found that the more neurons a primate brain has the fewer connections does the average neuron make with all other neurons (Herculano-Houzel et al., 2010). This is very much contrary to how we design deep neural networks, which is to connect every new neuron in a layer with all neurons in the previous layer. We already understand how to compress a fully trained dense network to a sparse network (Han et al., 2015), but there has been little work on how to do this successfully if one starts from a sparse network which we keep sparse during training. How do we do this?</p>\n<h2>Sparse Momentum: An Efficient Way to Train Sparse Networks</h2>\n<p>This section explains the sparse momentum algorithm from intutiton up to the full algorithm.</p>\n<p><figure id=\"attachment_779\" aria-describedby=\"caption-attachment-779\" style=\"width: 1096px\" class=\"wp-caption aligncenter\"><a href=\"https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/sparse_momentum.png?ssl=1\"><img data-attachment-id=\"779\" data-permalink=\"https://timdettmers.com/2019/07/11/sparse-networks-from-scratch/sparse_momentum/\" data-orig-file=\"https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/sparse_momentum.png?fit=1096%2C528&ssl=1\" data-orig-size=\"1096,528\" data-comments-opened=\"1\" data-image-meta=\"{\"aperture\":\"0\",\"credit\":\"\",\"camera\":\"\",\"caption\":\"\",\"created_timestamp\":\"0\",\"copyright\":\"\",\"focal_length\":\"0\",\"iso\":\"0\",\"shutter_speed\":\"0\",\"title\":\"\",\"orientation\":\"0\"}\" data-image-title=\"Sparse Momentum Dettmers &#038; Zettlemoyer 2019\" data-image-description=\"<p>Figure X: The sparse training algorithm developed has three stages: (1) Determine the importance of each layer. (2) Remove the smallest, unimportant weights. (3) Grow new weights proportional to the importance of each layers.</p>\n\" data-image-caption=\"<p>Figure X: The sparse training algorithm developed has three stages: (1) Determine the importance of each layer. (2) Remove the smallest, unimportant weights. (3) Grow new weights proportional to the importance of each layers.</p>\n\" data-medium-file=\"https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/sparse_momentum.png?fit=300%2C145&ssl=1\" data-large-file=\"https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/sparse_momentum.png?fit=1024%2C493&ssl=1\" class=\"wp-image-779 size-full\" src=\"https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/sparse_momentum.png?resize=1096%2C528&#038;ssl=1\" alt=\"Sparse Momentum determines where to grow new weights in a sparse network by looking at the weighted average of recent gradients (momentum) to find weights and layers which reduce the error consistently. (1) We determine the importance of each layer according to the mean momentum magnitude. (2) For each layer, we remove the 50\\% of the smallest weights. (3) We then redistribute the weights across layers according to layer importance. Within a layer we grow weights where the momentum magnitude is large.\" width=\"1096\" height=\"528\" srcset=\"https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/sparse_momentum.png?w=1096&ssl=1 1096w, https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/sparse_momentum.png?resize=300%2C145&ssl=1 300w, https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/sparse_momentum.png?resize=768%2C370&ssl=1 768w, https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/sparse_momentum.png?resize=1024%2C493&ssl=1 1024w\" sizes=\"(max-width: 1000px) 100vw, 1000px\" data-recalc-dims=\"1\" /></a><figcaption id=\"caption-attachment-779\" class=\"wp-caption-text\">Figure 1: Sparse Momentum determines where to grow new weights in a sparse network by looking at the weighted average of recent gradients (momentum) to find weights and layers which reduce the error consistently. (1) We determine the importance of each layer according to the mean momentum magnitude. (2) For each layer, we remove the 50% of the smallest weights. (3) We then redistribute the weights across layers according to layer importance. Within a layer we grow weights where the momentum magnitude is large.</figcaption></figure></p>\n<h3>What is the Main Quality of Good Sparse Learning Algorithms?</h3>\n<p>In sparse learning, the most important thing is to use every single weight in a neural network as effectively as possible. If you define &#8220;effectiveness&#8221; as &#8220;reducing the error,&#8221; then we have an obvious perspective on how we can proceed. We need to find a measure which describes how effective a weight is at reducing the error and remove all weights which do not. Once we removed weights, we want to regrow new weights in locations which we think are promising at reducing the error in the future.</p>\n<p>If we look at the gradient of the error with respect to the weight, we actually have precisely such a measure. However, if we look at successive gradients, we find that gradients can wildly oscillate. For example if you have a neural network which classifies handwritten digits 0 to 9 then a weight might be good at detecting a straight line at the top and it might help to reduce the error for the numbers 5, 7 but then it might not help or even be detrimental for numbers 0, 1, 2, 3, 6, 8, 9. Instead, a weight which detects a curvy pattern in the top right might help for 0, 2, 3, 8, 9 and as such we would expect that this weight reduces the error more consistently over time than the &#8220;straight line at the top&#8221; weight. How can we detect such promising weights in a neural network automatically?</p>\n<h3>Momentum: Finding Weights that Reduce the Error Consistently</h3>\n<p>If you take the north pole to be a local minimum and a compass needle the gradient towards the local minimum, then you can simulate stochastic gradient descent updates by shaking the compass wildly to spin the compass needle. With every time the needle passes the north pole it will slow down and line-up more and more with the north pole, however, due to the spin it will still &#8220;overshoot&#8221; that direction. So it might be unclear where the north pole is from two or three measurements while the needle is still moving back and forth. However, if you take the average directions&nbsp;— one time the needle is a bit to the left of the north pole, another time it is more to the right&nbsp;— then these deviations cancel out, and you will immediately get a direction which is very close to the real north pole.</p>\n<p>This is the main idea behind the momentum optimization technique: We average successive gradients to get a better estimate of the direction of the local minimum. Similarly to the compass needle, which gets more and more accurate over time as it slows down, we want to weight more recent gradient directions in stochastic gradient descent more highly. One way to do this is to assign a weighted average where we assign a much larger weight to the current gradient and a small weight to the previous gradients&nbsp;— this is called exponential smoothing. Through exponential smoothing the gradients of the weight we receive a weighted gradient matrix — this matrix is the momentum matrix which gives momentum optimization its name. With this measure, we can identify which are the weights which reduce the error consistently.</p>\n<h3>Redistributing Weights: The Mean Momentum Magnitude of a Layer</h3>\n<p>From here we make the first important observation for our sparse momentum algorithm: If the momentum of a weight indicates how much it reduces the error consistently, then the mean momentum magnitude of all the weights in a layer should indicate how much each layer is reducing the error on average. We take the magnitude because two different weights might consistently go into a negative direction and a positive direction. By taking the mean momentum magnitude of layers, we can easily compare how effective the average weight in each layer is. This enables to say, for example, that a weight in a convolutional layer A is on average 1/3 as effective at reducing the error as the average weight in fully connected layer B, or vice versa. This method enables us to redistribute weights effectively: if we find &#8220;useless&#8221; weights, we now know precisely in which layer to put it&nbsp;— but where to put them exactly within a layer?</p>\n<h3>Which Weights Should be Removed? Where to Regrow them?</h3>\n<p>The next two problems are more straightforward: Which are the most useless weights? Where do we grow weights within a layer? The first problem is a common problem in neural network compression research, where one often prunes the weights with the smallest magnitude. Why does this make sense? If we assume all weights receive on average inputs of similar magnitude&nbsp;— a reasonable assumption if one uses batch normalization&nbsp;— then weights with small magnitudes make the smallest difference in the activation of a neuron. As such, removing them should change the predictive performance of our networks by the smallest amount.</p>\n<p>Once we removed weights and redistributed them to weight-effective layers as measured by the mean momentum magnitude of a layer, we need to decide where exactly to grow them within a layer. One possible solution becomes apparent if we ask: &#8220;Which two unconnected neurons would reduce the error consistently if we connect them?&#8221; The answer to this question would again point to the momentum magnitude. This time, however, we want to look at the momentum magnitude of &#8220;missing&#8221; or zero-valued weights, that is, we want to look at those weights which have been excluded from training before. Thus we grow weights in locations where missing weights have the largest momentum magnitude. This completes the sparse momentum algorithm, which depicted in Figure 1.</p>\n<h2>Results</h2>\n<p>The results are quite impressive! We compared against compression algorithms on MNIST, where sparse momentum outperforms most other methods. This is a pretty good result given that compression methods start from a dense network and usually retrain repetitively while we train a sparse network from scratch! Another impressive result is that we can match or even exceed the performance of dense networks by using 20% of weights (80% sparsity). On CIFAR-10, we compare against Single-shot Network Pruning which is designed for simplicity and not performance&nbsp;— so it is not surprising that sparse momentum does better. However, what is interesting is that we can train both VGG16-D (a version of VGG16 with two fully connected layers) and Wide Residual Network (WRN) 16-10 (16 layers deep and very wide WRN) to dense performance levels with just 5% of weights. For other networks, sparse momentum comes close to dense performance levels. Furthermore, as I will show later, with an optimized sparse convolution algorithm, we would be able to train a variety of networks to yield the same performance levels while training between 3.0-5.6x faster!</p>\n<p>&nbsp;</p>\n<p><figure id=\"attachment_800\" aria-describedby=\"caption-attachment-800\" style=\"width: 1830px\" class=\"wp-caption aligncenter\"><a href=\"https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/sparse_momentum_vs_compression.png?ssl=1\"><img data-attachment-id=\"800\" data-permalink=\"https://timdettmers.com/2019/07/11/sparse-networks-from-scratch/sparse_momentum_vs_compression/\" data-orig-file=\"https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/sparse_momentum_vs_compression.png?fit=1830%2C697&ssl=1\" data-orig-size=\"1830,697\" data-comments-opened=\"1\" data-image-meta=\"{\"aperture\":\"0\",\"credit\":\"\",\"camera\":\"\",\"caption\":\"\",\"created_timestamp\":\"0\",\"copyright\":\"\",\"focal_length\":\"0\",\"iso\":\"0\",\"shutter_speed\":\"0\",\"title\":\"\",\"orientation\":\"0\"}\" data-image-title=\"sparse_momentum_vs_compression\" data-image-description=\"\" data-image-caption=\"\" data-medium-file=\"https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/sparse_momentum_vs_compression.png?fit=300%2C114&ssl=1\" data-large-file=\"https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/sparse_momentum_vs_compression.png?fit=1024%2C390&ssl=1\" class=\"wp-image-800 size-full\" src=\"https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/sparse_momentum_vs_compression.png?resize=1830%2C697&#038;ssl=1\" alt=\"Sparse Momentum results compared to neural network compression methods on MNIST for LeNet-300-100 and LeNet-5 Caffe.\" width=\"1830\" height=\"697\" srcset=\"https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/sparse_momentum_vs_compression.png?w=1830&ssl=1 1830w, https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/sparse_momentum_vs_compression.png?resize=300%2C114&ssl=1 300w, https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/sparse_momentum_vs_compression.png?resize=768%2C293&ssl=1 768w, https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/sparse_momentum_vs_compression.png?resize=1024%2C390&ssl=1 1024w\" sizes=\"(max-width: 1000px) 100vw, 1000px\" data-recalc-dims=\"1\" /></a><figcaption id=\"caption-attachment-800\" class=\"wp-caption-text\">Sparse Momentum results compared to neural network compression methods on MNIST for LeNet-300-100 and LeNet-5 Caffe.</figcaption></figure></p>\n<p>&nbsp;</p>\n<p><figure id=\"attachment_801\" aria-describedby=\"caption-attachment-801\" style=\"width: 1024px\" class=\"wp-caption aligncenter\"><a href=\"https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/imagenet_results.png?ssl=1\"><img data-attachment-id=\"801\" data-permalink=\"https://timdettmers.com/2019/07/11/sparse-networks-from-scratch/imagenet_results/\" data-orig-file=\"https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/imagenet_results.png?fit=1062%2C388&ssl=1\" data-orig-size=\"1062,388\" data-comments-opened=\"1\" data-image-meta=\"{\"aperture\":\"0\",\"credit\":\"\",\"camera\":\"\",\"caption\":\"\",\"created_timestamp\":\"0\",\"copyright\":\"\",\"focal_length\":\"0\",\"iso\":\"0\",\"shutter_speed\":\"0\",\"title\":\"\",\"orientation\":\"0\"}\" data-image-title=\"imagenet_results\" data-image-description=\"\" data-image-caption=\"\" data-medium-file=\"https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/imagenet_results.png?fit=300%2C110&ssl=1\" data-large-file=\"https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/imagenet_results.png?fit=1024%2C374&ssl=1\" class=\"wp-image-801 size-large\" src=\"https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/imagenet_results.png?resize=1024%2C374&#038;ssl=1\" alt=\"ImageNet results for Sparse momentum and related methods. For the models that are not fully sparse, the first convolution and all downsample residual connections are dense from the start of training. In the fully sparse setting, all layers are sparse. Sparse momentum works better than other methods and works almost equally well if all the weights are sparse. This indicates that sparse momentum is efficient at finding important layers which require a high density.\" width=\"1024\" height=\"374\" srcset=\"https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/imagenet_results.png?resize=1024%2C374&ssl=1 1024w, https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/imagenet_results.png?resize=300%2C110&ssl=1 300w, https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/imagenet_results.png?resize=768%2C281&ssl=1 768w, https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/imagenet_results.png?w=1062&ssl=1 1062w\" sizes=\"(max-width: 1000px) 100vw, 1000px\" data-recalc-dims=\"1\" /></a><figcaption id=\"caption-attachment-801\" class=\"wp-caption-text\">ImageNet results for Sparse momentum and related methods. For the models that are not fully sparse, the first convolution and all downsample residual connections are dense from the start of training. In the fully sparse setting, all layers are sparse. Sparse momentum works better than other methods and works almost equally well if all the weights are sparse. This indicates that sparse momentum is efficient at finding important layers which require a high density.</figcaption></figure></p>\n<p>On ImageNet, we are not able to reach dense performance levels, which indicates that there is room to improve sparse momentum. However, we can demonstrate that sparse momentum has a clear lead compared to other methods that maintain sparse weights throughout training.</p>\n<h3>Speedups</h3>\n<p>The main promise of sparse learning was to accelerate training&nbsp;— were we successful? Yes&nbsp;— and no. Sparse momentum accelerates training efficiently if we measure possible speedups for sparse convolution, but since sparse networks were only very recently used for training, no optimized sparse convolution algorithms exist for the GPU&nbsp;— at least not for the fine-grained sparse patterns of weights as exhibited by sparse momentum.</p>\n<p>As such, we divide the speedups into two groups: Possible speedups which could be achieved if sparse convolution algorithms would exist, and speedups which we can achieve today with standard dense convolutional algorithms. How can dense convolutions help for sparse networks?</p>\n<p>If we look at the sparsity pattern of our network, we have the case where a convolutional channel is entirely empty&nbsp;— a convolutional filter full of zeros! If this happens, we can remove the channel from the computation without changing the results of the convolution and thus gain speedups.</p>\n<p>&nbsp;</p>\n<p><figure id=\"attachment_799\" aria-describedby=\"caption-attachment-799\" style=\"width: 1024px\" class=\"wp-caption aligncenter\"><a href=\"https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/dense_equivalents.png?ssl=1\"><img data-attachment-id=\"799\" data-permalink=\"https://timdettmers.com/2019/07/11/sparse-networks-from-scratch/dense_equivalents/\" data-orig-file=\"https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/dense_equivalents.png?fit=1096%2C468&ssl=1\" data-orig-size=\"1096,468\" data-comments-opened=\"1\" data-image-meta=\"{\"aperture\":\"0\",\"credit\":\"\",\"camera\":\"\",\"caption\":\"\",\"created_timestamp\":\"0\",\"copyright\":\"\",\"focal_length\":\"0\",\"iso\":\"0\",\"shutter_speed\":\"0\",\"title\":\"\",\"orientation\":\"0\"}\" data-image-title=\"dense_equivalents\" data-image-description=\"\" data-image-caption=\"\" data-medium-file=\"https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/dense_equivalents.png?fit=300%2C128&ssl=1\" data-large-file=\"https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/dense_equivalents.png?fit=1024%2C437&ssl=1\" class=\"wp-image-799 size-large\" src=\"https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/dense_equivalents.png?resize=1024%2C437&#038;ssl=1\" alt=\"\" width=\"1024\" height=\"437\" srcset=\"https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/dense_equivalents.png?resize=1024%2C437&ssl=1 1024w, https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/dense_equivalents.png?resize=300%2C128&ssl=1 300w, https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/dense_equivalents.png?resize=768%2C328&ssl=1 768w, https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/dense_equivalents.png?w=1096&ssl=1 1096w\" sizes=\"(max-width: 1000px) 100vw, 1000px\" data-recalc-dims=\"1\" /></a><figcaption id=\"caption-attachment-799\" class=\"wp-caption-text\">Sparse momentum can replicate dense performance levels for a range of networks with a fraction of the weights thus leading to speedups.</figcaption></figure></p>\n<p>However, if we look at the speedups, we see there is a marked difference between sparse convolution and dense convolution speedups. This clearly shows the need for optimized sparse convolution algorithms for the GPU.</p>\n<h2>Why does Sparse Learning Work?</h2>\n<p>Some of our sparse networks trained with sparse momentum matched the performance levels of dense networks with just 5% of weights. What makes these 5% of weights so efficient that they can match a neural network with 20 times as many weights?</p>\n<p>To look into this question, we looked at how the features of sparse networks compare to dense networks. Low-level features might include things like edge detectors. Mid-level features might be things like wheels, noses, eyes, paws. High-level features might be the &#8220;face&#8221; of a car, a cat face, a fridge door, and so forth.</p>\n<p>To reduce features to numbers we look at convolutional channels&nbsp;— the equivalent to a &#8220;neuron&#8221; in a convolutional network&nbsp;— and how useful the channel is to classes in the dataset. Edge detectors should be useful to almost all classes in the dataset&nbsp;— in other words, they should have a low level of class-specialization. Mid-level features like eyes should be useful to—some classes such as cats, dogs, and humans. High-level features should be useful to a few selected classes&nbsp;— they are highly class-specialized.</p>\n<p><figure id=\"attachment_778\" aria-describedby=\"caption-attachment-778\" style=\"width: 1016px\" class=\"wp-caption aligncenter\"><a href=\"https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/sparse_features.png?ssl=1\"><img data-attachment-id=\"778\" data-permalink=\"https://timdettmers.com/2019/07/11/sparse-networks-from-scratch/sparse_features/\" data-orig-file=\"https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/sparse_features.png?fit=1016%2C1098&ssl=1\" data-orig-size=\"1016,1098\" data-comments-opened=\"1\" data-image-meta=\"{\"aperture\":\"0\",\"credit\":\"\",\"camera\":\"\",\"caption\":\"\",\"created_timestamp\":\"0\",\"copyright\":\"\",\"focal_length\":\"0\",\"iso\":\"0\",\"shutter_speed\":\"0\",\"title\":\"\",\"orientation\":\"0\"}\" data-image-title=\"sparse_features\" data-image-description=\"\" data-image-caption=\"\" data-medium-file=\"https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/sparse_features.png?fit=278%2C300&ssl=1\" data-large-file=\"https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/sparse_features.png?fit=948%2C1024&ssl=1\" class=\"wp-image-778 size-full\" src=\"https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/sparse_features.png?resize=1016%2C1098&#038;ssl=1\" alt=\"Figure 6: Class-specialization histograms for sparse and dense networks for AlexNet, VGG16 and WRN 28-2.\" width=\"1016\" height=\"1098\" srcset=\"https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/sparse_features.png?w=1016&ssl=1 1016w, https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/sparse_features.png?resize=278%2C300&ssl=1 278w, https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/sparse_features.png?resize=768%2C830&ssl=1 768w, https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/sparse_features.png?resize=948%2C1024&ssl=1 948w\" sizes=\"(max-width: 1000px) 100vw, 1000px\" data-recalc-dims=\"1\" /></a><figcaption id=\"caption-attachment-778\" class=\"wp-caption-text\">Figure 6: Class-specialization histograms for sparse and dense networks for AlexNet, VGG16 and WRN 28-2.</figcaption></figure></p>\n<p>What we find is that on average, sparse networks learn features which are useful to a broader range of classes&nbsp;— they learn more general features. This might be a possible explanation of why sparse networks can match the performance of dense networks with as few as 5% weights.</p>\n<h2>The Future of Sparse Learning</h2>\n<p>I believe sparse learning has a very bright future because (1) GPUs will stagnate in performance over the next years, (2) specialized processors for sparse workloads, Graphcore processors, are around the corner. Graphcore processors store an entire network in its 300 MB cache and accelerate it by a factor of roughly 100x. This means, if we can compress a network to 300 MB during training, then we will have 100x faster training overall. Training a ResNet-50 on ImageNet would then take only roughly 15 minutes using one Graphcore processor. With sparse learning, the 300 MB limit will be in reach without a problem.</p>\n<p>My prediction is that the first research team that can train a sparse neural network on a Graphcore processor successfully will unlock an entirely new level of artificial intelligence.</p>\n<p>Besides this, another challenge is to apply sparse learning algorithms to natural language processing (NLP). Unsurprisingly, my experimentation on transformers for natural language processing tasks show that sparse learning is much more difficult in NLP compared to computer vision&nbsp;— lots of work to do!</p>\n<h2>Try Sparse Momentum with Your Own Model in 10 Lines of Code!</h2>\n<p><figure id=\"attachment_781\" aria-describedby=\"caption-attachment-781\" style=\"width: 766px\" class=\"wp-caption aligncenter\"><a href=\"https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/code.png?ssl=1\"><img data-attachment-id=\"781\" data-permalink=\"https://timdettmers.com/2019/07/11/sparse-networks-from-scratch/code/\" data-orig-file=\"https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/code.png?fit=766%2C533&ssl=1\" data-orig-size=\"766,533\" data-comments-opened=\"1\" data-image-meta=\"{\"aperture\":\"0\",\"credit\":\"\",\"camera\":\"\",\"caption\":\"\",\"created_timestamp\":\"0\",\"copyright\":\"\",\"focal_length\":\"0\",\"iso\":\"0\",\"shutter_speed\":\"0\",\"title\":\"\",\"orientation\":\"0\"}\" data-image-title=\"code\" data-image-description=\"\" data-image-caption=\"\" data-medium-file=\"https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/code.png?fit=300%2C209&ssl=1\" data-large-file=\"https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/code.png?fit=766%2C533&ssl=1\" class=\"wp-image-781 size-full\" src=\"https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/code.png?resize=766%2C533&#038;ssl=1\" alt=\"Figure 7: Example of a generic sparse learning script which you can use for your own model. With my sparselearning library it is easy to use sparse momentum: (1) Import the library, (2) add the parser options, (3) wrap your model with the Masking class, (4) apply mask instead of optimizer, (5) apply sparse momentum at the end of epoch. The library is also easily extendable with your own sparse learning algorithms for growth, pruning, or redistribution -- all it takes is a few lines of code!\" width=\"766\" height=\"533\" srcset=\"https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/code.png?w=766&ssl=1 766w, https://i0.wp.com/timdettmers.com/wp-content/uploads/2019/07/code.png?resize=300%2C209&ssl=1 300w\" sizes=\"(max-width: 766px) 100vw, 766px\" data-recalc-dims=\"1\" /></a><figcaption id=\"caption-attachment-781\" class=\"wp-caption-text\">Figure 7: Example of a generic sparse learning script which you can use for your own model. With my sparselearning library it is easy to use sparse momentum: (1) Import the library, (2) add the parser options, (3) wrap your model with the Masking class, (4) apply mask instead of optimizer, (5) apply sparse momentum at the end of epoch. The library is also easily extendable with your own sparse learning algorithms for growth, pruning, or redistribution&nbsp;— all it takes is a few lines of code!</figcaption></figure></p>\n<p>To make sparse learning accessible to everyone I developed a sparse learning library which allows the easy application of existing algorithms like sparse momentum to your own models&nbsp;— it can be done in less than 10 lines of code. The library is also designed to make it very easy to add your own sparse learning methods. You find my <a href=\"https://github.com/TimDettmers/sparse_learning\">sparse learning library</a> on GitHub.</p>\n<h3>Questions?</h3>\n<p>For questions, I prefer if you post them below if they are simple and straightforward. If you have a more formal question regarding our work that requires careful answers, you can post an the question as <a href=\"https://github.com/TimDettmers/sparse_learning/issues\">a GitHub issue</a>&nbsp;— I will try to answer as timely as possible.</p>\n<h4>Acknowledgements</h4>\n<p>I thank Luke Zettlemoyer for feedback on an early draft of this blog post.</p>\n<h3>References</h3>\n<p>Frankle, J. and Carbin, M. (2019). The lottery ticket hypothesis: Finding sparse, trainable neural networks. In <em>ICLR 2019</em>.</p>\n<p>Han, S., Pool, J., Tran, J., and Dally, W. (2015). Learning both weights and connections for efficient neural network. In <em>Advances in neural information processing systems</em>, pages<br />\n1135—1143.</p>\n<p>Herculano-Houzel, S., Mota, B., Wong, P., and Kaas, J.H. (2010). Connectivity-driven white matter scaling and folding in primate cerebral cortex. In&nbsp;<em>Proceedings of the National Academy of Sciences of the United States of America</em>, 107 44:19008—13.</p>\n<p>&nbsp;</p>\n<p>The post <a rel=\"nofollow\" href=\"https://timdettmers.com/2019/07/11/sparse-networks-from-scratch/\">Sparse Networks from Scratch: Faster Training without Losing Performance</a> appeared first on <a rel=\"nofollow\" href=\"https://timdettmers.com\">Tim Dettmers</a>.</p>\n",
  "wfw:commentRss": "https://timdettmers.com/2019/07/11/sparse-networks-from-scratch/feed/",
  "slash:comments": 38,
  "post-id": 774
}