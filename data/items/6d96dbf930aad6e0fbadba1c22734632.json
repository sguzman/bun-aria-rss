{
  "title": "3D Mutant Mfers Contract Review",
  "link": "https://streamhacker.com/2022/04/04/3d-mutant-mfers-contract-review/#utm_source=feed&#038;utm_medium=feed&#038;utm_campaign=feed",
  "comments": "https://streamhacker.com/2022/04/04/3d-mutant-mfers-contract-review/#respond",
  "dc:creator": "Jacob",
  "pubDate": "Mon, 04 Apr 2022 13:34:40 +0000",
  "category": [
    "contracts",
    "erc721",
    "eth",
    "gas",
    "mfers",
    "mint",
    "nft",
    "signatures",
    "slither",
    "solidity",
    "token"
  ],
  "guid": "https://streamhacker.com/?p=2236",
  "description": "Contract review of 3DMutantMfers, a new project from the creator of 3DMfers and Cosmo Creatures.",
  "content:encoded": "\n<p><a href=\"https://www.3dmutantmfers.com/\">3DMutantMfers</a> is a new NFT collection by <a href=\"https://linktr.ee/scott_visuals\">@scott_visuals</a>. He is also the artist and creator of <a href=\"https://opensea.io/collection/3d-mfrs\">3DMfers</a> and <a href=\"https://opensea.io/collection/cosmo-creatures\">Cosmo Creatures</a>. For this mint, the team wanted to reward holders of 3DMfers and Cosmo Creatures with free mints, while still keeping public mints very affordable at 0.029 ETH. The idea with the free mint was that you would be able to get 1 3DMutantMfer for each 3DMfer or Cosmo Creature you held. Unfortunately, there was a bug in the contract function that caused the free claim to fail for most people. Let&#8217;s dig in to the <a href=\"https://etherscan.io/address/0x09f589e03381b767939ce118a209d474cc6d52fc#code\">contract code</a>.</p>\n\n\n\n<h2>Public Mint</h2>\n\n\n\n<p>Let&#8217;s start with the public <code>mint</code> function, which works great and is very simple.</p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-solidity\">  function mint( uint numberOfTokens ) external payable mintCompliance( numberOfTokens ) {\n    require( msg.value >= price * numberOfTokens, \"Ether value sent is not correct\" );\n\n    _mintLoop( msg.sender, numberOfTokens );    \n  }</code></pre>\n\n\n\n<p>The <code>mint</code> function takes in the number of tokens you want to mint, ensures that you&#8217;ve sent the correct amount of ETH (0.029 * <code>numberOfTokens</code>), then calls <code>_mintLoop</code> with <code>msg.sender</code> (your wallet address).</p>\n\n\n\n<h2>Mint Compliance</h2>\n\n\n\n<p>Before you can mint, there&#8217;s a number of conditions that are checked by <code>mintCompliance</code>.</p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-solidity\">  modifier mintCompliance( uint numberOfTokens ) {\n    require( isActive,                            \"Sale must be active to mint 3DMutantMfers\" );\n    require( numberOfTokens <= maxOrder,          \"Can only mint 20 tokens at a time\" );\n    require( numberOfTokens > 0,                  \"Token Mint Count must be > 0\" );\n\n    uint256 supply = _owners.length;\n    require( supply + numberOfTokens <= MAX_SUPPLY, \"Purchase would exceed max supply of 3DMutantMfers\" );\n    \n    uint256 mintedCount = addressMintedBalance[msg.sender];\n    require(mintedCount + numberOfTokens <= MAX_PER_WALLET, \"Max NFT per address exceeded\");\n\n    _;\n  }</code></pre>\n\n\n\n<p>The <code>mintCompliance</code> modifier function is also used by the <code>freeClaimMint</code> function covered below. It checks for the following conditions:</p>\n\n\n\n<ul><li>Minting is active</li><li>You are minting at least one token but not more than 20</li><li>You can&#8217;t exceed the total supply of 4444 tokens</li><li>You can&#8217;t mint more than 1000 tokens into 1 wallet</li></ul>\n\n\n\n<p>All of these numbers can be changed by the contract owner, with the restriction that total supply cannot be set lower than the number of tokens. The functions that allow these modifications are below:</p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-solidity\"> function setActive(bool isActive_) external onlyOwner {\n    if( isActive != isActive_ )\n      isActive = isActive_;\n  }\n\n  function setMaxOrder(uint maxOrder_) external onlyOwner {\n    if( maxOrder != maxOrder_ )\n      maxOrder = maxOrder_;\n  }\n\n  function setPrice(uint price_ ) external onlyOwner {\n    if( price != price_ )\n      price = price_;\n  }\n\n  function setMaxSupply(uint maxSupply_ ) external onlyOwner {\n    if( MAX_SUPPLY != maxSupply_ ){\n      require(maxSupply_ >= _owners.length, \"Specified supply is lower than current balance\" );\n      MAX_SUPPLY = maxSupply_;\n    }\n  }\n\n  // Update Max Tokens A Wallet can mint\n  function setMaxPerWallet(uint maxPerWallet_ ) external onlyOwner {\n    if( MAX_PER_WALLET != maxPerWallet_ ){\n      MAX_PER_WALLET = maxPerWallet_;\n    }\n  }</code></pre>\n\n\n\n<h2>Mint Loop</h2>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-solidity\">  function _mintLoop(address _receiver, uint256 numberOfTokens) internal {\n    uint256 supply = _owners.length;\n\n    for (uint256 i = 0; i < numberOfTokens; i++) {\n      addressMintedBalance[_receiver]++;\n      _safeMint( _receiver, supply++, \"\" );\n    }\n  }</code></pre>\n\n\n\n<p>This function simply iterates through the number of tokens to mint, increments that number of tokens for your wallet (<code>_receiver</code>) then mints each token. This contract uses <a href=\"https://github.com/badbabybearbots/ERC721B\">ERC721B</a>, which is an implementation of <a href=\"https://docs.openzeppelin.com/contracts/3.x/erc721\">ERC721</a> optimized to reduce gas when minting multiple tokens. Because this is relatively new code, and not from <a href=\"https://docs.openzeppelin.com/contracts/4.x/\">OpenZeppelin</a> (the defacto standard library), it&#8217;s possible there&#8217;s some issues that haven&#8217;t been identified yet. However, the code in each function is relatively simple and very similar to standard ERC721 code. </p>\n\n\n\n<h2>Free Claim Mint</h2>\n\n\n\n<p>Let&#8217;s look at the <code>freeClaimMint</code>, which had an issue where most transactions attempts failed with &#8220;<code>Warning! Error encountered during contract execution [Out of gas]</code>&#8220;.</p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-solidity\">function freeClaimMint( uint numberOfTokens, bytes memory signature, string[] memory contract1TokenIds, string[] memory contract2TokenIds ) external mintCompliance( numberOfTokens ) {\n    \n    require(verifySender(signature, contract1TokenIds, contract2TokenIds), \"Invalid Access\");\n\n    // Check to make sure there are token ids\n    require(contract1TokenIds.length > 0 || contract2TokenIds.length > 0, \"Empty Token IDs\");\n\n    uint totalTokenIds = contract1TokenIds.length + contract2TokenIds.length;\n    require(totalTokenIds == numberOfTokens, \"Token IDs and Mint Count mismatch\");\n\n    // Lets make sure we are not claiming for already claimed tokens of contract 1\n    bool isValidTokenIds = true;\n    for (uint i = 0; isValidTokenIds && i < contract1TokenIds.length; i++) {\n      for (uint j = 0; isValidTokenIds && j < contract1ClaimedTokensCount; j++) {\n        string memory contractClaimedToken = contract1ClaimedTokens[j];\n        string memory tokenToClaim = contract1TokenIds[i];\n\n        if (keccak256(bytes(tokenToClaim)) == keccak256(bytes(contractClaimedToken))) {\n          isValidTokenIds = false;\n        }\n      } \n    } \n    require(isValidTokenIds, \"Cosmo Creatures Token ID passed is already claimed\");\n\n    // Lets make sure we are not claiming for already claimed tokens of contract 2\n    for (uint i = 0; isValidTokenIds && i < contract2TokenIds.length; i++) {\n      for (uint j = 0; isValidTokenIds && j < contract2ClaimedTokensCount; j++) {\n        string memory contractClaimedToken = contract2ClaimedTokens[j];\n        string memory tokenToClaim = contract2TokenIds[i];\n\n        if (keccak256(bytes(tokenToClaim)) == keccak256(bytes(contractClaimedToken))) {\n          isValidTokenIds = false;\n        }\n      } \n    } \n    require(isValidTokenIds, \"3D Mfrs Token ID passed is already claimed\");\n\n\n    for (uint i = 0; i < contract1TokenIds.length; i++) {\n      contract1ClaimedTokensCount++;\n      contract1ClaimedTokens.push(contract1TokenIds[i]);\n    }\n    \n    for (uint i = 0; i < contract2TokenIds.length; i++) {\n      contract2ClaimedTokensCount++;\n      contract2ClaimedTokens.push(contract2TokenIds[i]);\n    }\n\n    _mintLoop( msg.sender, numberOfTokens );\n  }</code></pre>\n\n\n\n<p>As you can see, this is quite a complicated function. You can compare it to the <a href=\"https://streamhacker.com/2022/03/30/dadmfers-background-mfers-contract-review/#utm_source=feed&utm_medium=feed&utm_campaign=feed\">BackgroundMfers minting functions</a> to see how much simpler their implementation is for each free claim function. In this case, the intention was to provide a single function that would mint 1 or more tokens depending on how many you owned from 3DMfers and Cosmo Creatures. But for most people that tried this, the transaction failed, losing them gas. The team is very supportive of their community, though, and they very quickly responded by:</p>\n\n\n\n<ol><li>announcing the problem</li><li>removing the free claim button from their website</li><li>refunding gas fees to everyone that had a failed transaction</li><li>creating a claim form and then airdropping 3DMutantMfers, at their own expense</li></ol>\n\n\n\n<p>Over 1.3 ETH is a somewhat expensive bug to pay for, but it builds a lot of good will, and makes it clear this is a quality team that&#8217;s not out for a quick cash grab. So what went wrong? I&#8217;m reminded of the <a href=\"https://peps.python.org/pep-0020/\">Zen of Python</a>: <em>explicit is better than implicit</em>. In the <a href=\"https://streamhacker.com/2022/03/30/dadmfers-background-mfers-contract-review/#utm_source=feed&utm_medium=feed&utm_campaign=feed\">BackgroundMfers minting functions</a>, they made everything very explicit:</p>\n\n\n\n<ul><li>each contract has its own minting function (mfers, dadmfers1, dadmfers2)</li><li>you have to select precisely which tokens from the external contract to mint with</li></ul>\n\n\n\n<p>For 3DMutantMfers, the team tried to make a very simple user experience, requiring a lot of implicit/hidden complexity that didn&#8217;t quite work. Let&#8217;s look at the code more.</p>\n\n\n\n<h2>Verify Signature</h2>\n\n\n\n<p>The very first line, after <code>mintCompliance</code>, is <code>verifySignature</code>, which checks that the function arguments have been signed by a known <code>signerAddress</code>.</p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-solidity\">  function verifySender(bytes memory signature, string[] memory contract1TokenIds, string[] memory contract2TokenIds) internal view returns (bool) {\n\n    string memory contract1TokensString = \"\";\n    string memory contract2TokensString = \"\";\n\n    for (uint i = 0; i < contract1TokenIds.length; i++) {\n      contract1TokensString = string(abi.encodePacked(contract1TokensString, contract1TokenIds[i], i < contract1TokenIds.length - 1 ? \",\" : \"\"));\n    }\n    \n    for (uint i = 0; i < contract2TokenIds.length; i++) {\n      contract2TokensString = string(abi.encodePacked(contract2TokensString, contract2TokenIds[i], i < contract2TokenIds.length - 1 ? \",\" : \"\"));\n    }\n\n    bytes32 hash = ECDSA.toEthSignedMessageHash(keccak256(abi.encodePacked(msg.sender, contract1TokensString, contract2TokensString)));\n    return ECDSA.recover(hash, signature) == signerAddress;\n  }</code></pre>\n\n\n\n<p>This means the website must be generating these signatures, hopefully on a backend server where the private key for the <code>signerAddress</code> is kept secure. There is a function to change the signer address, which could be used in case the key is compromised, or just as good practice <a href=\"https://crypto.stackexchange.com/questions/41796/whats-the-purpose-of-key-rotation\">key rotation</a>.</p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-solidity\">  function setSignerAddress(address _newSignerAddress) external onlyOwner {\n    signerAddress = _newSignerAddress;\n  }</code></pre>\n\n\n\n<h2>Token Validation</h2>\n\n\n\n<p>Next the function tries to validate the following:</p>\n\n\n\n<ul><li>There is at least 1 external contract token to check (3DMfers or Cosmo Creatures)</li><li>The number of tokens to mint matches the number of tokens that you own</li><li>The tokens to mint haven&#8217;t been claimed already</li></ul>\n\n\n\n<p>For the last point, this is done for each contract, and I&#8217;ve copied the first block below.</p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-solidity\">    // Lets make sure we are not claiming for already claimed tokens of contract 1\n    bool isValidTokenIds = true;\n    for (uint i = 0; isValidTokenIds && i < contract1TokenIds.length; i++) {\n      for (uint j = 0; isValidTokenIds && j < contract1ClaimedTokensCount; j++) {\n        string memory contractClaimedToken = contract1ClaimedTokens[j];\n        string memory tokenToClaim = contract1TokenIds[i];\n\n        if (keccak256(bytes(tokenToClaim)) == keccak256(bytes(contractClaimedToken))) {\n          isValidTokenIds = false;\n        }\n      } \n    } \n    require(isValidTokenIds, \"Cosmo Creatures Token ID passed is already claimed\");</code></pre>\n\n\n\n<h2>Minting</h2>\n\n\n\n<p>Finally, there&#8217;s 2 loops, 1 for each contract, to increment a counter and record which contract tokens have been claimed. I only included 1 loop below for brevity. Once the loops are completed, there&#8217;s a call to <code>_mintLoop</code> to finally mint the tokens.</p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-solidity\">    for (uint i = 0; i < contract2TokenIds.length; i++) {\n      contract2ClaimedTokensCount++;\n      contract2ClaimedTokens.push(contract2TokenIds[i]);\n    }\n\n    _mintLoop( msg.sender, numberOfTokens );</code></pre>\n\n\n\n<p>This final part seems simple enough, but it turns out this where the bug is. Let&#8217;s see what we can learn from <a href=\"https://github.com/crytic/slither\">slither</a>.</p>\n\n\n\n<h2>Slither Analysis</h2>\n\n\n\n<p><a href=\"https://github.com/crytic/slither\">Slither</a> is a python tool for static analysis of Solidity contracts. You can use it to get a quick summary of the contract code, and then look for any deeper issues.</p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-bash\">$ slither 0x09f589e03381b767939ce118a209d474cc6d52fc --print human-summary</code></pre>\n\n\n\n<figure class=\"wp-block-image size-large\"><a href=\"https://i0.wp.com/streamhacker.com/wp-content/uploads/2022/04/Screen-Shot-2022-04-02-at-9.53.48-PM.png?ssl=1\"><img decoding=\"async\" loading=\"lazy\" width=\"474\" height=\"346\" src=\"https://i0.wp.com/streamhacker.com/wp-content/uploads/2022/04/Screen-Shot-2022-04-02-at-9.53.48-PM.png?resize=474%2C346&#038;ssl=1\" alt=\"\" class=\"wp-image-2239\" srcset=\"https://i0.wp.com/streamhacker.com/wp-content/uploads/2022/04/Screen-Shot-2022-04-02-at-9.53.48-PM.png?resize=1024%2C748&ssl=1 1024w, https://i0.wp.com/streamhacker.com/wp-content/uploads/2022/04/Screen-Shot-2022-04-02-at-9.53.48-PM.png?resize=300%2C219&ssl=1 300w, https://i0.wp.com/streamhacker.com/wp-content/uploads/2022/04/Screen-Shot-2022-04-02-at-9.53.48-PM.png?resize=768%2C561&ssl=1 768w, https://i0.wp.com/streamhacker.com/wp-content/uploads/2022/04/Screen-Shot-2022-04-02-at-9.53.48-PM.png?w=1306&ssl=1 1306w, https://i0.wp.com/streamhacker.com/wp-content/uploads/2022/04/Screen-Shot-2022-04-02-at-9.53.48-PM.png?w=948&ssl=1 948w\" sizes=\"(max-width: 474px) 100vw, 474px\" data-recalc-dims=\"1\" /></a></figure>\n\n\n\n<p>As we&#8217;ve seen above, there&#8217;s definitely complex code. One less important issue identified is that there&#8217;s no <a href=\"https://github.com/crytic/slither/wiki/Detector-Documentation#missing-zero-address-validation\">check for a zero address</a> when setting the <code>signerAddress</code>. However, <code>signerAddress</code> is only used for the free claim, which shouldn&#8217;t be used anyway due to the bug. Almost all other issues are for the 11 dependency contracts, and none are significant. Except when you look at all the analysis, slither does identify the likely cause for the <a href=\"https://github.com/crytic/slither/wiki/Detector-Documentation#costly-operations-inside-a-loop\">out of gas error</a>:</p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-bash\">$ slither 0x09f589e03381b767939ce118a209d474cc6d52fc</code></pre>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-shell-session\">MutantMfers.freeClaimMint(uint256,bytes,string[],string[]) (MutantMfers.sol#1401-1450) has costly operations inside a loop:\n- contract1ClaimedTokensCount ++ (MutantMfers.sol#1440)\nMutantMfers.freeClaimMint(uint256,bytes,string[],string[]) (MutantMfers.sol#1401-1450) has costly operations inside a loop:\n- contract2ClaimedTokensCount ++ (MutantMfers.sol#1445)</code></pre>\n\n\n\n<p>Magmar, the creator of the BackgroundMfers contract, explained the issue in the <a href=\"https://discord.gg/yfC6y4yS6N\">Discord</a>:</p>\n\n\n\n<blockquote class=\"wp-block-quote\"><p>The issue here is out of gas. The problem is the free mint contract has two variable-gas for loops and is screwing with Metamask&#8217;s infura gas estimation fees. These functions were likely tested with low quantities but the gas usage will increase as minting increases, costing more and more gas, with a higher likelihood of failing. They will likely work if you gas up your transaction heavily, but you will spend 0.02+ for a free mint.</p></blockquote>\n\n\n\n<p>In other words, for users that had many 3DMfers and/or Cosmo Creatures, their wallet underestimated the gas fee required, causing the transaction to fail. Some people in the discord said they successfully got free claims by increasing the gas fee, which is a more advanced user behavior. Perhaps if a <a href=\"https://docs.openzeppelin.com/contracts/3.x/api/utils#Counters\">Counter</a> was used instead, everything would have worked great &#8211; lower gas fees and better wallet gas estimation. This is an excellent example of how different <a href=\"https://soliditylang.org/\">Solidity</a> and the <a href=\"https://ethereum.org/en/developers/docs/evm/\">EVM</a> are different from most other programming languages and environments, where incrementing a counter is simple and very cheap.</p>\n\n\n\n<h2>Conclusion</h2>\n\n\n\n<p>So what could have been done differently? As stated above, if <code>contract1ClaimedTokensCount</code> and <code>contract2ClaimedTokensCount</code> were <a href=\"https://docs.openzeppelin.com/contracts/3.x/api/utils#Counters\">Counters</a>, then maybe everything would have worked as intended. Also, it&#8217;s possible the counters were not even necessary. In all the instances that one of the counters is used, the corresponding array length (such as <code>contract2ClaimedTokens.length</code>) could have been used instead. Alternatively (or in addition to) they could have done the following:</p>\n\n\n\n<ul><li>separate claiming functions for 3DMfers and Cosmo Creatures</li><li>let users choose how many free tokens to mint, and which tokens to claim with</li><li>address any user experience changes on the website, such as an option to mint with all tokens from a contract (some people own quite a few Cosmo Creatures, so a &#8220;claim with all&#8221; button could be helpful)</li></ul>\n\n\n\n<p>The user experience would be a little different, but I doubt free minters would complain. And two more things that every contract creator should do:</p>\n\n\n\n<ol><li>Run <a href=\"https://github.com/crytic/slither\">slither</a> on your contract</li><li>Test every public function in many ways, with many inputs</li></ol>\n\n\n\n<p>Given the situation, what went right?</p>\n\n\n\n<ul><li>the team quickly notified everyone and removed the free claim button from the website</li><li>they refunded all the failed transactions</li><li>they provided a simple form for claiming free tokens, then airdropped them, paying the gas fee themselves</li><li>the public mint function worked great at a very affordable price</li><li><a href=\"https://opensea.io/collection/3dmutantmfers\">art was revealed</a> 24 hours later with ~25% of the collection minted, and many happy owners</li></ul>\n",
  "wfw:commentRss": "https://streamhacker.com/2022/04/04/3d-mutant-mfers-contract-review/feed/",
  "slash:comments": 0,
  "post-id": 2236
}