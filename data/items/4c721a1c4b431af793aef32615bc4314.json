{
  "title": "Headless RPi - prevent SD corruption",
  "description": "<p>Raspberry Pis are perfect when building interactive art projects (e.g. <a href=\"http://www.miketyka.com/?p=usandthem\">20 printers printing ML generated tweets</a>\nand often it’s nice to leave the Pi headless, i.e. without keyboard or monitor. And it’s convenient to just power up the device to start it and pull the power when its time to shut it down. However there are two minor issues - how do you get your code to start without a login and how do you precent system corruption. Thanksfully there are solutions to that.</p>\n\n<h2 id=\"startup-starting-your-code-on-startup\">Startup: Starting your code on startup.</h2>\n\n<p>There a <a href=\"https://www.dexterindustries.com/howto/run-a-program-on-your-raspberry-pi-at-startup/\">many solutions</a> for this \nbut personally I like to run my code as a service. To do so add a file like the one below to /etc/rc.d/ and make it executable.\nThis assumes your startup script lives in /home/you/mycode/run.sh and exepects to be run from that directory.</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>#! /bin/sh\n\n### BEGIN INIT INFO\n# Provides:             tweet_printer\n# Required-Start:       $remote_fs $syslog\n# Required-Stop:        $remote_fs $syslog\n# Default-Start:        2 3 4 5\n# Default-Stop:         0 1 6\n# Short-Description:    Tweet stream deamon\n### END INIT INFO\n\n. /lib/lsb/init-functions\n\nstart() {\n  log_action_begin_msg \"Starting tweet printer daemon\"\n\tcd /home/you/mycode/\n\tsh run.sh # OR python3 run.oy OR ./myexe \n  log_action_end_msg\n}\n\nstop() {\n  log_action_begin_msg \"Stopping tweet printer daemon\"\n  # &lt;Insert command to kill your process here&gt;\n  #\n  log_action_end_msg\n}\n\ncase \"$1\" in\n    start)\n      start\n  ;;\n    stop)\n      stop\n  ;;\n    restart)\n      stop\n      start\n  ;;\n    *)\n      echo \"Usage: &lt;MYSERVICENAME&gt; {start|stop|restart}\"\n      exit 1\n  ;;\nesac\nexit 0\n</code></pre></div></div>\n<p>After making the file, run</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>sudo chmod +x /etc/init.d/myscript \nsudo update-rc.d /etc/init.d/myscript defaults\n</code></pre></div></div>\n\n<p>Note your code will run as root.  Note this can also be a python program directly but i prefer the shell script to keep things more seperated.</p>\n\n<h2 id=\"shutdown-preventing-sd-corruption\">Shutdown: Preventing SD corruption</h2>\n\n<p>Linux systems do not like to to be powered off suddenly and this can lead to corruption of the filesystem on the SD card. \nLast time we faced this issue we researched a bunch of UPS-like soutions that would detect power failure and provide both bridge-over \npower and a signal to the Pi to cleanly shut down using extra electronics and super caps or batteries. \nHowever, there’s a much much simpler solution: just mount\nthe filesystem read only. This is not 100% straightforward and can have some drawbacks but for what we were doing it was perfect.\nDoing so makes the entire system completely stateless and thus unable to corrupt itself. THe drawback is you cannot persist any state from one boot to the next but there are aalso workarounds which we’ll discuss at the end. \nI’m basically following the instructions from <a href=\"http://ideaheap.com/2013/07/stopping-sd-card-corruption-on-a-raspberry-pi/\">http://ideaheap.com/2013/07/stopping-sd-card-corruption-on-a-raspberry-pi/</a> here, except that\nI go one more step and fully mount the system read-only. The lock/unlock scripts work around the usability issue.</p>\n\n<p>0) Disable swapping</p>\n\n<p>This will disable swapping:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>sudo dphys-swapfile swapoff\nsudo dphys-swapfile uninstall\nsudo update-rc.d dphys-swapfile remove\n\n</code></pre></div></div>\n\n<p>Check that <code class=\"language-plaintext highlighter-rouge\">free -m</code> shows the swap to be 0</p>\n\n<p>1) Set up /etc/fstab to mount /var/log and /var/tmp using tmpfs.\nThe system needs scratch space to write into, so just mounting the root filesystem read-only doesnt work very well.\nHowever we can setup in-RAM filesystem for this purpose.\nAdd these two lines to <code class=\"language-plaintext highlighter-rouge\">/etc/fstab</code></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>none                  /var/log        tmpfs   size=1M,noatime   0       0\nnone                  /var/tmp        tmpfs   size=1M,noatime   0       0\n</code></pre></div></div>\n\n<p>Then also add <code class=\"language-plaintext highlighter-rouge\">ro</code> to the line that mounts your root and boot file system. In the end the file should now look someting like this:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>proc                  /proc           proc    defaults          0       0\nPARTUUID=d6a29f93-01  /boot           vfat    ro,noatime        0       2\nPARTUUID=d6a29f93-02  /               ext4    ro,noatime        0       1\nnone                  /var/log        tmpfs   size=1M,noatime   0       0\nnone                  /var/tmp        tmpfs   size=1M,noatime   0       0\n</code></pre></div></div>\n\n<p>Now the system will be stateless. However sometime its necesseray to unlock it to make mods:</p>\n\n<p>2) Set up two script that will allow us to temporarily lock and unlock the filesystem if we need to edit something.</p>\n\n<p>~/lock.sh</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>#!/bin/sh\nmount -o remount,ro $(mount | grep \" on / \" | awk '{print $1}')\n</code></pre></div></div>\n\n<p>~/unlock.sh</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>#!/bin/sh\nmount -o remount,rw $(mount | grep \" on / \" | awk '{print $1}')\n</code></pre></div></div>\n\n<p>If you’re updating kernels etc oyu may also have to remount /boot but that’s not as frequently necessary so I dont set up a script for that.</p>\n\n<p>4) Hit <code class=\"language-plaintext highlighter-rouge\">sudo reboot</code>  check your service starts up</p>\n\n<h2 id=\"drawbacks-of-this-method\">Drawbacks of this method</h2>\n<p>In my experience this works really well in practice, but there could be drawbacks:</p>\n\n<ul>\n  <li>You have no persistent system log - if something went wrong it can make debugging hard.</li>\n  <li>You can’t persist state from one boot to the next. One work around is to have a second SD card using a \nUSB stick which is mounted periodically just when needed and then unmounted. Or you can briefly remount <code class=\"language-plaintext highlighter-rouge\">/</code> read-write, write your state and then remount again.\nNot perfect (if the power goes of right that second) but it makes it way less likely. Or, if you hae network, you could send the state to a farawy server.</li>\n  <li>The tmp dirs that are in memory fill up you have an issue.</li>\n  <li>Not having a swap partition, if you run out of memory, you’ll likely crash.</li>\n</ul>",
  "pubDate": "Tue, 09 Oct 2018 00:00:00 +0000",
  "link": "http://mtyka.github.io//hardware/2018/10/09/read-only-pi.html",
  "guid": "http://mtyka.github.io//hardware/2018/10/09/read-only-pi.html",
  "category": "hardware"
}