{
  "title": "Distributed Dask Arrays",
  "link": "",
  "updated": "2016-02-26T00:00:00+00:00",
  "id": "https://mrocklin.github.io/blog/work/2016/02/26/dask-distributed-part-3",
  "content": "<p><em>This work is supported by <a href=\"http://continuum.io\">Continuum Analytics</a>\nand the <a href=\"http://www.darpa.mil/program/XDATA\">XDATA Program</a>\nas part of the <a href=\"http://blaze.pydata.org\">Blaze Project</a></em></p>\n\n<p>In this post we analyze weather data across a cluster using NumPy in\nparallel with dask.array.  We focus on the following:</p>\n\n<ol>\n  <li>How to set up the distributed scheduler with a job scheduler like Sun\nGridEngine.</li>\n  <li>How to load NetCDF data from a network file system (NFS) into distributed\nRAM</li>\n  <li>How to manipulate data with dask.arrays</li>\n  <li>How to interact with distributed data using IPython widgets</li>\n</ol>\n\n<p>This blogpost has an accompanying\n<a href=\"https://www.youtube.com/watch?v=ZpMXEVp-iaY\">screencast</a> which might be a bit\nmore fun than this text version.</p>\n\n<p>This is the third in a sequence of blogposts about dask.distributed:</p>\n\n<ol>\n  <li><a href=\"http://matthewrocklin.com/blog/work/2016/02/17/dask-distributed-part1\">Dask Bags on GitHub Data</a></li>\n  <li><a href=\"http://matthewrocklin.com/blog/work/2016/02/22/dask-distributed-part-2\">Dask DataFrames on HDFS</a></li>\n  <li>Dask Arrays on NetCDF data</li>\n</ol>\n\n<h2 id=\"setup\">Setup</h2>\n\n<p>We wanted to emulate the typical academic cluster setup using a job scheduler\nlike SunGridEngine (similar to SLURM, Torque, PBS scripts and other\ntechnologies), a shared network file system, and typical binary stored arrays\nin NetCDF files (similar to HDF5).</p>\n\n<p>To this end we used <a href=\"http://star.mit.edu/cluster/\">Starcluster</a>, a quick way to\nset up such a cluster on EC2 with SGE and NFS, and we downloaded data from the\n<a href=\"http://www.ecmwf.int/en/research/climate-reanalysis/era-interim\">European Centre for Meteorology and Weather\nForecasting</a></p>\n\n<p>To deploy dask’s distributed scheduler with SGE we made a scheduler on the\nmaster node:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>sgeadmin@master:~$ dscheduler\ndistributed.scheduler - INFO - Start Scheduler at:  172.31.7.88:8786\n</code></pre></div></div>\n\n<p>And then used the <code class=\"language-plaintext highlighter-rouge\">qsub</code> command to start four dask workers, pointing to the\nscheduler address:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>sgeadmin@master:~$ qsub -b y -V dworker 172.31.7.88:8786\nYour job 1 (\"dworker\") has been submitted\nsgeadmin@master:~$ qsub -b y -V dworker 172.31.7.88:8786\nYour job 2 (\"dworker\") has been submitted\nsgeadmin@master:~$ qsub -b y -V dworker 172.31.7.88:8786\nYour job 3 (\"dworker\") has been submitted\nsgeadmin@master:~$ qsub -b y -V dworker 172.31.7.88:8786\nYour job 4 (\"dworker\") has been submitted\n</code></pre></div></div>\n\n<p>After a few seconds these workers start on various nodes in the cluster and\nconnect to the scheduler.</p>\n\n<h2 id=\"load-sample-data-on-a-single-machine\">Load sample data on a single machine</h2>\n\n<p>On the shared NFS drive we’ve downloaded several NetCDF3 files, each holding\nthe global temperature every six hours for a single day:</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">glob</span> <span class=\"kn\">import</span> <span class=\"n\">glob</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">filenames</span> <span class=\"o\">=</span> <span class=\"nb\">sorted</span><span class=\"p\">(</span><span class=\"n\">glob</span><span class=\"p\">(</span><span class=\"s\">'*.nc3'</span><span class=\"p\">))</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">filenames</span><span class=\"p\">[:</span><span class=\"mi\">5</span><span class=\"p\">]</span>\n<span class=\"p\">[</span><span class=\"s\">'2014-01-01.nc3'</span><span class=\"p\">,</span>\n <span class=\"s\">'2014-01-02.nc3'</span><span class=\"p\">,</span>\n <span class=\"s\">'2014-01-03.nc3'</span><span class=\"p\">,</span>\n <span class=\"s\">'2014-01-04.nc3'</span><span class=\"p\">,</span>\n <span class=\"s\">'2014-01-05.nc3'</span><span class=\"p\">]</span>\n</code></pre></div></div>\n\n<p>We use conda to install the netCDF4 library and make a small function to\nread the <code class=\"language-plaintext highlighter-rouge\">t2m</code> variable for “temperature at two meters elevation” from a single\nfilename:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>$ conda install netcdf4\n</code></pre></div></div>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">import</span> <span class=\"nn\">netCDF4</span>\n<span class=\"k\">def</span> <span class=\"nf\">load_temperature</span><span class=\"p\">(</span><span class=\"n\">fn</span><span class=\"p\">):</span>\n    <span class=\"k\">with</span> <span class=\"n\">netCDF4</span><span class=\"p\">.</span><span class=\"n\">Dataset</span><span class=\"p\">(</span><span class=\"n\">fn</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">f</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"n\">f</span><span class=\"p\">.</span><span class=\"n\">variables</span><span class=\"p\">[</span><span class=\"s\">'t2m'</span><span class=\"p\">][:]</span>\n</code></pre></div></div>\n\n<p>This converts a single file into a single numpy array in memory.  We could call\nthis on an individual file locally as follows:</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">load_temperature</span><span class=\"p\">(</span><span class=\"n\">filenames</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span>\n<span class=\"n\">array</span><span class=\"p\">([[[</span> <span class=\"mf\">253.96238624</span><span class=\"p\">,</span>  <span class=\"mf\">253.96238624</span><span class=\"p\">,</span>  <span class=\"mf\">253.96238624</span><span class=\"p\">,</span> <span class=\"p\">...,</span>  <span class=\"mf\">253.96238624</span><span class=\"p\">,</span>\n          <span class=\"mf\">253.96238624</span><span class=\"p\">,</span>  <span class=\"mf\">253.96238624</span><span class=\"p\">],</span>\n        <span class=\"p\">[</span> <span class=\"mf\">252.80590921</span><span class=\"p\">,</span>  <span class=\"mf\">252.81070124</span><span class=\"p\">,</span>  <span class=\"mf\">252.81389593</span><span class=\"p\">,</span> <span class=\"p\">...,</span>  <span class=\"mf\">252.79792249</span><span class=\"p\">,</span>\n          <span class=\"mf\">252.80111718</span><span class=\"p\">,</span>  <span class=\"mf\">252.80271452</span><span class=\"p\">],</span>\n          <span class=\"p\">...</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">load_temperature</span><span class=\"p\">(</span><span class=\"n\">filenames</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]).</span><span class=\"n\">shape</span>\n<span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">721</span><span class=\"p\">,</span> <span class=\"mi\">1440</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<p>Our dataset has dimensions of <code class=\"language-plaintext highlighter-rouge\">(time, latitude, longitude)</code>.  Note above that\neach day has four time entries (measurements every six hours).</p>\n\n<p>The NFS set up by Starcluster is unfortunately quite small.  We were only able\nto fit around five months of data (136 days) in shared disk.</p>\n\n<h2 id=\"load-data-across-cluster\">Load data across cluster</h2>\n\n<p>We want to call the <code class=\"language-plaintext highlighter-rouge\">load_temperature</code> function on our list <code class=\"language-plaintext highlighter-rouge\">filenames</code> on each\nof our four workers.  We connect a dask Executor to our scheduler address and\nthen map our function on our filenames:</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">distributed</span> <span class=\"kn\">import</span> <span class=\"n\">Executor</span><span class=\"p\">,</span> <span class=\"n\">progress</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">Executor</span><span class=\"p\">(</span><span class=\"s\">'172.31.7.88:8786'</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">e</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Executor</span><span class=\"p\">:</span> <span class=\"n\">scheduler</span><span class=\"o\">=</span><span class=\"mf\">172.31</span><span class=\"p\">.</span><span class=\"mf\">7.88</span><span class=\"p\">:</span><span class=\"mi\">8786</span> <span class=\"n\">workers</span><span class=\"o\">=</span><span class=\"mi\">4</span> <span class=\"n\">threads</span><span class=\"o\">=</span><span class=\"mi\">32</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">futures</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"p\">.</span><span class=\"nb\">map</span><span class=\"p\">(</span><span class=\"n\">load_temperature</span><span class=\"p\">,</span> <span class=\"n\">filenames</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">progress</span><span class=\"p\">(</span><span class=\"n\">futures</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<p><img src=\"https://mrocklin.github.io/blog/images/load-netcdf.gif\" /></p>\n\n<p>After this completes we have several numpy arrays scattered about the memory of\neach of our four workers.</p>\n\n<h2 id=\"coordinate-with-daskarray\">Coordinate with dask.array</h2>\n\n<p>We coordinate these many numpy arrays into a single logical dask array as\nfollows:</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">distributed.collections</span> <span class=\"kn\">import</span> <span class=\"n\">futures_to_dask_arrays</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">xs</span> <span class=\"o\">=</span> <span class=\"n\">futures_to_dask_arrays</span><span class=\"p\">(</span><span class=\"n\">futures</span><span class=\"p\">)</span>  <span class=\"c1\"># many small dask arrays\n</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">dask.array</span> <span class=\"k\">as</span> <span class=\"n\">da</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">da</span><span class=\"p\">.</span><span class=\"n\">concatenate</span><span class=\"p\">(</span><span class=\"n\">xs</span><span class=\"p\">,</span> <span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>        <span class=\"c1\"># one large dask array, joined by time\n</span><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">x</span>\n<span class=\"n\">dask</span><span class=\"p\">.</span><span class=\"n\">array</span><span class=\"o\">&lt;</span><span class=\"n\">concate</span><span class=\"p\">...,</span> <span class=\"n\">shape</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">544</span><span class=\"p\">,</span> <span class=\"mi\">721</span><span class=\"p\">,</span> <span class=\"mi\">1440</span><span class=\"p\">),</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"n\">float64</span><span class=\"p\">,</span> <span class=\"n\">chunksize</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">721</span><span class=\"p\">,</span> <span class=\"mi\">1440</span><span class=\"p\">)</span><span class=\"o\">&gt;</span>\n</code></pre></div></div>\n\n<p>This single logical dask array is comprised of 136 numpy arrays spread across\nour cluster.  Operations on the single dask array will trigger many operations\non each of our numpy arrays.</p>\n\n<h2 id=\"interact-with-distributed-data\">Interact with Distributed Data</h2>\n\n<p>We can now interact with our dataset using standard NumPy syntax and other\nPyData libraries.  Below we pull out a single time slice and render it to the\nscreen with matplotlib.</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">from</span> <span class=\"nn\">matplotlib</span> <span class=\"kn\">import</span> <span class=\"n\">pyplot</span> <span class=\"k\">as</span> <span class=\"n\">plt</span>\n<span class=\"n\">plt</span><span class=\"p\">.</span><span class=\"n\">imshow</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"p\">:,</span> <span class=\"p\">:].</span><span class=\"n\">compute</span><span class=\"p\">(),</span> <span class=\"n\">cmap</span><span class=\"o\">=</span><span class=\"s\">'viridis'</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"p\">.</span><span class=\"n\">colorbar</span><span class=\"p\">()</span>\n</code></pre></div></div>\n\n<p><img src=\"https://mrocklin.github.io/blog/images/temperature-viridis.png\" /></p>\n\n<p>In the <a href=\"https://www.youtube.com/watch?v=ZpMXEVp-iaY\">screencast version of this\npost</a> we hook this up to an\nIPython slider widget and scroll around time, which is fun.</p>\n\n<h2 id=\"speed\">Speed</h2>\n\n<p>We benchmark a few representative operations to look at the strengths and\nweaknesses of the distributed system.</p>\n\n<h3 id=\"single-element\">Single element</h3>\n\n<p>This single element computation accesses a single number from a single NumPy\narray of our dataset.  It is bound by a network roundtrip from client to\nscheduler, to worker, and back.</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"o\">%</span><span class=\"n\">time</span> <span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"n\">compute</span><span class=\"p\">()</span>\n<span class=\"n\">CPU</span> <span class=\"n\">times</span><span class=\"p\">:</span> <span class=\"n\">user</span> <span class=\"mi\">4</span> <span class=\"n\">ms</span><span class=\"p\">,</span> <span class=\"n\">sys</span><span class=\"p\">:</span> <span class=\"mi\">0</span> <span class=\"n\">ns</span><span class=\"p\">,</span> <span class=\"n\">total</span><span class=\"p\">:</span> <span class=\"mi\">4</span> <span class=\"n\">ms</span>\n<span class=\"n\">Wall</span> <span class=\"n\">time</span><span class=\"p\">:</span> <span class=\"mf\">9.72</span> <span class=\"n\">ms</span>\n</code></pre></div></div>\n\n<h3 id=\"single-time-slice\">Single time slice</h3>\n\n<p>This time slice computation pulls around 8 MB from a single NumPy array on a\nsingle worker.  It is likely bound by network bandwidth.</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"o\">%</span><span class=\"n\">time</span> <span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"n\">compute</span><span class=\"p\">()</span>\n<span class=\"n\">CPU</span> <span class=\"n\">times</span><span class=\"p\">:</span> <span class=\"n\">user</span> <span class=\"mi\">24</span> <span class=\"n\">ms</span><span class=\"p\">,</span> <span class=\"n\">sys</span><span class=\"p\">:</span> <span class=\"mi\">24</span> <span class=\"n\">ms</span><span class=\"p\">,</span> <span class=\"n\">total</span><span class=\"p\">:</span> <span class=\"mi\">48</span> <span class=\"n\">ms</span>\n<span class=\"n\">Wall</span> <span class=\"n\">time</span><span class=\"p\">:</span> <span class=\"mi\">274</span> <span class=\"n\">ms</span>\n</code></pre></div></div>\n\n<h3 id=\"mean-computation\">Mean computation</h3>\n\n<p>This mean computation touches every number in every NumPy array across all of\nour workers.  Computing means is quite fast, so this is likely bound by\nscheduler overhead.</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"o\">%</span><span class=\"n\">time</span> <span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">mean</span><span class=\"p\">().</span><span class=\"n\">compute</span><span class=\"p\">()</span>\n<span class=\"n\">CPU</span> <span class=\"n\">times</span><span class=\"p\">:</span> <span class=\"n\">user</span> <span class=\"mi\">88</span> <span class=\"n\">ms</span><span class=\"p\">,</span> <span class=\"n\">sys</span><span class=\"p\">:</span> <span class=\"mi\">0</span> <span class=\"n\">ns</span><span class=\"p\">,</span> <span class=\"n\">total</span><span class=\"p\">:</span> <span class=\"mi\">88</span> <span class=\"n\">ms</span>\n<span class=\"n\">Wall</span> <span class=\"n\">time</span><span class=\"p\">:</span> <span class=\"mi\">422</span> <span class=\"n\">ms</span>\n</code></pre></div></div>\n\n<h2 id=\"interactive-widgets\">Interactive Widgets</h2>\n\n<p>To make these times feel more visceral we hook up these computations to IPython\nWidgets.</p>\n\n<p>This first example looks fairly fluid.  This only touches a single worker and\nreturns a small result.  It is cheap because it indexes in a way that is well\naligned with how our NumPy arrays are split up by time.</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"o\">@</span><span class=\"n\">interact</span><span class=\"p\">(</span><span class=\"n\">time</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">])</span>\n<span class=\"k\">def</span> <span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">time</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">x</span><span class=\"p\">[</span><span class=\"n\">time</span><span class=\"p\">,</span> <span class=\"p\">:,</span> <span class=\"p\">:].</span><span class=\"n\">mean</span><span class=\"p\">().</span><span class=\"n\">compute</span><span class=\"p\">()</span>\n</code></pre></div></div>\n\n<p><img src=\"https://mrocklin.github.io/blog/images/mean-time.gif\" /></p>\n\n<p>This second example is less fluid because we index across our NumPy chunks.\nEach computation touches all of our data.  It’s still not bad though and quite\nacceptable by today’s standards of interactive distributed data\nscience.</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"o\">@</span><span class=\"n\">interact</span><span class=\"p\">(</span><span class=\"n\">lat</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">])</span>\n<span class=\"k\">def</span> <span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">lat</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">x</span><span class=\"p\">[:,</span> <span class=\"n\">lat</span><span class=\"p\">,</span> <span class=\"p\">:].</span><span class=\"n\">mean</span><span class=\"p\">().</span><span class=\"n\">compute</span><span class=\"p\">()</span>\n</code></pre></div></div>\n\n<p><img src=\"https://mrocklin.github.io/blog/images/mean-latitude.gif\" /></p>\n\n<h2 id=\"normalize-data\">Normalize Data</h2>\n\n<p>Until now we’ve only performed simple calculations on our data, usually grabbing\nout means.  The image of the temperature above looks unsurprising.  The image\nis dominated by the facts that land is warmer than oceans and that the equator\nis warmer than the poles.  No surprises there.</p>\n\n<p>To make things more interesting we subtract off the mean and divide by the\nstandard deviation over time.  This will tell us how unexpectedly hot or cold a\nparticular point was, relative to all measurements of that point over time.\nThis gives us something like a geo-located Z-Score.</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">z</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">-</span> <span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">mean</span><span class=\"p\">(</span><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">))</span> <span class=\"o\">/</span> <span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">std</span><span class=\"p\">(</span><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"n\">z</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"p\">.</span><span class=\"n\">persist</span><span class=\"p\">(</span><span class=\"n\">z</span><span class=\"p\">)</span>\n<span class=\"n\">progress</span><span class=\"p\">(</span><span class=\"n\">z</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<p><img src=\"https://mrocklin.github.io/blog/images/normalize.gif\" /></p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">plt</span><span class=\"p\">.</span><span class=\"n\">imshow</span><span class=\"p\">(</span><span class=\"n\">z</span><span class=\"p\">[</span><span class=\"nb\">slice</span><span class=\"p\">].</span><span class=\"n\">compute</span><span class=\"p\">(),</span> <span class=\"n\">cmap</span><span class=\"o\">=</span><span class=\"s\">'RdBu_r'</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"p\">.</span><span class=\"n\">colorbar</span><span class=\"p\">()</span>\n</code></pre></div></div>\n\n<p><img src=\"https://mrocklin.github.io/blog/images/temperature-denormalized.png\" /></p>\n\n<p>We can now see much more fine structure of the currents of the day.  In the\n<a href=\"https://www.youtube.com/watch?v=ZpMXEVp-iaY\">screencast version</a> we hook this\ndataset up to a slider as well and inspect various times.</p>\n\n<p>I’ve avoided displaying GIFs of full images changing in this post to keep the\nsize down, however we can easily render a plot of average temperature by\nlatitude changing over time here:</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"n\">np</span>\n<span class=\"nb\">xrange</span> <span class=\"o\">=</span> <span class=\"mi\">90</span> <span class=\"o\">-</span> <span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"n\">z</span><span class=\"p\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">])</span> <span class=\"o\">/</span> <span class=\"mi\">4</span>\n\n<span class=\"o\">@</span><span class=\"n\">interact</span><span class=\"p\">(</span><span class=\"n\">time</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">z</span><span class=\"p\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">])</span>\n<span class=\"k\">def</span> <span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">time</span><span class=\"p\">):</span>\n    <span class=\"n\">plt</span><span class=\"p\">.</span><span class=\"n\">figure</span><span class=\"p\">(</span><span class=\"n\">figsize</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">))</span>\n    <span class=\"n\">plt</span><span class=\"p\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"nb\">xrange</span><span class=\"p\">,</span> <span class=\"n\">z</span><span class=\"p\">[</span><span class=\"n\">time</span><span class=\"p\">].</span><span class=\"n\">mean</span><span class=\"p\">(</span><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">).</span><span class=\"n\">compute</span><span class=\"p\">())</span>\n    <span class=\"n\">plt</span><span class=\"p\">.</span><span class=\"n\">ylabel</span><span class=\"p\">(</span><span class=\"s\">\"Normalized Temperature\"</span><span class=\"p\">)</span>\n    <span class=\"n\">plt</span><span class=\"p\">.</span><span class=\"n\">xlabel</span><span class=\"p\">(</span><span class=\"s\">\"Latitude (degrees)\"</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<p><img src=\"https://mrocklin.github.io/blog/images/latitude-plot.gif\" /></p>\n\n<h2 id=\"conclusion\">Conclusion</h2>\n\n<p>We showed how to use distributed dask.arrays on a typical academic cluster.\nI’ve had several conversations with different groups about this topic; it seems\nto be a common case.  I hope that the instructions at the beginning of this\npost prove to be helpful to others.</p>\n\n<p>It is really satisfying to me to couple interactive widgets with data on a\ncluster in an intuitive way.  This sort of fluid interaction on larger datasets\nis a core problem in modern data science.</p>\n\n<h2 id=\"what-didnt-work\">What didn’t work</h2>\n\n<p>As always I’ll include a section like this on what didn’t work well or what I\nwould have done with more time:</p>\n\n<ul>\n  <li>No high-level <code class=\"language-plaintext highlighter-rouge\">read_netcdf</code> function:  We had to use the mid-level API of\n<code class=\"language-plaintext highlighter-rouge\">executor.map</code> to construct our dask array.  This is a bit of a pain for\nnovice users.  We should probably adapt existing high-level functions in\ndask.array to robustly handle the distributed data case.</li>\n  <li>Need a larger problem:  Our dataset could have fit into a Macbook Pro.\nA larger dataset that could not have been efficiently investigated from a\nsingle machine would have really cemented the need for this technology.</li>\n  <li>Easier deployment:  The solution above with <code class=\"language-plaintext highlighter-rouge\">qsub</code> was straightforward but\nnot always accessible to novice users.  Additionally while SGE is common\nthere are several other systems that are just as common.  We need to think\nof nice ways to automate this for the user.</li>\n  <li>XArray integration:  Many people use dask.array on single machines through\n<a href=\"http://xarray.pydata.org/en/stable/\">XArray</a>, an excellent library for the\nanalysis of labeled nd-arrays especially common in climate science.  It\nwould be good to integrate this new distributed work into the XArray\nproject.  I suspect that doing this mostly involves handling the data\ningest problem described above.</li>\n  <li>Reduction speed: The computation of normalized temperature, <code class=\"language-plaintext highlighter-rouge\">z</code>, took a\nsurprisingly long time.  I’d like to look into what is holding up that\ncomputation.</li>\n</ul>\n\n<h2 id=\"links\">Links</h2>\n\n<ul>\n  <li><a href=\"https://dask.pydata.org/en/latest/array.html\">dask.array</a></li>\n  <li><a href=\"https://distributed.readthedocs.org/en/latest/\">dask.distributed</a></li>\n</ul>"
}