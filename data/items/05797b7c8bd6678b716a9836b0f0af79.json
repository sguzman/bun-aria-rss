{
  "id": "tag:blogger.com,1999:blog-37798047.post-5304991896640692146",
  "published": "2022-01-31T15:33:00.003-05:00",
  "updated": "2022-01-31T15:33:58.536-05:00",
  "title": "No, a researcher didn't find Olympics app spying on you",
  "content": "<p>For the Beijing 2022 Winter Olympics, the Chinese government requires everyone to download an app onto their phone. It has many security/privacy concerns, as <a href=\"https://citizenlab.ca/2022/01/cross-country-exposure-analysis-my2022-olympics-app/\">CitizenLab documents</a>. However, another researcher goes further, claiming <a href=\"https://twitter.com/jonathandata1/status/1486458526767661060\">his analysis</a> proves the app is recording all audio all the time. His analysis is fraudulent. He shows a lot of technical content that looks plausible, but nowhere does he show anything that substantiates his claims.</p><p><span></span></p><a name='more'></a>Average techies may not be able to see this. It all looks technical. Therefore, I thought I'd describe one example of the problems with this data -- something the average techie can recognize.<p></p><p>His \"evidence\" consists screenshots from reverse-engineering tools, with red arrows pointing to the suspicious bits. An example of one of these screenshots is this on:</p><p></p><div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"https://blogger.googleusercontent.com/img/a/AVvXsEht_qbSj6D-i35cKD8v5I-exLu35CuNci3C7XB9NtawR8fXjjojtWePt69v96CAwtax02bG8nnOp-_HsIsbMiOCntQvDPpdUfM_EIzE-5UF0c0nPaGB2lrp6fSZTJUoHCgq3xEqceTpGVnMBjFPlsXMGlSvGoT-qIE1XhuUL49jNjchwhpKug\" style=\"margin-left: 1em; margin-right: 1em;\"><img alt=\"\" data-original-height=\"545\" data-original-width=\"848\" height=\"206\" src=\"https://blogger.googleusercontent.com/img/a/AVvXsEht_qbSj6D-i35cKD8v5I-exLu35CuNci3C7XB9NtawR8fXjjojtWePt69v96CAwtax02bG8nnOp-_HsIsbMiOCntQvDPpdUfM_EIzE-5UF0c0nPaGB2lrp6fSZTJUoHCgq3xEqceTpGVnMBjFPlsXMGlSvGoT-qIE1XhuUL49jNjchwhpKug\" width=\"320\" /></a></div><div><br /></div><div>This screenshot is that of a reverse-engineering tool (Hopper, I think) that takes code and \"disassembles\" it. When you dump something into a reverse-engineering tool, it'll make a few assumptions about what it sees. These assumptions are <b>usually wrong</b>. There's a process where the human user looks at the analyzed output, does a \"sniff-test\" on whether it looks reasonable, and works with the tool until it gets the assumptions correct.</div><div><br /></div><div>That's the red flag above: the researcher has dumped the results of a reverse-engineering tool without recognizing that something is wrong in the analysis.</div><p>It fails the sniff test. Different researchers will notice different things first. Famed google researcher Tavis Ormandy&nbsp;<a href=\"https://twitter.com/taviso/status/1487089870749069313\">points out</a>&nbsp;one flaw. In this post, I describe what jumps out first to me. That would be the 'imul' (multiplication) instruction shown in the blowup below:</p><p></p><div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"https://blogger.googleusercontent.com/img/a/AVvXsEil0gizOZOCfgPxDhWNvcVb4kLzGZ2uuK2vA3j5sSZwhlbbZcnv4nOyRE-JF_GmJ36giTl612W6LQDaFXejNeKgnDxf62sfSYCA647I3KWqK0IP7LwJY214i-z42UAhrs4SgZCOm2p3Ugbu8Zvu9OS0EE2Zu9ywjkWJuDLHS3XOt_BTPmYYyA\" style=\"margin-left: 1em; margin-right: 1em;\"><img alt=\"\" data-original-height=\"210\" data-original-width=\"1050\" height=\"64\" src=\"https://blogger.googleusercontent.com/img/a/AVvXsEil0gizOZOCfgPxDhWNvcVb4kLzGZ2uuK2vA3j5sSZwhlbbZcnv4nOyRE-JF_GmJ36giTl612W6LQDaFXejNeKgnDxf62sfSYCA647I3KWqK0IP7LwJY214i-z42UAhrs4SgZCOm2p3Ugbu8Zvu9OS0EE2Zu9ywjkWJuDLHS3XOt_BTPmYYyA\" width=\"320\" /></a></div><br />It's obviously ASCII. In other words, it's a series of bytes. The tool has tried to interpret these bytes as Intel x86 instructions (like 'and', 'insd', 'das', 'imul', etc.). But it's obviously not Intel x86, because those instructions make no sense.<div><p></p><p>That 'imul' instruction is multiplying something by the (hex) number 0x6b657479. That doesn't look like a number -- it looks like four lower-case ASCII letters. ASCII lower-case letters are in the range 0x61 through 0x7A, so it's not the single 4-byte number 0x6b657479 but the 4 individual bytes 6b 65 74 79, which map to the ASCII letters 'k', 'e', 't', 'y' (actually, because \"little-endian\", reverse order, so \"ytek\").</p><p>No, no. Techies aren't expected to be able to <i>read</i>&nbsp;hex this way. Instead, we are expected to <i>recognize</i>&nbsp;what's going on. I just used a <a href=\"http://www.unit-conversion.info/texttools/hexadecimal/\">random website</a> to interpret hex bytes as ASCII.</p><p>There are 26 lower case letters, roughly 10% of the 256 possible values for a byte. Thus, the chance that a random 4 byte number will consist of all lower-case letters is 1-in-10,000. Moreover, multiplication by strange constants happens even more rarely. You'll commonly see multiplications by small numbers like 48, or large well-formed numbers like 0x1000000. You pretty much never see multiplication by a number like 0x6b657479, baring something rare like an LCG.</p><p>QED: this isn't actually an Intel x86 imul instruction, it's ASCII text that the tool has tried to interpret as x86 instructions.</p><p><b>Conclusion</b></p><p>At first glance, all those screenshots by the researcher look very technical, which many will assume supports his claims. But when we actually look at them, none of them support his claims. Instead, it's all just handwaving nonsense. It's clear the researchers doesn't understand them, either.</p><p><br /></p></div>",
  "link": [
    "",
    "",
    "",
    "",
    ""
  ],
  "author": {
    "name": "Robert Graham",
    "uri": "http://www.blogger.com/profile/09879238874208877740",
    "email": "noreply@blogger.com",
    "gd:image": ""
  },
  "media:thumbnail": "",
  "thr:total": 2
}