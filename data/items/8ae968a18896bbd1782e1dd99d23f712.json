{
  "title": "Memory Latency, Hashing, Optimal Golomb Rulers and Feistel Networks",
  "description": "<p>In many problems involving hashing we want to look up a range of elements from a vector, e.g. of the form \\(v[h(i,j)]\\) for arbitrary \\(i\\) and for a range of \\(j \\in \\{1, \\ldots, n\\}\\) where \\(h(i,j)\\) is a hash function. This happens e.g. for multiclass classification, collaborative filtering, and multitask learning. </p>\n<p>While this works just fine in terms of estimation performance, traversing all values of j leads to an algorithm which is horrible in terms of memory access patterns. Modern RAM chips are much faster (over 10x) when it comes to reading values in sequence than when carrying out random reads. Furthermore, random access destroys the benefit of a cache. This leads to algorithms which are efficient in terms of their memory footprint, however, they can be relatively slow. One way to address this is to bound the range of \\(h(i,j)\\) for different values of j. Here are some ways of how we could do this:</p>\n<ol><li>Decompose \\(h(i,j) = h(i) + j\\). This is computationally very cheap, it has good sequential access properties but it leads to horrible collisions should there ever be two \\(i\\) and \\(i&rsquo;\\) for which \\(|h(i) - h(i&rsquo;)| \\leq n\\). </li>\n<li>Decompose \\(h(i,j) = h(i) + h&rsquo;(j)\\) where \\(h&rsquo;(j)\\) has a small range of values. <br/>This is a really bad idea since now we have a nontrivial probability of collision as soon as the range of \\(h&rsquo;(j)\\) is less than \\(n^2\\) due to the birthday paradox. Moreover, for adjacent values \\(h(i)\\) and \\(h(i&rsquo;)\\) we will get many collisions.</li>\n<li>Decompose \\(h(i,j) = h(i) + g(j)\\) where \\(g(j)\\) is an <a title=\"Optimal Golomb Ruler\" href=\"http://en.wikipedia.org/wiki/Golomb_ruler\">Optimal Golomb Ruler</a>.<br/>The latter is an increasing sequence of integers for which any pairwise distance occurs exactly once. In other words, the condition \\(h(a) - h(b) = h&copy; - h(d)\\) implies that \\(a = c\\) and \\(b = d\\). <a title=\"John Langford\" href=\"http://hunch.net/~jl\">John Langford</a> proposed this to address the problem. In fact, it solves our problem since there are a) no collisions for a fixed \\(i\\) and b) for neighboring values \\(h(i)\\) and \\(h(i&rsquo;)\\) we will get at most one collision (due to the Golomb ruler property). Alas, this only works up to \\(n=26\\) since finding an Optimal Golomb Ruler is hard (it is currently unknown whether it is actually NP hard).</li>\n<li>An alternative that works for larger n and that is sufficiently simple to compute is to use cryptography. After all, all we want is that the hash function \\(h&rsquo;(j)\\) has small range and that it doesn&rsquo;t have any self collisions or any systematic collisions. We can achieve this by encrypting j using the key i to generate an encrypted message of N possible values. In other words we use<br/>$$h(i,j) = h(i) + \\mathrm{crypt}(j|i,N)$$<br/>Since it is an encryption of j, the mapping is invertible and we won&rsquo;t have collisions for a given value of j. Furthermore, for different i the encodings will be uncorrelated (after all, i is the key). Finally, we can control the range \\(N&gt;n\\) simply by choosing the encryption algorithm. In this case the random memory access is of bounded range, hence the CPU cache will not suffer from too many misses.</li>\n</ol><p>A particularly nice algorithm is the <a title=\"Feistel cipher\" href=\"http://en.wikipedia.org/wiki/Feistel_cipher\">Feistel cipher</a>. It works as follows: define the iterative map</p>\n<p>$$f(x,y) = (y, x \\mathrm{XOR} h(y))$$</p>\n<p>Here \\(h\\) is a hash function. After 4 iterations \\((x,y) \\to f(x,y)\\) we obtain an encryption of \\((x,y)\\). Now use \\(x=i\\) and \\(y = j\\) to obtain the desired result. Basically we are trading off memory latency with computation (which is local).</p>",
  "link": "https://blog.smola.org/post/3243371889",
  "guid": "https://blog.smola.org/post/3243371889",
  "pubDate": "Fri, 11 Feb 2011 17:56:00 -0800"
}