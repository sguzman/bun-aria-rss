{
  "guid": "tag:blogger.com,1999:blog-6300367579216018061.post-6744534622534479234",
  "pubDate": "Tue, 25 Aug 2015 14:33:00 +0000",
  "atom:updated": "2015-08-29T02:11:47.091-07:00",
  "category": [
    "cloud native java",
    "docker",
    "docker compose",
    "microservices",
    "mysql",
    "neo4j",
    "polyglot persistence",
    "spring boot",
    "spring cloud",
    "spring data"
  ],
  "title": "Building Microservices with Polyglot Persistence Using Spring Cloud and Docker",
  "description": "<link rel=\"stylesheet\" href=\"https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400\"><style>.sect1{padding-bottom:0!important} .sect1+.sect1{border:0!important} .admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-size:1.25rem;font-style:italic} .conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:\"Open Sans\",\"DejaVu Sans\",sans-serif;font-style:normal;font-weight:bold} .conum[data-value] *{color:#fff!important} .conum[data-value]+b{display:none} .conum[data-value]:after{content:attr(data-value)} pre .conum[data-value]{position:relative;top:-.125em} b.conum *{color:inherit!important} .conum:not([data-value]):empty{display:none} .hdlist>table,.colist>table{border:0;background:none} .hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none} td.hdlist1{padding-right:.75em;font-weight:bold} td.hdlist1,td.hdlist2{vertical-align:top} .literalblock+.colist,.listingblock+.colist{margin-top:-.5em} .colist>table tr>td:first-of-type{padding:0 .75em;line-height:1} .colist>table tr>td:last-of-type{padding:.25em 0} h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:\"Open Sans\",sans-serif;font-style:normal;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;} .blog-post-asciidoc p{margin-bottom:1.25rem} .blog-post-asciidoc .content img {         max-height: 22em;     width: auto;     display: block;     height: inherit; } .blog-post-asciidoc .imageblock {     max-width: 100%;     background: #ffffff;     border: 1px solid #eeeeee;     -moz-box-shadow: 1px 1px 5px rgba(0, 0, 0, .1);     -webkit-box-shadow: 1px 1px 5px rgba(0, 0, 0, .1);     box-shadow: 1px 1px 5px rgba(0, 0, 0, .1);     display: inline-block;     padding: 1em; } .blog-post-asciidoc img { border: none; -webkit-box-shadow: none; box-shadow: none; } @media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}.sect1+.sect1{border-top:1px solid #efefed} pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:\"Droid Sans Mono\",\"DejaVu Sans Mono\",monospace;font-weight:400;text-rendering:optimizeSpeed} .blog-post-asciidoc code,kbd,pre,samp{font-size:.9em;font-weight:300;} .blog-post-asciidoc .admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%} .blog-post-asciidoc .admonitionblock>table td.icon{text-align:center;width:80px} .blog-post-asciidoc .admonitionblock>table td.icon img{max-width:none} .blog-post-asciidoc .admonitionblock>table td.icon .title{font-weight:bold;font-family:\"Open Sans\",\"DejaVu Sans\",sans-serif;text-transform:uppercase} .blog-post-asciidoc .admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)} .blog-post-asciidoc .admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0} .blog-post-asciidoc .admonitionblock td.icon [class^=\"fa icon-\"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default} .blog-post-asciidoc .admonitionblock td.icon .icon-note:before{content:\"\\f05a\";color:#19407c} .blog-post-asciidoc .admonitionblock td.icon .icon-tip:before{content:\"\\f0eb\";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111} .blog-post-asciidoc .admonitionblock td.icon .icon-warning:before{content:\"\\f071\";color:#bf6900} .blog-post-asciidoc .admonitionblock td.icon .icon-caution:before{content:\"\\f06d\";color:#bf3400} .blog-post-asciidoc .admonitionblock td.icon .icon-important:before{content:\"\\f06a\";color:#bf0000} </style><link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.2.0/css/font-awesome.min.css\"><link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css\"><script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js\"></script><div id=\"content\" class=\"blog-post-asciidoc\"><div id=\"preamble\"><div class=\"sectionbody\"><div class=\"paragraph\"><p>This series continues from the <a href=\"http://www.kennybastani.com/2015/07/spring-cloud-docker-microservices.html\">last blog post about building microservices</a> using <a href=\"http://projects.spring.io/spring-cloud/\">Spring Cloud</a>. This post has two parts. The first part describes how to create cloud-native data services using Spring Boot. The second part is a companion example project that uses Docker Compose to run multiple microservices locally to simulate a polyglot persistence setup.</p></div></div></div><div class=\"sect1\"><h2 id=\"_what_is_polyglot_persistence\">What is polyglot persistence?</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p><a href=\"http://martinfowler.com/bliki/PolyglotPersistence.html\">Polyglot persistence is a term</a> that describes an architecture that uses a collection of different database solutions as a part of a platform&#8217;s core design. More plainly, each <a href=\"http://12factor.net/backing-services\">backing service</a> is managed from an exclusive connection to a Spring Boot service that exposes domain data as HTTP resources.</p></div><div class=\"paragraph\"><p>The central idea behind polyglot persistence is that service architectures should be able to utilize the best languages for the job at hand. There is no clear definition of how to do this well, and it tends to evolve organically as central databases become cumbersome when required to add new features.</p></div></div></div><div class=\"sect1\"><h2 id=\"_spring_boot_roles\">Spring Boot Roles</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p>When designing microservices that manage exclusive access to multiple data providers, it can be useful to think about the roles in which your microservices will play.</p></div><div class=\"paragraph\"><p>We can think of a <a href=\"http://projects.spring.io/spring-boot/\">Spring Boot</a> application as the basic building block for our microservice architecture.</p></div><div id=\"img-microservice-roles\" class=\"imageblock\"><div class=\"content\"><img src=\"http://i.imgur.com/StpflHf.png\" alt=\"Microservice Roles\" width=\"70%\" height=\"auto\"></div><div class=\"title\">Figure 1. Each Spring Boot application plays a role when integrating with other services</div></div><div class=\"paragraph\"><p>The diagram above describes six Spring Boot applications that are color coded to describe the role they play when integrated using <a href=\"http://projects.spring.io/spring-cloud/\">Spring Cloud</a>.</p></div><div class=\"sect2\"><h3 id=\"_data_services\">Data Services</h3><div class=\"paragraph\"><p>Each Spring Boot application in a microservices architecture will play a role to varying degrees of importance. The data service role is one of the most important roles in any setup. This role handles exposing the application&#8217;s domain data to other microservices in the platform.</p></div><div class=\"sect3\"><h4 id=\"_polyglot_data_services\">Polyglot Data Services</h4><div class=\"paragraph\"><p>The diagram below describes an example microservice architecture with multiple Spring Boot applications that expose data from multiple database providers.</p></div><div id=\"img-polyglot\" class=\"imageblock\"><div class=\"content\"><img src=\"http://i.imgur.com/aQYGZFy.png\" alt=\"Polyglot Persistence Microservices\" width=\"80%\"></div><div class=\"title\">Figure 2. Example Polyglot Persistence Architecture</div></div><a name='more'></a><div class=\"paragraph\"><p>We can see that our <code>User Service</code> connects to two databases: <a href=\"https://en.wikipedia.org/wiki/MySQL\">MySQL</a> and <a href=\"https://en.wikipedia.org/wiki/Couchbase_Server\">Couchbase</a>. We can also see that our <code>Rating Service</code> swaps out MySQL (RDBMS) for a <a href=\"http://www.neo4j.com/developer\">Neo4j graph database</a>.</p></div><div class=\"paragraph\"><p>One of the reasons why you might decide to use a polyglot persistence setup for a microservice architecture is that it gives you the benefit of using the best <a href=\"https://en.wikipedia.org/wiki/Database_model\">database model</a> for the use case. For instance, I decided to use Neo4j for the <code>Rating Service</code> because the shape of the data for ratings can be used to generate recommendations using <a href=\"http://www.kennybastani.com/2014/11/using-apache-spark-and-neo4j-for-big.html\">Apache Spark</a>.</p></div></div></div></div></div><div class=\"sect1\"><h2 id=\"_configuring_a_data_service\">Configuring a Data Service</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p>Let&#8217;s take a look at what some of the common characteristics of a data service are in Spring Boot when using Spring Cloud.</p></div><div class=\"sect2\"><h3 id=\"_spring_data\">Spring Data</h3><div class=\"paragraph\"><p>Each Spring Boot application that we can consider to be a data service is one that has the responsibility for managing data access for other applications in the architecture. To do this, we can use another project of the Spring Framework, <a href=\"http://projects.spring.io/spring-data/\">Spring Data</a>.</p></div></div><div class=\"sect2\"><h3 id=\"_what_is_spring_data\">What is Spring Data?</h3><div class=\"paragraph\"><p>Spring Data is a project in the <a href=\"http://projects.spring.io/spring-framework/\">Spring Framework</a> ecosystem of tools that provides a familiar abstraction for interacting with a data store while preserving the special traits of its database model.</p></div><div class=\"paragraph\"><p>Anyone who has worked with the Spring Framework over the years has a good idea how to use Spring Data. If you&#8217;re not familiar, please take a look at the <a href=\"https://github.com/spring-projects/spring-data-examples\">Spring Data guides</a> to get working examples.</p></div></div><div class=\"sect2\"><h3 id=\"_creating_a_data_service\">Creating a Data Service</h3><div class=\"paragraph\"><p>When deciding to create a new data service for a <a href=\"http://shop.oreilly.com/product/0636920038252.do\">cloud-native application</a>, it is helpful to first examine the domain model of the application.</p></div><div id=\"img-movie-domain-graph-model\" class=\"imageblock\"><div class=\"content\"><img src=\"http://i.imgur.com/5vPmly4.png\" alt=\"Movie Domain\" width=\"70%\"></div><div class=\"title\">Figure 3. Graph model of the movie domain of our example application</div></div><div class=\"paragraph\"><p>In the graph data model above we can see the common entities that we need to expose from our services. The nodes represent the domain entities within our movie application.</p></div><div class=\"ulist\"><ul><li><p>User</p></li><li><p>Movie</p></li><li><p>Genre</p></li></ul></div><div class=\"paragraph\"><p>The connections between these entities give us a good idea of our boundaries that we need to consider when designing our microservices. For instance, we may have a requirement to analyze the ratings data between movies and users to generate movie recommendations.</p></div><div class=\"paragraph\"><p>For this example project we will use three data services:</p></div><div class=\"ulist\"><ul><li><p><code>Rating Service</code> (Neo4j)</p></li><li><p><code>Movie Service</code> (MySQL)</p></li><li><p><code>User Service</code> (Neo4j)</p></li></ul></div><div class=\"paragraph\"><p>Before we can get started creating our data services, let&#8217;s talk about what the anatomy of a Spring Boot data service looks like in a cloud-native application with Spring Cloud.</p></div></div></div></div><div class=\"sect1\"><h2 id=\"_anatomy_of_a_spring_boot_data_service\">Anatomy of a Spring Boot Data Service</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p>This section will do a deep dive on how Spring Boot application are automatically configured to use data sources using Spring Data. Since each Spring Boot application is integrated using Spring Cloud, it is helpful to understand how these applications bootstrap their dependencies.</p></div><div class=\"paragraph\"><p>The dependencies each of our data services will have in common are:</p></div><div class=\"ulist\"><ul><li><p><a href=\"http://cloud.spring.io/spring-cloud-config/spring-cloud-config.html\">Configuration Server</a></p></li><li><p><a href=\"http://projects.spring.io/spring-cloud/spring-cloud.html#_service_discovery_eureka_clients\">Discovery Client</a></p></li><li><p><a href=\"http://projects.spring.io/spring-cloud/spring-cloud.html#_router_and_filter_zuul\">API Gateway</a></p></li><li><p><a href=\"http://docs.spring.io/spring-data/jpa/docs/current/reference/html/\">Spring Data</a></p></li><li><p><a href=\"http://projects.spring.io/spring-data-rest/\">Spring Data REST</a></p></li></ul></div><div class=\"paragraph\"><p>These dependencies are declared in a Spring Boot application&#8217;s <code>pom.xml</code>. The common dependencies we will need are listed below.</p></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-xml\" data-lang=\"xml\">&lt;dependency&gt;<br />    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br />    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;<br />&lt;/dependency&gt;<br />&lt;dependency&gt;<br />    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br />    &lt;artifactId&gt;spring-boot-starter-data-rest&lt;/artifactId&gt;<br />&lt;/dependency&gt;<br />&lt;dependency&gt;<br />    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br />    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;<br />&lt;/dependency&gt;<br />&lt;dependency&gt;<br />    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br />    &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;<br />&lt;/dependency&gt;<br />&lt;dependency&gt;<br />    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br />    &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;<br />&lt;/dependency&gt;<br />&lt;dependency&gt;<br />    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br />    &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;<br />&lt;/dependency&gt;<br />&lt;dependency&gt;<br />    &lt;groupId&gt;mysql&lt;/groupId&gt;<br />    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;<br />&lt;/dependency&gt;</code></pre></div></div><div class=\"sect2\"><h3 id=\"_bootstrapping_datasource_dependencies\">Bootstrapping Datasource Dependencies</h3><div class=\"paragraph\"><p>One of the core principles of Spring Boot is minimal configuration. Spring Boot will automatically scan the classpath of an application at startup and bootstrap dependencies. For example, if I added <code>spring-boot-starter-jpa</code> as one of my dependencies, the data source is automatically configured by looking for a compatible database driver elsewhere in the dependencies.</p></div><div class=\"paragraph\"><p>In the example code snippet from the <code>pom.xml</code>, I&#8217;ve specified <code>mysql-connector-java</code> dependency. Now when I start the Spring Boot application, this MySQL driver will automatically be configured as our default <a href=\"http://projects.spring.io/spring-data-jpa/\">data source for JPA</a>.</p></div><div class=\"paragraph\"><p>The data source connection details are retrieved from the configuration service for a specific environment. Those configurations are contained in <code>application.yml</code>. Below is an example application properties for a Spring Data JPA application that has a connection to a MySQL database. This is similar to how the <code>Movie Service</code> in the example project is configured.</p></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-yaml\" data-lang=\"yaml\">spring:<br />  profiles:<br />    active: development<br />---<br />spring:<br />  profiles: development<br />  jpa:<br />    show_sql: false<br />    database: MYSQL<br />    hibernate:<br />      ddl-auto: none<br />  datasource: <i class=\"conum\" data-value=\"1\"></i><b>(1)</b><br />    url: jdbc:mysql://localhost/test<br />    username: dbuser<br />    password: dbpass</code></pre></div></div><div class=\"colist arabic\"><table><tr><td><i class=\"conum\" data-value=\"1\"></i><b>1</b></td><td>The <code>spring.datasource</code> property block is where you configure connection details.</td></tr></table></div></div><div class=\"sect2\"><h3 id=\"_spring_cloud_dependencies\">Spring Cloud Dependencies</h3><div class=\"paragraph\"><p>The Spring Cloud dependencies that I&#8217;ve specified in the <code>pom.xml</code> will be common and standard throughout our connected data services. The dependency we can expect to change per the requirements of the attached data store will be the Spring Data project we choose for that data service.</p></div><div class=\"sect3\"><h4 id=\"_config_server\">Config Server</h4><div class=\"paragraph\"><p>The <code>spring-cloud-starter-config-server</code> dependency is used to tell our Spring Boot application to use a configuration server to retrieve environment configurations.</p></div><div id=\"img-config-server\" class=\"imageblock\"><div class=\"content\"><img src=\"http://i.imgur.com/J7FazPH.png\" alt=\"Spring Configurations\" width=\"80%\" height=\"80%\"></div><div class=\"title\">Figure 4. Config server enables automatic configuration per environment in a Git repository</div></div><div class=\"paragraph\"><p>By adding this dependency to our classpath, we can configure the service to retrieve a set of configurations for a specific <a href=\"http://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-profiles.html\">Spring profile</a>. A Spring profile could define configurations for an environment, for instance, staging and production profiles. Retrieving configurations for a profile is an important feature of a data service since we will connect to different databases in different environments.</p></div></div><div class=\"sect3\"><h4 id=\"_eureka_discovery\">Eureka Discovery</h4><div class=\"paragraph\"><p>The <code>spring-cloud-starter-eureka</code> dependency is used to tell our Spring Boot application that it should register itself with the Eureka discovery service on startup.</p></div><div class=\"paragraph\"><p>Eureka is a service registry that provides us with a way to automatically discover and connect to other data services using the ID of a Spring Boot application. Further, as we scale up the number of instances of a data service, a client-side load balancer will automatically route requests to registered instances of the same service ID.</p></div><div id=\"img-eureka-load-balance\" class=\"imageblock\"><div class=\"content\"><img src=\"http://i.imgur.com/aqCtybq.png?1\" alt=\"Discovery\" width=\"60%\" height=\"100%\"></div><div class=\"title\">Figure 5. Eureka client-side load balancing with ribbon</div></div></div><div class=\"sect3\"><h4 id=\"_zuul_gateway\">Zuul Gateway</h4><div class=\"paragraph\"><p>The <code>spring-cloud-starter-zuul</code> dependency is used to tell our Spring Boot application that it should advertise its HTTP routes to other services using a <a href=\"https://en.wikipedia.org/wiki/Reverse_proxy\">reverse proxy lookup</a>. This technique is called a <a href=\"http://projects.spring.io/spring-cloud/spring-cloud.html#_polyglot_support_with_sidecar\">sidecar proxy</a>, which is used to expose domain resources to applications that do not register with Eureka. The use of a sidecar on an API Gateway is helpful if you have applications using a language other than the JVM.</p></div><div class=\"paragraph\"><p>By adding the annotation <code>@EnableZuulProxy</code> on the Spring Boot application class, your service will automatically add HTTP routes advertised by other services through Eureka.</p></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-bash\" data-lang=\"bash\">curl -X GET 'http://service.cfapps.io/routes'</code></pre></div></div><div class=\"paragraph\"><p>By making a request to the <code>/routes</code> endpoint of a Zuul enabled service, you will get back a manifest of services who have registered with Eureka and are exposing a REST API or HTTP route.</p></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-json\" data-lang=\"json\">{<br />  \"_links\": {<br />    \"self\": {<br />      \"href\": \"http://service.cfapps.io/routes\",<br />      \"templated\": false<br />    }<br />  },<br />  \"/rating/**\": \"rating\",<br />  \"/user/**\": \"user\",<br />  \"/movie/**\": \"movie\",<br />  \"/gateway/**\": \"gateway\",<br />  \"/moviesui/**\": \"moviesui\"<br />}</code></pre></div></div><div class=\"paragraph\"><p>The result shows that we have multiple services registered with their service ID as routes we can make requests to. Let&#8217;s see the result of calling the <code>movie</code> service&#8217;s route at <code>/movie/**</code>.</p></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-bash\" data-lang=\"bash\">curl -X GET 'http://service.cfapps.io/movie'</code></pre></div></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-json\" data-lang=\"json\">{<br />  \"_links\": {<br />    \"movies\": {<br />      \"href\": \"http://service.cfapps.io/movie/movies{?page,size,sort}\",<br />      \"templated\": true<br />    },<br />    \"profile\": {<br />      \"href\": \"http://service.cfapps.io/movie/alps\",<br />      \"templated\": false<br />    }<br />  }<br />}</code></pre></div></div><div class=\"paragraph\"><p>We can now see the list of links that are advertised by the <code>movie</code> service&#8217;s root. We can see that this service has a single repository exposed as a REST resource at <code>/movie/movies</code> and that it is a paging and sorting repository.</p></div><div class=\"admonitionblock note\"><table><tr><td class=\"icon\"><i class=\"fa icon-note\" title=\"Note\"></i></td><td class=\"content\">The JSON format we are looking at is <a href=\"https://en.wikipedia.org/wiki/Hypertext_Application_Language\">HAL</a>, which is the JSON and XML specification based on the principles of <a href=\"https://en.wikipedia.org/wiki/HATEOAS\">HATEOAS (Hypermedia as the Engine of Application State)</a>. This JSON format provides a way for clients to traverse a REST API using embedded links. </td></tr></table></div><div class=\"paragraph\"><p>We can now traverse into the <code>movie</code> service&#8217;s <code>movies</code> repository and take a look at the results.</p></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-bash\" data-lang=\"bash\">curl -X GET 'http://service.cfapps.io/movie/movies'</code></pre></div></div><div class=\"paragraph\"><p>The results of this request show a traversable page of items that are returned by the paging and sorting repository for this domain entity.</p></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-json\" data-lang=\"json\">{<br />  \"_links\": {<br />    \"first\": {<br />      \"href\": \"http://service.cfapps.io/movie/movies?page=0&amp;size=20\",<br />      \"templated\": false<br />    },<br />    \"self\": {<br />      \"href\": \"http://service.cfapps.io/movie/movies\",<br />      \"templated\": false<br />    },<br />    \"next\": {<br />      \"href\": \"http://service.cfapps.io/movie/movies?page=1&amp;size=20\",<br />      \"templated\": false<br />    },<br />    \"last\": {<br />      \"href\": \"http://service.cfapps.io/movie/movies?page=83&amp;size=20\",<br />      \"templated\": false<br />    },<br />    \"search\": {<br />      \"href\": \"http://service.cfapps.io/movie/movies/search\",<br />      \"templated\": false<br />    }<br />  },<br />  \"_embedded\": {<br />    \"movies\": [<br />      {<br />        \"id\": 1,<br />        \"title\": \"Toy Story (1995)\",<br />        \"released\": 788918400000,<br />        \"url\": \"http://us.imdb.com/M/title-exact?Toy%20Story%20(1995)\",<br />        \"genres\": [<br />          {<br />            \"name\": \"Animation\"<br />          },<br />          {<br />            \"name\": \"Children's\"<br />          },<br />          {<br />            \"name\": \"Comedy\"<br />          }<br />        ],<br />        \"_links\": {<br />          \"self\": {<br />            \"href\": \"http://service.cfapps.io/movie/movies/1\",<br />            \"templated\": false<br />          },<br />          \"movie\": {<br />            \"href\": \"http://service.cfapps.io/movie/movies/1\",<br />            \"templated\": false<br />          }<br />        }<br />      }<br />      ...</code></pre></div></div></div></div></div></div><div class=\"sect1\"><h2 id=\"_adding_a_neo4j_data_service\">Adding a Neo4j Data Service</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p>Now let&#8217;s take a look at what a Spring Boot data service would look like if it exposed data from a Neo4j database. Since Spring Data provides a project for Neo4j, we can use a set of features that take advantage of the specialized traits of a graph database.</p></div><div class=\"paragraph\"><p>Instead of needing to specify a database driver in my classpath like we did with MySQL, I can provide dependencies in my <code>pom.xml</code> for the Spring Data Neo4j project.</p></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-xml\" data-lang=\"xml\">&lt;dependency&gt;<br />   &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;<br />   &lt;artifactId&gt;spring-data-neo4j&lt;/artifactId&gt;<br />   &lt;version&gt;3.4.0.RC1&lt;/version&gt;<br />&lt;/dependency&gt;<br />&lt;dependency&gt;<br />   &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;<br />   &lt;artifactId&gt;spring-data-neo4j-rest&lt;/artifactId&gt;<br />   &lt;version&gt;3.3.0.M1&lt;/version&gt;<br />&lt;/dependency&gt;</code></pre></div></div><div class=\"paragraph\"><p>Now I can use the specific features of the Spring Data Neo4j project, which gives native graph features like routing and graph traversals.</p></div><div class=\"sect2\"><h3 id=\"_rating_service\">Rating Service</h3><div class=\"paragraph\"><p>Going back to our domain model from earlier, I can see that users in my application can rate movies. We can use our Neo4j graph store as a way to index the connections between users and movies and later use that data to generate recommendations, a leading use case for graph databases.</p></div><div id=\"img-domain-graph-model-2\" class=\"imageblock\"><div class=\"content\"><img src=\"http://i.imgur.com/5vPmly4.png\" alt=\"Movie Domain\" width=\"70%\"></div><div class=\"title\">Figure 6. The domain model shows how we can use a graph database to analyze the connections between movies and users</div></div><div class=\"paragraph\"><p>Using the Zuul enabled reverse proxy, let&#8217;s take a look at what the <code>Rating Service</code> exposes from Neo4j.</p></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-bash\" data-lang=\"bash\">curl -X GET 'http://service.cfapps.io/rating'</code></pre></div></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-json\" data-lang=\"json\">{<br />  \"_links\": {<br />    \"products\": {<br />      \"href\": \"http://service.cfapps.io/rating/products{?page,size,sort}\",<br />      \"templated\": true<br />    },<br />    \"ratings\": {<br />      \"href\": \"http://service.cfapps.io/rating/ratings{?page,size,sort}\",<br />      \"templated\": true<br />    },<br />    \"users\": {<br />      \"href\": \"http://service.cfapps.io/rating/users{?page,size,sort}\",<br />      \"templated\": true<br />    },<br />    \"profile\": {<br />      \"href\": \"http://service.cfapps.io/rating/alps\",<br />      \"templated\": false<br />    }<br />  }<br />}</code></pre></div></div><div class=\"paragraph\"><p>We see from the results that we have 3 repositories that are exposed through REST and HATEOAS. The <code>/rating/products</code> endpoint is a generic form of the <code>movie</code> domain entity from our other service. Later we may want to offer things other than movies, this generic term saves us from having to change the semantics later if we enter a new line of business and still need recommendations.</p></div><div class=\"paragraph\"><p>One of the key differences between our Spring Data JPA MySQL repository for movies is that a graph model has different underlying entity types that describe our data: nodes and relationships.</p></div><div class=\"paragraph\"><p>Let&#8217;s take a look at the <code>/rating/ratings</code> endpoint, which exposes the ratings of a user and movie.</p></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-json\" data-lang=\"json\">...<br />\"ratings\": [<br />{<br />  \"id\": 87863,<br />  \"timestamp\": 881252305,<br />  \"rating\": 1,<br />  \"_links\": {<br />    \"self\": {<br />      \"href\": \"http://service.cfapps.io/ratings/87863\",<br />      \"templated\": false<br />    },<br />    \"rating\": {<br />      \"href\": \"http://service.cfapps.io/ratings/87863\",<br />      \"templated\": false<br />    },<br />    \"user\": {<br />      \"href\": \"http://service.cfapps.io/ratings/87863/user\",<br />      \"templated\": false<br />    },<br />    \"product\": {<br />      \"href\": \"http://service.cfapps.io/ratings/87863/product\",<br />      \"templated\": false<br />    }<br />  }<br />},<br />...</code></pre></div></div><div class=\"paragraph\"><p>The rating repository shows each relationship that connects a user to a product, and what they rated the product. The ID used for the user and the product relates back to the unique ID used by our other services that manage parts of our domain data, such as <code>Movie Service</code> and <code>User Service</code>.</p></div><div class=\"sect3\"><h4 id=\"_custom_graph_queries\">Custom Graph Queries</h4><div class=\"paragraph\"><p>Depending on how our connected data is used, we can create repository endpoints that allow us to bind certain REST API endpoints to tailored queries that use Neo4j&#8217;s Cypher query language.</p></div><div class=\"paragraph\"><p>One such example is the requirement to find all ratings for a user. The Cypher query to do this could be:</p></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-cypher\" data-lang=\"cypher\">MATCH (n:User)-[r:Rating]-&gt;() WHERE n.knownId = {id} RETURN r</code></pre></div></div><div class=\"paragraph\"><p>Here we are matching the pattern where a user has rated something, starting at the user&#8217;s ID and returning a list of the relationship entities containing the attributes of the rating entity.</p></div><div class=\"paragraph\"><p>To bind this query to our Spring Data REST repository we would describe it as follows:</p></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-java\" data-lang=\"java\">@RepositoryRestResource<br />public interface RatingRepository extends PagingAndSortingRepository&lt;Rating, Long&gt; {<br />    @Query(value = \"MATCH (n:User)-[r:Rating]-&gt;() WHERE n.knownId = {id} RETURN r\")<br />    Iterable&lt;Rating&gt; findByUserId(@Param(value = \"id\") String id);<br />}</code></pre></div></div><div class=\"paragraph\"><p>By registering this custom repository method, Spring Data REST will automatically register it as an embedded link in the rating&#8217;s REST repository. Let&#8217;s take a look.</p></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-bash\" data-lang=\"bash\">curl -X GET \"http://service.cfapps.io/rating/ratings/search/findByUserId?id=1\"</code></pre></div></div><div class=\"paragraph\"><p>The custom repository method will be added to the <code>rating</code> service&#8217;s <code>search</code> links. We can now call this new method by its name, as shown above.</p></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-json\" data-lang=\"json\">{<br />  \"_links\": {<br />    \"self\": {<br />      \"href\": \"http://service.cfapps.io/rating/ratings/search/findByUserId?id=1\",<br />      \"templated\": false<br />    }<br />  },<br />  \"_embedded\": {<br />    \"ratings\": [<br />      {<br />        \"id\": 87863,<br />        \"timestamp\": 881252305,<br />        \"rating\": 1<br />      },<br />      ...</code></pre></div></div></div></div><div class=\"sect2\"><h3 id=\"_binding_rest_clients\">Binding REST Clients</h3><div class=\"paragraph\"><p>The next thing we will want to do is to consume the data from our different polyglot persistence data services. To do this using Java is entirely too simple using Netflix Feign client, as described in my last blog post. Let&#8217;s take a look at what these client contracts might look like in a UI application.</p></div><div class=\"sect3\"><h4 id=\"_movie_client\">Movie Client</h4><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-java\" data-lang=\"java\">@FeignClient(\"movie\")<br />public interface MovieClient {<br /><br />  @RequestMapping(method = RequestMethod.GET, value = \"/movies\")<br />  PagedResources&lt;Movie&gt; findAll();<br /><br />  @RequestMapping(method = RequestMethod.GET,<br />      value = \"/movies/search/findByTitleContainingIgnoreCase?title={title}\")<br />  PagedResources&lt;Movie&gt; findByTitleContainingIgnoreCase(@PathVariable(\"title\") String title);<br /><br />  @RequestMapping(method = RequestMethod.GET, value = \"/movies/{id}\")<br />  List&lt;Movie&gt; findById(@PathVariable(\"id\") String id);<br /><br />  @RequestMapping(method = RequestMethod.GET,<br />      value = \"/movies/search/findByIdIn?ids={ids}\")<br />  PagedResources&lt;Movie&gt; findByIds(@PathVariable(\"ids\") String ids);<br />}</code></pre></div></div><div class=\"paragraph\"><p>The above interface declares that I would like to bind a method signature to the REST API route of the <code>movie</code> service, as configured by the <code>@FeignClient(\"movie\")</code> annotation. This interface will be registered as a bean when the application starts up and can be autowired in other beans in the application.</p></div><div class=\"paragraph\"><p>If you&#8217;re like me, when you think about how powerful this can be in a large operation with many microservices, it gets you excited about the future of developing cloud-native Java applications using Spring.</p></div></div><div class=\"sect3\"><h4 id=\"_autowire_a_feign_client\">Autowire a Feign Client</h4><div class=\"paragraph\"><p>The snippet below shows how we would auto wire our Feign Client interface for our <code>movie</code> service.</p></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-java\" data-lang=\"java\">@SpringUI(path = \"/movies\")<br />@Title(\"Movies\")<br />@Theme(\"valo\")<br />public class MovieUI extends UI {<br /><br />    private static final long serialVersionUID = -3540851800967573466L;<br /><br />    TextField filter = new TextField();<br />    Grid movieList = new Grid();<br /><br />    @Autowired<br />    MovieClient movieClient;<br /><br />    ...<br /><br />    private void refreshMovies(String stringFilter) {<br />        if(!Objects.equals(stringFilter.trim(), \"\")) {<br />            movieList.setContainerDataSource(new BeanItemContainer&lt;&gt;(<br />                    Movie.class, movieClient<br />                        .findByTitleContainingIgnoreCase(stringFilter) <i class=\"conum\" data-value=\"1\"></i><b>(1)</b><br />                        .getContent()));<br />        }<br />    }</code></pre></div></div><div class=\"colist arabic\"><table><tr><td><i class=\"conum\" data-value=\"1\"></i><b>1</b></td><td>We can call client APIs just as if they were Autowired repositories hosted within our application.</td></tr></table></div></div></div></div></div><div class=\"sect1\"><h2 id=\"_docker_demo\">Docker Demo</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p>The example project uses Docker to build a container image of each of our microservices as a part of the Maven build process. We can easily orchestrate the full microservice cluster on our machine using Docker compose.</p></div><div class=\"sect2\"><h3 id=\"_getting_started\">Getting Started</h3><div class=\"paragraph\"><p>To get started, visit the GitHub repository for this example project.</p></div><div class=\"paragraph\"><p><a href=\"https://github.com/kbastani/spring-cloud-polyglot-persistence-example\" class=\"bare\">https://github.com/kbastani/spring-cloud-polyglot-persistence-example</a></p></div><div class=\"paragraph\"><p>Clone or fork the project and download the repository to your machine. After downloading, you will need to use both Maven and Docker to compile and build the images locally.</p></div></div><div class=\"sect2\"><h3 id=\"_download_docker\">Download Docker</h3><div class=\"paragraph\"><p>First, download Docker if you haven&#8217;t already. Follow the instructions <a href=\"https://docs.docker.com/installation/\">found here</a>, to get Docker up and running on your development machine.</p></div><div class=\"paragraph\"><p>You will also need to install <a href=\"https://docs.docker.com/compose/\">Docker Compose</a>, the installation guide can be <a href=\"https://docs.docker.com/compose/install/\">found here</a>.</p></div></div><div class=\"sect2\"><h3 id=\"_requirements\">Requirements</h3><div class=\"paragraph\"><p>The requirements for running this demo on your machine are found below.</p></div><div class=\"ulist\"><ul><li><p>Maven 3</p></li><li><p>Java 8</p></li><li><p>Docker</p></li><li><p>Docker Compose</p></li></ul></div></div><div class=\"sect2\"><h3 id=\"_building_the_project\">Building the project</h3><div class=\"paragraph\"><p>To build the project, from the terminal, run the following command at the root of the project.</p></div><div class=\"listingblock\"><div class=\"content\"><pre>$ mvn clean install</pre></div></div><div class=\"paragraph\"><p>The project will then download all of the needed dependencies and compile each of the project artifacts. Each service will be built, and then a Maven Docker plugin will automatically build each of the images into your local Docker registry. Docker must be running and available from the command line where you run the <code>mvn clean install</code> command for the build to succeed.</p></div><div class=\"paragraph\"><p>After the project successfully builds, you’ll see the following output:</p></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-bash\" data-lang=\"bash\">[INFO] ------------------------------------------------------------------------<br />[INFO] Reactor Summary:<br />[INFO]<br />[INFO] spring-cloud-microservice-example-parent ........... SUCCESS [  0.478 s]<br />[INFO] user-microservice .................................. SUCCESS [ 36.055 s]<br />[INFO] discovery-microservice ............................. SUCCESS [ 15.911 s]<br />[INFO] api-gateway-microservice ........................... SUCCESS [ 17.904 s]<br />[INFO] config-microservice ................................ SUCCESS [ 11.513 s]<br />[INFO] movie-microservice ................................. SUCCESS [ 13.818 s]<br />[INFO] ui-search .......................................... SUCCESS [ 31.328 s]<br />[INFO] rating-microservice ................................ SUCCESS [ 22.910 s]<br />[INFO] ------------------------------------------------------------------------<br />[INFO] BUILD SUCCESS<br />[INFO] ------------------------------------------------------------------------</code></pre></div></div></div><div class=\"sect2\"><h3 id=\"_start_the_cluster_with_docker_compose\">Start the Cluster with Docker Compose</h3><div class=\"paragraph\"><p>Now that each of the images has been built successfully, we can using Docker Compose to spin up our cluster. I’ve included a pre-configured Docker Compose yaml file with the project.</p></div><div class=\"paragraph\"><p>From the project root, navigate to the <code>spring-cloud-polyglot-persistence-example/docker</code> directory.</p></div><div class=\"paragraph\"><p>Now, to startup the microservice cluster, run the following command:</p></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-bash\" data-lang=\"bash\">$ docker-compose up</code></pre></div></div><div class=\"paragraph\"><p>If everything is configured correctly, each of the container images we built earlier will be launched within their VM container on Docker and networked for automatic service discovery. You will see a flurry of log output from each of the services as they begin their startup sequence. This might take a few minutes to complete, depending on the performance of the machine you’re running this demo on.</p></div><div class=\"paragraph\"><p>Once the startup sequence is completed, you can navigate to the Eureka host and see which services have registered with the discovery service.</p></div><div class=\"paragraph\"><p>Copy and paste the following command into the terminal where Docker can be accessed using the <code>$DOCKER_HOST</code> environment variable.</p></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-bash\" data-lang=\"bash\">$ open $(echo \\\"$(echo $DOCKER_HOST)\\\"|<br />            \\sed 's/tcp:\\/\\//http:\\/\\//g'|<br />            \\sed 's/[0-9]\\{4,\\}/8761/g'|<br />            \\sed 's/\\\"//g')</code></pre></div></div><div class=\"paragraph\"><p>If Eureka correctly started up, a browser window will open to the location of the Eureka service’s dashboard.</p></div><div class=\"admonitionblock note\"><table><tr><td class=\"icon\"><i class=\"fa icon-note\" title=\"Note\"></i></td><td class=\"content\">You&#8217;ll need to wait for Eureka to start and see that all the other services are registered before proceeding. If Eureka is not yet available, give Docker Compose a few more minutes to get all the services fully started. </td></tr></table></div></div><div class=\"sect2\"><h3 id=\"_sidecar_routes\">Sidecar Routes</h3><div class=\"paragraph\"><p>After all the services have started up and registered with Eureka, we can see each of the service instances that are running and their status. We can then access one of the data-driven services, for example the movie service. The following command will open a browser window and display the routes that have been bootstrapped on the API Gateway using the <code>@EnableZuulProxy</code> ane <code>@EnableSidecar</code> annotations.</p></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-bash\" data-lang=\"bash\">$ open $(echo \\\"$(echo $DOCKER_HOST)/routes\\\"|<br />            \\sed 's/tcp:\\/\\//http:\\/\\//g'|<br />            \\sed 's/[0-9]\\{4,\\}/10000/g'|<br />            \\sed 's/\\\"//g')</code></pre></div></div><div class=\"paragraph\"><p>This command will navigate to the API gateway’s endpoint display each route that has been discovered through the Zuul Sidecar.</p></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-bash\" data-lang=\"bash\">{<br />  \"_links\" : {<br />    \"self\" : {<br />      \"href\" : \"http://192.168.59.103:10000/routes\",<br />      \"templated\" : false<br />    }<br />  },<br />  \"/gateway/**\" : \"gateway\",<br />  \"/movie/**\" : \"movie\",<br />  \"/rating/**\" : \"rating\",<br />  \"/moviesui/**\" : \"moviesui\",<br />  \"/user/**\" : \"user\",<br />  \"/discovery/**\" : \"discovery\"<br />}</code></pre></div></div></div><div class=\"sect2\"><h3 id=\"_movies_ui\">Movies UI</h3><div class=\"paragraph\"><p>I&#8217;ve created a simple <a href=\"https://vaadin.com/wiki/-/wiki/Spring+Vaadin/I+-+Getting+Started+with+Vaadin+Spring+and+Spring+Boot\">Spring Boot Vaadin</a> application to allow us to consume our data services and perform simple searches.</p></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-bash\" data-lang=\"bash\">$ open $(echo \\\"$(echo $DOCKER_HOST)/movies\\\"|<br />            \\sed 's/tcp:\\/\\//http:\\/\\//g'|<br />            \\sed 's/[0-9]\\{4,\\}/1111/g'|<br />            \\sed 's/\\\"//g')</code></pre></div></div><div class=\"paragraph\"><p>This command will open up the <code>search-ui</code> application and allow us to search for movies. Try typing in one of your favorite movies from the early 90s like I&#8217;ve done in the screen shot below.</p></div><div id=\"img-vaadin-ui-movies\" class=\"imageblock\"><div class=\"content\"><img src=\"http://i.imgur.com/KCS1riY.png\" alt=\"Vaadin Movies\" style=\"max-height: 38em;\"></div><div class=\"title\">Figure 7. Search Movies UI</div></div></div><div class=\"sect2\"><h3 id=\"_users_ui\">Users UI</h3><div class=\"paragraph\"><p>Paste the following command into your terminal to open the user application.</p></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-bash\" data-lang=\"bash\">$ open $(echo \\\"$(echo $DOCKER_HOST)/users\\\"|<br />            \\sed 's/tcp:\\/\\//http:\\/\\//g'|<br />            \\sed 's/[0-9]\\{4,\\}/1111/g'|<br />            \\sed 's/\\\"//g')</code></pre></div></div><div class=\"paragraph\"><p>I created this view to display the results from querying the <code>User Service</code>, the <code>Rating Service</code>, and the <code>Movie Service</code>. This example demonstrates how fast Spring Boot can handle queries that span multiple data services. There are two view in this page. The table view to the left displays users that are returned from our <code>User Service</code>. The table to the right will display the movies that a user has previously rated. To activate the view on the right, click on one of the table rows containing a user record, as shown below.</p></div><div id=\"img-vaadin-ui-users\" class=\"imageblock\"><div class=\"content\"><img src=\"http://i.imgur.com/fPMtn3f.png\" alt=\"Vaadin Users\" style=\"max-height: 38em;\"></div><div class=\"title\">Figure 8. Search Users UI</div></div></div></div></div></div>",
  "enclosure": "",
  "link": "https://www.kennybastani.com/2015/08/polyglot-persistence-spring-cloud-docker.html",
  "author": "noreply@blogger.com (Kenny Bastani)",
  "thr:total": 0
}