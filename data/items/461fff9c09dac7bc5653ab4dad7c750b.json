{
  "title": "Avoid unsigned integers in C++ if you can",
  "link": "",
  "published": "2016-03-17T10:00:00-07:00",
  "updated": "2016-03-17T10:00:00-07:00",
  "author": {
    "name": "Wes McKinney"
  },
  "id": "tag:wesmckinney.com,2016-03-17:/blog/avoid-unsigned-integers/",
  "summary": "<p>Unsigned integers (<code>size_t</code>, <code>uint32_t</code>, and friends) can be hazardous, as\nsigned-to-unsigned integer conversions can happen without so much as a compiler\nwarning.</p>",
  "content": "<p>Unsigned integers (<code>size_t</code>, <code>uint32_t</code>, and friends) can be hazardous, as\nsigned-to-unsigned integer conversions can happen without so much as a compiler\nwarning.</p>\n\n\n<h3>An example: <code>size_t</code> as an index variable</h3>\n<p>Occasionally, discussions come up about using unsigned integers as index\nvariables for STL containers (whose <code>size()</code> attribute is unsigned). So the\ndebate is between effectively these two alternatives:</p>\n<div class=\"github\"><pre><span></span><code><span class=\"cp\">#include</span><span class=\"w\"> </span><span class=\"cpf\">&lt;iostream&gt;</span><span class=\"cp\"></span>\n\n<span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"nf\">do_something_unsigned</span><span class=\"p\">(</span><span class=\"kt\">size_t</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"s\">&quot;I see: &quot;</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"nf\">do_something_signed</span><span class=\"p\">(</span><span class=\"kt\">int</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"s\">&quot;I see: &quot;</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"kt\">int</span><span class=\"w\"> </span><span class=\"nf\">main</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">do_something_unsigned</span><span class=\"p\">(</span><span class=\"mi\">-1</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">do_something_signed</span><span class=\"p\">(</span><span class=\"mi\">-1</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n<p>This compiles in gcc with no warnings (unless you set <code>-Wconversion</code>, but in\ngeneral this results in a huge amount of warnings), and the results are not\nwhat you expect:</p>\n<div class=\"github\"><pre><span></span><code>$ ./a.out\nI see: <span class=\"m\">18446744073709551615</span>\nI see: -1\n</code></pre></div>\n\n<p>Since this programmer mistake can happen by accident due to pointer arithmetic\nerrors and other buglets, you're sometimes looking at a segfault or core dump\nrather than a more sane error message.</p>\n<p>Pedantic note: for platforms with 32-bit <code>int</code> and concerns about overflows,\nsubstitute <code>int64_t</code> for the purposes of this discussion.</p>\n<h3>What to do instead</h3>\n<p>The Google C++ style guide recommends <a href=\"https://google.github.io/styleguide/cppguide.html#Integer_Types\">avoiding unsigned integers</a> except in\nsituations that definitely require it (for example: file formats often store\nsizes in <code>uint32_t</code> or <code>uint64_t</code> -- no point in wasting a signedness bit that\nwill never be used).</p>\n<blockquote>\n<p>\"In particular, do not use unsigned types to say a number will never be\nnegative. Instead, use assertions for this.\" - Google C++ Style Guide</p>\n</blockquote>\n<p>You also <em>do</em> need to be able to check if a variable that should not be\nnegative ended up being accidentally negative. One approach that many Google\nprojects (and projects developing in the Google style, like the Apache\nincubator projects Impala and Kudu) take is using <code>DCHECK</code> macros:</p>\n<div class=\"github\"><pre><span></span><code><span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"nf\">do_something_signed</span><span class=\"p\">(</span><span class=\"kt\">int</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">DCHECK</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">&gt;=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"s\">&quot;i cannot be negative&quot;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"s\">&quot;I see: &quot;</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n<p>These assertions are generally disabled in release builds, but while you are\ndeveloping a project in <code>DEBUG</code> mode (and running your test suite), you get\nhelpful error messages when you break a \"can't happen\" contract without\nsuffering a performance penalty in production.</p>\n<p>Of course, like all things C++-related, this is just my opinion. Feel free to\nuse unsigned integers for function arguments, but they may not buy you the\nprotection from negative numbers that you're after.</p>"
}