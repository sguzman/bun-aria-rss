{
  "title": "In Defense of a Switch",
  "link": "",
  "published": "2020-09-02T00:00:00+00:00",
  "updated": "2020-09-02T00:00:00+00:00",
  "id": "https://pkolaczk.github.io/in-defense-of-switch",
  "content": "<p>Recently I came across a <a href=\"https://levelup.gitconnected.com/if-else-is-a-poor-mans-polymorphism-ab0b333b7265\">blog post</a>\nwhose author claims, from the perspective of good coding practices, polymorphism is strictly superior to branching. \nIn the post they make general statements about how branching statements lead to unreadable, unmaintainable, inflexible code and\nhow they are a sign of immaturity. However, in my opinion, the topic is much deeper and in this post \nI try to objectively discuss the reasons for and against branching.</p>\n\n<!--more-->\n\n<h1 id=\"is-my-code-easy-to-extend\">Is My Code Easy to Extend?</h1>\n\n<p>Before I dive into polymorphism vs branching dilemma, let’s first define what we mean when we say some code is\nflexible and easy to extend. In my career I reviewed thousands of lines of code, and I had thousands of lines of my code\nreviewed by others, and during these reviews it often occured that the terms <em>code extensibility</em> or <em>flexibility</em> \nmean different things to different people. Familiarity with the code-base or particular programming style plays a huge role.</p>\n\n<p>For example, someone used to writing code in a Java/C# OOP style would generally consider dynamic polymorphism through \ninterfaces a standard way of providing extensibility to the code, \nwhile a C programmer may find a switch or if/else much more \napproachable than OOP. There are also many other factors related \nto maintainability as quality of documentation, good naming, separation of concerns, etc. These factors are orthogonal \nto the “polymorphism vs branching” dimension and also far too broad for a single blog post, so I won’t discuss them.</p>\n\n<p>For the sake of this post, let’s define <em>extensibility</em> as the inverse of number of distinct units in the codebase\nthat need to be changed in order to implement a new feature. The more places you have to touch to implement the feature, \nthe harder the code is to change. Obviously, it is much better when you have to touch only\none unit of code (one function, one class, one module, one package) rather than change 10 distinct unrelated units.</p>\n\n<h1 id=\"example\">Example</h1>\n<p>Imagine you’re writing a calculator. Your program gets an expression as an input and outputs the computed value.\nFor example the user inputs <code class=\"language-plaintext highlighter-rouge\">1 + 2 * 3</code> and the output is <code class=\"language-plaintext highlighter-rouge\">7</code> \n(or <code class=\"language-plaintext highlighter-rouge\">9</code> if you’ve messed up the operator precedence like one of my former CS students).</p>\n\n<p>Why such a silly example? Who is writing calculators these days? Probably no-one, but this looks like a classic example given\nin many programming classes. And it is easy enough to illustrate the concept.</p>\n\n<p>How can we model a structure to represent an expression?\nYou’d probably use classes or structures. Here is the code in Scala:</p>\n\n<div class=\"language-scala highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">trait</span> <span class=\"nc\">Expression</span> <span class=\"o\">{</span>\n    <span class=\"k\">def</span> <span class=\"nf\">eval</span><span class=\"k\">:</span> <span class=\"kt\">Double</span>\n<span class=\"o\">}</span>\n\n<span class=\"k\">case</span> <span class=\"k\">class</span> <span class=\"nc\">Const</span><span class=\"o\">(</span><span class=\"n\">value</span><span class=\"k\">:</span> <span class=\"kt\">Double</span><span class=\"o\">)</span> <span class=\"k\">extends</span> <span class=\"nc\">Expression</span> <span class=\"o\">{</span>\n    <span class=\"k\">def</span> <span class=\"nf\">eval</span><span class=\"k\">:</span> <span class=\"kt\">Double</span> <span class=\"o\">=</span> <span class=\"n\">value</span>\n<span class=\"o\">}</span>\n\n<span class=\"k\">case</span> <span class=\"k\">class</span> <span class=\"nc\">Add</span><span class=\"o\">(</span><span class=\"n\">left</span><span class=\"k\">:</span> <span class=\"kt\">Expression</span><span class=\"o\">,</span> <span class=\"n\">right</span><span class=\"k\">:</span> <span class=\"kt\">Expression</span><span class=\"o\">)</span> <span class=\"k\">extends</span> <span class=\"nc\">Expression</span> <span class=\"o\">{</span>\n    <span class=\"k\">def</span> <span class=\"nf\">eval</span><span class=\"k\">:</span> <span class=\"kt\">Double</span> <span class=\"o\">=</span> <span class=\"nv\">left</span><span class=\"o\">.</span><span class=\"py\">eval</span> <span class=\"o\">+</span> <span class=\"nv\">right</span><span class=\"o\">.</span><span class=\"py\">eval</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>Then it is quite easy to build an expression and evaluate it:</p>\n<div class=\"language-scala highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Add</span><span class=\"o\">(</span><span class=\"nc\">Const</span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">),</span> <span class=\"nc\">Const</span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">)).</span><span class=\"py\">eval</span> <span class=\"c1\">// evaluates to 5 </span>\n</code></pre></div></div>\n\n<h1 id=\"adding-new-classes\">Adding New Classes</h1>\n<p>This OOP-based solution is indeed very extensible when it comes to add a new operator.\nThe example above is missing subtraction operation. We can add one by defining a new class:</p>\n\n<div class=\"language-scala highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">case</span> <span class=\"k\">class</span> <span class=\"nc\">Sub</span><span class=\"o\">(</span><span class=\"n\">left</span><span class=\"k\">:</span> <span class=\"kt\">Expression</span><span class=\"o\">,</span> <span class=\"n\">right</span><span class=\"k\">:</span> <span class=\"kt\">Expression</span><span class=\"o\">)</span> <span class=\"k\">extends</span> <span class=\"nc\">Expression</span> <span class=\"o\">{</span>\n    <span class=\"k\">def</span> <span class=\"nf\">eval</span><span class=\"k\">:</span> <span class=\"kt\">Double</span> <span class=\"o\">=</span> <span class=\"nv\">left</span><span class=\"o\">.</span><span class=\"py\">eval</span> <span class=\"o\">-</span> <span class=\"nv\">right</span><span class=\"o\">.</span><span class=\"py\">eval</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>That’s really awesome – we didn’t have to touch any old code at all! \nOOP definitely rocks here.</p>\n\n<h1 id=\"adding-new-operations\">Adding New Operations</h1>\n<p>Imagine you continued to extend our calculation engine with more operation classes over the next few years.\nYou’ve added multiplication, division, modulo, variables, logarithms, trigonometric functions, etc.</p>\n\n<p>Then suddenly a new requirement comes – users want to not only evaluate the value of an expression,\nbut also do symbolic manipulation – e.g. simplify expressions. For example, given an expression\n<code class=\"language-plaintext highlighter-rouge\">a + a</code> they want to get an expression <code class=\"language-plaintext highlighter-rouge\">2 * a</code> as a result.</p>\n\n<p>This requirement can’t be captured by the <code class=\"language-plaintext highlighter-rouge\">eval</code> method on the <code class=\"language-plaintext highlighter-rouge\">Expression</code> interface. We need a new method:</p>\n\n<div class=\"language-scala highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">trait</span> <span class=\"nc\">Expression</span> <span class=\"o\">{</span>\n    <span class=\"k\">def</span> <span class=\"nf\">eval</span><span class=\"k\">:</span> <span class=\"kt\">Double</span>\n    <span class=\"k\">def</span> <span class=\"nf\">simplify</span><span class=\"k\">:</span> <span class=\"kt\">Expression</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>And as the next step, they would likely want to be able to display the expression as a String:</p>\n\n<div class=\"language-scala highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">trait</span> <span class=\"nc\">Expression</span> <span class=\"o\">{</span>\n    <span class=\"k\">def</span> <span class=\"nf\">eval</span><span class=\"k\">:</span> <span class=\"kt\">Double</span>\n    <span class=\"k\">def</span> <span class=\"nf\">simplify</span><span class=\"k\">:</span> <span class=\"kt\">Expression</span>\n    <span class=\"k\">def</span> <span class=\"nf\">toString</span><span class=\"k\">:</span> <span class=\"kt\">String</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>How many units of code do you have to change now to implement these features?\n<strong>All the implementations of <code class=\"language-plaintext highlighter-rouge\">Expression</code></strong>. Before touching all the classes, the code wouldn’t even compile.\nIt looks like in the context of this kind of feature, our polymorphic solution is terribly non-extensible.</p>\n\n<h1 id=\"what-can-switch-do-about-it\">What Can Switch Do About It?</h1>\n<p>Let’s take a step back and let’s see how we could implement this differently.\nScala and many other modern languages have a feature called <em>pattern matching</em>\nwhich can be considered a very flexible, powerful switch.</p>\n\n<p>Instead of defining the operations like <code class=\"language-plaintext highlighter-rouge\">eval</code> or <code class=\"language-plaintext highlighter-rouge\">simplify</code> on the case classes,\nlet’s pull them up:</p>\n\n<div class=\"language-scala highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">trait</span> <span class=\"nc\">Expression</span> <span class=\"o\">{</span>\n<span class=\"k\">case</span> <span class=\"k\">class</span> <span class=\"nc\">Const</span><span class=\"o\">(</span><span class=\"n\">value</span><span class=\"k\">:</span> <span class=\"kt\">Double</span><span class=\"o\">)</span> <span class=\"k\">extends</span> <span class=\"nc\">Expression</span>\n<span class=\"k\">case</span> <span class=\"k\">class</span> <span class=\"nc\">Add</span><span class=\"o\">(</span><span class=\"n\">left</span><span class=\"k\">:</span> <span class=\"kt\">Expression</span><span class=\"o\">,</span> <span class=\"n\">right</span><span class=\"k\">:</span> <span class=\"kt\">Expression</span><span class=\"o\">)</span> <span class=\"k\">extends</span> <span class=\"nc\">Expression</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">eval</span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"k\">:</span> <span class=\"kt\">Expression</span><span class=\"o\">)</span><span class=\"k\">:</span> <span class=\"kt\">Double</span> <span class=\"o\">=</span> <span class=\"o\">{</span>\n  <span class=\"n\">e</span> <span class=\"k\">match</span> <span class=\"o\">{</span>\n    <span class=\"k\">case</span> <span class=\"nc\">Const</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"k\">=&gt;</span> <span class=\"n\">x</span>\n    <span class=\"k\">case</span> <span class=\"nc\">Add</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"k\">=&gt;</span> <span class=\"n\">a</span> <span class=\"o\">+</span> <span class=\"n\">b</span>\n  <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>Now adding a new operation like <code class=\"language-plaintext highlighter-rouge\">Sub</code> would require two changes to the code – adding a new class\n<em>and</em> adding a new case in the match (switch) statement.</p>\n\n<p>Some may say this much worse not only because of more places to update, but because of a possibility of\nforgetting to update the switches which could lead to runtime errors due to unhandled cases.\nFortunately, Scala designers thought about this by providing the <code class=\"language-plaintext highlighter-rouge\">sealed</code> keyword, which instructs the compiler\nthat all case classes can be defined in the same module only. This unlocks pattern exhaustiveness analysis and the\ncompiler would warn about missing cases:</p>\n\n<div class=\"language-scala highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">sealed</span> <span class=\"k\">trait</span> <span class=\"nc\">Expression</span>\n<span class=\"k\">case</span> <span class=\"k\">class</span> <span class=\"nc\">Const</span><span class=\"o\">(</span><span class=\"n\">value</span><span class=\"k\">:</span> <span class=\"kt\">Double</span><span class=\"o\">)</span> <span class=\"k\">extends</span> <span class=\"nc\">Expression</span>\n<span class=\"k\">case</span> <span class=\"k\">class</span> <span class=\"nc\">Add</span><span class=\"o\">(</span><span class=\"n\">left</span><span class=\"k\">:</span> <span class=\"kt\">Expression</span><span class=\"o\">,</span> <span class=\"n\">right</span><span class=\"k\">:</span> <span class=\"kt\">Expression</span><span class=\"o\">)</span> <span class=\"k\">extends</span> <span class=\"nc\">Expression</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">eval</span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"k\">:</span> <span class=\"kt\">Expression</span><span class=\"o\">)</span><span class=\"k\">:</span> <span class=\"kt\">Double</span> <span class=\"o\">=</span> <span class=\"o\">{</span>\n  <span class=\"n\">e</span> <span class=\"k\">match</span> <span class=\"o\">{</span>\n    <span class=\"k\">case</span> <span class=\"nc\">Const</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"k\">=&gt;</span> <span class=\"n\">x</span>\n    <span class=\"k\">case</span> <span class=\"nc\">Add</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"k\">=&gt;</span> <span class=\"n\">a</span> <span class=\"o\">+</span> <span class=\"n\">b</span>\n  <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>What about adding new functions like <code class=\"language-plaintext highlighter-rouge\">simplify</code> or <code class=\"language-plaintext highlighter-rouge\">toString</code>? \nIt requires to changle only <strong>one place</strong> – by adding the required methods. \nNo changes to the existing code are needed!</p>\n\n<div class=\"language-scala highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">simplify</span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"k\">:</span> <span class=\"kt\">Expression</span><span class=\"o\">)</span><span class=\"k\">:</span> <span class=\"kt\">Expression</span> <span class=\"o\">=</span> <span class=\"o\">{</span>\n  <span class=\"n\">e</span> <span class=\"k\">match</span> <span class=\"o\">{</span>\n    <span class=\"k\">case</span> <span class=\"nc\">Add</span><span class=\"o\">(</span><span class=\"nc\">Const</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">),</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"k\">=&gt;</span> <span class=\"n\">x</span>\n    <span class=\"k\">case</span> <span class=\"nc\">Add</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"nc\">Const</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"k\">=&gt;</span> <span class=\"n\">x</span>\n    <span class=\"k\">case</span> <span class=\"n\">other</span> <span class=\"k\">=&gt;</span> <span class=\"n\">other</span>\n  <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">toString</span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"k\">:</span> <span class=\"kt\">Expression</span><span class=\"o\">)</span><span class=\"k\">:</span> <span class=\"kt\">String</span> <span class=\"o\">=</span> <span class=\"o\">{</span>\n  <span class=\"n\">e</span> <span class=\"k\">match</span> <span class=\"o\">{</span>\n    <span class=\"k\">case</span> <span class=\"nc\">Const</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"k\">=&gt;</span> <span class=\"nv\">x</span><span class=\"o\">.</span><span class=\"py\">toString</span>\n    <span class=\"k\">case</span> <span class=\"nc\">Add</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"k\">=&gt;</span> <span class=\"s\">\"(\"</span> <span class=\"o\">+</span> <span class=\"nf\">toString</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">+</span> <span class=\"s\">\" + \"</span> <span class=\"o\">+</span> <span class=\"nf\">toString</span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">+</span> <span class=\"err\">\"</span><span class=\"o\">)</span> \n  <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<h1 id=\"code-readability\">Code Readability</h1>\n<p>The blog post I mentioned in the introduction stated that using polymorphism instead of\nbranching leads to more readable code. I find this statement far too general and actually very debatable.</p>\n\n<p>First, even in their own example given by the author of that blog, the solution using branching was a lot\nshorter and less complex than the solution using OOP. While brief code is not always more readable than a longer version of it,\nin that case, I found branching to be very explicit and easy to follow. \nIt is much easier to understand the control flow\nin such a program because all targets are explicitly given in a single place. In the OOP solution, \nthe actual implementations are hidden behind the interface and it is much harder to find them all without additional \nhelp of a good IDE with a “jump to implementations” feature \n(which fortunately often works well for statically typed languages, but I’ve seen IDEs sometimes \nstruggle with dynamic languages like Python).</p>\n\n<p>Second, in general case, branching has an advantage that the function logic may depend on more than\none object type or even the actual data. For example, in the example from this post, \nthe transformation <code class=\"language-plaintext highlighter-rouge\">a * (b + c)</code> =&gt; <code class=\"language-plaintext highlighter-rouge\">a * b + a * c</code> would depend on \nboth addition and multiplication. In the classic OOP solution, would you place it in the <code class=\"language-plaintext highlighter-rouge\">Add</code> or in the <code class=\"language-plaintext highlighter-rouge\">Mul</code> class? \nNeither seems right. Also, putting it into one of them creates a dependency on the other one. \nAn expression simplifier with code scattered accross multiple classes heavily depending on each other \nwould be hard to understand.</p>\n\n<h1 id=\"performance\">Performance</h1>\n<p>This is a blog on high performance programming, so the post would be incomplete without a \nsection on performance. In theory, a sufficiently good compiler should produce the same\ncode regardless of the choice between branching or dynamic polymorphism, but is this the case in reality?\nCompilers have limitations and often don’t generate the best result code possible.</p>\n\n<p>Let’s consider a more realistic example this time.\nSome time ago I was working on serializing/deserializing code in a database system.\nI stumbled upon a set of classes that described data types. They all implemented \na common interface defining methods for serializing and deserializing values of given data type\nand also computing serialized data lenghts. The following Rust snippet is a huge simplification \nof that code, but it illustrates the concept:</p>\n\n<div class=\"language-rust highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">pub</span> <span class=\"k\">trait</span> <span class=\"n\">DataType</span> <span class=\"p\">{</span>\n    <span class=\"k\">fn</span> <span class=\"nf\">len</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">self</span><span class=\"p\">)</span> <span class=\"k\">-&gt;</span> <span class=\"nb\">usize</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">pub</span> <span class=\"k\">struct</span> <span class=\"n\">BoolType</span><span class=\"p\">;</span>\n<span class=\"k\">pub</span> <span class=\"k\">struct</span> <span class=\"n\">IntType</span><span class=\"p\">;</span>\n<span class=\"k\">pub</span> <span class=\"k\">struct</span> <span class=\"n\">LongType</span><span class=\"p\">;</span>\n\n<span class=\"k\">impl</span> <span class=\"n\">DataType</span> <span class=\"k\">for</span> <span class=\"n\">BoolType</span> <span class=\"p\">{</span>\n    <span class=\"k\">fn</span> <span class=\"nf\">len</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">self</span><span class=\"p\">)</span> <span class=\"k\">-&gt;</span> <span class=\"nb\">usize</span> <span class=\"p\">{</span> <span class=\"mi\">1</span> <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">impl</span> <span class=\"n\">DataType</span> <span class=\"k\">for</span> <span class=\"n\">IntType</span> <span class=\"p\">{</span>\n    <span class=\"k\">fn</span> <span class=\"nf\">len</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">self</span><span class=\"p\">)</span> <span class=\"k\">-&gt;</span> <span class=\"nb\">usize</span> <span class=\"p\">{</span> <span class=\"mi\">4</span> <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">impl</span> <span class=\"n\">DataType</span> <span class=\"k\">for</span> <span class=\"n\">LongType</span> <span class=\"p\">{</span>\n    <span class=\"k\">fn</span> <span class=\"nf\">len</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">self</span><span class=\"p\">)</span> <span class=\"k\">-&gt;</span> <span class=\"nb\">usize</span> <span class=\"p\">{</span> <span class=\"mi\">8</span> <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">pub</span> <span class=\"k\">fn</span> <span class=\"nf\">data_len</span><span class=\"p\">(</span><span class=\"n\">data_type</span><span class=\"p\">:</span> <span class=\"o\">&amp;</span><span class=\"n\">dyn</span> <span class=\"n\">DataType</span><span class=\"p\">)</span> <span class=\"k\">-&gt;</span> <span class=\"nb\">usize</span> <span class=\"p\">{</span>\n    <span class=\"n\">data_type</span><span class=\"nf\">.len</span><span class=\"p\">()</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>Given a reference to a <code class=\"language-plaintext highlighter-rouge\">DataType</code> object, it is trivial to compute the data size associated with it, \nwithout knowing the exact static type:</p>\n\n<div class=\"language-rust highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">let</span> <span class=\"n\">t1</span> <span class=\"o\">=</span> <span class=\"n\">IntType</span><span class=\"p\">;</span>\n<span class=\"k\">let</span> <span class=\"n\">t2</span> <span class=\"o\">=</span> <span class=\"n\">LongType</span><span class=\"p\">;</span>\n<span class=\"k\">let</span> <span class=\"n\">v</span><span class=\"p\">:</span> <span class=\"nb\">Vec</span><span class=\"o\">&lt;&amp;</span><span class=\"n\">dyn</span> <span class=\"n\">DataType</span><span class=\"o\">&gt;</span> <span class=\"o\">=</span> <span class=\"nd\">vec!</span><span class=\"p\">[</span><span class=\"o\">&amp;</span><span class=\"n\">t1</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">t2</span><span class=\"p\">];</span>\n<span class=\"nd\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span> <span class=\"nf\">data_len</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]));</span>  <span class=\"c\">// prints 4</span>\n<span class=\"nd\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span> <span class=\"nf\">data_len</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]));</span>  <span class=\"c\">// prints 8</span>\n</code></pre></div></div>\n\n<h2 id=\"performance-of-dynamic-dispatch\">Performance of Dynamic Dispatch</h2>\n\n<p>The implementation of the <code class=\"language-plaintext highlighter-rouge\">data_len</code> function is actually very simple:</p>\n<div class=\"language-nasm highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nf\">jmpq</span> <span class=\"o\">*</span><span class=\"mh\">0x18</span><span class=\"p\">(</span><span class=\"o\">%</span><span class=\"nb\">rsi</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<p>Wow! A single assembly instruction! \nIt jumps to the address stored in the the vtable of the object pointed by the <code class=\"language-plaintext highlighter-rouge\">rsi</code> register.\nThe target of the jump depends on the actual type of the object. Here is the code generated for <code class=\"language-plaintext highlighter-rouge\">IntType.len</code>:</p>\n\n<div class=\"language-nasm highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nf\">mov</span>  <span class=\"kc\">$</span><span class=\"mh\">0x4</span><span class=\"p\">,</span><span class=\"o\">%</span><span class=\"nb\">eax</span>\n<span class=\"nf\">retq</span>\n</code></pre></div></div>\n\n<p>The codes for the other types differ only in the constant value.</p>\n\n<p>These are only 3 instructions to return the result. Shouldn’t it be fast? \nLet’s measure this. Let’s put more random <code class=\"language-plaintext highlighter-rouge\">DataType</code> objects into a vector, \niterate them and print out the sum of the values returned by <code class=\"language-plaintext highlighter-rouge\">data_len()</code> to avoid any attempts \nat dead code elimination by the compiler:</p>\n\n<div class=\"language-rust highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">let</span> <span class=\"k\">mut</span> <span class=\"n\">rng</span> <span class=\"o\">=</span> <span class=\"nn\">rand</span><span class=\"p\">::</span><span class=\"nf\">thread_rng</span><span class=\"p\">();</span>\n<span class=\"k\">let</span> <span class=\"k\">mut</span> <span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"nn\">Vec</span><span class=\"p\">::</span><span class=\"o\">&lt;</span><span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"n\">dyn</span> <span class=\"n\">DataType</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">::</span><span class=\"nf\">new</span><span class=\"p\">();</span>\n<span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"n\">in</span> <span class=\"mi\">1</span><span class=\"o\">..</span><span class=\"mi\">1000000</span> <span class=\"p\">{</span>\n    <span class=\"k\">match</span> <span class=\"n\">rng</span><span class=\"nf\">.gen_range</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"mi\">0</span> <span class=\"k\">=&gt;</span> <span class=\"n\">data</span><span class=\"nf\">.push</span><span class=\"p\">(</span><span class=\"nn\">Box</span><span class=\"p\">::</span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">BoolType</span><span class=\"p\">)),</span>\n        <span class=\"mi\">1</span> <span class=\"k\">=&gt;</span> <span class=\"n\">data</span><span class=\"nf\">.push</span><span class=\"p\">(</span><span class=\"nn\">Box</span><span class=\"p\">::</span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">IntType</span><span class=\"p\">)),</span>\n        <span class=\"mi\">_</span> <span class=\"k\">=&gt;</span> <span class=\"n\">data</span><span class=\"nf\">.push</span><span class=\"p\">(</span><span class=\"nn\">Box</span><span class=\"p\">::</span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">LongType</span><span class=\"p\">)),</span>        \n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">let</span> <span class=\"k\">mut</span> <span class=\"n\">len</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"n\">in</span> <span class=\"mi\">0</span><span class=\"o\">..</span><span class=\"mi\">1000</span> <span class=\"p\">{</span>\n    <span class=\"k\">for</span> <span class=\"n\">dt</span> <span class=\"n\">in</span> <span class=\"n\">data</span><span class=\"nf\">.iter</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n        <span class=\"n\">len</span> <span class=\"o\">+=</span> <span class=\"nf\">data_len</span><span class=\"p\">(</span><span class=\"n\">dt</span><span class=\"nf\">.as_ref</span><span class=\"p\">());</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"nd\">println!</span><span class=\"p\">(</span><span class=\"s\">\"Total len: {}\"</span><span class=\"p\">,</span> <span class=\"n\">len</span><span class=\"p\">);</span>\n</code></pre></div></div>\n\n<p>A <code class=\"language-plaintext highlighter-rouge\">perf stat</code> on this program yields:</p>\n<pre>\n      6 777,73 msec task-clock                #    1,000 CPUs utilized          \n            13      context-switches          #    0,002 K/sec                  \n             1      cpu-migrations            #    0,000 K/sec                  \n         4 047      page-faults               #    0,597 K/sec                  \n23 800 190 663      cycles                    #    3,512 GHz                    \n10 076 137 503      instructions              #    0,42  insn per cycle         \n 4 012 788 756      branches                  #    592,055 M/sec                  \n   667 673 937      branch-misses             #    16,64% of all branches        \n     4 556 657      LLC-loads-misses     \n\n   6,778608106 seconds time elapsed\n</pre>\n\n<p>One thing that immediately stands out is a high number of branch misses and low instructions-per-cycle.\nEven though the code is short, an indirect jump to a random location can’t be predicted in many cases,\ntherefore the CPU pipeline stalls for a while and many cycles go to waste.</p>\n\n<p>Another issue with runtime polymorphism is that it requires using heap for storing the objects.\nWe can’t store objects of different types directly in a vector, because their sizes might potentially \ndiffer. The size of each item in the vector must be the same. Therefore, we can only store \nreferences (pointers) in the vector and the objects data must be allocated elsewhere. \nTraversing these references causes random memory accesses (which is called often <em>pointer chasing</em>) \nwhich reduces the efficiency of CPU caches and may cause a lot of cache misses for large enough data structures. \nIn this case <code class=\"language-plaintext highlighter-rouge\">perf</code> recorded over 4 million of last-level-cache misses.</p>\n\n<h2 id=\"performance-of-a-match--switch\">Performance of a Match / Switch</h2>\n\n<p>We can implement the same logic using enums and a match:</p>\n<div class=\"language-rust highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">pub</span> <span class=\"k\">enum</span> <span class=\"n\">DataType</span> <span class=\"p\">{</span>\n    <span class=\"n\">BoolType</span><span class=\"p\">,</span>\n    <span class=\"n\">IntType</span><span class=\"p\">,</span>\n    <span class=\"n\">LongType</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">pub</span> <span class=\"k\">fn</span> <span class=\"nf\">data_len</span><span class=\"p\">(</span><span class=\"n\">data_type</span><span class=\"p\">:</span> <span class=\"o\">&amp;</span><span class=\"n\">DataType</span><span class=\"p\">)</span> <span class=\"k\">-&gt;</span> <span class=\"nb\">usize</span> <span class=\"p\">{</span>\n    <span class=\"k\">match</span> <span class=\"n\">data_type</span> <span class=\"p\">{</span>\n        <span class=\"nn\">DataType</span><span class=\"p\">::</span><span class=\"n\">BoolType</span> <span class=\"k\">=&gt;</span> <span class=\"mi\">1</span><span class=\"p\">,</span>\n        <span class=\"nn\">DataType</span><span class=\"p\">::</span><span class=\"n\">IntType</span> <span class=\"k\">=&gt;</span> <span class=\"mi\">4</span><span class=\"p\">,</span>\n        <span class=\"nn\">DataType</span><span class=\"p\">::</span><span class=\"n\">LongType</span> <span class=\"k\">=&gt;</span> <span class=\"mi\">8</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>This allows to put the <code class=\"language-plaintext highlighter-rouge\">DataType</code> objects inside of a vector directly, because now they are all the same size and have the same static type:</p>\n\n<div class=\"language-rust highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">let</span> <span class=\"k\">mut</span> <span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"nn\">Vec</span><span class=\"p\">::</span><span class=\"o\">&lt;</span><span class=\"n\">DataType</span><span class=\"o\">&gt;</span><span class=\"p\">::</span><span class=\"nf\">new</span><span class=\"p\">();</span>\n<span class=\"k\">let</span> <span class=\"k\">mut</span> <span class=\"n\">rng</span> <span class=\"o\">=</span> <span class=\"nn\">rand</span><span class=\"p\">::</span><span class=\"nf\">thread_rng</span><span class=\"p\">();</span>\n<span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"n\">in</span> <span class=\"mi\">1</span><span class=\"o\">..</span><span class=\"mi\">1000000</span> <span class=\"p\">{</span>\n    <span class=\"k\">match</span> <span class=\"n\">rng</span><span class=\"nf\">.gen_range</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"mi\">0</span> <span class=\"k\">=&gt;</span> <span class=\"n\">data</span><span class=\"nf\">.push</span><span class=\"p\">(</span><span class=\"nn\">DataType</span><span class=\"p\">::</span><span class=\"n\">BoolType</span><span class=\"p\">),</span>\n        <span class=\"mi\">1</span> <span class=\"k\">=&gt;</span> <span class=\"n\">data</span><span class=\"nf\">.push</span><span class=\"p\">(</span><span class=\"nn\">DataType</span><span class=\"p\">::</span><span class=\"n\">IntType</span><span class=\"p\">),</span>\n        <span class=\"mi\">2</span> <span class=\"k\">=&gt;</span> <span class=\"n\">data</span><span class=\"nf\">.push</span><span class=\"p\">(</span><span class=\"nn\">DataType</span><span class=\"p\">::</span><span class=\"n\">LongType</span><span class=\"p\">),</span>\n        <span class=\"mi\">_</span> <span class=\"k\">=&gt;</span> <span class=\"p\">{}</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">let</span> <span class=\"k\">mut</span> <span class=\"n\">len</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"n\">in</span> <span class=\"mi\">0</span><span class=\"o\">..</span><span class=\"mi\">1000</span> <span class=\"p\">{</span>\n    <span class=\"k\">for</span> <span class=\"n\">dt</span> <span class=\"n\">in</span> <span class=\"n\">data</span><span class=\"nf\">.iter</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n        <span class=\"n\">len</span> <span class=\"o\">+=</span> <span class=\"nf\">data_len</span><span class=\"p\">(</span><span class=\"n\">dt</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"nd\">println!</span><span class=\"p\">(</span><span class=\"s\">\"Total len: {}\"</span><span class=\"p\">,</span> <span class=\"n\">len</span><span class=\"p\">);</span>\n</code></pre></div></div>\n\n<p>Let’s look at the code generated for <code class=\"language-plaintext highlighter-rouge\">data_len</code>:</p>\n<div class=\"language-nasm highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nf\">movzbl</span> <span class=\"p\">(</span><span class=\"o\">%</span><span class=\"nb\">rdi</span><span class=\"p\">),</span><span class=\"o\">%</span><span class=\"nb\">eax</span>\n<span class=\"nf\">lea</span>    <span class=\"nv\">anon.d7e157471cbbc210d945c8fcb95e1baa.3.llvm.2081724968588745877</span><span class=\"o\">+</span><span class=\"mh\">0xc</span><span class=\"p\">,</span><span class=\"o\">%</span><span class=\"nb\">rcx</span>\n<span class=\"nf\">mov</span>    <span class=\"p\">(</span><span class=\"o\">%</span><span class=\"nb\">rcx</span><span class=\"p\">,</span><span class=\"o\">%</span><span class=\"nb\">rax</span><span class=\"p\">,</span><span class=\"mi\">8</span><span class=\"p\">),</span><span class=\"o\">%</span><span class=\"nb\">rax</span>\n<span class=\"nf\">retq</span>\n</code></pre></div></div>\n\n<p>There is no branching in this code! The compiler noticed a simple lookup table does \nthe job. So not only the vector is now totally flat and there is no pointer chasing, \nbut also there are no jumps. The effect on performance is significant:</p>\n\n<pre>\n      1 762,37 msec task-clock                #    1,000 CPUs utilized          \n             8      context-switches          #    0,005 K/sec                  \n             0      cpu-migrations            #    0,000 K/sec                  \n           387      page-faults               #    0,220 K/sec                  \n 6 361 343 641      cycles                    #    3,610 GHz                    \n10 053 423 994      instructions              #    1,58  insn per cycle         \n 3 009 768 006      branches                  #    1707,796 M/sec                  \n     1 127 367      branch-misses             #    0,04% of all branches        \n        33 221      LLC-loads-misses \n\n   1,762797864 seconds time elapsed\n</pre>\n\n<p>That’s almost 4 times faster! \nThe numbers of branch misses and LLC misses are at least two orders of magnitude lower.</p>\n\n<p>Of course, you may find more complex cases where branching would yield exactly same performance\nas a virtual table dispatch, because often a switch / match is implemented by a jump-table as well.\nHowever, generally, branching offers the compiler more flexibility to optimize because all the jump\ntargets are known in advance. In case of virtual dispatch, a static compiler may not know all the jump \ntargets at the time of compilation so generally such code is harder to optimize.</p>\n\n<h1 id=\"conclusions\">Conclusions</h1>\n\n<ul>\n  <li>Polymorphism scales well when we want to extend the program by adding <em>types</em>, but it doesn’t scale\nwell when we want to add <em>functions</em> over these types.</li>\n  <li>Branching scales well when we want to extend the program by adding <em>functions</em> but it doesn’t scale well when we want to add <em>types</em>.</li>\n  <li>Branching is a cleaner solution when the dispatch target depends on more than a single type.</li>\n  <li>Branching gives the compiler much more room to optimize.</li>\n</ul>\n\n<h1 id=\"further-reading\">Further Reading</h1>\n<p><a href=\"https://en.wikipedia.org/wiki/Expression_problem\">Expression Problem</a></p>",
  "author": {
    "name": "Piotr Kołaczkowski"
  },
  "category": [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ],
  "summary": "Recently I came across a blog post whose author claims, from the perspective of good coding practices, polymorphism is strictly superior to branching. In the post they make general statements about how branching statements lead to unreadable, unmaintainable, inflexible code and how they are a sign of immaturity. However, in my opinion, the topic is much deeper and in this post I try to objectively discuss the reasons for and against branching."
}