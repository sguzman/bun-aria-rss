{
  "title": "Wavelet image hash in Python",
  "link": "https://fullstackml.com/wavelet-image-hash-in-python-3504fdd282b5?source=rss----46e065078cc1---4",
  "guid": "https://medium.com/p/3504fdd282b5",
  "category": [
    "image-processing",
    "python",
    "machine-learning"
  ],
  "dc:creator": "Dmitry Petrov",
  "pubDate": "Sat, 02 Jul 2016 16:19:26 GMT",
  "atom:updated": "2017-11-07T06:37:01.648Z",
  "content:encoded": "<p>For several weekends, I had fun playing Kaggle: <a href=\"http://kaggle.com/c/avito-duplicate-ads-detection/\">Avito Duplicate Ads Detection problem</a>. This machine learning problem includes more than 10 million images in addition to the structured data set. In this competition, many players use image hashes instead of the actual images to optimize the model creation process.</p><p>What I found interesting is — most of the implementation of the image hashing uses a standard Discrete Cosine Transformation (CDT). I used to work with images many years back and remember that Discrete Wavelet Transformation (DWT) might give better results for images. <strong>I was unable to find any Python implementation DWT based image hashing, so I implemented one and pushed to the </strong><a href=\"https://github.com/JohannesBuchner/imagehash\"><strong>imagehash</strong></a><strong> library</strong>. The change is available in the master branch on github and in the new version of the package. In this blogpost, I will describe how it works concisely.</p><h3>1. Imagehash Python library</h3><p>The most simple and effective library that I found was the <a href=\"https://github.com/JohannesBuchner/imagehash\"><strong>imagehash</strong></a> library from Johannes Bucher. There were several image hashes implemented in the library: aHash, pHash, dHash. All three of the approaches scale an image into a grayscale 8x8 image first. Then the library performs some calculations for each of these 64 pixels and assigns a binary 1 or 0 value. These 64 bits form the output of algorithm. The bit computation methods are different:</p><ol><li><strong>aHash</strong> — average hash, for each of the pixels output 1 if the pixel is bigger or equal to the average and 0 otherwise.</li><li><strong>pHash</strong> — perceptive hash, does the same as aHash, but first it does a Discrete Cosine Transformation and works in the <a href=\"https://en.wikipedia.org/wiki/Frequency_domain\">frequency domain</a>.</li><li><strong>dHash</strong> — gradient hash, calculate the difference for each of the pixel and compares the difference with the average differences.</li><li><strong>* wHash</strong> — wavelet hashing, that I added to the library a couple days back. It works in the frequency domain as pHash but it uses DWT instead of DCT.</li></ol><p>You can fine more detailed description of the hashes in <a href=\"http://www.hackerfactor.com/blog/index.php?/archives/529-Kind-of-Like-That.html\">this blogpost</a>.</p><p>The code below shows how to use the library.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/bce34d689cb52213c0fcdff0e4cbbbec/href\">https://medium.com/media/bce34d689cb52213c0fcdff0e4cbbbec/href</a></iframe><p>The two images from the code example are definitely not equal. The 44 bits out of 64 are different. Similar images will have a difference up to 6–8 bits.</p><p>UPDATE: A typo was found by <a href=\"https://www.kaggle.com/c/avito-duplicate-ads-detection/forums/t/22011/precomputed-wavelet-image-hashes/126522#post126522\">LIN China</a>. The hash values and the difference were changed.</p><h3>2. Calculate image hash</h3><p>For regular photos, frequency based methods like pHash usually give better results because the frequency domain is more stable for images transformations like:</p><ul><li>JPG compression</li><li>color schema change or applying image filters</li><li>size scaling</li><li>and even some minor image editing: cutting part of an image, marking an image by watermark, adding text of modifying an image .</li></ul><p>For example, let’s take a look at an image and a transformed version of the same image. This is going to be a very popular <a href=\"https://en.wikipedia.org/wiki/Lenna\">Lenna image</a>. Many image processing researches use this picture. I remember this picture pretty well from my student days when I did some image researches more than some 10 years back.</p><figure><img alt=\"lenna\" src=\"https://cdn-images-1.medium.com/max/512/0*-X0-tcEnb4Hq3NJr.png\" /><figcaption>Lenna.png. Original image. Size 512x512.</figcaption></figure><p>Let’s make some basic transformations on the image and compare the hashes. First of all we will introduce size change from 512x512 to 400x400 pixels. Then we will change color schema and then compress to JPEG for the final step.</p><figure><img alt=\"lenna1\" src=\"https://cdn-images-1.medium.com/max/400/0*xFkSVII_-GttrjWL.jpg\" /><figcaption>Lenna1.jpg. Color schema and image size were changed. JPG compressed. Size 400x400</figcaption></figure><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/b7fac079684bbd62ae52aeb5d877eee7/href\">https://medium.com/media/b7fac079684bbd62ae52aeb5d877eee7/href</a></iframe><p>Ha… not bad! No difference in the image hashes even after compression, resizing and color changing.</p><p>Let’s apply more transformations to the lenna1.jpg image (not the original one):</p><ul><li>take only the central part of the picture</li><li>add text</li><li>compress again</li></ul><figure><img alt=\"lenna2\" src=\"https://cdn-images-1.medium.com/max/317/0*lHj_fOuBxDLoQ_Hv.jpg\" /><figcaption>Lenna2.jpg. More image transformations. Size 317x360</figcaption></figure><p>I shared all three images: <a href=\"https://www.dropbox.com/s/sakmlt0qdga9slk/lenna1.jpg?dl=0\">lenna.png</a>, <a href=\"https://www.dropbox.com/s/8ipod2szqp6hfok/lenna2.jpg?dl=0\">lenna1.jpg</a>, <a href=\"https://www.dropbox.com/s/hfplym5br85okk3/lenna.png?dl=0\">lenna2.jpg</a>.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/29730b5245a232b9d81fa98f7405e1c7/href\">https://medium.com/media/29730b5245a232b9d81fa98f7405e1c7/href</a></iframe><p>All right. Now we can see the hash difference is 20, or 31.2% per hash bit. The second metric is much better because the hash size is varies for different hashes.</p><p>aHash brings different results. Even simple transformation of lenna1.jpg shows 1.6% hash difference. More aggressive lenna2.jpg gives 29.7 % difference.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/3becb2a1c4be3b3f589d96c9efc8bea2/href\">https://medium.com/media/3becb2a1c4be3b3f589d96c9efc8bea2/href</a></iframe><h3>3. Wavelet hash</h3><p>Discrete Wavelet Transformation (DWT) is another form of frequency representation. The popular DCT and Fourier transformations use a set of sin\\cos functions as a basis: sin(x), sin(2x), sin(3x), etc. In contrast, DWT uses one single function as a basis but in different forms: scaled and shifted. The basis function can be changed and this is why we can have Haar wavelet, Daubechie-4 wavelet etc. This scaling effect gives us a great “time-frequency representation” when the low frequency part looks similar to the original signal.</p><p>There is a great Python library for wavelets — <a href=\"http://www.pybytes.com/pywavelets/\"><strong>pywt</strong></a>. I used this library to implement whash() method for the imagehash library. By default whash() computes 8x8 hash using Haar transformation. In addition, the method removes the lowest Haar frequency LL(max). The lowest frequency consists from only one data point/pixel and this point represent the contrast of the image and isn’t so useful for hashing.</p><p>wHash Python code is below:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/bfa4b84f1e254f7ad970a2f2f8f992b9/href\">https://medium.com/media/bfa4b84f1e254f7ad970a2f2f8f992b9/href</a></iframe><h3>4. Validation</h3><p>To make results cleaner, let’s compare the original image with another one. The expected hash difference should be 50%. Here is another standard image for comparison — barbara.jpg. Let’s calculate the hash difference between Lenna and Barbara using all hashes. The code a listed below:</p><figure><img alt=\"barbara\" src=\"https://cdn-images-1.medium.com/max/512/0*7FbVwbM2zJsWbbjL.jpg\" /><figcaption>Barbara.jpg</figcaption></figure><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/4b79f5363591801a18f601d5ee8cf60a/href\">https://medium.com/media/4b79f5363591801a18f601d5ee8cf60a/href</a></iframe><p>Table with all results:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/5eef097818d4f6a4dc7f68d97c6dcfe0/href\">https://medium.com/media/5eef097818d4f6a4dc7f68d97c6dcfe0/href</a></iframe><p>In the new whash() method, we can play with different parameters. The most important thing in whash() is the hash size. It is 8 by default but you can change it by any power of 2 number less than input image size (minimum by an image dimensions). Also, you can avoid removing the lowest frequency by setting parameter <strong><em>remove_max_haar_ll</em></strong> to <strong><em>False</em></strong>. In addition, you can change the initial scaling of the image rom 64 (which is 8x8) to any power of 2 less than the image size.</p><p>The most interesting parameter is <strong><em>mode</em></strong> — wavelet families. By default the library use haar wavelet but the value can be change to any value from pywt library like ‘db4’. See <a href=\"http://www.pybytes.com/pywavelets/regression/wavelet.html\">the library page</a>.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/a7caca5379cd5366a6b08a66ac96aa68/href\">https://medium.com/media/a7caca5379cd5366a6b08a66ac96aa68/href</a></iframe><h3>5. Known issues</h3><p>I had an issue when processed big number of small images. It looks like pywt has a memory leak. <a href=\"https://github.com/JohannesBuchner/imagehash/issues/25\">An issue was created</a> in github. I’ll try to contact pywt creators regarding the issue.</p><p>To mitigate the issue I just split images by directories with ~50K images each and re-run processing for each directory separately.</p><h3>Conclusion</h3><p>It is hard to say which of the methods provides better results. It depends on your application and you should focus on your application or machine learning model metrics like precision\\recall or AUC. For my Kaggle score the whash() brought +0.04% to AUC metric, in addition to my current ~92.9% result.</p><p>It doesn’t look like a huge difference. However, we should remember that in the modeling code, we achieved this by a one-letter change from <strong>p</strong>hash() to <strong>w</strong>hash(). It is nice to have more advanced analytical tools and I hope this method will be a good addition to your analytical toolbox. In addition, I believe that wHash has a great potential for tuning by the method parameters.</p><p>Please share your experience in using the library. Any comments, suggestions, code improvements and fixes are highly appreciated.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=3504fdd282b5\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://fullstackml.com/wavelet-image-hash-in-python-3504fdd282b5\">Wavelet image hash in Python</a> was originally published in <a href=\"https://fullstackml.com\">FullStackML</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"
}