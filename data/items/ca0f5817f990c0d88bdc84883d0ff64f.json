{
  "title": "Python v. Clojure v. Julia",
  "link": "",
  "updated": "2014-01-13T00:00:00+00:00",
  "id": "https://mrocklin.github.io/blog/work/2014/01/13/Text-Benchmarks",
  "content": "<p><strong>tl;dr: We compare Python performance against Clojure, Julia, and Java in\ntext-processing and dynamic collections.  Remarkably, Python does well.</strong></p>\n\n<p><em>Note - this post embeds gists for code.  These do not render well on Planet\npages or on RSS readers like feedly.  It may be better to view on the <a href=\"http://matthewrocklin.com/blog/work/2014/01/13/Text-Benchmarks/\">original\nsite</a></em></p>\n\n<h2 id=\"situation\">Situation</h2>\n\n<p>I mostly understand numeric performance; I am ignorant when it comes to text\nand basic data wrangling.  Actually, that’s an understatement</p>\n\n<p><em>The SciPy community has optimized the heck out of numerics; lets think about\ntext!</em></p>\n\n<p>I think that many of us are in the same position.  At work we analyze\nnon-numeric data and run-times now slow down my work cycle.  After benchmarking\nand tuning code within Python I have the following three options to\nfurther increase performance:</p>\n\n<ol>\n  <li>Use more machines</li>\n  <li>Invent a better algorithm</li>\n  <li>Switch to a lower level language</li>\n</ol>\n\n<p>Often we choose number 1, “use more machines”.  We make this\nchoice because it’s easy.  Option 2, “invent better algorithms” is hard and\nso we avoid it if we’re not intellectually interested in the problem.</p>\n\n<p>In numeric work we often pursue option 3, “switch to a lower level language”\nand with good reason.  The Python -&gt; numpy -&gt; fancy-numeric-package -&gt; tuned\nC/Fortran -&gt; CUDA progression often comes along with somewhat predictable\norder-of-magnitude gains at each step.  We know we can improve computation and\nwe know roughly by how much.</p>\n\n<p>In text-based work I lack the same strong intuition on performance that I have\nin numeric work.  I don’t know how valuable lower level languages really are.\nThis blogpost helps to answer that question.</p>\n\n<h2 id=\"a-small-language-shootout\">A Small Language Shootout</h2>\n\n<p>Can my 30-core shared memory machine or large distributed system be replaced\nwith a few cores running tight compiled code?  To test this we run a very\nsimple parse-and-group operation in three languages of current interest:</p>\n\n<ul>\n  <li>Python – our favorite low-performance language</li>\n  <li>Clojure – A compiled lisp on the JVM with a vibrant community</li>\n  <li>Julia – The language all of Scientific Python is talking about but no one\nseems to have used.</li>\n</ul>\n\n<p>Each is a modern high-productivity language optimized for development time as\nwell as performance.  I would feel comfortable marrying myself to any of them\nlong-term.</p>\n\n<p>Later on in the blogpost I introduce Java as a baseline language:</p>\n\n<ul>\n  <li>Java – the oddly effective language that everyone loves to hate</li>\n</ul>\n\n<h2 id=\"installing-julia\">Installing Julia</h2>\n\n<p>Julia is a compiled language that targets</p>\n\n<ul>\n  <li>imperative array code (like C/Fortran)</li>\n  <li>with a lightweight syntax (like Python)</li>\n  <li>but with a real type system (like Haskell).</li>\n</ul>\n\n<p>Along with Rust and Go it is one of the recent advances in imperative\nlanguages.  It caters more to the Matlab/Fortran crowd than the Systems/C crowd\n(like Go).</p>\n\n<p>While curious about Julia I’ve never played with it.  I had been warned about\nJulia’s installation process.  I was told that it depended on a custom LLVM and\ntook up a Gig+ of storage.  I was pleasantly surprised when the following\nworked (Ubuntu 13.04)</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>mrocklin@notebook:~$ sudo add-apt-repository ppa:staticfloat/juliareleases\nmrocklin@notebook:~$ sudo apt-get update\nmrocklin@notebook:~$ sudo apt-get install julia\n    ...\n    Need to get 12.8 MB of archives.\n    After this operation, 37.5 MB of additional disk space will be used.\n    ...\nmrocklin@notebook:~$ julia\n               _\n   _       _ _(_)_     |  A fresh approach to technical computing\n  (_)     | (_) (_)    |  Documentation: http://docs.julialang.org\n   _ _   _| |_  __ _   |  Type \"help()\" to list help topics\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 0.2.0 (2013-11-16 23:48 UTC)\n _/ |\\__'_|_|_|\\__'_|  |  Official http://julialang.org release\n|__/                   |  x86_64-linux-gnu\n\njulia&gt; 1 + 2\n3\n</code></pre></div></div>\n\n<p>Well that was simple!  There is no longer an excuse not to try Julia.</p>\n\n<h2 id=\"problem\">Problem</h2>\n\n<p>I want to test</p>\n\n<ul>\n  <li>File I/O</li>\n  <li>Basic string operations</li>\n  <li>Grouping operations (mostly dictionary lookups and collection appends).</li>\n</ul>\n\n<p>To do this we take all of the word-pairs in “Tale of Two Cities”\nand group them by the first word.</p>\n\n<p>Given data that looks like the the following:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>$ cat data.txt\na,b\na,c\na,d\nb,a\nb,d\nd,c\nd,a\n</code></pre></div></div>\n\n<p>We produce data that looks like the following:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>{'a': ['b', 'c', 'd'],\n 'b': ['a', 'd'],\n 'd': ['c', 'a']}\n</code></pre></div></div>\n\n<p>But instead of <code class=\"language-plaintext highlighter-rouge\">a, b, c</code> we use words from a long book, <em>The Tale of Two\nCities</em></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>it, was\nwas, the\nthe, best\nbest, of\nof, times\ntimes, it\nit, was\nwas, the\nthe, worst\nworst, of\nof, times\n...\n</code></pre></div></div>\n\n<p>We read in a file, split each line by commas, and then perform a groupby\noperation.  Comma spliting and grouping are both commonly used operations.\nFor example these steps might be used to create a Markov chain to power\nword prediction in your smartphone keyboard.</p>\n\n<h2 id=\"solutions\">Solutions</h2>\n\n<p>Note that these are all done using the pure language.  Both Python and Julia\nhave a DataFrame project (like <code class=\"language-plaintext highlighter-rouge\">pandas</code>) with heavily optimized\n<code class=\"language-plaintext highlighter-rouge\">groupby</code> operations.  Today we stick with the core language.</p>\n\n<h3 id=\"python\">Python</h3>\n\n<p>We use <code class=\"language-plaintext highlighter-rouge\">toolz</code> for the <code class=\"language-plaintext highlighter-rouge\">groupby</code> operation</p>\n\n<script src=\"https://gist.github.com/8365524.js\"> </script>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>python benchmark.py word-pairs.txt\n</code></pre></div></div>\n\n<h3 id=\"julia\">Julia</h3>\n\n<p>We first make a <code class=\"language-plaintext highlighter-rouge\">groupby</code> operation in Julia.</p>\n\n<script src=\"https://gist.github.com/8365495.js\"> </script>\n\n<p>Afterwards out code closely matches the Python Solution</p>\n\n<script src=\"https://gist.github.com/8365510.js\"> </script>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>julia benchmark.jl word-pairs.txt\n</code></pre></div></div>\n\n<h3 id=\"clojure\">Clojure</h3>\n\n<p>The Clojure standard library has everything we need</p>\n\n<script src=\"https://gist.github.com/8365551.js\"> </script>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>lein uberjar\njava -jar location-of-standalone.jar word-pairs.txt\n</code></pre></div></div>\n\n<h2 id=\"numeric-results\">Numeric Results</h2>\n\n<p>The results surprised me.</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Python:     200 ms\nJulia:      200 to 800 ms  # I don't know what's going on here\nClojure:    550 ms\n</code></pre></div></div>\n\n<p>I expected Python to be dead last.  Instead it comfortably hums along in first.\nIt also has the shortest latency (both Julia and Clojure have painful compile\ntimes (not included in totals)).</p>\n\n<p>Perhaps this is because neither the Clojure nor Julia solutions have sufficient\ntype information.  If any Clojurians or Julians (is that what we call you?) are\naround I welcome better solutions.</p>\n\n<p>In particular, I was sad to learn that Julia’s <code class=\"language-plaintext highlighter-rouge\">readlines</code> function is of type\n<code class=\"language-plaintext highlighter-rouge\">file -&gt; Array{Any}</code> rather than <code class=\"language-plaintext highlighter-rouge\">file -&gt; Array{String}</code>.  This propagates down\nto <code class=\"language-plaintext highlighter-rouge\">word_pairs</code> being of type <code class=\"language-plaintext highlighter-rouge\">Array{Array{Any}}</code> which I suspect stops\nmany meaningful optimizations.</p>\n\n<h2 id=\"thoughts-on-the-code\">Thoughts on the Code</h2>\n\n<h3 id=\"timing-macros\">Timing Macros</h3>\n\n<p>Writing code to time other code is tricky.  It always requires some sort of\nsuper-code.  In Clojure and Julia this is the <code class=\"language-plaintext highlighter-rouge\">time</code> macro</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>;; Clojure\n(time (... ))\n\n# Julia\n@time begin\n    ...\nend\n</code></pre></div></div>\n\n<p>In Python I used the <code class=\"language-plaintext highlighter-rouge\">duration</code> context manager.  Context managers commonly\nserve well where macros are desired.</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>with duration():\n    ...\n</code></pre></div></div>\n\n<p>But normally people use IPython’s <code class=\"language-plaintext highlighter-rouge\">timeit</code> magic (also macro-like).  I used\n<code class=\"language-plaintext highlighter-rouge\">duration</code> here because it was pure Python and because it doesn’t benefit from\nthe caching of repeated iterations.</p>\n\n<h3 id=\"lambdas\">Lambdas</h3>\n\n<p>I miss nice lambda syntax.  Both Clojure and Julia have concise\nmulti-line anonymous functions.  Julia even has pretty ones:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Python  : lambda x: x + 1\nClojure : #(+ 1 %)\nJulia   : x -&gt; x + 1\n</code></pre></div></div>\n\n<p>As much as I love Clojure I have to say, that’s an ugly <code class=\"language-plaintext highlighter-rouge\">lambda</code>.  It looks\nlike a child mashing the top row of the keyboard.</p>\n\n<h3 id=\"no-obligatory-types\">No Obligatory Types</h3>\n\n<p>There is no necessary explicit type information in any of the languages.  This\nseems to be a common trait among high productivity languages.</p>\n\n<h3 id=\"performance-from-optional-types\">Performance from Optional Types?</h3>\n\n<p>Clojure and Julia both support adding optional type information to increase\nperformance.  Python3 supports static type annotations but doesn’t use them\nmeaningfully.  I suspect that one can get more performance on both the Clojure and Julia\nsolutions by adding type information.  If any experts are out there on\nsupplying type hints I’d be grateful for the suggestions.</p>\n\n<h2 id=\"lets-consider-java\">Lets Consider Java</h2>\n\n<p>To see how much runtimes could improve we test Java, a language without\nfanciness, where all types are explicit, and whose compiler optimizations we\nmostly understand.</p>\n\n<p>The results?</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Python:     200 ms\nJulia:      200 to 800 ms  # I don't know what's going on here\nClojure:    550 ms\n\nJava:       190 ms\n</code></pre></div></div>\n\n<p>Surprisingly, Java is not significantly faster.  This provides us with a pretty\nstable lower bound for this problem.  We’re unlikely to get much faster with\nstandard data structures.</p>\n\n<p>As a corollary this probably answers the question:</p>\n\n<p><em>“Can more type information accelerate the Clojure/Julia solutions to this\nproblem?”</em></p>\n\n<p>with the answer:</p>\n\n<p><em>“No”</em>.</p>\n\n<h3 id=\"code\">Code</h3>\n\n<p>The Java standard library has the data structures we need but fancy operations\nlike <code class=\"language-plaintext highlighter-rouge\">groupby</code> are absent and difficult to create.</p>\n\n<script src=\"https://gist.github.com/8387373.js\"> </script>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>javac Benchmark.java\njava Benchmark word-pairs.txt\n</code></pre></div></div>\n\n<h2 id=\"conclusion\">Conclusion</h2>\n\n<p>It turns out that runtimes for this problem are dominated by data structures for\nwhich Python is well optimized.  But how common in this computational focus\namong text-analytics problems?  If anyone has insight here I’d love to hear\nabout it.  Remember that my goal is to generate intuition about computational\nperformance in text-analytic operations.</p>\n\n<p>Numerical computation intuition tells us that types are important.  Switching\nfrom a Python <code class=\"language-plaintext highlighter-rouge\">int</code> to a C <code class=\"language-plaintext highlighter-rouge\">int</code> often results in a significant performance\ngain.  This intuition didn’t carry over well to text and grouping; instead we\nmostly benchmarked the dictionary/HashMap of each language.</p>\n\n<p>I used to feel guilty about using Python for data processing.  But this test\ngives me confidence in the performance of Python data structures relative to\nother languages and makes me more optimistic about Python’s role in data\nanalytics in general.</p>\n\n<h2 id=\"appendix\">Appendix</h2>\n\n<p>My Python <code class=\"language-plaintext highlighter-rouge\">duration</code> context manager.  This is more a lesson on the value and\nsimplicity of context managers than anything else:</p>\n\n<script src=\"https://gist.github.com/8365436.js\"> </script>\n\n<p>Also, if you want the data then you should run this script:</p>\n\n<script src=\"https://gist.github.com/8365482.js\"> </script>\n\n<p>It depends on <code class=\"language-plaintext highlighter-rouge\">toolz</code> which you can get from PyPI with</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>pip install toolz\n</code></pre></div></div>\n\n<p>or</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>easy_install toolz\n</code></pre></div></div>"
}