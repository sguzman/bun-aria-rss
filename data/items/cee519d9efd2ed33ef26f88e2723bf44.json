{
  "title": "Dotfiles for peace of mind",
  "link": "",
  "published": "2016-02-23T12:18:00-08:00",
  "updated": "2016-02-23T12:18:00-08:00",
  "author": {
    "name": "Cathy Yeh"
  },
  "id": "tag:efavdb.com,2016-02-23:/dotfiles",
  "summary": "<p>Reinstalling software and configuring settings on a new computer is a pain. After my latest hard drive failure set the stage for yet another round of download-extract-install and configuration file twiddling, it was time to overhaul my approach. <em>&#8220;Enough is&nbsp;enough!&#8221;</em></p>\n<p>This post walks&nbsp;through</p>\n<ol>\n<li>how to back up and …</li></ol>",
  "content": "<p>Reinstalling software and configuring settings on a new computer is a pain. After my latest hard drive failure set the stage for yet another round of download-extract-install and configuration file twiddling, it was time to overhaul my approach. <em>&#8220;Enough is&nbsp;enough!&#8221;</em></p>\n<p>This post walks&nbsp;through</p>\n<ol>\n<li>how to back up and automate the installation and configuration&nbsp;process</li>\n<li>how to set up a minimal framework for data&nbsp;science</li>\n</ol>\n<p>We&#8217;ll use a <a href=\"https://github.com/EFavDB/dotfiles\">dotfiles repository</a> on Github to illustrate both points in&nbsp;parallel.</p>\n<hr>\n<p>Dotfiles are named after the configuration files that start with a dot in Unix-based systems. These files are hidden from view in your home directory, but visible with a <code>$ ls -a</code> command. Some examples are <code>.bashrc</code> (for configuring the bash shell), <code>.gitconfig</code> (for configuring git), and <code>.emacs</code> (for configuring the Emacs text&nbsp;editor).</p>\n<p>Let&#8217;s provide a concrete example of a customization: suppose you have a hard time remembering the syntax to extract a file (&#8220;Is it tar -xvf, -jxvf, or -zxvf?&#8221;). If you&#8217;re using a bash shell, you can define a function, <code>extract()</code> in your <code>.bashrc</code> file that makes life a little&nbsp;easier:</p>\n<div class=\"highlight\"><pre><span></span><span class=\"err\">extract() {  </span>\n<span class=\"err\">if [ -f &quot;$1&quot; ]; then  </span>\n<span class=\"err\">case &quot;$1&quot; in  </span>\n<span class=\"err\">*.tar.bz2) tar -jxvf &quot;$1&quot; ;;  </span>\n<span class=\"err\">*.tar.gz) tar -zxvf &quot;$1&quot; ;;  </span>\n<span class=\"err\">*.bz2) bunzip2 &quot;$1&quot; ;;  </span>\n<span class=\"err\">*.dmg) hdiutil mount &quot;$1&quot; ;;  </span>\n<span class=\"err\">*.gz) gunzip &quot;$1&quot; ;;  </span>\n<span class=\"err\">*.tar) tar -xvf &quot;$1&quot; ;;  </span>\n<span class=\"err\">*.tbz2) tar -jxvf &quot;$1&quot; ;;  </span>\n<span class=\"err\">*.tgz) tar -zxvf &quot;$1&quot; ;;  </span>\n<span class=\"err\">*.zip) unzip &quot;$1&quot; ;;  </span>\n<span class=\"err\">*.ZIP) unzip &quot;$1&quot; ;;  </span>\n<span class=\"err\">*.pax) cat &quot;$1&quot; | pax -r ;;  </span>\n<span class=\"err\">*.pax.Z) uncompress &quot;$1&quot; --stdout | pax -r ;;  </span>\n<span class=\"err\">*.Z) uncompress &quot;$1&quot; ;;  </span>\n<span class=\"err\">*) echo &quot;&#39;$1&#39; cannot be extracted/mounted via extract()&quot; ;;  </span>\n<span class=\"err\">esac  </span>\n<span class=\"err\">else  </span>\n<span class=\"err\">echo &quot;&#39;$1&#39; is not a valid file to extract&quot;  </span>\n<span class=\"err\">fi  </span>\n<span class=\"err\">}  </span>\n</pre></div>\n\n\n<p>So the next time you have to extract a file <code>some_file.tar.bz2</code>, just type <code>extract some_file.tar.bz2</code> in bash. (This example was found in this <a href=\"https://github.com/webpro/dotfiles/blob/master/system/.function_fs#L23\">dotfiles repo</a>.)</p>\n<p>The structure of my dotfiles takes after the <a href=\"https://github.com/webpro/dotfiles\">repo</a> described by Lars Kappert in the article <a href=\"https://medium.com/@webprolific/getting-started-with-dotfiles-43c3602fd789#.eis4hwbff\">&#8220;Getting Started With Dotfiles&#8221;</a>. However, my repo is pared down significantly, with minor modifications for my Linux Mint system (his is <span class=\"caps\">OS</span> X) and a focus on packages for data&nbsp;science.</p>\n<hr>\n<h2>A framework for data&nbsp;science</h2>\n<p>This starter environment only has a few parts. We need a text editor &#8212; preferably one that can support multiple languages encountered in data science &#8212; and a way to manage scientific/statistical software&nbsp;packages.</p>\n<h3>Components</h3>\n<p>The setup consists&nbsp;of:</p>\n<ul>\n<li><a href=\"https://www.gnu.org/software/emacs/\">Emacs</a> &#8212; a powerful text editor that can be customized to provide an <span class=\"caps\">IDE</span>-like experience for both python and R, while providing syntax highlighting for other languages, e.g. markdown, LaTeX, shell, lisp, and so on. (More on customizing Emacs in a future&nbsp;post.)</li>\n<li><a href=\"http://conda.pydata.org/docs/\">Conda</a> &#8212; both a package manager and environment manager. Advantages:<ul>\n<li>Packages are easy to install compared to pip, e.g. see a post by the <a href=\"http://technicaldiscovery.blogspot.com/2013/12/why-i-promote-conda.html\">author of numpy</a>.</li>\n<li>Conda is language agnostic in terms of both managing packages and environments for different languages (as opposed to pip/virtualenv/venv). This feature is great if you use both python and&nbsp;R.</li>\n<li>Standard python scientific computing libraries like numpy, scipy, matplotlib, etc. are available in the conda&nbsp;repository.</li>\n</ul>\n</li>\n</ul>\n<p>I use the system package manager (i.e. <code>apt-get install ...</code>) to install a few packages like git, but otherwise rely on Conda to install Python (multiple versions are okay!), R, and their&nbsp;libraries.</p>\n<p>I like how clean the conda installation feels. Any packages installed by Conda, as well as different versions of Python itself, are neatly organized under the <code>miniconda3</code> directory in my home directory. In contrast, my previous Linux setups were littered with software installations from various package managers, along with sometimes unsuccessful attempts to compile software from&nbsp;source.</p>\n<h3>Workflow</h3>\n<p>My workflow with Conda follows this helpful <a href=\"http://stiglerdiet.com/blog/2015/Nov/24/my-python-environment-workflow-with-conda/\">post</a> by Tim Hopper. Each project gets its own directory and is associated with an environment whose dependencies are specified by an <code>environment.yml</code> file.</p>\n<p>For example, create a folder for a project, my_proj. Within the project folder, create a bare-bones <code>environment.yml</code> file to specify a dependency on python 3 and&nbsp;matplotlib:</p>\n<div class=\"highlight\"><pre><span></span><span class=\"n\">name</span><span class=\"o\">:</span> <span class=\"n\">my_proj</span>\n<span class=\"n\">dependencies</span><span class=\"o\">:</span>\n<span class=\"o\">-</span> <span class=\"n\">python</span><span class=\"o\">=</span><span class=\"mi\">3</span>\n<span class=\"o\">-</span> <span class=\"n\">matplotlib</span>\n</pre></div>\n\n\n<p>Then, to create the conda environment named after that directory, run <code>$ conda env create</code> inside the my_proj directory. To activate the virtual environment, run <code>$ source activate my_proj</code>.</p>\n<p>Activating a conda environment can be further automated with <a href=\"https://github.com/kennethreitz/autoenv\">autoenv</a>. Autoenv automatically activates the environment for you when you <code>$ cd</code> into a project directory. You just need to create a <code>.env</code> file that contains the command to activate your environment, e.g. <code>source activate my_proj</code>, under the project&nbsp;directory.</p>\n<p>Tim has written a convenient bash function, <code>conda-env-file</code> (see <a href=\"#conda-env-file\">below</a>), for generating a basic <code>environment.yml</code> file and <code>.env</code> file, which I&#8217;ve incorporated into my own dotfiles, along with autoenv. The order of commands that I type in bash then&nbsp;follows:</p>\n<ol>\n<li><code>mkdir my_proj</code> # create project&nbsp;folder</li>\n<li><code>cd my_proj</code> # enter project&nbsp;directory</li>\n<li><code>conda-env-file</code> # execute homemade function to create environment.yml and&nbsp;.env</li>\n<li><code>conda env create</code> # conda creates an environment &#8220;my_proj&#8221; that is named after the project directory (using&nbsp;environment.yml)</li>\n<li><code>cd ..</code></li>\n<li><code>cd my_proj</code> # autoenv automatically activates environment (using the file .env) when you re-enter the&nbsp;directory</li>\n</ol>\n<hr>\n<h2>The dotfiles&nbsp;layout</h2>\n<p>Below is the layout of the directories and files (generated by the <code>tree</code> command) in the <a href=\"https://github.com/EFavDB/dotfiles\">dotfiles repo</a>.</p>\n<div class=\"highlight\"><pre><span></span><span class=\"err\">.</span>\n<span class=\"err\">├── install</span>\n<span class=\"err\">│   ├── apt-get.sh</span>\n<span class=\"err\">│   ├── conda.sh</span>\n<span class=\"err\">│   ├── git.sh</span>\n<span class=\"err\">│   ├── install-emacs.sh</span>\n<span class=\"err\">│   └── install-miniconda.sh</span>\n<span class=\"err\">├── install.sh</span>\n<span class=\"err\">├── runcom</span>\n<span class=\"err\">│   ├── .bash_profile</span>\n<span class=\"err\">│   ├── .bashrc</span>\n<span class=\"err\">│   └── .profile</span>\n<span class=\"err\">└── system</span>\n<span class=\"err\">    ├── env</span>\n<span class=\"err\">    ├── functions</span>\n<span class=\"err\">    └── path</span>\n</pre></div>\n\n\n<h3>Configuration</h3>\n<p>There any number of dotfiles that can be configured (for example, see the collection <a href=\"http://dotfiles.github.io/\">here</a>), but this repo only provides customizations for the dotfiles <code>.profile</code>, <code>.bash_profile</code>, and <code>.bashrc</code> &#8212; located in the directory, <code>runcom</code> (which stands for &#8220;run commands&#8221;) &#8212; that contain commands that are executed at login or during interactive non-login shell sessions. For details about the role of shell initialization dotfiles, see the <a href=\"#aside\">end</a> of this&nbsp;post.</p>\n<p>Instead of putting all our customizations in one long, unwieldy dotfile, it&#8217;s helpful to divide them into chunks, which we keep in the subfolder, <code>system</code>.</p>\n<p>The files <code>env</code>, <code>functions</code>, <code>path</code> are sourced in a loop by the dotfiles in <code>runcom</code>. For example, <code>.bashrc</code> sources <code>functions</code> and <code>env</code>:</p>\n<div class=\"highlight\"><pre><span></span><span class=\"err\">for DOTFILE in &quot;$DOTFILES_DIR&quot;/system/{functions,env}; do  </span>\n<span class=\"err\">[ -f &quot;$DOTFILE&quot; ] &amp;&amp; . &quot;$DOTFILE&quot;  </span>\n<span class=\"err\">done  </span>\n</pre></div>\n\n\n<p>Let&#8217;s take a look at the configurations in each of these files:<br>\n</p>\n<p><strong>env</strong> - enables autoenv for activating virtual&nbsp;environments</p>\n<div class=\"highlight\"><pre><span></span><span class=\"err\">[ -f /opt/autoenv/activate.sh ] &amp;&amp; . /opt/autoenv/activate.sh</span>\n</pre></div>\n\n\n<p><strong>functions</strong> - defines a custom function, <code>conda-env-file</code>, that generates an <code>environment.yml</code> that lists the dependencies for a conda virtual environment, and a one-line file <code>.env</code> (not to be confused with <code>env</code> in the previous bullet point) used by autoenv. (In addition to pip and python, I include the dependencies ipython, jedi, and flake8 needed by my Emacs python <span class=\"caps\">IDE</span>&nbsp;setup.)  </p>\n<div class=\"highlight\"><pre><span></span><span class=\"k\">function</span> <span class=\"n\">conda</span><span class=\"o\">-</span><span class=\"n\">env</span><span class=\"o\">-</span><span class=\"n\">file</span> <span class=\"err\">{</span>  \n<span class=\"o\">#</span> <span class=\"k\">Create</span> <span class=\"n\">conda</span> <span class=\"n\">environment</span><span class=\"p\">.</span><span class=\"n\">yml</span> <span class=\"n\">file</span> <span class=\"k\">and</span> <span class=\"n\">autoenv</span> <span class=\"n\">activation</span> <span class=\"n\">file</span>  \n<span class=\"o\">#</span> <span class=\"n\">based</span> <span class=\"k\">on</span> <span class=\"n\">directory</span> <span class=\"n\">name</span><span class=\"p\">.</span>  \n<span class=\"n\">autoenvfilename</span><span class=\"o\">=</span><span class=\"s1\">&#39;.env&#39;</span>  \n<span class=\"n\">condaenvfilename</span><span class=\"o\">=</span><span class=\"s1\">&#39;environment.yml&#39;</span>  \n<span class=\"n\">foldername</span><span class=\"o\">=</span><span class=\"err\">$</span><span class=\"p\">(</span><span class=\"n\">basename</span> <span class=\"err\">$</span><span class=\"n\">PWD</span><span class=\"p\">)</span>\n\n<span class=\"k\">if</span> <span class=\"p\">[</span> <span class=\"o\">!</span> <span class=\"o\">-</span><span class=\"n\">f</span> <span class=\"err\">$</span><span class=\"n\">condaenvfilename</span> <span class=\"p\">];</span> <span class=\"k\">then</span>  \n<span class=\"n\">printf</span> <span class=\"ss\">&quot;name: $foldername\\ndependencies:\\n- pip\\n- python\\n- ipython\\n- jedi\\n- flake8&quot;</span> <span class=\"o\">&gt;</span> <span class=\"err\">$</span><span class=\"n\">condaenvfilename</span>  \n<span class=\"n\">echo</span> <span class=\"ss\">&quot;$condaenvfilename created.&quot;</span>  \n<span class=\"k\">else</span>  \n<span class=\"n\">echo</span> <span class=\"ss\">&quot;$condaenvfilename already exists.&quot;</span>  \n<span class=\"n\">fi</span>\n\n<span class=\"k\">if</span> <span class=\"p\">[</span> <span class=\"o\">!</span> <span class=\"o\">-</span><span class=\"n\">f</span> <span class=\"err\">$</span><span class=\"n\">autoenvfilename</span> <span class=\"p\">];</span> <span class=\"k\">then</span>  \n<span class=\"n\">printf</span> <span class=\"ss\">&quot;source activate $foldername\\n&quot;</span> <span class=\"o\">&gt;</span> <span class=\"err\">$</span><span class=\"n\">autoenvfilename</span>  \n<span class=\"n\">echo</span> <span class=\"ss\">&quot;$autoenvfilename created.&quot;</span>  \n<span class=\"k\">else</span>  \n<span class=\"n\">echo</span> <span class=\"ss\">&quot;$autoenvfilename already exists.&quot;</span>  \n<span class=\"n\">fi</span>  \n<span class=\"err\">}</span>  \n</pre></div>\n\n\n<p><strong>path</strong> - prepends the miniconda3 path to the <span class=\"caps\">PATH</span> environment variable. For example, calls to python will default to the Miniconda3 version (3.5.1 in my case) rather than my system version&nbsp;(2.7).</p>\n<div class=\"highlight\"><pre><span></span><span class=\"err\">export PATH=&quot;/home/$USER/miniconda3/bin:$PATH&quot;</span>\n</pre></div>\n\n\n<p>Now, we&#8217;re done with configuring the dotfiles in this repo (apart from Emacs, which is treated separately). We just have to create symlinks in our home directory to the dotfiles in <code>runcom</code>, which is performed by the shell script, <code>install.sh</code>:</p>\n<div class=\"highlight\"><pre><span></span><span class=\"o\">##</span> <span class=\"p\">...</span>\n\n<span class=\"n\">ln</span> <span class=\"o\">-</span><span class=\"n\">sfv</span> <span class=\"ss\">&quot;$DOTFILES_DIR/runcom/.bash_profile&quot;</span> <span class=\"o\">~</span>  \n<span class=\"n\">ln</span> <span class=\"o\">-</span><span class=\"n\">sfv</span> <span class=\"ss\">&quot;$DOTFILES_DIR/runcom/.profile&quot;</span> <span class=\"o\">~</span>  \n<span class=\"n\">ln</span> <span class=\"o\">-</span><span class=\"n\">sfv</span> <span class=\"ss\">&quot;$DOTFILES_DIR/runcom/.bashrc&quot;</span> <span class=\"o\">~</span>\n\n<span class=\"o\">##</span> <span class=\"p\">...</span>  \n</pre></div>\n\n\n<h3>Installation</h3>\n<p>In addition to setting up dotfiles symlinks, <code>install.sh</code> automates the installation of all our data science tools via calls to each of the scripts in the <code>install</code> subfolder. Each script is named after the mechanism of installation (i.e. <code>apt-get</code>, <code>conda</code>, <code>git</code>) or purpose (to install Miniconda and&nbsp;Emacs).</p>\n<ul>\n<li><strong>apt-get.sh</strong> - installs a handful of programs using the system package manager, including <code>build-essentials</code>, which is needed to compile programs from source. Also enables source-code repositories (not enabled by default in Linux Mint 17), to be used for compiling emacs from&nbsp;source.</li>\n<li><strong>install-emacs.sh</strong> - build Emacs 24.4 from source, which is needed for compatibility with the Magit plug-in (git for Emacs). At the time of writing, only Emacs 24.3 was available on the system&nbsp;repo.</li>\n<li><strong>install-miniconda.sh</strong> - <a href=\"http://conda.pydata.org/docs/\">miniconda</a> includes just conda, conda-build, and python. I prefer this lightweight version to the Anaconda version, which comes with more than 150 scientific packages by default. <em>A note from the Miniconda downloads page: &#8220;There are two variants of the installer: Miniconda is Python 2 based and Miniconda3 is Python 3 based&#8230; the choice of which Miniconda is installed only affects the root environment. Regardless of which version of Miniconda you install, you can still install both Python 2.x and Python 3.x environments. The other difference is that the Python 3 version of Miniconda will default to Python 3 when creating new environments and building packages.&#8221; (I chose&nbsp;Miniconda3.)</em></li>\n<li><strong>conda.sh</strong> - Use conda to install popular scientific packages for python, R, some popular R packages, and packages for <span class=\"caps\">IDE</span> support in&nbsp;Emacs.</li>\n<li><strong>git.sh</strong> - Install <a href=\"https://github.com/kennethreitz/autoenv\">autoenv</a> for working with virtual environment directories. Also clone the configurations from my <a href=\"https://github.com/frangipane/emacs\">Emacs repo</a>.</li>\n</ul>\n<hr>\n<h3>Conclusion</h3>\n<p>The <a href=\"https://github.com/EFavDB/dotfiles\">dotfiles repo</a> discussed in this post will remain in this minimal state on GitHub so that it can be easily parsed and built upon. It&#8217;s the most straightforward to adopt if you are on a similar system (Linux Mint or Ubuntu 14.04), as I haven&#8217;t put in checks for <span class=\"caps\">OSX</span>. If you don&#8217;t like Emacs, feel free to comment out the relevant lines in <code>install.sh</code> and <code>install/git.sh</code>, and replace with your editor of&nbsp;choice.</p>\n<p>Also take a look at other collections of <a href=\"https://github.com/webpro/awesome-dotfiles\">awesome dotfiles</a> for nuggets (like the <code>extract()</code> function) to co-opt. And enjoy the peace of mind that comes with having dotfiles&nbsp;insurance!</p>\n<hr>\n<h3><em>Notes on shell initialization&nbsp;dotfiles</em></h3>\n<p>The handling of the dotfiles .profile, .bash_profile, and .bashrc is frequently a source of <a href=\"http://superuser.com/questions/183870/difference-between-bashrc-and-bash-profile\">confusion</a> that we&#8217;ll try to clear up&nbsp;here.</p>\n<p>For example, .profile and .bash_profile are both recommended for setting environment variables, so what&#8217;s the point of having&nbsp;both?</p>\n<p><strong>.profile</strong><br>\n.profile is loaded upon login to a Unix system (for most distributions) and is where you should put customizations that apply to your whole session, e.g. environment variable assignments like <code>PATH</code> that are not specifically related to bash. .profile holds anything that should be (1) available to graphical applications &#8212; like launching a program from a <span class=\"caps\">GUI</span> by clicking on an icon or menu &#8212; or (2) to <code>sh</code>, which is run by graphical <a href=\"https://wiki.archlinux.org/index.php/display_manager\">display managers</a> like <span class=\"caps\">GDM</span>/LightDM/<span class=\"caps\">MDM</span> when your computer boots up in graphics mode (the most common scenario these days). Note, even though the default login shell is bash in Ubuntu, the default system shell that is used during the bootup process in Ubuntu is <a href=\"https://wiki.ubuntu.com/DashAsBinSh\">dash, not bash</a>, (<code>readlink -f /bin/sh</code> outputs <code>/bin/dash</code>).</p>\n<p>Let&#8217;s give a concrete example of case (1): the miniconda installer provides a default option to add the miniconda binaries to the search path in .bashrc: <code>export PATH=\"/home/$USER/miniconda3/bin:$PATH\"</code>. Assuming you&#8217;ve used <code>conda</code> (not <code>apt-get</code>) to install python scientific computing libraries and have set the path in .bashrc, if Emacs is launched from an icon on the desktop, then Emacs plugins that depend on those libraries (e.g. <code>ein</code>, a plugin that integrates IPython with Emacs) will throw an error; since the graphical invocation only loads .profile, the miniconda binaries would not be in the search path. (On the other hand, there would be no problem launching Emacs from the terminal via <code>$ emacs</code>.) For this reason, it&#8217;s preferable to add the miniconda path in .profile instead of&nbsp;.bashrc.</p>\n<p>For changes to .profile to take effect, you have to log out entirely and then log back&nbsp;in.</p>\n<p><strong>.bash_profile</strong><br>\nLike .profile, .bash_profile should contain environment variable definitions. I haven&#8217;t yet encountered a situation where a configuration can be set in .bash_profile that can&#8217;t be set in .profile or&nbsp;.bashrc.</p>\n<p>Therefore, my .bash_profile just loads .profile and .bashrc. Some choose to bypass .bash_profile entirely and only have .profile (which bash reads if .bash_profile or .bash_login don&#8217;t exist) and&nbsp;.bashrc.</p>\n<p><strong>.bashrc</strong><br>\nDefinitions of alias, functions, and other settings you&#8217;d want in an interactive command line should be put in .bashrc. .bashrc is sourced by interactive, non-login&nbsp;shells.</p>\n<p><strong>login, non-login, interactive, and non-interactive&nbsp;shells</strong></p>\n<ul>\n<li>To check if you&#8217;re in a login shell, type on the command line <code>echo $0</code>. If the output is <code>-bash</code>, then you&#8217;re in a login shell. If the output is <code>bash</code>, then it&#8217;s not a login shell (see <code>man bash</code>).</li>\n<li>Usually, a shell started from a new terminal in a <span class=\"caps\">GUI</span> will be an interactive, non-login shell. The notable exception is <span class=\"caps\">OSX</span>, whose terminal defaults to starting login shells. Thus, an <span class=\"caps\">OSX</span> user may blithely sweep customizations that would ordinarily be placed in .bashrc &#8212; like aliases and functions &#8212; into .bash_profile and not bother with creating a .bashrc at all. However, those settings would not be properly initialized if the terminal default is changed to non-login&nbsp;shells.</li>\n<li>If you ssh in or login on a text console, then you get an interactive, login&nbsp;shell.</li>\n<li>More examples in <a href=\"http://unix.stackexchange.com/questions/38175/difference-between-login-shell-and-non-login-shell/46856#46856\">this StackExchange thread</a>.</li>\n</ul>\n<p>This discussion might seem pedantic since you can often get away with a less careful setup. In my experience, though, what can go wrong will probably go wrong, so best to be&nbsp;proactive.</p>",
  "category": [
    "",
    "",
    "",
    "",
    ""
  ]
}