{
  "guid": "tag:blogger.com,1999:blog-6300367579216018061.post-5256427464584699488",
  "pubDate": "Sun, 03 Jan 2016 18:49:00 +0000",
  "atom:updated": "2016-01-03T15:02:50.556-08:00",
  "category": [
    "apache spark",
    "docker",
    "docker compose",
    "graph analytics",
    "graph processing",
    "graphx",
    "microservices",
    "neo4j",
    "rabbitmq",
    "spring boot",
    "spring cloud",
    "twitter"
  ],
  "title": "Creating a PageRank Analytics Platform Using Spring Boot Microservices",
  "description": "<link rel=\"stylesheet\" href=\"https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans:400,700\"><style>.hljs-title, .hljs-id, .scss .hljs-preprocessor {    font-weight: 400 !important; } .hljs-class .hljs-title, .hljs-type, .vhdl .hljs-literal, .tex .hljs-command {    font-weight: 400 !important; } .hljs-keyword, .css .rule .hljs-keyword, .hljs-winutils, .nginx .hljs-title, .hljs-subst, .hljs-request, .hljs-status {    font-weight: 400 !important; } .sect1{padding-bottom:0!important} .sect1+.sect1{border:0!important} .conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:\"Open Sans\",\"DejaVu Sans\",sans-serif;font-style:normal;font-weight:bold} .conum[data-value] *{color:#fff!important} .conum[data-value]+b{display:none} .conum[data-value]:after{content:attr(data-value)} .fa-caret-up {     color: green;     text-shadow: 1px 1px 1px #ccc;     font-size: 1.75em !important; }  .fa-caret-down {     color: red;     text-shadow: 1px 1px 1px #ccc;     font-size: 1.75em !important; }  .fa-minus {     color: #999;     text-shadow: 1px 1px 1px #ccc;     font-size: 1em !important; }  .fa-plus {     font-size: 1em !important;     color: green;     text-shadow: 1px 1px 1px #ccc; }   @media screen and (min-width: 768px) { .table-responsive { font-size: 0.8em; max-width: 50em; } }  @media screen and (max-width: 768px) {     .table-responsive {     font-size: 0.65em; } }  .table-responsive th, .table-responsive tr, .table-responsive td { padding: 4px 4px 4px 4px !important; } p {     margin-bottom: 1.25em !important; line-height: 1.4; } li p { line-height: 1.4 !important; margin: 0 !important; } .blog-post-asciidoc .content img {  max-height: none; } .admonitionblock > table {     background: rgba(0, 0, 0, 0) none repeat scroll 0 0;     border: 0 none;     border-collapse: separate;     width: 100%; } table {     background: #fff none repeat scroll 0 0;     border: 1px solid #dedede;     margin-bottom: 1.25em; } pre .conum[data-value]{position:relative;top:-.125em} b.conum *{color:inherit!important} .conum:not([data-value]):empty{display:none} .hdlist>table,.colist>table{border:0;background:none} .hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none} td.hdlist1{padding-right:.75em;font-weight:bold} td.hdlist1,td.hdlist2{vertical-align:top} .literalblock+.colist,.listingblock+.colist{margin-top:-.5em} .colist>table tr>td:first-of-type{padding:0 .75em;line-height:1} .colist>table tr>td:last-of-type{padding:.25em 0} h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h3,h4,h6{font-family:\"Open Sans\",sans-serif;font-style:normal;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;} .blog-post-asciidoc p{margin-bottom:1.25rem} @media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}.sect1+.sect1{border-top:1px solid #efefed} pre, pre > code {     -moz-osx-font-smoothing: auto;     color: rgba(0, 0, 0, 0.9);     font-family: monospace,monospace;     font-weight: 400;     line-height: 1.45;     text-rendering: optimizelegibility; } .blog-post-asciidoc code,kbd,pre,samp{font-size:.9em;font-weight:400;} .blog-post-asciidoc .admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%} .blog-post-asciidoc .admonitionblock>table td.icon{text-align:center;width:80px} .blog-post-asciidoc .admonitionblock>table td.icon img{max-width:none} .blog-post-asciidoc .admonitionblock>table td.icon .title{font-weight:bold;font-family:\"Open Sans\",\"DejaVu Sans\",sans-serif;text-transform:uppercase} .blog-post-asciidoc .admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)} .blog-post-asciidoc .admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0} .blog-post-asciidoc .admonitionblock td.icon [class^=\"fa icon-\"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default} .blog-post-asciidoc .admonitionblock td.icon .icon-note:before{content:\"\\f05a\";color:#19407c} .blog-post-asciidoc .admonitionblock td.icon .icon-tip:before{content:\"\\f0eb\";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111} .blog-post-asciidoc .admonitionblock td.icon .icon-warning:before{content:\"\\f071\";color:#bf6900} .blog-post-asciidoc .admonitionblock td.icon .icon-caution:before{content:\"\\f06d\";color:#bf3400} .blog-post-asciidoc .admonitionblock td.icon .icon-important:before{content:\"\\f06a\";color:#bf0000} #personDataTable td {     vertical-align: middle; } .rank-col {     text-align: center; } #personDataTable img {     max-width: 35px;     padding: 0; } .table-responsive {     font-weight: 400; } .table > thead > tr > th {     border-bottom: 2px solid #ddd;     font-weight: 400;     padding: 8px !important;     vertical-align: bottom; } .table-responsive {     font-family: Helvetica,sans-serif; } .exampleblock pre {     margin-top: auto; } .exampleblock .content {     margin-top: auto; } blockquote {     border-left: 5px solid #eee;     color: #666;     font-size: 16px;     margin: 0;     padding: 10px 20px; } .attribution {     font-size: small;     text-align: right; } </style><link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.2.0/css/font-awesome.min.css\"><div id=\"content\" class=\"blog-post-asciidoc\"><a style=\"display: none;\" href=\"http://2.bp.blogspot.com/-KlU_6MvFD5Y/VolMB55ZkVI/AAAAAAAABU8/3eu4YMbpcj8/s1600/twitter-analytics-microservice-diagram.png\" imageanchor=\"1\" ><img border=\"0\" src=\"http://2.bp.blogspot.com/-KlU_6MvFD5Y/VolMB55ZkVI/AAAAAAAABU8/3eu4YMbpcj8/s1600/twitter-analytics-microservice-diagram.png\" /></a><div id=\"preamble\"><div class=\"sectionbody\"><div class=\"paragraph\"><p>This article introduces you <a href=\"https://github.com/kbastani/spring-boot-graph-processing-example\" target=\"_blank\">to a sample application</a> that combines multiple microservices with a graph processing platform to rank communities of users on Twitter. We&#8217;re going to use a collection of popular tools as a part of this article&#8217;s sample application. The tools we&#8217;ll use, in the order of importance, will be:</p></div><div class=\"ulist\"><ul><li><p><a href=\"http://projects.spring.io/spring-boot/\" target=\"_blank\">Spring Boot</a></p></li><li><p><a href=\"http://neo4j.com/\" target=\"_blank\">Neo4j</a></p></li><li><p><a href=\"http://spark.apache.org/\" target=\"_blank\">Apache Spark</a></p></li><li><p><a href=\"https://www.docker.com/\">Docker</a></p></li><li><p><a href=\"https://www.rabbitmq.com/\" target=\"_blank\">RabbitMQ</a></p></li></ul></div></div></div><div class=\"sect1\"><h2 id=\"_ranking_twitter_profiles\">Ranking Twitter Profiles</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p>Let&#8217;s do an overview of the problem we will solve as a part of our sample application. The problem we&#8217;re going to solve is how to <a href=\"https://en.wikipedia.org/wiki/Influencer_marketing#What_is_.E2.80.9CInfluence.E2.80.9D.3F\" target=\"_blank\">discover communities of influencers</a> on Twitter using a set of seed profiles as inputs. To solve this problem without a background in machine learning or social network analytics might be a bit of a stretch, but we&#8217;re going to take a stab at it using a little bit of computer science history.</p></div><div class=\"paragraph\"><p>The <a href=\"https://en.wikipedia.org/wiki/PageRank\" target=\"_blank\">PageRank algorithm</a>, created by Google co-founder <a href=\"https://en.wikipedia.org/wiki/Larry_Page\" target=\"_blank\">Larry Page</a>, was first used by Google to rank website documents from analyzing the graph of backlinks between sites.</p></div><div class=\"paragraph\"><p>I dug up the <a href=\"http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf\" target=\"_blank\">original research paper</a> on PageRank from Stanford for some inspiration. In the paper, the authors talk about the notion of approximating the \"importance\" of an academic publication by weighting the value of its citations.</p></div><div class=\"quoteblock\"><blockquote>The reason that PageRank is interesting is that there are many cases where simple citation counting does not correspond to our common sense notion of importance. For example, if a webpage has a link to the Yahoo home page, it may be just one link but it is a very important one. This page should be ranked higher than many pages with more links but from obscure places. PageRank is an attempt to see how good an approximation to \"importance\" can be obtained just from the link structure. </blockquote><div class=\"attribution\">&mdash; Page, Lawrence and Brin, Sergey and Motwani, Rajeev and Winograd, Terry (1999)<br><cite><a href=\"http://ilpubs.stanford.edu:8090/422\" target=\"_blank\">The PageRank Citation Ranking: Bringing Order to the Web</a></cite></div></div><div class=\"paragraph\"><p>Now let&#8217;s take the same definition that is described in the paper and apply it to our problem of discovering important profiles on Twitter. Twitter users typically follow other users to track their updates as a part of their stream. We can use the same reasoning behind using PageRank on citations to approximate the \"importance\" of profiles on Twitter. This reasoning would tell us that it&#8217;s not the number of followers that make a profile important, it is measured by how important those followers are.</p></div><div class=\"paragraph\"><p>That&#8217;s exactly what we&#8217;re going to build in this article, and we&#8217;ll end up with something that looks like the following table.</p></div><div class=\"table-responsive\">  <table class=\"table table-striped\">    <thead>      <tr>        <th style=\"text-align: center;\">Rank</th>        <th>Photo</th>        <th class=\"hidden-xs\">Name</th>        <th>Profile</th>        <th class=\"hidden-xs\">Following</th>        <th>Followers</th>        <th>PageRank</th>        <th class=\"hidden-xs\">Change</th>      </tr>    </thead>    <tbody id=\"personDataTable\">      <tr>        <td class=\"rank-col\">1.</td>        <td><img src=\"http://pbs.twimg.com/profile_images/3363818792/c90e33ccf22e3146d5cd871ce561795a_normal.png\"></td>        <td class=\"hidden-xs\">Paul Ford</td>        <td><a target=\"_blank\" href=\"http://www.twitter.com/ftrain\">@ftrain</a></td>        <td class=\"hidden-xs\">175</td>        <td>31948</td>        <td>7368.2417</td>        <td class=\"hidden-xs\"><i aria-hidden=\"true\" class=\"fa fa-minus\"></i></td>      </tr>      <tr>        <td class=\"rank-col\">2.</td>        <td><img src=\"http://pbs.twimg.com/profile_images/550153119208726529/ZZqJSFpi_normal.jpeg\"></td>        <td class=\"hidden-xs\">harper</td>        <td><a target=\"_blank\" href=\"http://www.twitter.com/harper\">@harper</a></td>        <td class=\"hidden-xs\">1024</td>        <td>32452</td>        <td>6754.455</td>        <td class=\"hidden-xs\"><i aria-hidden=\"true\" class=\"fa fa-minus\"></i></td>      </tr>      <tr>        <td class=\"rank-col\">3.</td>        <td><img src=\"http://pbs.twimg.com/profile_images/478069251790499841/GNcGrhNt_normal.png\"></td>        <td class=\"hidden-xs\">Bret Victor</td>        <td><a target=\"_blank\" href=\"http://www.twitter.com/worrydream\">@worrydream</a></td>        <td class=\"hidden-xs\">35</td>        <td>37658</td>        <td>6747.585</td>        <td class=\"hidden-xs\"><i aria-hidden=\"true\" class=\"fa fa-minus\"></i></td>      </tr>      <tr>        <td class=\"rank-col\">4.</td>        <td><img src=\"http://pbs.twimg.com/profile_images/673478075892404225/FB25Vch7_normal.jpg\"></td>        <td class=\"hidden-xs\">Lincoln Stoll</td>        <td><a target=\"_blank\" href=\"http://www.twitter.com/lstoll\">@lstoll</a></td>        <td class=\"hidden-xs\">872</td>        <td>41067</td>        <td>5976.3555</td>        <td class=\"hidden-xs\"><i aria-hidden=\"true\" class=\"fa fa-minus\"></i></td>      </tr>      <tr>        <td class=\"rank-col\">5.</td>        <td><img src=\"http://pbs.twimg.com/profile_images/1768986828/image1327082013_normal.png\"></td>        <td class=\"hidden-xs\">kate matsudaira</td>        <td><a target=\"_blank\" href=\"http://www.twitter.com/katemats\">@katemats</a></td>        <td class=\"hidden-xs\">20465</td>        <td>25799</td>        <td>5916.3843</td>        <td class=\"hidden-xs\"><i aria-hidden=\"true\" class=\"fa fa-caret-up\"></i></td>      </tr>      <tr>        <td class=\"rank-col\">6.</td>        <td><img src=\"http://pbs.twimg.com/profile_images/651438942181453824/Ov8RmRF9_normal.png\"></td>        <td class=\"hidden-xs\">rands</td>        <td><a target=\"_blank\" href=\"http://www.twitter.com/rands\">@rands</a></td>        <td class=\"hidden-xs\">741</td>        <td>35079</td>        <td>5888.145</td>        <td class=\"hidden-xs\"><i aria-hidden=\"true\" class=\"fa fa-caret-down\"></i></td>      </tr>      <tr>        <td class=\"rank-col\">7.</td>        <td><img src=\"http://pbs.twimg.com/profile_images/513088789585993728/s1DnFxP6_normal.jpeg\"></td>        <td class=\"hidden-xs\">Alex Payne</td>        <td><a target=\"_blank\" href=\"http://www.twitter.com/al3x\">@al3x</a></td>        <td class=\"hidden-xs\">405</td>        <td>41099</td>        <td>5547.4307</td>        <td class=\"hidden-xs\"><i aria-hidden=\"true\" class=\"fa fa-minus\"></i></td>      </tr>      <tr>        <td class=\"rank-col\">8.</td>        <td><img src=\"http://pbs.twimg.com/profile_images/1245949369/b8dbb1987e8e5318584865f880036796_normal.jpeg\"></td>        <td class=\"hidden-xs\">Chris Wanstrath</td>        <td><a target=\"_blank\" href=\"http://www.twitter.com/defunkt\">@defunkt</a></td>        <td class=\"hidden-xs\">5645</td>        <td>45310</td>        <td>4787.9644</td>        <td class=\"hidden-xs\"><i aria-hidden=\"true\" class=\"fa fa-minus\"></i></td>      </tr>      <tr>        <td class=\"rank-col\">9.</td>        <td><img src=\"http://pbs.twimg.com/profile_images/629693983610961921/k-pW0Isa_normal.png\"></td>        <td class=\"hidden-xs\">SaraReyChipps</td>        <td><a target=\"_blank\" href=\"http://www.twitter.com/SaraJChipps\">@SaraJChipps</a></td>        <td class=\"hidden-xs\">1007</td>        <td>29617</td>        <td>4271.676</td>        <td class=\"hidden-xs\"><i aria-hidden=\"true\" class=\"fa fa-caret-down\"></i></td>      </tr>      <tr>        <td class=\"rank-col\">10.</td>        <td><img src=\"http://pbs.twimg.com/profile_images/679769047022436353/nhMCEyEj_normal.jpg\"></td>        <td class=\"hidden-xs\">Leah Culver</td>        <td><a target=\"_blank\" href=\"http://www.twitter.com/leahculver\">@leahculver</a></td>        <td class=\"hidden-xs\">491</td>        <td>30723</td>        <td>3852.3728</td>        <td class=\"hidden-xs\"><i aria-hidden=\"true\" class=\"fa fa-minus\"></i></td>      </tr>    </tbody>  </table></div><div class=\"paragraph\"><p>The first thing we&#8217;re going to need to worry about when building this solution is how we&#8217;re going to calculate PageRank on potentially millions of users and links. To do this, we&#8217;re going to use something called a <em>graph processing platform</em>.</p></div></div></div><div class=\"sect1\"><h2 id=\"_what_is_a_graph_processing_platform\">What is a graph processing platform?</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p>A graph processing platform is an application architecture that provides a general-purpose job scheduling interface for analyzing graphs. The application we&#8217;ll build will make use of a graph processing platform to analyze and rank communities of users on Twitter. For this we&#8217;ll use <a href=\"https://github.com/neo4j-contrib/neo4j-mazerunner\" target=\"_blank\">Neo4j Mazerunner</a>, an open source project that I started that connects Neo4j’s database server to Apache Spark.</p></div><div class=\"paragraph\"><p>The diagram below illustrates a graph processing platform similar to Neo4j Mazerunner.</p></div><div class=\"exampleblock\"><div class=\"content\"><div class=\"imageblock\" style=\"display: block;\"><div class=\"content\" style=\"text-align: center;\"><img width=\"100%\" alt=\"Graph processing platform diagram\" src=\"http://i.imgur.com/93dJ2MM.png\" style=\"max-height: 25em; margin: auto !important;\"></div></div></div></div><div class=\"sect2\"><h3 id=\"_submitting_pagerank_jobs_to_graphx\">Submitting PageRank Jobs to GraphX</h3><div class=\"paragraph\"><p>The graph processing platform I&#8217;ve described will provide us with a general purpose API for submitting PageRank jobs to <a href=\"http://spark.apache.org/graphx/\" target=\"_blank\">Apache Spark&#8217;s GraphX module</a> from Neo4j. The PageRank results from GraphX will be automatically applied back to Neo4j without any additional work to manually handle data loading. The workflow for this is extremely simple for our purposes. From a backend service we will only need to make a simple HTTP request to Neo4j to begin a PageRank job.</p></div><div class=\"paragraph\"><p>I&#8217;ve also taken care of making sure that the graph processing platform is easily deployable to a cloud provider using Docker containers. In a <a href=\"http://www.kennybastani.com/2015/03/spark-neo4j-tutorial-docker.html\" target=\"_blank\">previous article</a>, I describe how to use <a href=\"https://docs.docker.com/compose/\" target=\"_blank\">Docker Compose</a> to run Mazerunner as a multi-container application. We&#8217;ll do the same for this sample application but extend the Docker Compose file to include additional Spring Boot applications that will become our backend microservices.</p></div><div class=\"admonitionblock caution\"><table><tr><td class=\"icon\"><i class=\"fa icon-caution\" title=\"Caution\"></i></td><td class=\"content\">By default, Docker Compose will orchestrate containers on a single virtual machine. If we were to build a truly fault tolerant and resilient cloud-based application, we&#8217;d need to be sure to scale our system to multiple virtual machines using a cloud platform. This is the subject of a later article. </td></tr></table></div><div class=\"paragraph\"><p>Now that we understand how we will use a graph processing platform, let&#8217;s talk about how to build a microservice architecture using Spring Boot and Spring Cloud to rank profiles on Twitter.</p></div></div></div></div><h1 id=\"_building_microservices\" class=\"sect0\">Building Microservices</h1><div class=\"paragraph\"><p>I&#8217;ve talked a lot about microservices in past articles. When we talk about microservices we are talking about developing software in the context of <a href=\"https://en.wikipedia.org/wiki/Continuous_delivery\" target=\"_blank\">continuous delivery</a>. Microservices are not just smaller services that scale horizontally. When we talk about microservices, we are talking about being able to create applications that are the product of many teams delivering continuously in independent release cycles. Josh Long and I describe at length how to untangle the patterns of building and operating JVM-based microservices in <a href=\"http://shop.oreilly.com/product/0636920038252.do\" target=\"_blank\">O&#8217;Reilly&#8217;s <em>Cloud Native Java</em></a>.</p></div><div class=\"paragraph\"><p>In this sample, we&#8217;ll build 4 microservices, each as a Spring Boot application. If we were to build this architecture as microservices in an authentic scenario, each microservice would be owned and managed by a different team. This is an important differentiation in this new practice, as there is much confusion around what a microservice is and what it is not. A microservice is not just a distributed system of small services. The practice of building microservices should never be without the discipline of continuous delivery.</p></div><div class=\"paragraph\"><p>For the purposes of this article, we&#8217;ll focus on scenarios that help us gain experience and familiarity with building distributed systems that resemble a microservice architecture.</p></div><div class=\"sect1\"><h2 id=\"_overview\">Overview</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p>Now let&#8217;s do a quick overview of the concepts we&#8217;re going to cover as a part of this sample application. We will apply the same recipe from previous articles on similar topics for <a href=\"http://www.kennybastani.com/2015/07/spring-cloud-docker-microservices.html\" target=\"_blank\">building microservices with Spring Boot and Spring Cloud</a>. The key difference from my previous articles is that we are going to create a data service that does both batch processing tasks as well as exposing data as HTTP resources to API consumers.</p></div></div></div><div class=\"sect1\"><h2 id=\"_system_architecture_diagram\">System Architecture Diagram</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p>The diagram below shows each component and microservice that we will create as a part of this sample application. Notice how we’re connecting the Spring Boot applications to the graph processing platform we looked at earlier. Also, notice the connections between the services, these connections define communication points between each service and what protocol is used.</p></div><div class=\"exampleblock\"><div class=\"content\"><div class=\"imageblock\" style=\"display: block;\"><div class=\"content\" style=\"text-align: center;\"><img width=\"100%\" alt=\"Microservice architecture with Spring Boot\" src=\"http://i.imgur.com/LDHQJAx.png\" style=\"max-height: 25em; margin: auto !important;\"></div></div></div></div><div class=\"paragraph\"><p>The three applications that are colored in blue are stateless services. Stateless services will not attach a persistent <a href=\"http://12factor.net/backing-services\" target=\"_blank\">backing service</a> or need to worry about managing state locally. The application that is colored in green is the <em>Twitter Crawler</em> service. Components that are colored in green will typically have an attached backing service. These backing services are responsible for managing state locally, and will either persist state to disk or in-memory.</p></div></div></div><a name='more'></a><h1 id=\"_twitter_crawler\" class=\"sect0\">Twitter Crawler</h1><div class=\"paragraph\"><p>We’ll start by creating a service that is responsible for importing data from Twitter’s API and storing it in Neo4j. This service will be called the <em>Twitter Crawler</em> service. This service will also schedule PageRank jobs on data it imports into Neo4j. The <em>Twitter Crawler</em> service will be built using Spring Boot and attach backing services for Neo4j and RabbitMQ.</p></div><div class=\"paragraph\"><p>We&#8217;re going to walkthrough each of the following concerns as a part of building this service.</p></div><div class=\"ulist\"><ul><li><p><a href=\"#_creating_spring_data_neo4j_repositories\">Creating Spring Data Neo4j repositories</a></p></li><li><p><a href=\"#_exposing_repository_apis_using_spring_data_rest\">Exposing repository APIs using Spring Data REST</a></p></li><li><p><a href=\"#_connecting_to_the_twitter_api\">Connecting to the Twitter API</a></p></li><li><p><a href=\"#_using_amqp_to_import_profiles_from_the_twitter_api\">Using AMQP to import profiles from the Twitter API</a></p></li><li><p><a href=\"#_scheduling_new_pagerank_jobs\">Scheduling new PageRank jobs</a></p></li><li><p><a href=\"#_discovering_new_users\">Discovering new users</a></p></li><li><p><a href=\"#_registering_as_a_discovery_client_with_eureka\">Registering as a discovery client with Eureka</a></p></li></ul></div><div class=\"sect1\"><h2 id=\"_creating_spring_data_neo4j_repositories\">Creating Spring Data Neo4j repositories</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p>We&#8217;ll start building the <em>Twitter Crawler</em> service by creating a set of domain classes and repositories to manage data with the <a href=\"http://projects.spring.io/spring-data-neo4j/\" target=\"_blank\">Spring Data Neo4j project</a>. Spring Data Neo4j is a project in the Spring Data ecosystem that implements the Spring Data repository abstraction using an <a href=\"http://neo4j.com/docs/ogm/java/stable/\" target=\"_blank\">OGM (Object Graph Mapping)</a> library for Neo4j. Spring Data Neo4j allows you to manage data on a Neo4j server using annotated POJOs as entity references in a Spring Data application.</p></div><div class=\"paragraph\"><p>Before we can start managing data in Neo4j, we&#8217;ll need to design and construct a graph data model for our application&#8217;s domain data. The domain model for this application is rather simple, and we&#8217;ll construct it using domain objects described in <a href=\"https://dev.twitter.com/overview/documentation\" target=\"_blank\">Twitter&#8217;s API documentation</a>. We&#8217;ll only have one domain concept, which is a <code>User</code> profile, and we&#8217;ll source this resource from profiles that are imported from the Twitter API. We&#8217;ll then have a relationship entity with the type named <code>FOLLOWS</code>. The <code>FOLLOWS</code> relationship will connect <code>User</code> profiles together in Neo4j after importing follower data from the Twitter API.</p></div><div class=\"paragraph\"><p>The graph data model that we will end up with looks like the following diagram.</p></div><div class=\"exampleblock\"><div class=\"content\"><div class=\"imageblock\" style=\"display: block;\"><div class=\"content\" style=\"text-align: center;\"><img width=\"100%\" alt=\"Graph data model for Neo4j\" src=\"http://i.imgur.com/Fg2oOal.png\" style=\"max-height: 25em; margin: auto !important;\"></div></div></div></div><div class=\"paragraph\"><p>We&#8217;ll now use the graph data model illustrated in the diagram to create a POJO that represents a domain class for the <code>User</code> node in Neo4j. We&#8217;ll also be sure to add fields for the incoming and outgoing follower connections as members of the <code>User</code> domain class. These fields will be created with the type <code>Set&lt;User&gt;</code>, and give us a way to load profiles that are connected to a <code>User</code> node with a <code>FOLLOWS</code> relationship. These steps are shown in the example code snippet below.</p></div><div class=\"exampleblock\"><div class=\"title\">Example 1. <a href=\"https://github.com/kbastani/spring-boot-graph-processing-example/blob/master/twitter-rank-crawler/src/main/java/org/kbastani/twitter/User.java#L22\" target=\"_blank\">User.java</a></div><div class=\"content\"><div class=\"listingblock\"><div class=\"content\"><pre class=\"prettyprint highlight\"><code class=\"language-java\" data-lang=\"java\">@NodeEntity<br />public class User implements Serializable {<br /><br />    @GraphId<br />    private Long id;<br /><br />    @Index(unique = true) <i class=\"conum\" data-value=\"1\"></i><b>(1)</b><br />    private Long profileId;<br /><br />    @Relationship(type = \"FOLLOWS\", direction = \"OUTGOING\") <i class=\"conum\" data-value=\"2\"></i><b>(2)</b><br />    private Set&lt;User&gt; follows = new HashSet&lt;&gt;();<br /><br />    @Relationship(type = \"FOLLOWS\", direction = \"INCOMING\") <i class=\"conum\" data-value=\"3\"></i><b>(3)</b><br />    private Set&lt;User&gt; followers = new HashSet&lt;&gt;();<br /><br />    private String screenName;<br />    private Float pagerank;<br /><br />    ...</code></pre></div></div><div class=\"colist arabic\"><table><tr><td><i class=\"conum\" data-value=\"1\"></i><b>1</b></td><td>Creates a unique constraint on a user&#8217;s <code>profileId</code> property</td></tr><tr><td><i class=\"conum\" data-value=\"2\"></i><b>2</b></td><td>Manages relationships of user nodes that this profile is following</td></tr><tr><td><i class=\"conum\" data-value=\"3\"></i><b>3</b></td><td>Manages relationships of user nodes that this profile is being followed by</td></tr></table></div></div></div><div class=\"paragraph\"><p>Next, we&#8217;ll need to create a repository to manage our data that will be mapped to the <code>User</code> domain class. The Spring Data project makes repository-based management of database entities a snap. We&#8217;re going to use the <code>GraphRepository&lt;T&gt;</code> interface to create a repository bean that will be created at runtime in our Spring Boot application.</p></div><div class=\"exampleblock\"><div class=\"title\">Example 2. <a href=\"https://github.com/kbastani/spring-boot-graph-processing-example/blob/master/twitter-rank-crawler/src/main/java/org/kbastani/twitter/UserRepository.java#L14\" target=\"_blank\">UserRepository.java</a></div><div class=\"content\"><div class=\"listingblock\"><div class=\"content\"><pre class=\"prettyprint highlight\"><code class=\"language-java\" data-lang=\"java\">public interface UserRepository extends GraphRepository&lt;User&gt; {<br /><br />  // Get a User's Neo4j node ID using a Twitter profile ID<br />  @Query(\"MATCH (user:User { profileId: {profileId} }) RETURN id(user) as id\")<br />  Long getUserIdByProfileId(@Param(\"profileId\") Long profileId);<br /><br />  ...<br />}</code></pre></div></div></div></div><div class=\"paragraph\"><p>Here we create a basic interface that extends <code>GraphRepository&lt;User&gt;</code>. This repository interface will be initialized as a bean at runtime, and provides us with a client to manage transactions on entities for <code>User</code> nodes in Neo4j.</p></div><div class=\"paragraph\"><p>Now that we can manage <code>User</code> nodes and <code>FOLLOWS</code> relationships, we need to think about how performant it will be to save potentially thousands of relationships per second when importing user profiles from the Twitter API. We&#8217;ll need to be able to batch transactions so that Neo4j can handle the throughput of ingesting writes at a rapid pace. To do this, we need to create another <code>GraphRepository</code> bean for managing the creation of many <code>FOLLOWS</code> relationships between a set of <code>User</code> profiles.</p></div><div class=\"exampleblock\"><div class=\"title\">Example 3. <a href=\"https://github.com/kbastani/spring-boot-graph-processing-example/blob/master/twitter-rank-crawler/src/main/java/org/kbastani/twitter/FollowsRepository.java#L13\" target=\"_blank\">FollowsRepository.java</a></div><div class=\"content\"><div class=\"listingblock\"><div class=\"content\"><pre class=\"prettyprint highlight\"><code class=\"language-java\" data-lang=\"java\">public interface FollowsRepository extends GraphRepository&lt;Follows&gt; {<br /><br />  // Batches the creation of many FOLLOWS relationships<br />  @Query(\"FOREACH(x in {follows} | MERGE (a:User { profileId: x.userA.profileId })\\n\" +<br />          \"MERGE (b:User { profileId: x.userB.profileId })\\n\" +<br />          \"MERGE (a)-[:FOLLOWS]-&gt;(b))\")<br />  void saveFollows(@Param(\"follows\") Set&lt;Follows&gt; follows);<br />}</code></pre></div></div></div></div><div class=\"paragraph\"><p>The repository interface definition above is similar to the <code>UserRepository</code> interface. We&#8217;ve defined a <a href=\"http://neo4j.com/docs/stable/cypher-query-lang.html\" target=\"_blank\">Cypher query</a> template for a custom repository method that will allow us to save batches of thousands of relationships that will connect <code>User</code> nodes together with a <code>FOLLOWS</code> relationship type in our Neo4j database. The custom <code>saveFollows</code> method takes in a domain class representing a relationship entity for the <code>FOLLOWS</code> relationship type. We&#8217;ll also need to create this domain class as a POJO like we did with the <code>User</code> node.</p></div><div class=\"exampleblock\"><div class=\"title\">Example 4. <a href=\"https://github.com/kbastani/spring-boot-graph-processing-example/blob/master/twitter-rank-crawler/src/main/java/org/kbastani/twitter/Follows.java#L11\" target=\"_blank\">Follows.java</a></div><div class=\"content\"><div class=\"listingblock\"><div class=\"content\"><pre class=\"prettyprint highlight\"><code class=\"language-java\" data-lang=\"java\">@RelationshipEntity(type = \"FOLLOWS\") <i class=\"conum\" data-value=\"1\"></i><b>(1)</b><br />public class Follows {<br /><br />  @GraphId<br />  private Long relationshipId;<br />  @StartNode<br />  private User userA; <i class=\"conum\" data-value=\"2\"></i><b>(2)</b><br />  @EndNode<br />  private User userB; <i class=\"conum\" data-value=\"3\"></i><b>(3)</b><br /><br />  ...</code></pre></div></div><div class=\"colist arabic\"><table><tr><td><i class=\"conum\" data-value=\"1\"></i><b>1</b></td><td>Demarcates this class as a relationship entity for the <code>FOLLOWS</code> type</td></tr><tr><td><i class=\"conum\" data-value=\"2\"></i><b>2</b></td><td>This is the user with the outgoing <code>FOLLOWS</code> relationship</td></tr><tr><td><i class=\"conum\" data-value=\"3\"></i><b>3</b></td><td>This is the other user with the incoming <code>FOLLOWS</code> relationship</td></tr></table></div></div></div><div class=\"paragraph\"><p>We now have the necessary data management capabilities to import Twitter profiles and their connections in the native shape of a graph. This is the advantage of using a graph database. Having our data stored as a graph makes it easy to perform PageRank analysis on without tedious aggregation and transformation that would be necessary if we used a relational database.</p></div></div></div><div class=\"sect1\"><h2 id=\"_exposing_repository_apis_using_spring_data_rest\">Exposing repository APIs using Spring Data REST</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p>Now that we have created our Spring Data Neo4j repositories for managing our Twitter follower graph, we&#8217;ll need to expose a REST API interface that allows remote services to manage our domain data over HTTP. Thankfully this is a simple task when using the <a href=\"http://projects.spring.io/spring-data-rest/\" target=\"_blank\">Spring Data REST</a> project. All that we need to do to enable this as a feature on our Spring Data Neo4j repositories is add the <code>spring-boot-starter-data-rest</code> artifact as a dependency to the project&#8217;s <code>pom.xml</code> file.</p></div><div class=\"exampleblock\"><div class=\"title\">Example 5. <a href=\"https://github.com/kbastani/spring-boot-graph-processing-example/blob/master/twitter-rank-crawler/pom.xml#L44\" target=\"_blank\">pom.xml</a></div><div class=\"content\"><div class=\"listingblock\"><div class=\"content\"><pre class=\"prettyprint highlight\"><code class=\"language-xml\" data-lang=\"xml\">&lt;dependency&gt;<br />    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br />    &lt;artifactId&gt;spring-boot-starter-data-rest&lt;/artifactId&gt;<br />&lt;/dependency&gt;</code></pre></div></div></div></div><div class=\"paragraph\"><p>By adding this artifact as a dependency, the Spring Boot application will automatically find Spring Data repositories and expose a REST API to manage repository data remotely over HTTP. Now if we start our Spring Boot application and navigate to the base HTTP endpoint we&#8217;ll see a JSON response in the format of <code>application/hal+json</code>.</p></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"prettyprint highlight\"><code class=\"language-json\" data-lang=\"json\">{<br />  \"_links\" : {<br />    \"following\" : {<br />      \"href\" : \"http://localhost:8080/following{?page,size,sort}\",<br />      \"templated\" : true<br />    },<br />    \"users\" : {<br />      \"href\" : \"http://localhost:8080/users{?page,size,sort}\",<br />      \"templated\" : true<br />    },<br />    \"profile\" : {<br />      \"href\" : \"http://localhost:8080/profile\"<br />    }<br />  }<br />}</code></pre></div></div><div class=\"paragraph\"><p>The <code>application/hal+json</code> content type is a JSON representation that lists <a href=\"https://spring.io/understanding/HATEOAS\" target=\"_blank\">hypermedia resources</a> as embedded links. We can use these embedded links for <code>/users{?page,size,sort}</code> and <code>/following{?page,size,sort}</code> to manage resources of our graph repositories over HTTP.</p></div></div></div><div class=\"sect1\"><h2 id=\"_connecting_to_the_twitter_api\">Connecting to the Twitter API</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p>Now that we have everything we need to manage our Twitter profile data in Neo4j, we can import profiles from the Twitter API. To do this, we can use the <a href=\"http://projects.spring.io/spring-social-twitter/\" target=\"_blank\"><em>Spring Social Twitter</em></a> project, an open source project from the Spring ecosystem that provides a managed Twitter API client. Before we can start using this client, we&#8217;ll need to add the <code>spring-social-twitter</code> artifact as one of our project dependencies in the <code>pom.xml</code>, which is shown in the code snippet below.</p></div><div class=\"exampleblock\"><div class=\"title\">Example 6. <a href=\"https://github.com/kbastani/spring-boot-graph-processing-example/blob/master/twitter-rank-crawler/pom.xml#L39\" target=\"_blank\">pom.xml</a></div><div class=\"content\"><div class=\"listingblock\"><div class=\"content\"><pre class=\"prettyprint highlight\"><code class=\"language-xml\" data-lang=\"xml\">&lt;dependency&gt;<br />    &lt;groupId&gt;org.springframework.social&lt;/groupId&gt;<br />    &lt;artifactId&gt;spring-social-twitter&lt;/artifactId&gt;<br />    &lt;version&gt;1.1.2.RELEASE&lt;/version&gt;<br />&lt;/dependency&gt;</code></pre></div></div></div></div><div class=\"paragraph\"><p>The next step will be to configure the <a href=\"http://docs.spring.io/spring-social-twitter/docs/1.1.0.RELEASE/reference/htmlsingle/#twitter-api-binding\" target=\"_blank\">Twitter client</a> that is provided by <code>spring-social-twitter</code>. In order to access operations for importing profiles from Twitter’s API, we will need to provide API tokens and keys that are generated for an application by Twitter. You’ll need to register with Twitter and create a developer app in order to get these keys. Getting API access is a simple process. <a href=\"https://spring.io/guides/gs/register-twitter-app/\">A step-by-step guide</a> is available from Spring&#8217;s website that will show you how to generate Twitter API keys for an application.</p></div><div class=\"paragraph\"><p>In our Spring Boot application we will map configuration properties as key values on the classpath. To do this, we will map keys in our application&#8217;s <code>.properties</code> file to values in the environment. These values will be our keys and access tokens that we need to authenticate with the Twitter API, and we&#8217;ll use them as parameters to configure a new <code>TwitterTemplate</code> bean at runtime.</p></div><div class=\"admonitionblock note\"><table><tr><td class=\"icon\"><i class=\"fa icon-note\" title=\"Note\"></i></td><td class=\"content\">The <code>TwitterTemplate</code> is provided as a bean from the <a href=\"http://projects.spring.io/spring-social/\" target=\"_blank\">Spring Social</a> project and provides a client for authenticating and interacting with Twitter&#8217;s API. </td></tr></table></div><div class=\"paragraph\"><p>The example snippet below shows how we can use the <code>@Value</code> <a href=\"https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html\" target=\"_blank\">annotation to load in configurations</a> defined from the application&#8217;s <code>.properties</code> file.</p></div><div class=\"exampleblock\"><div class=\"title\">Example 7. <a href=\"https://github.com/kbastani/spring-boot-graph-processing-example/blob/master/twitter-rank-crawler/src/main/java/org/kbastani/config/TwitterCrawlerConfig.java#L43\" target=\"_blank\">TwitterCrawlerConfig.java</a></div><div class=\"content\"><div class=\"listingblock\"><div class=\"content\"><pre class=\"prettyprint highlight\"><code class=\"language-java\" data-lang=\"java\">@Value(\"${spring.social.twitter.appId}\")<br />private String appId;<br /><br />@Value(\"${spring.social.twitter.appSecret}\")<br />private String appSecret;<br /><br />@Value(\"${spring.social.twitter.accessToken}\")<br />private String accessToken;<br /><br />@Value(\"${spring.social.twitter.accessTokenSecret}\")<br />private String accessTokenSecret;<br /><br />@Bean<br />Twitter twitter() {<br />    return new TwitterTemplate(appId, appSecret, accessToken, accessTokenSecret);<br />}</code></pre></div></div></div></div><div class=\"paragraph\"><p>As we can see from the code example, we will use a hierarchy of keys as a map to where we will find configuration properties in our <code>application.yml</code> file. We&#8217;ll need to add our Twitter API keys and tokens to the <code>application.yml</code> file exactly where it will be expected in our <code>TwitterTemplate</code> configuration class. The <code>application.yml</code> file for the <em>Twitter Crawler</em> service will look like the following.</p></div><div class=\"exampleblock\"><div class=\"title\">Example 8. <a href=\"https://github.com/kbastani/spring-boot-graph-processing-example/blob/master/twitter-rank-crawler/src/main/resources/application.yml#L22\" target=\"_blank\">application.yml</a></div><div class=\"content\"><div class=\"listingblock\"><div class=\"content\"><pre class=\"prettyprint highlight\"><code class=\"language-yaml\" data-lang=\"yaml\">spring.profiles.active: 'production'<br />---<br />server:<br />  port: 8080<br />spring:<br />  social: <i class=\"conum\" data-value=\"1\"></i><b>(1)</b><br />    twitter:<br />      accessTokenSecret: 'replace'<br />      accessToken: 'replace'<br />      appSecret: 'replace'<br />      appId: 'replace'</code></pre></div></div><div class=\"colist arabic\"><table><tr><td><i class=\"conum\" data-value=\"1\"></i><b>1</b></td><td>The <code>spring.social.twitter</code> configuration properties map will contain our Twitter API keys and tokens</td></tr></table></div></div></div><div class=\"admonitionblock caution\"><table><tr><td class=\"icon\"><i class=\"fa icon-caution\" title=\"Caution\"></i></td><td class=\"content\">The Twitter API keys and access tokens for these properties can be overridden using externalized values in the application&#8217;s runtime environment, since it&#8217;s not a good practice to store sensitive information like this as hardcoded values in the project&#8217;s source code repository. </td></tr></table></div><div class=\"admonitionblock note\"><table><tr><td class=\"icon\"><i class=\"fa icon-note\" title=\"Note\"></i></td><td class=\"content\">Spring Boot provides an <a href=\"https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html#boot-features-external-config-yaml\" target=\"_blank\">option to use YAML</a> as a format for an application&#8217;s configuration <code>.properties</code> file, which I happen to be partial to using. To use YAML as a format instead of the classic <code>.properties</code> format, change the <code>application.properties</code> file name to <code>application.yml</code>, located in the application&#8217;s <code>src/main/resources</code> folder </td></tr></table></div><div class=\"paragraph\"><p>Now our Spring Boot application for the <em>Twitter Crawler</em> service will be able to use a <code>TwitterTemplate</code> object as a client to interact with the Twitter API. The code snippet below is a simplified example of how we will access a <code>TwitterTemplate</code> bean using a Spring framework technique called <a href=\"http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-constructor-injection\">constructor-based dependency injection</a>.</p></div><div class=\"exampleblock\"><div class=\"title\">Example 9. <a href=\"https://github.com/kbastani/spring-boot-graph-processing-example/blob/master/twitter-rank-crawler/src/main/java/org/kbastani/message/Receiver.java#L46\" target=\"_blank\">Receiver.java</a></div><div class=\"content\"><div class=\"listingblock\"><div class=\"content\"><pre class=\"prettyprint highlight\"><code class=\"language-java\" data-lang=\"java\">@Component<br />public class Receiver {<br /><br />  private Twitter twitter;<br /><br />  @Autowired <i class=\"conum\" data-value=\"1\"></i><b>(1)</b><br />  public Listener(Twitter twitter) {<br />    this.twitter = twitter;<br />  }<br /><br />  private void findFollowers(Long profileId) {<br />    // Retrieve a profile's followers using the TwitterTemplate<br />    twitter.friendOperations().getFollowerIds(profileId);<br />  }<br /><br />...</code></pre></div></div><div class=\"colist arabic\"><table><tr><td><i class=\"conum\" data-value=\"1\"></i><b>1</b></td><td>Causes an instance of the <code>TwitterTemplate</code> object to be provided as a constructor&#8217;s parameter</td></tr></table></div></div></div><div class=\"paragraph\"><p>The snippet of code above is meant to illustrate how we&#8217;ll be using the <code>TwitterTemplate</code> client throughout the application. We can see that in this class that we&#8217;re getting a reference to the <code>TwitterTemplate</code> through the constructor, which will be called by Spring when initializing the bean at runtime.</p></div></div></div><div class=\"sect1\"><h2 id=\"_using_amqp_to_import_profiles_from_the_twitter_api\">Using AMQP to import profiles from the Twitter API</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p>The Twitter API has <a href=\"https://dev.twitter.com/rest/public/rate-limiting\" target=\"_blank\">strict rate limiting policies</a> for a single access token. The <em>follower</em> and <em>friend</em> API resources come with a 15 minute fixed window to make 15 HTTP requests. If we were to try to import a single user per request, it would take us roughly a year to import 1 million unique users. The good news is that Twitter has added the ability to grab cursored lists of followers and friends of a user. This allows us to import up to 5000 profiles per request. If you&#8217;re crawling the right users, you can import about 1 million unique users per day. That&#8217;s not too shabby.</p></div><div class=\"paragraph\"><p>If we were to get rate limited before we were done importing all of a user&#8217;s friends and followers, we need to make sure that we finish importing the rest of the user&#8217;s friends and followers when our rate limit expires. We will need a complete picture of the follower graph in order for PageRank to be an accurate predictor of a user&#8217;s importance in a community. We can&#8217;t lose any data during the import process or the crawler algorithm will be unreliable. We need our data to be consistent at all times or else we&#8217;ll suffer skewed results.</p></div><div class=\"paragraph\"><p>To ensure that data is imported reliably while maximizing utility of the rate limiting policies for resources, we&#8217;ll use the <a href=\"http://projects.spring.io/spring-amqp/\" target=\"_blank\">Spring AMQP</a> project and bind to RabbitMQ.</p></div><div class=\"paragraph\"><p>We&#8217;re going to create two queues that we will use to serially import friends and followers of each discovered Twitter profile. We&#8217;ll start by configuring two RabbitMQ queues as beans in our Spring Boot application. The queues we need to create will be named <strong>twitter.follows</strong> and <strong>twitter.followers</strong>. We can do this by initializing the bean using the <code>@Bean</code> annotation and returning a new instance of the <code>Queue</code> class, shown below.</p></div><div class=\"exampleblock\"><div class=\"title\">Example 10. <a href=\"https://github.com/kbastani/spring-boot-graph-processing-example/blob/master/twitter-rank-crawler/src/main/java/org/kbastani/config/TwitterCrawlerConfig.java#L34\" target=\"_blank\">TwitterCrawlerConfig.java</a></div><div class=\"content\"><div class=\"listingblock\"><div class=\"content\"><pre class=\"prettyprint highlight\"><code class=\"language-java\" data-lang=\"java\">@Configuration<br />public class TwitterCrawlerConfig {<br /><br />  @Bean<br />  Queue follows() {<br />      return new Queue(\"twitter.follows\", true, false, false);<br />  }<br /><br />  @Bean<br />  Queue followers() {<br />      return new Queue(\"twitter.followers\", true, false, false);<br />  }<br />...</code></pre></div></div></div></div><div class=\"paragraph\"><p>We&#8217;ll now create our RabbitMQ listeners for the two queues. The code snippet below uses the <code>@RabbitListener</code> annotation to indicate that the <code>followers(String message)</code> method should process messages that arrive to the <code>twitter.followers</code> queue on the active RabbitMQ connection.</p></div><div class=\"exampleblock\"><div class=\"title\">Example 11. <a href=\"https://github.com/kbastani/spring-boot-graph-processing-example/blob/master/twitter-rank-crawler/src/main/java/org/kbastani/message/Receiver.java#L59\" target=\"_blank\">Receiver.java</a></div><div class=\"content\"><div class=\"listingblock\"><div class=\"content\"><pre class=\"prettyprint highlight\"><code class=\"language-java\" data-lang=\"java\">@RabbitListener(queues = {\"twitter.followers\"})<br />public void followers(String message) throws InterruptedException, IOException {<br />  User user = objectMapper.readValue(message, User.class);<br /><br />  if (user != null) {<br />    try {<br />      // Get the first cursor of followers for the user<br />      CursoredList&lt;Long&gt; followers = twitter.friendOperations()<br />          .getFollowerIds(user.getProfileId());<br /><br />      // Import the users to Neo4j<br />      saveFollowers(user, followers);<br /><br />      // Now import the users that the profile is following<br />      amqpTemplate.convertAndSend(\"twitter.follows\", objectMapper.writeValueAsString(user));<br /><br />    } catch (RateLimitExceededException rateLimitException) {<br /><br />      // We exceeded the rate limit, redeliver the message to retry after 40 seconds<br />      Thread.sleep(40000L);<br />      throw new AmqpIllegalStateException(rateLimitException.getMessage());<br />      ...<br />    }<br />  }<br />}</code></pre></div></div></div></div><div class=\"paragraph\"><p>We&#8217;ll create a similar listener to the one that is shown in the snippet above for the <code>twitter.follows</code> queue. To see both of these methods in full, head over to the source code repository for the sample application.</p></div><div class=\"admonitionblock note\"><table><tr><td class=\"icon\"><i class=\"fa icon-note\" title=\"Note\"></i></td><td class=\"content\">The reason why we need separate queues for each resource is to prevent wasting API requests if a failure occurs. Since the API resources for \"followers\" and \"friends\" have separate rate limiting policies, we could end up wasting duplicate API requests on the first resource if we encountered a fault during operations on the second resource. </td></tr></table></div></div></div><div class=\"sect1\"><h2 id=\"_scheduling_new_pagerank_jobs\">Scheduling new PageRank jobs</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p>The last concern we need to address on our <em>Twitter Crawler</em> service is to integrate with the graph processing platform. The graph processing platform is an attached backing service on Neo4j, which makes it easy for us to issue requests for new graph processing jobs. Neo4j exposes an endpoint to an unmanaged extension for Mazerunner on the classpath of the Neo4j database server. This unmanaged extension exposes a REST API for interacting with the graph processing platform&#8217;s analysis service that embeds an instance of Apache Spark.</p></div><div class=\"paragraph\"><p>It&#8217;s easy enough to make an HTTP GET request to the job scheduling interface on Neo4j, but we will still need to create a trigger that will be called on a scheduled time interval from the <em>Twitter Crawler</em> service. To do this, we can use the <code>@Scheduled</code> <a href=\"http://docs.spring.io/spring/docs/current/spring-framework-reference/html/scheduling.html#scheduling-annotation-support-scheduled\" target=\"_blank\">annotation on a method</a> of an object in our Spring Boot application. We&#8217;ll then provide a fixed value for the rate parameter of the annotation that is measured in milliseconds. I&#8217;ve decided that the PageRank job should be started about every 5 minutes, so we&#8217;ll initialize the <code>fixedRate</code> value to <code>300000</code> milliseconds.</p></div><div class=\"paragraph\"><p>The snippet of code below is an example of how we will register a method using Spring&#8217;s <code>@Scheduled</code> annotation. The method issues an HTTP GET request to the job scheduling interface&#8217;s REST API, which resides on Neo4j.</p></div><div class=\"exampleblock\"><div class=\"title\">Example 12. <a href=\"https://github.com/kbastani/spring-boot-graph-processing-example/blob/master/twitter-rank-crawler/src/main/java/org/kbastani/scheduling/AnalyticsScheduler.java#L47\" target=\"_blank\">AnalyticsScheduler.java</a></div><div class=\"content\"><div class=\"listingblock\"><div class=\"content\"><pre class=\"prettyprint highlight\"><code class=\"language-java\" data-lang=\"java\">@Scheduled(fixedRate = 300000) <i class=\"conum\" data-value=\"1\"></i><b>(1)</b><br />public void schedulePageRank() {<br /><br />  // Schedule a PageRank job for the Twitter follower graph in Neo4j<br />  String relativePath = \"%s/service/mazerunner/analysis/pagerank/FOLLOWS\"<br />  String analysisEndpoint = String.format(relativePath, neo4jServer.url());<br /><br />  // Make a HTTP GET request to the analysis endpoint<br />  new RestTemplate().getForEntity(analysisEndpoint, null);<br /><br />  logger.info(\"PageRank scheduled on follows graph \" + dateFormat.format(new Date()));<br />}</code></pre></div></div><div class=\"colist arabic\"><table><tr><td><i class=\"conum\" data-value=\"1\"></i><b>1</b></td><td>The <code>@Scheduled</code> annotation registers this method to be called every 5 minutes</td></tr></table></div></div></div><div class=\"paragraph\"><p>Now that we know how to schedule operations using the <code>@Scheduled</code> annotation, we can use the same pattern above to create a reoccurring job to discover new users to import.</p></div><div class=\"exampleblock\"><div class=\"title\">Example 13. <a href=\"https://github.com/kbastani/spring-boot-graph-processing-example/blob/master/twitter-rank-crawler/src/main/java/org/kbastani/scheduling/AnalyticsScheduler.java\" target=\"_blank\">AnalyticsScheduler.java</a></div><div class=\"content\"><div class=\"listingblock\"><div class=\"content\"><pre class=\"prettyprint highlight\"><code class=\"language-java\" data-lang=\"java\">...<br />/**<br /> * Every minute, an attempt to discover a new user to be imported is made. This only succeeds if<br /> * the API is not restricted by a temporary rate limit. This makes sure that only relevant users are<br /> * discovered over time, to keep the API crawling relevant.<br /> */<br />@Scheduled(fixedRate = 60000)<br />public void scheduleDiscoverUser() {<br />  // Only discover users if the rate limit has not been exceeded<br />  if (!rateLimited) {<br />    // Uses PageRank to find the next most important user to import<br />    User user = userRepository.findRankedUserToCrawl();<br /><br />    // If the user is null, the first PageRank hasn't been applied<br />    if (user == null) {<br />      // Uses a mutual follower metric<br />      user = userRepository.findNextUserToCrawl();<br />    }<br /><br />    // If a user has been found, request the user to be imported<br />    if (user != null) {<br />      twitterService.discoverUserByProfileId(user.getProfileId());<br />    }<br />  } else {<br />    rateLimited = false;<br />  }<br /><br />  // Update user rankings for the web dashboard<br />  logger.info(\"Updating last ranks...\");<br />  userRepository.setLastPageRank();<br />  logger.info(\"Updating current rank...\");<br />  userRepository.updateUserCurrentRank();<br />  logger.info(\"Current ranks updated!\");<br />}</code></pre></div></div></div></div></div></div><div class=\"sect1\"><h2 id=\"_discovering_new_users\">Discovering new users</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p>Now we&#8217;ll need to implement a service contract that provides methods for crawling and discovering new Twitter profiles to import to Neo4j. To do this we&#8217;ll provide a REST API endpoint that takes in a Twitter user&#8217;s screen name as input and imports their profile and follower data to Neo4j. We&#8217;ll also need to implement a method for discovering a user using the Twitter <code>profileId</code> as input. When we import a user&#8217;s followers, we are only importing each follower&#8217;s <code>profileId</code>. This is enough for running PageRank on the resulting graph, but to display the user&#8217;s information on the web dashboard, we&#8217;ll need the rest of the profile information.</p></div><div class=\"paragraph\"><p>The <code>TwitterServiceImpl</code> class is shown below in full, and implements methods for <code>discoverUserByScreenName</code> and <code>discoverUserByProfileId</code>.</p></div><div class=\"exampleblock\"><div class=\"title\">Example 14. <a href=\"https://github.com/kbastani/spring-boot-graph-processing-example/blob/master/twitter-rank-crawler/src/main/java/org/kbastani/twitter/TwitterServiceImpl.java\" target=\"_blank\">TwitterServiceImpl.java</a></div><div class=\"content\"><div class=\"listingblock\"><div class=\"content\"><pre class=\"prettyprint highlight\"><code class=\"language-java\" data-lang=\"java\">...<br />/**<br /> * This class implements the service contract for {@link TwitterService} and<br /> * is responsible for discovering users by screen name or profile ID.<br /> *<br /> * @author kbastani<br /> */<br />@Service<br />public class TwitterServiceImpl implements TwitterService {<br /><br />  private static final SimpleDateFormat dateFormat = new SimpleDateFormat(\"HH:mm:ss\");<br />  private final Log log = LogFactory.getLog(TwitterService.class);<br />  private static final String QUEUE_NAME = \"twitter.followers\";<br />  private final Twitter twitter;<br />  private final UserRepository userRepository;<br />  private final RabbitTemplate rabbitTemplate;<br />  private final ObjectMapper objectMapper;<br /><br />  // These two fields are constants that target users below follows/following thresholds<br />  private static final Integer MAX_FOLLOWS = 50000;<br />  private static final Integer MAX_FOLLOWERS = 50000;<br /><br />  @Autowired<br />  public TwitterServiceImpl(Twitter twitter, UserRepository userRepository,<br />    RabbitTemplate rabbitTemplate, ObjectMapper objectMapper) {<br />    this.twitter = twitter;<br />    this.userRepository = userRepository;<br />    this.rabbitTemplate = rabbitTemplate;<br />    this.objectMapper = objectMapper;<br />  }<br /><br />  /**<br />   * Discover a user on Twitter using only their screen name<br />   *<br />   * @param screenName is the screen name of the user on Twitter<br />   * @return a user that has been retrieved from the Twitter API and saved to Neo4j<br />   */<br />  public User discoverUserByScreenName(String screenName) {<br />    User user;<br /><br />    user = Optional.of(twitter.userOperations().getUserProfile(screenName))<br />        .map(User::new)<br />        .get();<br /><br />    // Set the user's default values<br />    user.setPagerank(0f);<br />    user.setImported(true);<br /><br />    user = getUser(user);<br /><br />    return user;<br />  }<br /><br />  /**<br />   * Discover a user on Twitter using their profile ID<br />   *<br />   * @param profileId is the profile ID of the user on the Twitter API<br />   * @return a user that has been retrieved from the Twitter API and saved to Neo4j<br />   */<br />  public User discoverUserByProfileId(Long profileId) {<br />    User user;<br /><br />    user = Optional.of(twitter.userOperations().getUserProfile(profileId))<br />        .map(User::new)<br />        .get();<br /><br />    user = getUser(user);<br /><br />    log.info(String.format(\"Discover user: %s\", user.getScreenName()));<br /><br />    return user;<br />  }<br /><br />  /**<br />   * Submit a job to crawl this user only if their follows/follower counts are within limits<br />   *<br />   * @param user is the {@link User} that is to potentially be requested for crawling<br />   * @return the saved {@link User} with full profile information now updated on the Neo4j node<br />   */<br />  private User getUser(User user) {<br />    Long userId = userRepository.getUserIdByProfileId(user.getProfileId());<br /><br />    if (userId != null) {<br />      user.setId(userId);<br />    }<br /><br />    user = userRepository.save(user, 0);<br /><br />    try {<br />      // Only crawl users that have manageable follows/follower counts<br />      if (user.getFollowerCount() &lt; MAX_FOLLOWERS &amp;&amp; user.getFollowsCount() &lt; MAX_FOLLOWS) {<br />        log.info(\"Discover user scheduled on follows graph \" + dateFormat.format(new Date()));<br />        user.setDiscoveredTime(new Date().getTime());<br /><br />        // Update discovery time<br />        userRepository.save(user, 0);<br /><br />        // Update the discovery chain<br />        userRepository.updateDiscoveryChain();<br /><br />        // Send a new import message to the 'twitter.followers' queue for the user<br />        rabbitTemplate.convertAndSend(QUEUE_NAME, objectMapper.writeValueAsString(user));<br />      } else {<br />        // Retry on a user with a valid number of follows/followers<br />        User nextUserToCrawl = userRepository.findNextUserToCrawl();<br /><br />        if (nextUserToCrawl != null) {<br />          this.discoverUserByProfileId(nextUserToCrawl.getProfileId());<br />        }<br />      }<br />    } catch (JsonProcessingException e) {<br />      log.error(e);<br />    }<br />    return user;<br />  }<br />}</code></pre></div></div></div></div><div class=\"paragraph\"><p>The last thing we&#8217;ll need to do is to expose the <code>discoverUserByScreenName</code> from the <code>TwitterService</code> as a REST API method to allow the web dashboard to add seed profiles. Below, I&#8217;ve created a <code>@RestController</code> annotated class with the name <code>ApiController</code>. This controller will be registered at runtime and allow consumers to issue <code>GET</code> requests to the URL template <code>/v1/user/{screenName}</code>, where <code>screenName</code> is the Twitter profile&#8217;s unique handle.</p></div><div class=\"exampleblock\"><div class=\"title\">Example 15. <a href=\"https://github.com/kbastani/spring-boot-graph-processing-example/blob/master/twitter-rank-crawler/src/main/java/org/kbastani/web/ApiController.java\" target=\"_blank\">ApiController.java</a></div><div class=\"content\"><div class=\"listingblock\"><div class=\"content\"><pre class=\"prettyprint highlight\"><code class=\"language-java\" data-lang=\"java\">...<br />/**<br /> * Provides a single REST endpoint for seeding users to crawl on Twitter. Automated<br /> * crawling of Twitter users requires three seed users as input.<br /> *<br /> * @author kbastani<br /> */<br />@RestController<br />@RequestMapping(\"v1\")<br />public class ApiController {<br /><br />  private final TwitterService twitterService;<br /><br />  @Autowired<br />  public ApiController(TwitterService twitterService) {<br />    this.twitterService = twitterService;<br />  }<br /><br />  @RequestMapping(path = \"user/{screenName}\", method = RequestMethod.GET)<br />  public ResponseEntity&lt;User&gt; discoverProfileByScreenName(@PathVariable(\"screenName\") String screenName) {<br />    return Optional.of(ResponseEntity.ok(twitterService.discoverUserByScreenName(screenName)))<br />        .or(new ResponseEntity&lt;&gt;(HttpStatus.INTERNAL_SERVER_ERROR));<br />  }<br />}</code></pre></div></div></div></div></div></div><div class=\"sect1\"><h2 id=\"_registering_as_a_discovery_client_with_eureka\">Registering as a discovery client with Eureka</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p>Now that we&#8217;re done with the core business logic of the <em>Twitter Crawler</em> service, we need to think about making it operational. I&#8217;ve introduced <a href=\"http://www.kennybastani.com/search/label/spring%20cloud\" target=\"_blank\">Spring Cloud in previous articles</a>, and we&#8217;ll use it here in the form of a <a href=\"http://cloud.spring.io/spring-cloud-netflix/spring-cloud-netflix.html#_registering_with_eureka\" target=\"_blank\">Eureka discovery service</a>.</p></div><div class=\"paragraph\"><p>The discovery service is a critical part of a microservice architecture. Eureka acts as a registry of service information that can be downloaded by members in a cluster and used for client-side load balancing, or <a href=\"http://projects.spring.io/spring-cloud/spring-cloud.html#_environment_changes\" target=\"_blank\">pushing live configuration changes</a> to all instances of a service that are running in a cluster.</p></div><div class=\"exampleblock\"><div class=\"title\">Example 16. <a href=\"https://github.com/kbastani/spring-boot-graph-processing-example/blob/master/twitter-rank-crawler/src/main/java/org/kbastani/TwitterAnalyticsApplication.java\" target=\"_blank\">TwitterCrawlerApplication.java</a></div><div class=\"content\"><div class=\"listingblock\"><div class=\"content\"><pre class=\"prettyprint highlight\"><code class=\"language-java\" data-lang=\"java\">@SpringCloudApplication <i class=\"conum\" data-value=\"1\"></i><b>(1)</b><br />@EnableZuulProxy <i class=\"conum\" data-value=\"2\"></i><b>(2)</b><br />@EnableScheduling <i class=\"conum\" data-value=\"3\"></i><b>(3)</b><br />public class TwitterCrawlerApplication extends SpringBootServletInitializer {<br />    public static void main(String[] args) {<br />        new SpringApplicationBuilder(TwitterCrawlerApplication.class).web(true).run(args);<br />    }<br />}</code></pre></div></div><div class=\"colist arabic\"><table><tr><td><i class=\"conum\" data-value=\"1\"></i><b>1</b></td><td>Adds <code>@SpringBootApplication</code>, <code>@DiscoveryClient</code>, and <code>@CircuitBreaker</code> annotations</td></tr><tr><td><i class=\"conum\" data-value=\"2\"></i><b>2</b></td><td>Enables reverse proxying capabilities to route HTTP requests from other services</td></tr><tr><td><i class=\"conum\" data-value=\"3\"></i><b>3</b></td><td>Enables scheduling, making sure <code>@Scheduler</code> annotations are registered</td></tr></table></div></div></div></div></div><h1 id=\"_ranking_dashboard\" class=\"sect0\">Ranking Dashboard</h1><div class=\"paragraph\"><p>We&#8217;ve finished creating the backend components of the microservice architecture and can now write a simple client-side web application to interface with the <em>Twitter Crawler</em> service&#8217;s REST API. Since we are using <em>Spring Cloud</em>, we are able to take advantage of the <em>Eureka</em> discovery service and the <code>@EnableZuulProxy</code> annotation to automatically inject routes from the <em>Twitter Crawler</em> service into our new <em>Ranking Dashboard</em> service. What this means is that the new <em>Ranking Dashboard</em> service will be able to expose the full REST API of the <em>Twitter Crawler</em> service on its own host, without writing a single line of code.</p></div><div class=\"sect1\"><h2 id=\"_configuring_the_ranking_dashboard_for_reverse_proxy\">Configuring the Ranking Dashboard for reverse proxy</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p>The Spring Boot application we&#8217;ll create is as simple as it gets. The only application code we&#8217;ll create is the Spring Boot application class, shown below.</p></div><div class=\"exampleblock\"><div class=\"title\">Example 17. <a href=\"https://github.com/kbastani/spring-boot-graph-processing-example/blob/master/twitter-rank-web/src/main/java/org/kbastani/RankingDashboardApplication.java\" target=\"_blank\">RankingDashboardApplication.java</a></div><div class=\"content\"><div class=\"listingblock\"><div class=\"content\"><pre class=\"prettyprint highlight\"><code class=\"language-java\" data-lang=\"java\">@SpringCloudApplication<br />@EnableZuulProxy<br />public class RankingDashboardApplication {<br />  public static void main(String[] args) {<br />    SpringApplication.run(RankingDashboardApplication.class, args);<br />  }<br />}</code></pre></div></div></div></div><div class=\"paragraph\"><p>Here we&#8217;ve provided the annotations <code>@SpringCloudApplication</code>, which enables the basic Spring Cloud features for connecting to a discovery service. We&#8217;ve also added the annotation <code>@EnableZuulProxy</code>, which will enable an embedded Zuul proxy in this service. To get this to work, we do need to worry about some configuration properties in our <code>application.yml</code> file.</p></div><div class=\"paragraph\"><p>The properties below are configured for the <em>production</em> Spring profile and provides the necessary settings to connect and register with the discovery service. Since the <em>Twitter Crawler</em> service we created earlier uses the same discovery service connection settings, the <em>Ranking Dashboard</em> will automatically create a proxy to the <em>Twitter Crawler&#8217;s</em> REST API.</p></div><div class=\"exampleblock\"><div class=\"title\">Example 18. <a href=\"https://github.com/kbastani/spring-boot-graph-processing-example/blob/master/twitter-rank-web/src/main/resources/application.yml\" target=\"_blank\">application.yml</a></div><div class=\"content\"><div class=\"listingblock\"><div class=\"content\"><pre class=\"prettyprint highlight\"><code class=\"language-yaml\" data-lang=\"yaml\">spring.profiles.active: 'production'<br />---<br />server:<br />  port: 8081<br />  servletPath: /<br />spring:<br />  profiles: 'production'<br />eureka:<br />  client:<br />    serviceUrl:<br />      defaultZone: http://discovery:8761/eureka/<br />  instance:<br />    preferIpAddress: true<br />    leaseRenewalIntervalInSeconds: 10<br />    hostname: ${spring.cloud.client.ipAddress:HOSTNAME}<br />    statusPageUrlPath: /info<br />    healthCheckUrlPath: /health<br />hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds: 60000<br />ribbon:<br />  ConnectTimeout: 3000<br />  ReadTimeout: 60000</code></pre></div></div></div></div><div class=\"paragraph\"><p>Now when the <em>Ranking Dashboard</em> service is started, it will contact the <em>Eureka</em> discovery service at <code><a href=\"http://discovery:8761/eureka/\" class=\"bare\">http://discovery:8761/eureka/</a></code> and embed the request mappings that are exposed by the <em>Twitter Crawler</em> service. The ID that the <em>Twitter Crawler</em> service will use when registering with <em>Eureka</em> will be <code>twitter-rank</code>. This ID will be used as the request path to access the routes of the <em>Twitter Crawler</em> service from the <em>Ranking Dashboard</em> service. All requests to <code>/twitter-rank/**</code> on the <em>Ranking Dashboard</em> service will be forwarded to the <em>Twitter Crawler</em> service.</p></div><div class=\"paragraph\"><p>The next step will be to add static web content to the <em>Ranking Dashboard</em> service that connects to the REST API of the <em>Twitter Crawler</em> service through our newly embedded Zuul proxy.</p></div></div></div><div class=\"sect1\"><h2 id=\"_adding_static_web_content\">Adding static web content</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p>I&#8217;ve created a simple client-side web application that uses jQuery to make AJAX requests to the <em>Twitter Crawler</em> REST API. Spring Boot makes it easy to map static content by placing it in the resource directory under <code>resources/static</code>. The example below shows a directory tree of the <em>Ranking Dashboard</em> service and the static content I&#8217;ve placed in the resource directory.</p></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"prettyprint highlight\"><code class=\"language-text\" data-lang=\"text\">├── docker<br />│   └── Dockerfile<br />├── java<br />│   └── org<br />│       └── kbastani<br />└── resources<br />    ├── application.yml<br />    ├── bootstrap.yml<br />    └── static<br />        ├── assets<br />        ├── css<br />        ├── dist<br />        ├── fonts<br />        ├── index.html<br />        └── js</code></pre></div></div><div class=\"paragraph\"><p>Now when I run the Spring Boot application, the <code>src/main/resources/static/index.html</code> file will be mapped to the service&#8217;s root at <code>/</code>, or accessed directly at <code>/index.html</code>.</p></div></div></div><div class=\"sect1\"><h2 id=\"_consuming_the_twitter_crawler_s_rest_api\">Consuming the Twitter Crawler&#8217;s REST API</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p>The dashboard is a single page web application which consumes two REST API methods on the <em>Twitter Crawler</em> service. Let&#8217;s first review how the dashboard will be used.</p></div><div class=\"paragraph\"><p>The first time the dashboard is loaded, there won&#8217;t be any data to display from the <em>Twitter Crawler</em> service.</p></div><div class=\"exampleblock\"><div class=\"content\"><div class=\"imageblock\" style=\"display: block;\"><div class=\"content\" style=\"text-align: center;\"><img width=\"100%\" alt=\"Twitter discovery dashboard\" src=\"http://i.imgur.com/Zli5V4u.png\" style=\"max-height: 25em; margin: auto !important;\"></div></div></div></div><div class=\"paragraph\"><p>Before the <em>Twitter Crawler</em> service will begin to automatically discover new profiles, the user must provide a minimum of three screen names of Twitter users as seeds. The goal is to add three seed profiles of users who are members of a community on Twitter. It&#8217;s important to make sure that these users follow each other, which will make it likely that there are other mutual profile connections between these users.</p></div><div class=\"exampleblock\"><div class=\"content\"><div class=\"imageblock\" style=\"display: block;\"><div class=\"content\" style=\"text-align: center;\"><img width=\"100%\" alt=\"Add new Twitter profile to crawl\" src=\"http://i.imgur.com/XhWkJNd.png\" style=\"max-height: 25em; margin: auto !important;\"></div></div></div></div><div class=\"paragraph\"><p>The seed profiles I&#8217;ve chosen for this demonstration are:</p></div><div class=\"ulist\"><ul><li><p><a href=\"http://www.twitter.com/kennybastani\">@kennybastani</a></p></li><li><p><a href=\"http://www.twitter.com/starbuxman\">@starbuxman</a></p></li><li><p><a href=\"http://www.twitter.com/bridgetkromhout\">@bridgetkromhout</a></p></li></ul></div><div class=\"paragraph\"><p>When adding new seed profiles through the UI, an AJAX call will be made as an HTTP GET request to the relative path:</p></div><div class=\"paragraph\"><p><code>/twitter-rank/v1/user/{screenName}</code></p></div><div class=\"paragraph\"><p>After adding each of these profiles manually through the UI, we&#8217;ll end up with the following view.</p></div><div class=\"exampleblock\"><div class=\"content\"><div class=\"imageblock\" style=\"display: block;\"><div class=\"content\" style=\"text-align: center;\"><img width=\"100%\" alt=\"PageRank on Twitter profile followers\" src=\"http://i.imgur.com/dePUme2.png\" style=\"max-height: 35em; margin: auto !important;\"></div></div></div></div><div class=\"paragraph\"><p>To get the results that are displayed in the ranking table, the UI will make an AJAX call as an HTTP GET request to the relative path:</p></div><div class=\"paragraph\"><p><code>/twitter-rank/users/search/findRankedUsers?skip=0&amp;limit=100</code></p></div><div class=\"paragraph\"><p>Now that I&#8217;ve added the three seed profiles, each of these user&#8217;s connections will be imported to Neo4j on the <em>Twitter Crawler</em> service. After about 5 minutes, the PageRank job will have been scheduled and completed its analysis of the initial users. After a PageRank value has been assigned to the initial users, you will begin to see other users that the crawling algorithm on the <em>Twitter Crawler</em> service has automatically discovered.</p></div><div class=\"paragraph\"><p>The following screenshot shows users that were discovered automatically by the <em>Twitter Crawler</em> service.</p></div><div class=\"exampleblock\"><div class=\"content\"><div class=\"imageblock\" style=\"display: block;\"><div class=\"content\" style=\"text-align: center;\"><img width=\"100%\" alt=\"Automated discovery of new Twitter profiles\" src=\"http://i.imgur.com/5TjfNj2.png\" style=\"max-height: 35em; margin: auto !important;\"></div></div></div></div></div></div><h1 id=\"_docker_demo\" class=\"sect0\">Docker Demo</h1><div class=\"paragraph\"><p>The example project uses Docker to build a container image of each of our microservices as a part of the Maven build process.</p></div><div class=\"sect1\"><h2 id=\"_getting_started\">Getting Started</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p>To get started, visit the GitHub repository for this example project.</p></div><div class=\"exampleblock\"><div class=\"content\"><div class=\"paragraph\"><p><a href=\"https://github.com/kbastani/spring-boot-graph-processing-example\" target=\"_blank\">https://github.com/kbastani/spring-boot-graph-processing-example</a></p></div></div></div><div class=\"paragraph\"><p>Clone or fork the project and download the repository to your machine. After downloading, you will need to use both Maven and Docker to compile and build the images locally.</p></div></div></div><div class=\"sect1\"><h2 id=\"_download_docker\">Download Docker</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p>First, download Docker if you haven’t already. Follow the <a href=\"https://www.docker.com/docker-toolbox\" target=\"_blank\">instructions found here</a>, to get Docker toolbox up and running on your development machine.</p></div><div class=\"paragraph\"><p>After you&#8217;ve installed Docker toolbox, run the following command to initialize a new virtualbox VM for this sample application.</p></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"prettyprint highlight\"><code class=\"language-bash\" data-lang=\"bash\">$ docker-machine create twitter-demo --driver virtualbox --virtualbox-memory \"11000\" --virtualbox-disk-size \"100000\"<br />$ eval \"$(docker-machine env twitter-demo)\"</code></pre></div></div></div></div><div class=\"sect1\"><h2 id=\"_requirements\">Requirements</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p>The requirements for running this demo on your machine are found below.</p></div><div class=\"ulist\"><ul><li><p>Maven 3</p></li><li><p>Java 8</p></li><li><p>Docker</p></li><li><p>Docker Compose</p></li></ul></div><div class=\"sect2\"><h3 id=\"_building_the_project\">Building the project</h3><div class=\"paragraph\"><p>To build the project, from the terminal, run the following command at the root of the project.</p></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"prettyprint highlight\"><code class=\"language-bash\" data-lang=\"bash\">$ mvn clean install</code></pre></div></div><div class=\"paragraph\"><p>The project will then download all of the needed dependencies and compile each of the project artifacts. Each service will be built, and then a Maven Docker plugin will automatically build each of the images into your local Docker registry. Docker must be running and available from the command line where you run the <code>mvn clean install</code> command for the build to succeed.</p></div></div></div></div><div class=\"sect1\"><h2 id=\"_start_the_cluster_with_docker_compose\">Start the Cluster with Docker Compose</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p>Now that each of the images has been built successfully, we can use Docker Compose to spin up our cluster. I&#8217;ve put together a Docker Compose file that will allow you to run the full sample application without needing to run the build. Before being able to run the application, you must provide your Twitter API credentials.</p></div><div class=\"exampleblock\"><div class=\"title\">Example 19. <a href=\"https://github.com/kbastani/spring-boot-graph-processing-example/blob/master/docker-compose.yml\" target=\"_blank\">docker-compose.yml</a></div><div class=\"content\"><div class=\"listingblock\"><div class=\"content\"><pre class=\"prettyprint highlight\"><code class=\"language-yaml\" data-lang=\"yaml\">---<br />twitter-rank-crawler:<br />  image: kbastani/twitter-rank-crawler:latest<br />  ports:<br />   - '8080:8080'<br />  links:<br />   - config<br />   - discovery<br />   - rabbit<br />   - graphdb<br />  environment:<br />    SPRING_SOCIAL_TWITTER_ACCESSTOKENSECRET: 'REPLACE'<br />    SPRING_SOCIAL_TWITTER_ACCESSTOKEN: 'REPLACE'<br />    SPRING_SOCIAL_TWITTER_APPSECRET: 'REPLACE'<br />    SPRING_SOCIAL_TWITTER_APPID: 'REPLACE'<br />    SPRING_PROFILES_ACTIVE: 'production'</code></pre></div></div></div></div><div class=\"admonitionblock caution\"><table><tr><td class=\"icon\"><i class=\"fa icon-caution\" title=\"Caution\"></i></td><td class=\"content\">Make sure that you replace the environment values in the Docker Compose file with your own Twitter API keys and access tokens. Also, I highly recommend that you run this sample on a machine with at least 16GB of system memory. </td></tr></table></div><div class=\"paragraph\"><p>Once you have modified the <code>docker-compose.yml</code> file in the project root, navigate to the <code>spring-boot-graph-processing-example/</code> directory in your console.</p></div><div class=\"paragraph\"><p>To startup the cluster in detached mode, run the following command:</p></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"prettyprint highlight\"><code class=\"language-bash\" data-lang=\"bash\">$ docker-compose up -d</code></pre></div></div><div class=\"paragraph\"><p>If everything is configured correctly, each of the container images we built earlier will be launched within their own VM container on Docker and networked for automatic service discovery. You will see a flurry of log output from each of the services as they begin their startup sequence. This might take a few minutes to complete, depending on the performance of the machine you’re running this demo on.</p></div><div class=\"paragraph\"><p>To see the log output from the cluster, you can run the following command.</p></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"prettyprint highlight\"><code class=\"language-bash\" data-lang=\"bash\">$ docker-compose logs</code></pre></div></div><div class=\"paragraph\"><p>Once the startup sequence is completed, you can navigate to the Eureka host and see which services have registered with the discovery service.</p></div><div class=\"paragraph\"><p>Copy and paste the following command into the terminal where Docker can be accessed using the <code>$DOCKER_HOST</code> environment variable.</p></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"prettyprint highlight\"><code class=\"language-bash\" data-lang=\"bash\">$ open $(echo \\\"$(echo $DOCKER_HOST)\\\"|<br />            \\sed 's/tcp:\\/\\//http:\\/\\//g'|<br />            \\sed 's/[0-9]\\{4,\\}/8761/g'|<br />            \\sed 's/\\\"//g')</code></pre></div></div><div class=\"paragraph\"><p>When the user interface successfully loads for Eureka, you&#8217;ll see the list of services that have registered as a Eureka client instance.</p></div><div class=\"exampleblock\"><div class=\"content\"><div class=\"imageblock\" style=\"display: block;\"><div class=\"content\" style=\"text-align: center;\"><img width=\"100%\" alt=\"Eureka discovery service UI\" src=\"http://i.imgur.com/AaEz9hI.png\" style=\"max-height: 35em; margin: auto !important;\"></div></div></div></div></div></div><h1 id=\"_conclusion\" class=\"sect0\">Conclusion</h1><div class=\"paragraph\"><p>In this article we built a ranking engine and crawler for discovering influential Twitter profiles. As a part of this article we covered the following Spring concepts:</p></div><div class=\"ulist\"><ul><li><p>Spring Data Neo4j</p></li><li><p>Spring Social Twitter</p></li><li><p>Spring Boot: Schedulers</p></li><li><p>Spring Boot: AMQP</p></li><li><p>Spring Cloud: Eureka client registration</p></li><li><p>Spring Cloud: Zuul Reverse Proxy</p></li></ul></div><div class=\"paragraph\"><p>We covered a lot of ground in this one! This sample project is near and dear to my heart. I hope that this article showed you how incredibly simple Spring Boot makes developing these kinds of architectures. While there are some missing pieces, such as securing REST API access, and mapping device volumes to the containers, these kinds of important topics will be covered in future articles.</p></div><div class=\"paragraph\"><p>Please feel free to leave your questions and comments below.</p></div><div class=\"paragraph\"><p>If you found this article useful, please share it on Twitter&#8201;&#8212;&#8201;preferably with the influencers that you discover using the sample application!</p></div></div>",
  "link": "https://www.kennybastani.com/2016/01/spring-boot-graph-processing-microservices.html",
  "author": "noreply@blogger.com (Kenny Bastani)",
  "media:thumbnail": "",
  "thr:total": 0
}