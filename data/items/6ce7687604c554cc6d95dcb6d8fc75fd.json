{
  "title": "Exploring Performance Monitoring Data with Multivariate Tools: SVD and PCA",
  "description": "<p>Most methods that were presented here so far are dealing with a single time series (performance metric) at a time. Now I’d like to make a quick overview of methods which allow to glance over a whole collection of time series at once.</p>\n\n<p>Data used here was gathered during a load test of an application which consists of several components: http server, messaging server (<a href=\"http://www.rabbitmq.com/\">RabbitMQ</a>), database (<a href=\"http://cassandra.apache.org/\">Cassandra</a>). That application uses 5 hosts and number of system metrics + application metrics is about 3300 after filtering (~32000 before). Think of it as a number of graphs to get through while exploring results of the test.</p>\n\n<p>The load applied to the http server looks like this (number of identical clients sending requests):</p>\n\n<p><img src=\"https://mabrek.github.io/img/multivariate/jmeter-threads.png\" alt=\"connected clients\" /></p>\n\n<p>The idea behind the table hill shape of the load is that the upwards slope shows when the system breaks (how it scales), flat top shows how stable it is (if it didn’t break on upwards slope), and the downwards slope shows how it recovers.</p>\n\n<p>The service didn’t do very well this time. Here is a plot of successful and error response rates:</p>\n\n<p><img src=\"https://mabrek.github.io/img/multivariate/request-error-rates.png\" alt=\"request and error rates\" /></p>\n\n<p>And response latencies:</p>\n\n<p><img src=\"https://mabrek.github.io/img/multivariate/latencies.png\" alt=\"latencies\" /></p>\n\n<p>Error rate is not zero and 99th percentile of response latency has spikes close to allowed by SLA maximum. At least it recovered and continued to serve requests at a lower rate.</p>\n\n<p>Here’s what a result of <a href=\"https://en.wikipedia.org/wiki/Singular_value_decomposition\">SVD (Singular Value Decomposition)</a> looks like (left-singular vectors sorted by decreasing singular values):</p>\n\n<p><img src=\"https://mabrek.github.io/img/multivariate/svd-u.png\" alt=\"svd left singular\" /></p>\n\n<p>In time series context SVD decomposes original set of series into set of uncorrelated base series (left-singular vectors), set of singular values, and a matrix of weights (right-singular vectors). These matrices could be used to reconstruct the original set of series. The nice feature is that you can take only several base series corresponding to the top singular values to get quite good (in terms of squared error) reconstruction result.</p>\n\n<p><img src=\"https://mabrek.github.io/img/multivariate/svd-d.png\" alt=\"singular values sorted by decreasing value\" /></p>\n\n<p>First 6 singular values (sorted by decreasing value) contribute most and the rest is a background noise.</p>\n\n<p>When the data is centered (mean subtracted) and scaled (divided by standard deviation) before applying SVD then the top (by singular values) base series represent the most common shapes in the data with some caveats. Sometimes it can change sign (flip shape vertically) or mix several common shapes into one. Outliers distort extracted base series due to the scaling used and the least-squares nature of the decomposition (which amplifies outliers).</p>\n\n<p>In this case the first extracted series is a slightly skewed table hill shape of the load applied because most metrics follow that pattern. A lot of metrics comes from Cassandra which uses <a href=\"http://metrics.dropwizard.io/3.1.0/manual/core/#exponentially-decaying-reservoirs\">exponentially decaying sampling</a> for latencies. This algorithm smoothes and moves the shape to the right (delays signal). The second extracted series corresponds to growing counters and caches. The third series looks like a flipped shape of RabbitMQ disk activity during the test. There are some spikes and drops visible on several base series which corresponds to errors and latency spikes.</p>\n\n<p>Closely related <a href=\"https://en.wikipedia.org/wiki/Principal_component_analysis\">PCA (Principal Component Analysis)</a> produces set of principal components (which are base series from SVD scaled by singular values) and the same weights (loadings) from SVD. Here the first 2 original series selected by maximum absolute loading per each principal component.</p>\n\n<p><img src=\"https://mabrek.github.io/img/multivariate/svd-v.png\" alt=\"top original by right singular vectors\" /></p>\n\n<p>It selects original series which have largest contribution from top components (base series).</p>\n\n<p>These methods are quite fast and produce meaningful results: they extract the most common shapes and group original series by these shapes.</p>\n\n<p>They are sensitive to outliers. The usual way of scaling data (by standard deviation) doesn’t make a lot of sence for long tailed distributions which are quite common in performance monitoring data. It might be a good thing for exploratory data analysis because if you see some spikes or step-like changes in several first base series  then it definitely means some abrupt changes at that time in system being monitored.</p>\n\n<p>I’ve tried to center data by subtracting median and scale by <a href=\"https://en.wikipedia.org/wiki/Median_absolute_deviation\">MAD (Median Absolute Deviation)</a> but discovered that zero MAD is quite common in my data (when it’s mostly constant with a few spikes).</p>\n\n<p>What SVD/PCA are good for: if you have a lots of data, slow anomaly detection algorithm and interested mostly in the time when anomaly happens then running the algorithm on several first principal components might be much faster than feeding it all the original data.</p>",
  "pubDate": "Thu, 20 Aug 2015 00:00:00 +0000",
  "link": "https://mabrek.github.io/blog/multivariate-svd-pca/",
  "guid": "https://mabrek.github.io/blog/multivariate-svd-pca/"
}