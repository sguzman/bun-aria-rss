{
  "title": "Computing the Kalman Filter",
  "link": "",
  "updated": "2012-11-24T00:00:00+00:00",
  "id": "https://mrocklin.github.io/blog/work/2012/11/24/Kalman-Filter",
  "content": "<p>The <a href=\"http://en.wikipedia.org/wiki/Kalman_filter\">Kalman Filter</a> is an algorithm to update probability distributions with new observations made under noisy conditions.  It is used in everything from smartphone GPS navigation systems to large scale climate simulations.  It is implemented in hardware ranging from embedded devices to super-computers.  It is important and widely used.</p>\n\n<p>In this post I will</p>\n\n<ol>\n  <li>Show how to compute the Kalman Filter with BLAS/LAPACK</li>\n  <li>Relate this to old work on <code class=\"language-plaintext highlighter-rouge\">sympy.stats</code></li>\n  <li>Analyze the computation graph for some flaws and features</li>\n</ol>\n\n<h2 id=\"results\">Results</h2>\n\n<p>The Kalman filter can be defined as a pair of matrix expressions</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"c1\"># kalman.py\n</span><span class=\"kn\">from</span> <span class=\"nn\">sympy.matrices.expressions</span> <span class=\"kn\">import</span> <span class=\"n\">MatrixSymbol</span><span class=\"p\">,</span> <span class=\"n\">Identity</span>\n<span class=\"kn\">from</span> <span class=\"nn\">sympy</span> <span class=\"kn\">import</span> <span class=\"n\">Symbol</span><span class=\"p\">,</span> <span class=\"n\">Q</span>\n\n<span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">k</span>    <span class=\"o\">=</span> <span class=\"n\">Symbol</span><span class=\"p\">(</span><span class=\"s\">'n'</span><span class=\"p\">),</span> <span class=\"n\">Symbol</span><span class=\"p\">(</span><span class=\"s\">'k'</span><span class=\"p\">)</span>\n<span class=\"n\">mu</span>      <span class=\"o\">=</span> <span class=\"n\">MatrixSymbol</span><span class=\"p\">(</span><span class=\"s\">'mu'</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"n\">Sigma</span>   <span class=\"o\">=</span> <span class=\"n\">MatrixSymbol</span><span class=\"p\">(</span><span class=\"s\">'Sigma'</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">)</span>\n<span class=\"n\">H</span>       <span class=\"o\">=</span> <span class=\"n\">MatrixSymbol</span><span class=\"p\">(</span><span class=\"s\">'H'</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">)</span>\n<span class=\"n\">R</span>       <span class=\"o\">=</span> <span class=\"n\">MatrixSymbol</span><span class=\"p\">(</span><span class=\"s\">'R'</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">)</span>\n<span class=\"n\">data</span>    <span class=\"o\">=</span> <span class=\"n\">MatrixSymbol</span><span class=\"p\">(</span><span class=\"s\">'data'</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"n\">I</span>       <span class=\"o\">=</span> <span class=\"n\">Identity</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span>\n\n<span class=\"n\">new_mu</span>      <span class=\"o\">=</span> <span class=\"n\">mu</span> <span class=\"o\">+</span> <span class=\"n\">Sigma</span><span class=\"o\">*</span><span class=\"n\">H</span><span class=\"p\">.</span><span class=\"n\">T</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">R</span> <span class=\"o\">+</span> <span class=\"n\">H</span><span class=\"o\">*</span><span class=\"n\">Sigma</span><span class=\"o\">*</span><span class=\"n\">H</span><span class=\"p\">.</span><span class=\"n\">T</span><span class=\"p\">).</span><span class=\"n\">I</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">H</span><span class=\"o\">*</span><span class=\"n\">mu</span> <span class=\"o\">-</span> <span class=\"n\">data</span><span class=\"p\">)</span>\n<span class=\"n\">new_Sigma</span>   <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">I</span> <span class=\"o\">-</span> <span class=\"n\">Sigma</span><span class=\"o\">*</span><span class=\"n\">H</span><span class=\"p\">.</span><span class=\"n\">T</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">R</span> <span class=\"o\">+</span> <span class=\"n\">H</span><span class=\"o\">*</span><span class=\"n\">Sigma</span><span class=\"o\">*</span><span class=\"n\">H</span><span class=\"p\">.</span><span class=\"n\">T</span><span class=\"p\">).</span><span class=\"n\">I</span> <span class=\"o\">*</span> <span class=\"n\">H</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"n\">Sigma</span>\n\n<span class=\"n\">assumptions</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">Q</span><span class=\"p\">.</span><span class=\"n\">positive_definite</span><span class=\"p\">(</span><span class=\"n\">Sigma</span><span class=\"p\">)</span> <span class=\"o\">&amp;</span> <span class=\"n\">Q</span><span class=\"p\">.</span><span class=\"n\">symmetric</span><span class=\"p\">(</span><span class=\"n\">Sigma</span><span class=\"p\">)</span> <span class=\"o\">&amp;</span>\n               <span class=\"n\">Q</span><span class=\"p\">.</span><span class=\"n\">positive_definite</span><span class=\"p\">(</span><span class=\"n\">R</span><span class=\"p\">)</span> <span class=\"o\">&amp;</span> <span class=\"n\">Q</span><span class=\"p\">.</span><span class=\"n\">symmetric</span><span class=\"p\">(</span><span class=\"n\">R</span><span class=\"p\">))</span></code></pre>\n</figure>\n\n<p>We convert these matrix expressions into a computation</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"c1\"># kalman_computation.py\n</span><span class=\"kn\">from</span> <span class=\"nn\">kalman</span> <span class=\"kn\">import</span> <span class=\"n\">new_mu</span><span class=\"p\">,</span> <span class=\"n\">new_Sigma</span><span class=\"p\">,</span> <span class=\"n\">assumptions</span>\n<span class=\"kn\">from</span> <span class=\"nn\">sympy.computations.matrices.compile</span> <span class=\"kn\">import</span> <span class=\"n\">make_rule</span><span class=\"p\">,</span> <span class=\"n\">patterns</span>\n<span class=\"kn\">from</span> <span class=\"nn\">sympy.computations.core</span> <span class=\"kn\">import</span> <span class=\"n\">Identity</span>\n\n<span class=\"n\">ident</span> <span class=\"o\">=</span> <span class=\"n\">Identity</span><span class=\"p\">(</span><span class=\"n\">new_mu</span><span class=\"p\">,</span> <span class=\"n\">new_Sigma</span><span class=\"p\">)</span>\n<span class=\"n\">rule</span> <span class=\"o\">=</span> <span class=\"n\">make_rule</span><span class=\"p\">(</span><span class=\"n\">patterns</span><span class=\"p\">,</span> <span class=\"n\">assumptions</span><span class=\"p\">)</span>\n<span class=\"n\">mathcomp</span> <span class=\"o\">=</span> <span class=\"nb\">next</span><span class=\"p\">(</span><span class=\"n\">rule</span><span class=\"p\">(</span><span class=\"n\">ident</span><span class=\"p\">))</span>\n<span class=\"n\">mathcomp</span><span class=\"p\">.</span><span class=\"n\">show</span><span class=\"p\">()</span></code></pre>\n</figure>\n\n<p><a href=\"https://mrocklin.github.io/blog/images/kalman-math-1.pdf\"><img src=\"https://mrocklin.github.io/blog/images/kalman-math-1.png\" alt=\"\" /></a></p>\n\n<p>This is a useful result.</p>\n\n<h2 id=\"history-with-stats\">History with stats</h2>\n\n<p>Two years ago I wrote two blogposts about the Kalman filter, one on <a href=\"http://sympystats.wordpress.com/2011/07/02/a-lesson-in-data-assimilation-using-sympy/\">the univariate case</a> and one on <a href=\"http://sympystats.wordpress.com/2011/07/19/multivariate-normal-random-variables/\">the multivariate case</a>.  At the time I was working on <code class=\"language-plaintext highlighter-rouge\">sympy.stats</code>, a module that enabled uncertainty modeling through the introduction of a random variables into the SymPy language.</p>\n\n<p>SymPy stats was designed with atomicity in mind.  It tried to be as small and thin a layer as possible.</p>\n\n<ul>\n  <li>It turned queries on continuous random expressions into integral expressions.</li>\n  <li>It turned queries on discrete random expressions into iterators and sums.</li>\n  <li>It also turned queries on multivariate normal random expressions into matrix expressions.</li>\n</ul>\n\n<p>The goal was to turn a specialized problem (uncertainty quantification) into a general one (integrals, sums, matrix expressions) under the assumption that tools are much richer to solve general problems than specific ones.</p>\n\n<p>The first blogpost on the univariate kalman filter produced integral expressions that were then solved by SymPy’s integration routines.  The <a href=\"http://sympystats.wordpress.com/2011/07/19/multivariate-normal-random-variables/\">second blogpost</a> on the multivariate Kalman filter generated the following matrix expressions</p>\n\n<p>\\(\\mu' = \\mu + \\Sigma H^T \\left( R + H \\Sigma H^T \\right )^{-1} \\left(H\\mu - \\textrm{data} \\right)\\)\n\\(\\Sigma' = \\left( \\mathbb{I} - \\Sigma H^T \\left(R + H \\Sigma H^T \\right)^{-1} H \\right) \\Sigma\\)</p>\n\n<p>That blogpost finished with this result, claiming that the job of <code class=\"language-plaintext highlighter-rouge\">sympy.stats</code> was finished and that any of the popular numerical linear algebra packages could pick up from that point.</p>\n\n<p>These two equations are the Kalman filter and were our starting point for today.  Matrix Expressions are an intermediate representation layer between <code class=\"language-plaintext highlighter-rouge\">sympy.stats</code> and <code class=\"language-plaintext highlighter-rouge\">sympy.computations.matrices</code>.</p>\n\n<p>By composing these projects we compile high level statistical expressions of <code class=\"language-plaintext highlighter-rouge\">sympy.stats</code> to intermediate level matrix expressions to the DAGs of <code class=\"language-plaintext highlighter-rouge\">sympy.computations</code> and even down to low level Fortran code.  If we add a traditional Fortran compiler we can build working binaries directly from <code class=\"language-plaintext highlighter-rouge\">sympy.stats</code>.</p>\n\n<h2 id=\"features-and-flaws-in-the-kalman-graph\">Features and Flaws in the Kalman graph</h2>\n\n<p>Lets investigate the Kalman computation.  It contains a few notable features.</p>\n\n<p>First, unlike previous examples it has two outputs, <code class=\"language-plaintext highlighter-rouge\">new_mu</code> and <code class=\"language-plaintext highlighter-rouge\">new_Sigma</code>.  These two have large common subexpressions like <code class=\"language-plaintext highlighter-rouge\">H*Sigma*H' + R</code>.  You can see that these were computed once and shared.</p>\n\n<p>Second, lets appreciate that <code class=\"language-plaintext highlighter-rouge\">H*Sigma*H + R</code> is identified as symmetric positive definite allowing the more efficient <code class=\"language-plaintext highlighter-rouge\">POSV</code> routine.  I’ve brought this up before in artificial examples.  It’s nice to see that this occurs in practice.</p>\n\n<p>Third, there is an unfortunately common motif.  This instance was taken from the upper right of the image but the <code class=\"language-plaintext highlighter-rouge\">GE/SYMM -&gt; AXPY</code> motif occurs four times in this graph.</p>\n\n<p><img src=\"https://mrocklin.github.io/blog/images/kalman-math-gemm-axpy-motif.png\" alt=\"\" /></p>\n\n<p><code class=\"language-plaintext highlighter-rouge\">GEMM/SYMM</code> are matrix multiply operations used to break down expressions like <code class=\"language-plaintext highlighter-rouge\">alpha*A*B</code>.  <code class=\"language-plaintext highlighter-rouge\">AXPY</code> is a matrix addition used to break down expressions like <code class=\"language-plaintext highlighter-rouge\">alpha*A + B</code>.  They are both used properly here.</p>\n\n<p>This motif is unforunate because <code class=\"language-plaintext highlighter-rouge\">GEMM</code> is also capable of breaking down a larger expression like <code class=\"language-plaintext highlighter-rouge\">alpha*A*B + beta*C</code>, doing a fused matrix multiply and add all in one pass.   The <code class=\"language-plaintext highlighter-rouge\">AXPY</code> would be unnecessary if the larger <code class=\"language-plaintext highlighter-rouge\">GE/SYMM</code> patterns had matched correctly.</p>\n\n<h2 id=\"canonicalization\">Canonicalization</h2>\n\n<p>The <code class=\"language-plaintext highlighter-rouge\">alpha*A*B + beta*C</code> patterns did not match here for a silly reason, there wasn’t anything to match for the scalars <code class=\"language-plaintext highlighter-rouge\">alpha</code> and <code class=\"language-plaintext highlighter-rouge\">beta</code>.  Instead the patterns were like <code class=\"language-plaintext highlighter-rouge\">A*B - C</code>.  One solution to this problem is to make more patterns with all possibilities.  Alternatively we could change how we canonicalize <code class=\"language-plaintext highlighter-rouge\">MatMul</code> objects so that they always have a scalar coefficient, even if it defaults to 1.</p>\n\n<p>We don’t want to change <code class=\"language-plaintext highlighter-rouge\">MatMul</code> to behave like this throughout all of SymPy though; the extra 1 is usually unwanted.  This is a case where there are multiple correct definitions of canonical.  Fortunately <code class=\"language-plaintext highlighter-rouge\">MatMul</code> is written with this eventuality in mind.</p>\n\n<h2 id=\"links\">Links</h2>\n\n<ol>\n  <li><a href=\"http://sympystats.wordpress.com/2011/07/02/a-lesson-in-data-assimilation-using-sympy/\">A Lesson in Data Assimilation using SymPy</a></li>\n  <li><a href=\"http://sympystats.wordpress.com/2011/07/19/multivariate-normal-random-variables/\">Multivariate Normal Random Variables</a></li>\n  <li>Source for this post: <a href=\"https://mrocklin.github.io/blog/scripts/kalman.py\">kalman.py</a>, <a href=\"https://mrocklin.github.io/blog/scripts/kalman_comp.py\">kalman_comp.py</a></li>\n</ol>"
}