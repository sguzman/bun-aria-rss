{
  "title": "SymPy and Theano -- Code Generation",
  "link": "",
  "updated": "2013-03-19T00:00:00+00:00",
  "id": "https://mrocklin.github.io/blog/work/2013/03/19/SymPy-Theano-part-1",
  "content": "<p>No one is good at everything, that’s why we have society.</p>\n\n<p>No project is good at everything, that’s why we have interfaces.</p>\n\n<p>This is the first of three posts that join <code class=\"language-plaintext highlighter-rouge\">SymPy</code>, a library for symbolic mathematics, and <code class=\"language-plaintext highlighter-rouge\">Theano</code>, a library for mathematical compilation to numeric code.  Each library does a few things really well.  Each library also over-reaches bit and does a few things not-as-well.  Fortunately the two libraries have clear and simple data structures and so can be used together effectively.</p>\n\n<p>In this post I’ll focus on how SymPy can use Theano to generate efficient code.</p>\n\n<h2 id=\"physics\">Physics</h2>\n\n<p>SymPy knows Physics.  For example, here is the radial wavefunction corresponding to <code class=\"language-plaintext highlighter-rouge\">n = 3</code> and <code class=\"language-plaintext highlighter-rouge\">l = 1</code> for Carbon (<code class=\"language-plaintext highlighter-rouge\">Z = 6</code>)</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>from sympy.physics.hydrogen import R_nl\nfrom sympy.abc import x\nexpr = R_nl(3, 1, x, 6)\nprint latex(expr)\n</code></pre></div></div>\n\n\\[\\frac{8}{3} x \\left(- 4 x + 4\\right) e^{- 2 x}\\]\n\n<p>SymPy is great at this.  It can manipulate high level mathematical expressions very naturally.  When it comes to numeric computation it is less effective.</p>\n\n<h2 id=\"numerics\">Numerics</h2>\n\n<p>Fortunately there are methods to offload the work to numerical projects like <code class=\"language-plaintext highlighter-rouge\">numpy</code> or to generate and compile straight <code class=\"language-plaintext highlighter-rouge\">Fortran</code> code.  Here we use two existing methods to create two identical vectorized functions to compute the above expression.</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>from sympy.utilities.autowrap import ufuncify\nfrom sympy.utilities.lambdify import lambdify\nfn_numpy   = lambdify(x, expr, 'numpy')\nfn_fortran = ufuncify([x], expr)\n</code></pre></div></div>\n\n<p><code class=\"language-plaintext highlighter-rouge\">fn_numpy</code> replaces each of the SymPy operations with the equivalent function from the popular NumPy package.  <code class=\"language-plaintext highlighter-rouge\">fn_fortran</code> generates and compiles low-level Fortran code and uses <code class=\"language-plaintext highlighter-rouge\">f2py</code> to bind it to a Python function.  They each use <code class=\"language-plaintext highlighter-rouge\">numpy</code> arrays as common data structures, supporting broad interoperability with the rest of the Scientific Python ecosystem.  They both work well and produce identical results.</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&gt;&gt;&gt; from numpy import linspace\n&gt;&gt;&gt; xx = linspace(0, 1, 5)\n&gt;&gt;&gt; fn_numpy(xx)\n[ 0.          1.21306132  0.98101184  0.44626032  0.        ]\n&gt;&gt;&gt; fn_fortran(xx)\n[ 0.          1.21306132  0.98101184  0.44626032  0.        ]\n</code></pre></div></div>\n\n<p>We use these functions and <code class=\"language-plaintext highlighter-rouge\">matplotlib</code> to plot the original equation</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>from pylab import plot, show, legend\nxx = linspace(0, 5, 50000)\nplot(xx, fn_numpy(xx))\n</code></pre></div></div>\n\n<p><img src=\"https://mrocklin.github.io/blog/images/R_31.png\" alt=\"\" /></p>\n\n<h2 id=\"performance\">Performance</h2>\n\n<p>When we profile these functions we find that the <code class=\"language-plaintext highlighter-rouge\">Fortran</code> solution runs a bit faster.  This is because it is able to fuse all of the scalar operations into one loop while the <code class=\"language-plaintext highlighter-rouge\">numpy</code> solution walks over memory several times, performing each operation individually.  Jensen wrote a more thorough <a href=\"http://ojensen.wordpress.com/2010/08/10/fast-ufunc-ish-hydrogen-solutions/\">blogpost about this</a> when he worked on code generation.  He shows substantial performance increases as the complexity of the mathematical expression increases.</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&gt;&gt;&gt; timeit fn_numpy(xx)\n1000 loops, best of 3: 1.4 ms per loop\n&gt;&gt;&gt; timeit fn_fortran(xx)\n1000 loops, best of 3: 884 us per loop\n</code></pre></div></div>\n\n<p>This weekend I built up a translation from SymPy expressions to Theano computations.  This builds off of <a href=\"http://github.com/nouiz/theano_sympy/\">old work</a> done with <a href=\"http://github.com/nouiz\">Frederic Bastien</a> at SciPy2012.</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&gt;&gt;&gt; from sympy.printing.theanocode import theano_function\n&gt;&gt;&gt; fn_theano  = theano_function([x], [expr], dims={x: 1}, dtypes={x: 'float64'})\n&gt;&gt;&gt; timeit fn_theano(xx)\n1000 loops, best of 3: 1.04 ms per loop\n</code></pre></div></div>\n\n<p>Theano generates <code class=\"language-plaintext highlighter-rouge\">C</code> code that performs the same loop fusion done in <code class=\"language-plaintext highlighter-rouge\">Fortran</code> but it incurs a bit more startup time.  It performs somewhere between the <code class=\"language-plaintext highlighter-rouge\">numpy</code> and <code class=\"language-plaintext highlighter-rouge\">Fortran</code> solutions.</p>\n\n<p>However, the <code class=\"language-plaintext highlighter-rouge\">SymPy to Theano</code> translation interface only takes up about a page of code while the <code class=\"language-plaintext highlighter-rouge\">lambdify</code> and <code class=\"language-plaintext highlighter-rouge\">autowrap</code> modules are substantially more complex.  Additionally, Theano is actively developed and is sure to improve and track changes in hardware well into the future.  <code class=\"language-plaintext highlighter-rouge\">lambdify</code> and <code class=\"language-plaintext highlighter-rouge\">autowrap</code> have been relatively untouched over the past year.  For example Theano is able to seemlessly compile these computations to the GPU.</p>\n\n<h2 id=\"leveraging-theano\">Leveraging Theano</h2>\n\n<p>In the above example we used Theano to copy the behavior of SymPy’s existing <code class=\"language-plaintext highlighter-rouge\">numpy</code> and <code class=\"language-plaintext highlighter-rouge\">Fortran</code> numeric solutions.  Theano is capable of substantially more than this.  To show a simple example we’ll compute both our original output and the derivative simultaneously.</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>outputs = expr, simplify(expr.diff(x))\nprint latex(outputs)\n</code></pre></div></div>\n\n\\[\\begin{pmatrix}\\frac{8}{3} x \\left(- 4 x + 4\\right) e^{- 2 x}, &amp; \\frac{32}{3} \\left(2 x^{2} - 4 x + 1\\right) e^{- 2 x}\\end{pmatrix}\\]\n\n<p>We redefine our functions to produce both outputs, instead of just <code class=\"language-plaintext highlighter-rouge\">expr</code> alone</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>fn_numpy  = lambdify([x], outputs, 'numpy')\nfn_theano = theano_function([x], outputs, dims={x: 1}, dtypes={x: 'float64'})\n\nfns_fortran = [ufuncify([x], output) for output in outputs]\nfn_fortran  = lambda xx: [fn_fortran(xx) for fn_fortran in fns_fortran]\n</code></pre></div></div>\n\n<p>The expression and its derivative look like this:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>for y in fn_theano(xx):\n    plot(xx, y)\nlegend(['$R_{31}$', \"$R'_{31}$\"])\n</code></pre></div></div>\n\n<p><img src=\"https://mrocklin.github.io/blog/images/R_31_prime.png\" alt=\"\" /></p>\n\n<p>Because Theano handles common subexpressions well it is able to perform the extra computation with only a very slight increase in runtime, easily eclipsing either of the other two options.</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&gt;&gt;&gt; timeit fn_numpy(xx)\n100 loops, best of 3: 2.85 ms per loop\n&gt;&gt;&gt; timeit fn_fortran(xx)\n1000 loops, best of 3: 1.8 ms per loop\n&gt;&gt;&gt; timeit fn_theano(xx)\n1000 loops, best of 3: 1.16 ms per loop\n</code></pre></div></div>\n\n<p>When we extend this experiment and vary the number of simultaneous derivatives we observe the following runtimes</p>\n\n<p><img src=\"https://mrocklin.github.io/blog/images/profile-theano-fortran-numpy.png\" alt=\"\" /></p>\n\n<p>In the case of highly structured computation Theano is able to scale very favorably.</p>\n\n<h2 id=\"conclusion\">Conclusion</h2>\n\n<p>The Theano project is devoted to code generation at a level that exceeds the devotion of SymPy to this same topic.  This is natural and prevalent.  When we combine the good parts of both projects we often achieve a better result than with an in-house solution</p>\n\n<p>In-house solutions to foreign problems lack persistence.  As programmers within an ecosystem we should make projects that do one thing well and provide clean interfaces and simple data structures to encourage inter-project communication.</p>\n\n<h2 id=\"references\">References</h2>\n\n<ul>\n  <li><a href=\"http://sympy.org/\">SymPy</a></li>\n  <li><a href=\"http://deeplearning.net/software/theano\">Theano</a></li>\n  <li><a href=\"http://ojensen.wordpress.com/2010/08/10/fast-ufunc-ish-hydrogen-solutions/\">Jensen’s Blogpost</a></li>\n  <li><a href=\"https://github.com/mrocklin/sympy/tree/theano-print\">Development git repository</a></li>\n  <li><a href=\"https://mrocklin.github.io/blog/scripts/sympy_theano_printing.ipynb\">IPython notebook of this work</a></li>\n</ul>"
}