{
  "title": "How to Use Python Data Classes",
  "link": "https://www.dataquest.io/blog/how-to-use-python-data-classes/",
  "comments": "https://www.dataquest.io/blog/how-to-use-python-data-classes/#respond",
  "dc:creator": "Otávio Simões Silveira",
  "pubDate": "Tue, 01 Nov 2022 08:00:29 +0000",
  "category": [
    "Data Science Tutorials",
    "Data Science",
    "python",
    "Tutorials"
  ],
  "guid": "https://www.dataquest.io/?p=41406",
  "description": "In Python, a data class is a class that is designed to only hold data values. They aren&#8217;t different from regular classes, but they usually don&#8217;t have any other methods. They are typically used to store information that will be passed between different parts of a program or a system. However, when creating classes to [&#8230;]",
  "content:encoded": "<p>In Python, a data class is a class that is designed to only hold data values. They aren&#8217;t different from regular classes, but they usually don&#8217;t have any other methods. They are typically used to store information that will be passed between different parts of a program or a system.</p>\n<p>However, when creating classes to work only as data containers, writing the <code>__init__</code> method repeatedly can generate a great amount of work and potential errors.</p>\n<p>The <code>dataclasses </code> module,  a feature introduced in Python 3.7, provides a way to create data classes in a simpler manner without the need to write methods. </p>\n<p>In this article, we&#8217;ll see how to take advantage of this module to quickly create new classes that already come not only with <code>__init__</code>, but several other methods already implemented so we don&#8217;t need to implement them manually. Also, we can do that with just a few lines of code.</p>\n<p>We expect you to have some intermediate python experience, including an understanding of how to create classes and object-oriented programming in general.</p>\n<h2>Using the <code>dataclasses</code> Module</h2>\n<p>As a starting example, let&#8217;s say we&#8217;re implementing a class to store data about a certain group of people. For each person, we&#8217;ll have attributes such as name, age, height, and email address. This is what a regular class looks like:</p>\n<pre><code class=\"language-python\">class Person():\n    def __init__(self, name, age, height, email):\n        self.name = name\n        self.age = age\n        self.height = height\n        self.email = email</code></pre>\n<p>If we use the <code>dataclasses</code> module, however, we need to import <code>dataclass</code> to use it as a decorator in the class we&#8217;re creating. When we do that, we no longer need to write the <strong>init</strong> function, only specify the attributes of the class and their types. Here&#8217;s the same <code>Person</code> class, implemented in this way:</p>\n<pre><code class=\"language-python\">from dataclasses import dataclass\n\n@dataclass\nclass Person():\n    name: str\n    age: int\n    height: float\n    email: str</code></pre>\n<p>We can also set default values to the class attributes:</p>\n<pre><code class=\"language-python\">@dataclass\nclass Person():\n    name: str = &#039;Joe&#039;\n    age: int = 30\n    height: float = 1.85\n    email: str = &#039;joe@dataquest.io&#039;\n\nprint(Person())</code></pre>\n<pre><code class=\"language-text\">    Person(name=&#039;Joe&#039;, age=30, height=1.85, email=&#039;joe@dataquest.io&#039;)</code></pre>\n<p>As a reminder, Python doesn&#8217;t accept a non-default attribute after default in both class and functions, so this would throw an error:</p>\n<pre><code class=\"language-python\">@dataclass\nclass Person():\n    name: str = &#039;Joe&#039;\n    age: int = 30\n    height: float = 1.85\n    email: str </code></pre>\n<pre><code class=\"language-text\">\n    ---------------------------------------------------------------------------\n\n    TypeError                                 Traceback (most recent call last)\n\n    ~\\AppData\\Local\\Temp/ipykernel_5540/741473360.py in <module>\n          1 @dataclass\n    ----> 2 class Person():\n          3     name: str = &#039;Joe&#039;\n          4     age: int = 30\n          5     height: float = 1.85\n\n    ~\\anaconda3\\lib\\dataclasses.py in dataclass(cls, init, repr, eq, order, unsafe_hash, frozen)\n       1019 \n       1020     # We&#039;re called as @dataclass without parens.\n    -> 1021     return wrap(cls)\n       1022 \n       1023 \n\n    ~\\anaconda3\\lib\\dataclasses.py in wrap(cls)\n       1011 \n       1012     def wrap(cls):\n    -> 1013         return _process_class(cls, init, repr, eq, order, unsafe_hash, frozen)\n       1014 \n       1015     # See if we&#039;re being called as @dataclass or @dataclass().\n\n    ~\\anaconda3\\lib\\dataclasses.py in _process_class(cls, init, repr, eq, order, unsafe_hash, frozen)\n        925                 if f._field_type in (_FIELD, _FIELD_INITVAR)]\n        926         _set_new_attribute(cls, &#039;__init__&#039;,\n    --> 927                            _init_fn(flds,\n        928                                     frozen,\n        929                                     has_post_init,\n\n    ~\\anaconda3\\lib\\dataclasses.py in _init_fn(fields, frozen, has_post_init, self_name, globals)\n        502                 seen_default = True\n        503             elif seen_default:\n    --> 504                 raise TypeError(f&#039;non-default argument {f.name!r} &#039;\n        505                                 &#039;follows default argument&#039;)\n        506 \n\n    TypeError: non-default argument &#039;email&#039; follows default argument</code></pre>\n<p>Once the class is defined, it&#8217;s easy to instantiate a new object and access its attributes, just like with a standard class:</p>\n<pre><code class=\"language-python\">person = Person(&#039;Joe&#039;, 25, 1.85, &#039;joe@dataquest.io&#039;)\nprint(person.name)</code></pre>\n<pre><code class=\"language-text\">    Joe</code></pre>\n<p>So far we&#8217;ve used regular data types like string, integer, and float; we can also combine <code>dataclass</code> with the <code>typing</code> modules to create attributes of any kind in the class. For instance, let&#8217;s add a <code>house_coordinates</code> attribute to the <code>Person</code>:</p>\n<pre><code class=\"language-python\">from typing import Tuple\n\n@dataclass\nclass Person():\n    name: str\n    age: int\n    height: float\n    email: str\n    house_coordinates: Tuple\n\nprint(Person(&#039;Joe&#039;, 25, 1.85, &#039;joe@dataquest.io&#039;, (40.748441, -73.985664)))</code></pre>\n<pre><code class=\"language-text\">    Person(name=&#039;Joe&#039;, age=25, height=1.85, email=&#039;joe@dataquest.io&#039;, house_coordinates=(40.748441, -73.985664))</code></pre>\n<p>Following the same logic, we can create a data class to hold multiple instances of the <code>Person</code> class:</p>\n<pre><code class=\"language-python\">from typing import List\n\n@dataclass\nclass People():\n    people: List[Person]</code></pre>\n<p>Notice that the <code>people</code> attribute in the <code>People</code> class is defined as a list of instances of the <code>Person</code> class. For example, we could instantiate an object of  <code>People</code> like this:</p>\n<pre><code class=\"language-python\">joe = Person(&#039;Joe&#039;, 25, 1.85, &#039;joe@dataquest.io&#039;, (40.748441, -73.985664))\nmary = Person(&#039;Mary&#039;, 43, 1.67, &#039;mary@dataquest.io&#039;, (-73.985664, 40.748441))\n\nprint(People([joe, mary]))</code></pre>\n<pre><code class=\"language-text\">    People(people=[Person(name=&#039;Joe&#039;, age=25, height=1.85, email=&#039;joe@dataquest.io&#039;, house_coordinates=(40.748441, -73.985664)), Person(name=&#039;Mary&#039;, age=43, height=1.67, email=&#039;mary@dataquest.io&#039;, house_coordinates=(-73.985664, 40.748441))])</code></pre>\n<p>This allows us to define the attribute as being any type we want, but also a combination of data types.</p>\n<h2>Representation and Comparisons</h2>\n<p>As we mentioned earlier, <code>dataclass</code> implements not only the <code>__init__</code> method, but several others, including the <code>__repr__</code> method. In a regular class, we use this method to display a representation of an object in the class.</p>\n<p>For instance, we&#8217;d define the method as in the example below when we call the object:</p>\n<pre><code class=\"language-python\">class Person():\n    def __init__(self, name, age, height, email):\n        self.name = name\n        self.age = age\n        self.height = height\n        self.email = email\n\n    def __repr__(self):\n        return (f&#039;{self.__class__.__name__}(name={self.name}, age={self.age}, height={self.height}, email={self.email})&#039;)\n\nperson = Person(&#039;Joe&#039;, 25, 1.85, &#039;joe@dataquest.io&#039;)\nprint(person)</code></pre>\n<pre><code class=\"language-text\">    Person(name=Joe, age=25, height=1.85, email=joe@dataquest.io)</code></pre>\n<p>When using <code>dataclass</code>, however, there&#8217;s no need to write any of that:</p>\n<pre><code class=\"language-python\">@dataclass\nclass Person():\n    name: str\n    age: int\n    height: float\n    email: str    \n\nperson = Person(&#039;Joe&#039;, 25, 1.85, &#039;joe@dataquest.io&#039;)\nprint(person)</code></pre>\n<pre><code class=\"language-text\">    Person(name=&#039;Joe&#039;, age=25, height=1.85, email=&#039;joe@dataquest.io&#039;)</code></pre>\n<p>Notice that without all that code, the output is equivalent to the one from the standard Python class.</p>\n<p>We can always overwrite it if we want to customize the representation of our class:</p>\n<pre><code class=\"language-python\">@dataclass\nclass Person():\n    name: str\n    age: int\n    height: float\n    email: str\n\n    def __repr__(self):\n        return (f&#039;&#039;&#039;This is a {self.__class__.__name__} called {self.name}.&#039;&#039;&#039;)\n\nperson = Person(&#039;Joe&#039;, 25, 1.85, &#039;joe@dataquest.io&#039;)\nprint(person)</code></pre>\n<pre><code class=\"language-text\">    This is a Person called Joe.</code></pre>\n<p>Notice that the output of the representation is customized.</p>\n<p>When it comes to comparisons, the <code>dataclasses</code> module makes our lives easier. For example, we can directly compare two instances of a class just like this:</p>\n<pre><code class=\"language-python\">@dataclass\nclass Person():\n    name: str = &#039;Joe&#039;\n    age: int = 30\n    height: float = 1.85\n    email: str = &#039;joe@dataquest.io&#039;\n\nprint(Person() == Person())</code></pre>\n<pre><code class=\"language-text\">    True</code></pre>\n<p>Notice that we used default attributes to make the example shorter.</p>\n<p>In this case, the comparison is valid because the <code>dataclass</code> creates behind the scenes an <code>__eq__</code> method, which performs the comparison. Without the decorator, we&#8217;d have to create this method ourselves.</p>\n<p>The same comparison would result in a different outcome if using a standard Python class, even though the classes are in fact equal to each other:</p>\n<pre><code class=\"language-python\">class Person():\n    def __init__(self, name=&#039;Joe&#039;, age=30, height=1.85, email=&#039;joe@dataquest.io&#039;):\n        self.name = name\n        self.age = age\n        self.height = height\n        self.email = email\n\nprint(Person() == Person())</code></pre>\n<pre><code class=\"language-text\">    False</code></pre>\n<p>Without the use of the <code>dataclass</code> decorator, that class doesn&#8217;t test whether two instances are equal. So, by default, Python will use the object&#8217;s <code>id</code> to make the comparison, and, as we see below, they are different:</p>\n<pre><code class=\"language-python\">print(id(Person()))\nprint(id(Person()))</code></pre>\n<pre><code>1734438049008\n1734438050976</code></pre>\n<p>All this means that we&#8217;d have to write an <code>__eq__</code> method that makes this comparison:</p>\n<pre><code class=\"language-python\">class Person():\n    def __init__(self, name=&#039;Joe&#039;, age=30, height=1.85, email=&#039;joe@dataquest.io&#039;):\n        self.name = name\n        self.age = age\n        self.height = height\n        self.email = email\n\n    def __eq__(self, other):\n        if isinstance(other, Person):\n            return (self.name, self.age,\n                    self.height, self.email) == (other.name, other.age,\n                                                 other.height, other.email)\n        return NotImplemented\n\nprint(Person() == Person())</code></pre>\n<pre><code class=\"language-text\">    True</code></pre>\n<p>Now we see the two objects are equal to each other, but we had to write more code to get this result.</p>\n<h2>The <code>@dataclass</code> Parameters </h2>\n<p>As we saw above, when using the <code>dataclass</code> decorator, the <code>__init__</code>, <code>__repr__</code>, and <code>__eq__</code> methods are implemented for us. The creation of all these methods is set by the <code>init</code>, <code>repr</code>, and <code>eq</code> parameters of <code>dataclass</code>. These three parameters are <code>True</code> by default. If one of them is created inside the class, then the parameter is ignored.</p>\n<p>However, we have other parameters of <code>dataclass</code> that we should look at before moving on:</p>\n<ul>\n<li><code>order</code>: enables sorting of the class as we&#8217;ll see in the next section. The default is <code>False</code>.</li>\n<li><code>frozen</code>: When <code>True</code>, the values inside the instance of the class can&#8217;t be modified after it&#8217;s created. The default is <code>False</code>.</li>\n</ul>\n<p>There are a few other methods that you can check in the <a href=\"https://docs.python.org/3/library/dataclasses.html#dataclasses.dataclass\">documentation</a>.</p>\n<h2>Sorting</h2>\n<p>When working with data, we often need to sort values. In our scenario, we may want to sort our different people based on some attribute. For that, we&#8217;ll use the <code>order</code> parameter of the <code>dataclass</code> decorator mentioned above which enables sorting in the class:</p>\n<pre><code class=\"language-python\">@dataclass(order=True)\nclass Person():\n    name: str\n    age: int\n    height: float\n    email: str</code></pre>\n<p>When the <code>order</code> parameter is set to <code>True</code>, it automatically generates the <code>__lt__</code> (less than), <code>__le__</code> (less or equal), <code>__gt__</code> (greater than), and <code>__ge__</code> (greater or equal) methods used for sorting.</p>\n<p>Let&#8217;s instantiate our <code>joe</code> and <code>mary</code> objects to see if one is greater than the other:</p>\n<pre><code class=\"language-python\">joe = Person(&#039;Joe&#039;, 25, 1.85, &#039;joe@dataquest.io&#039;)\nmary = Person(&#039;Mary&#039;, 43, 1.67, &#039;mary@dataquest.io&#039;)\n\nprint(joe > mary)</code></pre>\n<pre><code class=\"language-text\">    False</code></pre>\n<p>Python tells us that <code>joe</code> is not greater than <code>mary</code>, but based on what criteria? The class compares the objects as tuples containing their attributes, like this:</p>\n<pre><code class=\"language-python\">print((&#039;Joe&#039;, 25, 1.85, &#039;joe@dataquest.io&#039;) > (&#039;Mary&#039;, 43, 1.67, &#039;mary@dataquest.io&#039;))</code></pre>\n<pre><code class=\"language-text\">    False</code></pre>\n<p>As the letter \"J\" comes before \"M\", it says the <code>joe < mary</code>. If the names were the same, it would move to the next element in each tuple. As it is, it&#8217;s comparing the objects alphabetically. Although that can make some sense depending on the problem we&#8217;re dealing with, we want to be able to control how the objects will be sorted.</p>\n<p>To achieve that, we&#8217;ll take advantage of two other features of the <code>dataclasses</code> module.</p>\n<p>The first is the <code>field</code> function. This function is used to customize one attribute of a data class individually, which allows us to define new attributes that will depend on another attribute and will only be created after the object is instantiated.</p>\n<p>In our sorting problem, we&#8217;ll use <code>field</code> to create a <code>sort_index</code> attribute in our class. This attribute can only be created after the object is instantiated and is what <code>dataclasses</code> uses for sorting:</p>\n<pre><code class=\"language-python\">from dataclasses import dataclass, field\n\n@dataclass(order=True)\nclass Person():\n    sort_index: int = field(init=False, repr=False)\n    name: str\n    age: int\n    height: float\n    email: str</code></pre>\n<p>The two arguments that we passed as <code>False</code> state that this attribute isn&#8217;t in the <code>__init__</code> and that it shouldn&#8217;t be displayed when we call <code>__repr__</code>. There are other parameters in the <code>field</code> function that you can check in the documentation.</p>\n<p>After we&#8217;ve  referenced this new attribute, we&#8217;ll use the second new tool: the <code>__post_int__</code> method. As it goes by the name, this method is executed right after the <code>__init__</code> method. We&#8217;ll use <code>__post_int__</code> to define the <code>sort_index</code>, right after the creation of the object. As an example, let&#8217;s say we want to compare people based on their age. Here&#8217;s how:</p>\n<pre><code class=\"language-python\">@dataclass(order=True)\nclass Person():\n    sort_index: int = field(init=False, repr=False)\n    name: str\n    age: int\n    height: float\n    email: str\n\n    def __post_init__(self):\n        self.sort_index = self.age</code></pre>\n<p>If we make the same comparison, we know that Joe is younger than Mary:</p>\n<pre><code class=\"language-python\">joe = Person(&#039;Joe&#039;, 25, 1.85, &#039;joe@dataquest.io&#039;)\nmary = Person(&#039;Mary&#039;, 43, 1.67, &#039;mary@dataquest.io&#039;)\n\nprint(joe > mary)</code></pre>\n<pre><code class=\"language-text\">    False</code></pre>\n<p>If we wanted to sort people by height, we&#8217;d use this code:</p>\n<pre><code class=\"language-python\">@dataclass(order=True)\nclass Person():\n    sort_index: float = field(init=False, repr=False)\n    name: str\n    age: int\n    height: float\n    email: str\n\n    def __post_init__(self):\n        self.sort_index = self.height\n\njoe = Person(&#039;Joe&#039;, 25, 1.85, &#039;joe@dataquest.io&#039;)\nmary = Person(&#039;Mary&#039;, 43, 1.67, &#039;mary@dataquest.io&#039;)\n\nprint(joe > mary)</code></pre>\n<pre><code class=\"language-text\">    True</code></pre>\n<p>Joe is taller than Mary. Notice that we set <code>sort_index</code> as a <code>float</code>.</p>\n<p>We were able to implement sorting in our data class without the need to write multiple methods.</p>\n<h2>Working with Immutable Data Classes</h2>\n<p>Another parameter of <code>@dataclass</code> that we mentioned above is <code>frozen</code>. When set to <code>True</code>, <code>frozen</code> doesn&#8217;t allow us to modify the attributes of an object after it&#8217;s created.</p>\n<p>With <code>frozen=False</code>, we can easily perform such modification:</p>\n<pre><code class=\"language-python\">@dataclass()\nclass Person():\n    name: str\n    age: int\n    height: float\n    email: str\n\njoe = Person(&#039;Joe&#039;, 25, 1.85, &#039;joe@dataquest.io&#039;)\n\njoe.age = 35\nprint(joe)</code></pre>\n<pre><code class=\"language-text\">    Person(name=&#039;Joe&#039;, age=35, height=1.85, email=&#039;joe@dataquest.io&#039;)</code></pre>\n<p>We created a <code>Person</code> object and then modified the <code>age</code> attribute without any problems.</p>\n<p>However, when set to <code>True</code>, any attempt to modify the object throws an error:</p>\n<pre><code class=\"language-python\">@dataclass(frozen=True)\nclass Person():\n    name: str\n    age: int\n    height: float\n    email: str\n\njoe = Person(&#039;Joe&#039;, 25, 1.85, &#039;joe@dataquest.io&#039;)\n\njoe.age = 35\nprint(joe)</code></pre>\n<pre><code class=\"language-text\">    ---------------------------------------------------------------------------\n\n    FrozenInstanceError                       Traceback (most recent call last)\n\n    ~\\AppData\\Local\\Temp/ipykernel_5540/2036839054.py in <module>\n          8 joe = Person(&#039;Joe&#039;, 25, 1.85, &#039;joe@dataquest.io&#039;)\n          9 \n    ---> 10 joe.age = 35\n         11 print(joe)\n\n    <string> in __setattr__(self, name, value)\n\n    FrozenInstanceError: cannot assign to field &#039;age&#039;</code></pre>\n<p>Notice that the error message states <code>FrozenInstanceError</code>.</p>\n<p>There&#8217;s a trick that can modify the value of the immutable data class . If our class contains a mutable attribute, this attribute can change even though the class is frozen. This may seem like it doesn&#8217;t make sense, but let&#8217;s look at an example.</p>\n<p>Let&#8217;s recall the <code>People</code> class that we created earlier in this article, but now let&#8217;s make it immutable:</p>\n<pre><code class=\"language-python\">@dataclass(frozen=True)\nclass People():\n    people: List[Person]\n\n@dataclass(frozen=True)\nclass Person():\n    name: str\n    age: int\n    height: float\n    email: str</code></pre>\n<p>We then create two instances of the <code>Person</code> class and use them to create an instance of <code>People</code> that we&#8217;ll name <code>two_people</code>:</p>\n<pre><code class=\"language-python\">joe = Person(&#039;Joe&#039;, 25, 1.85, &#039;joe@dataquest.io&#039;)\nmary = Person(&#039;Mary&#039;, 43, 1.67, &#039;mary@dataquest.io&#039;)\n\ntwo_people = People([joe, mary])\nprint(two_people)</code></pre>\n<pre><code class=\"language-text\">    People(people=[Person(name=&#039;Joe&#039;, age=25, height=1.85, email=&#039;joe@dataquest.io&#039;), Person(name=&#039;Mary&#039;, age=43, height=1.67, email=&#039;mary@dataquest.io&#039;)])</code></pre>\n<p>The <code>people</code> attribute in the <code>People</code> class is a list. We can easily access the values in this list in the <code>two_people</code> object:</p>\n<pre><code class=\"language-python\">print(two_people.people[0])</code></pre>\n<pre><code class=\"language-text\">    Person(name=&#039;Joe&#039;, age=25, height=1.85, email=&#039;joe@dataquest.io&#039;)</code></pre>\n<p>So, even though both <code>Person</code> and <code>People</code> classes are immutable, the list is not, which means we can change the values in it:</p>\n<pre><code class=\"language-python\">two_people.people[0] = Person(&#039;Joe&#039;, 35, 1.85, &#039;joe@dataquest.io&#039;)\nprint(two_people.people[0])</code></pre>\n<pre><code class=\"language-text\">    Person(name=&#039;Joe&#039;, age=35, height=1.85, email=&#039;joe@dataquest.io&#039;)</code></pre>\n<p>Notice that the age is now 35.</p>\n<p>We didn&#8217;t change the attributes of any object of the immutable classes, but we replaced the first element of the list with a different one, and the list is mutable.</p>\n<p>Keep in mind that all the attributes of the class should also be immutable in order to safely work with immutable data classes.</p>\n<h2>Inheritance with <code>dataclasses</code></h2>\n<p>The <code>dataclasses</code> module also supports inheritance, which means we can create a data class that uses the attributes of another data class. Still using our <code>Person</code> class, we&#8217;ll create a new <code>Employee</code> class that inherits all the attributes from <code>Person</code>.<br />\nSo we have <code>Person</code>:</p>\n<pre><code class=\"language-python\">@dataclass(order=True)\nclass Person():\n    name: str\n    age: int\n    height: float\n    email: str</code></pre>\n<p>And the new <code>Employee</code> class:</p>\n<pre><code class=\"language-python\">@dataclass(order=True)\nclass Employee(Person):\n    salary: int\n    departament: str</code></pre>\n<p>Now we can create an object of the <code>Employee</code> class using all the attributes of the <code>Person</code> class:</p>\n<pre><code class=\"language-python\">print(Employee(&#039;Joe&#039;, 25, 1.85, &#039;joe@dataquest.io&#039;, 100000, &#039;Marketing&#039;))</code></pre>\n<pre><code class=\"language-text\">    Employee(name=&#039;Joe&#039;, age=25, height=1.85, email=&#039;joe@dataquest.io&#039;, salary=100000, departament=&#039;Marketing&#039;)</code></pre>\n<p>From now on we can use everything we saw in this article in the <code>Employee</code> class as well.</p>\n<p>Take note of the default attributes. Let&#8217;s say we have default attributes in <code>Person</code>, but not in <code>Employee</code>. This scenario, as in the code below, raises an error:</p>\n<pre><code class=\"language-python\">@dataclass\nclass Person():\n    name: str = &#039;Joe&#039;\n    age: int = 30\n    height: float = 1.85\n    email: str = &#039;joe@dataquest.io&#039;\n\n@dataclass(order=True)\nclass Employee(Person):\n    salary: int\n    departament: str\n\nprint(Employee(&#039;Joe&#039;, 25, 1.85, &#039;joe@dataquest.io&#039;, 100000, &#039;Marketing&#039;))</code></pre>\n<pre><code class=\"language-text\">\n    ---------------------------------------------------------------------------\n\n    TypeError                                 Traceback (most recent call last)\n\n    ~\\AppData\\Local\\Temp/ipykernel_5540/1937366284.py in <module>\n          9 \n         10 @dataclass(order=True)\n    ---> 11 class Employee(Person):\n         12     salary: int\n         13     departament: str\n\n    ~\\anaconda3\\lib\\dataclasses.py in wrap(cls)\n       1011 \n       1012     def wrap(cls):\n    -> 1013         return _process_class(cls, init, repr, eq, order, unsafe_hash, frozen)\n       1014 \n       1015     # See if we&#039;re being called as @dataclass or @dataclass().\n\n    ~\\anaconda3\\lib\\dataclasses.py in _process_class(cls, init, repr, eq, order, unsafe_hash, frozen)\n        925                 if f._field_type in (_FIELD, _FIELD_INITVAR)]\n        926         _set_new_attribute(cls, &#039;__init__&#039;,\n    --> 927                            _init_fn(flds,\n        928                                     frozen,\n        929                                     has_post_init,\n\n    ~\\anaconda3\\lib\\dataclasses.py in _init_fn(fields, frozen, has_post_init, self_name, globals)\n        502                 seen_default = True\n        503             elif seen_default:\n    --> 504                 raise TypeError(f&#039;non-default argument {f.name!r} &#039;\n        505                                 &#039;follows default argument&#039;)\n        506 \n\n    TypeError: non-default argument &#039;salary&#039; follows default argument</code></pre>\n<p>If the base class has default attributes, all the attributes in the class derived from it must have default values too.</p>\n<h2>Conclusion</h2>\n<p>In this article, we saw how the <code>dataclasses</code> module is a very powerful tool to create data classes in a quick, intuitive way. Although we&#8217;ve seen a lot in this article, the module contains many more tools, and there&#8217;s always more to learn about it.</p>\n<p>So far, we&#8217;ve learned how to:</p>\n<ul>\n<li>\n<p>Define a class using <code>dataclasses</code></p>\n</li>\n<li>\n<p>Use default attributes and their rules</p>\n</li>\n<li>\n<p>Create a representation method</p>\n</li>\n<li>\n<p>Compare data classes</p>\n</li>\n<li>\n<p>Sort data classes</p>\n</li>\n<li>\n<p>Use inheritance with data classes</p>\n</li>\n<li>\n<p>Work with immutable data classes</p>\n</li>\n</ul>\n",
  "wfw:commentRss": "https://www.dataquest.io/blog/how-to-use-python-data-classes/feed/",
  "slash:comments": 0
}