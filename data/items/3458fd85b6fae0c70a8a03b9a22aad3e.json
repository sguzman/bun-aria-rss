{
  "title": "Validating your data with Hamilton",
  "description": "<h1 id=\"validating-your-data-with-hamilton\">Validating your Data with Hamilton</h1>\n\n<p>Since we open-sourced Hamilton late last year, we have received an outpouring of community engagement and support. It turns out the problems we needed to solve at Stitch Fix were well aligned with the rest of the industry’s approach to transforming data!</p>\n\n<p>With the goal of being a one-stop-shop for all dataflow-related needs, we have constantly received feedback and contributions on improving the product.  The most consistent feedback we received was that, while the API for managing dataflows was clean and scalable, nothing in Hamilton ensured the robustness or quantitative stability of execution. If garbage data went in, dataflows broke or garbage data came out.</p>\n\n<p>We have solved this in <code class=\"language-plaintext highlighter-rouge\">sf-hamilton&gt;=1.9.0</code> with the introduction of two decorators. Our goal was to build an experience that hit the majority of use cases, while setting up extensions and integrations for future capabilities…</p>\n\n<h2 id=\"reintroducing-hamilton\">Reintroducing Hamilton</h2>\n\n<p>In case you aren’t familiar with the product, here’s a brief introduction to Hamilton. For more details, check out the <a href=\"https://multithreaded.stitchfix.com/blog/2021/10/14/functions-dags-hamilton/\">initial introduction</a>, as well as the <a href=\"https://multithreaded.stitchfix.com/blog/2022/02/22/scaling-hamilton/\">update on scaling up dataflows</a>.</p>\n\n<p>Stitch Fix’s demand forecasting team manages an ever-expanding set of complex, highly-configurable forecasts. In the before-times, these pipelines took the form of an ancient codebase that continually manipulated the same dataframe to transform <em>actuals</em> data into predictions.</p>\n\n<p>The systems that massaged features to produce the team’s forecasts were among the oldest at Stitch Fix. While they had been business-critical for years, the organic, sprawling nature of the code’s development meant that nobody fully understood the software in all its complexity.</p>\n\n<p>Hamilton was born to enable this team to scale. At its core, it allows the manager of a dataflow to express every element as a simple python function. Instead of writing code that looks like this:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>df['c'] = df['b'] + df['a']\n</code></pre></div></div>\n\n<p>they would write the following:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>def c(a: pd.Series, b: pd.Series) -&gt; pd.Series:\n    \"\"\"Column c - this sums up a and b\"\"\"\n    return a+b\n</code></pre></div></div>\n\n<p>The Hamilton framework compiles these functions to model a dataflow as nodes in a <a href=\"https://en.wikipedia.org/wiki/Directed_acyclic_graph\">Directed Acyclic Graph</a> (DAG). It uses the names of the parameters as references to upstream nodes, and the name of the function itself to specify the node. In this case, <code>a </code>&lt;/strong&gt;and<code> <strong>b </strong></code>are implied to be other nodes in the DAG (possibly defined by further upstream functions…).</p>\n\n<p>This simple abstraction, powered by a variety of extensions in the framework, made it remarkably easy to work on these vast, complex feature pipelines without incurring additional cognitive burden. Their newly migrated codebase turned into a self-documenting feature store, and the forecasting team was able to scale, and therefore able to focus more importantly on building better models for the business.</p>\n\n<h2 id=\"data-quality\">Data Quality</h2>\n\n<p>While the abstraction that Hamilton provides is uniquely powerful, it initially did nothing to ensure that the data processed within Hamilton’s dataflow was what one expected. Data quality issues generally creep into dataflows abruptly or over time. For example, either something changed with the inputs (e.g. a value drops off in appearance), or a change was made to transformation logic that invalidated downstream assumptions, e.g. allowing NaNs. While debugging such issues is more straightforward with Hamilton, we felt that we could provide the dataflow developer with a better experience. One should be able to specify and have confidence that each function produces sane results upon execution.</p>\n\n<h3 id=\"design-considerations\">Design Considerations</h3>\n\n<p>There are three popular open source frameworks that come to mind with respect to tabular data:</p>\n\n<ul>\n  <li><a href=\"https://github.com/awslabs/deequ\">Deequ</a></li>\n  <li><a href=\"https://greatexpectations.io/blog/pandas-profiling-integration/\">Great Expectations</a></li>\n  <li><a href=\"https://pandera.readthedocs.io/\">Pandera</a></li>\n</ul>\n\n<p>The first two are heavy weight frameworks that require a suite of services &amp; databases to be spun up. The last one, Pandera, takes a much simpler approach. It does away with the need for managing a service, and instead focuses on defining simple expectations on dataframe-like objects. All three frameworks generally require you to think about data quality as an explicit step in your dataflow that you need to express.</p>\n\n<p>While the above all provide powerful capabilities, we wanted to take a lighter-weight approach. Specifically, we believed:</p>\n\n<ol>\n  <li>Most data validation checks do not need to rely on stored state (hence the success of Pandera).</li>\n  <li>Actions upon validation failures should be simple (e.g. log a warning or fail out).</li>\n  <li>Defining the tests together with the code ensures expectations and code are less likely to be out of sync and are self-documenting.</li>\n  <li>Using version control to handle test expectations is the optimal way to manage the lifecycle of a dataflow.</li>\n</ol>\n\n<h3 id=\"api\">API</h3>\n\n<p>With these principles we set out to extend the <em>decorator</em> framework in Hamilton to allow for simple tests and assertions. We ended up with the following…</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"o\">@</span><span class=\"n\">check_output</span><span class=\"p\">(</span>\n    <span class=\"n\">data_type</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">int64</span><span class=\"p\">,</span>\n    <span class=\"n\">data_in_range</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">100</span><span class=\"p\">),</span>\n    <span class=\"n\">importance</span><span class=\"o\">=</span><span class=\"s\">\"warn\"</span><span class=\"p\">,</span>\n<span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">some_int_data_between_0_and_100</span><span class=\"p\">(</span><span class=\"n\">some_input</span><span class=\"p\">:</span> <span class=\"n\">pd</span><span class=\"p\">.</span><span class=\"n\">Series</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">pd</span><span class=\"p\">.</span><span class=\"n\">Series</span><span class=\"p\">:</span>\n    <span class=\"c1\"># Do some computation\n</span></code></pre></div></div>\n\n<p>And it’s as simple as that! Behind the scenes, this does a few things:</p>\n\n<ol>\n  <li>Creates two additional nodes (data_type and data_in_range validators)</li>\n  <li>Executes the nodes after running the function</li>\n  <li>Logs a warning (as specified)</li>\n</ol>\n\n<p>By querying the final results of the DAG, one can query and store the test results (see the <a href=\"https://hamilton-docs.gitbook.io/docs/tutorials/data-quality-checks\">documentation</a> for an example). There are a variety of arguments available, each corresponding to a unique validator. You can explore them <a href=\"https://github.com/stitchfix/hamilton/blob/main/hamilton/data_quality/default_validators.py\">here</a>.</p>\n\n<p>Note, however, that these basic validation arguments are the tip of the iceberg when it comes to data quality. There is an extensive pluggable framework to enable integrations. Pandera even comes out of the box!</p>\n\n<p>To take full advantage of Pandera, all one has to do is pass a schema into the <code class=\"language-plaintext highlighter-rouge\">check_output</code> function.</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">import</span> <span class=\"nn\">Pandera</span> <span class=\"k\">as</span> <span class=\"n\">pa</span>\n<span class=\"o\">@</span><span class=\"n\">check_output</span><span class=\"p\">(</span>\n    <span class=\"n\">schema</span><span class=\"o\">=</span><span class=\"n\">pa</span><span class=\"p\">.</span><span class=\"n\">SeriesSchema</span><span class=\"p\">(</span>\n        <span class=\"n\">pa</span><span class=\"p\">.</span><span class=\"n\">Column</span><span class=\"p\">(</span><span class=\"nb\">int</span><span class=\"p\">),</span> \n        <span class=\"n\">pa</span><span class=\"p\">.</span><span class=\"n\">Check</span><span class=\"p\">.</span><span class=\"n\">in_range</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">100</span><span class=\"p\">)),</span>\n    <span class=\"n\">importance</span><span class=\"o\">=</span><span class=\"s\">\"warn\"</span>\n<span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">some_int_data_between_0_and_100</span><span class=\"p\">(</span><span class=\"n\">some_input</span><span class=\"p\">:</span> <span class=\"n\">pd</span><span class=\"p\">.</span><span class=\"n\">Series</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">pd</span><span class=\"p\">.</span><span class=\"n\">Series</span><span class=\"p\">:</span>\n    <span class=\"c1\"># Do some computation\n</span></code></pre></div></div>\n\n<p>Now you can leverage the full power of Pandera and Hamilton, all with a simple validator.</p>\n\n<p>For more reference, read the tutorial on <a href=\"https://hamilton-docs.gitbook.io/docs/tutorials/data-quality-checks\">gitbook</a> and more detailed documentation on <a href=\"https://github.com/stitchfix/hamilton/blob/main/data_quality.md\">github</a>.</p>\n\n<h2 id=\"extensionsintegrations\">Extensions/Integrations</h2>\n\n<p>Hamilton’s design for data quality is intended to be highly flexible. We wanted to solve <a href=\"https://en.wikipedia.org/wiki/Pareto_principle\">80% of the problem</a> (run basic assertions on the output), while enabling future contributors to solve the more complex ones (running stateful computations against previous runs, for example).</p>\n\n<p>Thus we built a framework for extensions. Anyone who wants more power out of their data validation can implement a subclass of <a href=\"https://github.com/stitchfix/hamilton/blob/90afd3a08df15794f95f9741510923d089a6946a/hamilton/data_quality/base.py#L26\">DataValidator</a>, and validate to their heart’s content. We leave this as an exercise to the reader, but have some exciting integrations planned soon…</p>\n\n<h2 id=\"future-plans\">Future Plans</h2>\n\n<p>Data validation in Hamilton is still in its early stages. In the upcoming weeks, we’ll be working on (and would love contributions for):</p>\n\n<ul>\n  <li><strong>Configuration</strong> – allowing for fine-grained control over the behavior of specific checks. This will enable the user to turn on and off certain checks at runtime.</li>\n  <li><strong>Flexibility</strong> – enabling usage of more underlying data validation systems. While we were mainly avoiding the complexity of the more powerful systems, the extensions framework could happily integrate with tooling such as Great Expectations, Deequ, or Whylogs.</li>\n  <li><strong>Learning</strong> – generating expected tests from profiles of previous runs.</li>\n</ul>\n\n<p>In the meanwhile, however, we’re very excited about the current offering and can’t wait to get feedback from all of you! Join our community on <a href=\"https://join.slack.com/t/hamilton-opensource/shared_invite/zt-1bjs72asx-wcUTgH7q7QX1igiQ5bbdcg\">slack</a>, read the docs on <a href=\"https://hamilton-docs.gitbook.io/docs/\">gitbook</a>, check out the repo on <a href=\"https://github.com/stitchfix/hamilton\">github</a>, and follow us on <a href=\"https://twitter.com/hamilton_os\">twitter</a>.</p>",
  "pubDate": "Tue, 26 Jul 2022 09:00:00 +0000",
  "link": "https://multithreaded.stitchfix.com/blog/2022/07/26/hamilton-data-quality/",
  "guid": "https://multithreaded.stitchfix.com/blog/2022/07/26/hamilton-data-quality/"
}