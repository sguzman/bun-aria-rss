{
  "title": "Simple Recurrent Neural Network",
  "link": "",
  "published": "2015-08-05T00:00:00-05:00",
  "updated": "2015-08-05T00:00:00-05:00",
  "author": {
    "name": "Brandon Brown"
  },
  "id": "tag:outlace.com,2015-08-05:/rnn.html",
  "summary": "<p>A beginner tutorial on building a simple (Elman) recurrent neural network in Python. We'll build an RNN than can compute XOR on sequential data and another that can predict the next character in a sequence.</p>",
  "content": "<h3>Assumptions:</h3>\n<p>I'm assuming you already know how to build a simple neural network (e.g. to solve XOR) and train it using backpropagation. I have a previous post covering backpropagation/gradient descent and at the end of that tutorial I build and train a neural network to solve the XOR problem, so I recommend making sure you understand that because I am basing the RNNs I demonstrate here off of that. I also assume you have a functional understanding of Python/numpy.</p>\n<h3>Summary &amp; Motivations:</h3>\n<p>This blog is my journey into learning the fundamentals of machine learning and other quantitative principles and applications and is generally in chronological order of my learning. After I successfully learned how to make feedforward neural networks and train them, I really wanted to learn how to make recurrent neural networks (RNNs). I understood that they were for temporal/sequential data and thus they could learn relationships through time. But I could not for the life of me figure out how to make the jump from a feedforward neural net to an RNN until I watched this youtube video: https://www.youtube.com/watch?v=e2sGq_vI41s (which I highly suggest you watch) by Jeff Heaton. Then I understood that RNNs can be implemented almost exactly like an ordinary feedforward neural network. I will re-explain some of the contents of that video here as I build a simple recurrent (Elman) neural network to solve a temporal version of the XOR problem (my favorite toy problem). I will also show you how to do basic time series/sequence prediction with a mini-mini-char-RNN implementation.</p>\n<h4>Converting to Sequential Data: XOR</h4>\n<p>We're going to build a simple recurrent neural network to solve a sequential/temporal version of the XOR problem.\n<br />Just as a reminder, here is the truth table for XOR.</p>\n<table>\n<tr><td>$x_1$</td><td>$x_2$</td><td>$y$</td></tr>\n<tr><td>$0$</td><td>$0$</td><td>$0$</td></tr>\n<tr><td>$0$</td><td>$1$</td><td>$1$</td></tr>\n<tr><td>$1$</td><td>$0$</td><td>$1$</td></tr>\n<tr><td>$1$</td><td>$1$</td><td>$0$</td></tr>\n</table>\n<p>\nSo normally, in a feedforward neural network, we would feed each training example as a tuple $(x_1, x_2)$ and we would expect an output $h(x)$ that closely matches $y$ if the network has been trained. As review, here's what our ordinary feedforward XOR architecture looks like:\n\n<img src=\"images/SimpleRNN/XORnormal.png\" />\n\nIn an RNN, we're going to add in the time dimension. But how? Well we simply reformat our training data to be in a time-dependent sequence.</p>\n<p>Here's our new (temporal) training data:</p>\n<table style=\"width:150px;\">\n<tr><td>$x$</td><td>$y$</td><td>$t$</td></tr>\n<tr><td>$0$</td><td>?</td><td>$0$</td></tr>\n<tr><td>$0$</td><td>0</td><td>$1$</td></tr>\n<tr><td>$1$</td><td>1</td><td>$2$</td></tr>\n<tr><td>$1$</td><td>0</td><td>$3$</td></tr>\n<tr><td>$0$</td><td>1</td><td>$4$</td></tr>\n<tr><td>$...x_n$</td><td>$...y_n$</td><td>$...t_n$</td></tr>\n</table>\n\n<p>Where <span class=\"math\">\\(x ... x_n\\)</span> represents our training data, <span class=\"math\">\\(y...y_n\\)</span> are the corresponding expected values, and <span class=\"math\">\\(t ... t_n $ represents our time steps. I arranged a sequence of bits [0 0 1 1 0] such that we can XOR the current bit and the previous bit to get the result. For every-time step our RNN is going to make output the XOR of the previous 2 bits, so notice that after the first bit $y=?\\)</span> because there is no previous bit to XOR, so we just ignore what the RNN outputs. But for <span class=\"math\">\\(x=0, t=1\\)</span> we see that <span class=\"math\">\\(y=0\\)</span> because XOR(0,0)=0.  Also notice how <span class=\"math\">\\(time\\)</span> is in discrete, integer, steps. Some algorithms may actually have continous time implementation and that's something I'll likely explore in a future post. Let's take another look at our sequential data written horizontally as numpy code:</p>\n<div class=\"highlight\"><pre><span></span><code><span class=\"n\">X</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">matrix</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0;0;1;1;0]&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">Y</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">matrix</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0;0;1;0;1]&#39;</span><span class=\"p\">)</span> <span class=\"c1\">#first bit should be ignored, just arbitrarily putting 0</span>\n</code></pre></div>\n\n<p>\nSo what do we do with our sequential XOR data and what does our neural network look like? Well, we're simply going to feed each (one at a time) $x$ value into our neural network and expect one output value at a time. Instead of having 2 input units (excluding bias), we only need one now:\n<img src=\"images/SimpleRNN/XORrnn.png\" />\n</p>\n\n<p>What's that loop and $t-1$ thing? Well it means we're going to take our output from the hidden layer at time $t_n$ and feed it back into our hidden layer as additional input at $t_{n+1}$ (the next time step), or we could rephrase that to say that our hidden layer input at $t_n$ includes the output of the hidden layer from $t_{n-1}$ (the previous time step).\n</p>\n<p>\nYou might be wondering how this is any more useful than an ordinary feedforward NN, and the answer is it's not really. For a problem like XOR, I can't think of a reason why you'd ever want to use an RNN over a feedforward. We're just using it here because it's familiar and I'm a reductionist. But after we get this down, we'll move onto something where RNNs really shine: sequence prediction (in our case, predicting the next character in a sequence).\n</p>\n\n<h3>The Elman Neural Network</h3>\n<p>An Elman network is in the class of \"simple recurrent neural networks\" (presumably because they really are simple, with no frills) and it's the type of RNN we're going to build to solve our temporal XOR problem. Here's what it looks like when applied to our XOR problem:</p>\n<p><img src=\"images/SimpleRNN/XORrnnFull.png\" /></p>\n<p>where $\\theta_1$ refers to the weights between the input layer and the hidden layer (a 6x4 matrix) and $\\theta_2$ refers to our weights in between the hidden layer and our output layer (a 5x1 matrix).</p>\n<p>\nOkay so everything should make sense here except those 4 units labeled $C_1 - C_4$. Those are called <em>context</em> units in the parlance of simple RNNs. These context units are additional input units that feed the output from $t_{n-1}$'s hidden layer back into $t_n$'s hidden layer. They're treated exactly like a normal input unit, with adjustable weights. (At $t = 0$ there is no history to remember, so we have to initialize our network's context units with something, generally 0s.) Notice that we have the <b>same number of context units as we do hidden units</b>, that's by design and is simply the architecture of an Elman network.\n</p>\n<p>\nSo what we've done here by adding context units that feed the previous time step's state into the current time step is to turn that diagram with the t-1 loop into essentially an ordinary feedforward neural network. And since it's a feedforward neural network, we can train it exactly like we do with a feed forward XOR neural network: backpropagation (it often get's called <em>backpropagation through time</em> but it's just a different name for the same thing).</p>\n<p>\nLet's walk through the flow of how this works in the feedforward direction for 2 time steps.\n<ul>\n<li>1. $t=0$. Start with $x_1 = 0$ (first element in our list), intialize $C_1 - C_4$ to input 0s.</li>\n<li>2. Feed those inputs (from bottom to top, $x_1, c_4, c_3, c_2, c_1, B_1$): [0,0,0,0,0,1] into the hidden layer (of course we multiply by $\\theta_1$).</li>\n<li>3. The hidden layer outputs $a_4, a_3, a_2, a_1, B_2$. We'll then store these values (except bias, $B_2$) in another temporary vector for the next time step. </li>\n<li>4. Then our output unit uses the hidden layer outputs to produce the final output, $g(x)$</li>\n<li>5. $t=1$ (next time step). So still $x_1 = 0$ (second element in our list), intialize $C_1 - C_4$ to the stored outputs of $H_1 - H_4$ from the last time we ran the network forward.</li>\n<li>6. Feed those inputs (from bottom to top, $x_1, c_4, c_3, c_2, c_1, B_1$): [0, $H_4^{t-1}, H_3^{t-1}, H_2^{t-1}, H_1^{t-1}$, 1] into the hidden layer.</li>\n<li>7. The hidden layer outputs $a_4, a_3, a_2, a_1, B_2$. We'll then store these values in the temporary vector for the next time step.</li>\n<li>8. Then our output unit uses the hidden layer outputs to produce the final output, $g(x)$</li>\n</ul>\n</p>\n<p>\n<b>Important Notes:</b> As mentioned before, we treat the context units just like ordinary input units, that means they have weighted connections between them and the hidden layer, but their input does not go through any activation function nor do we manipulate those values in anyway before we feed them back in the next time step.\n</p>\n\n<h3>Let's build it (updated)</h3>\n<p>So as mentioned before, when I originally posted this article I attemped to train it using ordinary backpropagation/gradient descent (with momentum), and it was not reliably working. So rather than posting some code that may or may not work for you, I'm going to use scipy's optimize functions to help out the training (and even then it has issues converging sometimes). RNNs are infamously difficult to train compared to NNs. (We'll graph the cost function to see why later.) </p>\n\n<p>\nIf you have taken Andrew Ng's machine learning course, then you should be familiar with Matlab's 'fminunc' (and `fmincg`) optimizer. We're going to use scipy's version, `fmin_tnc` (I'll explain how it works later). Let me just walk through the major points of the following implementation\n<ul>\n<li>I have a cost function defined in a separate file which accepts an 'unrolled' theta vector, so in the cost function we have to assign theta1 and theta2 by slicing the long thetaVec. This cost function returns the cost ('J') and the gradient (an unrolled vector containing theta1_grad and theta2_grad).</li>\n<li> In the main code to follow, we give scipy's `fmin_tnc` our cost function and some initial weights and it quickly finds an optimal set of weights. `fmin_tnc` will return the optimal weights as an unrolled vector.</li>\n<li>After we define theta1 and theta2 from the optimal weights returned, we run the network forward on a different sequence of bits to see if it really learned how to XOR the sequence one step at a time.</li>\n</ul>\n</p>\n\n<div class=\"highlight\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"kn\">from</span> <span class=\"nn\">sigmoid</span> <span class=\"kn\">import</span> <span class=\"n\">sigmoid</span>\n<span class=\"kn\">from</span> <span class=\"nn\">scipy</span> <span class=\"kn\">import</span> <span class=\"n\">optimize</span>\n<span class=\"kn\">import</span> <span class=\"nn\">cost_xorRNN</span> <span class=\"k\">as</span> <span class=\"nn\">cr</span> <span class=\"c1\">#I defined the cost function in a separate file</span>\n<span class=\"n\">X</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">matrix</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0;0;1;1;0]&#39;</span><span class=\"p\">)</span> <span class=\"c1\">#training data</span>\n<span class=\"n\">Y</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">matrix</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0;0;1;0;1]&#39;</span><span class=\"p\">)</span> <span class=\"c1\">#expect y values for every pair in the sequence of X</span>\n<span class=\"n\">numIn</span><span class=\"p\">,</span> <span class=\"n\">numHid</span><span class=\"p\">,</span> <span class=\"n\">numOut</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">1</span>\n<span class=\"c1\">#initial, randomized weights:</span>\n<span class=\"n\">theta1</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">matrix</span><span class=\"p\">(</span> <span class=\"mf\">0.5</span> <span class=\"o\">*</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sqrt</span> <span class=\"p\">(</span> <span class=\"mi\">6</span> <span class=\"o\">/</span> <span class=\"p\">(</span> <span class=\"n\">numIn</span> <span class=\"o\">+</span> <span class=\"n\">numHid</span><span class=\"p\">)</span> <span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">randn</span><span class=\"p\">(</span> <span class=\"n\">numIn</span> <span class=\"o\">+</span> <span class=\"n\">numHid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">numHid</span> <span class=\"p\">)</span> <span class=\"p\">)</span>\n<span class=\"n\">theta2</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">matrix</span><span class=\"p\">(</span> <span class=\"mf\">0.5</span> <span class=\"o\">*</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sqrt</span> <span class=\"p\">(</span> <span class=\"mi\">6</span> <span class=\"o\">/</span> <span class=\"p\">(</span> <span class=\"n\">numHid</span> <span class=\"o\">+</span> <span class=\"n\">numOut</span> <span class=\"p\">)</span> <span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">randn</span><span class=\"p\">(</span> <span class=\"n\">numHid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">numOut</span> <span class=\"p\">)</span> <span class=\"p\">)</span>\n<span class=\"c1\">#we&#39;re going to concatenate or &#39;unroll&#39; theta1 and theta2 into a 1-dimensional, long vector</span>\n<span class=\"n\">thetaVec</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">concatenate</span><span class=\"p\">((</span><span class=\"n\">theta1</span><span class=\"o\">.</span><span class=\"n\">flatten</span><span class=\"p\">(),</span> <span class=\"n\">theta2</span><span class=\"o\">.</span><span class=\"n\">flatten</span><span class=\"p\">()),</span> <span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"c1\">#give the optimizer our cost function and our unrolled weight vector</span>\n<span class=\"n\">opt</span> <span class=\"o\">=</span> <span class=\"n\">optimize</span><span class=\"o\">.</span><span class=\"n\">fmin_tnc</span><span class=\"p\">(</span><span class=\"n\">cr</span><span class=\"o\">.</span><span class=\"n\">costRNN</span><span class=\"p\">,</span> <span class=\"n\">thetaVec</span><span class=\"p\">,</span> <span class=\"n\">args</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">,</span> <span class=\"n\">Y</span><span class=\"p\">),</span> <span class=\"n\">maxfun</span><span class=\"o\">=</span><span class=\"mi\">5000</span><span class=\"p\">)</span>\n<span class=\"c1\">#retrieve the optimal weights</span>\n<span class=\"n\">optTheta</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">(</span><span class=\"n\">opt</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span>\n<span class=\"c1\">#reconstitute our original 2 weight vectors</span>\n<span class=\"n\">theta1</span> <span class=\"o\">=</span> <span class=\"n\">optTheta</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">:</span><span class=\"mi\">24</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">(</span><span class=\"mi\">6</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">)</span>\n<span class=\"n\">theta2</span> <span class=\"o\">=</span> <span class=\"n\">optTheta</span><span class=\"p\">[</span><span class=\"mi\">24</span><span class=\"p\">:]</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">runForward</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">,</span> <span class=\"n\">theta1</span><span class=\"p\">,</span> <span class=\"n\">theta2</span><span class=\"p\">):</span>\n    <span class=\"n\">m</span> <span class=\"o\">=</span> <span class=\"n\">X</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n    <span class=\"c1\">#forward propagation</span>\n    <span class=\"n\">hid_last</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">zeros</span><span class=\"p\">((</span><span class=\"n\">numHid</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">))</span> <span class=\"c1\">#context units</span>\n    <span class=\"n\">results</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">zeros</span><span class=\"p\">((</span><span class=\"n\">m</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">))</span> <span class=\"c1\">#to save the output</span>\n    <span class=\"k\">for</span> <span class=\"n\">j</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"p\">):</span><span class=\"c1\">#for every input element</span>\n        <span class=\"n\">context</span> <span class=\"o\">=</span> <span class=\"n\">hid_last</span>\n        <span class=\"n\">x_context</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">concatenate</span><span class=\"p\">((</span><span class=\"n\">X</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">,:],</span> <span class=\"n\">context</span><span class=\"p\">))</span>\n        <span class=\"n\">a1</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">matrix</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">concatenate</span><span class=\"p\">((</span><span class=\"n\">x_context</span><span class=\"p\">,</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">matrix</span><span class=\"p\">(</span><span class=\"s1\">&#39;[1]&#39;</span><span class=\"p\">))))</span><span class=\"c1\">#add bias, context units to input layer</span>\n        <span class=\"n\">z2</span> <span class=\"o\">=</span> <span class=\"n\">theta1</span><span class=\"o\">.</span><span class=\"n\">T</span> <span class=\"o\">*</span> <span class=\"n\">a1</span>\n        <span class=\"n\">a2</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">concatenate</span><span class=\"p\">((</span><span class=\"n\">sigmoid</span><span class=\"p\">(</span><span class=\"n\">z2</span><span class=\"p\">),</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">matrix</span><span class=\"p\">(</span><span class=\"s1\">&#39;[1]&#39;</span><span class=\"p\">)))</span> <span class=\"c1\">#add bias, output hidden layer</span>\n        <span class=\"n\">hid_last</span> <span class=\"o\">=</span> <span class=\"n\">a2</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">:</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]</span>\n        <span class=\"n\">z3</span> <span class=\"o\">=</span> <span class=\"n\">theta2</span><span class=\"o\">.</span><span class=\"n\">T</span> <span class=\"o\">*</span> <span class=\"n\">a2</span>\n        <span class=\"n\">a3</span> <span class=\"o\">=</span> <span class=\"n\">sigmoid</span><span class=\"p\">(</span><span class=\"n\">z3</span><span class=\"p\">)</span>\n        <span class=\"n\">results</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">a3</span>\n    <span class=\"k\">return</span> <span class=\"n\">results</span>\n\n<span class=\"n\">Xt</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">matrix</span><span class=\"p\">(</span><span class=\"s1\">&#39;[1;0;0;1;1;0]&#39;</span><span class=\"p\">)</span> <span class=\"c1\">#test it out on some new data</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">round</span><span class=\"p\">(</span><span class=\"n\">runForward</span><span class=\"p\">(</span><span class=\"n\">Xt</span><span class=\"p\">,</span> <span class=\"n\">theta1</span><span class=\"p\">,</span> <span class=\"n\">theta2</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">T</span><span class=\"p\">))</span>\n</code></pre></div>\n\n<div class=\"highlight\"><pre><span></span><code>[[ 0.  1.  0.  1.  0.  1.]]\n</code></pre></div>\n\n<p>\nCool! It worked. Remember, ignore the first bit of the output, it can't XOR just 1 digit. The rest of the sequence [1 0 1 0 1] matches with XOR of each pair of bits along the sequence. You might have to run this code a couple of times before it works because even when using a fancy optimizer, this thing is hard to train. Also try changing how we initialize the weights. Unfortunately scipy's `fmin_tnc` doesn't seem to work as well as Matlab's `fmincg` (I originally wrote this in Matlab and ported to Python; `fmincg` trains it alot more reliably) and I'm not sure why (email me if you know).\n</p>\n<p>\nAlso note I imported \"sigmoid\" which is a separate file that only contains the sigmoid function and 'cost_xorRNN' which is the cost function.. I'll reproduce both below so you can run everything on your own.\n</p>\n\n<div class=\"highlight\"><pre><span></span><code><span class=\"c1\">#sigmoid.py</span>\n<span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"k\">def</span> <span class=\"nf\">sigmoid</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">matrix</span><span class=\"p\">(</span><span class=\"mf\">1.0</span> <span class=\"o\">/</span> <span class=\"p\">(</span><span class=\"mf\">1.0</span> <span class=\"o\">+</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">exp</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"n\">x</span><span class=\"p\">)))</span>\n</code></pre></div>\n\n<div class=\"highlight\"><pre><span></span><code><span class=\"c1\">#cost_xorRNN.py</span>\n<span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"kn\">from</span> <span class=\"nn\">sigmoid</span> <span class=\"kn\">import</span> <span class=\"n\">sigmoid</span>\n<span class=\"k\">def</span> <span class=\"nf\">costRNN</span><span class=\"p\">(</span><span class=\"n\">thetaVec</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">):</span>\n    <span class=\"n\">X</span> <span class=\"o\">=</span> <span class=\"n\">args</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n    <span class=\"n\">Y</span> <span class=\"o\">=</span> <span class=\"n\">args</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n    <span class=\"n\">numIn</span><span class=\"p\">,</span> <span class=\"n\">numHid</span><span class=\"p\">,</span> <span class=\"n\">numOut</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">1</span>\n    <span class=\"c1\">#reconstitute our theta1 and theta2 from the unrolled thetaVec</span>\n    <span class=\"n\">theta1</span> <span class=\"o\">=</span> <span class=\"n\">thetaVec</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">:</span><span class=\"mi\">24</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">(</span><span class=\"n\">numIn</span> <span class=\"o\">+</span> <span class=\"n\">numHid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">numHid</span><span class=\"p\">)</span>\n    <span class=\"n\">theta2</span> <span class=\"o\">=</span> <span class=\"n\">thetaVec</span><span class=\"p\">[</span><span class=\"mi\">24</span><span class=\"p\">:]</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">(</span><span class=\"n\">numHid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">numOut</span><span class=\"p\">)</span>\n    <span class=\"c1\">#initialize our gradient vectors</span>\n    <span class=\"n\">theta1_grad</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">zeros</span><span class=\"p\">((</span><span class=\"n\">numIn</span> <span class=\"o\">+</span> <span class=\"n\">numHid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">numHid</span><span class=\"p\">))</span>\n    <span class=\"n\">theta2_grad</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">zeros</span><span class=\"p\">((</span><span class=\"n\">numHid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">numOut</span><span class=\"p\">))</span>\n    <span class=\"c1\">#this will keep track of the output from the hidden layer</span>\n    <span class=\"n\">hid_last</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">zeros</span><span class=\"p\">((</span><span class=\"n\">numHid</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">))</span>\n    <span class=\"n\">m</span> <span class=\"o\">=</span> <span class=\"n\">X</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n    <span class=\"n\">J</span> <span class=\"o\">=</span> <span class=\"mi\">0</span> <span class=\"c1\">#cost output</span>\n    <span class=\"n\">results</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">zeros</span><span class=\"p\">((</span><span class=\"n\">m</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">))</span> <span class=\"c1\">#to store the output of the network</span>\n    <span class=\"c1\">#this is to find the gradients:</span>\n    <span class=\"k\">for</span> <span class=\"n\">j</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"p\">):</span> <span class=\"c1\">#for every training element</span>\n        <span class=\"c1\">#y = X[j+1,:] #expected output, the next element in the sequence</span>\n        <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">Y</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]</span>\n        <span class=\"n\">context</span> <span class=\"o\">=</span> <span class=\"n\">hid_last</span>\n        <span class=\"n\">x_context</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">concatenate</span><span class=\"p\">((</span><span class=\"n\">X</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">],</span> <span class=\"n\">context</span><span class=\"p\">))</span> <span class=\"c1\">#add the context units to our input layer</span>\n        <span class=\"n\">a1</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">matrix</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">concatenate</span><span class=\"p\">((</span><span class=\"n\">x_context</span><span class=\"p\">,</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">matrix</span><span class=\"p\">(</span><span class=\"s1\">&#39;[1]&#39;</span><span class=\"p\">))))</span><span class=\"c1\">#add bias, context units to input layer; 3x1</span>\n        <span class=\"n\">z2</span> <span class=\"o\">=</span> <span class=\"n\">theta1</span><span class=\"o\">.</span><span class=\"n\">T</span> <span class=\"o\">*</span> <span class=\"n\">a1</span><span class=\"p\">;</span> <span class=\"c1\">#2x1</span>\n        <span class=\"n\">a2</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">concatenate</span><span class=\"p\">((</span><span class=\"n\">sigmoid</span><span class=\"p\">(</span><span class=\"n\">z2</span><span class=\"p\">),</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">matrix</span><span class=\"p\">(</span><span class=\"s1\">&#39;[1]&#39;</span><span class=\"p\">)))</span> <span class=\"c1\">#add bias, output hidden layer; 3x1</span>\n        <span class=\"n\">hid_last</span> <span class=\"o\">=</span> <span class=\"n\">a2</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">:</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">];</span>\n        <span class=\"n\">z3</span> <span class=\"o\">=</span> <span class=\"n\">theta2</span><span class=\"o\">.</span><span class=\"n\">T</span> <span class=\"o\">*</span> <span class=\"n\">a2</span> <span class=\"c1\">#1x1</span>\n        <span class=\"n\">a3</span> <span class=\"o\">=</span> <span class=\"n\">sigmoid</span><span class=\"p\">(</span><span class=\"n\">z3</span><span class=\"p\">)</span>\n        <span class=\"n\">results</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">a3</span>\n        <span class=\"c1\">#Backpropagation:::</span>\n        <span class=\"c1\">#calculate delta errors</span>\n        <span class=\"n\">d3</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">a3</span> <span class=\"o\">-</span> <span class=\"n\">y</span><span class=\"p\">)</span>\n        <span class=\"n\">d2</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">multiply</span><span class=\"p\">((</span><span class=\"n\">theta2</span> <span class=\"o\">*</span> <span class=\"n\">d3</span><span class=\"p\">),</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">multiply</span><span class=\"p\">(</span><span class=\"n\">a2</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">-</span> <span class=\"n\">a2</span><span class=\"p\">)))</span>\n        <span class=\"c1\">#accumulate gradients</span>\n        <span class=\"n\">theta1_grad</span> <span class=\"o\">=</span> <span class=\"n\">theta1_grad</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">d2</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">:</span><span class=\"n\">numHid</span><span class=\"p\">,</span> <span class=\"p\">:]</span> <span class=\"o\">*</span> <span class=\"n\">a1</span><span class=\"o\">.</span><span class=\"n\">T</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">T</span>\n        <span class=\"n\">theta2_grad</span> <span class=\"o\">=</span> <span class=\"n\">theta2_grad</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">d3</span> <span class=\"o\">*</span> <span class=\"n\">a2</span><span class=\"o\">.</span><span class=\"n\">T</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">T</span>\n    <span class=\"c1\">#calculate the network cost</span>\n    <span class=\"k\">for</span> <span class=\"n\">n</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"p\">):</span>\n        <span class=\"n\">a3n</span> <span class=\"o\">=</span> <span class=\"n\">results</span><span class=\"p\">[</span><span class=\"n\">n</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">T</span>\n        <span class=\"n\">yn</span> <span class=\"o\">=</span> <span class=\"n\">Y</span><span class=\"p\">[</span><span class=\"n\">n</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">T</span>\n        <span class=\"n\">J</span> <span class=\"o\">=</span> <span class=\"n\">J</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"o\">-</span><span class=\"n\">yn</span><span class=\"o\">.</span><span class=\"n\">T</span> <span class=\"o\">*</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">log</span><span class=\"p\">(</span><span class=\"n\">a3n</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"o\">-</span><span class=\"n\">yn</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">T</span> <span class=\"o\">*</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">log</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"o\">-</span><span class=\"n\">a3n</span><span class=\"p\">))</span> <span class=\"c1\">#cross-entropy cost function</span>\n    <span class=\"n\">J</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"o\">/</span><span class=\"n\">m</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"n\">J</span>\n    <span class=\"n\">grad</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">concatenate</span><span class=\"p\">((</span><span class=\"n\">theta1_grad</span><span class=\"o\">.</span><span class=\"n\">flatten</span><span class=\"p\">(),</span> <span class=\"n\">theta2_grad</span><span class=\"o\">.</span><span class=\"n\">flatten</span><span class=\"p\">()),</span> <span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"c1\">#unroll our gradients</span>\n    <span class=\"k\">return</span> <span class=\"n\">J</span><span class=\"p\">,</span> <span class=\"n\">grad</span>\n</code></pre></div>\n\n<p>Everything should look fairly familiar if you've gone through my post on gradient descent and backpropagation, or already have a decent handle on building an XOR-capable feedforward network, but let me walk through the important/new parts of the code.\n</p>\n<p>1. Every training iteration, we temporarily save the hidden layer outputs in `hid_last` and then at the start of the next training iteration, we initialize our context units to what we stored in `hid_last`.\n</p>\n\n<div class=\"highlight\"><pre><span></span><code><span class=\"n\">context</span> <span class=\"o\">=</span> <span class=\"n\">hid_last</span>\n</code></pre></div>\n\n<p>\n2. We have 4 context units, we add/concatenate them with our 1 input unit $X_1$ (and the bias of course), so our total input layer contains 6 units. This means our `theta1` is a 6x4 matrix (6 inputs projecting to 4 hidden units). Our hidden layer has 4 hidden units + 1 bias, so `theta2` is a 5x1 matrix. Other than these manipulations, the network is virtually identical to an ordinary feedforward network.\n</p>\n\n<p>\n3. In case the 'unrolling' of matrices is unclear... When we unroll theta1 and theta2 into a single vector, `thetaVec`, we simply flatten those vectors into a 1 dimensional sequence and concatenate them. So `theta1` is a 6x4 matrix (24 total elements) which we flatten to a 24 element vector, and we likewise flatten `theta` (5x1 = 5 elements) to a 5 element vector, then concatenate them in order to produce a 29 element vector, `thetaVec`. Thus the first 24 elements of this vector are `theta1` and the last 5 arre `theta2`, so we can rebuild our original vectors by slicing up `thetaVec` and using `.reshape()` to give us matrices of the proper dimensions.\n<br /><br />\n4. Let's discuss the scipy optimizer.\n</p>\n\n<div class=\"highlight\"><pre><span></span><code><span class=\"n\">opt</span> <span class=\"o\">=</span> <span class=\"n\">optimize</span><span class=\"o\">.</span><span class=\"n\">fmin_tnc</span><span class=\"p\">(</span><span class=\"n\">cr</span><span class=\"o\">.</span><span class=\"n\">costRNN</span><span class=\"p\">,</span> <span class=\"n\">thetaVec</span><span class=\"p\">,</span> <span class=\"n\">args</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">,</span> <span class=\"n\">Y</span><span class=\"p\">),</span> <span class=\"n\">maxfun</span><span class=\"o\">=</span><span class=\"mi\">2000</span><span class=\"p\">)</span>\n</code></pre></div>\n\n<p>\nScipy's optimizer `fmin_tnc` just wants the reference to our cost function (i.e we're passing the object itself, not calling the function, hence we don't do `cr.costRNN(...)`. But if we do that, how do we pass in the arguments it expects? Well `fmin_tnc` will assume that the first argument of our cost function is supposed to be the unrolled theta vector and thus the 2nd argument to `fmin_tnc` is `thetaVec` which we randomly initialize. The optmizer will iteratively modify and improve the thetaVec we originally pass in.</p>\n<p>But wait, our cost function also expects `X` and `Y` parameters! We defined the second argument in our cost function to be `*args` which essentially allows us to accept a tuple of arguments there, and that's what `fmin_tnc` is going to do. We give `fmin_tnc` an `args=()` parameter which is a tuple of additional arguments to pass into our cost function. In our case, we just want to pass in our X and Y vectors.\n</p>\n<p>\nThe 4th parameter we give to `fmin_tnc` is `maxfun=5000` which refers to the maximum number of times the optimizer is allowed to call our cost function. It isn't necessary to set this, but I decided to set it to be higher than default to allow it to hopefully find a better optimum.\n</p>\n<p>\nWhat does `fmin_tnc` return to us? It returns 3 items by default in an array. The first is the only thing we really care about, our optimal weights stored in an unrolled vector. Hence I retrieve it with this line: `optTheta = np.array(opt[0])`  The other 2 return values are the number of times it called our cost function, and a return code string. You can see the documentation here: http://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.optimize.fmin_tnc.html\n</p>\n\n<h4>Why is it so difficult to train this thing?</h4>\n<div class=\"highlight\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"nn\">matplotlib.pyplot</span> <span class=\"k\">as</span> <span class=\"nn\">plt</span>\n<span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"kn\">import</span> <span class=\"nn\">cost_xorRNN</span> <span class=\"k\">as</span> <span class=\"nn\">cr</span>\n<span class=\"o\">%</span><span class=\"n\">matplotlib</span> <span class=\"n\">inline</span>\n<span class=\"n\">thetaVec_f</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">linspace</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"mf\">10.0</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">)</span>\n<span class=\"n\">thetaVec_all</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span> <span class=\"o\">-</span><span class=\"mf\">18.37619967</span><span class=\"p\">,</span>  <span class=\"mf\">124.9886293</span> <span class=\"p\">,</span>    <span class=\"mf\">0.69066491</span><span class=\"p\">,</span>   <span class=\"o\">-</span><span class=\"mf\">2.38403005</span><span class=\"p\">,</span>\n         <span class=\"o\">-</span><span class=\"mf\">2.3863598</span> <span class=\"p\">,</span>   <span class=\"mf\">34.07749817</span><span class=\"p\">,</span>   <span class=\"o\">-</span><span class=\"mf\">4.0086386</span> <span class=\"p\">,</span>  <span class=\"o\">-</span><span class=\"mf\">99.19477153</span><span class=\"p\">,</span>\n          <span class=\"mf\">5.28132817</span><span class=\"p\">,</span>  <span class=\"mf\">154.89424477</span><span class=\"p\">,</span>   <span class=\"mf\">17.32554579</span><span class=\"p\">,</span>  <span class=\"o\">-</span><span class=\"mf\">64.2570698</span> <span class=\"p\">,</span>\n         <span class=\"mf\">16.34582581</span><span class=\"p\">,</span>  <span class=\"o\">-</span><span class=\"mf\">20.79296525</span><span class=\"p\">,</span>  <span class=\"o\">-</span><span class=\"mf\">21.30831168</span><span class=\"p\">,</span>  <span class=\"o\">-</span><span class=\"mf\">15.76185224</span><span class=\"p\">,</span>\n          <span class=\"mf\">4.64747081</span><span class=\"p\">,</span>  <span class=\"o\">-</span><span class=\"mf\">65.70656672</span><span class=\"p\">,</span>   <span class=\"mf\">13.59414862</span><span class=\"p\">,</span>  <span class=\"o\">-</span><span class=\"mf\">53.70279419</span><span class=\"p\">,</span>\n        <span class=\"mf\">113.13004224</span><span class=\"p\">,</span>  <span class=\"o\">-</span><span class=\"mf\">33.56398667</span><span class=\"p\">,</span>    <span class=\"mf\">0.7257491</span> <span class=\"p\">,</span>   <span class=\"o\">-</span><span class=\"mf\">9.27982256</span><span class=\"p\">,</span>\n        <span class=\"o\">-</span><span class=\"mf\">18.29977063</span><span class=\"p\">,</span>  <span class=\"mf\">129.48720956</span><span class=\"p\">,</span>  <span class=\"o\">-</span><span class=\"mf\">37.57674034</span><span class=\"p\">,</span>  <span class=\"o\">-</span><span class=\"mf\">30.04523486</span><span class=\"p\">,</span>\n        <span class=\"o\">-</span><span class=\"mf\">90.35656788</span><span class=\"p\">])</span>\n<span class=\"n\">thetaVec_sample</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">concatenate</span><span class=\"p\">((</span><span class=\"n\">thetaVec_all</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">:</span><span class=\"mi\">2</span><span class=\"p\">],</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"n\">theta_</span><span class=\"p\">]),</span> <span class=\"n\">thetaVec_all</span><span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">:]),</span> <span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span> \n                   <span class=\"k\">for</span> <span class=\"n\">theta_</span> <span class=\"ow\">in</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">nditer</span><span class=\"p\">(</span><span class=\"n\">thetaVec_f</span><span class=\"p\">)]</span>\n<span class=\"n\">Xs</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">matrix</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0;0;1;1;0]&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">Ys</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">matrix</span><span class=\"p\">(</span><span class=\"s1\">&#39;[0;0;1;0;1]&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">zs</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"n\">cr</span><span class=\"o\">.</span><span class=\"n\">costRNN</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">(</span><span class=\"n\">theta_s</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">T</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">Xs</span><span class=\"p\">,</span> <span class=\"n\">Ys</span><span class=\"p\">))[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"k\">for</span> <span class=\"n\">theta_s</span> <span class=\"ow\">in</span> <span class=\"n\">thetaVec_sample</span><span class=\"p\">])</span><span class=\"o\">.</span><span class=\"n\">flatten</span><span class=\"p\">()</span>\n<span class=\"n\">ax</span> <span class=\"o\">=</span> <span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">subplot</span><span class=\"p\">(</span><span class=\"mi\">111</span><span class=\"p\">)</span>\n<span class=\"c1\">#ax.set_yscale(&#39;log&#39;) #Try uncommenting this to see a different perspective</span>\n<span class=\"n\">ax</span><span class=\"o\">.</span><span class=\"n\">set_ylabel</span><span class=\"p\">(</span><span class=\"s1\">&#39;Cost&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">ax</span><span class=\"o\">.</span><span class=\"n\">set_xlabel</span><span class=\"p\">(</span><span class=\"s1\">&#39;thetaVec[2]&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">scatter</span><span class=\"p\">(</span><span class=\"n\">thetaVec_f</span><span class=\"p\">,</span> <span class=\"n\">zs</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">()</span>\n</code></pre></div>\n\n<p><img alt=\"png\" src=\"XOR%20RNN%20Tutorial_files/XOR%20RNN%20Tutorial_26_0.png\"></p>\n<p>You don't really need to understand the code behind this graph. Essentially what I'm doing is taking the set of optimal weights returned from the optimization function, and then changing the third weight (arbitrarily chosen) in the unrolled weight vector to between the values of -1 to -10 and calculating the cost for each new set of weights (but of the 29 total weights, only one individual weight is changed). So we're only looking at the cost as a function of <b>1</b> individual weight. The graph looks different if you look at a different weight, but the point is, this is not a nice cost surface. If our initial weight lands somewhere left of 6, then we'll probably be able to gradient descent down to the minimum, but if it lands to the right, we'll probably get stuck in that local minimum. Now imagine all 29 weights in our network having a cost surface like this and you can see how it gets ugly. <b>The take-away here is that RNNs have a lot of local optima that make it really difficult to train with the typical methods we use in feedforward networks.</b> Ideally, we want a cost function that is smooth and convex.\n</p>\n\n<h3>Let's build a mini, mini, mini char-RNN</h3>\n<p>What's \"mini, mini, mini char-RNN\" ? If you're familiar with Karpathy's charRNN (http://karpathy.github.io/2015/05/21/rnn-effectiveness/) then you'll have an idea. We're going to build the simple RNN that predicts the next character in a short word like \"hello\" as presented on his blog. We're just going to modify the RNN we built above with a few key changes:</p>\n<p>1) There is no longer a distinct Y vector of expected values. Our expected values are the next character in the sequence. So if we feed our RNN 'hell' we expect it to return 'ello' to complete the word we trained it on. So <span class=\"math\">\\(y = X[j+1, :]\\)</span>.</p>\n<p>2) Since we have only have 4 characters in our \"vocabularly\", we'll represent them as binary vectors of length 4. I.e. our binary encoding (arbitrarily assigned) is: <code>h = [0 0 1 0], e = [0 1 0 0], l = [0 0 0 1], o = [1 0 0 0]</code></p>\n<p>3) We're going to expand the hidden layer from 4 to 10. Seems to make training faster.</p>\n<p>4) Thus the input layer will now contain: 4 inputs + 10 context units + 1 bias = 11 total. And the output will contain  4 units since each letter is a vector of length 4.</p>\n<p>As before, I'll reproduce the code below (two separate files: RNNoptim.py and cost_charRNN.py; but you could put it all in one file if you want) and explain the important points.</p>\n<div class=\"highlight\"><pre><span></span><code><span class=\"c1\">#cost_charRNN.py OUR COST FUNCTION FILE</span>\n<span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"kn\">from</span> <span class=\"nn\">sigmoid</span> <span class=\"kn\">import</span> <span class=\"n\">sigmoid</span>\n<span class=\"k\">def</span> <span class=\"nf\">costRNN</span><span class=\"p\">(</span><span class=\"n\">thetaVec</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">):</span>\n    <span class=\"n\">X</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">matrix</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">(</span><span class=\"n\">args</span><span class=\"p\">))</span>\n    <span class=\"n\">numIn</span><span class=\"p\">,</span> <span class=\"n\">numHid</span><span class=\"p\">,</span> <span class=\"n\">numOut</span> <span class=\"o\">=</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">4</span>\n    <span class=\"n\">numInTot</span> <span class=\"o\">=</span> <span class=\"n\">numIn</span> <span class=\"o\">+</span> <span class=\"n\">numHid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span>\n    <span class=\"n\">theta1</span> <span class=\"o\">=</span> <span class=\"n\">thetaVec</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">:(</span><span class=\"n\">numInTot</span> <span class=\"o\">*</span> <span class=\"n\">numHid</span><span class=\"p\">)]</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">(</span><span class=\"n\">numInTot</span><span class=\"p\">,</span> <span class=\"n\">numHid</span><span class=\"p\">)</span>\n    <span class=\"n\">theta2</span> <span class=\"o\">=</span> <span class=\"n\">thetaVec</span><span class=\"p\">[(</span><span class=\"n\">numInTot</span> <span class=\"o\">*</span> <span class=\"n\">numHid</span><span class=\"p\">):]</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">(</span><span class=\"n\">numHid</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">numOut</span><span class=\"p\">)</span>\n    <span class=\"n\">theta1_grad</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">zeros</span><span class=\"p\">((</span><span class=\"n\">numInTot</span><span class=\"p\">,</span> <span class=\"n\">numHid</span><span class=\"p\">))</span>\n    <span class=\"n\">theta2_grad</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">zeros</span><span class=\"p\">((</span><span class=\"n\">numHid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">numOut</span><span class=\"p\">))</span>\n    <span class=\"n\">hid_last</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">zeros</span><span class=\"p\">((</span><span class=\"n\">numHid</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">))</span>\n    <span class=\"n\">m</span> <span class=\"o\">=</span> <span class=\"n\">X</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n    <span class=\"n\">J</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n    <span class=\"n\">results</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">zeros</span><span class=\"p\">((</span><span class=\"n\">m</span><span class=\"p\">,</span> <span class=\"n\">numOut</span><span class=\"p\">))</span>\n    <span class=\"k\">for</span> <span class=\"n\">j</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">):</span> <span class=\"c1\">#for every training element</span>\n        <span class=\"c1\">#y = X[j+1,:] #expected output, the next element in the sequence</span>\n        <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">X</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"p\">:]</span>\n        <span class=\"n\">context</span> <span class=\"o\">=</span> <span class=\"n\">hid_last</span>\n        <span class=\"n\">x_context</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">concatenate</span><span class=\"p\">((</span><span class=\"n\">X</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">,</span> <span class=\"p\">:],</span> <span class=\"n\">context</span><span class=\"o\">.</span><span class=\"n\">T</span><span class=\"p\">),</span> <span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n        <span class=\"n\">a1</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">matrix</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">concatenate</span><span class=\"p\">((</span><span class=\"n\">x_context</span><span class=\"p\">,</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">matrix</span><span class=\"p\">(</span><span class=\"s1\">&#39;[1]&#39;</span><span class=\"p\">)),</span> <span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">T</span><span class=\"c1\">#add bias, context units to input layer; 3x1</span>\n        <span class=\"n\">z2</span> <span class=\"o\">=</span> <span class=\"n\">theta1</span><span class=\"o\">.</span><span class=\"n\">T</span> <span class=\"o\">*</span> <span class=\"n\">a1</span><span class=\"p\">;</span> <span class=\"c1\">#2x1</span>\n        <span class=\"n\">a2</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">concatenate</span><span class=\"p\">((</span><span class=\"n\">sigmoid</span><span class=\"p\">(</span><span class=\"n\">z2</span><span class=\"p\">),</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">matrix</span><span class=\"p\">(</span><span class=\"s1\">&#39;[1]&#39;</span><span class=\"p\">)))</span> <span class=\"c1\">#add bias, output hidden layer; 3x1</span>\n        <span class=\"n\">hid_last</span> <span class=\"o\">=</span> <span class=\"n\">a2</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">:</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">];</span>\n        <span class=\"n\">z3</span> <span class=\"o\">=</span> <span class=\"n\">theta2</span><span class=\"o\">.</span><span class=\"n\">T</span> <span class=\"o\">*</span> <span class=\"n\">a2</span> <span class=\"c1\">#1x1</span>\n        <span class=\"n\">a3</span> <span class=\"o\">=</span> <span class=\"n\">sigmoid</span><span class=\"p\">(</span><span class=\"n\">z3</span><span class=\"p\">)</span>\n        <span class=\"n\">results</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">,</span> <span class=\"p\">:]</span> <span class=\"o\">=</span> <span class=\"n\">a3</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">(</span><span class=\"n\">numOut</span><span class=\"p\">,)</span>\n        <span class=\"c1\">#Backpropagation:::</span>\n        <span class=\"c1\">#calculate delta errors</span>\n        <span class=\"n\">d3</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">a3</span><span class=\"o\">.</span><span class=\"n\">T</span> <span class=\"o\">-</span> <span class=\"n\">y</span><span class=\"p\">)</span>\n        <span class=\"n\">d2</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">multiply</span><span class=\"p\">((</span><span class=\"n\">theta2</span> <span class=\"o\">*</span> <span class=\"n\">d3</span><span class=\"o\">.</span><span class=\"n\">T</span><span class=\"p\">),</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">multiply</span><span class=\"p\">(</span><span class=\"n\">a2</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">-</span> <span class=\"n\">a2</span><span class=\"p\">)))</span>\n        <span class=\"c1\">#accumulate gradients</span>\n        <span class=\"n\">theta1_grad</span> <span class=\"o\">=</span> <span class=\"n\">theta1_grad</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">d2</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">:</span><span class=\"n\">numHid</span><span class=\"p\">,</span> <span class=\"p\">:]</span> <span class=\"o\">*</span> <span class=\"n\">a1</span><span class=\"o\">.</span><span class=\"n\">T</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">T</span>\n        <span class=\"n\">theta2_grad</span> <span class=\"o\">=</span> <span class=\"n\">theta2_grad</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">a2</span> <span class=\"o\">*</span> <span class=\"n\">d3</span><span class=\"p\">)</span>\n    <span class=\"k\">for</span> <span class=\"n\">n</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">):</span>\n        <span class=\"n\">a3n</span> <span class=\"o\">=</span> <span class=\"n\">results</span><span class=\"p\">[</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"p\">:]</span><span class=\"o\">.</span><span class=\"n\">T</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">(</span><span class=\"n\">numOut</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n        <span class=\"n\">yn</span> <span class=\"o\">=</span> <span class=\"n\">X</span><span class=\"p\">[</span><span class=\"n\">n</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"p\">:]</span><span class=\"o\">.</span><span class=\"n\">T</span>\n        <span class=\"n\">J</span> <span class=\"o\">=</span> <span class=\"n\">J</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"o\">-</span><span class=\"n\">yn</span><span class=\"o\">.</span><span class=\"n\">T</span> <span class=\"o\">*</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">log</span><span class=\"p\">(</span><span class=\"n\">a3n</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"o\">-</span><span class=\"n\">yn</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">T</span> <span class=\"o\">*</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">log</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"o\">-</span><span class=\"n\">a3n</span><span class=\"p\">))</span>\n    <span class=\"n\">J</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"o\">/</span><span class=\"n\">m</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"n\">J</span>\n    <span class=\"n\">grad</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">concatenate</span><span class=\"p\">((</span><span class=\"n\">theta1_grad</span><span class=\"o\">.</span><span class=\"n\">flatten</span><span class=\"p\">(),</span> <span class=\"n\">theta2_grad</span><span class=\"o\">.</span><span class=\"n\">flatten</span><span class=\"p\">()),</span> <span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">J</span><span class=\"p\">,</span> <span class=\"n\">grad</span>\n</code></pre></div>\n\n<p>That's our cost function file. It accepts an unrolled theta vector and the input data and returns the cost and the gradients. It is virtually the same as before besides the changed layer architecture and the fact that our <span class=\"math\">\\(y\\)</span> (expected output) is just <span class=\"math\">\\(X[j+1]\\)</span></p>\n<div class=\"highlight\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"kn\">from</span> <span class=\"nn\">sigmoid</span> <span class=\"kn\">import</span> <span class=\"n\">sigmoid</span>\n<span class=\"kn\">from</span> <span class=\"nn\">scipy</span> <span class=\"kn\">import</span> <span class=\"n\">optimize</span>\n<span class=\"c1\">#Vocabulary h,e,l,o</span>\n<span class=\"c1\">#Encoding:   h = [0,0,1,0], e = [0,1,0,0], l = [0,0,0,1], o = [1,0,0,0]</span>\n<span class=\"n\">X</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">matrix</span><span class=\"p\">(</span><span class=\"s1\">&#39;0,0,1,0; 0,1,0,0; 0,0,0,1; 0,0,0,1; 1,0,0,0&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">numIn</span><span class=\"p\">,</span> <span class=\"n\">numHid</span><span class=\"p\">,</span> <span class=\"n\">numOut</span> <span class=\"o\">=</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">4</span>\n<span class=\"n\">numInTot</span> <span class=\"o\">=</span> <span class=\"n\">numIn</span> <span class=\"o\">+</span> <span class=\"n\">numHid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span>\n<span class=\"n\">theta1</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">matrix</span><span class=\"p\">(</span> <span class=\"mi\">1</span> <span class=\"o\">*</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sqrt</span> <span class=\"p\">(</span> <span class=\"mi\">6</span> <span class=\"o\">/</span> <span class=\"p\">(</span> <span class=\"n\">numIn</span> <span class=\"o\">+</span> <span class=\"n\">numHid</span><span class=\"p\">)</span> <span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">randn</span><span class=\"p\">(</span> <span class=\"n\">numIn</span> <span class=\"o\">+</span> <span class=\"n\">numHid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">numHid</span> <span class=\"p\">)</span> <span class=\"p\">)</span>\n<span class=\"n\">theta2</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">matrix</span><span class=\"p\">(</span> <span class=\"mi\">1</span> <span class=\"o\">*</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sqrt</span> <span class=\"p\">(</span> <span class=\"mi\">6</span> <span class=\"o\">/</span> <span class=\"p\">(</span> <span class=\"n\">numHid</span> <span class=\"o\">+</span> <span class=\"n\">numOut</span> <span class=\"p\">)</span> <span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">randn</span><span class=\"p\">(</span> <span class=\"n\">numHid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">numOut</span> <span class=\"p\">)</span> <span class=\"p\">)</span>\n<span class=\"n\">thetaVec</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">concatenate</span><span class=\"p\">((</span><span class=\"n\">theta1</span><span class=\"o\">.</span><span class=\"n\">flatten</span><span class=\"p\">(),</span> <span class=\"n\">theta2</span><span class=\"o\">.</span><span class=\"n\">flatten</span><span class=\"p\">()),</span> <span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"n\">opt</span> <span class=\"o\">=</span> <span class=\"n\">optimize</span><span class=\"o\">.</span><span class=\"n\">fmin_tnc</span><span class=\"p\">(</span><span class=\"n\">costRNN</span><span class=\"p\">,</span> <span class=\"n\">thetaVec</span><span class=\"p\">,</span> <span class=\"n\">args</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">),</span> <span class=\"n\">maxfun</span><span class=\"o\">=</span><span class=\"mi\">5000</span><span class=\"p\">)</span>\n<span class=\"n\">optTheta</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">(</span><span class=\"n\">opt</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span>\n<span class=\"n\">theta1</span> <span class=\"o\">=</span> <span class=\"n\">optTheta</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">:(</span><span class=\"n\">numInTot</span> <span class=\"o\">*</span> <span class=\"n\">numHid</span><span class=\"p\">)]</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">(</span><span class=\"n\">numInTot</span><span class=\"p\">,</span> <span class=\"n\">numHid</span><span class=\"p\">)</span>\n<span class=\"n\">theta2</span> <span class=\"o\">=</span> <span class=\"n\">optTheta</span><span class=\"p\">[(</span><span class=\"n\">numInTot</span> <span class=\"o\">*</span> <span class=\"n\">numHid</span><span class=\"p\">):]</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">(</span><span class=\"n\">numHid</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">numOut</span><span class=\"p\">)</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">runForward</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">,</span> <span class=\"n\">theta1</span><span class=\"p\">,</span> <span class=\"n\">theta2</span><span class=\"p\">):</span>\n    <span class=\"n\">m</span> <span class=\"o\">=</span> <span class=\"n\">X</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n    <span class=\"c1\">#forward propagation</span>\n    <span class=\"n\">hid_last</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">zeros</span><span class=\"p\">((</span><span class=\"n\">numHid</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">))</span> <span class=\"c1\">#context units</span>\n    <span class=\"n\">results</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">zeros</span><span class=\"p\">((</span><span class=\"n\">m</span><span class=\"p\">,</span> <span class=\"n\">numOut</span><span class=\"p\">))</span>\n    <span class=\"k\">for</span> <span class=\"n\">j</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"p\">):</span><span class=\"c1\">#for every input element</span>\n        <span class=\"n\">context</span> <span class=\"o\">=</span> <span class=\"n\">hid_last</span>\n        <span class=\"n\">x_context</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">concatenate</span><span class=\"p\">((</span><span class=\"n\">X</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">,:],</span> <span class=\"n\">context</span><span class=\"o\">.</span><span class=\"n\">T</span><span class=\"p\">),</span> <span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n        <span class=\"n\">a1</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">matrix</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">concatenate</span><span class=\"p\">((</span><span class=\"n\">x_context</span><span class=\"p\">,</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">matrix</span><span class=\"p\">(</span><span class=\"s1\">&#39;[1]&#39;</span><span class=\"p\">)),</span> <span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">T</span><span class=\"c1\">#add bias, context units to input layer</span>\n        <span class=\"n\">z2</span> <span class=\"o\">=</span> <span class=\"n\">theta1</span><span class=\"o\">.</span><span class=\"n\">T</span> <span class=\"o\">*</span> <span class=\"n\">a1</span> \n        <span class=\"n\">a2</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">concatenate</span><span class=\"p\">((</span><span class=\"n\">sigmoid</span><span class=\"p\">(</span><span class=\"n\">z2</span><span class=\"p\">),</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">matrix</span><span class=\"p\">(</span><span class=\"s1\">&#39;[1]&#39;</span><span class=\"p\">)))</span> <span class=\"c1\">#add bias, output hidden layer</span>\n        <span class=\"n\">hid_last</span> <span class=\"o\">=</span> <span class=\"n\">a2</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">:</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"c1\">#ignore bias</span>\n        <span class=\"n\">z3</span> <span class=\"o\">=</span> <span class=\"n\">theta2</span><span class=\"o\">.</span><span class=\"n\">T</span> <span class=\"o\">*</span> <span class=\"n\">a2</span>\n        <span class=\"n\">a3</span> <span class=\"o\">=</span> <span class=\"n\">sigmoid</span><span class=\"p\">(</span><span class=\"n\">z3</span><span class=\"p\">)</span>\n        <span class=\"n\">results</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">,</span> <span class=\"p\">:]</span> <span class=\"o\">=</span> <span class=\"n\">a3</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">(</span><span class=\"n\">numOut</span><span class=\"p\">,)</span>\n    <span class=\"k\">return</span> <span class=\"n\">results</span>\n<span class=\"c1\">#This spells &#39;hell&#39; and we expect it to return &#39;ello&#39; as it predicts the next character for each input</span>\n<span class=\"n\">Xt</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">matrix</span><span class=\"p\">(</span><span class=\"s1\">&#39;0,0,1,0; 0,1,0,0; 0,0,0,1; 0,0,0,1&#39;</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">round</span><span class=\"p\">(</span><span class=\"n\">runForward</span><span class=\"p\">(</span><span class=\"n\">Xt</span><span class=\"p\">,</span> <span class=\"n\">theta1</span><span class=\"p\">,</span> <span class=\"n\">theta2</span><span class=\"p\">)))</span>\n</code></pre></div>\n\n<div class=\"highlight\"><pre><span></span><code><span class=\"k\">[[ 0.  1.  0.  0.]</span>\n <span class=\"k\">[ 0.  0.  0.  1.]</span>\n <span class=\"k\">[ 0.  0.  0.  1.]</span>\n <span class=\"k\">[ 1.  0.  0.  0.]]</span>\n</code></pre></div>\n\n<p><b>That's cool.</b> Do you remember our encoding? h = [0,0,1,0], e = [0,1,0,0], l = [0,0,0,1], o = [1,0,0,0]\n<br />\nSo we gave it 'hell' and it returned 'ello' ! That means, when it received the first character, [0,0,1,0] (\"h\"), it returned [ 0.  1.  0.  0.] (\"e\"). It knew what letter is supposed to come next! Neat.</p>\n<p>\nAgain, this is virtually identical to the network we built for XOR just that our input layer accepts binary 4 element vectors and returns 4 element vectors representing characters. We also increased the hidden layer size to 10.\n</p>\n\n<h4>Closing Words</h4>\n<p>If you want to take this farther, try increasing the number of characters you can encode by increasing the input and output layers. I tried (not shown here) up to 11 element vectors, using the letters \"e t a o i n s h r d\" (which are the top 10 highest frequency letters in english) and the space character. With just those 11 characters you can encode alot of words, even sentences. While I got it to work on individual words, training became increasingly difficult for longer input sequences (I tried expanding the hidden layer). My guess is that it just doesn't have enough 'memory' to remember more than a couple of characters back, therefore it won't be able to learn the character sequences of a long word or sentence. Hence why anyone doing 'real' character prediction (like the Karpathy charRNN) uses a much more sophisticated RNN, an LSTM network.</p>\n<p>\nI also attempted to build a character generator from this code, so that we train it on a word or small sentence and then tell it to generate some sequence of characters based on a seed/starting character or word. That didn't work well enough to present here, but if I get it working, I'll make a new post.\n</p>\n<p>Do note that I wrote this code for readability, thus it doesn't follow best coding practices like DRY.</p>\n<p>Also, like I mentioned before, I had to resort to using a scipy optimizer to help train the network rather than use my own implementation of gradient descent like I did with the normal feedforward XOR network in my previous post. I suppose I was experiencing the exploding/vanishing gradient problem and I just didn't have a sophisticated enough gradient descent implementation. If you have any expertise to lend here then please email me (outlacedev@gmail.com). And please email me if you spot any errors.</p>\n\n<h3>References:</h3>\n<ol>\n<li>https://www.youtube.com/watch?v=e2sGq_vI41s (Elman Network Tutorial)</li>\n<li>http://karpathy.github.io/2015/05/21/rnn-effectiveness/</li>\n</ol>\n<script type=\"text/javascript\">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {\n    var align = \"center\",\n        indent = \"0em\",\n        linebreak = \"false\";\n\n    if (false) {\n        align = (screen.width < 768) ? \"left\" : align;\n        indent = (screen.width < 768) ? \"0em\" : indent;\n        linebreak = (screen.width < 768) ? 'true' : linebreak;\n    }\n\n    var mathjaxscript = document.createElement('script');\n    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';\n    mathjaxscript.type = 'text/javascript';\n    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';\n\n    var configscript = document.createElement('script');\n    configscript.type = 'text/x-mathjax-config';\n    configscript[(window.opera ? \"innerHTML\" : \"text\")] =\n        \"MathJax.Hub.Config({\" +\n        \"    config: ['MMLorHTML.js'],\" +\n        \"    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } },\" +\n        \"    jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" +\n        \"    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" +\n        \"    displayAlign: '\"+ align +\"',\" +\n        \"    displayIndent: '\"+ indent +\"',\" +\n        \"    showMathMenu: true,\" +\n        \"    messageStyle: 'normal',\" +\n        \"    tex2jax: { \" +\n        \"        inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" +\n        \"        displayMath: [ ['$$','$$'] ],\" +\n        \"        processEscapes: true,\" +\n        \"        preview: 'TeX',\" +\n        \"    }, \" +\n        \"    'HTML-CSS': { \" +\n        \"        availableFonts: ['STIX', 'TeX'],\" +\n        \"        preferredFont: 'STIX',\" +\n        \"        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" +\n        \"        linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" +\n        \"    }, \" +\n        \"}); \" +\n        \"if ('default' !== 'default') {\" +\n            \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" +\n                \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" +\n                \"VARIANT['normal'].fonts.unshift('MathJax_default');\" +\n                \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" +\n                \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" +\n                \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" +\n            \"});\" +\n            \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" +\n                \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" +\n                \"VARIANT['normal'].fonts.unshift('MathJax_default');\" +\n                \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" +\n                \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" +\n                \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" +\n            \"});\" +\n        \"}\";\n\n    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);\n    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);\n}\n</script>",
  "category": [
    "",
    ""
  ]
}