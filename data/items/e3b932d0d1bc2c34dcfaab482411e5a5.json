{
  "title": "A Weekend with Asyncio",
  "link": "",
  "updated": "2015-08-10T00:00:00+00:00",
  "id": "https://mrocklin.github.io/blog/work/2015/08/10/asyncio-1",
  "content": "<p><em>This work is supported by <a href=\"http://continuum.io\">Continuum Analytics</a>\nand the <a href=\"http://www.darpa.mil/program/XDATA\">XDATA Program</a>\nas part of the <a href=\"http://blaze.pydata.org\">Blaze Project</a></em></p>\n\n<p><strong>tl;dr: I learned asyncio and rewrote part of dask.distributed with it; this\ndetails my experience</strong></p>\n\n<h2 id=\"asyncio\">asyncio</h2>\n\n<p>The <a href=\"https://docs.python.org/3/library/asyncio.html\">asyncio</a> library provides\nconcurrent programming in the style of Go, Clojure’s <code class=\"language-plaintext highlighter-rouge\">core.async</code> library, or\nmore traditional libraries like Twisted.  Asyncio offers a programming paradigm\nthat lets many moving parts interact without involving separate threads.  These\nseparate parts explicitly yield control to each other and to a central\nauthority and then regain control as others yield control to them.  This lets\none escape traps like race conditions to shared state, a web of callbacks, lost\nerror reporting, and general confusion.</p>\n\n<p>I’m not going to write too much about asyncio.  Instead I’m going to briefly\ndescribe my problem, link to a solution, and then dive into good-and-bad points\nabout using <code class=\"language-plaintext highlighter-rouge\">asyncio</code> while they’re fresh in my mind.</p>\n\n<h2 id=\"exercise\">Exercise</h2>\n\n<p><em>I won’t actually discuss the application much after this section; you can\nsafely skip this.</em></p>\n\n<p>I decided to rewrite the\n<a href=\"http://dask.pydata.org/en/latest/distributed.html\"><code class=\"language-plaintext highlighter-rouge\">dask.distributed</code></a> Worker using\nasyncio.  This worker has to do the following:</p>\n\n<ol>\n  <li>Store local data in a dictionary  (easy)</li>\n  <li>Perform computations on that data as requested by a remote connection\n(act as a server in a client-server relationship)</li>\n  <li>Collect data from other workers when we don’t have all of the necessary\ndata for a computation locally (peer-to-peer)</li>\n  <li>Serve data to other workers who need our data for their own computations\n(peer-to-peer)</li>\n</ol>\n\n<p>It’s a sort of distributed RPC mechanism with peer-to-peer value sharing.\nMetadata for who-has-what data is stored in a central metadata store; this\ncould be something like Redis.</p>\n\n<p>The current implementation of this is a nest of threads, queues, and callbacks.\nIt’s not bad and performs well but tends to be hard for others to develop.</p>\n\n<p>Additionally I want to separate the worker code because it’s useful outside of\n<code class=\"language-plaintext highlighter-rouge\">dask.distributed</code>.  Other distributed computation solutions exist in my head\nthat rely on this technology.</p>\n\n<p>For the moment the code lives here:\n<a href=\"https://github.com/mrocklin/dist\">https://github.com/mrocklin/dist</a>.  I like\nthe design.  The <a href=\"https://github.com/mrocklin/dist/blob/master/dist/worker.py\">module-level docstring of\nworker.py</a> is\nshort and informative.  But again, I’m not going to discuss the application\nyet; instead, here are some thoughts on learning/developing with <code class=\"language-plaintext highlighter-rouge\">asyncio</code>.</p>\n\n<h2 id=\"general-thoughts\">General Thoughts</h2>\n\n<p><em>Disclaimer I am a novice concurrent programmer.  I write lots of parallel code\nbut little concurrent code.  I have never used existing frameworks like\nTwisted.</em></p>\n\n<p>I liked the experience of using asyncio and recommend the paradigm to anyone\nbuilding concurrent applications.</p>\n\n<h4 id=\"the-good\">The Good:</h4>\n\n<ul>\n  <li>I can write complex code that involves multiple asynchronous calls,\ncomplex logic, and exception handling all in a single place.  Complex\napplication logic is no longer spread in many places.</li>\n  <li>Debugging is much easier now that I can throw <code class=\"language-plaintext highlighter-rouge\">import pdb; pdb.set_trace()</code>\nlines into my code and expect them to work (this fails when using threads).</li>\n  <li>My code fails more gracefully, further improving the debug experience.\n<code class=\"language-plaintext highlighter-rouge\">Ctrl-C</code> works.</li>\n  <li>The paradigm shared by Go, Clojure’s <code class=\"language-plaintext highlighter-rouge\">core.async</code>, and Python’s <code class=\"language-plaintext highlighter-rouge\">asyncio</code>\nfelt viscerally good.  I was able to reason well about my program as I was\nbuilding it and made nice diagrams about explicitly which sequential\nprocesses interacted with which others over which channels.  I am much more\nconfident of the correctness of the implementation and the design of my\nprogram.  However, after having gone through this exercise I suspect that I\ncould now implement just about the same design without <code class=\"language-plaintext highlighter-rouge\">asyncio</code>.  The\ndesign paradigm was perhaps as important as the library itself.</li>\n  <li>I have to support Python 2.  Fortunately I found the\n<a href=\"https://trollius.readthedocs.org/\">trollius</a> port of <code class=\"language-plaintext highlighter-rouge\">asyncio</code> to be\nvery usable.  It looks like it was a direct fork-then-modify of <code class=\"language-plaintext highlighter-rouge\">tulip</code>.</li>\n</ul>\n\n<h4 id=\"the-bad\">The Bad:</h4>\n\n<ul>\n  <li>There wasn’t a ZeroMQ connectivity layer for Trollius (though\n<a href=\"https://github.com/aio-libs/aiozmq\"><code class=\"language-plaintext highlighter-rouge\">aiozmq</code></a> exists in Python 3) so I\nended up having to use threads anyway for inter-node I/O.  This, combined\nwith ZeroMQ’s finicky behavior did mean that my program crashed hard\nsometimes.  I’m considering switching to plain sockets (which are supported\nnativel by Trollius and asyncio) due to this.</li>\n  <li>While exceptions raise cleanly I can’t determine from where they originate.\nThere are no line numbers or tracebacks.  Debugging in a concurrent\nenvironment is hard; my experience was definitely better than threads but\nstill could be improved.  I hope that <code class=\"language-plaintext highlighter-rouge\">asyncio</code> in Python 3.4 has better\ndebugging support.</li>\n  <li>The API documentation is thorough but stackoverflow, general best\npractices, and example coverage is very sparse.  The project is new so\nthere isn’t much to go on.  I found that reading documentation for Go and\npresentations on Clojure’s <code class=\"language-plaintext highlighter-rouge\">core.async</code> were far more helpful in preparing\nme to use <code class=\"language-plaintext highlighter-rouge\">asyncio</code> than any of the asyncio docs/presentations.</li>\n</ul>\n\n<h2 id=\"future\">Future</h2>\n\n<p>I intend to pursue this into the future and, if the debugging experience is\nbetter in Python 3 am considering rewriting the dask.distributed Scheduler in\nPython 3 with asyncio proper.  This is possible because the Scheduler doesn’t\nhave to be compatible with user code.</p>\n\n<p>I found these videos to be useful:</p>\n\n<ol>\n  <li><a href=\"https://www.youtube.com/watch?v=VrmfuuHW_6w\">Stuart Halloway on <code class=\"language-plaintext highlighter-rouge\">core.async</code></a></li>\n  <li><a href=\"https://www.youtube.com/watch?v=AhxcGGeh5ho\">David Nolen on <code class=\"language-plaintext highlighter-rouge\">core.async</code></a></li>\n</ol>"
}