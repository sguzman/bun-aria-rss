{
  "title": "A Gentle Introduction to Deep Neural Networks with Python",
  "link": "https://kavita-ganesan.com/neural-network-intro/",
  "comments": "https://kavita-ganesan.com/neural-network-intro/#respond",
  "dc:creator": "Kavita Ganesan",
  "pubDate": "Thu, 27 Jan 2022 21:44:08 +0000",
  "category": "AI Implementation",
  "guid": "https://kavita-ganesan.com/?p=6748",
  "description": "This article examines the parts that make up neural networks and deep neural networks, as well as the fundamental different types of models (e.g. regression), their constituent parts (and how they contribute to model accuracy), and which tasks they are designed to learn.",
  "content:encoded": "\n<p><em>This is a guest post from Andrew Ferlitsch, author of <a href=\"https://www.manning.com/books/deep-learning-patterns-and-practices\">Deep Learning Patterns and Practices</a>. &nbsp;It provides an introduction to deep neural networks in Python. Andrew is an expert on computer vision, deep learning, and operationalizing ML in production at Google Cloud AI Developer Relations.</em></p>\n\n\n\n<div class=\"wp-block-image\"><figure class=\"aligncenter size-large is-resized\"><img decoding=\"async\" loading=\"lazy\" src=\"https://kavita-ganesan.com/wp-content/uploads/Ferlitsch-DL-HI-817x1024.png\" alt=\"\" class=\"wp-image-6795\" width=\"174\" height=\"218\" srcset=\"https://kavita-ganesan.com/wp-content/uploads/Ferlitsch-DL-HI-817x1024.png 817w, https://kavita-ganesan.com/wp-content/uploads/Ferlitsch-DL-HI-239x300.png 239w, https://kavita-ganesan.com/wp-content/uploads/Ferlitsch-DL-HI-120x150.png 120w, https://kavita-ganesan.com/wp-content/uploads/Ferlitsch-DL-HI-768x963.png 768w, https://kavita-ganesan.com/wp-content/uploads/Ferlitsch-DL-HI-1225x1536.png 1225w, https://kavita-ganesan.com/wp-content/uploads/Ferlitsch-DL-HI-1633x2048.png 1633w\" sizes=\"(max-width: 174px) 100vw, 174px\" /></figure></div>\n\n\n\n<p class=\"has-black-color has-text-color has-background\" style=\"background-color:#eeeeee\">This article examines the parts that make up neural networks and deep neural networks, as well as the fundamental different types of models (e.g. regression), their constituent parts (and how they contribute to model accuracy), and which tasks they are designed to learn. This article is meant for machine learning engineers who are familiar with Python and deep learning and want to get a thorough intro to the parts and functions of deep neural networks and related models.</p>\n\n\n\t\t\t\t<div class=\"wp-block-uagb-table-of-contents uagb-toc__align-left uagb-toc__columns-1  uagb-block-fc090491    \"\n\t\t\t\t\tdata-scroll= \"1\"\n\t\t\t\t\tdata-offset= \"30\"\n\t\t\t\t>\n\t\t\t\t<div class=\"uagb-toc__wrap\">\n\t\t\t\t\t\t<div class=\"uagb-toc__title\">\n\t\t\t\t\t\t\tTable Of Contents\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<div class=\"uagb-toc__list-wrap\">\n\t\t\t\t\t\t<ol class=\"uagb-toc__list\"><li class=\"uagb-toc__list\"><a href=\"#introduction-to-neural-networks-in-python\">Introduction to Neural Networks in Python</a><li class=\"uagb-toc__list\"><a href=\"#neural-network-basics\">Neural Network Basics</a><ul class=\"uagb-toc__list\"><li class=\"uagb-toc__list\"><a href=\"#input-layer\">Input Layer</a></li></ul></li><li class=\"uagb-toc__list\"><a href=\"#deep-neural-networks-dnn\">Deep Neural Networks (DNN)</a><ul class=\"uagb-toc__list\"><li class=\"uagb-toc__list\"><a href=\"#feed-forward-networks\">Feed Forward networks</a><li class=\"uagb-toc__list\"><a href=\"#sequential-api-method\">Sequential API Method</a><li class=\"uagb-toc__list\"><a href=\"#functional-api-method\">Functional API Method</a><li class=\"uagb-toc__list\"><a href=\"#input-shape-vs-input-layer\">Input Shape vs Input Layer</a><li class=\"uagb-toc__list\"><a href=\"#dense-layer\">Dense Layer</a><li class=\"uagb-toc__list\"><a href=\"#activation-functions\">Activation Functions</a><li class=\"uagb-toc__list\"><a href=\"#shorthand-syntax\">Shorthand Syntax</a></li></ul></li></ul></ol>\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\n\n\n<p></p>\n\n\n\n<h2><strong>Introduction to Neural Networks in Python</strong></h2>\n\n\n\n<p>We will start this article with some basics on neural networks. First, we will cover the input layer to a neural network, then how this is connected to an output layer, and then how hidden layers are added in-between to become what is called a deep neural network. From there, we cover how the layers are made of nodes, how these nodes learn, and how layers are connected to each other to form fully connected neural networks.</p>\n\n\n\n<p>We will also cover the fundamental different types of models. That is, there are different model types, such as regression and classification, which learn different types of tasks. Depending on the task you want to learn, determines the model type you will design a model for.</p>\n\n\n\n<p>We will also cover the fundamentals of weights, biases, activations and optimizers, and how they contribute to the accuracy of the model.</p>\n\n\n\n<h2><strong>Neural Network Basics</strong></h2>\n\n\n\n<p>We will start with some basics on neural networks. First, we will cover the input layer to a neural network, then how this is connected to an output layer, and then how hidden layers are added in-between to become what is called a deep neural network. From there, we cover how the layers are made of nodes, what nodes do, and how layers are connected to each other to form fully connected neural networks.</p>\n\n\n\n<h3><strong>Input Layer</strong></h3>\n\n\n\n<p>The input layer to a neural network takes numbers! All the input data is converted to numbers. Everything is a number. The text becomes numbers, speech becomes numbers, pictures become numbers, and things that are already numbers are just numbers.</p>\n\n\n\n<p>Neural networks take numbers either as vectors, matrices, or tensors. These are simply names for the number of dimensions in an array. A&nbsp;vector&nbsp;is a one-dimensional array, such as a list of numbers. A&nbsp;matrix&nbsp;is a two- dimensional array, like the pixels in a black and white image. And a&nbsp;tensor&nbsp;is any array of three or more dimensions. For example, a three dimensional array is a stack of matrices where each matrix is the same dimension. That&#8217;s it.</p>\n\n\n\n<div class=\"wp-block-image\"><figure class=\"aligncenter size-full is-resized\"><img decoding=\"async\" loading=\"lazy\" src=\"https://kavita-ganesan.com/wp-content/uploads/CH02_F01_Ferlitsch.png\" alt=\"A Gentle Introduction to Deep Neural Networks with Python\" class=\"wp-image-6794\" width=\"437\" height=\"472\" srcset=\"https://kavita-ganesan.com/wp-content/uploads/CH02_F01_Ferlitsch.png 1746w, https://kavita-ganesan.com/wp-content/uploads/CH02_F01_Ferlitsch-278x300.png 278w, https://kavita-ganesan.com/wp-content/uploads/CH02_F01_Ferlitsch-947x1024.png 947w, https://kavita-ganesan.com/wp-content/uploads/CH02_F01_Ferlitsch-139x150.png 139w, https://kavita-ganesan.com/wp-content/uploads/CH02_F01_Ferlitsch-768x830.png 768w, https://kavita-ganesan.com/wp-content/uploads/CH02_F01_Ferlitsch-1421x1536.png 1421w\" sizes=\"(max-width: 437px) 100vw, 437px\" /></figure></div>\n\n\n\n<p class=\"has-text-align-center\"><strong>Fig. 1 Comparison of array shapes and corresponding names in deep learning.</strong></p>\n\n\n\n<p>Speaking of numbers, you might have heard terms like normalization or standardization. In standardization the numbers are converted to be centered around a mean of zero, with one standard deviation on each side of the mean. If you’re saying, &#8216;I don&#8217;t do statistics&#8217; right about now, I know how you feel. But don&#8217;t worry. Packages like&nbsp;scikit-learn&nbsp;and&nbsp;numpy&nbsp;have library calls that do this for you. Standardization is basically a button to push, and it doesn’t even need a lever, so there are no parameters to set.</p>\n\n\n\n<p>Speaking of packages, you&#8217;re going to be using a lot of&nbsp;numpy. What is numpy and why is it so popular? Given the interpretive nature of Python, the language handles large arrays poorly. Like really big, super big arrays of numbers &#8211; thousands, tens of thousands, millions of numbers. Think of Carl Sagan&#8217;s infamous quote on the size of the Universe – “billions and billions of stars.” That&#8217;s a tensor!</p>\n\n\n\n<p>One day a C programmer got the idea to write, in low-level C, a high performance implementation for handling super big arrays, and then added an external Python wrapper. Numpy was born. Today&nbsp;numpy&nbsp;is a class with lots of useful methods and properties, like the property shape which tells you the shape (or dimensions) of the array, and the where() method which allows you to do SQL-like queries on your super big array.</p>\n\n\n\n<p>All Python machine learning frameworks, including TensorFlow and PyTorch, will take as input on the input layer a&nbsp;numpy&nbsp;multidimensional array. And speaking of C, or Java, or C+, &#8230;, the input layer in a neural network is just like the parameters passed to a function in a programming language. That&#8217;s it.</p>\n\n\n\n<p>Let&#8217;s get started by installing Python packages you will need. I assume you have&nbsp;<a href=\"https://www.python.org/downloads/\">Python installed</a>&nbsp;(version 3.X). Whether you directly installed it, or it got installed as part of a larger package, like&nbsp;<a href=\"https://www.anaconda.com/what-is-anaconda/\">Anaconda</a>, you got with it a nifty command-like tool called pip. This tool is used to install any Python package you will ever need again, from a single command invocation. You use pip install and then the name of the package. It goes to the global repository PyPi of Python packages and downloads and installs the package for you. It&#8217;s quite easy.</p>\n\n\n\n<p>We want to start off by downloading and installing the&nbsp;Tensorflow&nbsp;framework, and the&nbsp;numpy&nbsp;package. Guess what their names are in the registry, tensorflow and numpy &#8211; thankfully very obvious. Let&#8217;s do it together. Go to the command line and issue the following:</p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"python\" class=\"language-python\">cmd> pip install tensorflow\ncmd> pip install numpy</code></pre>\n\n\n\n<p>With Tensorflow 2.0, Keras is built-in and the recommended model API, referred to now as&nbsp;TF.Keras.</p>\n\n\n\n<p>TF.Keras&nbsp;is based on object oriented programming with a collection of classes and associated methods and properties. Let&#8217;s start simply. Say we have a dataset of housing data. Each row has fourteen columns of data. One column has the sale price of a home. We are going to call that the &#8220;label&#8221;. The other thirteen columns have information about the house, such as the square footage and property tax. It&#8217;s all numbers. We are going to call those the &#8220;features&#8221;. What we want to do is &#8220;learn&#8221; to predict (or estimate) the &#8220;label&#8221; from the &#8220;features&#8221;. Now before we had all this compute power and these awesome machine learning frameworks, data analysts did this stuff by hand or by using formulas in an Excel spreadsheet with some amount of data and lots and lots of linear algebra.We, however, will use Keras and TensorFlow.</p>\n\n\n\n<p>We will start by first importing the&nbsp;Keras&nbsp;module from&nbsp;TensorFlow, and then instantiate an Input class object. For this class object, we define the shape or dimensions of the input. In our example, the input is a one-dimensional array (a vector) of 13 elements, one for each feature.</p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"python\" class=\"language-python\">from tensorflow.keras import Input\nInput(shape=(13,))</code></pre>\n\n\n\n<p>When you run the above two lines in a notebook, you will see the output:</p>\n\n\n\n<pre class=\"wp-block-preformatted\"><<strong>tf.Tensor</strong> 'input_1:0' shape=(?, 13) dtype=float32></pre>\n\n\n\n<p>This is showing you what Input(shape=(13,)) evaluates to. It produces a tensor object by the name &#8216;input_1:0&#8217;. This name will be useful later in assisting you in debugging your models. The &#8216;?&#8217; in shape shows that the input object takes an unbounded number of entries (your examples or rows) of 13 elements each. That is, at run-time it will bind the number of one-dimensional vectors of 13 elements to the actual number of examples (rows) you pass in, referred to as the (mini) batch size. The &#8216;dtype&#8217; shows the default data type of the elements, which in this case is a 32-bit float (single precision).</p>\n\n\n\n<p class=\"has-background\" style=\"background-color:#eeeeee\">Take 40% off <a href=\"https://www.manning.com/books/deep-learning-patterns-and-practices\"><em>Deep Learning Patterns and Practices</em></a> by entering <strong>fccferlitsch</strong> into the discount code box at checkout at <a href=\"https://www.manning.com/\">manning.com</a>.</p>\n\n\n\n<h2><strong>Deep Neural Networks (DNN)</strong></h2>\n\n\n\n<p>DeepMind, Deep Learning, Deep, Deep, Deep. Oh my, what&#8217;s all this? Deep in this context just means that the neural network has one or more layers between the input layer and the output layer. Visualize a directed graph in layers of depth. The root nodes are the input layer and the terminal nodes are the output layer. The layers in between are known as the hidden or deep layers. So a four-layer DNN architecture would look like this:</p>\n\n\n\n<pre class=\"wp-block-preformatted\">input layer\nhidden layer\nhidden layer\noutput layer</pre>\n\n\n\n<p>To get started, we’ll assume every neural network node in every layer, except the output layer, is the same type of neural network node. And that every node on each layer is connected to every other node on the next layer. This is known as a fully connected neural network (FCNN), as depicted in figure 2. For example, if the input layer has three nodes and the next (hidden) layer has four nodes, then each node on the first layer is connected to all four nodes on the next layer for a total of 12 (3&#215;4) connections.</p>\n\n\n\n<div class=\"wp-block-image\"><figure class=\"aligncenter size-large is-resized\"><img decoding=\"async\" loading=\"lazy\" src=\"https://kavita-ganesan.com/wp-content/uploads/CH02_F02_Ferlitsch-1024x706.png\" alt=\"A Gentle Introduction to Deep Neural Networks with Python\" class=\"wp-image-6793\" width=\"512\" height=\"353\" srcset=\"https://kavita-ganesan.com/wp-content/uploads/CH02_F02_Ferlitsch-1024x706.png 1024w, https://kavita-ganesan.com/wp-content/uploads/CH02_F02_Ferlitsch-300x207.png 300w, https://kavita-ganesan.com/wp-content/uploads/CH02_F02_Ferlitsch-150x103.png 150w, https://kavita-ganesan.com/wp-content/uploads/CH02_F02_Ferlitsch-768x529.png 768w, https://kavita-ganesan.com/wp-content/uploads/CH02_F02_Ferlitsch.png 1336w\" sizes=\"(max-width: 512px) 100vw, 512px\" /></figure></div>\n\n\n\n<p class=\"has-text-align-center\"><strong>Fig. 2 Deep neural networks have one or more hidden layers between the input and output layers. This is a fully-connected network, so the nodes at each level are all connected to each other.</strong></p>\n\n\n\n<h3><strong>Feed Forward networks</strong></h3>\n\n\n\n<p>The DNN and Convolutional Neural Network (CNN), are known as feed forward neural networks. Feed forward means that data moves through the network sequentially, in one direction, from input to output layer). This is analogous to a function in procedural programming. The inputs are passed as parameters in the input layer, the function performs a sequenced set of actions based on the inputs (in the hidden layers) and outputs a result (the output layer).</p>\n\n\n\n<p>When coding a forward feed network in&nbsp;TF.Keras,&nbsp;you will see two distinctive styles in blogs and other tutorials. I will briefly touch on both so when you see a code snippet in one style you can translate it to the other.</p>\n\n\n\n<h3><strong>Sequential API Method</strong></h3>\n\n\n\n<p>The&nbsp;Sequential API&nbsp;method is easier to read and follow for beginners, but the trade-off is that it is less flexible. Essentially, you create an empty forward feed neural network with the&nbsp;Sequential&nbsp;class object, and then &#8220;add&#8221; one layer at a time, until the output layer. In the examples below, the ellipses represent pseudo code.</p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"python\" class=\"language-python\">from tensorflow.keras import Sequential\nmodel = Sequential()\nmodel.add( ...the first layer... )\nmodel.add( ...the next layer... )\nmodel.add( ...the output layer... )\n</code></pre>\n\n\n\n<p class=\"has-background\" style=\"background-color:#eeeeee\"><strong>A Create an empty model.</strong><br><strong>B Placeholders for adding layers in sequential order.</strong></p>\n\n\n\n<p>Alternatively, the layers can be specified in sequential order as a list passed as a parameter when instantiating the&nbsp;Sequential&nbsp;class object.</p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"python\" class=\"language-python\">model = Sequential([ ...the first layer...,\n                     ...the next layer...,\n                     ...the output layer...\n                   ])</code></pre>\n\n\n\n<p>So, you might ask, when would one use the add() method versus specifying as a list in the instantiation of the Sequential object. Well, both methods generate the same model and behavior, so it’s a matter of personal preference. For myself, I tend to use the more verbose add() method in instructional and demonstration material for clarity. But, if I am writing code for production, I will use the sparser list method, where I can visualize and edit the code more easily.</p>\n\n\n\n<h3><strong>Functional API Method</strong></h3>\n\n\n\n<p>The&nbsp;Functional API&nbsp;method is more advanced, allowing you to construct models that are non-sequential in flow &#8211;such as branches, skip links, and multiple inputs and outputs. You build the layers separately and then &#8220;tie&#8221; them together. This latter step gives you the freedom to connect layers in creative ways. Essentially, for a forward feed neural network, you create the layers, bind them to another layer(s), and then pull all the layers together in a final instantiation of a&nbsp;Model&nbsp;class object.</p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"python\" class=\"language-python\">input = layers.(...the first layer...)\nhidden = layers.(...the next layer...)( ...the layer to bind to... )\noutput = layers.(...the output layer...)( /the layer to bind to... )\nmodel = Model(input, output)</code></pre>\n\n\n\n<p></p>\n\n\n\n<h3><strong>Input Shape vs Input Layer</strong></h3>\n\n\n\n<p>The input shape and input layer can be confusing at first. They are not the same thing. More specifically, the number of nodes in the input layer does not need to match the shape of the input vector. That&#8217;s because every element in the input vector will be passed to every node in the input layer, as depicted in figure 2a.</p>\n\n\n\n<div class=\"wp-block-image\"><figure class=\"aligncenter size-full is-resized\"><img decoding=\"async\" loading=\"lazy\" src=\"https://kavita-ganesan.com/wp-content/uploads/CH02_F03_Ferlitsch.png\" alt=\"A Gentle Introduction to Deep Neural Networks with Python\" class=\"wp-image-6792\" width=\"390\" height=\"372\" srcset=\"https://kavita-ganesan.com/wp-content/uploads/CH02_F03_Ferlitsch.png 780w, https://kavita-ganesan.com/wp-content/uploads/CH02_F03_Ferlitsch-300x286.png 300w, https://kavita-ganesan.com/wp-content/uploads/CH02_F03_Ferlitsch-150x143.png 150w, https://kavita-ganesan.com/wp-content/uploads/CH02_F03_Ferlitsch-768x732.png 768w\" sizes=\"(max-width: 390px) 100vw, 390px\" /></figure></div>\n\n\n\n<p class=\"has-text-align-center\"><strong>Fig. 2a Shows the difference between the input (shape) and input layer and how every element in the input is connected to every node in the input layer.</strong></p>\n\n\n\n<p>For example, if our input layer is ten nodes, and we use our earlier example of a thirteen-element input vector, we will have 130 connections (10 x 13) between the input vector and the input layer.</p>\n\n\n\n<p>Each one of these connections between an element in the input vector and a node in the input layer will have a weight and each node in the input layer has a bias. Think of each connection between the input vector and input layer, as well as connections between layers, as sending a signal forward in how strongly it believes the input value will contribute to what the model predictions. We need to have a measurement of the strength of this signal, and that is what the weight does. It is a coefficient that is multiplied against the input value for the input layer, and previous value for subsequent layers. Now each one of these connections is like a vector on an x-y plane. Ideally, we would want each of these vectors to cross the y-axis at the same central point, e.g., 0 origin. But they don’t. To make the vectors relative to each other, the bias is the offset of each vector from the central point on the y-axis.</p>\n\n\n\n<p>The weights and biases are what the neural network will &#8220;learn&#8221; during training. The weights and biases are also referred to as parameters. That is, these values stay with the model after it is trained. This operation will otherwise be invisible to you.</p>\n\n\n\n<h3><strong>Dense Layer</strong></h3>\n\n\n\n<p>In&nbsp;TF.Keras, layers in a fully connected neural network (FCNN) are called&nbsp;Dense&nbsp;layers. A&nbsp;Dense&nbsp;layer is defined as having an &#8220;n&#8221; number of nodes, and is fully connected to the previous layer. Let&#8217;s continue and define in&nbsp;TF.Keras&nbsp;a three layer neural network, using the&nbsp;Sequential API&nbsp;method, for our example. Our input layer will be ten nodes, and take as input a thirteen element vector (i.e., the thirteen features), which will be connected to a second (hidden) layer of ten nodes, which will then be connected to a third (output) layer of one node. Our output layer only needs to be one node, since it will be outputting a single real value (e.g. &#8211; the predicted price of the house). This is an example where we are going to use a neural network as a regressor. That means, the neural network will output a single real number.</p>\n\n\n\n<pre class=\"wp-block-preformatted\">input layer&nbsp; = 10 nodes\nhidden layer = 10 nodes\noutput layer = 1 node</pre>\n\n\n\n<p>For input and hidden layers, we can pick any number of nodes. The more nodes we have, the better the neural network can learn, but more nodes means more complexity and more time in training and predicting.</p>\n\n\n\n<p>In the following code example, we have three&nbsp;add()&nbsp;calls to the class object&nbsp;Dense(). The&nbsp;add()&nbsp;method &#8220;adds&#8221; the layers in the same sequential order we specified them in. The first (positional) parameter is the number of nodes, ten in the first and second layer and one in the third layer. Notice how in the first&nbsp;Dense()&nbsp;layer we added the (keyword) parameter&nbsp;input_shape. This is where we will define the input vector and connect it to the first (input) layer in a single instantiation of&nbsp;Dense().</p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"python\" class=\"language-python\">from tensorflow.keras import Sequential\nfrom tensorflow.keras.layers import Dense\nmodel = Sequential()\n# Add the first (input) layer (10 nodes) with input shape 13 element vector (1D).\nmodel.add(Dense(10, input_shape=(13,)))\n# Add the second (hidden) layer of 10 nodes.\nmodel.add(Dense(10))\n# Add the third (output) layer of 1 node.\nmodel.add(Dense(1))</code></pre>\n\n\n\n<p>Alternatively, we can define the sequential sequence of the layers as a list parameter when instantiating the&nbsp;Sequential&nbsp;class object.</p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"python\" class=\"language-python\">from tensorflow.keras import Sequential\nfrom tensorflow.keras.layers import Dense\nmodel = Sequential([\n                   # Add the first (input) layer (10 nodes)\n                   Dense(10, input_shape=(13,)),\n                   # Add the second (hidden) layer of 10 nodes.\n                   Dense(10),\n                   # Add the third (output) layer of 1 node.\n                   Dense(1)\n                   ])\n</code></pre>\n\n\n\n<p>Let&#8217;s now do the same but use the&nbsp;Functional API&nbsp;method. We start by creating an input vector by instantiating an&nbsp;Input&nbsp;class object. The (positional) parameter to the&nbsp;Input()&nbsp;object is the shape of the input, which can be a vector, matrix or tensor. In our example, we have a vector that is thirteen elements long. So our shape is (13,). I am sure you noticed the trailing comma. That&#8217;s to overcome a quirk in Python. Without the comma, a (13) is evaluated as an expression. That is, the integer value 13 is surrounded by a parenthesis. Adding a comma will tell the interpreter this is a tuple (an ordered set of values).</p>\n\n\n\n<p>Next, we create the input layer by instantiating a&nbsp;Dense&nbsp;class object. The positional parameter to the&nbsp;Dense()&nbsp;object is the number of nodes; which in our example is ten. Note the peculiar syntax that follows with a&nbsp;(inputs). The&nbsp;Dense()&nbsp;object is a callable. That is, the object returned by instantiating the&nbsp;Dense()&nbsp;object can be callable as a function. So we call it as a function, and in this case, the function takes as a (positional) parameter the input vector (or layer output) to connect it to; hence we pass it&nbsp;inputs&nbsp;so the input vector is bound to the ten node input layer.</p>\n\n\n\n<p>Next, we create the hidden layer by instantiating another&nbsp;Dense()&nbsp;object with ten nodes, and using it as a callable, we (fully) connect it to the input layer.</p>\n\n\n\n<p>Then we create the output layer by instantiating another&nbsp;Dense()&nbsp;object with one node, and using it as a callable, we (fully) connect it to the hidden layer.</p>\n\n\n\n<p>Finally, we put it altogether by instantiating a&nbsp;Model&nbsp;class object, passing it the (positional) parameters for the input vector and output layer. Remember, all the other layers in-between are already connected so we don&#8217;t need to specify them when instantiating the&nbsp;Model()&nbsp;object.</p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"python\" class=\"language-python\">from tensorflow.keras import Input, Model\nfrom tensorflow.keras.layers import Dense\n \ninputs = Input((13,))\ninput = Dense(10)(inputs)\nhidden = Dense(10)(input)\noutput = Dense(1)(hidden)\nmodel = Model(inputs, output)\n</code></pre>\n\n\n\n<h3><strong>Activation Functions</strong></h3>\n\n\n\n<p>When training or predicting (inference), each node in a layer will output a value to the nodes in the next layer. We don&#8217;t always want to pass the value &#8216;as-is&#8217;, but instead sometimes we want to change the value in some manner. This process is called an activation function. Think of a function that returns some result, like&nbsp;return result. In the case of an activation function, instead of returning&nbsp;result, we would return the result of passing the result value to another (activation) function, like&nbsp;return A(result), where A() is the activation function. Conceptually, you can think of this as:</p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"python\" class=\"language-python\">def layer(params):\n    \"\"\" inside are the nodes \"\"\"\n    result = some_calculations\n    return A(result)\n \ndef A(result):\n    \"\"\" modifies the result \"\"\"\n    return some_modified_value_of_result\n</code></pre>\n\n\n\n<p>Activation functions assist neural networks in learning faster and better. By default, when no activation function is specified, the values from one layer are passed as-is (unchanged) to the next layer. The most basic activation function is a step function. If the value is greater than 0, then a 1 is outputted; otherwise a zero. The step function hasn&#8217;t been used in a long, long time.</p>\n\n\n\n<p>Let’s pause for a moment and discuss the purpose of an activation function. You likely have heard the phrase non-linearity. What is this? To me, more importantly, is what it is not?</p>\n\n\n\n<p>In traditional statistics, we worked in low dimensional space where there was a strong linear correlation between the input space and output space. This correlation could be computed as a polynomial transformation of the input that, when transformed, had a linear correlation to the output. The most fundamental example is the slope of a line, which is represented as y = mx + b. In this case, x and y are coordinates of the line, and we want to fit the value of m, the slope, and b, where the line intercepts the y access.</p>\n\n\n\n<p>In deep learning, we work in high dimensional space where there is substantial non-linearity between the input space and output space. What is non-linearity? It means that an input is not (near) uniformly related to an output based on a polynomial transformation of the input. For example, let’s say one’s property tax is a fixed percentage rate (r) of the house value. In this case, the property tax can be represented by a function that multiplies the rate by the house value &#8212; thus having a linear (i.e., straight line) relationship between value (input) and property tax (output).</p>\n\n\n\n<pre class=\"wp-block-preformatted\">tax = F(<strong>value</strong>) = r * <strong>value</strong></pre>\n\n\n\n<p>Let’s look at the logarithmic scale for measuring earthquakes, where an increase of one, means the power released is ten times greater. For example, an earthquake of 4 is 10 times stronger than a 3. By applying a logarithmic transform to the input power we have a linear relationship between power and scale.</p>\n\n\n\n<pre class=\"wp-block-preformatted\">scale&nbsp; = F(power) = log(power)</pre>\n\n\n\n<p>In a non-linear relationship, sequences within the input have different linear relationships to the output, and in deep learning we want to learn both the separation points as well as the linear functions for each input sequence. For example, consider age vs. income to demonstrate a non-linear relationship. In general, toddlers have no income, grade-school children have an allowance, early-teens earn an allowance + money for chores, later teens earn money from jobs, and then when they go to college their income drops to zero! After college, their income gradually increases until retirement, when it becomes fixed. We could model this nonlinearity as sequences across age and learn a linear function for each sequence, such as depicted below.</p>\n\n\n\n<pre class=\"wp-block-preformatted\">income = F1(age) = 0    for age [0..5]\nincome = F2(age) = c1    for age[6..9]\nincome = F3(age) = c1 + (w1 * age)  for age[10..15]\nincome = F4(age) = (w2 * age) for age[16..18]\nincome = F5(age) = 0 for age[19..22]\nincome = F6(age) = (w3 * age) for age[23..64]\nincome = F7(age) = c2 for age [65+]\n</pre>\n\n\n\n<p>Activation functions assist in finding the non-linear separations and corresponding clustering of nodes within input sequences which then learn the (near) linear relationship to the output.</p>\n\n\n\n<p>There are three activation functions you will use most of the time: the rectified linear unit (ReLU); sigmoid; softmax. We will start with the ReLU, since it is the one that is most used in all but the output layer of a model. The sigmoid and softmax activation we will then cover when we look at how different model types affect the design of the output layer.</p>\n\n\n\n<p>The rectified linear unit, as depicted in figure 3, passes values greater than zero as-is (unchanged); otherwise zero (no signal).</p>\n\n\n\n<div class=\"wp-block-image\"><figure class=\"aligncenter size-large is-resized\"><img decoding=\"async\" loading=\"lazy\" src=\"https://kavita-ganesan.com/wp-content/uploads/CH02_F04_Ferlitsch-1024x847.png\" alt=\"A Gentle Introduction to Deep Neural Networks with Python\" class=\"wp-image-6791\" width=\"512\" height=\"424\" srcset=\"https://kavita-ganesan.com/wp-content/uploads/CH02_F04_Ferlitsch-1024x847.png 1024w, https://kavita-ganesan.com/wp-content/uploads/CH02_F04_Ferlitsch-300x248.png 300w, https://kavita-ganesan.com/wp-content/uploads/CH02_F04_Ferlitsch-150x124.png 150w, https://kavita-ganesan.com/wp-content/uploads/CH02_F04_Ferlitsch-768x635.png 768w, https://kavita-ganesan.com/wp-content/uploads/CH02_F04_Ferlitsch-1536x1271.png 1536w, https://kavita-ganesan.com/wp-content/uploads/CH02_F04_Ferlitsch-2048x1694.png 2048w\" sizes=\"(max-width: 512px) 100vw, 512px\" /><figcaption><strong>Fig. 3 The function for a rectified linear unit clips all negative values to zero. In essence, any negative value is the same as no signal ~ zero.</strong></figcaption></figure></div>\n\n\n\n<p class=\"has-text-align-center\"></p>\n\n\n\n<p>The rectified linear unit is generally used between layers. While early researchers used different activation functions, such as a hyperbolic tangent, between layers, researchers found that the ReLU produced the best result in training a model. In our example, we will add a rectified linear unit between each layer.</p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"python\" class=\"language-python\"> \nmodel = Sequential()\n# Add the first (input) layer (10 nodes) with input shape 13 element vector (1D).\nmodel.add(Dense(10, input_shape=(13,)))\n# Pass the output from the input layer through a rectified linear unit activation  # function.\nmodel.add(ReLU())\n# Add the second (hidden) layer (10 nodes).\nmodel.add(Dense(10))\n# Pass the output from the input layer through a rectified linear unit activation  # function.\nmodel.add(ReLU())\n# Add the third (output) layer of 1 node.\nmodel.add(Dense(1))</code></pre>\n\n\n\n<p>Let&#8217;s take a look inside our model object and see if we constructed what we think we did. You can do this using the summary() method. It will show in sequential order a summary of each layer.</p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"python\" class=\"language-python\">model.summary()</code></pre>\n\n\n\n<pre class=\"wp-block-preformatted\">Layer (type)                 Output Shape              Param #   \n=================================================================\ndense_56 (Dense)             (None, 10)                140       \n_________________________________________________________________\nre_lu_18 (ReLU)              (None, 10)                0         \n_________________________________________________________________\ndense_57 (Dense)             (None, 10)                110       \n_________________________________________________________________\nre_lu_19 (ReLU)              (None, 10)                0         \n_________________________________________________________________\ndense_58 (Dense)             (None, 1)                 11        \n=================================================================\nTotal params: 261\nTrainable params: 261\nNon-trainable params: 0\n_________________________________________________________________\n</pre>\n\n\n\n<p>For this code example, you see the summary starts with a&nbsp;Dense&nbsp;layer of ten nodes (input layer), followed by a&nbsp;ReLU&nbsp;activation function, followed by a second&nbsp;Dense&nbsp;layer (hidden) of ten nodes, followed by a&nbsp;ReLU&nbsp;activation function, and finally followed by a&nbsp;Dense&nbsp;layer (output) of one node. So, yes, we got what we expected.</p>\n\n\n\n<p>Next, let&#8217;s look at the parameter field in the summary. See how, for the input layer, it shows 140 parameters. How is that calculated? We have 13 inputs and 10 nodes, so 13 x 10 is 130. Where does 140 come from? Each connection between the inputs and each node has a weight, which adds up to 130. But each node has an additional bias. That&#8217;s ten nodes, so 130 + 10 = 140. As I’ve said, it&#8217;s the weights and biases that the neural network will &#8220;learn&#8221; during training. A bias is a learned offset, conceptually equivalent to the y-intercept (b) in the slope of a line, which is where the line intercepts the y-axis:</p>\n\n\n\n<pre class=\"wp-block-preformatted\">y = b + mx</pre>\n\n\n\n<p>At the next (hidden) layer you see 110 params. That&#8217;s ten outputs from the input layer connected to each of the ten nodes from the hidden layer (10&#215;10) plus the ten biases for the nodes in the hidden layers, for a total of 110 parameters to &#8220;learn&#8221;.</p>\n\n\n\n<h3><strong>Shorthand Syntax</strong></h3>\n\n\n\n<p>TF.Keras provides a shorthand syntax when specifying layers. You don&#8217;t actually need to separately specify activation functions between layers, as we did above. Instead, you can specify the activation function as a (keyword) parameter when instantiating a Dense() layer.</p>\n\n\n\n<p>You might ask, why not then simply always use the shorthand syntax? As you will see later in the book, where in today’s model architecture the activation function is preceded by another intermediate layer &#8212; batch normalization, or precedes the layer altogether &#8212; pre-activation batch normalization.</p>\n\n\n\n<p>The code example below does exactly the same as the code above.</p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"python\" class=\"language-python\">from tensorflow.keras import Sequential\nfrom tensorflow.keras.layers import Dense\n \nmodel = Sequential()\n# Add the first (input) layer (10 nodes) with input shape 13 element vector (1D).\nmodel.add(Dense(10, input_shape=(13,), activation='relu'))\n# Add the second (hidden) layer (10 nodes).\nmodel.add(Dense(10, activation='relu'))\n# Add the third (output) layer of 1 node.\nmodel.add(Dense(1))#A The activation function is specified as a keyword parameter in the layer.</code></pre>\n\n\n\n<p>Let&#8217;s call the&nbsp;summary()&nbsp;method on this model.</p>\n\n\n\n<pre class=\"wp-block-code\"><code class=\"\">model.summary()</code></pre>\n\n\n\n<pre class=\"wp-block-preformatted\">Layer (type)                 Output Shape              Param #   \n=================================================================\ndense_56 (Dense)             (None, 10)                140       \n_________________________________________________________________\nre_lu_18 (ReLU)              (None, 10)                0         \n_________________________________________________________________\ndense_57 (Dense)             (None, 10)                110       \n_________________________________________________________________\nre_lu_19 (ReLU)              (None, 10)                0         \n_________________________________________________________________\ndense_58 (Dense)             (None, 1)                 11        \n=================================================================\n\nTotal params: 261\nTrainable params: 261\nNon-trainable params: 0\n</pre>\n\n\n\n<p>Hum, you don&#8217;t see the activations between the layers as you did in the earlier example. Why not? It&#8217;s a quirk in how the summary() method displays output. They are still there.</p>\n\n\n\n<p><strong>Improving accuracy with optimizer</strong></p>\n\n\n\n<p>Once you&#8217;ve completed building the forward feed portion of your neural network, as we have for our simple example, we now need to add a few things for training the model. This is done with the&nbsp;compile()&nbsp;method. This step adds the backward propagation during training. Let’s define and explore this concept.</p>\n\n\n\n<p>Each time we send data (or a batch of data) forward through the neural network, the neural network calculates the errors in the predicted results (known as the loss) from the actual values (called labels) and uses that information to incrementally adjust the weights and biases of the nodes. This, for a model, is the process of learning.</p>\n\n\n\n<p>The calculation of the error, as I’ve said, is called a loss. It can be calculated in many different ways. Since we designed our example neural network to be a regresser (meaning that the output, house price, is a real value), we want to use a loss function that is best suited for a regresser. Generally, for this type of neural network, we use the Mean Square Error method of calculating a loss. In Keras, the&nbsp;compile()&nbsp;method takes a (keyword) parameter&nbsp;loss&nbsp;where we can specify how we want to calculate the loss. We are going to pass it the value&nbsp;‘mse’&nbsp;for Mean Square Error.</p>\n\n\n\n<p>The next step in the process is the optimizer that occurs during backward propagation. The optimizer is based on gradient descent; where different variations of the gradient descent algorithm can be selected. These terms can be hard to understand at first. Essentially, each time we pass data through the neural network we use the calculated loss to decide how much to change the weights and biases in the layers by. The goal is to gradually get closer and closer to the correct values for the weights and biases to accurately predict or estimate the &#8220;label&#8221; for each example. This process of progressively getting closer and closer to the accurate values is called convergence. The job of the optimizer is to calculate the updates to the weights to progressively get closer to the accurate values to reach convergence.</p>\n\n\n\n<p>As the loss gradually decreases we are converging and once the loss plateaus out, we have convergence, and the result is the accuracy of the neural network. Before using gradient descent, the methods used by early AI researchers could take years on a supercomputer to find convergence on a non-trivial problem. After the discovery of using the gradient descent algorithm, this time reduced to days, hours and even just minutes on ordinary compute power. Let&#8217;s skip the math and just say that gradient descent is the data scientist&#8217;s pixie dust that makes convergence possible.</p>\n\n\n\n<p>For our regressor neural network, we will use the&nbsp;<code>rmsprop</code>&nbsp;method (root mean square property).</p>\n\n\n\n<pre class=\"wp-block-code\"><code class=\"\">model.compile(loss='mse', optimizer='rmsprop')</code></pre>\n\n\n\n<p>Now we have completed building your first &#8216;trainable&#8217; neural network.</p>\n\n\n\n<p>That’s all for now. If you want to learn more about the book, check it out on Manning’s liveBook platform <a href=\"https://livebook.manning.com/book/deep-learning-patterns-and-practices?origin=product-look-inside\">here</a>.</p>\n",
  "wfw:commentRss": "https://kavita-ganesan.com/neural-network-intro/feed/",
  "slash:comments": 0,
  "post-id": 6748
}