{
  "title": "Building Computations",
  "link": "",
  "updated": "2012-11-23T00:00:00+00:00",
  "id": "https://mrocklin.github.io/blog/work/2012/11/23/BuildingComputations",
  "content": "<p>In my <a href=\"https://mrocklin.github.io/blog/work/2012/11/21/Computations/\">last post</a> I described a\nbase type that represented a computation as a directed acyclic graph.  In my\npost on <a href=\"https://mrocklin.github.io/blog/work/2012/11/10/GeneratingBLAS-PreliminaryResults/\">preliminary results</a> I showed how we could write Fortran code for a simple matrix expression.  In this post I want to show how unificaiton, rewrite rules, and manipulations on computations can compile computations from fairly complex matrix expressions.</p>\n\n<h2 id=\"inputs\">Inputs</h2>\n\n<p>Lets begin with a complex expression and a set of assumptions</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\">    <span class=\"n\">expr</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">Y</span><span class=\"p\">.</span><span class=\"n\">I</span><span class=\"o\">*</span><span class=\"n\">Z</span><span class=\"o\">*</span><span class=\"n\">Y</span> <span class=\"o\">+</span> <span class=\"n\">b</span><span class=\"o\">*</span><span class=\"n\">Z</span><span class=\"o\">*</span><span class=\"n\">Y</span> <span class=\"o\">+</span> <span class=\"n\">c</span><span class=\"o\">*</span><span class=\"n\">W</span><span class=\"o\">*</span><span class=\"n\">W</span><span class=\"p\">).</span><span class=\"n\">I</span><span class=\"o\">*</span><span class=\"n\">Z</span><span class=\"o\">*</span><span class=\"n\">W</span>\n    <span class=\"n\">assumptions</span> <span class=\"o\">=</span> <span class=\"n\">Q</span><span class=\"p\">.</span><span class=\"n\">symmetric</span><span class=\"p\">(</span><span class=\"n\">Y</span><span class=\"p\">)</span> <span class=\"o\">&amp;</span> <span class=\"n\">Q</span><span class=\"p\">.</span><span class=\"n\">positive_definite</span><span class=\"p\">(</span><span class=\"n\">Y</span><span class=\"p\">)</span> <span class=\"o\">&amp;</span> <span class=\"n\">Q</span><span class=\"p\">.</span><span class=\"n\">symmetric</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">)</span></code></pre>\n</figure>\n\n<p>We also specify a list of conditional rewrite patterns.  A pattern has the\nfollowing form</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\">    <span class=\"n\">Source</span><span class=\"p\">:</span>     <span class=\"n\">alpha</span><span class=\"o\">*</span><span class=\"n\">A</span><span class=\"o\">*</span><span class=\"n\">B</span>\n    <span class=\"n\">Target</span><span class=\"p\">:</span>     <span class=\"n\">SYMM</span><span class=\"p\">(</span><span class=\"n\">alpha</span><span class=\"p\">,</span> <span class=\"n\">A</span><span class=\"p\">,</span> <span class=\"n\">B</span><span class=\"p\">,</span> <span class=\"n\">S</span><span class=\"p\">.</span><span class=\"n\">Zero</span><span class=\"p\">,</span> <span class=\"n\">B</span><span class=\"p\">)</span>\n    <span class=\"n\">Wilds</span><span class=\"p\">:</span>      <span class=\"n\">alpha</span><span class=\"p\">,</span> <span class=\"n\">A</span><span class=\"p\">,</span> <span class=\"n\">B</span>\n    <span class=\"n\">Condition</span><span class=\"p\">:</span>  <span class=\"n\">Q</span><span class=\"p\">.</span><span class=\"n\">symmetric</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">)</span> <span class=\"o\">|</span> <span class=\"n\">Q</span><span class=\"p\">.</span><span class=\"n\">symmetric</span><span class=\"p\">(</span><span class=\"n\">B</span><span class=\"p\">)</span></code></pre>\n</figure>\n\n<p>This means that we convert the expression <code class=\"language-plaintext highlighter-rouge\">alpha*A*B</code> into the computation <code class=\"language-plaintext highlighter-rouge\">SYMM(alpha, A, B, S.Zero, B)</code> (a SYmmetric Matrix Multiply) for any <code class=\"language-plaintext highlighter-rouge\">(alpha, A, B)</code> when either <code class=\"language-plaintext highlighter-rouge\">A</code> is symmetric or <code class=\"language-plaintext highlighter-rouge\">B</code> is symmetric.</p>\n\n<p>Thanks to <a href=\"https://mrocklin.github.io/blog/work/2012/11/01/Unification/\">unification</a> rewrite patterns are easy to write.  Someone who is familiar with BLAS/LAPACK but unfamiliar with compilers would be able to make these easily.</p>\n\n<h2 id=\"expressions-to-computations\">Expressions to Computations</h2>\n\n<p>Each pattern is turned into a function/rule that transforms an expression\ninto a computation.  We start with an identity computation</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\">    <span class=\"n\">expr</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">Y</span><span class=\"p\">.</span><span class=\"n\">I</span><span class=\"o\">*</span><span class=\"n\">Z</span><span class=\"o\">*</span><span class=\"n\">Y</span> <span class=\"o\">+</span> <span class=\"n\">b</span><span class=\"o\">*</span><span class=\"n\">Z</span><span class=\"o\">*</span><span class=\"n\">Y</span> <span class=\"o\">+</span> <span class=\"n\">c</span><span class=\"o\">*</span><span class=\"n\">W</span><span class=\"o\">*</span><span class=\"n\">W</span><span class=\"p\">).</span><span class=\"n\">I</span><span class=\"o\">*</span><span class=\"n\">Z</span><span class=\"o\">*</span><span class=\"n\">W</span>\n    <span class=\"n\">assumptions</span> <span class=\"o\">=</span> <span class=\"n\">Q</span><span class=\"p\">.</span><span class=\"n\">symmetric</span><span class=\"p\">(</span><span class=\"n\">Y</span><span class=\"p\">)</span> <span class=\"o\">&amp;</span> <span class=\"n\">Q</span><span class=\"p\">.</span><span class=\"n\">positive_definite</span><span class=\"p\">(</span><span class=\"n\">Y</span><span class=\"p\">)</span> <span class=\"o\">&amp;</span> <span class=\"n\">Q</span><span class=\"p\">.</span><span class=\"n\">symmetric</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">)</span>\n    <span class=\"n\">identcomp</span> <span class=\"o\">=</span> <span class=\"n\">Identity</span><span class=\"p\">(</span><span class=\"n\">expr</span><span class=\"p\">)</span>\n    <span class=\"n\">identcomp</span><span class=\"p\">.</span><span class=\"n\">show</span><span class=\"p\">()</span></code></pre>\n</figure>\n\n<p>Computations are able to print themselves in the <a href=\"http://en.wikipedia.org/wiki/DOT_language\">DOT Language</a> enabling simple visualization. Here we see a computation that produces the expression we want but its input is the same.  Weâ€™d prefer one that had more atomic inputs like <code class=\"language-plaintext highlighter-rouge\">a, b, c, W, X, Y, Z</code></p>\n\n<p><img src=\"https://mrocklin.github.io/blog/images/complex-matrix-computation-identity.png\" alt=\"\" /></p>\n\n<p>Our patterns know how to break down big expressions into smaller ones by adding the right computation (e.g <code class=\"language-plaintext highlighter-rouge\">alpha*A*B</code> -&gt; <code class=\"language-plaintext highlighter-rouge\">alpha, A, B</code> via <code class=\"language-plaintext highlighter-rouge\">SYMM</code>.)  We convert each of our patterns into a rule.  This rule looks at the inputs and, if it finds a matching expression adds on a new computation to break down that expression.  We use <a href=\"https://mrocklin.github.io/blog/work/2012/11/09/BranchingStrategies/\">branching strategies</a> to orchestrate <em>how</em> all of  these rules are applied.  This is accomplished in the last line of the <code class=\"language-plaintext highlighter-rouge\">make_matrix_rule</code> function</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\">    <span class=\"k\">def</span> <span class=\"nf\">make_matrix_rule</span><span class=\"p\">(</span><span class=\"n\">patterns</span><span class=\"p\">,</span> <span class=\"n\">assumptions</span><span class=\"p\">):</span>\n        <span class=\"n\">rules</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">expr_to_comp_rule</span><span class=\"p\">(</span><span class=\"n\">src</span><span class=\"p\">,</span> <span class=\"n\">target</span><span class=\"p\">,</span> <span class=\"n\">wilds</span><span class=\"p\">,</span> <span class=\"n\">cond</span><span class=\"p\">,</span> <span class=\"n\">assumptions</span><span class=\"p\">)</span>\n                 <span class=\"k\">for</span> <span class=\"n\">src</span><span class=\"p\">,</span> <span class=\"n\">target</span><span class=\"p\">,</span> <span class=\"n\">wilds</span><span class=\"p\">,</span> <span class=\"n\">cond</span> <span class=\"ow\">in</span> <span class=\"n\">patterns</span><span class=\"p\">]</span>\n        <span class=\"k\">return</span> <span class=\"n\">exhaust</span><span class=\"p\">(</span><span class=\"n\">multiplex</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"nb\">map</span><span class=\"p\">(</span><span class=\"n\">input_crunch</span><span class=\"p\">,</span> <span class=\"n\">rules</span><span class=\"p\">)))</span></code></pre>\n</figure>\n\n<p>This function combines logic (<code class=\"language-plaintext highlighter-rouge\">patterns/assumptions</code>) with control (<code class=\"language-plaintext highlighter-rouge\">exhaust/multiplex/input_crunch</code>) to create a <a href=\"http://www.icsd.aegean.gr/lecturers/stamatatos/courses/Logic/Prolog/Ch1/Ch1_files/algorithm%3Dlogic%2Bcontrol.pdf\">complete algorithm</a>.  We apply this algorithm to our identity computation and pull off a compiled result</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\">    <span class=\"n\">rule</span> <span class=\"o\">=</span> <span class=\"n\">make_matrix_rule</span><span class=\"p\">(</span><span class=\"n\">patterns</span><span class=\"p\">,</span> <span class=\"n\">assumptions</span><span class=\"p\">)</span>\n    <span class=\"n\">comp</span> <span class=\"o\">=</span> <span class=\"nb\">next</span><span class=\"p\">(</span><span class=\"n\">rule</span><span class=\"p\">(</span><span class=\"n\">identcomp</span><span class=\"p\">))</span>\n    <span class=\"n\">comp</span><span class=\"p\">.</span><span class=\"n\">show</span><span class=\"p\">()</span></code></pre>\n</figure>\n\n<p><img src=\"https://mrocklin.github.io/blog/images/complex-matrix-computation.png\" alt=\"\" /></p>\n\n<p>We still have same output but now the input is broken down into smaller pieces by a set of computations.  These computations are arranged in a graph based on their dependencies.  We had to use a <code class=\"language-plaintext highlighter-rouge\">GESV</code>, a <code class=\"language-plaintext highlighter-rouge\">POSV</code>, two <code class=\"language-plaintext highlighter-rouge\">GEMM</code>s a <code class=\"language-plaintext highlighter-rouge\">SYMM</code> and two <code class=\"language-plaintext highlighter-rouge\">AXPY</code>s to break down this computation.  Our inputs are now <code class=\"language-plaintext highlighter-rouge\">a,b,c,W,X,Y,Z</code> as desired.</p>\n\n<p><code class=\"language-plaintext highlighter-rouge\">rule(identcomp)</code> iterates over all possible computations to compute this expression.  If you are not satisfied with the computation above you may ask for another.</p>\n\n<h2 id=\"inplace-computations\">Inplace Computations</h2>\n\n<p>The BLAS/LAPACK routines are <em>inplace</em>; they write their results to the memory locations of some of their inputs.  The above <em>matheamtical</em> graph doesnâ€™t have the necessary information to think about this <em>computational</em> concern. We have a separate system to compile and optimize inplace computations.</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\">    <span class=\"kn\">from</span> <span class=\"nn\">sympy.computations.inplace</span> <span class=\"kn\">import</span> <span class=\"n\">inplace_compile</span>\n    <span class=\"n\">icomp</span> <span class=\"o\">=</span> <span class=\"n\">inplace_compile</span><span class=\"p\">(</span><span class=\"n\">comp</span><span class=\"p\">)</span>\n    <span class=\"n\">icomp</span><span class=\"p\">.</span><span class=\"n\">show</span><span class=\"p\">()</span></code></pre>\n</figure>\n\n<p><img src=\"https://mrocklin.github.io/blog/images/complex-matrix-computation-inplace.png\" alt=\"\" /></p>\n\n<p>Each variable is now of the form</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Mathematical Expression @ memory location\n</code></pre></div></div>\n\n<p>We have introduced <code class=\"language-plaintext highlighter-rouge\">Copy</code> operations into the graph where necessary to prevent dangerous overwrites.\nIf you track the memory locations you can see which BLAS/LAPACK operations overwrite which variables.  For example <code class=\"language-plaintext highlighter-rouge\">Z</code> is never overwritten and so is never copied. On the other hand <code class=\"language-plaintext highlighter-rouge\">W</code> is used in two overwrite operations and so it is copied to two new variables, <code class=\"language-plaintext highlighter-rouge\">W_2</code> and <code class=\"language-plaintext highlighter-rouge\">W_3</code>.  Copies are not added if obviously unnecessary.</p>\n\n<h2 id=\"future-work\">Future Work</h2>\n\n<p>There are a couple of small items and one large one.</p>\n\n<ol>\n  <li>\n    <p>An expert in BLAS/LAPACK will note that there are some issues with my graphs; they are not yet ideal.  I donâ€™t handle <code class=\"language-plaintext highlighter-rouge\">IPIV</code> permutation operations well (I need to add some new patterns), I am overwrie the <code class=\"language-plaintext highlighter-rouge\">INFO</code> out parameter, and there are a few cases where a copy could be avoided by operation reordering.</p>\n  </li>\n  <li>\n    <p>I need to refactor my old Fortran generation code to work with the new inplace system.</p>\n  </li>\n  <li>\n    <p>The largest challenge is to build strategies for intelligent application of rewrite rules.  Expressions are now large enough and the list of patterns is now long enough so that checking all possiblities is definitely infeasible.  I need to think hard about traversals.  Fortunately this problem is purely algorithmic and has no connection to BLAS, inplace computations, etcâ€¦.  I should be able to think about it in isolation.</p>\n  </li>\n</ol>\n\n<h2 id=\"closing-note\">Closing Note</h2>\n\n<p>Except for the mathematical definition of BLAS none of this code is specific to generating matrix computations.  The majority of this technology isnâ€™t even specific to building computations.  The computaitonal core of most of the technologies isnâ€™t even dependent on SymPy.  My final <code class=\"language-plaintext highlighter-rouge\">sympy.computations.matrices</code> directory is small.</p>\n\n<p>Throughout this project Iâ€™ve tried to keep all of the technology as general as possible in hopes that others will make use of it.  Only a small fraction of my work has been specific to my application.  I hope that others find this work interesting.  I hope that this technology enables a variety of other unrelated projects.</p>\n\n<h2 id=\"links\">Links</h2>\n\n<ol>\n  <li><a href=\"https://github.com/mrocklin/sympy/tree/compblas\">Development Branch</a></li>\n  <li><a href=\"https://mrocklin.github.io/blog/scripts/2012-11-23-BuildingComputations.py\">Script to generate images within this post</a></li>\n</ol>"
}