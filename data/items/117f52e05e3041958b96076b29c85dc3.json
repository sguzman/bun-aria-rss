{
  "title": "Sessionizing Log Data Using SQL",
  "description": "<p>Over my career as a predictive modeler/data scientist, the most important step(s) in any data project without question have been data cleaning and feature engineering. By taking the data you have, correcting flaws and reformulating raw data into additional business-specific concepts, you ensure that you move beyond pure mathematical optimization and actually solve a <em>business problem</em>. While “big data” is often held up as the future of knowing everything, when it comes down to it, a Hadoop cluster is more often a “Ha-dump” cluster: the place data gets dumped without any proper ETL.</p>",
  "pubDate": "Thu, 08 Jan 2015 11:57:56 +0000",
  "link": "http://randyzwitch.com/sessionizing-log-data-sql/",
  "guid": "http://randyzwitch.com/sessionizing-log-data-sql/",
  "content": "<p>Over my career as a predictive modeler/data scientist, the most important step(s) in any data project without question have been data cleaning and feature engineering. By taking the data you have, correcting flaws and reformulating raw data into additional business-specific concepts, you ensure that you move beyond pure mathematical optimization and actually solve a <em>business problem</em>. While “big data” is often held up as the future of knowing everything, when it comes down to it, a Hadoop cluster is more often a “Ha-dump” cluster: the place data gets dumped without any proper ETL.</p>\n\n<p>For this blog post, I’m going to highlight a common request for time-series data: combining discrete events into sessions. Whether you are dealing with sensor data, television viewing data, digital analytics data or any other stream of events, the problem of interest is usually how a human interacts with a machine over a given period of time, not each individual event.</p>\n\n<p>While I usually use Hive (Hadoop) for daily work, I’m going to use Postgres (via OSX <a title=\"Postgres.app OSX\" href=\"http://postgresapp.com\" target=\"_blank\">Postgres.app</a>) to make this as widely accessible as possible. In general, this process will work with any infrastructure/SQL-dialect that supports <a href=\"http://www.postgresql.org/docs/9.1/static/tutorial-window.html\">window functions</a>.</p>\n\n<h2 id=\"connecting-to-databaseload-data\">Connecting to Database/Load Data</h2>\n\n<p>For lightweight tasks, I find using psql (command-line tool) is easy enough. Here are the commands to create a database to hold our data and to load our two .csv files (download <a href=\"/wp-content/uploads/2015/01/single_col_timestamp.csv.gz\">here</a> and <a href=\"/wp-content/uploads/2015/01/two_col_timestamp.csv.gz\">here</a>):</p>\n\n<p><img src=\"/wp-content/uploads/2015/01/psql-load-data.png\" alt=\"psql-load-data\" /></p>\n\n<p>These files contain timestamps generated for 1000 uid values.</p>\n\n<h2 id=\"query-1-inner-determining-session-boundary-using-a-window-function\">Query 1 (“Inner”): Determining Session Boundary Using A Window Function</h2>\n\n<p>In order to determine the boundary of each session, we can use a window function along with <code class=\"language-plaintext highlighter-rouge\">lag()</code>, which will allow the current row being processed to compare vs. the prior row. Of course, for all of this to work correctly, we need to have our data sorted in time order by each of our users:</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-sql\" data-lang=\"sql\"><table class=\"rouge-table\"><tbody><tr><td class=\"gutter gl\"><pre class=\"lineno\">1\n2\n3\n4\n5\n6\n7\n</pre></td><td class=\"code\"><pre><span class=\"c1\">--Create boundaries at 30 minute timeout</span>\n<span class=\"k\">select</span>\n<span class=\"n\">uid</span><span class=\"p\">,</span>\n<span class=\"n\">event_timestamp</span><span class=\"p\">,</span>\n<span class=\"p\">(</span><span class=\"k\">extract</span><span class=\"p\">(</span><span class=\"n\">epoch</span> <span class=\"k\">from</span> <span class=\"n\">event_timestamp</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"n\">lag</span><span class=\"p\">(</span><span class=\"k\">extract</span><span class=\"p\">(</span><span class=\"n\">epoch</span> <span class=\"k\">from</span> <span class=\"n\">event_timestamp</span><span class=\"p\">))</span> <span class=\"n\">OVER</span> <span class=\"p\">(</span><span class=\"n\">PARTITION</span> <span class=\"k\">BY</span> <span class=\"n\">uid</span> <span class=\"k\">ORDER</span> <span class=\"k\">BY</span> <span class=\"n\">event_timestamp</span><span class=\"p\">))</span><span class=\"o\">/</span><span class=\"mi\">60</span> <span class=\"k\">as</span> <span class=\"n\">minutes_since_last_interval</span><span class=\"p\">,</span>\n<span class=\"k\">case</span> <span class=\"k\">when</span> <span class=\"k\">extract</span><span class=\"p\">(</span><span class=\"n\">epoch</span> <span class=\"k\">from</span> <span class=\"n\">event_timestamp</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"n\">lag</span><span class=\"p\">(</span><span class=\"k\">extract</span><span class=\"p\">(</span><span class=\"n\">epoch</span> <span class=\"k\">from</span> <span class=\"n\">event_timestamp</span><span class=\"p\">))</span> <span class=\"n\">OVER</span> <span class=\"p\">(</span><span class=\"n\">PARTITION</span> <span class=\"k\">BY</span> <span class=\"n\">uid</span> <span class=\"k\">ORDER</span> <span class=\"k\">BY</span> <span class=\"n\">event_timestamp</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"mi\">30</span> <span class=\"o\">*</span> <span class=\"mi\">60</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">ELSE</span> <span class=\"mi\">0</span> <span class=\"k\">END</span> <span class=\"k\">as</span> <span class=\"n\">new_event_boundary</span>\n<span class=\"k\">from</span> <span class=\"n\">single_col_timestamp</span><span class=\"p\">;</span>\n</pre></td></tr></tbody></table></code></pre></figure>\n\n<p>For this query, we use the <code class=\"language-plaintext highlighter-rouge\">lag()</code> function on the <code class=\"language-plaintext highlighter-rouge\">event_timestamp</code> column, and we use <code class=\"language-plaintext highlighter-rouge\">over partition by uid order by event_timestamp</code> to define the window over which we want to do our calculation. To provide additional clarification about how this syntax works, I’ve added a column showing how many minutes have passed between intervals to validate that the 30-minute window is calculated correctly. The result is as follows:</p>\n\n<p><img src=\"/wp-content/uploads/2015/01/sql-session-boundary-definition.png\" alt=\"sql-session-boundary-definition\" /></p>\n\n<p>For each row where the value of <code class=\"language-plaintext highlighter-rouge\">minutes_since_last_interval &gt; 30</code>, there is a value of <code class=\"language-plaintext highlighter-rouge\">1</code> for <code class=\"language-plaintext highlighter-rouge\">new_event_boundary</code>.</p>\n\n<h2 id=\"query-2-outer-creating-a-session-id\">Query 2 (“Outer”): Creating A Session ID</h2>\n\n<p>The query above defines the event boundaries (which is helpful), but if we want to calculate session-level metrics, we need to create a unique id for each set of rows that are part of one session. To do this, we’re again going to use a window function:</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-sql\" data-lang=\"sql\"><table class=\"rouge-table\"><tbody><tr><td class=\"gutter gl\"><pre class=\"lineno\">1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n</pre></td><td class=\"code\"><pre><span class=\"k\">select</span>\n<span class=\"n\">uid</span><span class=\"p\">,</span>\n<span class=\"k\">sum</span><span class=\"p\">(</span><span class=\"n\">new_event_boundary</span><span class=\"p\">)</span> <span class=\"n\">OVER</span> <span class=\"p\">(</span><span class=\"n\">PARTITION</span> <span class=\"k\">BY</span> <span class=\"n\">uid</span> <span class=\"k\">ORDER</span> <span class=\"k\">BY</span> <span class=\"n\">event_timestamp</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">session_id</span><span class=\"p\">,</span>\n<span class=\"n\">event_timestamp</span><span class=\"p\">,</span>\n<span class=\"n\">minutes_since_last_interval</span><span class=\"p\">,</span>\n<span class=\"n\">new_event_boundary</span>\n<span class=\"k\">from</span>\n\t\t\t<span class=\"c1\">--Query 1: Define boundary events</span>\n\t\t\t<span class=\"p\">(</span><span class=\"k\">select</span>\n\t\t\t<span class=\"n\">uid</span><span class=\"p\">,</span>\n\t\t\t<span class=\"n\">event_timestamp</span><span class=\"p\">,</span>\n\t\t\t<span class=\"p\">(</span><span class=\"k\">extract</span><span class=\"p\">(</span><span class=\"n\">epoch</span> <span class=\"k\">from</span> <span class=\"n\">event_timestamp</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"n\">lag</span><span class=\"p\">(</span><span class=\"k\">extract</span><span class=\"p\">(</span><span class=\"n\">epoch</span> <span class=\"k\">from</span> <span class=\"n\">event_timestamp</span><span class=\"p\">))</span> <span class=\"n\">OVER</span> <span class=\"p\">(</span><span class=\"n\">PARTITION</span> <span class=\"k\">BY</span> <span class=\"n\">uid</span> <span class=\"k\">ORDER</span> <span class=\"k\">BY</span> <span class=\"n\">event_timestamp</span><span class=\"p\">))</span><span class=\"o\">/</span><span class=\"mi\">60</span> <span class=\"k\">as</span> <span class=\"n\">minutes_since_last_interval</span><span class=\"p\">,</span>\n\t\t\t<span class=\"k\">case</span> <span class=\"k\">when</span> <span class=\"k\">extract</span><span class=\"p\">(</span><span class=\"n\">epoch</span> <span class=\"k\">from</span> <span class=\"n\">event_timestamp</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"n\">lag</span><span class=\"p\">(</span><span class=\"k\">extract</span><span class=\"p\">(</span><span class=\"n\">epoch</span> <span class=\"k\">from</span> <span class=\"n\">event_timestamp</span><span class=\"p\">))</span> <span class=\"n\">OVER</span> <span class=\"p\">(</span><span class=\"n\">PARTITION</span> <span class=\"k\">BY</span> <span class=\"n\">uid</span> <span class=\"k\">ORDER</span> <span class=\"k\">BY</span> <span class=\"n\">event_timestamp</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"mi\">30</span> <span class=\"o\">*</span> <span class=\"mi\">60</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">ELSE</span> <span class=\"mi\">0</span> <span class=\"k\">END</span> <span class=\"k\">as</span> <span class=\"n\">new_event_boundary</span>\n\t\t\t<span class=\"k\">from</span> <span class=\"n\">single_col_timestamp</span>\n\t\t\t<span class=\"p\">)</span> <span class=\"n\">a</span><span class=\"p\">;</span>\n</pre></td></tr></tbody></table></code></pre></figure>\n\n<p>This query defines the same <code class=\"language-plaintext highlighter-rouge\">over partition by uid order by event_timestamp</code> window, but rather than using <code class=\"language-plaintext highlighter-rouge\">lag()</code> this time, we’re going to use <code class=\"language-plaintext highlighter-rouge\">sum()</code> for the outer query. The effect of using <code class=\"language-plaintext highlighter-rouge\">sum()</code> in our window function is to do a cumulative sum; every time <code class=\"language-plaintext highlighter-rouge\">1</code> shows up, the <code class=\"language-plaintext highlighter-rouge\">session_id</code> field gets incremented by <code class=\"language-plaintext highlighter-rouge\">1</code>. If there is a value of <code class=\"language-plaintext highlighter-rouge\">0</code>, the sum is still the same as the row above and thus has the same <code class=\"language-plaintext highlighter-rouge\">session_id</code>. This is easier to understand visually:</p>\n\n<p><img src=\"/wp-content/uploads/2015/01/sessionized-data.png\" alt=\"sessionized-data\" /></p>\n\n<p>At this point, we have a <code class=\"language-plaintext highlighter-rouge\">session_id</code> for a group of rows where there have been no 30 minute gaps in behavior.</p>\n\n<h2 id=\"final-query-cleaned-up\">Final Query: Cleaned Up</h2>\n\n<p>Although the previous section is technically done, I usually concatenate the uid and session_id together.  I do this concatenation just to highlight that the value is usually a ‘key’ value, not a metric in itself (though it can be). Concatenating the keys together and removing the teaching columns results in the following query:</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-r\" data-lang=\"r\"><table class=\"rouge-table\"><tbody><tr><td class=\"gutter gl\"><pre class=\"lineno\">1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n</pre></td><td class=\"code\"><pre><span class=\"o\">--</span><span class=\"n\">Query</span><span class=\"w\"> </span><span class=\"m\">3</span><span class=\"o\">:</span><span class=\"w\">  </span><span class=\"n\">Outer</span><span class=\"w\"> </span><span class=\"n\">query</span><span class=\"w\"> </span><span class=\"n\">uses</span><span class=\"w\"> </span><span class=\"n\">window</span><span class=\"w\"> </span><span class=\"k\">function</span><span class=\"w\"> </span><span class=\"n\">with</span><span class=\"w\"> </span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">do</span><span class=\"w\"> </span><span class=\"n\">cumulative</span><span class=\"w\"> </span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">concatentate</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">uid</span><span class=\"w\">\n</span><span class=\"n\">select</span><span class=\"w\">\n</span><span class=\"n\">uid</span><span class=\"p\">,</span><span class=\"w\">\n</span><span class=\"n\">uid</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"s1\">'-'</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"n\">cast</span><span class=\"p\">(</span><span class=\"nf\">sum</span><span class=\"p\">(</span><span class=\"n\">new_event_boundary</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">OVER</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">PARTITION</span><span class=\"w\"> </span><span class=\"n\">BY</span><span class=\"w\"> </span><span class=\"n\">uid</span><span class=\"w\"> </span><span class=\"n\">ORDER</span><span class=\"w\"> </span><span class=\"n\">BY</span><span class=\"w\"> </span><span class=\"n\">event_timestamp</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"n\">varchar</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"n\">session_id</span><span class=\"p\">,</span><span class=\"w\">\n</span><span class=\"n\">event_timestamp</span><span class=\"w\">\n</span><span class=\"n\">from</span><span class=\"w\">\n\t\t\t</span><span class=\"o\">--</span><span class=\"n\">Query</span><span class=\"w\"> </span><span class=\"m\">1</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Define</span><span class=\"w\"> </span><span class=\"n\">boundary</span><span class=\"w\"> </span><span class=\"n\">events</span><span class=\"w\">\n\t\t\t</span><span class=\"p\">(</span><span class=\"n\">select</span><span class=\"w\">\n\t\t\t</span><span class=\"n\">uid</span><span class=\"p\">,</span><span class=\"w\">\n\t\t\t</span><span class=\"n\">event_timestamp</span><span class=\"p\">,</span><span class=\"w\">\n\t\t\t</span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">when</span><span class=\"w\"> </span><span class=\"n\">extract</span><span class=\"p\">(</span><span class=\"n\">epoch</span><span class=\"w\"> </span><span class=\"n\">from</span><span class=\"w\"> </span><span class=\"n\">event_timestamp</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"n\">lag</span><span class=\"p\">(</span><span class=\"n\">extract</span><span class=\"p\">(</span><span class=\"n\">epoch</span><span class=\"w\"> </span><span class=\"n\">from</span><span class=\"w\"> </span><span class=\"n\">event_timestamp</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"n\">OVER</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">PARTITION</span><span class=\"w\"> </span><span class=\"n\">BY</span><span class=\"w\"> </span><span class=\"n\">uid</span><span class=\"w\"> </span><span class=\"n\">ORDER</span><span class=\"w\"> </span><span class=\"n\">BY</span><span class=\"w\"> </span><span class=\"n\">event_timestamp</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"m\">30</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"m\">60</span><span class=\"w\"> </span><span class=\"n\">then</span><span class=\"w\"> </span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"n\">ELSE</span><span class=\"w\"> </span><span class=\"m\">0</span><span class=\"w\"> </span><span class=\"n\">END</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"n\">new_event_boundary</span><span class=\"w\">\n\t\t\t</span><span class=\"n\">from</span><span class=\"w\"> </span><span class=\"n\">single_col_timestamp</span><span class=\"w\">\n\t\t\t</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">;</span>\n</pre></td></tr></tbody></table></code></pre></figure>\n\n<p><img src=\"/wp-content/uploads/2015/01/final-sessionized-data.png\" alt=\"final-sessionized-data\" /></p>\n\n<h2 id=\"window-functions-will-you-marry-me\">Window Functions, Will You Marry Me?</h2>\n\n<p>The first time I was asked to try and solve sessionization of time-series data using Hive, I was sure the answer would be that I’d have to get a peer to write some nasty custom Java code to be able generate unique ids; in retrospect, the solution is so obvious and simple that I wish I would’ve tried to do this years ago. This is a pretty easy problem to solve using imperative programming, but if you’ve got a gigantic amount of hardware in a RDBMS or Hadoop, SQL takes care of all of the calculation without needing think through looping (or more complicated logic/data structures).</p>\n\n<p>Window functions fall into a weird space in the SQL language, given that they allow you to do sequential calculations when SQL should generally be thought of as “set-level” calculations (i.e. no implied order and table-wide calculations vs. row/state-specific). But now that I’ve got a hang of them, I can’t imagine my analytical life without them.</p>"
}