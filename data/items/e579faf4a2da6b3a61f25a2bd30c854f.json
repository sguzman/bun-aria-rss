{
  "title": "BorutaPy",
  "link": "",
  "published": "2015-05-08T18:25:00+01:00",
  "updated": "2015-05-08T18:25:00+01:00",
  "id": "https://danielhomola.com/feature%20selection/phd/borutapy-an-all-relevant-feature-selection-method",
  "content": "<h2 id=\"quick-summary\">Quick summary</h2>\n\n<p>There’s a pretty clever all-relevant feature selection method, which was conceived by Witold R. Rudnicki and developed by Miron B. Kursa at the ICM UW. Here is the <a title=\"Boruta\" href=\"https://www.jstatsoft.org/article/view/v036i11\" target=\"_blank\">publication</a>.</p>\n\n<p>While working on my PhD project I read their paper, really liked the method, but didn’t quite like how slow it was. It’s based on R’s Random Forest implementation which runs only on a single core.</p>\n\n<p>On the other hand, I knew that the core dev team working at scikit-learn on the Random Forest Classifier has made an incredible job at optimizing its performance making it the <a href=\"http://www.slideshare.net/glouppe/accelerating-random-forests-in-scikitlearn\" target=\"_blank\">fastest</a> implementation currently available. So I thought I’d re-implement the algorithm in Python. It runs pretty fast now, and has a scikit-learn like interface, so you can call fit(), transform() and fit_transform() on it. You can check it out on my <a title=\"BorutaPy\" href=\"https://github.com/danielhomola/boruta_py\" target=\"_blank\">GitHub</a>.</p>\n\n<p>Miron kindly agreed to benchmark it against his original version so it might get modified, but in the meanwhile please feel free to use it and let me know what you think!</p>\n\n<h2 id=\"background\">Background</h2>\n\n<h3 id=\"whats-feature-selection\">What’s feature selection?</h3>\n\n<p>In many data analysis and modelling projects we end up with hundreds or thousands of collected features. Even worse, sometimes we have way more features than samples. It is a setting that is becoming increasingly common, at least in biomedical sciences for sure. This is called a small n large p situation, which pretty much means you’re left with regularized (preferably lasso) regression techniques if you want to avoid massively over-fitting your data.</p>\n\n<p>But fortunately most of the time not all your variables are interesting or relevant to the stuff you’re trying to understand/model. So you can try to devise clever ways to select the important ones and incorporate only those into your model, this is called feature selection and there are loads of published methods floating around.</p>\n\n<h3 id=\"doing-the-simple-way\">Doing the simple way</h3>\n\n<p>Probably the easiest way to go about feature selection, is to do some univariate test on each of your features relating it to the predicted outcome, and select the ones that do pretty well based on some obscenely arbitrary measure or some simple statistical test.</p>\n\n<p>This is simple and quick, but also univariate, which means it’s probably only useful if you can guarantee that all of your features are completely independent. Unless you are modelling some simulated toy dataset this is never the case.</p>\n\n<p>In fact, one of the main reasons doing science is so incredibly hard is because of the many intricate unknown relationships between your measured variables and other confounders you haven’t even thought of. OK, so what else?</p>\n\n<h3 id=\"going-multivariate\">Going multivariate</h3>\n\n<p>Well, you can do feature selection using a multivariate model, like Support Vector Machine. First you fit it to your data and get the weights it assigns to each of your features. Then you can recursively get rid of features in each round which didn’t do too well, until you reach some predefined end point when you stop.</p>\n\n<p>This is definitely slower, but it is also presumably better as it’s multivariate meaning it will attempt to weigh in the various relationships between your predictive variables and select a set of features that together explain a lot of the variance in your data. On the other hand it is quite arbitrary when you stop, or how many features you get rid off at each round. I hear you say, you can do an exhaustive grid search on these hyper-parameters, or include some cross-validation to make sure you stop at the right point.</p>\n\n<p>But even then, this method essentially is maximizing a regressor’s or classifier’s performance by selecting an exceedingly pruned version of your input data matrix. This might be a good a thing, but it can also throw away a number of important features.</p>\n\n<h3 id=\"how-is-boruta-different\">How is Boruta different?</h3>\n\n<p>Boruta is an all-relevant feature selection method. It tries to capture all the important, interesting features you might have in your dataset with respect to an outcome variable.</p>\n\n<blockquote>\n  <p>Boruta is an all relevant feature selection method, while most other are minimal optimal; this means it tries to find all features carrying information usable for prediction, rather than finding a possibly compact subset of features on which some classifier has a minimal error.<br />Miron B. Kursa</p>\n</blockquote>\n\n<p>This makes it really well suited for biomedical data analysis, where we regularly collect measurements of thousands of features (genes, proteins, metabolites, microbiomes in your gut, etc), but we have absolutely no clue about which one is important in relation to our outcome variable, or where should we cut off the decreasing “importance function” of these.</p>\n\n<p>As with so many great algorithms the idea behind Boruta is really simple. First, we duplicate our dataset, and shuffle the values in each column, these are called shadow features.</p>\n\n<p>Then we train a classifier on our dataset, such that we get importances for each of our features. Tree ensemble methods such as Random Forest, Gradient Boosted Trees, and the Extra Trees Classifiers are really great not only because they can capture non-linear highly intricate relationships between your predictors, but also because they tend to handle the small n large p situation rather well.</p>\n\n<blockquote>\n  <p>Why should you care? For a start, when you try to understand the phenomenon that made your data, you should care about all factors that contribute to it, not just the bluntest signs of it in context of your methodology (yes, minimal optimal set of features by definition depends on your classifier choice).<br />Miron B. Kursa</p>\n</blockquote>\n\n<p>There is quite a lot of discussion about whether these methods can truly overfit your training data, but generally it is accepted that even if they do, this happens much later with them than with many other machine learning algorithms.</p>\n\n<p>Back to the Boruta. So we train one of these ensemble methods on our merged training data and shadow features (see the image below). Then we get the relative importance of each feature from the ensemble method: higher means better or more important.</p>\n\n<p>Then we check for each of our real features if they have higher importance than the best of the shadow features. If they do, we record this in a vector (these are called a hits) and continue with another iteration. After a predefined set of iterations we end up with a table of these hits.</p>\n\n<p>At every iteration we check if a given feature is doing better then expected than random chance. We do this by simply comparing the number of times a feature did better than the shadow features using a binomial distribution.</p>\n\n<p><img src=\"/assets/images/boruta.png\" alt=\"image-center\" class=\"align-center\" /></p>\n\n<p>In the case of feature #1 in the table below, out of 3 runs it did better than the best of shadow features 3 times. So we calculate a p-value  using the binomial distribution, k=3, n=3, p=0.5. As we do this for thousands of features we need to correct for multiple testing. The original method uses the rather conservative Bonferroni correction for this. We say a feature is confirmed to be important if its corrected p-value is lower than 0.01.</p>\n\n<p><img src=\"/assets/images/boruta2.png\" alt=\"image-center\" class=\"align-center\" /></p>\n\n<p>Then we remove its column from the original data matrix and continue with another iteration.</p>\n\n<p>Conversely if a feature hasn’t been recorded as a hit in say 15 iterations, we reject it and also remove it from the original matrix. After a set number of iterations (or if all the features have been either confirmed or rejected) we stop.</p>\n\n<p>For all the parameters and options please check the <a href=\"https://github.com/danielhomola/boruta_py\" target=\"_blank\">GitHub</a> site and the documentation for more details.</p>\n\n<h2 id=\"python-implementation\">Python implementation</h2>\n\n<p>The Python version requires <code class=\"language-plaintext highlighter-rouge\">numpy, scipy, scikit-learn</code> and <code class=\"language-plaintext highlighter-rouge\">bottleneck</code>, so you’ll need to install these before trying it, but then you can simply apply it to your dataset like this:</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-python\" data-lang=\"python\"><table class=\"rouge-table\"><tbody><tr><td class=\"gutter gl\"><pre class=\"lineno\">1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n</pre></td><td class=\"code\"><pre><span class=\"kn\">import</span> <span class=\"nn\">pandas</span>\n<span class=\"kn\">from</span> <span class=\"nn\">sklearn.ensemble</span> <span class=\"kn\">import</span> <span class=\"n\">RandomForestClassifier</span>\n<span class=\"kn\">from</span> <span class=\"nn\">boruta_py</span> <span class=\"kn\">import</span> <span class=\"n\">boruta_py</span>\n\n<span class=\"c1\"># load X and y\n</span><span class=\"n\">X</span> <span class=\"o\">=</span> <span class=\"n\">pd</span><span class=\"p\">.</span><span class=\"n\">read_csv</span><span class=\"p\">(</span><span class=\"s\">'my_X_table.csv'</span><span class=\"p\">,</span> <span class=\"n\">index_col</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">).</span><span class=\"n\">values</span>\n<span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">pd</span><span class=\"p\">.</span><span class=\"n\">read_csv</span><span class=\"p\">(</span><span class=\"s\">'my_y_vector.csv'</span><span class=\"p\">,</span> <span class=\"n\">index_col</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">).</span><span class=\"n\">values</span>\n\n<span class=\"c1\"># define random forest classifier, with utilising all cores and\n# sampling in proportion to y labels\n</span><span class=\"n\">forest</span> <span class=\"o\">=</span> <span class=\"n\">RandomForestClassifier</span><span class=\"p\">(</span><span class=\"n\">n_jobs</span><span class=\"o\">=-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">class_weight</span><span class=\"o\">=</span><span class=\"s\">'auto'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># define Boruta feature selection method\n</span><span class=\"n\">feat_selector</span> <span class=\"o\">=</span> <span class=\"n\">boruta_py</span><span class=\"p\">.</span><span class=\"n\">BorutaPy</span><span class=\"p\">(</span><span class=\"n\">forest</span><span class=\"p\">,</span> <span class=\"n\">n_estimators</span><span class=\"o\">=</span><span class=\"s\">'auto'</span><span class=\"p\">,</span> <span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># find all relevant features\n</span><span class=\"n\">feat_selector</span><span class=\"p\">.</span><span class=\"n\">fit</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># check selected features\n</span><span class=\"n\">feat_selector</span><span class=\"p\">.</span><span class=\"n\">support_</span>\n\n<span class=\"c1\"># check ranking of features\n</span><span class=\"n\">feat_selector</span><span class=\"p\">.</span><span class=\"n\">ranking_</span>\n\n<span class=\"c1\"># call transform() on X to filter it down to selected features\n</span><span class=\"n\">X_filtered</span> <span class=\"o\">=</span> <span class=\"n\">feat_selector</span><span class=\"p\">.</span><span class=\"n\">transform</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">)</span>\n</pre></td></tr></tbody></table></code></pre></figure>\n\n<p>Again, all of the parameters, attributes and methods are documented with docstrings so grab a copy or fork it and let me know what you think!</p>",
  "author": {
    "name": "danielhomola"
  },
  "category": [
    "",
    "",
    "",
    "",
    ""
  ],
  "summary": "An all relevant feature selection method based on Random Forest estimators"
}