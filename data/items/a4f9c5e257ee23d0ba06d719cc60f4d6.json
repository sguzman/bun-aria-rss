{
  "title": "Attending to characters in neural sequence labeling models",
  "link": "https://www.marekrei.com/blog/attending-to-characters-in-neural-sequence-labeling-models/",
  "comments": "https://www.marekrei.com/blog/attending-to-characters-in-neural-sequence-labeling-models/#comments",
  "dc:creator": "Marek",
  "pubDate": "Fri, 06 Jan 2017 23:09:50 +0000",
  "category": "Uncategorized",
  "guid": "http://www.marekrei.com/blog/?p=789",
  "description": "<p>Word embeddings are great. They allow us to represent words as distributed vectors, such that semantically and functionally similar words have similar representations. Having similar&#8230;</p>\n<p>The post <a rel=\"nofollow\" href=\"https://www.marekrei.com/blog/attending-to-characters-in-neural-sequence-labeling-models/\">Attending to characters in neural sequence labeling models</a> appeared first on <a rel=\"nofollow\" href=\"https://www.marekrei.com/blog\">Marek Rei</a>.</p>\n",
  "content:encoded": "<p>Word embeddings are great. They allow us to represent words as distributed vectors, such that semantically and functionally similar words have similar representations. Having similar vectors means these words also behave similarly in the model, which is what we want for good generalisation properties.</p>\n<p>However, word embeddings have a couple of weaknesses:</p>\n<ol>\n<li>If a word doesn&#8217;t exist in the training data, we can&#8217;t have an embedding for it. Therefore, the best we can do is clump all unseen words together under a single OOV (out-of-vocabulary) token.</li>\n<li>If a word only occurs a couple of times, the word embedding likely has very poor quality. We simply don&#8217;t have enough information to learn how these words behave in different contexts.</li>\n<li>We can&#8217;t properly take advantage of character-level patterns. For example, there is no way to learn that all words ending with <em>-ing</em> are likely to be verbs. The best we can do is learn this for each word separately, but that doesn&#8217;t help when faced with new or rare words.</li>\n</ol>\n<p>In this post I will look at different ways of extending word embeddings with character-level information, in the context of neural sequence labeling models.  You can find more information in the Coling 2016 paper &#8220;<a href=\"https://aclweb.org/anthology/C/C16/C16-1030.pdf\">Attending to characters in neural sequence labeling models</a>&#8220;.</p>\n<h2>Sequence labeling</h2>\n<p>We&#8217;ll investigate word representations in order to improve on the task of sequence labeling. In a sequence labeling setting, a system gets a series of tokens as input and it needs to assign a label to every token. The correct label typically depends on both the context and the token itself. Quite a large number of NLP tasks can be formulated as sequence labeling, for example:</p>\n<p><em><strong>POS-tagging</strong></em><br />\n<code><span style=\"color: #3366ff;\">DT</span>  <span style=\"color: #008000;\">NN</span>    <span style=\"color: #ff6600;\">VBD</span>      <span style=\"color: #008000;\">NNS</span>    IN      <span style=\"color: #3366ff;\">DT</span>   <span style=\"color: #3366ff;\">DT</span>  <span style=\"color: #008000;\">NN</span>     CC  <span style=\"color: #3366ff;\">DT</span>  <span style=\"color: #008000;\">NN</span>   .<br />\nThe pound extended losses against both the dollar and the euro .</code></p>\n<p><em><strong>Error detection</strong></em><br />\n<code>+ +    +  <span style=\"color: #ff0000;\">x</span>       +   +      +   +    +    <span style=\"color: #ff0000;\">x</span>      +<br />\nI like to playing the guitar and sing very louder .</code></p>\n<p><em><strong>Named entity recognition</strong></em><br />\n<code><span style=\"color: #ff6600;\">PER</span> _      _   _      _  <span style=\"color: #3366ff;\">ORG</span>  <span style=\"color: #3366ff;\">ORG</span>   _  <span style=\"color: #008000;\">TIME</span> _<br />\nJim bought 300 shares of Acme Corp. in 2006 .</code></p>\n<p><em><strong>Chunking</strong></em><br />\n<code><span style=\"color: #008000;\">B-NP</span>    B-PP <span style=\"color: #008000;\">B-NP</span> <span style=\"color: #008000;\">I-NP</span> <span style=\"color: #ff6600;\">B-VP</span> <span style=\"color: #ff6600;\">I-VP</span>     <span style=\"color: #ff6600;\">I-VP</span> <span style=\"color: #ff6600;\">I-VP</span>   B-PP <span style=\"color: #008000;\">B-NP</span> <span style=\"color: #008000;\">B-NP</span>  O<br />\nService on   the  line is   expected to   resume by   noon today .</code></p>\n<p>In each of these cases, the model needs to understand how a word is being used in a specific context, and could also take advantage of character-level patterns and morphology.</p>\n<p><span id=\"more-789\"></span></p>\n<h2>Basic neural sequence labeling</h2>\n<p>Our baseline model for sequence labeling is as follows. Each word is represented as a 300-dimensional word embedding. This is passed through a bidirectional LSTM with hidden layers of size 200. The representations from both directions are concatenated, in order to get a word representation that is conditioned on the whole sentence. Next, we pass it through a 50-dimensional hidden layer and then an output layer, which can be a softmax or a CRF.</p>\n<p><a href=\"http://www.marekrei.com/blog/wp-content/uploads/2016/12/baseline_graph.png\" rel=\"attachment wp-att-790\"><img decoding=\"async\" loading=\"lazy\" class=\"aligncenter wp-image-790 size-medium\" src=\"http://www.marekrei.com/blog/wp-content/uploads/2016/12/baseline_graph-300x153.png\" alt=\"\" width=\"300\" height=\"153\" srcset=\"https://www.marekrei.com/blog/wp-content/uploads/2016/12/baseline_graph-300x153.png 300w, https://www.marekrei.com/blog/wp-content/uploads/2016/12/baseline_graph-150x76.png 150w, https://www.marekrei.com/blog/wp-content/uploads/2016/12/baseline_graph-768x391.png 768w, https://www.marekrei.com/blog/wp-content/uploads/2016/12/baseline_graph-1024x522.png 1024w, https://www.marekrei.com/blog/wp-content/uploads/2016/12/baseline_graph.png 1203w\" sizes=\"(max-width: 300px) 100vw, 300px\" /></a></p>\n<p>This configuration is based on a combination of my previous work on error detection (<a href=\"http://aclweb.org/anthology/P/P16/P16-1112.pdf\">Rei and Yannakoudakis, 2016</a>), and the models from <a href=\"https://aclweb.org/anthology/D/D14/D14-1080.pdf\">Irsoy and Cardie (2014)</a> and <a href=\"https://arxiv.org/abs/1603.01360\">Lample et al. (2016)</a>.</p>\n<h2>Concatenating character-based word representations</h2>\n<p>Now let&#8217;s look at an architecture that builds word representations from individual characters. We process each word separately and map characters to character embeddings. Next, these are passed through a bidirectional LSTM and the last states from either direction are concatenated. The resulting vector is passed through another feedforward layer, in order to map it to a suitable space and change the vector size as needed. We then have a word representation <strong>m</strong>, built from individual characters.</p>\n<p><a href=\"http://www.marekrei.com/blog/wp-content/uploads/2016/12/concat_graph.png\" rel=\"attachment wp-att-791\"><img decoding=\"async\" loading=\"lazy\" class=\"aligncenter size-medium wp-image-791\" src=\"http://www.marekrei.com/blog/wp-content/uploads/2016/12/concat_graph-300x245.png\" alt=\"concat_graph\" width=\"300\" height=\"245\" srcset=\"https://www.marekrei.com/blog/wp-content/uploads/2016/12/concat_graph-300x245.png 300w, https://www.marekrei.com/blog/wp-content/uploads/2016/12/concat_graph-150x122.png 150w, https://www.marekrei.com/blog/wp-content/uploads/2016/12/concat_graph-768x627.png 768w, https://www.marekrei.com/blog/wp-content/uploads/2016/12/concat_graph.png 796w\" sizes=\"(max-width: 300px) 100vw, 300px\" /></a></p>\n<p>We still have a normal word embedding <strong>x</strong> for each word, and in order to get the best of both worlds, we can combine these two representations. Following <a href=\"https://arxiv.org/abs/1603.01360\">Lample et al. (2016)</a>, one method is simply concatenating the character-based representation with the word embedding.</p>\n<p style=\"text-align: center;\">\\(<br />\n\\widetilde{x} = [x; m]<br />\n\\)</p>\n<p style=\"text-align: left;\">The resulting vector can then be used in the word-level sequence labeling model, instead of the regular word embedding. The whole network is connected together, so that the character-based component is also optimised during training.</p>\n<h2>Attending to character-based representations</h2>\n<p>Concatenating the two representations works, but we can do even better. We start off the same &#8211; character embeddings are passed through a bidirectional LSTM to build a word representation <strong>m</strong>. However, instead of concatenating this vector with the word embedding, we now combine them using dynamically predicted weights.</p>\n<p><a href=\"http://www.marekrei.com/blog/wp-content/uploads/2016/12/attention_graph.png\" rel=\"attachment wp-att-792\"><img decoding=\"async\" loading=\"lazy\" class=\"aligncenter size-medium wp-image-792\" src=\"http://www.marekrei.com/blog/wp-content/uploads/2016/12/attention_graph-300x238.png\" alt=\"attention_graph\" width=\"300\" height=\"238\" srcset=\"https://www.marekrei.com/blog/wp-content/uploads/2016/12/attention_graph-300x238.png 300w, https://www.marekrei.com/blog/wp-content/uploads/2016/12/attention_graph-150x119.png 150w, https://www.marekrei.com/blog/wp-content/uploads/2016/12/attention_graph-768x611.png 768w, https://www.marekrei.com/blog/wp-content/uploads/2016/12/attention_graph.png 834w\" sizes=\"(max-width: 300px) 100vw, 300px\" /></a></p>\n<p>A vector of weights <strong>z</strong> is predicted by the model, as a function of <strong>x</strong> and <strong>m</strong>. In this case, we use a two-layer feedforward component, with <em>tanh</em> activation in the first layer and <em>sigmoid</em> on the second layer.</p>\n<p style=\"text-align: center;\">\\(<br />\nz = \\sigma(W^{(3)}_z tanh(W^{(1)}_{z} x + W^{(2)}_{z} m))<br />\n\\)</p>\n<p style=\"text-align: left;\">Then, we combine <strong>x</strong> and <strong>m</strong> as a weighted sum, using <strong>z</strong> as the weights:</p>\n<p style=\"text-align: center;\">\\(<br />\n\\widetilde{x} = z\\cdot x + (1-z) \\cdot m<br />\n\\)</p>\n<p style=\"text-align: left;\">This operation essentially looks at both word representations and decides, for each feature, whether it wants to take the value from the word embedding or from the character-based representation. Values close to 1 in <strong>z</strong> indicate higher weight for the word embedding, and values close to 0 assign more importance to the character-based vector.</p>\n<p style=\"text-align: left;\">This combination requires that the two vectors are aligned &#8211; each feature position in the character-based representation needs to capture the same properties as that position in the word embedding. In order to encourage this property, we actively optimise for these vectors to be similar, by maximising their cosine similarity:</p>\n<p style=\"text-align: center;\">\\(<br />\n\\widetilde{E} = E + \\sum_{t=1}^{T} g_t (1 &#8211; cos(m^{(t)}, x_t)) \\hspace{3em}<br />\ng_t =<br />\n\\begin{cases}<br />\n0, & \\text{if}\\ w_t = OOV \\\\<br />\n1, & \\text{otherwise}<br />\n\\end{cases}<br />\n\\)</p>\n<p style=\"text-align: left;\">E is the main sequence labeling loss function that we minimise during training, T is the length of the sequence or sentence. Many OOV words share the same representation, and we do not want to optimise for this, therefore we use a variable g that limits optimisation only to non-OOV words.</p>\n<p style=\"text-align: left;\">In this setting, the model essentially learns two alternative representations for each word &#8211; a regular word embedding and a character-based representation. The word embedding itself is kind of a universal memory &#8211; we assign 300 elements to a word, and the model is free to save any information into it, including approximations of character-level information. For frequent words, there is really no reason to think that the character-based representation can offer much additional benefit. However, using word embeddings to save information is very inefficient &#8211; each feature needs to be learned and saved for every word separately. Therefore, we hope to get two benefits from including characters into the model:</p>\n<ol>\n<li style=\"text-align: left;\">Previously unseen (OOV) words and infrequent words with low-quality embeddings can get extra information from character features and morphemes.</li>\n<li style=\"text-align: left;\">The character-based component can act as a highly-generalised model of typical character-level patterns, allowing the word embeddings to act as a memory for storing exceptions to these patterns for each specific word.</li>\n</ol>\n<p>While we optimise for the cosine similarity of <strong>m</strong> and <strong>x</strong> to be high, we are essentially teaching the model to predict distributional properties based only on character-level patterns and morphology. However, while <strong>m</strong> is optimised to be similar to <strong>x</strong>, we implement it in such a way that <strong>x</strong> is not optimised to be similar to <strong>m</strong> (using <a href=\"http://deeplearning.net/software/theano/library/gradient.html#theano.gradient.disconnected_grad\">disconnected_grad</a> in Theano). Because word embeddings are more flexible, we want them to store exceptions as opposed to learning more general patterns.</p>\n<p>The resulting combined word representation is again plugged directly into the sequence labeling model. All the components, including the attention component for dynamically calculating <strong>z</strong>, are optimised at the same time.</p>\n<h2>Evaluation</h2>\n<p>We evaluated the alternative architectures on 8 different datasets, covering 4 different tasks: NER, POS-tagging, error detection and chunking. See the paper for more detailed results, but here is a summary:</p>\n<div class=\"table-responsive\"><table  style=\"width:100%; \"  class=\"easy-table easy-table-default \" border=\"0\">\n<thead>\n<tr><th >Dataset</th>\n<th >Task</th>\n<th >#labels</th>\n<th >Measure</th>\n<th >Word-based</th>\n<th >Char concat</th>\n<th >Char attn</th>\n</tr>\n</thead>\n<tbody>\n<tr><td >CoNLL00</td>\n<td >chunking</td>\n<td >22</td>\n<td >F1</td>\n<td >91.23</td>\n<td >92.35</td>\n<td ><strong>92.67</strong></td>\n</tr>\n\n<tr><td >CoNLL03</td>\n<td >NER</td>\n<td >8</td>\n<td >F1</td>\n<td >79.86</td>\n<td >83.37</td>\n<td ><strong>84.09</strong></td>\n</tr>\n\n<tr><td >PTB-POS</td>\n<td >POS-tagging</td>\n<td >48</td>\n<td >accuracy</td>\n<td > 96.42 </td>\n<td >97.22</td>\n<td ><strong>97.27</strong></td>\n</tr>\n\n<tr><td >FCEPUBLIC</td>\n<td >error detection</td>\n<td >2</td>\n<td >F0.5</td>\n<td >41.24</td>\n<td >41.27</td>\n<td ><strong>41.88</strong></td>\n</tr>\n\n<tr><td >BC2GM</td>\n<td >NER</td>\n<td >3</td>\n<td >F1*</td>\n<td >84.21</td>\n<td >87.75</td>\n<td ><strong>87.99</strong></td>\n</tr>\n\n<tr><td >CHEMDNER</td>\n<td >NER</td>\n<td >3</td>\n<td >F1</td>\n<td >79.74</td>\n<td >83.56</td>\n<td ><strong>84.53</strong></td>\n</tr>\n\n<tr><td >JNLPBA</td>\n<td >NER</td>\n<td >11</td>\n<td >F1</td>\n<td >70.75</td>\n<td >72.24</td>\n<td ><strong>72.70</strong></td>\n</tr>\n\n<tr><td >GENIA-POS</td>\n<td >POS-tagging</td>\n<td >42</td>\n<td >accuracy</td>\n<td >97.39</td>\n<td >98.49</td>\n<td ><strong>98.60</strong></td>\n</tr>\n</tbody></table></div>\n<p>As can be seen, including a character-based component into the sequence labeling model helps on every task. In addition, using the attention-based architecture outperforms character concatenation on all benchmarks.</p>\n<p>We also compared the number of parameters in each model. While both character-based models require more parameters compared to a basic architecture using only word embeddings, the attention-based architecture is actually more efficient compared to concatenation. If the vectors are simply concatenated, this increases the size of all the weight matrices in the proceeding LSTMs, whereas the attention framework combines them without increasing length.</p>\n<p><a href=\"https://arxiv.org/abs/1606.01700\">Miyamoto and Cho (2016)</a> have independently also proposed a similar architecture, with some differences: 1) They focus on the task of language modeling, 2) they predict a scalar weight for combining the representations as opposed to making the decision separately for each element, 3) they do not condition the weights on the character-based representation, and 4) they do not have the component that optimises character-based representations to be similar to the word embeddings.</p>\n<p>Since this model is aimed at learning morphological patterns, you might ask why are we not giving actual morphemes as input to the model, instead of starting from individual characters. The reason is that the definition of an informative morpheme is likely to change between tasks and datasets, and this allows the model to learn exactly what it finds most useful. The model for POS tagging can learn to detect specific suffixes, and the model for NER can focus more on capitalisation patterns.</p>\n<h2>Conclusion</h2>\n<p>Combining word embeddings with character-based representations makes neural models more powerful and allows us to have better representations for infrequent or unseen words. One option is to concatenate the two representations, treating them as separate sets of useful features. Alternatively, we can optimise them to be similar and combine them using a gating mechanism, essentially allowing the model to choose whether it wants to take each feature from the word embedding of from the character-based representation. We evaluated on 8 different sequence labeling datasets and found that the latter option performed consistently better, even with a fewer number of parameters.</p>\n<p>See the paper for more details:<br />\n<a href=\"https://aclweb.org/anthology/C/C16/C16-1030.pdf\">https://aclweb.org/anthology/C/C16/C16-1030.pdf</a></p>\n<p>I have made the code for running these experiments publicly available on github:<br />\n<a href=\"https://github.com/marekrei/sequence-labeler\">https://github.com/marekrei/sequence-labeler</a></p>\n<p>Also, the dataset for performing error detection as a sequence labeling task is now available online:<br />\n<a href=\"http://ilexir.co.uk/datasets/index.html\">http://ilexir.co.uk/datasets/index.html</a></p>\n<p>The post <a rel=\"nofollow\" href=\"https://www.marekrei.com/blog/attending-to-characters-in-neural-sequence-labeling-models/\">Attending to characters in neural sequence labeling models</a> appeared first on <a rel=\"nofollow\" href=\"https://www.marekrei.com/blog\">Marek Rei</a>.</p>\n",
  "wfw:commentRss": "https://www.marekrei.com/blog/attending-to-characters-in-neural-sequence-labeling-models/feed/",
  "slash:comments": 8
}