{
  "title": "Notes on running containers with bubblewrap",
  "link": "",
  "updated": "2022-06-28T12:24:34+00:00",
  "id": "https://jvns.ca/blog/2022/06/28/some-notes-on-bubblewrap/",
  "content": "\n\n<p>Hello! About a year ago I got mad about Docker container startup time. This was\nbecause I was building an <a href=\"https://jvns.ca/blog/2021/09/24/new-tool--an-nginx-playground/\">nginx playground</a>\nwhere I was starting a new &ldquo;container&rdquo; on every HTTP request, and so for it to\nfeel reasonably snappy, nginx needed to start quickly.</p>\n\n<p>Also, I was running this project on a pretty small cloud machine (256MB RAM), a\nsmall CPU, so I really wanted to avoid unnecessary overhead.</p>\n\n<p>I&rsquo;ve been looking for a way to run containers faster since then, but I couldn&rsquo;t\nfind one until last week when I discovered\n<a href=\"https://github.com/containers/bubblewrap\">bubblewrap</a>!! It&rsquo;s very fast and I\nthink it&rsquo;s super cool, but I also ran into a bunch of fun problems that I\nwanted to write down for my future self.</p>\n\n<h3 id=\"some-disclaimers\">some disclaimers</h3>\n\n<ul>\n<li>I&rsquo;m not sure if the way I&rsquo;m using bubblewrap in this post is maybe not how it&rsquo;s intended to be used</li>\n<li>there are a lot of sharp edges when using bubblewrap in this way, you need to\nthink a lot about Linux namespaces and how containers work</li>\n<li>bubblewrap is a security tool but I am not a security person and I am only\ndoing this for weird tiny projects. you should definitely not take security\nadvice from me.</li>\n</ul>\n\n<p>Okay, all of that said, let&rsquo;s talk about I&rsquo;m trying to use bubblewrap to run\ncontainers fast and in a relatively secure way :)</p>\n\n<h3 id=\"docker-containers-take-300ms-to-start-on-my-machine\">Docker containers take ~300ms to start on my machine</h3>\n\n<p>I ran a quick benchmark to see how long a Docker container takes to run a\nsimple command (<code>ls</code>). For both Docker and Podman, it&rsquo;s about 300ms.</p>\n\n<pre><code>$ time docker run --network none -it ubuntu:20.04 ls / > /dev/null\nExecuted in  378.42 millis \n$ time podman run --network none -it ubuntu:20.04 ls / > /dev/null\nExecuted in  279.27 millis\n</code></pre>\n\n<p>Almost all of this time is overhead from docker and podman &ndash; just running <code>ls</code>\nby itself takes about 3ms:</p>\n\n<pre><code>$ time ls / > /dev/null\nExecuted in    2.96 millis \n</code></pre>\n\n<p>I want to stress that, while I&rsquo;m not sure exactly what the slowest part of\nDocker and podman startup time is (I spent 5 minutes trying to profile them and\ngave up), I&rsquo;m 100% sure it&rsquo;s something important.</p>\n\n<p>The way we&rsquo;re going to run containers faster with bubblewrap has a lot of\nlimitations and it&rsquo;s a lower level interface which is a lot trickier to use.</p>\n\n<h3 id=\"goal-1-containers-that-start-quickly\">goal 1: containers that start quickly</h3>\n\n<p>I felt like it <em>should</em> be possible to have containers that start essentially\ninstantly or at least in less than 5ms. My thought process:</p>\n\n<ul>\n<li>creating a new namespace with <code>unshare</code> is basically instant</li>\n<li><a href=\"https://jvns.ca/blog/2016/10/10/what-even-is-a-container/\">containers are basically just a bunch of namespaces</a></li>\n<li>what&rsquo;s the problem?</li>\n</ul>\n\n<h3 id=\"container-startup-time-is-usually-not-that-important\">container startup time is (usually) not that important</h3>\n\n<p>Most of the time when people are using containers, they&rsquo;re running some\nlong-running process inside the container like a webserver, so it doesn&rsquo;t\nreally matter if it takes 300ms to start.</p>\n\n<p>So it makes sense to me that there aren&rsquo;t a lot of container tools that\noptimize for startup time. But I still wanted to optimize for startup time :)</p>\n\n<h3 id=\"goal-2-run-the-containers-as-an-unprivileged-user\">goal 2: run the containers as an unprivileged user</h3>\n\n<p>Another goal I had was to be able to run my containers as an unprivileged user\ninstead of root.</p>\n\n<p>I was surprised the first time I learned that Docker actually runs containers\nas root &ndash; even though I run <code>docker run ubuntu:20.04</code> as an unprivileged user (<code>bork</code>), that\nmessage is actually sent to a daemon running as root, and the Docker container\nprocess itself also runs as root (albeit a <code>root</code> that&rsquo;s stripped of all its\ncapabilities).</p>\n\n<p>That&rsquo;s fine for Docker (they have lots of very smart people making sure that\nthey get it right!), but if I&rsquo;m going to do container stuff <em>without</em> using\nDocker (for the speed reasons mentioned above), I&rsquo;d rather not do it as root to\nkeep everything a bit more secure.</p>\n\n<h3 id=\"podman-can-run-containers-as-an-non-root-user\">podman can run containers as an non-root user</h3>\n\n<p>Before we start talking about how to do weird stuff with bubblewrap, I want to\nquickly talk about a much more normal tool to run containers: podman!</p>\n\n<p>Podman, unlike Docker, can run containers as an unprivileged user!</p>\n\n<p>If I run this from my normal user:</p>\n\n<pre><code>$ podman run -it ubuntu:20.04 ls\n</code></pre>\n\n<p>it doesn&rsquo;t secretly run as root behind the scenes! It just starts the container\nas my normal user, and then uses something called &ldquo;user namespaces&rdquo; so that\n<em>inside the container</em> I appear to be root.</p>\n\n<p>The other cool thing aboud podman is that it has exactly the same interface as\nDocker, so you can just take a Docker command and replace <code>docker</code> with\n<code>podman</code> and it&rsquo;ll Just Work. I&rsquo;ve found that sometimes I need to do some extra\nwork to get podman to work in practice, but it&rsquo;s still pretty nice that it has\nthe same command line interface.</p>\n\n<p>This &ldquo;run containers as a non-root user&rdquo; feature is normally called &ldquo;rootless\ncontainers&rdquo;. (I find that name kind of counterintuitive, but that&rsquo;s what people call it)</p>\n\n<h3 id=\"failed-attempt-1-write-my-own-tool-using-runc\">failed attempt 1: write my own tool using <code>runc</code></h3>\n\n<p>I knew that Docker and podman use\n<a href=\"https://github.com/opencontainers/runc\">runc</a> (or maybe <code>crun</code>? I can&rsquo;t keep track honestly) under the hood, so I thought &ndash;\nwell, maybe I can just use <code>runc</code> directly to make my own tool that starts\ncontainers faster than Docker does!</p>\n\n<p>I tried to do this 6 months ago and I don&rsquo;t remember most of the details, but basically\nI spent 8 hours working on it, got frustrated because I couldn&rsquo;t get anything\nto work, and gave up.</p>\n\n<p>One specific detail I remember struggling with was setting up a working <code>/dev</code>\nfor my programs to use.</p>\n\n<h3 id=\"enter-bubblewrap\">enter bubblewrap</h3>\n\n<p>Okay, that was a very long preamble so let&rsquo;s get to the point! Last week, I\ndiscovered a tool called <code>bubblewrap</code> that was basically exactly the thing I\nwas trying to build with <code>runc</code> in my failed attempt, except that it actually\nworks and has many more features and it&rsquo;s built by people who know things about\nsecurity! Hooray!</p>\n\n<p>The interface to bubblewrap is pretty different than the interface to Docker &ndash;\nit&rsquo;s much lower level.  There&rsquo;s no concept of a container image &ndash; instead you\nmap a bunch of directories on your host to directories in the container.</p>\n\n<p>For example, here&rsquo;s how to run a container with the same root directory as your\nhost operating system, but with only read access to that root directory, and only write access to <code>/tmp</code>.</p>\n\n<pre><code>bwrap \\\n    --ro-bind / / \\\n    --bind /tmp /tmp \\\n    --proc /proc --dev /dev \\\n    --unshare-pid \\\n    --unshare-net \\\n    bash\n</code></pre>\n\n<p>For example, you could imagine running some untrusted process under bubblewrap\nthis way and then putting all the files you want the process to be able to access in <code>/tmp</code>.</p>\n\n<h3 id=\"bubblewrap-runs-containers-as-an-unprivileged-non-root-user\">bubblewrap runs containers as an unprivileged (non-root) user</h3>\n\n<p>Like podman, bubblewrap runs containers as a non-root user, using user\nnamespaces. It can also run containers as root, but in this post we&rsquo;re just\ngoing to be talking about using it as an unprivileged user.</p>\n\n<h3 id=\"bubblewrap-is-fast\">bubblewrap is fast</h3>\n\n<p>Let&rsquo;s see how long it takes to run <code>ls</code> in a bubblewrap container!</p>\n\n<pre><code>$ time bwrap --ro-bind / / --proc /proc --dev /dev --unshare-pid ls /\nExecuted in    8.04 millis\n</code></pre>\n\n<p>That&rsquo;s a big difference! 8ms is a lot faster than 279ms.</p>\n\n<p>Of course, like we said before, the reason bubblewrap is faster is that it does\na lot less. So let&rsquo;s talk about some things bubblewrap doesn&rsquo;t do.</p>\n\n<h3 id=\"some-things-bubblewrap-doesn-t-do\">some things bubblewrap doesn&rsquo;t do</h3>\n\n<p>Here are some things that Docker/podman do that bubblewrap doesn&rsquo;t do:</p>\n\n<ul>\n<li>set up overlayfs mounts for you, so that your changes to the filesystem don&rsquo;t affect the base image</li>\n<li>set up networking bridges so that you can connect to a webserver inside the container</li>\n<li>probably a bunch more stuff that I&rsquo;m not thinking of</li>\n</ul>\n\n<p>In general, bubblewrap is a much lower level tool than something like Docker.</p>\n\n<p>Also, bubblewrap seems to have pretty different goals than Docker &ndash; the README\nseems to say that it&rsquo;s intended as a tool for sandboxing desktop software (I\nthink it comes from <a href=\"https://flatpak.org/\">flatpak</a>).</p>\n\n<h3 id=\"running-a-container-image-with-bubblewrap\">running a container image with bubblewrap</h3>\n\n<p>I couldn&rsquo;t find instructions for running a Docker container image with\nbubblewrap, so here they are. Basically I just use Docker to download the\ncontainer image and put it into a directory and then run it with <code>bwrap</code>:</p>\n\n<p>There&rsquo;s also a tool called <a href=\"https://github.com/projectatomic/bwrap-oci\">bwrap-oci</a> which looks cool but I\ncouldn&rsquo;t get it to compile.</p>\n\n<pre><code>mkdir rootfs\ndocker export $(docker create frapsoft/fish) | tar -C rootfs -xf -\nbwrap \\\n    --bind $PWD/rootfs / \\\n    --proc /proc --dev /dev \\\n    --uid 0 \\\n    --unshare-pid \\\n    --unshare-net \\\n    fish\n</code></pre>\n\n<p>One important thing to note is that this doesn&rsquo;t create a temporary overlay\nfilesystem for the container&rsquo;s file writes, so it&rsquo;ll let the container edit\nfiles in the image.</p>\n\n<p>I wrote a post about <a href=\"https://jvns.ca/blog/2019/11/18/how-containers-work--overlayfs/\">overlay filesystems</a> if\nyou want to see how you could do that yourself though.</p>\n\n<h3 id=\"running-containers-with-bubblewrap-isn-t-the-same-as-with-podman\">running &ldquo;containers&rdquo; with bubblewrap isn&rsquo;t the same as with podman</h3>\n\n<p>I just gave an example of how to &ldquo;run a container&rdquo; with bubblewrap, and you\nmight think &ldquo;cool, this is just like podman but faster!&rdquo;. It is not, and it&rsquo;s\nactually unlike using podman in even more ways than I expected.</p>\n\n<p>I put &ldquo;container&rdquo; in scare quotes because there are two ways to define &ldquo;container&rdquo;:</p>\n\n<ul>\n<li>something that implements <a href=\"https://opencontainers.org/about/overview/\">OCI runtime specification</a></li>\n<li>any way of running a process in a way that&rsquo;s somehow isolated from the host system</li>\n</ul>\n\n<p>bubblewrap is a &ldquo;container&rdquo; tool in the second sense. It definitely provides\nisolation, and it does that using the same features &ndash; Linux namespaces &ndash; as\nDocker.</p>\n\n<p>But it&rsquo;s not a container tool in the first sense. And it&rsquo;s a lower level tool\nso you can get into a bunch of weird states and you really need to think about\nall the weird details of how container work while using it.</p>\n\n<p>For the rest of the post I&rsquo;m going to talk about some weird things that can\nhappen with bubblewrap that would not happen with podman/Docker.</p>\n\n<h3 id=\"weird-thing-1-processes-that-don-t-exist\">weird thing 1: processes that don&rsquo;t exist</h3>\n\n<p>Here&rsquo;s an example of a weird situation I got into with bubblewrap that confused\nme for a minute:</p>\n\n<pre><code>$ bwrap --ro-bind / / --unshare-all bash\n$ ps aux\n... some processes\nroot      390073  0.0  0.0   2848   124 pts/9    S    14:28   0:00 bwrap --ro-bind / / --unshare-all --uid 0 bash\n... some other processes\n$ kill 390073\nbash: kill: (390073) - No such process\n$ ps aux | grep 390073\nroot      390073  0.0  0.0   2848   124 pts/9    S    14:28   0:00 bwrap --ro-bind / / --unshare-all --uid 0 bash\n</code></pre>\n\n<p>Here&rsquo;s what happened</p>\n\n<ul>\n<li>I started a bash shell inside bubblewrap</li>\n<li>I ran <code>ps aux</code>, and saw a process with PID  <code>390073</code></li>\n<li>I try to kill the process. It fails with the error <code>no such process</code>. What?</li>\n<li>I ran <code>ps aux</code>, and still see the process with PID  <code>390073</code></li>\n</ul>\n\n<p>What&rsquo;s going on? Why doesn&rsquo;t the process <code>390073</code> exist, even though <code>ps</code> says it does? Isn&rsquo;t that impossible?</p>\n\n<p>Well, the problem is that <code>ps</code> doesn&rsquo;t actually list all the processes in your\ncurrent PID namespace. Instead, it iterates through all the entries in <code>/proc</code>\nand prints those out. Usually, what&rsquo;s in <code>/proc</code> is actually the same as the processes on your system.</p>\n\n<p>But with Linux containers these things can get out of sync. What&rsquo;s happening in\nthis example is that we have the <code>/proc</code> from the host PID namespace, but those\naren&rsquo;t actually the processes that we have access to in our PID namespace.</p>\n\n<p>Passing <code>--proc /proc</code> to bwrap fixes the issue &ndash; <code>ps</code> then actually lists the correct processes.</p>\n\n<pre><code>$ bwrap --ro-bind / / --unshare-all --dev /dev --proc /proc ps aux\nUSER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\nbork           1  0.0  0.0   3644   136 ?        S+   16:21   0:00 bwrap --ro-bind / / --unshare-all --dev /dev --proc /proc ps au\nbork           2  0.0  0.0  21324  1552 ?        R+   16:21   0:00 ps aux\n</code></pre>\n\n<p>Just 2 processes! Everything is normal!</p>\n\n<h3 id=\"weird-thing-2-trying-to-listen-on-port-80\">weird thing 2: trying to listen on port 80</h3>\n\n<p>Passing <code>--uid 0</code> to bubblewrap makes the user inside the container <code>root</code>. You\nmight think that this means that the root user has administrative privileges\ninside the container, but that&rsquo;s not true!</p>\n\n<p>For example, let&rsquo;s try to listen on port 80:</p>\n\n<pre><code>$ bwrap --ro-bind / / --unshare-all --uid 0 nc -l 80\nnc: Permission denied\n</code></pre>\n\n<p>What&rsquo;s going on here is that the new root user actually doesn&rsquo;t have the\n<strong>capabilities</strong> it needs to listen on port 80. (you need special permissions\nto listen on ports less than 1024, and 80 is less than 1024)</p>\n\n<p>There&rsquo;s actually a capability specifically for listening on privileged ports\ncalled <code>CAP_NET_BIND_SERVICE</code>.</p>\n\n<p>So to fix this all we need to do is to tell bubblewrap to give our user that\ncapability.</p>\n\n<pre><code>$ bwrap --ro-bind / / --unshare-all --uid 0 --cap-add cap_net_bind_service nc -l 80\n(no output, success!!!)\n</code></pre>\n\n<p>This works! Hooray!</p>\n\n<h3 id=\"finding-the-right-capabilities-is-pretty-annoying\">finding the right capabilities is pretty annoying</h3>\n\n<p>bubblewrap doesn&rsquo;t give out any capabilities by default, and I find that\nfiguring out all the right capabilities and adding them manually is kind of\nannoying. Basically my process is</p>\n\n<ul>\n<li>run the thing</li>\n<li>see what fails</li>\n<li>read <code>man capabilities</code> to figure out what capabilities I&rsquo;m missing</li>\n<li>add the capability with <code>--cap-add</code></li>\n<li>repeat until everything is running</li>\n</ul>\n\n<p>But that&rsquo;s the price I pay for wanting things to be fast I guess :)</p>\n\n<h3 id=\"weird-thing-2b-dev-dev-makes-listening-on-privileged-ports-not-work\">weird thing 2b:  <code>--dev /dev</code> makes listening on privileged ports not work</h3>\n\n<p>One other strange thing is that if I take the exact same command above (which\nworked!) and add <code>--dev /dev</code> (to set up the <code>/dev/</code> directory), it causes it to not work again:</p>\n\n<pre><code>$ bwrap --ro-bind / / --dev /dev --unshare-all --uid 0 --cap-add cap_net_bind_service nc -l 80\nnc: Permission denied\n</code></pre>\n\n<p>I think this might be a bug in bubblewrap, but I haven&rsquo;t mustered the courage\nto dive into the bubblewrap code and start investigating yet. Or maybe there&rsquo;s\nsomething obvious I&rsquo;m missing!</p>\n\n<h3 id=\"weird-thing-3-uid-mappings\">weird thing 3: UID mappings</h3>\n\n<p>Another slightly weird thing was &ndash; I tried to run <code>apt-get update</code> inside a bubblewrap Ubuntu container and everything went very poorly.</p>\n\n<p>Here&rsquo;s how I ran <code>apt-get update</code> inside the Ubuntu container:</p>\n\n<pre><code>mkdir rootfs\ndocker export $(docker create ubuntu:20.04) | tar -C rootfs -xf -\nbwrap \\\n    --bind $PWD/rootfs / \\\n    --proc /proc\\\n    --uid 0 \\\n    --unshare-pid \\\n    apt-get update\n</code></pre>\n\n<p>And here are the error messages:</p>\n\n<pre><code>E: setgroups 65534 failed - setgroups (1: Operation not permitted)\nE: setegid 65534 failed - setegid (22: Invalid argument)\nE: seteuid 100 failed - seteuid (22: Invalid argument)\nE: setgroups 0 failed - setgroups (1: Operation not permitted)\n.... lots more similar errors\n</code></pre>\n\n<p>At first I thought &ldquo;ok, this is a capabilities problem, I need to set\n<code>CAP_SETGID</code> or something to give the container permission to change groups. But I did that and it didn&rsquo;t help at all!</p>\n\n<p>I think what&rsquo;s going on here is a problem with UID maps. What are UID maps?\nWell, every time you run a container using &ldquo;user namespaces&rdquo; (which podman is\ndoing), it creates a mapping of UIDs inside the container to UIDs on the host.</p>\n\n<p>Let&rsquo;s look that the UID maps! Here&rsquo;s how to do that:</p>\n\n<pre><code>root@kiwi:/# cat /proc/self/uid_map \n         0       1000          1\nroot@kiwi:/# cat /proc/self/gid_map \n      1000       1000          1\n</code></pre>\n\n<p>This is saying that user 0 in the container is mapped to user 1000 on in the\nhost, and group 1000 is mapped to group 1000. (My normal user&rsquo;s UID/GID is 1000, so this makes sense). You can find out\nabout this <code>uid_map</code> file in <code>man user_namespaces</code>.</p>\n\n<p>All other users/groups that aren&rsquo;t 1000 are mapped to user 65534 by default, according\nto <code>man user_namespaces</code>.</p>\n\n<h3 id=\"what-s-going-on-non-mapped-users-can-t-be-used\">what&rsquo;s going on: non-mapped users can&rsquo;t be used</h3>\n\n<p>The only users and groups that have been mapped are <code>0</code> and <code>1000</code>. But <code>man user_namespaces</code> says:</p>\n\n<blockquote>\n<p>After the uid_map and gid_map files have been written, only the mapped values may be used in system calls that change user and group IDs.</p>\n</blockquote>\n\n<p><code>apt</code> is trying to use users 100 and 65534. Those aren&rsquo;t on the list of mapped\nusers! So they can&rsquo;t be used!</p>\n\n<p>This works fine in podman, because podman sets up its UID and GID mappings differently:</p>\n\n<pre><code>$ podman run -it ubuntu:20.04 bash\nroot@793d03a4d773:/# cat /proc/self/uid_map\n         0       1000          1\n         1     100000      65536\nroot@793d03a4d773:/# cat /proc/self/gid_map\n         0       1000          1\n         1     100000      65536\n</code></pre>\n\n<p>All the users get mapped, not just 1000.</p>\n\n<p>I don&rsquo;t quite know how to fix this, but I think it&rsquo;s probably possible in\nbubblewrap to set up the uid mappings the same way as podman does &ndash; there&rsquo;s an\n<a href=\"https://github.com/containers/bubblewrap/issues/468\">issue about it here that links to a workaround</a>.</p>\n\n<p>But this wasn&rsquo;t an actual problem I was trying to solve so I didn&rsquo;t dig further\ninto it.</p>\n\n<h3 id=\"a-quick-note-on-firecracker\">a quick note on Firecracker</h3>\n\n<p>Someone asked &ldquo;would Firecracker work here?&rdquo; (I <a href=\"https://jvns.ca/blog/2021/01/23/firecracker--start-a-vm-in-less-than-a-second/\">wrote about Firecracker</a> last year).</p>\n\n<p>My experience with Firecracker VMs is that they use kind of a lot of RAM (like\n50MB?), which makes sense because they&rsquo;re VMs. And when I tried Firecracker on\na tiny machine (with ~256MB of RAM / a tiny CPU), the startup times were 2-3\nseconds.</p>\n\n<p>I&rsquo;m sure it&rsquo;s possible to optimize Firecracker to be a bit faster, but at the\nend of the day I think it&rsquo;s a VM and it&rsquo;s not going to be anywhere near as low\noverhead as a process &ndash; there&rsquo;s a whole operating system to start!</p>\n\n<p>So Firecracker would add a lot more overhead than I want in this case.</p>\n\n<h3 id=\"bubblewrap-works-pretty-great\">bubblewrap works pretty great!</h3>\n\n<p>I&rsquo;ve talked about a bunch of issues, but the things I&rsquo;ve been trying to do in bubblewrap\nhave been very constrained and it&rsquo;s actually been pretty simple. For example, I\nwas working on a git project where I really just want to run <code>git</code> inside a\ncontainer and map a git repository from the host.</p>\n\n<p>That&rsquo;s very simple to get to work with bubblewrap! There were basically no weird problems!\nIt&rsquo;s really fast!</p>\n\n<p>So I&rsquo;m pretty excited about this tool and I might use it for more stuff in the\nfuture.</p>\n"
}