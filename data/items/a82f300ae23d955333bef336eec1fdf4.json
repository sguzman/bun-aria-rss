{
  "title": "Characteristic Functions",
  "link": "",
  "updated": "2012-12-03T00:00:00+00:00",
  "id": "https://mrocklin.github.io/blog/work/2012/12/03/Characteristic-Functions",
  "content": "<p>In a recent post, <a href=\"http://jpktd.blogspot.com/2012/12/characteristic-functions-and-scipystats.html\">Characteristic Functions and scipy.stats</a>, <a href=\"https://github.com/josef-pkt\">Josef Perktold</a> created functions for the <a href=\"http://en.wikipedia.org/wiki/Characteristic_function\">characteristic functions</a> of the <a href=\"http://en.wikipedia.org/wiki/Normal_distribution\">Normal</a> (easy) and <a href=\"http://en.wikipedia.org/wiki/Student%27s_t-distribution\">t</a> (hard) distributions.  The t-distribution is challenging because the solution involves special functions and has numerically challenging behavior around 0 for high degrees of freedom.  Some quotes</p>\n\n<p><em>The characteristic function for the normal distribution is easy, but looking at the characteristic function of the t-distribution, I wish someone had translated it into code already</em></p>\n\n<p><em>Since I haven’t seen it yet, I sat down and tried it myself. I managed to code the characteristic function of the t-distribution, but it returns NaNs when it is evaluated close to zero for large df.  I didn’t find a Bessel “k” function that works in this case</em></p>\n\n<p>He then includes his code and discusses a particular application of the characteristic function which I won’t discuss here.</p>\n\n<h2 id=\"symbolic-solution\">Symbolic Solution</h2>\n\n<p>Josef wished that this code had been written already.  Characteristic functions aren’t built into SymPy but we may be able to derive them automatically.</p>\n\n<p>Wikipedia says that the characteristic function \\(\\phi(t)\\) of a random variable <code class=\"language-plaintext highlighter-rouge\">X</code> is defined as follows</p>\n\n\\[\\phi_X(t) = E(e^{itX})\\]\n\n<p>It equal to the expectation of <code class=\"language-plaintext highlighter-rouge\">exp(i*t*X)</code>.  Lets do this in SymPy</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&gt;&gt;&gt; from sympy.stats import *\n&gt;&gt;&gt; mu = Symbol('mu', bounded=True)\n&gt;&gt;&gt; sigma = Symbol('sigma', positive=True, bounded=True)\n&gt;&gt;&gt; t = Symbol('t', positive=True)\n\n&gt;&gt;&gt; X = Normal('X', mu, sigma)  # Normal random variable\n&gt;&gt;&gt; simplify(E(exp(I*t*X)))     # Expectation of exp(I*t*X)\n              2  2\n             σ ⋅t\n     ⅈ⋅μ⋅t - ─────\n               2\n   ℯ\n</code></pre></div></div>\n\n<p>I was actually pretty surprised that this worked as smoothly as it did.  SymPy stats wasn’t designed for this.</p>\n\n<p>Here are some gists for the <a href=\"https://gist.github.com/4186685\">Cauchy</a> and <a href=\"https://gist.github.com/4186709\">Student-T</a> distributions.  Cauchy simplifies down pretty well but the Student-T characteristic function has a few special functions included.</p>\n\n<h2 id=\"behavior-near-zero\">Behavior near zero</h2>\n\n<p>Josef says that the behavior of the characteristic function of the t\ndistribution near zero for high degrees of freedom (the nu parameter) is\nchallenging to compute numerically.  Can SymPy handle this symbolically?</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">nu</span> <span class=\"o\">=</span> <span class=\"n\">Symbol</span><span class=\"p\">(</span><span class=\"s\">'nu'</span><span class=\"p\">,</span> <span class=\"n\">positive</span><span class=\"o\">=</span><span class=\"bp\">True</span><span class=\"p\">,</span> <span class=\"n\">integer</span><span class=\"o\">=</span><span class=\"bp\">True</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">t</span> <span class=\"o\">=</span> <span class=\"n\">Symbol</span><span class=\"p\">(</span><span class=\"s\">'t'</span><span class=\"p\">,</span> <span class=\"n\">positive</span><span class=\"o\">=</span><span class=\"bp\">True</span><span class=\"p\">)</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">X</span> <span class=\"o\">=</span> <span class=\"n\">StudentT</span><span class=\"p\">(</span><span class=\"s\">'X'</span><span class=\"p\">,</span> <span class=\"n\">nu</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">simplify</span><span class=\"p\">(</span><span class=\"n\">E</span><span class=\"p\">(</span><span class=\"n\">exp</span><span class=\"p\">(</span><span class=\"n\">I</span><span class=\"o\">*</span><span class=\"n\">t</span><span class=\"o\">*</span><span class=\"n\">X</span><span class=\"p\">)))</span></code></pre>\n</figure>\n\n<p><img src=\"http://goo.gl/a6xcw\" alt=\"\" /></p>\n\n<p>The bold scripted I’s are besseli functions.  We restrict this expression to a specific number of degrees of freedom, setting <code class=\"language-plaintext highlighter-rouge\">nu = 50</code></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&gt;&gt;&gt; simplify(E(exp(I*t*X))).subs(nu, 50)  # replace nu with 50\n         ⎛         ___  ⎞            ⎛        ___  ⎞\n∞⋅besseli⎝-25, 5⋅╲╱ 2 ⋅t⎠ - ∞⋅besseli⎝25, 5⋅╲╱ 2 ⋅t⎠\n</code></pre></div></div>\n\n<p>Whoops, simple substitution at that number of degrees of freedom fails, giving us infinities.  What if we build the expression with <code class=\"language-plaintext highlighter-rouge\">50</code> from the beginning?  This gives the integration routines more information when they compute the expectation.</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&gt;&gt;&gt; X = StudentT('X', 50)\n&gt;&gt;&gt; simplify(E(exp(I*t*X)))\n        ⎛              │     2  -ⅈ⋅π⎞           ⎛              │     2  ⅈ⋅π⎞\n╭─╮3, 1 ⎜   1/2        │ 25⋅t ⋅ℯ    ⎟   ╭─╮3, 1 ⎜   1/2        │ 25⋅t ⋅ℯ   ⎟\n│╶┐     ⎜              │ ───────────⎟ + │╶┐     ⎜              │ ──────────⎟\n╰─╯1, 3 ⎝25, 0, 1/2    │      2     ⎠   ╰─╯1, 3 ⎝25, 0, 1/2    │     2     ⎠\n────────────────────────────────────────────────────────────────────────────\n                        1240896803466478878720000⋅π\n</code></pre></div></div>\n\n<p>The solution is in terms of <a href=\"http://en.wikipedia.org/wiki/Meijer-G\">Meijer-G</a> functions.  Can we evaluate this close to <code class=\"language-plaintext highlighter-rouge\">t = 0</code>?</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&gt;&gt;&gt; simplify(E(exp(I*t*X))).subs(t, 1e-6).evalf()\n0.999999999999479 + 1.56564942264937e-29⋅ⅈ\n\n&gt;&gt;&gt; simplify(E(exp(I*t*X))).subs(t, 1e-30).evalf()\n1.0 - 1.2950748484704e-53⋅ⅈ\n</code></pre></div></div>\n\n<p>This is where scipy’s special functions failed in Josef’s post, yielding infinity instead of 1.</p>\n\n<p>And finally we plot the behavior around 0.</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&gt;&gt;&gt; plot(re(simplify(E(exp(I*t*X)))), (t, 1e-7, 1e-1))\n</code></pre></div></div>\n\n<p><img src=\"https://mrocklin.github.io/blog/images/student-t-characteristic-near-zero.png\" alt=\"\" /></p>\n\n<h2 id=\"closing-notes\">Closing Notes</h2>\n\n<p>The <code class=\"language-plaintext highlighter-rouge\">sympy.stats</code> module was not designed with characteristic functions in mind.  I was pleasantly surprised when I entered code almost identical to the mathematical definition</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>X = Normal('X', mu, sigma)\nE(exp(I*t*X))\n</code></pre></div></div>\n\n<p>and received the correct answer.  I am always happy when projects work on problems for which they were not originally designed.  The fact that this works is largely due to SymPy’s excellent handling of integrals of special functions, due largely to <a href=\"https://github.com/ness01\">Tom Bachmann</a>.</p>\n\n<p>If you do complex work on statistical functions I recommend you take a look at <code class=\"language-plaintext highlighter-rouge\">sympy.stats</code>.  It’s able to perform some interesting high level transformations.  Thanks to recent work by <a href=\"https://github.com/raoulb\">Raoul Bourquin</a> many of the common distributions found in <code class=\"language-plaintext highlighter-rouge\">scipy.stats</code> are now available (with even more in a <a href=\"https://github.com/sympy/sympy/pull/1413\">pull request</a>).</p>"
}