{
  "title": "Why I Love Scikit-learn",
  "link": "",
  "updated": "2013-09-18T00:00:00+00:00",
  "id": "http://daoudclarke.github.com/machine%20learning%20in%20practice/2013/09/18/why-i-love-scikit-learn",
  "content": "<p><em>Scikit-learn is great because it has a clean API, is robust, fast,\neasy to use, comprehensive, and well documented and supported,\nreleased under a permissive license and the developers are cool. If\nyou can implement your project in Python and you don’t need massively\nscalable algorithms, then it is probably for you.</em></p>\n\n<hr />\n\n<p>Choosing a library is often a crucial task. In the case of machine\nlearning, it is likely that the library you choose will form the core\nof your project, and your choice will impact on many other decisions\nyou will make when building your software. If you choose the wrong\nlibrary, you may spend weeks wrapping a poorly designed API,\ninspecting source code to understand undocumented features and working\naround bugs and limitations. If you get it right, you will be able to\nwrite clean, bug free code with a minimum of effort.</p>\n\n<p>I have seen this effect first hand. In this article, I want to talk\nabout my favourite machine learning library, Scikit-learn, and why I\nthink it is currently one of the best libraries around for doing\nmachine learning, both for academic work and in production.</p>\n\n<!-- Scikit-learn is a python library -->\n\n<h2 id=\"1-clean-api\">1. Clean API</h2>\n\n<p>The importance of a clean API cannot be overstated. It is much easier\nto write clean code if the underlying API is cleanly designed. Your\ncode will have to conform to the vision of the library writer, and\nthey can force you to write convoluted code if they want to. Complex\ndesign may sometimes be justified by increased generality, but if it\nis hard to implement the common use cases, then the API is poorly\ndesigned.</p>\n\n<p>The objects provided by the library are forced upon you, and they will\nlitter your code. Well designed objects will lead to terse, readable\ncode, while poorly designed objects will have you scratching your head\nsix months down the line trying to remember how the code you wrote\nworks.</p>\n\n<p>You may be tempted to take a machine learning library that has a poor\nAPI but more algorithms and wrap it in a clean API, but beware!\nCreating a good wrapper for a library is no mean feat. Doing machine\nlearning properly requires a variety of tools that will need to be\nwrapped, and you may find that it’s not worth the overhead (I learnt\nthis lesson the hard way). In addition, a library with a poor API is\nlikely to be lacking in other important qualities such as robustness\nand good documentation.</p>\n\n<h2 id=\"2-robust\">2. Robust</h2>\n\n<p>If you are planning to use a machine learning library in production\ncode, then robustness will be a high priority. One of the differences\nbetween Scikit-learn and other machine learning libraries is that the\nauthors are explicitly targetting not just academic use, but use in\nindustry as well. They have concentrated on doing a few things really\nwell, rather than trying to do everything.</p>\n\n<p>Scikit-learn is unit tested, with around 80% unit test coverage,\ngiving us confidence that old features will not break as new ones are\nimplemented and bugs are fixed.</p>\n\n<p>UPDATE: <a href=\"http://www.reddit.com/r/MachineLearning/comments/1mq8fb/why_i_love_scikitlearn/\">Edward Raff noted on\n/r/MachineLearning</a>\nthat his experience with SciKit-learn hasn’t been so rosy when the\ndatasets are large or poorly behaved, so your mileage may vary…</p>\n\n<!-- In my experience, upgrading -->\n<!-- Scikit-learn has occasionally broken my code -->\n\n<h2 id=\"3-fast\">3. Fast</h2>\n\n<p>If speed is important to you, Scikit-learn is fast. Despite being\nimplemented in an interpreted language, Python, its foundations are\nthe compiled libraries NumPy and SciPy, and in addition, the authors\nhave implemented a lot of tools in Cython, which compiles to C,\ngiving blazing fast Python-like code.</p>\n\n<p>The authors have also built on top of existing machine learning\nlibraries, such as LibLinear and LibSVM for support vector machines,\nhowever they didn’t stop there, optimising the algorithms to make them\neven faster.</p>\n\n<h2 id=\"4-easy-to-use\">4. Easy to Use</h2>\n\n<p>Being a fan of the Python language, I am undoubtedly a little biased,\nhowever, it is arguably one of the easier languages to learn and\nuse. The Scikit-learn team have followed Python conventions as much as\npossible, which makes using it a joy if you know Python. There are\nseveral methods which Scikit-learn classes can implement:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>fit\ntransform\nfit_transform\npredict\ndecision_function\n</code></pre></div></div>\n\n<p>Each type of object will implement a subset of these, and duck typing\ndetermines which objects are appropriate in each circumstance. For\nexample, classifiers are expected to implement the <code class=\"language-plaintext highlighter-rouge\">fit</code> and <code class=\"language-plaintext highlighter-rouge\">predict</code>\nmethods.</p>\n\n<p>Here’s an example from the documentation for the Multinomial Naive\nBayes classifier:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; X = np.random.randint(5, size=(6, 100))\n&gt;&gt;&gt; Y = np.array([1, 2, 3, 4, 5, 6])\n&gt;&gt;&gt; from sklearn.naive_bayes import MultinomialNB\n&gt;&gt;&gt; clf = MultinomialNB()\n&gt;&gt;&gt; clf.fit(X, Y)\nMultinomialNB(alpha=1.0, class_prior=None, fit_prior=True)\n&gt;&gt;&gt; print(clf.predict(X[2]))\n[3]\n</code></pre></div></div>\n\n<!-- ## 4. Comprehensive -->\n\n<!-- Machine learning requires a variety of tools for different situations -->\n<!-- and purposes, for example, feature extraction, feature selection, -->\n<!-- dimensionality reduction, classification and clustering. Scikit-learn -->\n<!-- provides most of these tools, while remaining strictly a -->\n<!-- general-purpose machine learning library. -->\n\n<h2 id=\"5-well-documented\">5. Well Documented</h2>\n\n<p>I have found the\n<a href=\"http://scikit-learn.org/stable/documentation.html\">Scikit-learn documentation</a>\nto be comprehensive, readable, and easy to understand. When doing\nsomething new with Scikit-learn, I have quickly been able to get to\nget to grips with how to do it after a quick peruse of the\ndocumentation, either using Python’s <code class=\"language-plaintext highlighter-rouge\">help()</code> function, or the\nexcellent online documentation, which includes tutorials as well as\ndocumenting the API.</p>\n\n<p>Of course, it also helps that the API is well designed: a lot of the\ntime you can guess the correct usage of a new class once you get to\nknow a few of the classes.</p>\n\n<p>Only occasionally have I had to fall back to reading the source to\nunderstand a feature (or, more often, a bug in my own code). Since the\ncode is mainly fairly clean Python, even this is not much of a chore.</p>\n\n<h2 id=\"6-permissive-license\">6. Permissive License</h2>\n\n<p>Scikit-learn is released under the liberal\n<a href=\"http://opensource.org/licenses/BSD-3-Clause\">BSD License</a> so you can\nuse it freely in commercial applications.</p>\n\n<h2 id=\"7-well-supported\">7. Well Supported</h2>\n\n<p>Scikit-learn must be one of the most actively developed open source\nmachine learning projects. Check out the\n<a href=\"https://github.com/scikit-learn/scikit-learn/pulse/monthly\">github stats for the last month</a>:\nat the time of writing, there were 734 commits by 42 authors.</p>\n\n<h2 id=\"and-the-downsides\">…And the Downsides</h2>\n\n<p>As well as the benefits of being implemented in a dynamic language,\nyou also get the downsides: refactoring is potentially tedious, and\nbecause there’s no strong typing, it is easy to break something\nwithout realising it, which is where good unit test coverage becomes\ncrucial.</p>\n\n<h2 id=\"alternatives\">Alternatives</h2>\n\n<p>Unfortunately, you can’t always have the best. There are numerous\nfactors to bear in mind when choosing a library that may impact your\ndecision on what to use:</p>\n\n<ul>\n  <li><strong>Language</strong>: if you have to integrate your machine learning\nfunctionality with legacy code, then this may restrict your choice\nof language, although it is often possible to avoid this by using a\nservice oriented architecture. Alternatively, you may have to stick\nto a particular language because of company policy, or because\nthe developers in your team don’t want to abandon their favourite\nlanguage for something new.</li>\n  <li><strong>Performance</strong>: for many applications, performance is critical, but\nif it is not, then this gives you more freedom in which machine\nlearning tools you can use.</li>\n  <li><strong>Scalability</strong>: if you need something that is massively scalable\n(which in my opinion is fairly rare), then you might want to\nconsider something like <a href=\"http://mahout.apache.org/\">Mahout</a> which\nis not as comprehensive as Scikit-learn, but is scalable to very\nlarge datasets as it is implemented on top of Hadoop.</li>\n</ul>\n\n<p>You may want to consider <a href=\"/machine%20learning%20in%20practice/2013/10/08/machine-learning-libraries\">some of these alternatives</a>.</p>\n\n<h2 id=\"conclusion\">Conclusion</h2>\n\n<ul>\n  <li>Choose your library carefully</li>\n  <li>Scikit-learn is robust, with a clean API, and fast implementation</li>\n  <li>It may not suit every application</li>\n</ul>"
}