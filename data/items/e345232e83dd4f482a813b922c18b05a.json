{
  "id": "tag:blogger.com,1999:blog-15045980.post-5834230578622472577",
  "published": "2020-11-09T09:23:00.001-08:00",
  "updated": "2020-11-09T09:23:56.785-08:00",
  "category": "",
  "title": "Fixing a Test Hourglass",
  "content": "By Alan Myrvold<div><br /></div><div><br /></div><div><div>Automated tests make it safer and faster to create new features, fix bugs, and refactor code. When planning the automated tests, we envision a pyramid with a strong foundation of small unit tests, some well designed integration tests, and a few large end-to-end tests. From <a href=\"https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html\">Just Say No to More End-to-End Tests</a>, tests should be fast, reliable, and specific; end-to-end tests, however, are often slow, unreliable, and difficult to debug.</div></div><div><br /></div><div><br /></div><div><div>As software projects grow, often the shape of our test distribution becomes undesirable, either top heavy (no unit or medium integration tests), or like an hourglass.</div></div><div><br /></div><div><br /></div><div><div>The hourglass test distribution has a large set of unit tests, a large set of end-to-end tests, and few or no medium integration tests.</div></div><div><br /></div><div><br /></div><div class=\"separator\" style=\"clear: both; text-align: center;\"><img border=\"0\" data-original-height=\"400\" data-original-width=\"330\" height=\"320\" src=\"https://1.bp.blogspot.com/-0jbHAgLFogI/X48dTAJoekI/AAAAAAAAAbI/JV6oUPImdT8Ho5bPgOKVwVZDFVKWGwgcACLcBGAsYHQ/s320/Copy%2Bof%2BGoogle%2BTesting%2BBlog_%2BFixing%2Ba%2BTest%2BHourglass%2B-%2BEdited.jpg\" />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img border=\"0\" data-original-height=\"400\" data-original-width=\"288\" height=\"320\" src=\"https://1.bp.blogspot.com/-e6bsyqU1yt8/X48dcQU9uLI/AAAAAAAAAbM/Ct-p0T6Y728g_gyHYZ_DWT6Ks2MPhrgfwCLcBGAsYHQ/s320/Copy%2Bof%2BGoogle%2BTesting%2BBlog_%2BFixing%2Ba%2BTest%2BHourglass%2B%25281%2529%2B-%2BEdited.jpg\" /></div><div class=\"separator\" style=\"clear: both; text-align: left;\"><br /></div><div class=\"separator\" style=\"clear: both; text-align: left;\"><div class=\"separator\" style=\"clear: both;\">To transform the hourglass back into a pyramid — so that you can test the integration of components in a reliable, sustainable way — you need to figure out how to architect the system under test and test infrastructure and make system testability improvements and test-code improvements.</div><div><br /></div><div><br /></div><div><div>I worked on a project with a web UI, a server, and many backends. There were unit tests at all levels with good coverage and a quickly increasing set of end-to-end tests.</div></div><div><br /></div><div><br /></div><div><div>The end-to-end tests found issues that the unit tests missed, but they ran slowly, and environmental issues caused spurious failures, including test data corruption. In addition, some functional areas were difficult to test because they covered more than the unit but required state within the system that was hard to set up.</div></div><div class=\"separator\" style=\"clear: both; text-align: left;\"><br /></div><div class=\"separator\" style=\"clear: both; text-align: left;\"><br /></div><div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"https://1.bp.blogspot.com/-X-jZgQxi8OM/X48eq3zzDEI/AAAAAAAAAbk/8qL5-YDjupIKkDeqdVJxxjVPsrCE8XPlACLcBGAsYHQ/s637/Copy%2Bof%2BGoogle%2BTesting%2BBlog_%2BFixing%2Ba%2BTest%2BHourglass%2B%25282%2529%2B-%2BEdited.jpg\" style=\"margin-left: 1em; margin-right: 1em;\"><img border=\"1\" data-original-height=\"400\" data-original-width=\"637\" src=\"https://1.bp.blogspot.com/-X-jZgQxi8OM/X48eq3zzDEI/AAAAAAAAAbk/8qL5-YDjupIKkDeqdVJxxjVPsrCE8XPlACLcBGAsYHQ/s16000/Copy%2Bof%2BGoogle%2BTesting%2BBlog_%2BFixing%2Ba%2BTest%2BHourglass%2B%25282%2529%2B-%2BEdited.jpg\" /></a></div><div class=\"separator\" style=\"clear: both; text-align: left;\"><br /></div><div class=\"separator\" style=\"clear: both; text-align: left;\"><br /></div>We eventually found a good test architecture for faster, more reliable integration tests, but with some missteps along the way.</div><div class=\"separator\" style=\"clear: both; text-align: left;\"><br /></div><div class=\"separator\" style=\"clear: both; text-align: left;\"><div class=\"separator\" style=\"clear: both;\">An example UI-level end-to-end test, written in <a href=\"https://protractor.angular.io/\">protractor</a>, looked something like this:</div><div><br /></div><div><br /></div></div>  <div style=\"overflow-x: auto;\"><table class=\"my-bordered-table\" style=\"width: 613px;\"><tbody><tr><td style=\"vertical-align: top; width: 607px;\"><pre style=\"border: 0px; color: black; margin: 0px; padding-bottom: 0px; padding-left: 0px; padding-top: 0px;\"><span style=\"font-family: consolas, &quot;courier new&quot;, courier, monospace;\">describe('Terms of service are handled', () =&gt; {<br />  it('accepts terms of service', async () =&gt; {<br />    const user = getUser('termsNotAccepted');<br />    await login(user);<br />    await see(termsOfServiceDialog());<br />    await click('Accept')<br />    await logoff();<br />    await login(user);<br />    await not.see(termsOfServiceDialog());<br />  });<br />});</span></pre></td></tr></tbody></table></div> <div style=\"overflow-x: auto;\"><div style=\"overflow-x: auto;\"><br /></div><div style=\"overflow-x: auto;\"><br /></div><div style=\"overflow-x: auto;\">This test logs on as a user, sees the terms of service dialog that the user needs to accept, accepts it, then logs off and logs back on to ensure the user is not prompted again.</div><div><br /></div><div><br /></div><div><div>This terms of service test was a challenge to run reliably, because once an agreement was accepted, the backend server had no RPC method to reverse the operation and “un-accept” the TOS. We could create a new user with each test, but that was time consuming and hard to clean up.</div></div><div><br /></div><div><br /></div><div><div>The first attempt to make the terms of service feature testable without end-to-end testing was to hook the server RPC method and set the expectations within the test. The hook intercepts the RPC call and provides expected results instead of calling the backend API.</div></div><div><br /></div><div><br /></div><div class=\"separator\" style=\"clear: both; text-align: center;\"><img border=\"1\" data-original-height=\"389\" data-original-width=\"595\" src=\"https://1.bp.blogspot.com/-BGOJjqQx95I/X5BYnaZ88CI/AAAAAAAAAb0/ktnX3SyprGoPklnpLjAo8vLGMmy7GTVegCLcBGAsYHQ/s16000/Copy%2Bof%2BGoogle%2BTesting%2BBlog_%2BFixing%2Ba%2BTest%2BHourglass%2B%25283%2529%2B-%2BEdited.jpg\" /></div><div style=\"overflow-x: auto;\"><br /></div><div style=\"overflow-x: auto;\"><br /></div>This approach worked. The test interacted with the backend RPC without really calling it, but it cluttered the test with extra logic.<br /><div><br /></div></div><div style=\"overflow-x: auto;\"><br /></div> <div style=\"overflow-x: auto;\"><table class=\"my-bordered-table\" style=\"width: 613px;\"><tbody><tr><td style=\"vertical-align: top; width: 607px;\"><pre style=\"border: 0px; color: black; margin: 0px; padding-bottom: 0px; padding-left: 0px; padding-top: 0px;\"><span style=\"font-family: consolas, &quot;courier new&quot;, courier, monospace;\">describe('Terms of service are handled', () =&gt; {<br />  it('accepts terms of service', async () =&gt; {<br />    const user = getUser('someUser');<br />    await hook('TermsOfService.Get()', true);<br />    await login(user);<br />    await see(termsOfServiceDialog());<br />    await click('Accept')<br />    await logoff();<br />    await hook('TermsOfService.Get()', false);<br />    await login(user);<br />    await not.see(termsOfServiceDialog());<br />  });<br />});</span></pre></td></tr></tbody></table></div>  <div style=\"overflow-x: auto;\"><div style=\"overflow-x: auto;\"><br /></div><div style=\"overflow-x: auto;\"><br /></div><div style=\"overflow-x: auto;\"><br /></div><div style=\"overflow-x: auto;\">The test met the goal of testing the integration of the web UI and server, but it was unreliable. As the system scaled under load, there were several server processes and no guarantee that the UI would access the same server for all RPC calls, so the hook might be set in one server process and the UI accessed in another.&nbsp;</div><div><br /></div><div><br /></div><div><div>The hook also wasn't at a natural system boundary, which made it require more maintenance as the system evolved and code was refactored.</div></div><div><br /></div><div><br /></div><div>The next design of the test architecture was to fake the backend that eventually processes the terms of service call.</div><div><br /></div><div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"https://1.bp.blogspot.com/-0tiG7Pt33G4/X5BaSNGZE4I/AAAAAAAAAcA/T7k2F4s_OPUmbP1rxXPLsqB6MjIyvdXJgCLcBGAsYHQ/s616/Copy%2Bof%2BGoogle%2BTesting%2BBlog_%2BFixing%2Ba%2BTest%2BHourglass%2B%25284%2529%2B-%2BEdited.jpg\" style=\"margin-left: 1em; margin-right: 1em;\"><img border=\"1\" data-original-height=\"400\" data-original-width=\"616\" src=\"https://1.bp.blogspot.com/-0tiG7Pt33G4/X5BaSNGZE4I/AAAAAAAAAcA/T7k2F4s_OPUmbP1rxXPLsqB6MjIyvdXJgCLcBGAsYHQ/s16000/Copy%2Bof%2BGoogle%2BTesting%2BBlog_%2BFixing%2Ba%2BTest%2BHourglass%2B%25284%2529%2B-%2BEdited.jpg\" /></a></div><div style=\"overflow-x: auto;\"><br /></div><div style=\"overflow-x: auto;\">The fake implementation can be quite simple:</div><div><br /></div></div> <div style=\"overflow-x: auto;\"><table class=\"my-bordered-table\" style=\"width: 613px;\"><tbody><tr><td style=\"vertical-align: top; width: 607px;\"><pre style=\"border: 0px; color: black; margin: 0px; padding-bottom: 0px; padding-left: 0px; padding-top: 0px;\"><span style=\"font-family: consolas, &quot;courier new&quot;, courier, monospace;\">public class FakeTermsOfService implements TermsOfService.Service {<br />  private static final Map&lt;String, Boolean&gt; accepted = new ConcurrentHashMap&lt;&gt;();<br /><br />  @Override<br />  public TosGetResponse get(TosGetRequest req) {<br />    return accepted.getOrDefault(req.UserID(), Boolean.FALSE);<br />  }<br /><br />  @Override<br />  public void accept(TosAcceptRequest req) {<br />    accepted.put(req.UserID(), Boolean.TRUE);<br />  }<br />}</span></pre></td></tr></tbody></table></div><div><br /></div><div><br /></div><div><br /></div> And the test is now uncluttered by the expectations:<div><br /><div style=\"overflow-x: auto;\"><table class=\"my-bordered-table\" style=\"width: 613px;\"><tbody><tr><td style=\"vertical-align: top; width: 607px;\"><pre style=\"border: 0px; color: black; margin: 0px; padding-bottom: 0px; padding-left: 0px; padding-top: 0px;\"><span style=\"font-family: consolas, &quot;courier new&quot;, courier, monospace;\">describe('Terms of service are handled', () =&gt; {<br /></span></pre><pre style=\"border: 0px; color: black; margin: 0px; padding-bottom: 0px; padding-left: 0px; padding-top: 0px;\"><span style=\"font-family: consolas, &quot;courier new&quot;, courier, monospace;\">  it('accepts terms of service', async () =&gt; {<br />    const user = getUser('termsNotAccepted');<br />    await login(user);<br />    await see(termsOfServiceDialog());<br />    await click('Accept')<br />    await logoff();<br />    await login(user);<br />    await not.see(termsOfServiceDialog());<br />  });<br />});</span></pre></td></tr></tbody></table></div><div><br /></div><div><br /></div><div>Because the fake stores the accepted state in memory, there is no need to reset the state for the next test iteration; it is enough just to restart the fake server.</div><div><br /></div><div><br /></div><div><div>This worked but was problematic when there was a mix of fake and real backends. This was because there was state between the real backends that was now out of sync with the fake backend.</div></div><div><br /></div><div><br /></div><div><div>Our final, successful integration test architecture was to provide fake implementations for all except one of the backends, all sharing the same in-memory state. One real backend was included in the system under test because it was tightly coupled with the Web UI. Its dependencies were all wired to fake backends. These are integration tests over the entire system under test, but they remove the backend dependencies. These tests expand the medium size tests in the test hourglass, allowing us to have fewer end-to-end tests with real backends.</div></div><div><br /></div><div><br /></div><div><div>Note that these integration tests are not only the option. For logic in the Web UI, we can write page level unit tests, which allow the tests to run faster and more reliably. For the terms of service feature, however, we want to test the Web UI and server logic together, so integration tests are a good solution.</div></div><div><br /></div><div><br /></div><div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"https://1.bp.blogspot.com/-GXnIcmGOhow/X5BcZDzfURI/AAAAAAAAAcM/6ld2Xg__3V8nkXqDEnPeuibPqXU9KntcACLcBGAsYHQ/s594/Copy%2Bof%2BGoogle%2BTesting%2BBlog_%2BFixing%2Ba%2BTest%2BHourglass%2B%25285%2529%2B-%2BEdited.jpg\" style=\"margin-left: 1em; margin-right: 1em;\"><img border=\"1\" data-original-height=\"461\" data-original-width=\"594\" src=\"https://1.bp.blogspot.com/-GXnIcmGOhow/X5BcZDzfURI/AAAAAAAAAcM/6ld2Xg__3V8nkXqDEnPeuibPqXU9KntcACLcBGAsYHQ/s16000/Copy%2Bof%2BGoogle%2BTesting%2BBlog_%2BFixing%2Ba%2BTest%2BHourglass%2B%25285%2529%2B-%2BEdited.jpg\" /></a></div><br /><div><br /></div><div><br /></div><div>This resulted in UI tests that ran, unmodified, on both the real and fake backend systems.&nbsp;</div><div><br /></div><div><br /></div><div><div>When run with fake backends the tests were faster and more reliable. This made it easier to add test scenarios that would have been more challenging to set up with the real backends. We also deleted end-to-end tests that were well duplicated by the integration tests, resulting in more integration tests than end-to-end tests.</div></div><div><br /></div><div><br /></div><div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"https://1.bp.blogspot.com/-FGkMIpFMPXM/X5BcvmDCcjI/AAAAAAAAAcU/vNtCPcVc1EML3xZv5w1-7sSPlacRO9rvQCLcBGAsYHQ/s463/Copy%2Bof%2BGoogle%2BTesting%2BBlog_%2BFixing%2Ba%2BTest%2BHourglass%2B%25286%2529%2B-%2BEdited.jpg\" style=\"margin-left: 1em; margin-right: 1em;\"><img border=\"0\" data-original-height=\"463\" data-original-width=\"380\" height=\"320\" src=\"https://1.bp.blogspot.com/-FGkMIpFMPXM/X5BcvmDCcjI/AAAAAAAAAcU/vNtCPcVc1EML3xZv5w1-7sSPlacRO9rvQCLcBGAsYHQ/s320/Copy%2Bof%2BGoogle%2BTesting%2BBlog_%2BFixing%2Ba%2BTest%2BHourglass%2B%25286%2529%2B-%2BEdited.jpg\" /></a></div><div><div><br /></div><div>By iterating, we arrived at a sustainable test architecture for the integration tests.</div></div><div><br /></div><div><br /></div><div>If you're facing a test hourglass the test architecture to devise medium tests may not be obvious. I'd recommend experimenting, dividing the system on well defined interfaces, and making sure the new tests are providing value by running faster and more reliably or by unlocking hard to test areas.</div><div><br /></div><div style=\"text-align: left;\"><br /></div><h3 style=\"text-align: left;\">References</h3><div><ul style=\"text-align: left;\"><li>Just Say No to More End-to-End Tests, Mike Wacker, <a href=\"https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html\">https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html</a></li><li>Test Pyramid &amp; Antipatterns, Khushi, <a href=\"https://khushiy.com/2019/02/07/test-pyramid-antipatterns/\">https://khushiy.com/2019/02/07/test-pyramid-antipatterns/</a></li><li>Testing on the Toilet: Fake Your Way to Better Tests, Jonathan Rockway and Andrew Trenk, <a href=\"https://testing.googleblog.com/2013/06/testing-on-toilet-fake-your-way-to.html\">https://testing.googleblog.com/2013/06/testing-on-toilet-fake-your-way-to.html</a></li><li>Testing on the Toilet: Know Your Test Doubles, Andrew Trenk, <a href=\"https://testing.googleblog.com/2013/07/testing-on-toilet-know-your-test-doubles.html\">https://testing.googleblog.com/2013/07/testing-on-toilet-know-your-test-doubles.html</a></li><li>Hermetic Servers, Chaitali Narla and Diego Salas, <a href=\"https://testing.googleblog.com/2012/10/hermetic-servers.html\">https://testing.googleblog.com/2012/10/hermetic-servers.html</a></li><li>Software Engineering at Google, Titus Winters, Tom Manshreck, Hyrum Wright, <a href=\"https://www.oreilly.com/library/view/software-engineering-at/9781492082781/\">https://www.oreilly.com/library/view/software-engineering-at/9781492082781/</a></li></ul></div><div><br /></div><div><br /></div></div>",
  "link": [
    "",
    "",
    "",
    "",
    ""
  ],
  "author": {
    "name": "Google Testing Bloggers",
    "uri": "http://www.blogger.com/profile/03153388556673050910",
    "email": "noreply@blogger.com",
    "gd:image": ""
  },
  "media:thumbnail": "",
  "thr:total": 4
}