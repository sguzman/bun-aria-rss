{
  "title": "Gotchas in Jetpack Compose Recomposition",
  "description": "<h2 id=\"intro\">Intro</h2>\n\n<p><a href=\"https://developer.android.com/jetpack/compose\">Jetpack Compose</a> is an amazing new declarative UI toolkit in Android that offers faster and simpler development of Android apps. Here at Stitch Fix, we’ve been using Compose for a while and have seen many of the improvements and challenges of this new addition. For example, as a team laser focused on the best customer experience, we’ve found a few “gotchas” that can really impact UI performance. This post will discuss a few of those “gotchas” encountered here at Stitch Fix and how to correct them.</p>\n\n<p>Recomposition in Jetpack Compose is the mechanism in which state changes are reflected within an app’s UI. To accomplish this, Compose will rerun a composable function whenever its inputs change. The gotchas discussed here break performance optimizations built into Compose and trigger unnecessary work, which have the potential to slow down an app’s UI and waste precious device resources.</p>\n\n<p>For efficiency, Compose will skip any child function or lambda calls that do not have any changes to their input. This optimization is quite important since animations and other UI elements can trigger recomposition every frame. The following example details when recomposition will occur:</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Composable</span>\n<span class=\"k\">fun</span> <span class=\"nf\">BookDescriptor</span><span class=\"p\">(</span>\n   <span class=\"n\">title</span><span class=\"p\">:</span> <span class=\"nc\">String</span><span class=\"p\">,</span>\n   <span class=\"n\">author</span><span class=\"p\">:</span> <span class=\"nc\">String</span><span class=\"p\">,</span>\n<span class=\"p\">)</span> <span class=\"p\">{</span>\n   <span class=\"nc\">Column</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// The Text function will recompose when [title] changes, but not when [author] changes</span>\n        <span class=\"nc\">Text</span><span class=\"p\">(</span><span class=\"n\">title</span><span class=\"p\">)</span>\n        <span class=\"nc\">Divider</span><span class=\"p\">()</span>\n        <span class=\"c1\">// This Text function will recompose only when [author] changes</span>\n        <span class=\"nc\">Text</span><span class=\"p\">(</span><span class=\"n\">author</span><span class=\"p\">)</span>       \n   <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>Go in-depth about the <a href=\"https://developer.android.com/jetpack/compose/lifecycle\">Jetpack Composition Lifecycle</a> with this article on the Google Developers site.</p>\n\n<h2 id=\"skipping-optimization\">Skipping Optimization</h2>\n\n<p>Since recomposition can happen so frequently, one of the most important optimizations Compose does to maintain performance is calling <a href=\"https://developer.android.com/jetpack/compose/lifecycle#skipping\"><strong>skipping</strong></a>. As the name implies, this optimization will skip calls to composable functions whose inputs have not changed since the previous call. Compose determines if inputs have “changed” using a set of requirements which can be found <a href=\"https://developer.android.com/jetpack/compose/lifecycle#skipping\">here</a>.</p>\n\n<p>For reference, there are two requirements that must be satisfied in order for a composition to be skipped.</p>\n<ol>\n  <li>All inputs must be stable.</li>\n  <li>Inputs must not have changed from the previous call.</li>\n</ol>\n\n<p>The article listed above describes what is necessary for a type to be <code class=\"language-plaintext highlighter-rouge\">@Stable</code>. They are also copied below:</p>\n\n<blockquote>\n  <p>A stable type must comply with the following contract:</p>\n\n  <ul>\n    <li>The result of equals for two instances will forever be the same for the same two instances.</li>\n    <li>If a public property of the type changes, Composition will be notified.</li>\n    <li>All public property types are also stable.</li>\n  </ul>\n\n  <p>There are some important common types that fall into this contract &gt; that the compose compiler will treat as stable, even though they are &gt; not explicitly marked as stable by using the @Stable annotation:</p>\n\n  <ul>\n    <li>All primitive value types: Boolean, Int, Long, Float, Char, etc.</li>\n    <li>Strings</li>\n    <li>All Function types (lambdas)</li>\n  </ul>\n</blockquote>\n\n<h2 id=\"gotcha---unstable-lambdas\">Gotcha - Unstable Lambdas</h2>\n<p>In order to best demonstrate this “Gotcha”, please consider the following code example:</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Composable</span>\n<span class=\"k\">fun</span> <span class=\"nf\">RecompositionTest</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n   <span class=\"kd\">val</span> <span class=\"py\">viewModel</span> <span class=\"p\">=</span> <span class=\"nf\">remember</span> <span class=\"p\">{</span> <span class=\"nc\">NamesViewModel</span><span class=\"p\">()</span> <span class=\"p\">}</span>\n   <span class=\"kd\">val</span> <span class=\"py\">state</span> <span class=\"k\">by</span> <span class=\"n\">viewModel</span><span class=\"p\">.</span><span class=\"n\">state</span><span class=\"p\">.</span><span class=\"nf\">collectAsState</span><span class=\"p\">()</span>\n\n   <span class=\"nc\">NameColumnWithButton</span><span class=\"p\">(</span>\n       <span class=\"n\">names</span> <span class=\"p\">=</span> <span class=\"n\">state</span><span class=\"p\">.</span><span class=\"n\">names</span><span class=\"p\">,</span>\n       <span class=\"n\">onButtonClick</span> <span class=\"p\">=</span> <span class=\"p\">{</span> <span class=\"n\">viewModel</span><span class=\"p\">.</span><span class=\"nf\">addName</span><span class=\"p\">()</span> <span class=\"p\">},</span>\n       <span class=\"n\">onNameClick</span> <span class=\"p\">=</span> <span class=\"p\">{</span> <span class=\"n\">viewModel</span><span class=\"p\">.</span><span class=\"nf\">handleNameClick</span><span class=\"p\">()</span> <span class=\"p\">},</span>\n   <span class=\"p\">)</span>\n<span class=\"p\">}</span>\n\n<span class=\"nd\">@Composable</span>\n<span class=\"k\">fun</span> <span class=\"nf\">NameColumnWithButton</span><span class=\"p\">(</span>\n   <span class=\"n\">names</span><span class=\"p\">:</span> <span class=\"nc\">List</span><span class=\"p\">&lt;</span><span class=\"nc\">String</span><span class=\"p\">&gt;,</span>\n   <span class=\"n\">onButtonClick</span><span class=\"p\">:</span> <span class=\"p\">()</span> <span class=\"p\">-&gt;</span> <span class=\"nc\">Unit</span><span class=\"p\">,</span>\n   <span class=\"n\">onNameClick</span><span class=\"p\">:</span> <span class=\"p\">()</span> <span class=\"p\">-&gt;</span> <span class=\"nc\">Unit</span><span class=\"p\">,</span>\n<span class=\"p\">)</span> <span class=\"p\">{</span>\n   <span class=\"nc\">Column</span> <span class=\"p\">{</span>\n        <span class=\"n\">names</span><span class=\"p\">.</span><span class=\"nf\">forEach</span> <span class=\"p\">{</span> \n            <span class=\"nc\">CompositionTrackingName</span><span class=\"p\">(</span><span class=\"n\">name</span> <span class=\"p\">=</span> <span class=\"n\">it</span><span class=\"p\">,</span> <span class=\"n\">onClick</span> <span class=\"p\">=</span> <span class=\"n\">onNameClick</span><span class=\"p\">)</span> \n        <span class=\"p\">}</span>\n        <span class=\"nc\">Button</span><span class=\"p\">(</span><span class=\"n\">onClick</span> <span class=\"p\">=</span> <span class=\"n\">onButtonClick</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"nc\">Text</span><span class=\"p\">(</span><span class=\"s\">\"Add a Name\"</span><span class=\"p\">)</span> <span class=\"p\">}</span>\n   <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"nd\">@Composable</span>\n<span class=\"k\">fun</span> <span class=\"nf\">CompositionTrackingName</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nc\">String</span><span class=\"p\">,</span> <span class=\"n\">onClick</span><span class=\"p\">:</span> <span class=\"p\">()</span> <span class=\"p\">-&gt;</span> <span class=\"nc\">Unit</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"nc\">Log</span><span class=\"p\">.</span><span class=\"nf\">e</span><span class=\"p\">(</span><span class=\"s\">\"*******COMPOSED\"</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"p\">)</span>\n    <span class=\"nc\">Text</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">modifier</span> <span class=\"p\">=</span> <span class=\"nc\">Modifier</span><span class=\"p\">.</span><span class=\"nf\">clickable</span><span class=\"p\">(</span><span class=\"n\">onClick</span> <span class=\"p\">=</span> <span class=\"n\">onClick</span><span class=\"p\">))</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>The above composition renders a list of names and a button that a user can click to add a name to the list. Each of those names when clicked perform some operation within the view model. Finally, to aid in debugging, a Logcat message is presented whenever any name within <code class=\"language-plaintext highlighter-rouge\">names</code> is composed.</p>\n\n<p>Originally, the expectation was that log messages would only occur for the names being added to the list (post the initial composition logs). After all, previous names are not changing and neither is the lambda. What does happen, however, is that every time a new name is added to the list, all names are being recomposed.</p>\n\n<p>To better understand why this is happening, let’s take a quick detour into how lambdas are implemented. Whenever a lambda is written, the compiler is creating an anonymous class with that code. If the lambda requires access to external variables, the compiler will add those variables as fields that are passed into the constructor of the lambda. This is sometimes described as <em>variable capture</em>. For the <code class=\"language-plaintext highlighter-rouge\">onNameClick</code> lambda, the compiler generates a class that looks something like this:</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nc\">NameClickLambda</span><span class=\"p\">(</span><span class=\"kd\">val</span> <span class=\"py\">viewModel</span><span class=\"p\">:</span> <span class=\"nc\">NamesViewModel</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n   <span class=\"k\">operator</span> <span class=\"k\">fun</span> <span class=\"nf\">invoke</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n       <span class=\"n\">viewModel</span><span class=\"p\">.</span><span class=\"nf\">handleNameClick</span><span class=\"p\">()</span>\n   <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>This implementation detail reveals why our function was recomposing! The public <code class=\"language-plaintext highlighter-rouge\">NamesViewModel</code> property is violating the <code class=\"language-plaintext highlighter-rouge\">@Stable</code> requirement that all public properties must also be <code class=\"language-plaintext highlighter-rouge\">@Stable</code>. To verify that this is the cause of the recomposition problems, the <code class=\"language-plaintext highlighter-rouge\">@Stable</code> annotation can be applied to the definition of <code class=\"language-plaintext highlighter-rouge\">NamesViewModel</code> like so:</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Stable</span>\n<span class=\"kd\">class</span> <span class=\"nc\">NamesViewModel</span> <span class=\"p\">:</span> <span class=\"nc\">ViewModel</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n   <span class=\"c1\">// snipped for brevity</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>After this change and running the original test again, recomposition is behaving as initially expected. Nice! Only the new names in the list are triggering a log message. While this solution works, marking every <code class=\"language-plaintext highlighter-rouge\">ViewModel</code> as <code class=\"language-plaintext highlighter-rouge\">@Stable</code> is not technically correct as they don’t fit Compose’s description of <code class=\"language-plaintext highlighter-rouge\">@Stable</code> data types.</p>\n\n<h2 id=\"what-is-safe-with-lambdas\">What is Safe with Lambdas?</h2>\n\n<p>Unfortunately, there isn’t a one-size-fits-all solution for every situation. Each unique situation may require a different solution.</p>\n\n<h3 id=\"option-1---method-references\">Option 1 - Method References</h3>\n\n<p>By using method references instead of a lambda, we will prevent the creation of a new class that references the view model. Method references are <code class=\"language-plaintext highlighter-rouge\">@Stable</code> functional types and will remain equivalent between recompositions. It is for this reason that wherever possible method references are usually the best choice to pass to <code class=\"language-plaintext highlighter-rouge\">@Composable</code> functions.</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Composable</span>\n<span class=\"k\">fun</span> <span class=\"nf\">RecompositionTest</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n   <span class=\"kd\">val</span> <span class=\"py\">viewModel</span> <span class=\"p\">=</span> <span class=\"nf\">remember</span> <span class=\"p\">{</span> <span class=\"nc\">NamesViewModel</span><span class=\"p\">()</span> <span class=\"p\">}</span>\n   <span class=\"kd\">val</span> <span class=\"py\">state</span> <span class=\"k\">by</span> <span class=\"n\">viewModel</span><span class=\"p\">.</span><span class=\"n\">state</span><span class=\"p\">.</span><span class=\"nf\">collectAsState</span><span class=\"p\">()</span>\n\n   <span class=\"nc\">NameColumnWithButton</span><span class=\"p\">(</span>\n       <span class=\"n\">names</span> <span class=\"p\">=</span> <span class=\"n\">state</span><span class=\"p\">.</span><span class=\"n\">names</span><span class=\"p\">,</span>\n       <span class=\"n\">onButtonClick</span> <span class=\"p\">=</span> <span class=\"n\">viewModel</span><span class=\"o\">::</span><span class=\"n\">addName</span><span class=\"p\">,</span> <span class=\"c1\">// Method reference</span>\n       <span class=\"n\">onNameClick</span> <span class=\"p\">=</span> <span class=\"n\">viewModel</span><span class=\"o\">::</span><span class=\"n\">handleNameClick</span><span class=\"p\">,</span> <span class=\"c1\">// Method reference</span>\n   <span class=\"p\">)</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<h3 id=\"option-2---remembered-lambdas\">Option 2 - Remembered Lambdas</h3>\n\n<p>Another option is to remember the lambda instance between recompositions. This will ensure the exact same instance of the lambda will be reused upon further compositions.</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Composable</span>\n<span class=\"k\">fun</span> <span class=\"nf\">RecompositionTest</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n   <span class=\"kd\">val</span> <span class=\"py\">viewModel</span> <span class=\"p\">=</span> <span class=\"nf\">remember</span> <span class=\"p\">{</span> <span class=\"nc\">NamesViewModel</span><span class=\"p\">()</span> <span class=\"p\">}</span>\n   <span class=\"kd\">val</span> <span class=\"py\">state</span> <span class=\"k\">by</span> <span class=\"n\">viewModel</span><span class=\"p\">.</span><span class=\"n\">state</span><span class=\"p\">.</span><span class=\"nf\">collectAsState</span><span class=\"p\">()</span>\n   <span class=\"kd\">val</span> <span class=\"py\">onButtonClick</span> <span class=\"p\">=</span> <span class=\"nf\">remember</span><span class=\"p\">(</span><span class=\"n\">viewModel</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"p\">{</span> <span class=\"n\">viewModel</span><span class=\"p\">.</span><span class=\"nf\">addName</span><span class=\"p\">()</span> <span class=\"p\">}</span> <span class=\"p\">}</span>\n   <span class=\"kd\">val</span> <span class=\"py\">onNameClick</span> <span class=\"p\">=</span> <span class=\"nf\">remember</span><span class=\"p\">(</span><span class=\"n\">viewModel</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"p\">{</span> <span class=\"n\">viewModel</span><span class=\"p\">.</span><span class=\"nf\">handleNameClick</span><span class=\"p\">()</span> <span class=\"p\">}</span> <span class=\"p\">}</span>\n\n   <span class=\"nc\">NameColumnWithButton</span><span class=\"p\">(</span>\n       <span class=\"n\">names</span> <span class=\"p\">=</span> <span class=\"n\">state</span><span class=\"p\">.</span><span class=\"n\">names</span><span class=\"p\">,</span>\n       <span class=\"n\">onButtonClick</span> <span class=\"p\">=</span> <span class=\"n\">onButtonClick</span><span class=\"p\">,</span>\n       <span class=\"n\">onNameClick</span> <span class=\"p\">=</span> <span class=\"n\">onNameClick</span>\n   <span class=\"p\">)</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p><strong>Tip:</strong> When remembering a lambda, pass any captured variables as <code class=\"language-plaintext highlighter-rouge\">keys</code> to <code class=\"language-plaintext highlighter-rouge\">remember</code> so that the lambda will be recreated if those variables change.</p>\n\n<h3 id=\"option-3---static-functions\">Option 3 - Static Functions</h3>\n\n<p>If a lambda is simply calling a top-level function, the base composition optimization rules applied to all lambdas still apply. For example, a call like below will require no changes:</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Composable</span>\n<span class=\"k\">fun</span> <span class=\"nf\">RecompositionTest</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n   <span class=\"kd\">val</span> <span class=\"py\">viewModel</span> <span class=\"p\">=</span> <span class=\"nf\">remember</span> <span class=\"p\">{</span> <span class=\"nc\">NamesViewModel</span><span class=\"p\">()</span> <span class=\"p\">}</span>\n   <span class=\"kd\">val</span> <span class=\"py\">state</span> <span class=\"k\">by</span> <span class=\"n\">viewModel</span><span class=\"p\">.</span><span class=\"n\">state</span><span class=\"p\">.</span><span class=\"nf\">collectAsState</span><span class=\"p\">()</span>\n\n   <span class=\"nc\">NameColumnWithButton</span><span class=\"p\">(</span>\n       <span class=\"n\">names</span> <span class=\"p\">=</span> <span class=\"n\">state</span><span class=\"p\">.</span><span class=\"n\">names</span><span class=\"p\">,</span>\n       <span class=\"n\">onButtonClick</span> <span class=\"p\">=</span> <span class=\"n\">viewModel</span><span class=\"o\">::</span><span class=\"n\">addName</span><span class=\"p\">,</span>\n       <span class=\"n\">onNameClick</span> <span class=\"p\">=</span> <span class=\"p\">{</span> <span class=\"nf\">someNonScopedFunction</span><span class=\"p\">()</span> <span class=\"p\">}</span>\n   <span class=\"p\">)</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">fun</span> <span class=\"nf\">someNonScopedFunction</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"nf\">print</span><span class=\"p\">(</span><span class=\"s\">\"Do something\"</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<h3 id=\"option-4---using-a-stable-type-in-a-lambda\">Option 4 - Using a @Stable Type in a Lambda</h3>\n\n<p>As long as a lambda is only capturing other <code class=\"language-plaintext highlighter-rouge\">@Stable</code> types it will not violate any skipping optimization requirements. Earlier, when temporarily marking <code class=\"language-plaintext highlighter-rouge\">NamesViewModel</code> with <code class=\"language-plaintext highlighter-rouge\">@Stable</code>, this solution was demonstrated. Here is an example where a lambda is modifying <code class=\"language-plaintext highlighter-rouge\">MutableState</code> which <em>is</em> a <code class=\"language-plaintext highlighter-rouge\">@Stable</code> type.</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Composable</span>\n<span class=\"k\">fun</span> <span class=\"nf\">RecompositionTest</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"kd\">var</span> <span class=\"py\">state</span> <span class=\"k\">by</span> <span class=\"nf\">remember</span> <span class=\"p\">{</span> <span class=\"nf\">mutableStateOf</span><span class=\"p\">(</span><span class=\"nf\">listOf</span><span class=\"p\">(</span><span class=\"s\">\"Aaron\"</span><span class=\"p\">,</span> <span class=\"s\">\"Bob\"</span><span class=\"p\">,</span> <span class=\"s\">\"Claire\"</span><span class=\"p\">))</span> <span class=\"p\">}</span>\n    \n    <span class=\"nc\">NameColumnWithButton</span><span class=\"p\">(</span>\n        <span class=\"n\">strings</span> <span class=\"p\">=</span> <span class=\"n\">state</span><span class=\"p\">,</span>\n        <span class=\"n\">buttonName</span> <span class=\"p\">=</span> <span class=\"s\">\"Recompose Lambda Capturing @Stable\"</span><span class=\"p\">,</span>\n        <span class=\"n\">onButtonClick</span> <span class=\"p\">=</span> <span class=\"p\">{</span> <span class=\"n\">state</span> <span class=\"p\">=</span> <span class=\"n\">state</span> <span class=\"p\">+</span> <span class=\"s\">\"Daisy\"</span> <span class=\"p\">},</span>\n        <span class=\"n\">onTextClick</span> <span class=\"p\">=</span> <span class=\"p\">{</span> <span class=\"n\">state</span> <span class=\"p\">=</span> <span class=\"n\">state</span> <span class=\"p\">+</span> <span class=\"s\">\"Daisy\"</span> <span class=\"p\">},</span>\n    <span class=\"p\">)</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<h2 id=\"gotcha---implicitly-stable-data-classes--multi-module-apps\">Gotcha - Implicitly @Stable Data Classes &amp; Multi-Module Apps</h2>\n\n<p>When passing a class instance to a <code class=\"language-plaintext highlighter-rouge\">@Composable</code> function, it must be marked as <code class=\"language-plaintext highlighter-rouge\">@Stable</code> to satisfy skipping optimization requirements. In order to help facilitate this process, Compose will attempt to infer the stability of a data type. If all public properties are immutable and <code class=\"language-plaintext highlighter-rouge\">@Stable</code>, the containing type will be marked as <code class=\"language-plaintext highlighter-rouge\">@Stable</code>. This <a href=\"https://developer.android.com/jetpack/compose/lifecycle#skipping\">link</a> discusses this process in more detail.</p>\n\n<p>While this inference tool is extremely helpful to the developer, it is important to understand how and when this happens. Consider the following example:</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">data class</span> <span class=\"nc\">FullName</span><span class=\"p\">(</span>\n   <span class=\"kd\">val</span> <span class=\"py\">firstName</span><span class=\"p\">:</span> <span class=\"nc\">String</span><span class=\"p\">,</span>\n   <span class=\"kd\">val</span> <span class=\"py\">lastName</span><span class=\"p\">:</span> <span class=\"nc\">String</span>\n<span class=\"p\">)</span>\n</code></pre></div></div>\n\n<p>Can this type be marked as <code class=\"language-plaintext highlighter-rouge\">@Stable</code>? The answer is: it depends on where it is! Compose will only infer the stability of this type at <strong>compile</strong> time. This means that the Compose compiler plugin must actually evaluate the code for the <code class=\"language-plaintext highlighter-rouge\">@Stable</code> annotation to be applied to the data type.</p>\n\n<p>This caveat is a very important consideration when building multi-module Android apps. If a <code class=\"language-plaintext highlighter-rouge\">@Composable</code> function uses an argument type from a module built without Compose, it will not have @Stable arguments and will violate the requirements for the skipping optimization. Here is a simple example to illustrate this point:</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">//Defined in a module without compose applied</span>\n<span class=\"kd\">data class</span> <span class=\"nc\">DomainFullName</span><span class=\"p\">(</span><span class=\"kd\">val</span> <span class=\"py\">first</span><span class=\"p\">:</span> <span class=\"nc\">String</span><span class=\"p\">,</span> <span class=\"kd\">val</span> <span class=\"py\">last</span><span class=\"p\">:</span> <span class=\"nc\">String</span><span class=\"p\">)</span>\n\n<span class=\"nd\">@Composable</span>\n<span class=\"k\">fun</span> <span class=\"nf\">DomainClassTest</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"kd\">val</span> <span class=\"py\">name</span> <span class=\"p\">=</span> <span class=\"nf\">remember</span> <span class=\"p\">{</span> <span class=\"nc\">DomainFullName</span><span class=\"p\">(</span><span class=\"s\">\"John\"</span><span class=\"p\">,</span> <span class=\"s\">\"Doe\"</span><span class=\"p\">)</span> <span class=\"p\">}</span>\n    <span class=\"kd\">var</span> <span class=\"py\">count</span> <span class=\"k\">by</span> <span class=\"nf\">remember</span> <span class=\"p\">{</span> <span class=\"nf\">mutableStateOf</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">}</span>\n\n    <span class=\"nc\">Column</span> <span class=\"p\">{</span>\n        <span class=\"c1\">//This shouldn't recompose when count increments since [name] isn't changing</span>\n        <span class=\"c1\">//but it does since DomainFullName is not @Stable.</span>\n        <span class=\"nc\">DomainFullNameComposable</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"p\">)</span>\n        <span class=\"nc\">Text</span><span class=\"p\">(</span><span class=\"s\">\"Click Count: $count\"</span><span class=\"p\">)</span>\n        <span class=\"nc\">Button</span><span class=\"p\">(</span><span class=\"n\">onClick</span> <span class=\"p\">=</span> <span class=\"p\">{</span> <span class=\"n\">count</span><span class=\"p\">++</span> <span class=\"p\">})</span> <span class=\"p\">{</span>\n            <span class=\"nc\">Text</span><span class=\"p\">(</span><span class=\"s\">\"Recompose domain module class test\"</span><span class=\"p\">)</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"nd\">@Composable</span>\n<span class=\"k\">private</span> <span class=\"k\">fun</span> <span class=\"nf\">DomainFullNameComposable</span><span class=\"p\">(</span><span class=\"n\">domainObject</span><span class=\"p\">:</span> <span class=\"nc\">DomainFullName</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"nc\">Log</span><span class=\"p\">.</span><span class=\"nf\">e</span><span class=\"p\">(</span><span class=\"err\">“</span><span class=\"p\">*******</span><span class=\"nc\">COMPOSED</span><span class=\"err\">”</span><span class=\"p\">,</span> <span class=\"s\">\"DomainFullName recomposed\"</span><span class=\"p\">)</span>\n    <span class=\"nc\">Text</span><span class=\"p\">(</span><span class=\"n\">domainObject</span><span class=\"p\">.</span><span class=\"n\">first</span> <span class=\"p\">+</span> <span class=\"s\">\" \"</span> <span class=\"p\">+</span> <span class=\"n\">domainObject</span><span class=\"p\">.</span><span class=\"n\">last</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>In this example, whenever the button is clicked, the <code class=\"language-plaintext highlighter-rouge\">DomainClassTest</code> composable will rerun since <code class=\"language-plaintext highlighter-rouge\">count</code> is changing. This recomposition then forces the recomposition of <code class=\"language-plaintext highlighter-rouge\">DomainFullNameComposable</code> despite the <code class=\"language-plaintext highlighter-rouge\">DomainFullName</code> not changing. If the <code class=\"language-plaintext highlighter-rouge\">DomainFullName</code> is moved into a module where Compose is being used, <code class=\"language-plaintext highlighter-rouge\">DomainFullNameComposable</code> will no longer recompose unnecessarily.</p>\n\n<h3 id=\"option-1---decouple-composables-from-domain-classes\">Option 1 - Decouple @Composables from Domain Classes</h3>\n\n<p>One solution to the above problem is to only use classes that live within the same module as <code class=\"language-plaintext highlighter-rouge\">@Composable</code> function arguments. Then, when necessary, map domain state into those Compose level classes. For example:</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">//Compose level state</span>\n<span class=\"kd\">data class</span> <span class=\"nc\">ComposeFullName</span><span class=\"p\">(</span><span class=\"kd\">val</span> <span class=\"py\">first</span><span class=\"p\">:</span> <span class=\"nc\">String</span><span class=\"p\">,</span> <span class=\"kd\">val</span> <span class=\"py\">last</span><span class=\"p\">:</span> <span class=\"nc\">String</span><span class=\"p\">)</span>\n\n<span class=\"k\">fun</span> <span class=\"nc\">DomainFullName</span><span class=\"p\">.</span><span class=\"nf\">toComposeFullName</span><span class=\"p\">()</span> <span class=\"p\">=</span> <span class=\"nc\">ComposeFullName</span><span class=\"p\">(</span><span class=\"n\">first</span> <span class=\"p\">=</span> <span class=\"n\">first</span><span class=\"p\">,</span> <span class=\"n\">last</span> <span class=\"p\">=</span> <span class=\"n\">last</span><span class=\"p\">)</span>\n\n<span class=\"nd\">@Composable</span>\n<span class=\"k\">fun</span> <span class=\"nf\">UiClassTest</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"kd\">val</span> <span class=\"py\">name</span> <span class=\"p\">=</span> <span class=\"nf\">remember</span> <span class=\"p\">{</span> <span class=\"nc\">DomainFullName</span><span class=\"p\">(</span><span class=\"s\">\"John\"</span><span class=\"p\">,</span> <span class=\"s\">\"Doe\"</span><span class=\"p\">)</span> <span class=\"p\">}</span>\n    <span class=\"kd\">val</span> <span class=\"py\">uiName</span> <span class=\"p\">=</span> <span class=\"nf\">remember</span> <span class=\"p\">{</span> <span class=\"n\">name</span><span class=\"p\">.</span><span class=\"nf\">toComposeFullName</span><span class=\"p\">()</span> <span class=\"p\">}</span>\n    <span class=\"kd\">var</span> <span class=\"py\">count</span> <span class=\"k\">by</span> <span class=\"nf\">remember</span> <span class=\"p\">{</span> <span class=\"nf\">mutableStateOf</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">}</span>\n\n    <span class=\"nc\">Column</span> <span class=\"p\">{</span>\n        <span class=\"c1\">//This shouldn't recompose when count changes since [uiName] isn't changing and is @Stable</span>\n        <span class=\"nc\">ComposeFullNameComposable</span><span class=\"p\">(</span><span class=\"n\">uiName</span><span class=\"p\">)</span>\n        <span class=\"nc\">Text</span><span class=\"p\">(</span><span class=\"s\">\"Click Count: $count\"</span><span class=\"p\">)</span>\n        <span class=\"nc\">Button</span><span class=\"p\">(</span><span class=\"n\">onClick</span> <span class=\"p\">=</span> <span class=\"p\">{</span> <span class=\"n\">count</span><span class=\"p\">++</span> <span class=\"p\">})</span> <span class=\"p\">{</span>\n            <span class=\"nc\">Text</span><span class=\"p\">(</span><span class=\"s\">\"Recompose UI module class test\"</span><span class=\"p\">)</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"nd\">@Composable</span>\n<span class=\"k\">private</span> <span class=\"k\">fun</span> <span class=\"nf\">ComposeFullNameComposable</span><span class=\"p\">(</span><span class=\"n\">uiObject</span><span class=\"p\">:</span> <span class=\"nc\">ComposeFullName</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"nc\">Log</span><span class=\"p\">.</span><span class=\"nf\">e</span><span class=\"p\">(</span><span class=\"err\">“</span><span class=\"p\">*******</span><span class=\"nc\">COMPOSED</span><span class=\"err\">”</span><span class=\"p\">,</span> <span class=\"s\">\"ComposeFullName recomposed\"</span><span class=\"p\">)</span>\n    <span class=\"nc\">Text</span><span class=\"p\">(</span><span class=\"n\">uiObject</span><span class=\"p\">.</span><span class=\"n\">first</span> <span class=\"p\">+</span> <span class=\"s\">\" \"</span> <span class=\"p\">+</span> <span class=\"n\">uiObject</span><span class=\"p\">.</span><span class=\"n\">last</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<h3 id=\"option-2---dont-use-class-arguments-in-composable-functions\">Option 2 - Don’t Use Class Arguments In @Composable Functions</h3>\n\n<p>Another solution is to simply pass only primitive types to Composables. In the original code sample the <code class=\"language-plaintext highlighter-rouge\">first</code> and <code class=\"language-plaintext highlighter-rouge\">last</code> fields could have been passed directly to the <code class=\"language-plaintext highlighter-rouge\">NameFromComposeModule</code> function (instead of <code class=\"language-plaintext highlighter-rouge\">DomainFullNameComposable</code>). For example:</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Composable</span>\n<span class=\"k\">fun</span> <span class=\"nf\">DomainClassTest</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"kd\">val</span> <span class=\"py\">name</span> <span class=\"p\">=</span> <span class=\"nf\">remember</span> <span class=\"p\">{</span> <span class=\"nc\">DomainFullName</span><span class=\"p\">(</span><span class=\"s\">\"John\"</span><span class=\"p\">,</span> <span class=\"s\">\"Doe\"</span><span class=\"p\">)</span> <span class=\"p\">}</span>\n    <span class=\"kd\">var</span> <span class=\"py\">count</span> <span class=\"k\">by</span> <span class=\"nf\">remember</span> <span class=\"p\">{</span> <span class=\"nf\">mutableStateOf</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">}</span>\n\n    <span class=\"nc\">Column</span> <span class=\"p\">{</span>\n        <span class=\"c1\">//This will no longer recompose since both [first] and [last] are @Stable</span>\n        <span class=\"nc\">DomainFullNameComposable</span><span class=\"p\">(</span><span class=\"n\">first</span> <span class=\"p\">=</span> <span class=\"n\">name</span><span class=\"p\">.</span><span class=\"n\">first</span><span class=\"p\">,</span> <span class=\"n\">last</span> <span class=\"p\">=</span> <span class=\"n\">name</span><span class=\"p\">.</span><span class=\"n\">last</span><span class=\"p\">)</span>\n        <span class=\"nc\">Text</span><span class=\"p\">(</span><span class=\"s\">\"Click Count: $count\"</span><span class=\"p\">)</span>\n        <span class=\"nc\">Button</span><span class=\"p\">(</span><span class=\"n\">onClick</span> <span class=\"p\">=</span> <span class=\"p\">{</span> <span class=\"n\">count</span><span class=\"p\">++</span> <span class=\"p\">})</span> <span class=\"p\">{</span>\n            <span class=\"nc\">Text</span><span class=\"p\">(</span><span class=\"s\">\"Recompose domain module class test\"</span><span class=\"p\">)</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"nd\">@Composable</span>\n<span class=\"k\">private</span> <span class=\"k\">fun</span> <span class=\"nf\">DomainFullNameComposable</span><span class=\"p\">(</span><span class=\"n\">first</span><span class=\"p\">:</span> <span class=\"nc\">String</span><span class=\"p\">,</span> <span class=\"n\">last</span><span class=\"p\">:</span> <span class=\"nc\">String</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"nc\">Log</span><span class=\"p\">.</span><span class=\"nf\">e</span><span class=\"p\">(</span><span class=\"err\">“</span><span class=\"p\">*******</span><span class=\"nc\">COMPOSED</span><span class=\"err\">”</span><span class=\"p\">,</span> <span class=\"s\">\"DomainFullName recomposed\"</span><span class=\"p\">)</span>\n    <span class=\"nc\">Text</span><span class=\"p\">(</span><span class=\"n\">first</span> <span class=\"p\">+</span> <span class=\"s\">\" \"</span> <span class=\"p\">+</span> <span class=\"n\">last</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<h2 id=\"gotcha---not-minimizing-the-effect-of-rapidly-changing-state\">Gotcha - Not Minimizing the Effect of Rapidly Changing State</h2>\n\n<p>In one of Google’s examples on recomposition, they discuss when to use a derived state in the context of a <code class=\"language-plaintext highlighter-rouge\">LazyColumn</code>. In an effort to clarify that example, consider this similar example:</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Composable</span>\n<span class=\"k\">fun</span> <span class=\"nf\">LazyListComposable</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"kd\">val</span> <span class=\"py\">someListOfStrings</span> <span class=\"p\">=</span> <span class=\"nc\">List</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"n\">index</span> <span class=\"p\">-&gt;</span> <span class=\"n\">index</span><span class=\"p\">.</span><span class=\"nf\">toString</span><span class=\"p\">()</span> <span class=\"p\">}</span>\n    <span class=\"kd\">val</span> <span class=\"py\">listState</span> <span class=\"p\">=</span> <span class=\"nf\">rememberLazyListState</span><span class=\"p\">()</span>\n\n    <span class=\"nc\">LazyColumn</span><span class=\"p\">(</span><span class=\"n\">state</span> <span class=\"p\">=</span> <span class=\"n\">listState</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"nf\">items</span><span class=\"p\">(</span><span class=\"n\">someListOfStrings</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"n\">numberString</span> <span class=\"p\">-&gt;</span>\n            <span class=\"nc\">Text</span><span class=\"p\">(</span><span class=\"n\">numberString</span><span class=\"p\">)</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"kd\">val</span> <span class=\"py\">showButton</span> <span class=\"p\">=</span> <span class=\"n\">listState</span><span class=\"p\">.</span><span class=\"n\">firstVisibleItemIndex</span> <span class=\"p\">&gt;</span> <span class=\"mi\">0</span>\n\n    <span class=\"nc\">AnimatedVisibility</span><span class=\"p\">(</span><span class=\"n\">visible</span> <span class=\"p\">=</span> <span class=\"n\">showButton</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n       <span class=\"nc\">ScrollToTopButton</span><span class=\"p\">()</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>Upon initial glance it may be difficult to spot why this is a problem. To start, consider the following:</p>\n<ul>\n  <li>This entire function will recompose every time the <code class=\"language-plaintext highlighter-rouge\">firstVisibleItemIndex</code> changes because it is used to determine the value of <code class=\"language-plaintext highlighter-rouge\">showButton</code>.</li>\n  <li>Each item’s <code class=\"language-plaintext highlighter-rouge\">Text()</code> composable won’t recompose unless the value changes (i.e. scrolling a new item on the screen)</li>\n  <li><code class=\"language-plaintext highlighter-rouge\">AnimatedVisibility</code> should only recompose when <code class=\"language-plaintext highlighter-rouge\">showButton</code> changes</li>\n</ul>\n\n<p>So, what’s the problem? The performance penalty is actually realized with recomposition of <code class=\"language-plaintext highlighter-rouge\">LazyColumn</code>. Each time <code class=\"language-plaintext highlighter-rouge\">LazyListComposable</code> runs, <code class=\"language-plaintext highlighter-rouge\">LazyColumn</code> must recompose because of the lambda which describes how to render the list’s items. Each <code class=\"language-plaintext highlighter-rouge\">Text()</code> composable call may be skipped, but Compose still has to iterate over each item to trigger its rendering calls (whether or not they are then skipped). In other words, if the above <code class=\"language-plaintext highlighter-rouge\">LazyColumn</code> looked like this:</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    <span class=\"nc\">LazyColumn</span><span class=\"p\">(</span><span class=\"n\">state</span> <span class=\"p\">=</span> <span class=\"n\">listState</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"nf\">items</span><span class=\"p\">(</span><span class=\"n\">someListOfStrings</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"n\">numberString</span> <span class=\"p\">-&gt;</span>\n            <span class=\"nc\">Log</span><span class=\"p\">.</span><span class=\"nf\">e</span><span class=\"p\">(</span><span class=\"s\">\"*******COMPOSED\"</span><span class=\"p\">,</span> <span class=\"s\">\"About to recompose item $it\"</span><span class=\"p\">)</span>\n   \t        <span class=\"nc\">Text</span><span class=\"p\">(</span><span class=\"n\">numberString</span><span class=\"p\">)</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>There would be a log message for every item currently visible on the screen every time the user scrolls. This is a lot of extra work that doesn’t need to happen if <code class=\"language-plaintext highlighter-rouge\">showButton</code> is not changing.</p>\n\n<h2 id=\"benefits-of-derived-state\">Benefits of Derived State</h2>\n\n<p>In this example, the <code class=\"language-plaintext highlighter-rouge\">showButton</code> variable is <em>derived</em> from some other rapidly changing state (the <code class=\"language-plaintext highlighter-rouge\">firstVisibleItemIndex</code>). In order to prevent needless recompositions, Compose provides a mechanism to react to state changes with a smaller scope: <code class=\"language-plaintext highlighter-rouge\">derivedStateOf</code>. Consider the following change to <code class=\"language-plaintext highlighter-rouge\">showButton</code>:</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>   <span class=\"kd\">val</span> <span class=\"py\">showButton</span> <span class=\"k\">by</span> <span class=\"nf\">remember</span> <span class=\"p\">{</span> \n        <span class=\"nf\">derivedStateOf</span> <span class=\"p\">{</span> \n            <span class=\"n\">listState</span><span class=\"p\">.</span><span class=\"n\">firstVisibleItemIndex</span> <span class=\"p\">&gt;</span> <span class=\"mi\">0</span> \n        <span class=\"p\">}</span> \n   <span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>By turning <code class=\"language-plaintext highlighter-rouge\">showButton</code> into a state, any consumers of <code class=\"language-plaintext highlighter-rouge\">showButton</code> will now only react to changes in its value. Additionally, the reaction to <code class=\"language-plaintext highlighter-rouge\">firstVisibleItemIndex</code> changes is now contained within the scope of the <code class=\"language-plaintext highlighter-rouge\">derivedStateOf</code> creation lambda. In other words, if a log was present in the <code class=\"language-plaintext highlighter-rouge\">derivedStateOf</code> block, that log method would still be firing every time the list is scrolled. However, unless <code class=\"language-plaintext highlighter-rouge\">showButton</code> changes, the recomposition would remain constrained to that derived state block. A full example of the new, more efficient code is as follows:</p>\n\n<div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Composable</span>\n<span class=\"k\">fun</span> <span class=\"nf\">LazyListComposable</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"kd\">val</span> <span class=\"py\">someListOfStrings</span> <span class=\"p\">=</span> <span class=\"nc\">List</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"n\">index</span> <span class=\"p\">-&gt;</span> <span class=\"n\">index</span><span class=\"p\">.</span><span class=\"nf\">toString</span><span class=\"p\">()</span> <span class=\"p\">}</span>\n    <span class=\"kd\">val</span> <span class=\"py\">listState</span> <span class=\"p\">=</span> <span class=\"nf\">rememberLazyListState</span><span class=\"p\">()</span>\n\n    <span class=\"nc\">LazyColumn</span><span class=\"p\">(</span><span class=\"n\">state</span> <span class=\"p\">=</span> <span class=\"n\">listState</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"nf\">items</span><span class=\"p\">(</span><span class=\"n\">someListOfStrings</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"n\">numberString</span> <span class=\"p\">-&gt;</span>\n   \t        <span class=\"nc\">Text</span><span class=\"p\">(</span><span class=\"n\">numberString</span><span class=\"p\">)</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"kd\">val</span> <span class=\"py\">showButton</span> <span class=\"k\">by</span> <span class=\"nf\">remember</span> <span class=\"p\">{</span> \n        <span class=\"nf\">derivedStateOf</span> <span class=\"p\">{</span> \n            <span class=\"n\">listState</span><span class=\"p\">.</span><span class=\"n\">firstVisibleItemIndex</span> <span class=\"p\">&gt;</span> <span class=\"mi\">0</span> \n        <span class=\"p\">}</span> \n    <span class=\"p\">}</span>\n\n    <span class=\"nc\">AnimatedVisibility</span><span class=\"p\">(</span><span class=\"n\">visible</span> <span class=\"p\">=</span> <span class=\"n\">showButton</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n       <span class=\"nc\">ScrollToTopButton</span><span class=\"p\">()</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>Now, whenever the user scrolls, the entire <code class=\"language-plaintext highlighter-rouge\">LazyColumn</code> is only recomposed when <code class=\"language-plaintext highlighter-rouge\">showButton</code> changes. This is a huge savings given how often recomposition occurs when scrolling a list!</p>\n\n<h2 id=\"summary\">Summary</h2>\n\n<p>Hopefully, this post shed some light on some of the ways unexpected performance issues can occur within Jetpack Compose UI. While it may be tempting to go forth and fix these issues right away, my advice is to identify screens with large composable hierarchies that may be exhibiting performance issues. Recently, in Android Studio Dolphin, a recomposition counter has been integrated with the layout inspector. This tool will undoubtedly prove invaluable when examining an app for recomposition issues and help identify potential performance issues in an easy way.</p>\n\n<h2 id=\"special-thanks\">Special Thanks</h2>\n\n<p>I’d like to take this opportunity to thank Joshua Soberg and Brian Stokes from the Stitch Fix team who assisted me in discovering some of these issues in Compose. Additionally, some of this work was prompted by this excellent <a href=\"https://proandroiddev.com/understanding-re-composition-in-jetpack-compose-with-a-case-study-9e7d96d98095\">article</a>.</p>\n\n<h2 id=\"additional-resources\">Additional Resources</h2>\n\n<ul>\n  <li><a href=\"https://developer.android.com/jetpack/compose/lifecycle\">Composable Lifecycle</a></li>\n  <li><a href=\"https://developer.android.com/jetpack/compose/performance\">Jetpack Compose performance</a></li>\n  <li><a href=\"https://proandroiddev.com/understanding-re-composition-in-jetpack-compose-with-a-case-study-9e7d96d98095\">Understanding re-composition in Jetpack Compose with a case study</a></li>\n</ul>\n\n<h2 id=\"code-repository\">Code Repository</h2>\n\n<p>Many of the code samples in this post exist here on <a href=\"https://github.com/jbreitfeller-sfix/jetpack-compose-recomposition-tests\">GitHub</a>.</p>",
  "pubDate": "Fri, 05 Aug 2022 09:00:00 +0000",
  "link": "https://multithreaded.stitchfix.com/blog/2022/08/05/jetpack-compose-recomposition/",
  "guid": "https://multithreaded.stitchfix.com/blog/2022/08/05/jetpack-compose-recomposition/"
}