{
  "title": "Branching Strategies",
  "link": "",
  "updated": "2012-11-09T00:00:00+00:00",
  "id": "https://mrocklin.github.io/blog/work/2012/11/09/BranchingStrategies",
  "content": "<p>In my last post on <a href=\"http://matthewrocklin.com/blog/work/2012/11/07/Strategies/\">strategies</a> I introduced a set of higher order functions to represent common control patterns (like <code class=\"language-plaintext highlighter-rouge\">top_down</code>).  We combined these with transformation rules (like <code class=\"language-plaintext highlighter-rouge\">flatten</code>) to create complex functions for tree manipulation (like <code class=\"language-plaintext highlighter-rouge\">flatten_tree</code>)</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>rule     :: expr -&gt; expr\nstrategy :: parameters, rule -&gt; rule\n</code></pre></div></div>\n\n<p>In my post on <a href=\"http://matthewrocklin.com/blog/work/2012/11/01/Unification/\">unification</a> we showed how to easily create rules from patterns.  At the end of this post I described that because patterns might match in multiple ways one rule might produce many different results.  To avoid combinatorial blowup in the number of possible matches we solved this by yielding matches lazily.</p>\n\n<p>Transformation rules produced by unify don’t return values, they yield possible solutions lazily.  How do we reconcile this with our previous notion of rules and strategies? We make a new set of strategies for branching rules.</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>branching-rule      :: expr -&gt; {expr}\nbranching-strategy  :: parameters, branching-rule -&gt; branching-rule\n</code></pre></div></div>\n\n<p>In <code class=\"language-plaintext highlighter-rouge\">sympy.rules.branch</code> we have implemented lazy analogs for the strategies found in <code class=\"language-plaintext highlighter-rouge\">sympy.rules</code>.  This allows us to apply strategies to transformations like the <code class=\"language-plaintext highlighter-rouge\">sincos_to_one</code> rule created in the unification post.</p>\n\n<h2 id=\"toy-problem\">Toy Problem</h2>\n\n<p>Lets see branching strategies with a toy problem. Consider the following\n“function”</p>\n\n\\[f(x) =\n\\cases{\nx+1                 &amp; \\text{if } 5 &lt; x &lt; 10 \\\\\\\\\nx-1                 &amp; \\text{if } 0 &lt; x &lt; 5 \\\\\\\\\nx+1 \\text{ or } x-1 &amp; \\text{if } x = 5 \\\\\\\\\nx                   &amp; \\text{otherwise} \\\\\\\\\n}\\]\n\n<p>And it’s equivalent in Python</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"k\">def</span> <span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span>\n    <span class=\"k\">if</span> <span class=\"mi\">0</span> <span class=\"o\">&lt;</span> <span class=\"n\">x</span> <span class=\"o\">&lt;</span> <span class=\"mi\">5</span><span class=\"p\">:</span>   <span class=\"k\">yield</span> <span class=\"n\">x</span> <span class=\"o\">-</span> <span class=\"mi\">1</span>\n    <span class=\"k\">if</span> <span class=\"mi\">5</span> <span class=\"o\">&lt;</span> <span class=\"n\">x</span> <span class=\"o\">&lt;</span> <span class=\"mi\">10</span><span class=\"p\">:</span>  <span class=\"k\">yield</span> <span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">1</span>\n    <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"o\">==</span> <span class=\"mi\">5</span><span class=\"p\">:</span>      <span class=\"k\">yield</span> <span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"k\">yield</span> <span class=\"n\">x</span> <span class=\"o\">-</span> <span class=\"mi\">1</span></code></pre>\n</figure>\n\n<p>Notice that in the case where <code class=\"language-plaintext highlighter-rouge\">x = 5</code> there are two possible outcomes. Each of these is preserved by the application of branching strategies. We use the branching version of the <code class=\"language-plaintext highlighter-rouge\">exhaust</code> strategy to make a new exhaustive\nversion of this function</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">sympy.rules.branch</span> <span class=\"kn\">import</span> <span class=\"n\">exhaust</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">newf</span> <span class=\"o\">=</span> <span class=\"n\">exhaust</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">set</span><span class=\"p\">(</span><span class=\"n\">newf</span><span class=\"p\">(</span><span class=\"mi\">6</span><span class=\"p\">))</span>\n<span class=\"p\">{</span><span class=\"mi\">10</span><span class=\"p\">}</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">set</span><span class=\"p\">(</span><span class=\"n\">newf</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">))</span>\n<span class=\"p\">{</span><span class=\"mi\">0</span><span class=\"p\">}</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">set</span><span class=\"p\">(</span><span class=\"n\">newf</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">))</span>\n<span class=\"p\">{</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">}</span></code></pre>\n</figure>\n\n<hr />\n\n<h2 id=\"practical-problem\">Practical Problem</h2>\n\n<p>We have all the machinery necessary. Lets make a <code class=\"language-plaintext highlighter-rouge\">sin(x)**2 + cos(x)**2 -&gt; 1</code> tree-wise simplification function.</p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">sympy.rules.branch.traverse</span> <span class=\"kn\">import</span> <span class=\"n\">top_down</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">sympy.unify.rewrite</span> <span class=\"kn\">import</span> <span class=\"n\">rewriterule</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">sympy.abc</span> <span class=\"kn\">import</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">sincos_to_one</span> <span class=\"o\">=</span> <span class=\"n\">rewriterule</span><span class=\"p\">(</span><span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"n\">cos</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">S</span><span class=\"p\">.</span><span class=\"n\">One</span><span class=\"p\">,</span> <span class=\"n\">wilds</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">])</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">sincos_tree</span> <span class=\"o\">=</span> <span class=\"n\">top_down</span><span class=\"p\">(</span><span class=\"n\">sincos_to_one</span><span class=\"p\">)</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">sincos_tree</span><span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"n\">c</span><span class=\"o\">**</span><span class=\"p\">(</span><span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">+</span><span class=\"n\">b</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"n\">cos</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">+</span><span class=\"n\">b</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">)))</span>  <span class=\"c1\"># see footnote\n</span><span class=\"p\">[</span><span class=\"n\">c</span><span class=\"o\">**</span><span class=\"mi\">1</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"p\">]</span></code></pre>\n</figure>\n\n<p>Lets make a rule to simplify expressions like <code class=\"language-plaintext highlighter-rouge\">c**1</code></p>\n\n<figure class=\"highlight\">\n  <pre><code class=\"language-python\" data-lang=\"python\"><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">pow_simp</span> <span class=\"o\">=</span> <span class=\"n\">rewriterule</span><span class=\"p\">(</span><span class=\"n\">Pow</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">evaluate</span><span class=\"o\">=</span><span class=\"bp\">False</span><span class=\"p\">),</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">wilds</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">])</span> <span class=\"c1\"># footnote 2\n</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">sympy.rules.branch.strat_pure</span> <span class=\"kn\">import</span> <span class=\"n\">multiplex</span><span class=\"p\">,</span> <span class=\"n\">exhaust</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">simplify</span> <span class=\"o\">=</span> <span class=\"n\">exhaust</span><span class=\"p\">(</span><span class=\"n\">top_down</span><span class=\"p\">(</span><span class=\"n\">multiplex</span><span class=\"p\">(</span><span class=\"n\">sincos_to_one</span><span class=\"p\">,</span> <span class=\"n\">pow_simp</span><span class=\"p\">)))</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">simplify</span><span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"n\">c</span><span class=\"o\">**</span><span class=\"p\">(</span><span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">+</span><span class=\"n\">b</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"n\">cos</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">+</span><span class=\"n\">b</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">)))</span>\n<span class=\"p\">[</span><span class=\"n\">c</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"p\">]</span></code></pre>\n</figure>\n\n<p>We see how we can easiy build up powerful simplification functions through the separate description of logic</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>sin(x)**2 + cos(x)**2 -&gt; 1\nx ** 1 -&gt; x\n</code></pre></div></div>\n\n<p>and control</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>simplify = exhaust(top_down(multiplex( ... )))\n</code></pre></div></div>\n\n<hr />\n\n<p><em>Footnote 1</em>: At the time of this writing this line should actually be</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>map(rebuild, sincos_tree( ... )\n</code></pre></div></div>\n\n<p>The <code class=\"language-plaintext highlighter-rouge\">rebuild</code> function is necessary because rules don’t play well with <code class=\"language-plaintext highlighter-rouge\">Expr</code>s. Expr’s need to be constructed normally in order to function properly. In particular all expressions built by rules lack the <code class=\"language-plaintext highlighter-rouge\">is_commutative</code> flag which is attached onto the object at construction time. I neglected to mention this above to simplify the discussion.</p>\n\n<p><em>Footnote 2</em>: This also requires a slight modification due to the Expr/rules mismatch. In particular the pattern <code class=\"language-plaintext highlighter-rouge\">Pow(x, 1, evaluate=False)</code> unfortunately matches to just <code class=\"language-plaintext highlighter-rouge\">x</code> because <code class=\"language-plaintext highlighter-rouge\">x == x**1</code> in SymPy.</p>"
}