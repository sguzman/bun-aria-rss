{
  "title": "Not every REINFORCE should be called Reinforcement Learning",
  "link": "http://artem.sobolev.name/posts/2020-11-29-reinforce-is-not-rl.html",
  "description": "<p>Deep RL is hot these days. It’s one of the most popular topics in the submissions at NeurIPS / ICLR / ICML and other ML conferences. And while the definition of RL is pretty general, in this note I’d argue that the famous REINFORCE algorithm <em>alone</em> is not enough to label your method as a Reinforcement Learning one.</p>\n<!--more-->\n<h2 id=\"reinforce\">REINFORCE</h2>\n<p>REINFORCE is a method introduced by Ronald Williams, commonly cited as coming from “Simple statistical gradient-following algorithms for connectionist reinforcement learning”. Given a long and fruitful history of the method, it’s natural that it’s definition has evolved and for different people this method might mean somewhat different things, so let me first describe what <strong>I</strong> mean by the REINFROCE in this particular discussion<a href=\"#fn1\" class=\"footnoteRef\" id=\"fnref1\"><sup>1</sup></a>.</p>\n<p>In this post we’ll assume REINFORCE to be equivalent to the score-function gradient estimator (also known as the log-derivative trick gradient estimator) with a certain (most likely constant<a href=\"#fn2\" class=\"footnoteRef\" id=\"fnref2\"><sup>2</sup></a>) baseline for variance reduction.</p>\n<p>I don’t want to re-introduce this method (I believe I <a href=\"/posts/2017-11-12-stochastic-computation-graphs-fixing-reinforce.html\">already did</a> it quite some time ago), instead I refer an interested reader to a <a href=\"http://blog.shakirm.com/2015/11/machine-learning-trick-of-the-day-5-log-derivative-trick/\">great blog post by Shakir Mohamed</a>, where the score-function (gradient) estimator is explained.</p>\n<h2 id=\"what-reinforce-is-used-for\">What REINFORCE is used for</h2>\n<p>REINFORCE is used to estimate the gradients of the policy <span class=\"math inline\">\\(\\pi_\\theta(\\tau)\\)</span> when dealing with the objectives of the following form<a href=\"#fn3\" class=\"footnoteRef\" id=\"fnref3\"><sup>3</sup></a>: <span class=\"math display\">\\[\n\\mathop{\\mathbb{E}}_{\\pi_\\theta(\\tau)} R(\\tau) \\to \\max_{\\theta}\n\\]</span> The REINFORCE gradient estimator is then given by (where <span class=\"math inline\">\\(b\\in\\mathbb{R}\\)</span> is a baseline)<span class=\"math display\">\\[\n\\left(R(\\tau) - b\\right) \\nabla_\\theta \\log \\pi_\\theta(\\tau), \\quad\\quad \\text{where $\\tau \\sim \\pi_\\theta(\\tau)$}\n\\]</span>The major benefits of this estimator are:</p>\n<ul>\n<li>We don’t need to know the reward function <span class=\"math inline\">\\(R(\\tau)\\)</span>, we only need to evaluate it on the sampled trajectories <span class=\"math inline\">\\(\\tau\\)</span>.</li>\n<li>There are no assumptions on <span class=\"math inline\">\\(R(\\tau)\\)</span>, it can be non-differentiable or even discontinuous.</li>\n<li>Even the <span class=\"math inline\">\\(\\tau\\)</span> itself could be discrete! We only need to log probability <span class=\"math inline\">\\(\\log \\pi_\\theta(\\tau)\\)</span> to be differentiable in <span class=\"math inline\">\\(\\theta\\)</span> (but not in <span class=\"math inline\">\\(\\tau\\)</span>).</li>\n</ul>\n<p>The last two properties make the REINFORCE estimator an appealing choice for the gradient estimation in stochastic computation graphs, which I <a href=\"/tags/stochastic%20computation%20graphs%20series.html\">have written at length</a> about.</p>\n<p>There are lots of papers that do use REINFORCE in this exact scenario. For example, in a recent paper <a href=\"http://proceedings.mlr.press/v119/yoon20a.html\">Data Valuation using Reinforcement Learning</a> (DVRL) researchers from Google do exactly that: they define a certain stochastic computation graph that contains discrete binary random variables in it. Then a simple REINFORCE gradient estimator is used to train those layers which cannot be reached by the standard backpropagation.</p>\n<p>Notably, the paper cites only one paper that has Reinforcement Learning in its title – the original one by Williams. Other than that it seems pretty disconnected from the RL literature. This hints a question: should it even be called to be “using RL”?</p>\n<h2 id=\"communicative-value\">Communicative Value</h2>\n<p>Words are used to communicate ideas. When I say “Deep Neural Network” associations fire up in your brain and, provided you’re well-versed in the modern ML, you immediately think of all these modern (well, maybe not all of them) fancy things we call CNNs, ResNets, RNNs, LSTMs, Transformers, GNNs and many-many-many more. But I can also claim that a Logistic Regression (LR) is a special case of fully-connected neural networks, especially if you train them with stochastic optimization methods. But what’s the <em>communicative value</em> of this statement? What information does it convey? Does much of knowledge about LR generalize to Neural Nets? Or, does it benefit hugely from our modern Deep Learning toolkit? When was the last time you used batchnorm to train your Logistic Regression?</p>\n<p>What I’m trying to say is that although LR can be technically categorized as a Neural Network, this categorization appears to be useless, it does not open any interesting knowledge / expertice transfer. However, stack a logistic classifier on top of a pre-trained neural network and train the whole pipeline end-to-end – and you’re in the <a href=\"https://twitter.com/realTurboPascal/status/1111136291394068480\">#backpropaganda</a> now!</p>\n<p>Same goes for REINFORCE: the communicative value of calling methods like the aforementioned DVRL as “using RL” is very small. In my opinion, distinctive traits of (modern) Reinforcement Learning are:</p>\n<ul>\n<li>Delayed rewards<a href=\"#fn4\" class=\"footnoteRef\" id=\"fnref4\"><sup>4</sup></a></li>\n<li>Unknown environment model</li>\n<li>A single action at each state</li>\n</ul>\n<p>When you say you “use RL” it should mean you’ve posed the problem at hand such that it benefits from the vast research produced by RL people that address these traits. It’s this connection that bears communicative value as now you know that advances in RL would translate to your problem, too.</p>\n<p>If your problem lacks these traits and you go for RL methods anyway, you ignore much of the useful structure you have in your problem, constraining yourself to methods that are designed for a much harder problem. Keep in mind that RL is hard:</p>\n<blockquote class=\"twitter-tweet\">\n<p lang=\"en\" dir=\"ltr\">\nWhen you say, “This is a reinforcement learning problem,” you should say it with the same excitement as “This is NP-hard.”\n</p>\n— Tim Vieira (<span class=\"citation\">@xtimv</span>) <a href=\"https://twitter.com/xtimv/status/795050238948110336?ref_src=twsrc%5Etfw\">November 5, 2016</a>\n</blockquote>\n<script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n<p>Perhaps a large body of RL work might be solving a problem you don’t even have to start with! Speaking of the REINFORCE method, it’s biggest problem is large variance, for which people have designed <a href=\"/posts/2017-11-12-stochastic-computation-graphs-fixing-reinforce.html\">clever baselines</a>, but in RL, one might argue, <a href=\"https://arxiv.org/abs/1802.10031\">such baselines have limited value</a>. On the other hand, Gumbel-Softmax (and <a href=\"/posts/2017-10-28-stochastic-computation-graphs-discrete-relaxations.html\">relaxations</a> in general) – a method one should almost always consider when thinking of training stochastic computation graphs with REINFORCE – is not applicable in the standard RL setting.</p>\n<p>In the particular case of DVRL the problem has much more useful structure that can be used than the RL literature assumes. It has no delay in feedback, has fully known environment model and allows you to take multiple actions at each state – all of these imply you can do things RL people can’t afford. Unsurprisingly, this departure from the standard RL setting is reflected in the absence of RL works in the bibliographic selection.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>There are other papers just like the DVRL that use REINFORCE to perform gradient estimation in models with discrete random variables and claim to be doing Reinforcement Learning. While possibly benefitting from all the hype around RL, this narrows the selection of methods to those designed for a much more general and hard problem. I hope I have convinced you that the Venn diagram for RL and REINFORCE should not have one containing the other.</p>\n<div class=\"footnotes\">\n<hr />\n<ol>\n<li id=\"fn1\"><p>If to you REINFORCE means something different of something more than what I describe, then you’d probably agree with my claim. But anyway let me know in the comments below!<a href=\"#fnref1\">↩</a></p></li>\n<li id=\"fn2\"><p>The original REINFORCE did assume a certain (probably) constant baseline to be employed, but let’s assume that constant could be 0 to include vanilla score-function estimator as well.<a href=\"#fnref2\">↩</a></p></li>\n<li id=\"fn3\"><p>In the RL parlance <span class=\"math inline\">\\(\\tau\\)</span> is a trajectory (sequence of state-action pairs) and <span class=\"math inline\">\\(R(\\tau)\\)</span> is an unknown reward function, which is usually assumed to be comprised of individual rewards per each state-action pair: <span class=\"math display\">\\[ R(\\tau) = \\sum_{(s_t, a_t) \\in \\tau} r_t(s_t, a_t) \\]</span><a href=\"#fnref3\">↩</a></p></li>\n<li id=\"fn4\"><p>For this reason I don’t think bandits should be called RL either.<a href=\"#fnref4\">↩</a></p></li>\n</ol>\n</div>",
  "pubDate": "Sun, 29 Nov 2020 00:00:00 UT",
  "guid": "http://artem.sobolev.name/posts/2020-11-29-reinforce-is-not-rl.html",
  "dc:creator": "Artem"
}