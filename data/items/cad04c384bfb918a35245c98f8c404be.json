{
  "title": "A Visual Guide to Evolution Strategies",
  "link": "https://blog.otoro.net/2017/10/29/visual-evolution-strategies/",
  "guid": "https://blog.otoro.net/2017/10/29/visual-evolution-strategies/",
  "description": "<center>\n<img src=\"/assets/20171031/es_bear.jpeg\" width=\"60%\" /><br />\n<p></p>\n<i>Survival of the fittest.</i>\n<!--\n<p></p>\nEvolved Bipedal Walker<br/>\n<code>\n<a href=\"https://github.com/hardmaru/\">GitHub</a>\n</code>\n-->\n</center>\n<p></p>\n\n<p>In this post I explain how evolution strategies (ES) work with the aid of a few visual examples. I try to keep the equations light, and I provide links to original articles if the reader wishes to understand more details. This is the first post in a series of articles, where I plan to show how to apply these algorithms to a range of tasks from MNIST, OpenAI Gym, Roboschool to PyBullet environments.</p>\n\n<h2 id=\"introduction\">Introduction</h2>\n\n<p>Neural network models are highly expressive and flexible, and if we are able to find a suitable set of model parameters, we can use neural nets to solve many challenging problems. Deep learning’s success largely comes from the ability to use the backpropagation algorithm to efficiently calculate the gradient of an objective function over each model parameter. With these gradients, we can efficiently search over the parameter space to find a solution that is often good enough for our neural net to accomplish difficult tasks.</p>\n\n<p>However, there are many problems where the backpropagation algorithm cannot be used. For example, in reinforcement learning (RL) problems, we can also train a neural network to make decisions to perform a sequence of actions to accomplish some task in an environment. However, it is not trivial to estimate the gradient of reward signals given to the agent in the future to an action performed by the agent right now, especially if the reward is realised many timesteps in the future. Even if we are able to calculate accurate gradients, there is also the issue of being stuck in a local optimum, which exists many for RL tasks.</p>\n\n<center>\n<img src=\"/assets/20171031/biped/biped_local_optima.gif\" width=\"100%\" />\n<p></p>\n<i>Stuck in a local optimum.</i>\n</center>\n<p></p>\n\n<p>A whole area within RL is devoted to studying this credit-assignment problem, and great progress has been made in recent years. However, credit assignment is still difficult when the reward signals are sparse. In the real world, rewards can be sparse and noisy. Sometimes we are given just a single reward, like a bonus check at the end of the year, and depending on our employer, it may be difficult to figure out exactly why it is so low. For these problems, rather than rely on a very noisy and possibly meaningless gradient estimate of the future to our policy, we might as well just ignore any gradient information, and attempt to use black-box optimisation techniques such as genetic algorithms (GA) or ES.</p>\n\n<p>OpenAI published a paper called <a href=\"https://blog.openai.com/evolution-strategies/\">Evolution Strategies as a Scalable Alternative to Reinforcement Learning</a> where they showed that evolution strategies, while being less data efficient than RL, offer many benefits. The ability to abandon gradient calculation allows such algorithms to be evaluated more efficiently. It is also easy to distribute the computation for an ES algorithm to thousands of machines for parallel computation. By running the algorithm from scratch many times, they also showed that policies discovered using ES tend to be more diverse compared to policies discovered by RL algorithms.</p>\n\n<p>I would like to point out that even for the problem of identifying a machine learning model, such as designing a neural net’s architecture, is one where we cannot directly compute gradients. While <a href=\"https://research.googleblog.com/2017/05/using-machine-learning-to-explore.html\">RL</a>, <a href=\"https://arxiv.org/abs/1703.00548\">Evolution</a>, <a href=\"https://blog.otoro.net/2016/05/07/backprop-neat/\">GA</a> etc., can be applied to search in the space of model architectures, in this post, I will focus only on applying these algorithms to search for parameters of a pre-defined model.</p>\n\n<h2 id=\"what-is-an-evolution-strategy\">What is an Evolution Strategy?</h2>\n\n<center>\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/8/8b/Rastrigin_function.png\" width=\"70%\" /><br />\n<i>Two-dimensional Rastrigin function has many local optima (Source: <a href=\"https://en.wikipedia.org/wiki/Test_functions_for_optimization\">Wikipedia</a></i>).\n</center>\n<p></p>\n<p>The diagrams below are top-down plots of <em>shifted</em> 2D <a href=\"https://en.wikipedia.org/wiki/Test_functions_for_optimization\">Schaffer and Rastrigin</a> functions, two of several simple toy problems used for testing continuous black-box optimisation algorithms. Lighter regions of the plots represent higher values of <script type=\"math/tex\">F(x, y)</script>. As you can see, there are many local optimums in this function. Our job is to find a set of <em>model parameters</em> <script type=\"math/tex\">(x, y)</script>, such that <script type=\"math/tex\">F(x, y)</script> is as close as possible to the global maximum.</p>\n\n<center>\n<table style=\"width:100%\">\n<tr>\n  <td>\n  <center><i>Schaffer-2D Function</i></center>\n  <br />\n  <img src=\"/assets/20171031/schaffer/schaffer_label.png\" width=\"100%\" />\n  </td>\n  <td>\n  <center><i>Rastrigin-2D Function</i></center>\n  <br />\n  <img src=\"/assets/20171031/rastrigin/rastrigin_label.png\" width=\"100%\" />\n  </td>\n</tr>\n</table>\n</center>\n\n<p>Although there are many definitions of evolution strategies, we can define an evolution strategy as an algorithm that provides the user a set of candidate solutions to evaluate a problem. The evaluation is based on an <em>objective function</em> that takes a given solution and returns a single <em>fitness</em> value. Based on the fitness results of the current solutions, the algorithm will then produce the next generation of candidate solutions that is more likely to produce even better results than the current generation. The iterative process will stop once the best known solution is satisfactory for the user.</p>\n\n<p>Given an evolution strategy algorithm called <code class=\"highlighter-rouge\">EvolutionStrategy</code>, we can use in the following way:</p>\n\n<hr />\n<p><code>solver = EvolutionStrategy()</code></p>\n\n<p><code>while True:</code></p>\n\n<p><code>&nbsp;&nbsp;# ask the ES to give us a set of candidate solutions</code><br />\n<code>&nbsp;&nbsp;solutions = solver.ask()</code></p>\n\n<p><code>&nbsp;&nbsp;# create an array to hold the fitness results.</code><br />\n<code>&nbsp;&nbsp;fitness_list = np.zeros(solver.popsize)</code></p>\n\n<p><code>&nbsp;&nbsp;# evaluate the fitness for each given solution.</code><br />\n<code>&nbsp;&nbsp;for i in range(solver.popsize):</code><br />\n<code>&nbsp;&nbsp;&nbsp;&nbsp;fitness_list[i] = evaluate(solutions[i])</code></p>\n\n<p><code>&nbsp;&nbsp;# give list of fitness results back to ES</code><br />\n<code>&nbsp;&nbsp;solver.tell(fitness_list)</code></p>\n\n<p><code>&nbsp;&nbsp;# get best parameter, fitness from ES</code><br />\n<code>&nbsp;&nbsp;best_solution, best_fitness = solver.result()</code></p>\n\n<p><code>&nbsp;&nbsp;if best_fitness &gt; MY_REQUIRED_FITNESS:</code><br />\n<code>&nbsp;&nbsp;&nbsp;&nbsp;break</code></p>\n\n<hr />\n\n<p>Although the size of the population is usually held constant for each generation, they don’t need to be. The ES can generate as many candidate solutions as we want, because the solutions produced by an ES are <em>sampled</em> from a distribution whose parameters are being updated by the ES at each generation. I will explain this sampling process with an example of a simple evolution strategy.</p>\n\n<h2 id=\"simple-evolution-strategy\">Simple Evolution Strategy</h2>\n\n<p>One of the simplest evolution strategy we can imagine will just sample a set of solutions from a Normal distribution, with a mean <script type=\"math/tex\">\\mu</script> and a fixed standard deviation <script type=\"math/tex\">\\sigma</script>. In our 2D problem, <script type=\"math/tex\">\\mu = (\\mu_x, \\mu_y)</script> and <script type=\"math/tex\">\\sigma = (\\sigma_x, \\sigma_y)</script>. Initially, <script type=\"math/tex\">\\mu</script> is set at the origin. After the fitness results are evaluated, we set <script type=\"math/tex\">\\mu</script> to the best solution in the population, and sample the next generation of solutions around this new mean. This is how the algorithm behaves over 20 generations on the two problems mentioned earlier:</p>\n\n<center>\n<table style=\"width:100%\">\n<tr>\n  <td>\n  <img src=\"/assets/20171031/schaffer/simplees.gif\" width=\"100%\" />\n  </td>\n  <td>\n  <img src=\"/assets/20171031/rastrigin/simplees.gif\" width=\"100%\" />\n  </td>\n</tr>\n</table>\n</center>\n\n<p>In the visualisation above, the green dot indicates the mean of the distribution at each generation, the blue dots are the sampled solutions, and the red dot is the best solution found so far by our algorithm.</p>\n\n<p>This simple algorithm will generally only work for simple problems. Given its greedy nature, it throws away all but the best solution, and can be prone to be stuck at a local optimum for more complicated problems. It would be beneficial to sample the next generation from a probability distribution that represents a more diverse set of ideas, rather than just from the best solution from the current generation.</p>\n\n<h2 id=\"simple-genetic-algorithm\">Simple Genetic Algorithm</h2>\n\n<p>One of the oldest black-box optimisation algorithms is the genetic algorithm. There are many variations with many degrees of sophistication, but I will illustrate the simplest version here.</p>\n\n<p>The idea is quite simple: keep only 10% of the best performing solutions in the current generation, and let the rest of the population die. In the next generation, to sample a new solution is to randomly select two solutions from the survivors of the previous generation, and recombine their parameters to form a new solution. This <em>crossover</em> recombination process uses a coin toss to determine which parent to take each parameter from. In the case of our 2D toy function, our new solution might inherit <script type=\"math/tex\">x</script> or <script type=\"math/tex\">y</script> from either parents with 50% chance. Gaussian noise with a fixed standard deviation will also be injected into each new solution after this recombination process.</p>\n\n<center>\n<table style=\"width:100%\">\n<tr>\n  <td>\n  <img src=\"/assets/20171031/schaffer/simplega.gif\" width=\"100%\" />\n  </td>\n  <td>\n  <img src=\"/assets/20171031/rastrigin/simplega.gif\" width=\"100%\" />\n  </td>\n</tr>\n</table>\n</center>\n\n<p>The figure above illustrates how the simple genetic algorithm works. The green dots represent members of the elite population from the previous generation, the blue dots are the offsprings to form the set of candidate solutions, and the red dot is the best solution.</p>\n\n<p>Genetic algorithms help diversity by keeping track of a diverse set of candidate solutions to reproduce the next generation. However, in practice, most of the solutions in the elite surviving population tend to converge to a local optimum over time. There are more sophisticated variations of GA out there, such as <a href=\"http://people.idsia.ch/~juergen/gomez08a.pdf\">CoSyNe</a>, <a href=\"https://blog.otoro.net/2015/03/10/esp-algorithm-for-double-pendulum/\">ESP</a>, and <a href=\"https://blog.otoro.net/2016/05/07/backprop-neat/\">NEAT</a>, where the idea is to cluster similar solutions in the population together into different species, to maintain better diversity over time.</p>\n\n<h2 id=\"covariance-matrix-adaptation-evolution-strategy-cma-es\">Covariance-Matrix Adaptation Evolution Strategy (CMA-ES)</h2>\n\n<p>A shortcoming of both the Simple ES and Simple GA is that our standard deviation noise parameter is fixed. There are times when we want to explore more and increase the standard deviation of our search space, and there are times when we are confident we are close to a good optima and just want to fine tune the solution. We basically want our search process to behave like this:</p>\n\n<center>\n<table style=\"width:100%\">\n<tr>\n  <td>\n  <img src=\"/assets/20171031/schaffer/cmaes.gif\" width=\"100%\" />\n  </td>\n  <td>\n  <img src=\"/assets/20171031/rastrigin/cmaes.gif\" width=\"100%\" />\n  </td>\n</tr>\n</table>\n</center>\n\n<p>Amazing isn’it it? The search process shown in the figure above is produced by <a href=\"https://en.wikipedia.org/wiki/CMA-ES\">Covariance-Matrix Adaptation Evolution Strategy (CMA-ES)</a>. CMA-ES an algorithm that can take the results of each generation, and adaptively increase or decrease the search space for the next generation. It will not only adapt for the mean <script type=\"math/tex\">\\mu</script> and sigma <script type=\"math/tex\">\\sigma</script> parameters, but will calculate the entire covariance matrix of the parameter space. At each generation, CMA-ES provides the parameters of a multi-variate normal distribution to sample solutions from. So how does it know how to increase or decrease the search space?</p>\n\n<p>Before we discuss its methodology, let’s review how to estimate a <a href=\"https://en.wikipedia.org/wiki/Covariance_matrix\">covariance matrix</a>. This will be important to understand CMA-ES’s methodology later on. If we want to estimate the covariance matrix of our entire sampled population of size of <script type=\"math/tex\">N</script>, we can do so using the set of equations below to calculate the maximum likelihood estimate of a covariance matrix <script type=\"math/tex\">C</script>. We first calculate the means of each of the <script type=\"math/tex\">x_i</script> and <script type=\"math/tex\">y_i</script> in our population:</p>\n\n<script type=\"math/tex; mode=display\">\\mu_x = \\frac{1}{N} \\sum_{i=1}^{N}x_i,</script>\n\n<script type=\"math/tex; mode=display\">\\mu_y = \\frac{1}{N} \\sum_{i=1}^{N}y_i.</script>\n\n<p>The terms of the 2x2 covariance matrix <script type=\"math/tex\">C</script> will be:</p>\n\n<script type=\"math/tex; mode=display\">\\sigma_x^2 = \\frac{1}{N} \\sum_{i=1}^{N}(x_i - \\mu_x)^2,</script>\n\n<script type=\"math/tex; mode=display\">\\sigma_y^2 = \\frac{1}{N} \\sum_{i=1}^{N}(y_i - \\mu_y)^2,</script>\n\n<script type=\"math/tex; mode=display\">\\sigma_{xy} = \\frac{1}{N} \\sum_{i=1}^{N}(x_i - \\mu_x)(y_i - \\mu_y).</script>\n\n<p>Of course, these resulting mean estimates <script type=\"math/tex\">\\mu_x</script> and <script type=\"math/tex\">\\mu_y</script>, and covariance terms <script type=\"math/tex\">\\sigma_x</script>, <script type=\"math/tex\">\\sigma_y</script>, <script type=\"math/tex\">\\sigma_{xy}</script> will just be an estimate to the actual covariance matrix that we originally sampled from, and not particularly useful to us.</p>\n\n<p>CMA-ES modifies the above covariance calculation formula in a clever way to make it adapt well to an optimisation problem. I will go over how it does this step-by-step. Firstly, it focuses on the best <script type=\"math/tex\">N_{best}</script> solutions in the current generation. For simplicity let’s set <script type=\"math/tex\">N_{best}</script> to be the best 25% of solutions. After sorting the solutions based on fitness, we calculate the mean <script type=\"math/tex\">\\mu^{(g+1)}</script> of the next generation <script type=\"math/tex\">(g+1)</script> as the average of only the best 25% of the solutions in current population <script type=\"math/tex\">(g)</script>, i.e.:</p>\n\n<script type=\"math/tex; mode=display\">\\mu_x^{(g+1)} = \\frac{1}{N_{best}} \\sum_{i=1}^{N_{best}}x_i,</script>\n\n<script type=\"math/tex; mode=display\">\\mu_y^{(g+1)} = \\frac{1}{N_{best}} \\sum_{i=1}^{N_{best}}y_i.</script>\n\n<p>Next, we use only the best 25% of the solutions to estimate the covariance matrix <script type=\"math/tex\">C^{(g+1)}</script> of the next generation, but the clever <em>hack</em> here is that it uses the <em>current</em> generation’s <script type=\"math/tex\">\\mu^{(g)}</script>, rather than the updated <script type=\"math/tex\">\\mu^{(g+1)}</script> parameters that we had just calculated, in the calculation:</p>\n\n<script type=\"math/tex; mode=display\">\\sigma_x^{2, (g+1)} = \\frac{1}{N_{best}} \\sum_{i=1}^{N_{best}}(x_i - \\mu_x^{(g)})^2,</script>\n\n<script type=\"math/tex; mode=display\">\\sigma_y^{2, (g+1)} = \\frac{1}{N_{best}} \\sum_{i=1}^{N_{best}}(y_i - \\mu_y^{(g)})^2,</script>\n\n<script type=\"math/tex; mode=display\">\\sigma_{xy}^{(g+1)} = \\frac{1}{N_{best}} \\sum_{i=1}^{N_{best}}(x_i - \\mu_x^{(g)})(y_i - \\mu_y^{(g)}).</script>\n\n<p>Armed with a set of <script type=\"math/tex\">\\mu_x</script>, <script type=\"math/tex\">\\mu_y</script>, <script type=\"math/tex\">\\sigma_x</script>, <script type=\"math/tex\">\\sigma_y</script>, and <script type=\"math/tex\">\\sigma_{xy}</script> parameters for the next generation <script type=\"math/tex\">(g+1)</script>, we can now sample the next generation of candidate solutions.</p>\n\n<p>Below is a set of figures to visually illustrate how it uses the results from the current generation <script type=\"math/tex\">(g)</script> to construct the solutions in the next generation <script type=\"math/tex\">(g+1)</script>:</p>\n\n<center>\n<table style=\"width:100%\">\n<tr>\n  <td><img src=\"/assets/20171031/rastrigin/cmaes_step1.png\" width=\"100%\" /><center><i>Step 1</i></center></td>\n  <td><img src=\"/assets/20171031/rastrigin/cmaes_step2.png\" width=\"100%\" /><center><i>Step 2</i></center></td>\n  <td><img src=\"/assets/20171031/rastrigin/cmaes_step3.png\" width=\"100%\" /><center><i>Step 3</i></center></td>\n  <td><img src=\"/assets/20171031/rastrigin/cmaes_step4.png\" width=\"100%\" /><center><i>Step 4</i></center></td>\n</tr>\n</table>\n</center>\n\n<ol>\n  <li>Calculate the fitness score of each candidate solution in generation <script type=\"math/tex\">(g)</script>.</li>\n  <li>Isolates the best 25% of the population in generation <script type=\"math/tex\">(g)</script>, in purple.</li>\n  <li>Using only the best solutions, along with the mean <script type=\"math/tex\">\\mu^{(g)}</script> of the current generation (the green dot), calculate the covariance matrix <script type=\"math/tex\">C^{(g+1)}</script> of the next generation.</li>\n  <li>Sample a new set of candidate solutions using the updated mean <script type=\"math/tex\">\\mu^{(g+1)}</script> and covariance matrix <script type=\"math/tex\">C^{(g+1)}</script>.</li>\n</ol>\n\n<p>Let’s visualise the scheme one more time, on the entire search process on both problems:</p>\n\n<center>\n<table style=\"width:100%\">\n<tr>\n  <td>\n  <img src=\"/assets/20171031/schaffer/cmaes2.gif\" width=\"100%\" />\n  </td>\n  <td>\n  <img src=\"/assets/20171031/rastrigin/cmaes2.gif\" width=\"100%\" />\n  </td>\n</tr>\n</table>\n</center>\n\n<p>Because CMA-ES can adapt both its mean and covariance matrix using information from the best solutions, it can decide to cast a wider net when the best solutions are far away, or narrow the search space when the best solutions are close by.  My description of the CMA-ES algorithm for a 2D toy problem is highly simplified to get the idea across. For more details, I suggest reading the <a href=\"https://arxiv.org/abs/1604.00772\">CMA-ES Tutorial</a> prepared by Nikolaus Hansen, the author of CMA-ES.</p>\n\n<p>This algorithm is one of the most popular gradient-free optimisation algorithms out there, and has been the algorithm of choice for many researchers and practitioners alike. The only real drawback is the performance if the number of model parameters we need to solve for is large, as the covariance calculation is <script type=\"math/tex\">O(N^2)</script>, although recently there has been approximations to make it <script type=\"math/tex\">O(N)</script>. CMA-ES is my algorithm of choice when the search space is less than a thousand parameters. I found it still usable up to ~ 10K parameters if I’m willing to be patient.</p>\n\n<h2 id=\"natural-evolution-strategies\">Natural Evolution Strategies</h2>\n\n<hr />\n\n<p><em>Imagine if you had built an artificial life simulator, and you sample a different neural network to control the behavior of each ant inside an ant colony. Using the Simple Evolution Strategy for this task will optimise for traits and behaviours that benefit individual ants, and with each successive generation, our population will be full of alpha ants who only care about their own well-being.</em></p>\n\n<p><em>Instead of using a rule that is based on the survival of the fittest ants, what if you take an alternative approach where you take the sum of all fitness values of the entire ant population, and optimise for this sum instead to maximise the well-being of the entire ant population over successive generations? Well, you would end up creating a Marxist utopia.</em></p>\n\n<hr />\n\n<p>A perceived weakness of the algorithms mentioned so far is that they discard the majority of the solutions and only keep the best solutions. Weak solutions contain information about what <em>not</em> to do, and this is valuable information to calculate a better estimate for the next generation.</p>\n\n<p>Many people who studied RL are familiar with the <a href=\"http://www-anw.cs.umass.edu/~barto/courses/cs687/williams92simple.pdf\">REINFORCE</a> paper. In this 1992 paper, Williams outlined an approach to estimate the gradient of the expected rewards with respect to the model parameters of a policy neural network. This paper also proposed using REINFORCE as an Evolution Strategy, in Section 6 of the paper. This special case of <em>REINFORCE-ES</em> was expanded later on in <a href=\"https://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=A64D1AE8313A364B814998E9E245B40A?doi=10.1.1.180.7104&amp;rep=rep1&amp;type=pdf\">Parameter-Exploring Policy Gradients</a> (PEPG, 2009) and <a href=\"https://www.jmlr.org/papers/volume15/wierstra14a/wierstra14a.pdf\">Natural Evolution Strategies</a> (NES, 2014).</p>\n\n<p>In this approach, we want to use all of the information from each member of the population, good or bad, for estimating a gradient signal that can move the entire population to a better direction in the next generation. Since we are estimating a gradient, we can also use this gradient in a standard SGD update rule typically used for deep learning. We can even use this estimated gradient with Momentum SGD, RMSProp, or Adam if we want to.</p>\n\n<p>The idea is to maximise the <em>expected value</em> of the fitness score of a sampled solution. If the expected result is good enough, then the best performing member within a sampled population will be even better, so optimising for the expectation might be a sensible approach. Maximising the expected fitness score of a sampled solution is almost the same as maximising the total fitness score of the entire population.</p>\n\n<p>If <script type=\"math/tex\">z</script> is a solution vector sampled from a probability distribution function <script type=\"math/tex\">\\pi(z, \\theta)</script>, we can define the expected value of the objective function <script type=\"math/tex\">F</script> as:</p>\n\n<script type=\"math/tex; mode=display\">J(\\theta) = E_{\\theta}[F(z)] = \\int F(z) \\; \\pi(z, \\theta) \\; dz,</script>\n\n<p>where <script type=\"math/tex\">\\theta</script> are the parameters of the probability distribution function. For example, if <script type=\"math/tex\">\\pi</script> is a normal distribution, then <script type=\"math/tex\">\\theta</script> would be <script type=\"math/tex\">\\mu</script> and <script type=\"math/tex\">\\sigma</script>. For our simple 2D toy problems, each ensemble <script type=\"math/tex\">z</script> is a 2D vector <script type=\"math/tex\">(x, y)</script>.</p>\n\n<p>The <a href=\"https://www.jmlr.org/papers/volume15/wierstra14a/wierstra14a.pdf\">NES paper</a> contains a nice derivation of the gradient of <script type=\"math/tex\">J(\\theta)</script> with respect to <script type=\"math/tex\">\\theta</script>. Using the same <em>log-likelihood trick</em> as in the REINFORCE algorithm allows us to calculate the gradient of <script type=\"math/tex\">J(\\theta)</script>:</p>\n\n<script type=\"math/tex; mode=display\">\\nabla_{\\theta} J(\\theta) = E_{\\theta}[ \\; F(z)  \\; \\nabla_{\\theta} \\log \\pi(z, \\theta) \\; ].</script>\n\n<p>In a population size of <script type=\"math/tex\">N</script>, where we have solutions <script type=\"math/tex\">z^1</script>, <script type=\"math/tex\">z^2</script>, <script type=\"math/tex\">...</script> <script type=\"math/tex\">z^N</script>, we can estimate this gradient as a summation:</p>\n\n<script type=\"math/tex; mode=display\">\\nabla_{\\theta} J(\\theta) \\approx \\frac{1}{N} \\sum_{i=1}^{N} \\; F(z^i)  \\; \\nabla_{\\theta} \\log \\pi(z^i, \\theta).</script>\n\n<p>With this gradient <script type=\"math/tex\">\\nabla_{\\theta} J(\\theta)</script>, we can use a learning rate parameter <script type=\"math/tex\">\\alpha</script> (such as 0.01) and start optimising the <script type=\"math/tex\">\\theta</script> parameters of pdf <script type=\"math/tex\">\\pi</script> so that our sampled solutions will likely get higher fitness scores on the objective function <script type=\"math/tex\">F</script>. Using SGD (or Adam), we can update <script type=\"math/tex\">\\theta</script> for the next generation:</p>\n\n<script type=\"math/tex; mode=display\">\\theta \\rightarrow \\theta + \\alpha \\nabla_{\\theta} J(\\theta),</script>\n\n<p>and sample a new set of candidate solutions <script type=\"math/tex\">z</script> from this updated pdf, and continue until we arrive at a satisfactory solution.</p>\n\n<p>In Section 6 of the <a href=\"https://www-anw.cs.umass.edu/~barto/courses/cs687/williams92simple.pdf\">REINFORCE</a> paper, Williams derived closed-form formulas of the gradient <script type=\"math/tex\">\\nabla_{\\theta} \\log \\pi(z^i, \\theta)</script>, for the special case where <script type=\"math/tex\">\\pi(z, \\theta)</script> is a factored multi-variate normal distribution (i.e., the correlation parameters are zero). In this special case, <script type=\"math/tex\">\\theta</script> are the <script type=\"math/tex\">\\mu</script> and <script type=\"math/tex\">\\sigma</script> vectors. Therefore, each element of a solution can be sampled from a univariate normal distribution <script type=\"math/tex\">z_j \\sim N(\\mu_j, \\sigma_j)</script>.</p>\n\n<p>The closed-form formulas for <script type=\"math/tex\">\\nabla_{\\theta} \\log N(z^i, \\theta)</script>, for each individual element of vector <script type=\"math/tex\">\\theta</script> on each solution <script type=\"math/tex\">i</script> in the population can be derived as:</p>\n\n<script type=\"math/tex; mode=display\">\\nabla_{\\mu_{j}} \\log N(z^i, \\mu, \\sigma) = \\frac{z_j^i - \\mu_j}{\\sigma_j^2},</script>\n\n<script type=\"math/tex; mode=display\">\\nabla_{\\sigma_{j}} \\log N(z^i, \\mu, \\sigma) = \\frac{(z_j^i - \\mu_j)^2 - \\sigma_j^2}{\\sigma_j^3}.</script>\n\n<p>For clarity, I use the index of <script type=\"math/tex\">j</script>, to count across parameter space, and this is not to be confused with superscript <script type=\"math/tex\">i</script>, used to count across each sampled member of the population. For our 2D problems, <script type=\"math/tex\">z_1 = x</script>, <script type=\"math/tex\">z_2 = y</script>, <script type=\"math/tex\">\\mu_1 = \\mu_x</script>, <script type=\"math/tex\">\\mu_2 = \\mu_y</script>, <script type=\"math/tex\">\\sigma_1 = \\sigma_x</script>, <script type=\"math/tex\">\\sigma_2 = \\sigma_y</script> in this context.</p>\n\n<p>These two formulas can be plugged back into the approximate gradient formula to derive explicit update rules for <script type=\"math/tex\">\\mu</script> and <script type=\"math/tex\">\\sigma</script>. In the papers mentioned above, they derived more explicit update rules, incorporated a <em>baseline</em>, and introduced other tricks such as antithetic sampling in PEPG, which is what my implementation is based on. NES proposed incorporating the inverse of the Fisher Information Matrix into the gradient update rule. But the concept is basically the same as other ES algorithms, where we update the mean and standard deviation of a multi-variate normal distribution at each new generation, and sample a new set of solutions from the updated distribution. Below is a visualization of this algorithm in action, following the formulas described above:</p>\n\n<center>\n<table style=\"width:100%\">\n<tr>\n  <td>\n  <img src=\"/assets/20171031/schaffer/pepg.gif\" width=\"100%\" />\n  </td>\n  <td>\n  <img src=\"/assets/20171031/rastrigin/pepg.gif\" width=\"100%\" />\n  </td>\n</tr>\n</table>\n</center>\n\n<p>We see that this algorithm is able to dynamically change the <script type=\"math/tex\">\\sigma</script>’s to explore or fine tune the solution space as needed. Unlike CMA-ES, there is no correlation structure in our implementation, so we don’t get the diagonal ellipse samples, only the vertical or horizontal ones, although in principle we can derive update rules to incorporate the entire covariance matrix if we needed to, at the expense of computational efficiency.</p>\n\n<p>I like this algorithm because like CMA-ES, the <script type=\"math/tex\">\\sigma</script>’s can adapt so our search space can be expanded or narrowed over time. Because the correlation parameter is not used in this implementation, the efficiency of the algorithm is <script type=\"math/tex\">O(N)</script> so I use PEPG if the performance of CMA-ES becomes an issue. I usually use PEPG when the number of model parameters exceed several thousand.</p>\n\n<h2 id=\"openai-evolution-strategy\">OpenAI Evolution Strategy</h2>\n\n<p>In OpenAI’s <a href=\"https://blog.openai.com/evolution-strategies/\">paper</a>, they implement an evolution strategy that is a special case of the REINFORCE-ES algorithm outlined earlier. In particular, <script type=\"math/tex\">\\sigma</script> is fixed to a constant number, and only the <script type=\"math/tex\">\\mu</script> parameter is updated at each generation. Below is how this strategy looks like, with a constant <script type=\"math/tex\">\\sigma</script> parameter:</p>\n\n<center>\n<table style=\"width:100%\">\n<tr>\n  <td>\n  <img src=\"/assets/20171031/schaffer/openes.gif\" width=\"100%\" />\n  </td>\n  <td>\n  <img src=\"/assets/20171031/rastrigin/oes.gif\" width=\"100%\" />\n  </td>\n</tr>\n</table>\n</center>\n\n<p>In addition to the simplification, this paper also proposed a modification of the update rule that is suitable for parallel computation across different worker machines. In their update rule, a large grid of random numbers have been pre-computed using a fixed seed.  By doing this, each worker can reproduce the parameters of every other worker over time, and each worker needs only to communicate a single number, the final fitness result, to all of the other workers. This is important if we want to scale evolution strategies to thousands or even a million workers located on different machines, since while it may not be feasible to transmit an entire solution vector a million times at each generation update, it may be feasible to transmit only the final fitness results. In the paper, they showed that by using 1440 workers on Amazon EC2 they were able to solve the Mujoco Humanoid walking task in ~ 10 minutes.</p>\n\n<p>I think in principle, this parallel update rule should work with the original algorithm where they can also adapt <script type=\"math/tex\">\\sigma</script>, but perhaps in practice, they wanted to keep the number of moving parts to a minimum for large-scale parallel computing experiments. This inspiring paper also discussed many other practical aspects of deploying ES for RL-style tasks, and I highly recommend going through it to learn more.</p>\n\n<h2 id=\"fitness-shaping\">Fitness Shaping</h2>\n\n<p>Most of the algorithms above are usually combined with a <em>fitness shaping</em> method, such as the rank-based fitness shaping method I will discuss here. Fitness shaping allows us to avoid outliers in the population from dominating the approximate gradient calculation mentioned earlier:</p>\n\n<script type=\"math/tex; mode=display\">\\nabla_{\\theta} J(\\theta) \\approx \\frac{1}{N} \\sum_{i=1}^{N} \\; F(z^i)  \\; \\nabla_{\\theta} \\log \\pi(z^i, \\theta).</script>\n\n<p>If a particular <script type=\"math/tex\">F(z^m)</script> is much larger than other <script type=\"math/tex\">F(z^i)</script> in the population, then the gradient might become dominated by this outliers and increase the chance of the algorithm being stuck in a local optimum. To mitigate this, one can apply a rank transformation of the fitness. Rather than use the actual fitness function, we would rank the results and use an augmented fitness function which is proportional to the solution’s rank in the population. Below is a comparison of what the original set of fitness may look like, and what the ranked fitness looks like:</p>\n<center>\n<img src=\"/assets/20171031/ranked_fitness.svg\" width=\"100%\" />\n</center>\n\n<p>What this means is supposed we have a population size of 101. We would evaluate each population to the actual fitness function, and then sort the solutions based by their fitness. We will assign an augmented fitness value of -0.50 to the worse performer, -0.49 to the second worse solution, …, 0.49 to the second best solution, and finally a fitness value of 0.50 to the best solution. This augmented set of fitness values will be used to calculate the gradient update, instead of the actual fitness values. In a way, it is a similar to just applying Batch Normalization to the results, but more direct. There are alternative methods for fitness shaping but they all basically give similar results in the end.</p>\n\n<p>I find fitness shaping to be very useful for RL tasks if the objective function is non-deterministic for a given policy network, which is often the cases on RL environments where maps are randomly generated and various opponents have random policies. It is less useful for optimising for well-behaved functions that are deterministic, and the use of fitness shaping can sometimes slow down the time it takes to find a good solution.</p>\n\n<h2 id=\"mnist\">MNIST</h2>\n\n<p>Although ES might be a way to search for more novel solutions that are difficult for gradient-based methods to find, it still vastly underperforms gradient-based methods on many problems where we can calculate high quality gradients. For instance, only an idiot would attempt to use a genetic algorithm for image classification. But sometimes <a href=\"https://blog.openai.com/nonlinear-computation-in-linear-networks/\">such people</a> do exist in the world, and sometimes these explorations can be fruitful!</p>\n\n<p>Since all ML algorithms should be tested on MNIST, I also tried to apply these various ES algorithms to find weights for a small, simple 2-layer convnet used to classify MNIST, just to see where we stand compared to SGD. The convnet only has ~ 11k parameters so we can accommodate the slower CMA-ES algorithm. The code and the experiments are available <a href=\"https://github.com/hardmaru/pytorch_notebooks/tree/master/mnist_es\">here</a>.</p>\n\n<!--\n______\n<code>class Net(nn.Module):</code><br/>\n<code>&nbsp;&nbsp;def __init__(self):</code><br/>\n<code>&nbsp;&nbsp;&nbsp;&nbsp;super(Net, self).__init__()</code>\n\n<code>&nbsp;&nbsp;&nbsp;&nbsp;self.num_filter1 = 8</code><br/>\n<code>&nbsp;&nbsp;&nbsp;&nbsp;self.num_filter2 = 16</code><br/>\n<code>&nbsp;&nbsp;&nbsp;&nbsp;self.num_padding = 2</code><br/>\n<code>&nbsp;&nbsp;&nbsp;&nbsp;self.filter_size = 5</code>\n\n<code>&nbsp;&nbsp;&nbsp;&nbsp;# input is 28x28</code><br/>\n<code>&nbsp;&nbsp;&nbsp;&nbsp;self.conv1 = nn.Conv2d(1,</code><br/>\n<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.num_filter1,</code><br/>\n<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.filter_size,</code><br/>\n<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;padding=self.num_padding)</code>\n\n<code>&nbsp;&nbsp;&nbsp;&nbsp;# feature map size is 14*14 by pooling</code><br/>\n<code>&nbsp;&nbsp;&nbsp;&nbsp;self.conv2 = nn.Conv2d(self.num_filter1,</code><br/>\n<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.num_filter2,</code><br/>\n<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.filter_size,</code><br/>\n<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;padding=self.num_padding)</code>\n\n<code>&nbsp;&nbsp;&nbsp;&nbsp;# feature map size is 7*7 by pooling</code><br/>\n<code>&nbsp;&nbsp;&nbsp;&nbsp;self.fc = nn.Linear(self.num_filter2*7*7, 10)</code>\n\n<code>&nbsp;&nbsp;def forward(self, x):</code><br/>\n<code>&nbsp;&nbsp;&nbsp;&nbsp;x = F.max_pool2d(F.relu(self.conv1(x)), 2)</code><br/>\n<code>&nbsp;&nbsp;&nbsp;&nbsp;x = F.max_pool2d(F.relu(self.conv2(x)), 2)</code><br/>\n<code>&nbsp;&nbsp;&nbsp;&nbsp;x = x.view(-1, self.num_filter2*7*7)</code><br/>\n<code>&nbsp;&nbsp;&nbsp;&nbsp;x = self.fc(x)</code><br/>\n<code>&nbsp;&nbsp;&nbsp;&nbsp;return F.log_softmax(x)</code>\n\n______\n-->\n<p>Below are the results for various ES methods, using a population size of 101, over 300 epochs. We keep track of the model parameters that performed best on the entire training set at the end of each epoch, and evaluate this model once on the test set after 300 epochs. It is interesting how sometimes the test set’s accuracy is higher than the training set for the models that have lower scores.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Method</th>\n      <th>Train Set</th>\n      <th>Test Set</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Adam (BackProp) Baseline</td>\n      <td>99.8</td>\n      <td>98.9</td>\n    </tr>\n    <tr>\n      <td>Simple GA</td>\n      <td>82.1</td>\n      <td>82.4</td>\n    </tr>\n    <tr>\n      <td>CMA-ES</td>\n      <td>98.4</td>\n      <td>98.1</td>\n    </tr>\n    <tr>\n      <td>OpenAI-ES</td>\n      <td>96.0</td>\n      <td>96.2</td>\n    </tr>\n    <tr>\n      <td>PEPG</td>\n      <td>98.5</td>\n      <td>98.0</td>\n    </tr>\n  </tbody>\n</table>\n\n<center>\n<img src=\"/assets/20171031/mnist_results.svg\" width=\"100%\" />\n</center>\n<p>We should take these results with a grain of salt, since they are based on a single run, rather than the average of 5-10 runs. The results based on a single-run seem to indicate that CMA-ES is the best at the MNIST task, but the PEPG algorithm is not that far off. Both of these algorithms achieved ~ 98% test accuracy, 1% lower than the SGD/ADAM baseline. Perhaps the ability to dynamically alter its covariance matrix, and standard deviation parameters over each generation allowed it to fine-tune its weights better than OpenAI’s simpler variation.</p>\n\n<h2 id=\"try-it-yourself\">Try It Yourself</h2>\n\n<p>There are probably open source implementations of all of the algorithms described in this article. The author of CMA-ES, Nikolaus Hansen, has been maintaining a numpy-based implementation of <a href=\"https://github.com/CMA-ES/pycma\">CMA-ES</a> with lots of bells and whistles. His python implementation introduced me to the training loop interface described earlier. Since this interface is quite easy to use, I also implemented the other algorithms such as Simple Genetic Algorithm, PEPG, and OpenAI’s ES using the same interface, and put it in a small python file called <code class=\"highlighter-rouge\">es.py</code>, and also wrapped the original CMA-ES library in this small library. This way, I can quickly compare different ES algorithms by just changing one line:</p>\n\n<hr />\n<p><code>import es</code></p>\n\n<p><code>#solver = es.SimpleGA(...)</code><br />\n<code>#solver = es.PEPG(...)</code><br />\n<code>#solver = es.OpenES(...)</code><br />\n<code>solver = es.CMAES(...)</code></p>\n\n<p><code>while True:</code></p>\n\n<p><code>&nbsp;&nbsp;solutions = solver.ask()</code></p>\n\n<p><code>&nbsp;&nbsp;fitness_list = np.zeros(solver.popsize)</code></p>\n\n<p><code>&nbsp;&nbsp;for i in range(solver.popsize):</code><br />\n<code>&nbsp;&nbsp;&nbsp;&nbsp;fitness_list[i] = evaluate(solutions[i])</code></p>\n\n<p><code>&nbsp;&nbsp;solver.tell(fitness_list)</code></p>\n\n<p><code>&nbsp;&nbsp;result = solver.result()</code></p>\n\n<p><code>&nbsp;&nbsp;if result[1] &gt; MY_REQUIRED_FITNESS:</code><br />\n<code>&nbsp;&nbsp;&nbsp;&nbsp;break</code></p>\n\n<hr />\n\n<p>You can look at <code class=\"highlighter-rouge\">es.py</code> on <a href=\"https://github.com/hardmaru/estool/blob/master/es.py\">GitHub</a> and the IPython notebook <a href=\"https://github.com/hardmaru/estool/blob/master/simple_es_example.ipynb\">examples</a> using the various ES algorithms.</p>\n\n<p>In this <a href=\"https://github.com/hardmaru/estool/blob/master/simple_es_example.ipynb\">IPython notebook</a> that accompanies <code class=\"highlighter-rouge\">es.py</code>, I show how to use the ES solvers in <code class=\"highlighter-rouge\">es.py</code> to solve a 100-Dimensional version of the Rastrigin function with even more local optimum points. The 100-D version is somewhat more challenging than the trivial 2D version used to produce the visualizations in this article. Below is a comparison of the performance for various algorithms discussed:</p>\n\n<center>\n<img src=\"/assets/20171031/rastrigin10d.svg\" width=\"100%\" />\n</center>\n\n<p>On this 100-D Rastrigin problem, none of the optimisers got to the global optimum solution, although CMA-ES comes close. CMA-ES blows everything else away. PEPG is in 2nd place, and OpenAI-ES / Genetic Algorithm falls behind. I had to use an annealing schedule to gradually lower <script type=\"math/tex\">\\sigma</script> for OpenAI-ES to make it perform better for this task.</p>\n<p></p>\n<center>\n<img src=\"/assets/20171031/rastrigin_cma_solution.png\" width=\"60%\" />\n<p></p>\n<i>Final solution that CMA-ES discovered for 100-D Rastrigin function.<br />Global optimal solution is a 100-dimensional vector of exactly 10.</i>\n</center>\n<p></p>\n\n<h2 id=\"whats-next\">What’s Next?</h2>\n\n<center>\n<blockquote class=\"twitter-video\" data-lang=\"en\"><p lang=\"en\" dir=\"ltr\">so proud of my little dude ... <a href=\"https://t.co/j5j61vQxP0\">pic.twitter.com/j5j61vQxP0</a></p>&mdash; hardmaru (@hardmaru) <a href=\"https://twitter.com/hardmaru/status/889265345172615168?ref_src=twsrc%5Etfw\">July 23, 2017</a></blockquote> <script async=\"\" src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script> \n</center>\n<p>\n</p>\n\n<p>In the <a href=\"/2017/11/12/evolving-stable-strategies/\">next article</a>, I will look at applying ES to other experiments and more interesting problems. Please <a href=\"/2017/11/12/evolving-stable-strategies/\">check</a> it out!</p>\n\n<h2 id=\"citation\">Citation</h2>\n\n<p>If you find this work useful, please cite it as:</p>\n\n<p><code>\n@article{ha2017visual,<br />\n&nbsp;&nbsp;title&nbsp;&nbsp;&nbsp;= \"A Visual Guide to Evolution Strategies\",<br />\n&nbsp;&nbsp;author&nbsp;&nbsp;= \"Ha, David\",<br />\n&nbsp;&nbsp;journal&nbsp;= \"blog.otoro.net\",<br />\n&nbsp;&nbsp;year&nbsp;&nbsp;&nbsp;&nbsp;= \"2017\",<br />\n&nbsp;&nbsp;url&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= \"https://blog.otoro.net/2017/10/29/visual-evolution-strategies/\"<br />\n}\n</code></p>\n\n<h2 id=\"references-and-other-links\">References and Other Links</h2>\n\n<p>Below are a few links to information related to evolutionary computing which I found useful or inspiring.</p>\n\n<p>Image Credits of <a href=\"https://www.reddit.com/r/CryptoMarkets/comments/6qpla3/investing_in_icos_results_may_vary/\">Lemmings Jumping off a Cliff</a>. Your results may vary when investing in ICOs.</p>\n\n<p>CMA-ES: <a href=\"https://github.com/CMA-ES\">Official Reference Implementation</a> on GitHub, <a href=\"https://arxiv.org/abs/1604.00772\">Tutorial</a>, Original CMA-ES <a href=\"http://www.cmap.polytechnique.fr/~nikolaus.hansen/cmaartic.pdf\">Paper</a> from 2001, Overview <a href=\"https://www.slideshare.net/OsamaSalaheldin2/cmaes-presentation\">Slides</a></p>\n\n<p><a href=\"https://www-anw.cs.umass.edu/~barto/courses/cs687/williams92simple.pdf\">Simple Statistical Gradient-Following Algorithms for Connectionist Reinforcement Learning</a> (REINFORCE), 1992.</p>\n\n<p><a href=\"https://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=A64D1AE8313A364B814998E9E245B40A?doi=10.1.1.180.7104&amp;rep=rep1&amp;type=pdf\">Parameter-Exploring Policy Gradients</a>, 2009.</p>\n\n<p><a href=\"https://www.jmlr.org/papers/volume15/wierstra14a/wierstra14a.pdf\">Natural Evolution Strategies</a>, 2014.</p>\n\n<p><a href=\"https://blog.openai.com/evolution-strategies/\">Evolution Strategies as a Scalable Alternative to Reinforcement Learning</a>, OpenAI, 2017.</p>\n\n<p>Risto Miikkulainen’s <a href=\"http://nn.cs.utexas.edu/downloads/slides/miikkulainen.ijcnn13.pdf\">Slides</a> on Neuroevolution.</p>\n\n<p>A Neuroevolution Approach to <a href=\"http://www.cs.utexas.edu/~ai-lab/?atari\">General Atari Game Playing</a>, 2013.</p>\n\n<p>Kenneth Stanley’s Talk on <a href=\"https://youtu.be/dXQPL9GooyI\">Why Greatness Cannot Be Planned: The Myth of the Objective</a>, 2015.</p>\n\n<p><a href=\"https://www.oreilly.com/ideas/neuroevolution-a-different-kind-of-deep-learning\">Neuroevolution</a>: A Different Kind of Deep Learning. The quest to evolve neural networks through evolutionary algorithms.</p>\n\n<p><a href=\"http://people.idsia.ch/~juergen/compressednetworksearch.html\">Compressed Network Search</a> Finds Complex Neural Controllers with a Million Weights.</p>\n\n<p>Karl Sims <a href=\"https://youtu.be/JBgG_VSP7f8\">Evolved Virtual Creatures</a>, 1994.</p>\n\n<p>Evolved <a href=\"https://youtu.be/euFvRfQRbLI\">Step Climbing</a> Creatures.</p>\n\n<p>Super Mario World Agent <a href=\"https://youtu.be/qv6UVOQ0F44\">Mario I/O</a>, Mario Kart 64 <a href=\"(https://github.com/nicknlsn/MarioKart64NEAT)\">Controller using</a> using <a href=\"https://www.cs.ucf.edu/~kstanley/neat.html\">NEAT Algorithm</a>.</p>\n\n<p><a href=\"http://www.bionik.tu-berlin.de/institut/xstart.htm\">Ingo Rechenberg</a>, the inventor of Evolution Strategies.</p>\n\n<p>A Tutorial on <a href=\"https://pablormier.github.io/2017/09/05/a-tutorial-on-differential-evolution-with-python/\">Differential Evolution</a> with Python.</p>\n\n<h3 id=\"my-previous-evolutionary-projects\">My Previous <em>Evolutionary</em> Projects</h3>\n\n<p><a href=\"https://deepmind.com/research/publications/pathnet-evolution-channels-gradient-descent-super-neural-networks/\">PathNet</a>: Evolution Channels Gradient Descent in Super Neural Networks</p>\n\n<p>Neural Network Evolution Playground with <a href=\"https://blog.otoro.net/2016/05/07/backprop-neat/\">Backprop NEAT</a></p>\n\n<p>Evolved Neural <a href=\"https://otoro.net/gallery\">Art Gallery</a> using <a href=\"https://otoro.net/neurogram/\">CPPN</a> Implementation</p>\n\n<p><a href=\"https://otoro.net/planks/\">Creatures Avoiding Planks</a></p>\n\n<p><a href=\"https://otoro.net/nabi/slimevolley/index.html\">Neural Slime Volleyball</a></p>\n\n<p>Evolution of <a href=\"https://otoro.net/ml/pendulum-esp/index.html\">Inverted Double Pendulum</a> Swing Up Controller</p>",
  "pubDate": "Sun, 29 Oct 2017 00:00:00 -0500"
}