{
  "title": "Learning Lean (Part 1)",
  "link": "",
  "published": "2022-07-04T14:35:00-05:00",
  "updated": "2022-07-04T14:35:00-05:00",
  "author": {
    "name": "Brandon Brown"
  },
  "id": "tag:outlace.com,2022-07-04:/Lean_part_1.html",
  "summary": "<p>An introduction to functional programming and mathematics in the dependently-typed functional programming language and theorem prover Lean 4.</p>",
  "content": "<p>I'm going to be starting a series of blog posts on Lean 4, a dependently typed functional programming language and theorem prover. If none of that sounds familiar, no problem, we'll get to that. First, Lean 4 has not been officially released as a 1.0, so breaking changes to the code in these posts may occur, but I'll try to update from time to time. The current stable release of Lean is Lean 3.</p>\n<p>Let me also preface that these blog posts, although meant to be instructive, mirror my own learning of Lean. I've been playing with Lean off and on since April 2020 but I am currently <em>not</em> an expert at Lean or functional programming in general, so there are likely going to be instances of me writing non-idiomatic Lean and doing things in not the most efficient way.  Also, my goal in learning Lean was mostly to learn formalizing mathematics rather than functional programming, so these blogs will hence be mostly focused on the mathematics use of Lean. In terms of pre-requisites if you want to be able to follow along, anyone with a background programming in <em>some</em> programming language and at least a high school mathematics background should be able to follow along.</p>\n<p>Go ahead and get Lean installed by following the guide here: <a href=\"https://leanprover.github.io/lean4/doc/quickstart.html\">Lean Setup Guide</a>.</p>\n<p>There's also a lively online community for Lean where friendly individuals from around the world will answer your questions surprisingly quickly: <a href=\"https://leanprover.zulipchat.com/\">https://leanprover.zulipchat.com/</a></p>\n<h3>What is Lean?</h3>\n<p>Lean is a programming language. More specifically, Lean is a functional programming language. Probably the most well-known (at least to me) functional programming language is Haskell. A functional programming language usually refers to a <strong><em>purely</em></strong> functional programming language. Many programming languages support functions as first-class citizens, allowing functions to be passed as arguments and returned, but a purely functional language imposes that all functions have a well-specified and static type signature and no other side effects can occur within a function (e.g. writing to disk, playing a sound file, etc.). These are called pure functions. Moreover, the only data these pure functions have access to is what gets explicitly passed as an argument. And every expression in Lean has a type, including types themselves.</p>\n<p>The mandate that all functions are pure is quite onerous coming from typical imperative programming languages such as C or Python. It is no longer trivial in a pure functional language to do something like read an input string, do some computation, write to a log and return a value. The benefit is that pure functions are completely predictable at compile-time, preventing a whole class of bugs.</p>\n<p>Lean is not only a functional programming language, but a dependently-typed functional programming language. This means that types can depend on other types and values. For example, in Lean, you can define a type of list of integers of length 3, and thus if you try to construct an instance of that type by giving it 4 integers, it will fail. In essence, dependent types give you extreme expressiveness and granularity when defining new types.</p>\n<h3>Why should you learn Learn?</h3>\n<p>I think Lean is going to be <em>the next big thing</em> in the functional programming world and hopefully the formal software verification and mathematics world. So if any of those things interest you, it may be worth learning Lean.</p>\n<p>One goal for me in learning Lean is to learn proofs in mathematics. I do data analysis, statistics and machine learning so my understanding of mathematics is very applied and calculational. I want to get a flavor of pure mathematics and how mathematical structures are made and theorems are proved. Because Lean is a dependently typed pure functional programming language, it can be used to encode all of modern mathematics using its type theory in place of traditional set theory.</p>\n<p>In any case, doing math in Lean is actually <em>fun</em> a lot of the time. It's like a programming and logic puzzle. So stop with the Sudoku and just prove theorems in Lean instead.</p>\n<h3>Natural Numbers</h3>\n<p>Before we can do much of anything in mathematics, we're going to need some numbers. Now Lean already has numbers defined, of course, but we will pretend it doesn't.</p>\n<p>Let's define the natural numbers, that is, the set of numbers 0, 1, 2, 3 ..., or the counting numbers.</p>\n<div class=\"highlight\"><pre><span></span><code><span class=\"nf\">namespace</span> <span class=\"kt\">Tutorial</span>\n\n<span class=\"nf\">inductive</span> <span class=\"kt\">Nat</span> <span class=\"kt\">:</span> <span class=\"kt\">Type</span> <span class=\"kr\">where</span> \n<span class=\"o\">|</span> <span class=\"n\">zero</span> <span class=\"kt\">:</span> <span class=\"kt\">Nat</span>\n<span class=\"o\">|</span> <span class=\"n\">succ</span> <span class=\"kt\">:</span> <span class=\"kt\">Nat</span> <span class=\"err\">→</span> <span class=\"kt\">Nat</span>\n\n<span class=\"nf\">end</span> <span class=\"kt\">Tutorial</span>\n</code></pre></div>\n\n<p>The namespace section is what it sounds like and works similarly to how namespaces work in other programming languages. Outside the namespace you have to refer to identifiers inside the namespace by prefixing <code>[namespace name].[identifier]</code> (without the brackets). We enclose our code in this namespace to avoid name clashes because we are defining types and functions that already exist in Lean with the same names.</p>\n<p>First, the keyword <code>inductive</code> means we are defining a new (inductive) type. In Lean's type theory, there are basically just two kinds of types, inductive types and function types, so we will use <strong><em>inductive</em></strong> a lot.</p>\n<p>After the keyword <code>inductive</code> comes the name of the type we are defining, in this case, we are calling it <code>Nat</code>, for natural numbers. After the name of the type comes a colon and the keyword <code>Type</code>. </p>\n<p>Recall, <em>every expression in Lean must have a type</em>, even the new type we are defining must itself be assigned a type. So in general, new inductive types will by default be assigned the type <code>Type</code>, which is an alias for <code>Type 0</code>, because if you ask Lean what the type of <code>Type</code> is, it must give you an answer, so it just creates an infinite hierarchy of types <code>Type : Type 1, Type 1 : Type 2</code> etc., meaning that the type of <code>Type</code> is <code>Type 1</code>.</p>\n<p>You can ask Lean what the type of an expression is by using the <code>#check</code> command.</p>\n<div class=\"highlight\"><pre><span></span><code><span class=\"o\">#</span><span class=\"n\">check</span> <span class=\"kt\">Nat</span>\n<span class=\"c1\">--Output: Nat : Type</span>\n<span class=\"o\">#</span><span class=\"n\">check</span> <span class=\"kt\">Type</span>\n<span class=\"c1\">--Output: Type : Type 1</span>\n</code></pre></div>\n\n<p>Now Lean tries to be smart and save you keystokes, so whenever possible, it will infer types when it can do so unambiguously. So it is fine to also declare our <code>Nat</code> type without explicitly assigning its type:</p>\n<div class=\"highlight\"><pre><span></span><code><span class=\"c1\">-- This also works</span>\n<span class=\"nf\">inductive</span> <span class=\"kt\">Nat</span> <span class=\"kr\">where</span>\n<span class=\"o\">|</span> <span class=\"n\">zero</span> <span class=\"kt\">:</span> <span class=\"kt\">Nat</span>\n<span class=\"o\">|</span> <span class=\"n\">succ</span><span class=\"kt\">:</span> <span class=\"kt\">Nat</span> <span class=\"err\">→</span> <span class=\"kt\">Nat</span>\n</code></pre></div>\n\n<p>And two dashes is how you start a comment line. Or a multiline comment can be delimited using </p>\n<div class=\"highlight\"><pre><span></span><code>/-\nMulti\nline \ncomment\n-/\n</code></pre></div>\n\n<p>Back to our new type.</p>\n<div class=\"highlight\"><pre><span></span><code><span class=\"nf\">inductive</span> <span class=\"kt\">Nat</span> <span class=\"kt\">:</span> <span class=\"kt\">Type</span> <span class=\"kr\">where</span> \n<span class=\"o\">|</span> <span class=\"n\">zero</span> <span class=\"kt\">:</span> <span class=\"kt\">Nat</span>\n<span class=\"o\">|</span> <span class=\"n\">succ</span> <span class=\"kt\">:</span> <span class=\"kt\">Nat</span> <span class=\"err\">→</span> <span class=\"kt\">Nat</span>\n</code></pre></div>\n\n<p>After assigning <code>Nat</code> as being the type <code>Type</code> is the keyword <code>where</code> which is also optional, as this is also valid:</p>\n<div class=\"highlight\"><pre><span></span><code><span class=\"nf\">inductive</span> <span class=\"kt\">Nat</span> \n<span class=\"o\">|</span> <span class=\"n\">zero</span> <span class=\"kt\">:</span> <span class=\"kt\">Nat</span>\n<span class=\"o\">|</span> <span class=\"n\">succ</span> <span class=\"kt\">:</span> <span class=\"kt\">Nat</span> <span class=\"err\">→</span> <span class=\"kt\">Nat</span>\n</code></pre></div>\n\n<p>I guess <code>where</code> is mostly of descriptive use, as you can translate the type declaration into English as \"We are making a new inductive type named <code>Nat</code> of type <code>Type</code> where <code>zero</code> is declared to be of type <code>Nat</code> and <code>succ</code> is a function that maps values of type <code>Nat</code> to values of type <code>Nat</code>.</p>\n<p>Back to the more verbose type declaration:</p>\n<div class=\"highlight\"><pre><span></span><code><span class=\"nf\">inductive</span> <span class=\"kt\">Nat</span> <span class=\"kt\">:</span> <span class=\"kt\">Type</span> <span class=\"kr\">where</span> \n<span class=\"o\">|</span> <span class=\"n\">zero</span> <span class=\"kt\">:</span> <span class=\"kt\">Nat</span>\n<span class=\"o\">|</span> <span class=\"n\">succ</span> <span class=\"kt\">:</span> <span class=\"kt\">Nat</span> <span class=\"err\">→</span> <span class=\"kt\">Nat</span>\n</code></pre></div>\n\n<p>So after the <code>where</code> keyword, we start a new line beginning with the pipe <code>|</code> character. Each line beginning with <code>|</code> is called a <em>constructor</em> since these lines specify how to construct terms (aka elements, values or members) of the new inductive type.</p>\n<p>First, we invent a name for a value of type <code>Nat</code>, in this case I am declaring that the string of characters <code>zero</code> is hereby defined to be a term (or value) of type <code>Nat</code>. </p>\n<p>We could stop here and we'd have a new (inductive) type with a single value, but that wouldn't help us create numbers, which we expect to be indefinite (infinite).</p>\n<p>Next, we start a new line beginning with a pipe, and this time instead of declaring a new term of type <code>Nat</code>, we declare the first function that operates on terms of type <code>Nat</code>. We call this function <code>succ</code> (short for successor). We know that <code>succ</code> is a function and not a term because we assign it the type <code>Nat → Nat</code> after the colon. Whenever you see the pattern <em>some type</em> → <em>some type</em>, you're looking at a function type. </p>\n<p>Functions are programs that map terms from one type to another (or the same) type. In this case, <code>succ</code> is a function that does not compute anything, in fact it doesn't do anything at all. All we can do with it is <strong><em>apply</em></strong> it.</p>\n<div class=\"highlight\"><pre><span></span><code><span class=\"o\">#</span><span class=\"n\">check</span> <span class=\"kt\">Nat</span><span class=\"o\">.</span><span class=\"n\">succ</span> <span class=\"p\">(</span><span class=\"kt\">Nat</span><span class=\"o\">.</span><span class=\"n\">succ</span> <span class=\"kt\">Nat</span><span class=\"o\">.</span><span class=\"n\">zero</span><span class=\"p\">)</span>\n<span class=\"c1\">--- Output: Nat.succ (Nat.succ Nat.zero) : Nat</span>\n</code></pre></div>\n\n<p>As you can see, we apply a function by putting the function name, a space, and then the term (value). To avoid ambiguity we must use parentheses when applying multiple times. Declaring the type <code>Nat</code> creates a local namespace <code>Nat</code> so we must prefix references to the value <code>zero</code> or function <code>succ</code> with <code>Nat.</code> e.g. <code>Nat.zero</code></p>\n<p>We can save keystokes by opening the namespace.</p>\n<div class=\"highlight\"><pre><span></span><code><span class=\"nf\">open</span> <span class=\"kt\">Nat</span>\n<span class=\"c1\">--- Now we can do this</span>\n<span class=\"o\">#</span><span class=\"n\">check</span> <span class=\"n\">succ</span> <span class=\"p\">(</span><span class=\"n\">succ</span> <span class=\"n\">zero</span><span class=\"p\">)</span>\n<span class=\"c1\">--- Output: succ (succ zero) : Nat</span>\n</code></pre></div>\n\n<p>Now we have defined the natural numbers, 0, 1, 2, ... and so on, identified in our new type as <code>zero, succ (zero), succ (succ (zero))</code>. Obviously writing numbers using function application is not as convenient as using our normal numerals 1, 2 etc. There is a way to map numerals to our more verbose natural numbers, but we will wait awhile before doing that.</p>\n<p>When I first understood what was going on here in this very simple inductive type, it was quite profound. By declaring this empty function <code>succ</code> and applying it to the only \"real\" term of type <code>Nat</code>, we get an infinite new set of terms of type <code>Nat</code>. Any string of characters that fits the pattern <code>succ x</code> where <code>x</code> is either <code>zero</code> or also of the pattern <code>succ (succ ... zero )</code> is also of type <code>Nat</code>.</p>\n<p>You can think of types as specifiying a pattern of characters, a type-checker as checking whether some expression matches a particular pattern, and a value or term is just an expression that matches a particular type pattern. So <code>succ (succ zero)</code> is of type <code>Nat</code> because that pattern of characters matches the pattern we defined as type <code>Nat</code>.</p>\n<p>Let's define our first function on our new <code>Nat</code> type. In Lean, all functions are pure as we discussed earlier, and they are also <em>total</em>. A total function is one where every possible input term gets mapped to an output term. That means for a function of type <code>Nat → Nat</code>, every natural number must get mapped to some output term that is also a natural number. You cannot have input terms that are left undefined. In mathematics, if we treat division as a function, we say that <span class=\"math\">\\(\\frac{x}{0}\\)</span> is <em>undefined</em>. In Lean, that is not acceptable, even <span class=\"math\">\\(\\frac{x}{0}\\)</span> is defined.</p>\n<p>Total functions can sometimes be an onerous constraint when using Lean for non-mathematical purposes, especially as you have to prove to Lean that your function is total, so Lean does provide a way to define <em>partial</em> functions, but we will not address that yet.</p>\n<p>Here's our first function:</p>\n<div class=\"highlight\"><pre><span></span><code><span class=\"nf\">def</span> <span class=\"n\">natId</span> <span class=\"kt\">:</span> <span class=\"kt\">Nat</span> <span class=\"err\">→</span> <span class=\"kt\">Nat</span> <span class=\"kt\">:=</span> <span class=\"n\">fun</span> <span class=\"n\">x</span> <span class=\"kt\">:</span> <span class=\"kt\">Nat</span> <span class=\"ow\">=&gt;</span> <span class=\"n\">x</span>\n</code></pre></div>\n\n<p>First we define a new function using the <code>def</code> keyword, then the name of our function, in this case we're calling it <code>natId</code>, then we have a colon, which indicates we're going to be assigning a type and after the colon we have the type <code>Nat → Nat</code>. Following that, we have the symbol <code>:=</code> which is an assignment operator, and then we have the body of the function which is <code>fun x : Nat =&gt; x</code></p>\n<p>This last part is called an anonymous function (or lambda function). An anonymous function is a function expression without giving it a name. As is clear, an anonymous function is declared using the <code>fun</code> keyword, following by an identifier (can be more than one) representing the input, then its type annotation, then the <code>=&gt;</code> symbol following by the function body, which in this case just returns the input <code>x</code>, and hence this is defining the identity function that does nothing but return its input unadulterated.</p>\n<p>One challenge when getting started with Lean is that Lean has a lot of syntactic sugar, so there are often multiple ways to express the same thing. Here are 3 other ways we could have defined the same identity function:</p>\n<div class=\"highlight\"><pre><span></span><code><span class=\"nf\">def</span> <span class=\"n\">natId2</span> <span class=\"kt\">:</span> <span class=\"kt\">Nat</span> <span class=\"err\">→</span> <span class=\"kt\">Nat</span> <span class=\"kt\">:=</span>\n    <span class=\"n\">fun</span> <span class=\"n\">a</span> <span class=\"ow\">=&gt;</span>\n        <span class=\"n\">match</span> <span class=\"n\">a</span> <span class=\"n\">with</span>\n            <span class=\"o\">|</span> <span class=\"n\">a</span> <span class=\"ow\">=&gt;</span> <span class=\"n\">a</span>\n</code></pre></div>\n\n<p>And:</p>\n<div class=\"highlight\"><pre><span></span><code><span class=\"nf\">def</span> <span class=\"n\">natId3</span> <span class=\"kt\">:</span> <span class=\"kt\">Nat</span> <span class=\"err\">→</span> <span class=\"kt\">Nat</span>\n<span class=\"o\">|</span> <span class=\"n\">a</span> <span class=\"ow\">=&gt;</span> <span class=\"n\">a</span>\n</code></pre></div>\n\n<p>And:</p>\n<div class=\"highlight\"><pre><span></span><code><span class=\"nf\">def</span> <span class=\"n\">natId4</span> <span class=\"p\">(</span><span class=\"n\">a</span> <span class=\"kt\">:</span> <span class=\"kt\">Nat</span><span class=\"p\">)</span> <span class=\"kt\">:</span> <span class=\"kt\">Nat</span> <span class=\"kt\">:=</span> <span class=\"n\">a</span>\n</code></pre></div>\n\n<p>The first of these alternatives also uses an anonymous function but then has a <code>match ... with</code> pattern. As we discussed, inductive types are essentially defined as a set of base terms and then one or more functions that define a pattern for creating other terms of that type using the base terms. So since we construct types by defining base terms and patterns over those base terms, we also define functions on types by deconstructing types into their base terms and patterns over those base terms, and then map each deconstructed pattern into terms of another type.</p>\n<p>Notice that the variable <code>a</code> after <code>fun</code> represents the input term and we can name it whatever we want. For multiple input functions we will have to introduce multiple input variables after <code>fun</code>.</p>\n<p>Also we can check how Lean actually defines types by using the <code>#print</code> command. Let's check the last of these alternatives for <code>idNat4</code></p>\n<div class=\"highlight\"><pre><span></span><code><span class=\"o\">#</span><span class=\"n\">print</span> <span class=\"n\">natId4</span>\n\n<span class=\"o\">/-</span>    \n<span class=\"kt\">Output:</span> \n<span class=\"nf\">def</span> <span class=\"kt\">Tutorial</span><span class=\"o\">.</span><span class=\"n\">natId4</span> <span class=\"kt\">:</span> <span class=\"kt\">Nat</span> <span class=\"err\">→</span> <span class=\"kt\">Nat</span> <span class=\"kt\">:=</span> <span class=\"n\">fun</span> <span class=\"n\">a</span> <span class=\"ow\">=&gt;</span> <span class=\"n\">a</span>   \n<span class=\"o\">-/</span>\n</code></pre></div>\n\n<p>As you can see, even though Lean lets us omit the explicit anonymous function, behind the scenes it is filling in the anonymous function for us.</p>\n<p>Okay, moving on. Let's write a simple function that just subtracts one from any natural number.</p>\n<div class=\"highlight\"><pre><span></span><code><span class=\"nf\">def</span> <span class=\"n\">subOne</span> <span class=\"kt\">:</span> <span class=\"kt\">Nat</span> <span class=\"err\">→</span> <span class=\"kt\">Nat</span> <span class=\"kt\">:=</span>\n  <span class=\"n\">fun</span> <span class=\"n\">a</span> <span class=\"ow\">=&gt;</span>\n    <span class=\"n\">match</span> <span class=\"n\">a</span> <span class=\"n\">with</span>\n    <span class=\"o\">|</span> <span class=\"n\">zero</span> <span class=\"ow\">=&gt;</span> <span class=\"n\">zero</span>\n    <span class=\"o\">|</span> <span class=\"n\">succ</span> <span class=\"n\">b</span> <span class=\"ow\">=&gt;</span> <span class=\"n\">b</span>\n</code></pre></div>\n\n<p>We define a function called <code>subOne</code> with the type <code>Nat → Nat</code>. We implement the function by assigning it to an anonymous function that takes an input variable <code>a</code> (which must be of type <code>Nat</code> according to the function type signature) and matches it against the patterns that a term of type <code>Nat</code> can have, namely it can either be the base term <code>zero</code> or of the pattern <code>succ b</code> where <code>b</code> is just a placeholder for whatever is inside the <code>succ</code> function. We could have also used <code>a</code> in place of <code>b</code> and Lean is smart enough to figure out what we mean based on the context.</p>\n<p>If the input <code>a</code> happens to be <code>zero</code> then we just return <code>zero</code> since natural numbers don't get any lower than <code>zero</code>. If the input <code>a</code> happens to be <code>succ b</code> with <code>b</code> being a term of type <code>Nat</code> then we return <code>b</code>, which effectively removes one application of <code>succ</code> and thus decrements the number by one.</p>\n<p>There are no other possible patterns that a term of type <code>Nat</code> could be and since we covered them in our function pattern match, Lean is satisfied our function is total.</p>\n<p>We can ask Lean to evaluate our function on the input <code>zero.succ.succ</code> (the number 2) by using the <code>#reduce</code> command.</p>\n<div class=\"highlight\"><pre><span></span><code><span class=\"o\">#</span><span class=\"n\">reduce</span> <span class=\"n\">subOne</span> <span class=\"n\">zero</span><span class=\"o\">.</span><span class=\"n\">succ</span><span class=\"o\">.</span><span class=\"n\">succ</span>\n<span class=\"c1\">--Output: succ zero</span>\n</code></pre></div>\n\n<p>It works, if we subtract one from 2 we get 1. Notice that the expression <code>zero.succ.succ</code> is equivalent to <code>succ (succ zero)</code> but easier to read as it avoids parentheses. Again, this is one challenge in learning Lean; there are many ways to do the same thing. But ultimately these are ways to save keystrokes and improve readability, at the expense of taking longer to learn.</p>\n<p>We can also write a function where we explicitly name the inputs and then pattern match on them:</p>\n<div class=\"highlight\"><pre><span></span><code><span class=\"nf\">def</span> <span class=\"n\">subOne</span> <span class=\"p\">(</span><span class=\"n\">a</span> <span class=\"kt\">:</span> <span class=\"kt\">Nat</span><span class=\"p\">)</span> <span class=\"kt\">:</span> <span class=\"kt\">Nat</span> <span class=\"kt\">:=</span>\n  <span class=\"n\">match</span> <span class=\"n\">a</span> <span class=\"n\">with</span>\n  <span class=\"o\">|</span> <span class=\"n\">zero</span> <span class=\"ow\">=&gt;</span> <span class=\"n\">zero</span>\n  <span class=\"o\">|</span> <span class=\"n\">succ</span> <span class=\"n\">b</span> <span class=\"ow\">=&gt;</span> <span class=\"n\">b</span>\n</code></pre></div>\n\n<p>In this style we name the inputs and annotate their types and then we give the output type after the last free colon.</p>\n<p>Now let's define the addition function on natural numbers.</p>\n<div class=\"highlight\"><pre><span></span><code><span class=\"nf\">def</span> <span class=\"n\">add</span> <span class=\"p\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"kt\">:</span> <span class=\"kt\">Nat</span><span class=\"p\">)</span> <span class=\"kt\">:</span> <span class=\"kt\">Nat</span> <span class=\"kt\">:=</span>\n  <span class=\"n\">match</span> <span class=\"n\">b</span> <span class=\"n\">with</span>\n  <span class=\"o\">|</span> <span class=\"n\">zero</span> <span class=\"ow\">=&gt;</span> <span class=\"n\">a</span>\n  <span class=\"o\">|</span> <span class=\"n\">succ</span> <span class=\"n\">c</span> <span class=\"ow\">=&gt;</span> <span class=\"n\">succ</span> <span class=\"p\">(</span><span class=\"n\">add</span> <span class=\"n\">a</span> <span class=\"n\">c</span><span class=\"p\">)</span>\n</code></pre></div>\n\n<p>We define our function <code>add</code> to take two inputs named <code>a</code> and <code>b</code> and both are of type <code>Nat</code> so we include them together separated by a space. The output type of our function is also of type <code>Nat</code>. We then match the pattern of input <code>b</code> to define the computation of the function.</p>\n<p>If the second input <code>b</code> is zero, then that means we are dealing with <code>a + 0</code> and that obviously just equals <code>a</code>, so we return <code>a</code>. </p>\n<p>If <code>b</code> is greater than 0, i.e. of the form <code>succ c</code> where <code>c</code> is another natural number, then we add together <code>a</code> and <code>c</code> (and <code>c = b - 1</code>), then we apply <code>succ</code> to the result, which is the same as adding one.</p>\n<p>In other words, we are recursively doing <code>1 + (a + (b - 1))</code>. Because we are in a purely functional programming language, we do not have access to things like <code>for</code> loops or <code>while</code> loops. Any iterative computations must be done using recursive (self-referential) function calls.</p>\n<p>When we compute <code>1 + (a + (b - 1))</code>, Lean will then call the <code>add</code> function again, with input <code>a</code> (the same as the original input <code>a</code>), and the second input will be <code>b - 1</code>. It keeps recursively calling itself until <code>b - 1 = 0</code> and then we hit the base case where the second input is <code>0</code> and <code>add</code> just returns the first input <code>a</code>.</p>\n<div class=\"highlight\"><pre><span></span><code><span class=\"o\">#</span><span class=\"n\">reduce</span> <span class=\"n\">add</span> <span class=\"n\">zero</span><span class=\"o\">.</span><span class=\"n\">succ</span> <span class=\"n\">zero</span><span class=\"o\">.</span><span class=\"n\">succ</span>\n<span class=\"c1\">--Output: succ (succ zero)</span>\n</code></pre></div>\n\n<p>As you can see, our function successfully computes <code>1 + 1 = 2</code>. Let's do it by hand to make sure we really understand what is going on.</p>\n<p>First,\n<code>add zero.succ zero.succ</code> (again, this represents <code>1 + 1</code>)\nwill pattern match on the second argument <code>b = zero.succ</code>, so it will return <code>succ (add zero.succ zero)</code> since the pattern match will \"pull off\" a <code>succ</code> from the input <code>b</code>.</p>\n<p>So now we're calling <code>add</code> within itself, namely <code>add zero.succ zero</code> (<code>1 + 0</code>). Now again, we pattern match on the second input <code>b = zero</code> and that matches the base case where we just return <code>a</code>. So <code>add zero.succ zero = zero.succ</code>. </p>\n<p>Now we substitute that into the expression above, <code>succ (add zero.succ zero)</code>, so we get <code>succ (succ zero)</code>, which is the final answer. So the <code>add</code> function works by recursively decrementing <code>b</code> by 1 while adding 1 to <code>a</code> until <code>b = 0</code>.</p>\n<p>In order for functions to be total (as described above), they need to be terminating. Lean has a component called a <strong>termination checker</strong> that makes sure every function you define will terminate in a finite number of steps. It does this by making sure that when you're recursively calling a function that the input arguments are <strong><em>structurally decreasing</em></strong>. In the case of the <code>add</code> function, the second input <code>b</code> will structurally decrease each recursive call of <code>add</code> because a <code>succ</code> is \"pulled off\" (i.e. <code>b</code> becomes <code>b - 1</code> each call). Once <code>b = zero</code> in the recursive calls then the function terminates.</p>\n<p>We'll end this post here, but we have a lot more to learn. In the next post we'll prove our first theorems about the natural numbers and learn a lot more Lean along the way.</p>\n<p>PS: My goal with these <em>Learning Lean</em> posts are to assume as few pre-requisites as possible, so please leave a comment or email me if anything needs additional explanation and you meet the pre-requisites of knowing how to program in some language and having a high school math background.</p>\n<script type=\"text/javascript\">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {\n    var align = \"center\",\n        indent = \"0em\",\n        linebreak = \"false\";\n\n    if (false) {\n        align = (screen.width < 768) ? \"left\" : align;\n        indent = (screen.width < 768) ? \"0em\" : indent;\n        linebreak = (screen.width < 768) ? 'true' : linebreak;\n    }\n\n    var mathjaxscript = document.createElement('script');\n    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';\n    mathjaxscript.type = 'text/javascript';\n    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';\n\n    var configscript = document.createElement('script');\n    configscript.type = 'text/x-mathjax-config';\n    configscript[(window.opera ? \"innerHTML\" : \"text\")] =\n        \"MathJax.Hub.Config({\" +\n        \"    config: ['MMLorHTML.js'],\" +\n        \"    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } },\" +\n        \"    jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" +\n        \"    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" +\n        \"    displayAlign: '\"+ align +\"',\" +\n        \"    displayIndent: '\"+ indent +\"',\" +\n        \"    showMathMenu: true,\" +\n        \"    messageStyle: 'normal',\" +\n        \"    tex2jax: { \" +\n        \"        inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" +\n        \"        displayMath: [ ['$$','$$'] ],\" +\n        \"        processEscapes: true,\" +\n        \"        preview: 'TeX',\" +\n        \"    }, \" +\n        \"    'HTML-CSS': { \" +\n        \"        availableFonts: ['STIX', 'TeX'],\" +\n        \"        preferredFont: 'STIX',\" +\n        \"        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" +\n        \"        linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" +\n        \"    }, \" +\n        \"}); \" +\n        \"if ('default' !== 'default') {\" +\n            \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" +\n                \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" +\n                \"VARIANT['normal'].fonts.unshift('MathJax_default');\" +\n                \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" +\n                \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" +\n                \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" +\n            \"});\" +\n            \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" +\n                \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" +\n                \"VARIANT['normal'].fonts.unshift('MathJax_default');\" +\n                \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" +\n                \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" +\n                \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" +\n            \"});\" +\n        \"}\";\n\n    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);\n    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);\n}\n</script>",
  "category": [
    "",
    ""
  ]
}