{
  "title": "Yet Another Game Of Life",
  "link": "https://datasciencelab.wordpress.com/2014/01/03/yet-another-game-of-life/",
  "comments": "https://datasciencelab.wordpress.com/2014/01/03/yet-another-game-of-life/#respond",
  "dc:creator": "datasciencelab",
  "pubDate": "Fri, 03 Jan 2014 17:18:09 +0000",
  "category": [
    "Experiments",
    "animations",
    "automata",
    "game of life",
    "matplotlib",
    "video"
  ],
  "guid": "http://datasciencelab.wordpress.com/?p=484",
  "description": "The famous Game of Life, devised by mathematician John Conway about four decades ago, is the best-known example of a cellular automaton. It has probably been coded up in every possible computer language about a million times by now, as evidenced by this plethora of examples. I was introduced to the rules of the game [&#8230;]",
  "content:encoded": "<p>The famous Game of Life, devised by mathematician <a href=\"http://www.conwaylife.com/wiki/John_Horton_Conway\">John Conway</a> about four decades ago, is the best-known example of a cellular automaton. It has probably been coded up in every possible computer language about a million times by now, as evidenced <a href=\"http://rosettacode.org/wiki/Conway's_Game_of_Life\">by this plethora of examples</a>. I was introduced to the rules of the game already 15 years ago during my first year in college, and became immediately fascinated by the complexity and beauty of some of the emerging patterns. At that time I implemented it in C, and soon forgot about it. This is already a very good reason to revisit the game, its rules, and to show animations produced with matplotlib in python. Let&#8217;s go!</p>\n<h3>Rules of Conway&#8217;s game of life</h3>\n<p>As per <a href=\"https://en.wikipedia.org/wiki/Conway's_Game_of_Life#Rules\">Wikipedia</a>, the universe of the Game of Life is an infinite two-dimensional grid of square cells, each of which is in one of two possible states, alive or dead. Every cell interacts with its eight neighbors, which are the cells that are horizontally, vertically, or diagonally adjacent. At each step in time, the following transitions occur:</p>\n<ol>\n<li>Any live cell with fewer than two live neighbors dies, as if caused by under-population.</li>\n<li>Any live cell with two or three live neighbors lives on to the next generation.</li>\n<li>Any live cell with more than three live neighbors dies, as if by overcrowding.</li>\n<li>Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.</li>\n</ol>\n<h3>Yet another python implementation of Life</h3>\n<p>Our python implementation will use a two-dimensional numpy array to store the grid representing the universe, with values 1 for live and 0 for dead cells. We will code a <code>init</code> function for the initialization of the grid and a <code>evolve</code> routine for the evolution of the universe. A very simple way of initializing the grid to random values, allowing for variable grid dimensions, is as follows: </p>\n<pre class=\"brush: python; title: ; notranslate\">\ndef init_universe(rows, cols):\n    grid = np.zeros([rows, cols])\n    for i in range(rows):\n        for j in range(cols):\n            grid[i][j] = round(random.random())\n    return grid\n</pre>\n<p><a href=\"https://datasciencelab.files.wordpress.com/2014/01/random_universe.png\"><img src=\"https://datasciencelab.files.wordpress.com/2014/01/random_universe.png?w=200&#038;h=135\" alt=\"random_universe\" width=\"200\" height=\"135\" class=\"alignright\" /></a><br />\nAn example of a random universe created with the <code>init_universe(rows, cols)</code> function with 600 cells distributed in 20 rows and 30 columns can be seen in the figure on the right. The call to generate the figure, with black cells representing live (or 1) states, is as follows:</p>\n<pre class=\"brush: python; title: ; notranslate\">\ngrid = init_universe(20,30)\nax = plt.axes()\nax.matshow(grid,cmap=cm.binary)\nax.set_axis_off()\n</pre>\n<p>Now, for the evolution logic, let us code a function that takes a universe as input, together with the parameters that regulate its evolution, and outputs the new universe after one iteration. The classical rules of the game of life set the parameters for overcrowding, under-population and reproduction as 3, 2, 3, respectively. In our implementation, we create a padding around the original universe, which allows us to define the neighbors in an easy way without having to worry whether a particular cell is at the border or not. At every position <em>i,j</em> we compute the sum of all cells in positions <img src=\"https://s0.wp.com/latex.php?latex=%5Bi-1%2C+i%2C+i%2B1%5D+%5Ctimes+%5Bj-1%2C+j%2C+j%2B1%5D&#038;bg=ffffff&#038;fg=000000&#038;s=0&#038;c=20201002\" srcset=\"https://s0.wp.com/latex.php?latex=%5Bi-1%2C+i%2C+i%2B1%5D+%5Ctimes+%5Bj-1%2C+j%2C+j%2B1%5D&#038;bg=ffffff&#038;fg=000000&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=%5Bi-1%2C+i%2C+i%2B1%5D+%5Ctimes+%5Bj-1%2C+j%2C+j%2B1%5D&#038;bg=ffffff&#038;fg=000000&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x\" alt=\"[i-1, i, i+1] &#92;times [j-1, j, j+1]\" class=\"latex\" /> and then we subtract the center point at <em>i,j</em>. Then we apply the evolution logic: cells die when underpopulated or overcrowded, and new cells are born when the reproduction condition (3 alive neighbors) is fulfilled:</p>\n<pre class=\"brush: python; title: ; notranslate\">\ndef evolve(grid, pars):\n    overcrowd, underpop, reproduction = pars\n    rows, cols = grid.shape\n    newgrid = np.zeros([rows, cols])\n    neighbors = np.zeros([rows,cols])\n    # Auxiliary padded grid\n    padboard = np.zeros([rows+2, cols+2])\n    padboard[:-2,:-2] = grid\n    # Compute neighbours and newgrid\n    for i in range(rows):\n        for j in range(cols):\n            neighbors[i][j] += sum([padboard[a][b] for a in [i-1, i, i+1] \\\n                                    for b in [j-1, j, j+1]])\n            neighbors[i][j] -= padboard[i][j]\n            # Evolution logic\n            newgrid[i][j] = grid[i][j]\n            if grid[i][j] and \\\n               (neighbors[i][j] > overcrowd or neighbors[i][j] < underpop):\n                newgrid[i][j] = 0\n            elif not grid[i][j] and neighbors[i][j] == reproduction:\n                newgrid[i][j] = 1\n    return newgrid\n</pre>\n<p>Note that in the above code we make use of a wonderful property of arrays in python, namely that the last element of an array <code>arr</code> can be referenced either as <code>arr[len(arr)-1]</code> or as <code>arr[-1]</code>. Thus, we create a padboard with 2 columns and 2 rows more than the dimensions of the grid. If n is the number of rows of the grid, the padboard has n+2 rows, which range from 0 to n+1, <em>or</em>, equivalently, from -1 to n!</p>\n<h3>Visualization of Life and creation of mp4 videos with matplotlib</h3>\n<p>For the visualization of the evolution of our random universe we could create a series of png plots and stitch them together to produce an animated gif. However, matplotlib also offers the possibility of generating animations and saving them directly in mp4 format. The code that follows is based on this <a href=\"http://jakevdp.github.io/blog/2013/05/12/embedding-matplotlib-animations/\">very useful tutorial</a>, which contains instructions to embed matplotlib animations directly in the ipython notebook.</p>\n<pre class=\"brush: python; title: ; notranslate\">\npars = 3, 2, 3\nrows, cols = 20, 20\nfig = plt.figure()\nax = plt.axes()\nim = ax.matshow(init_universe(rows,cols),cmap=cm.binary)\nax.set_axis_off()\n\ndef init():\n    im.set_data(init_universe(rows, cols))\n\ndef animate(i):\n    a = im.get_array()\n    a = evolve(a, pars)\n    im.set_array(a)\n    return [im]\n</pre>\n<p>In the code above, we have set the parameters for the evolution as described by the original logic of the game, and we initialize a matplotlib figure using the <code>matshow</code> directive. We also need the functions <code>init</code> and <code>animate</code>; the latter updates the content of the plot with evolved iterations of the universe. The matplotlib call to produce an animation and save it in mp4 format is then simply:</p>\n<pre class=\"brush: python; title: ; notranslate\">\nanim = animation.FuncAnimation(fig, animate, init_func=init, frames=100, blit=True)\n\nanim.save('animation_random.mp4', fps=10) # fps = FramesPerSecond\n</pre>\n<p>A random initialization gives rise to the following animation, which ends in a configuration with 3 stable patterns (<a href=\"http://www.conwaylife.com/wiki/Block\">block</a>, <a href=\"http://www.conwaylife.com/wiki/Blinker\">blinker</a> and a <a href=\"http://www.kulturservern.se/wronsov/selfpassage/XXI/XXI-0804/GoF1.gif\">diamond-shaped structure that settles to a blinker in 8 steps</a>) after approximately 50 iterations.</p>\n<iframe class=\"youtube-player\" width=\"420\" height=\"237\" src=\"https://www.youtube.com/embed/sfuqnGpl-Sg?version=3&#038;rel=0&#038;showsearch=0&#038;showinfo=1&#038;iv_load_policy=1&#038;fs=1&#038;hl=en&#038;autohide=2&#038;wmode=transparent\" allowfullscreen=\"true\" style=\"border:0;\" sandbox=\"allow-scripts allow-same-origin allow-popups allow-presentation\"></iframe>\n<p>While a random initialization often gives rise to interesting universes, there is a vast body of research devoted to classifying particular configurations that are known to evolve in a specific fashion (oscillators, stable figures, moving patterns&#8230;). A <a href=\"https://www.google.com/search?q=game+of+life+patterns\">quick google search</a> illustrates this point and leads to many resources for the interested reader. For starters, let us code up the initialization function of a <a href=\"https://en.wikipedia.org/wiki/File:Game_of_life_pulsar.gif\">&#8220;pulsar&#8221;</a>, a type of oscillator with a 3-iteration period. </p>\n<pre class=\"brush: python; title: ; notranslate\">\ndef init_universe_pulsar():\n    grid = zeros([15, 15])\n    line = zeros(15)\n    line[3:6] = 1\n    line[9:12] = 1\n    for ind in [1,6,8,13]:\n        grid[ind] = line\n        grid[:,ind] = line\n    return grid \n</pre>\n<p>To generate and save this universe, we need to modify the function <code>init</code> used to produce the matplotlib animation and replace the call to <code>init_universe(rows, cols)</code> with <code>init_universe_pulsar()</code>. The resulting evolution can be seen in the following video:</p>\n<iframe class=\"youtube-player\" width=\"420\" height=\"237\" src=\"https://www.youtube.com/embed/d8MAJtPQRlc?version=3&#038;rel=0&#038;showsearch=0&#038;showinfo=1&#038;iv_load_policy=1&#038;fs=1&#038;hl=en&#038;autohide=2&#038;wmode=transparent\" allowfullscreen=\"true\" style=\"border:0;\" sandbox=\"allow-scripts allow-same-origin allow-popups allow-presentation\"></iframe>\n<p>An interesting kind of universes are those that resemble spacecrafts. There are many of them, as a visit to <a href=\"http://www.conwaylife.com/wiki/Category:Spaceships\">this page</a> shows. Other configurations resemble guns that emit gliders forever. By far the most famous one is the <a href=\"http://www.conwaylife.com/wiki/Gosper_glider_gun\">Cosper glider gun</a>, which can be generated using the following initialization function:</p>\n<pre class=\"brush: python; title: ; notranslate\">\ndef init_universe_glider_gun():\n    glider_gun = 38*'0' + 25*'0'+'1'+12*'0' + 23*'0'+'101'+12*'0' +\\\n             13*'0'+'11'+6*'0'+'11'+12*'0'+'11'+'0' +\\\n             12*'0'+'1'+3*'0'+'1'+4*'0'+'11'+12*'0'+'11'+'0' +\\\n             '0'+'11'+8*'0'+'1'+5*'0'+'100011'+15*'0' +\\\n             '0'+'11'+8*'0'+'1'+'000'+'1011'+4*'0'+'101'+12*'0' +\\\n             11*'0'+'1000001'+7*'0'+'1'+12*'0' +\\\n             12*'0'+'10001'+21*'0' + 13*'0'+'11'+23*'0' + 38*'0' +\\\n             19*38*'0'\n    grid = np.array([float(g) for g in glider_gun]).reshape(30,38)\n    return grid\n</pre>\n<p>Once started, this glider gun evolves emitting gliders indefinitely, which move across the grid at -45 degrees and exit the universe bounding box through the bottom right corner. Bill Gosper discovered this first glider gun, which is so far the smallest one ever found, in 1970 and got 50 dollars from Conway for that. The discovery of the glider gun eventually led to the proof that Conway&#8217;s Game of Life could function as a Turing machine. A video of the Gosper glider gun in action can be seen below.</p>\n<iframe class=\"youtube-player\" width=\"420\" height=\"237\" src=\"https://www.youtube.com/embed/HyagFNAtPE0?version=3&#038;rel=0&#038;showsearch=0&#038;showinfo=1&#038;iv_load_policy=1&#038;fs=1&#038;hl=en&#038;autohide=2&#038;wmode=transparent\" allowfullscreen=\"true\" style=\"border:0;\" sandbox=\"allow-scripts allow-same-origin allow-popups allow-presentation\"></iframe>\n<p><a href=\"http://www.radicaleye.com/lifepage/patterns/linepuf.html\">Here</a> is a very nice visualization of yet another type of configuration in Life, the so-called &#8220;puffers&#8221;, patterns that move like a spaceship but leave debris behind as they evolve.</p>\n<h3>Table-top data experiment take-away message</h3>\n<p>Conway&#8217;s game of life is a zero-player game, with evolution completely determined by its initial state, consisting on live and dead cells on a two-dimensional grid. The state of each cell varies with each iteration according to the number of populated neighbors in the adjacent cells. The game, devised in 1970, opened up a whole new area of mathematical research, the field of cellular automata, and belongs to a growing class of what are called &#8220;simulation games&#8221;. Implementing the evolution algorithm behind the game in any programming language is a classical exercise in many CS schools, is always a lot of fun, and allows to explore the huge variety of configurations that give rise to strangely addictive evolution patterns.</p>\n",
  "wfw:commentRss": "https://datasciencelab.wordpress.com/2014/01/03/yet-another-game-of-life/feed/",
  "slash:comments": 0,
  "media:content": [
    {
      "media:title": "datasciencelab"
    },
    {
      "media:title": "random_universe"
    }
  ]
}