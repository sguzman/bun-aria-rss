{
  "title": "Introducing Twitter.jl",
  "description": "<p>This is possibly the latest “announcement” of a package ever, given that <a href=\"https://github.com/randyzwitch/Twitter.jl\">Twitter.jl</a> has existed on <a href=\"https://github.com/JuliaLang/METADATA.jl\" title=\"Julia METADATA\">METADATA</a> for nearly a year now, but that’s how things go sometimes. Here’s how to get started with Twitter.jl.</p>",
  "pubDate": "Mon, 08 Dec 2014 17:12:58 +0000",
  "link": "http://randyzwitch.com/twitter-api-julia/",
  "guid": "http://randyzwitch.com/twitter-api-julia/",
  "content": "<p>This is possibly the latest “announcement” of a package ever, given that <a href=\"https://github.com/randyzwitch/Twitter.jl\">Twitter.jl</a> has existed on <a href=\"https://github.com/JuliaLang/METADATA.jl\" title=\"Julia METADATA\">METADATA</a> for nearly a year now, but that’s how things go sometimes. Here’s how to get started with Twitter.jl.</p>\n\n<h2 id=\"hello-world\">Hello, World!</h2>\n\n<p>If ‘Hello, World!’ is the canonical example of getting started with a programming language, the Twitter API is becoming the first place to start for people wanting to learn about APIs. Authenticating with the Twitter API using Julia is similar to using the R or Python packages, except that rather than doing the OAuth “dance”, Twitter.jl takes all four authentication values in one function:</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-julia\" data-lang=\"julia\"><table class=\"rouge-table\"><tbody><tr><td class=\"gutter gl\"><pre class=\"lineno\">1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n</pre></td><td class=\"code\"><pre><span class=\"k\">using</span> <span class=\"n\">Twitter</span>\n\n<span class=\"n\">apikey</span> <span class=\"o\">=</span> <span class=\"s\">\"q8Qw7WJTVP...\"</span>\n<span class=\"n\">apisecret</span> <span class=\"o\">=</span> <span class=\"s\">\"FIichPpGJxiOssN...\"</span>\n<span class=\"n\">accesstoken</span> <span class=\"o\">=</span> <span class=\"s\">\"98689850-v0zZNr...\"</span>\n<span class=\"n\">accesstokensecret</span> <span class=\"o\">=</span> <span class=\"s\">\"w7bDg9K0c493T...\"</span>\n\n<span class=\"n\">twitterauth</span><span class=\"x\">(</span><span class=\"n\">apikey</span><span class=\"x\">,</span>\n            <span class=\"n\">apisecret</span><span class=\"x\">,</span>\n            <span class=\"n\">accesstoken</span><span class=\"x\">,</span>\n            <span class=\"n\">accesstokensecret</span><span class=\"x\">)</span>\n</pre></td></tr></tbody></table></code></pre></figure>\n\n<p>All four of these values can be found after registering at the <a href=\"https://dev.twitter.com/\">Twitter Developer page</a> and creating an application. Having all four values in your script is less secure than just providing the api key and api secret, but in the future, I’ll likely implement the full OAuth “handshake”. One thing to keep in mind with this function as it currently works is that no validation of your credentials is performed; the only thing this function does is define a global variable <code class=\"language-plaintext highlighter-rouge\">twittercred</code> for later use by the various functions that create the OAuth headers. To shout “Hello, World!” to all of your Twitter followers, you can use the following code:</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-julia\" data-lang=\"julia\"><table class=\"rouge-table\"><tbody><tr><td class=\"gutter gl\"><pre class=\"lineno\">1\n</pre></td><td class=\"code\"><pre><span class=\"n\">post_status_update</span><span class=\"x\">(</span><span class=\"s\">\"Hello, World!\"</span><span class=\"x\">)</span>\n</pre></td></tr></tbody></table></code></pre></figure>\n\n<h2 id=\"general-packagefunction-structure\">General Package/Function Structure</h2>\n\n<p>From the example above, you can see that the function naming follows the <a href=\"https://dev.twitter.com/rest/public\">Twitter REST API</a> naming convention, with the HTTP verb first and the endpoint as the remainder of the function name. As such, it’s a good idea at this early package state to have the Twitter documentation open while using this package, so that you can quickly find the methods you are looking for.</p>\n\n<p>For each function/API endpoint, I’ve gone through and determined which parameters are required; these are required arguments in the Julia functions. For all other options, each function takes a second optional <code class=\"language-plaintext highlighter-rouge\">Dict{String, String}</code> for any option shown in the Twitter documentation. While this Dict structure allows for ultimate flexibility (and quick definition of functions!), I do realize that it’s less than optimal that you don’t know what optional arguments each Twitter endpoint allows.</p>\n\n<p>As an example, suppose you wanted to search for tweets containing the hashtag <code class=\"language-plaintext highlighter-rouge\">#julialang</code>. The minimum function call is as follows:</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-julia\" data-lang=\"julia\"><table class=\"rouge-table\"><tbody><tr><td class=\"gutter gl\"><pre class=\"lineno\">1\n</pre></td><td class=\"code\"><pre><span class=\"n\">julia_tweets</span> <span class=\"o\">=</span> <span class=\"n\">get_search_tweets</span><span class=\"x\">(</span><span class=\"s\">\"#julialang\"</span><span class=\"x\">)</span>\n</pre></td></tr></tbody></table></code></pre></figure>\n\n<p>By default, the API will return the 15 most recent tweets containing the <code class=\"language-plaintext highlighter-rouge\">#julialang</code> hashtag. To return the most recent 100 tweets (the maximum per API ‘page’), you can pass the “count” parameter via the <code class=\"language-plaintext highlighter-rouge\">Options</code> Dict:</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-julia\" data-lang=\"julia\"><span class=\"n\">julia_tweets_100</span> <span class=\"o\">=</span> <span class=\"n\">get_search_tweets</span><span class=\"x\">(</span><span class=\"s\">\"#julialang\"</span><span class=\"x\">;</span> <span class=\"n\">options</span> <span class=\"o\">=</span> <span class=\"x\">{</span><span class=\"s\">\"count\"</span> <span class=\"o\">=&gt;</span> <span class=\"s\">\"100\"</span><span class=\"x\">})</span></code></pre></figure>\n\n<h2 id=\"composite-types-and-dataframes-definitions\">Composite Types and DataFrames definitions</h2>\n\n<p>The Twitter API is structured into 4 return data types (<a href=\"https://dev.twitter.com/overview/api/places\">Places</a>, <a href=\"https://dev.twitter.com/overview/api/users\">Users</a>, <a href=\"https://dev.twitter.com/overview/api/tweets\">Tweets</a>, and <a href=\"https://dev.twitter.com/overview/api/entities\">Entities</a>), and I’ve mimicked these types using Julia <a href=\"http://julia.readthedocs.org/en/latest/manual/types/#composite-types\">Composite Types</a>. As such, most functions in Twitter.jl return an array of specific type, such as <code class=\"language-plaintext highlighter-rouge\">Array{TWEETS,1}</code> from the prior <code class=\"language-plaintext highlighter-rouge\">#julialang</code> search example. The benefit to defining custom types for the returned Twitter data is that rudimentary DataFrame methods have also been defined:</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-julia\" data-lang=\"julia\"><table class=\"rouge-table\"><tbody><tr><td class=\"gutter gl\"><pre class=\"lineno\">1\n</pre></td><td class=\"code\"><pre><span class=\"n\">df</span> <span class=\"o\">=</span> <span class=\"n\">DataFrame</span><span class=\"x\">(</span><span class=\"n\">julia_tweets_100</span><span class=\"x\">)</span>\n</pre></td></tr></tbody></table></code></pre></figure>\n\n<p>I describe these DataFrames as ‘rudimentary’ as they parse the top level of JSON into columns, which results in some DataFrame columns having complex data types such as <code class=\"language-plaintext highlighter-rouge\">Dict()</code> (and within the <code class=\"language-plaintext highlighter-rouge\">Dict()</code>, nested Dicts!). As a running theme in this post, this is something I hope to get around to improving in the future.</p>\n\n<h2 id=\"want-to-get-started-developing-julia-start-here\">Want to Get Started Developing Julia? Start Here!</h2>\n\n<p>One of the common questions I get asked is how to get started with Julia, both from a learning perspective and from a package development perspective. Hacking away on the core Julia codebase is great if you have the ability, but the code can certainly be intimidating (the people are quite friendly though). Creating a package isn’t necessarily hard, but you have to think about an idea you want to implement. The third alternative is…</p>\n\n<p>…improve the Twitter package! If you go to the <a href=\"https://github.com/randyzwitch/Twitter.jl\">GitHub page for Twitter.jl</a>, you’ll see a long list of TODO items that need to be worked on. The hardest part (building the OAuth headers) has already been taken care of. What’s left is <a href=\"http://randyzwitch.com/julia-metaprogramming-refactoring/\">re-factoring the code for simplification</a>, factoring out the <a href=\"https://github.com/randyzwitch/OAuth.jl\">OAuth code in general into a new Julia library</a> (also partially started), then building the Streaming API functions, cleaning up the DataFrame methods to remove the <code class=\"language-plaintext highlighter-rouge\">Dict</code> column types, paging through API results…and so-on.</p>\n\n<p>So if any of you are on the sidelines wanting to get some practice on developing packages, without needing to worry about learning Astrophysics first, I’d love to collaborate. And if any Julia programming masters want to collaborate, well that’s great too. All help and pull requests are welcomed.</p>\n\n<p>In the meantime, hopefully some of you will find this package useful for natural language processing, social networking analysis or even creating bots 😉</p>"
}