{
  "title": "Gaussian Processes",
  "link": "",
  "published": "2017-11-25T09:53:00-08:00",
  "updated": "2017-11-25T09:53:00-08:00",
  "author": {
    "name": "Jonathan Landy"
  },
  "id": "tag:efavdb.com,2017-11-25:/gaussian-processes",
  "summary": "<p>We review the math and code needed to fit a Gaussian Process (<span class=\"caps\">GP</span>) regressor to data. We conclude with a demo of a popular application, fast function minimization through <span class=\"caps\">GP</span>-guided search. The gif below illustrates this approach in action &#8212; the red points are samples from the hidden red curve …</p>",
  "content": "<p>We review the math and code needed to fit a Gaussian Process (<span class=\"caps\">GP</span>) regressor to data. We conclude with a demo of a popular application, fast function minimization through <span class=\"caps\">GP</span>-guided search. The gif below illustrates this approach in action &#8212; the red points are samples from the hidden red curve. Using these samples, we attempt to leverage GPs to find the curve&#8217;s minimum as fast as&nbsp;possible.</p>\n<p><a href=\"https://efavdb.com/wp-content/uploads/2017/11/full_search.gif\"><img alt=\"full_search\" src=\"https://efavdb.com/wp-content/uploads/2017/11/full_search.gif\"></a></p>\n<p>Appendices contain quick reviews on (i) the <span class=\"caps\">GP</span> regressor posterior derivation, (ii) SKLearn&#8217;s <span class=\"caps\">GP</span> implementation, and (iii) <span class=\"caps\">GP</span>&nbsp;classifiers.</p>\n<h3>Introduction</h3>\n<p>Gaussian Processes (GPs) provide a tool for treating the following general problem: A function <span class=\"math\">\\(f(x)\\)</span> is sampled at <span class=\"math\">\\(n\\)</span> points, resulting in a set of noisy<span class=\"math\">\\(^1\\)</span> function measurements, <span class=\"math\">\\(\\{f(x_i) = y_i \\pm \\sigma_i, i = 1, \\ldots, n\\}\\)</span>. Given these available samples, can we estimate the probability that <span class=\"math\">\\(f = \\hat{f}\\)</span>, where <span class=\"math\">\\(\\hat{f}\\)</span> is some candidate&nbsp;function?</p>\n<p>To decompose and isolate the ambiguity associated with the above challenge, we begin by applying Bayes&#8217;s&nbsp;rule,\n</p>\n<div class=\"math\">\\begin{eqnarray} \\label{Bayes} \\tag{1}\np(\\hat{f} \\vert \\{y\\}) = \\frac{p(\\{y\\} \\vert \\hat{f} ) p(\\hat{f})}{p(\\{y\\}) }.\n\\end{eqnarray}</div>\n<p>\nThe quantity at left above is shorthand for the probability we seek &#8212; the probability that <span class=\"math\">\\(f = \\hat{f}\\)</span>, given our knowledge of the sampled function values <span class=\"math\">\\(\\{y\\}\\)</span>. To evaluate this, one can define and then evaluate the quantities at right. Defining the first in the numerator requires some assumption about the source of error in our measurement process. The second function in the numerator is the prior &#8212; it is here where the greatest assumptions must be taken. For example, we&#8217;ll see below that the prior effectively dictates the probability of a given smoothness for the <span class=\"math\">\\(f\\)</span> function in&nbsp;question.</p>\n<p>In the <span class=\"caps\">GP</span> approach, both quantities in the numerator at right above are taken to be multivariate Normals / Gaussians. The specific parameters of this Gaussian can be selected to ensure that the resulting fit is good &#8212; but the Normality requirement is essential for the mathematics to work out. Taking this approach, we can write down the posterior analytically, which then allows for some useful applications. For example, we used this approach to obtain the curves shown in the top figure of this post &#8212; these were obtained through random sampling from the posterior of a fitted <span class=\"caps\">GP</span>, pinned to equal measured values at the two pinched points shown. Posterior samples are useful for visualization and also for taking Monte Carlo&nbsp;averages.</p>\n<p>In this post, we (i) review the math needed to calculate the posterior above, (ii) discuss numerical evaluations and fit some example data using GPs, and (iii) review how a fitted <span class=\"caps\">GP</span> can help to quickly minimize a cost function &#8212; eg a machine learning cross-validation score. Appendices cover the derivation of the <span class=\"caps\">GP</span> regressor posterior, SKLearn&#8217;s <span class=\"caps\">GP</span> implementation, and <span class=\"caps\">GP</span>&nbsp;Classifiers.</p>\n<p>Our minimal python class SimpleGP used below is available on our GitHub, <a href=\"https://github.com/EFavDB/gaussian_processes\">here</a>.</p>\n<p>Note: To understand the mathematical details covered in this post, one should be familiar with multivariate normal distributions &#8212; these are reviewed in our prior post, <a href=\"http://efavdb.github.io/normal-distributions\">here</a>. These details can be skipped by those primarily interested in&nbsp;applications.</p>\n<h3>Analytic evaluation of the&nbsp;posterior</h3>\n<p>To evaluate the left side of (\\ref{Bayes}), we will evaluate the right. Only the terms in the numerator need to be considered, because the denominator does not depend on <span class=\"math\">\\(\\hat{f}\\)</span>. This means that the denominator must equate to a normalization factor, common to all candidate functions. In this section, we will first write down the assumed forms for the two terms in the numerator and then consider the posterior that&nbsp;results.</p>\n<p>The first assumption that we will make is that if the true function is <span class=\"math\">\\(\\hat{f}\\)</span>, then our <span class=\"math\">\\(y\\)</span>-measurements are independent and Gaussian-distributed about <span class=\"math\">\\(\\hat{f}(x)\\)</span>. This assumption implies that the first term on the right of (\\ref{Bayes})&nbsp;is\n</p>\n<div class=\"math\">\\begin{eqnarray} \\tag{2} \\label{prob}\np(\\{y\\} \\vert \\hat{f} ) \\equiv \\prod_{i=1}^n \\frac{1}{\\sqrt{2 \\pi \\sigma_i^2}} \\exp \\left ( - \\frac{(y_i - \\hat{f}(x_i) )^2}{2 \\sigma_i^2} \\right).\n\\end{eqnarray}</div>\n<p>\nThe <span class=\"math\">\\(y_i\\)</span> above are the actual measurements made at our sample points, and the <span class=\"math\">\\(\\sigma_i^2\\)</span> are their variance&nbsp;uncertainties.</p>\n<p>The second thing we must do is assume a form for <span class=\"math\">\\(p(\\hat{f})\\)</span>, our prior. We restrict attention to a set of points <span class=\"math\">\\(\\{x_i: i = 1, \\ldots, N\\}\\)</span>, where the first <span class=\"math\">\\(n\\)</span> points are the points that have been sampled, and the remaining <span class=\"math\">\\((N-n)\\)</span> are test points at other locations &#8212; points where we would like to estimate the joint statistics<span class=\"math\">\\(^2\\)</span> of <span class=\"math\">\\(f\\)</span>. To progress, we simply assume a multi-variate Normal distribution for <span class=\"math\">\\(f\\)</span> at these points, governed by a covariance matrix <span class=\"math\">\\(\\Sigma\\)</span>. This&nbsp;gives\n</p>\n<div class=\"math\">\\begin{eqnarray} \\label{prior} \\tag{3}\n&amp;&amp;p(f(x_1), \\ldots, f(x_N) ) \\sim \\\n&amp;&amp; \\frac{1}{\\sqrt{ (2 \\pi)^{N} \\vert \\Sigma \\vert }} \\exp \\left ( - \\frac{1}{2} \\sum_{ij=1}^N f_i \\Sigma^{-1}_{ij} f_j \\right).\n\\end{eqnarray}</div>\n<p>\nHere, we have introduced the shorthand, <span class=\"math\">\\(f_i \\equiv f(x_i)\\)</span>. Notice that we have implicitly assumed that the mean of our normal distribution is zero above. This is done for simplicity: If a non-zero mean is appropriate, this can be added in to the analysis, or subtracted from the underlying <span class=\"math\">\\(f\\)</span> to obtain a new one with zero&nbsp;mean.</p>\n<p>The particular form of <span class=\"math\">\\(\\Sigma\\)</span> is where all of the modeler&#8217;s insight and ingenuity must be placed when working with GPs. Researchers who know their topic very well can assert well-motivated, complex priors &#8212; often taking the form of a sum of terms, each capturing some physically-relevant contribution to the statistics of their problem at hand. In this post, we&#8217;ll assume the simple&nbsp;form\n</p>\n<div class=\"math\">\\begin{eqnarray} \\tag{4} \\label{covariance}\n\\Sigma_{ij} \\equiv \\sigma^2 \\exp \\left( - \\frac{(x_i - x_j)^2}{2 l^2}\\right).\n\\end{eqnarray}</div>\n<p>\nNotice that with this assumed form, if <span class=\"math\">\\(x_i\\)</span> and <span class=\"math\">\\(x_j\\)</span> are close together, the exponential will be nearly equal to one. This ensures that nearby points are highly correlated, forcing all high-probability functions to be smooth. The rate at which (\\ref{covariance}) dies down as two test points move away from each another is controlled by the length-scale parameter <span class=\"math\">\\(l.\\)</span> If this is large (small), the curve will be smooth over a long (short) distance. We illustrate these points in the next section, and also explain how an appropriate length scale can be inferred from the sample data at hand in the section after&nbsp;that.</p>\n<p>Now, if we combine (\\ref{prob}) and (\\ref{prior}) and plug this into (\\ref{Bayes}), we obtain an expression for the posterior, <span class=\"math\">\\(p(f \\vert \\{y\\})\\)</span>. This function is an exponential whose argument is a quadratic in the <span class=\"math\">\\(f_i\\)</span>. In other words, like the prior, the posterior is a multi-variate normal. With a little work, one can derive explicit expressions for the mean and covariance of this distribution: Using block notation, with <span class=\"math\">\\(0\\)</span> corresponding to the sample points and <span class=\"math\">\\(1\\)</span> to the test points, the marginal distribution at the test points&nbsp;is\n</p>\n<div class=\"math\">\\begin{eqnarray} \\tag{5} \\label{posterior}\n&amp;&amp; p(\\textbf{f}_1 \\vert \\{y\\}) =\\\n&amp;&amp; N\\left ( \\Sigma_{10} \\frac{1}{\\sigma^2 I_{00} + \\Sigma_{00}} \\cdot \\textbf{y}, \\Sigma_{11} - \\Sigma_{10} \\frac{1}{\\sigma^2 I_{00} + \\Sigma_{00}} \\Sigma_{01} \\right).\n\\end{eqnarray}</div>\n<p>\nHere,\n</p>\n<div class=\"math\">\\begin{eqnarray} \\tag{6} \\label{sigma_mat}\n\\sigma^2 I_{00} \\equiv\n\\left( \\begin{array}{cccc}\n\\sigma_1^2 &amp; 0 &amp; \\ldots &amp;0 \\\\\n0 &amp; \\sigma_2^2 &amp; \\ldots &amp;0 \\\\\n\\ldots &amp; &amp; &amp; \\\\\n0 &amp; 0 &amp; \\ldots &amp; \\sigma_n^2\n\\end{array} \\right),\n\\end{eqnarray}</div>\n<p>\nand <span class=\"math\">\\(\\textbf{y}\\)</span> is the length-<span class=\"math\">\\(n\\)</span> vector of&nbsp;measurements,\n</p>\n<div class=\"math\">\\begin{eqnarray}\\tag{7} \\label{y_vec}\n\\textbf{y}^T \\equiv (y_1, \\ldots, y_n).\n\\end{eqnarray}</div>\n<p>Equation (\\ref{posterior}) is one of the main results for Gaussian Process regressors &#8212; this result is all one needs to evaluate the posterior. Notice that the mean at all points is linear in the sampled values <span class=\"math\">\\(\\textbf{y}\\)</span> and that the variance at each point is reduced near the measured values. Those interested in a careful derivation of this result can consult our appendix &#8212; we actually provide two derivations there. However, in the remainder of the body of the post, we will simply explore applications of this&nbsp;formula.</p>\n<h3>Numerical evaluations of the&nbsp;posterior</h3>\n<p>In this section, we will demonstrate how two typical applications of (\\ref{posterior}) can be carried out: (i) Evaluation of the mean and standard deviation of the posterior distribution at a test point <span class=\"math\">\\(x\\)</span>, and (ii) Sampling functions <span class=\"math\">\\(\\hat{f}\\)</span> directly from the posterior. The former is useful in that it can be used to obtain confidence intervals for <span class=\"math\">\\(f\\)</span> at all locations, and the latter is useful both for visualization and also for obtaining general Monte Carlo averages over the posterior. Both concepts are illustrated in the header image for this post: In this picture, we fit a <span class=\"caps\">GP</span> to a one-d function that had been measured at two locations. The blue shaded region represents a one-sigma confidence interval for the function value at each location, and the colored curves are posterior&nbsp;samples.</p>\n<p>The code for our <code>SimpleGP</code> fitter class is available on our <a href=\"https://github.com/EFavDB/gaussian_processes\">GitHub</a>. We&#8217;ll explain a bit how this works below, but those interested in the details should examine the code &#8212; it&#8217;s a short script and should be largely&nbsp;self-explanatory.</p>\n<h4>Intervals</h4>\n<p>The code snippet below initializes our <code>SimpleGP</code> class, defines some sample locations, values, and uncertainties, then evaluates the mean and standard deviation of the posterior at a set of test points. Briefly, this carried out as follows: The <code>fit</code> method evaluates the inverse matrix <span class=\"math\">\\(\\left [ \\sigma^2 I_{00} + \\Sigma_{00} \\right]^{-1}\\)</span> that appears in (\\ref{posterior}) and saves the result for later use &#8212; this allows us to avoid reevaluation of this inverse at each test point. Next, (\\ref{posterior}) is evaluated once for each test point through the call to the <code>interval</code> method.</p>\n<div class=\"highlight\"><pre><span></span><span class=\"c1\"># Initialize fitter -- set covariance parameters</span>\n<span class=\"n\">WIDTH_SCALE</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>\n<span class=\"n\">LENGTH_SCALE</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>\n<span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">SimpleGP</span><span class=\"p\">(</span><span class=\"n\">WIDTH_SCALE</span><span class=\"p\">,</span> <span class=\"n\">LENGTH_SCALE</span><span class=\"p\">,</span> <span class=\"n\">noise</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Insert observed sample data here, fit</span>\n<span class=\"n\">sample_x</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mf\">2.5</span><span class=\"p\">]</span>\n<span class=\"n\">sample_y</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"o\">.</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"n\">sample_s</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mf\">0.01</span><span class=\"p\">,</span> <span class=\"mf\">0.25</span><span class=\"p\">]</span>\n<span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">fit</span><span class=\"p\">(</span><span class=\"n\">sample_x</span><span class=\"p\">,</span> <span class=\"n\">sample_y</span><span class=\"p\">,</span> <span class=\"n\">sample_s</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Get the mean and std at each point in x_test</span>\n<span class=\"n\">test_x</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"o\">.</span><span class=\"mi\">05</span><span class=\"p\">)</span>\n<span class=\"n\">means</span><span class=\"p\">,</span> <span class=\"n\">stds</span> <span class=\"o\">=</span> <span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">interval</span><span class=\"p\">(</span><span class=\"n\">test_x</span><span class=\"p\">)</span>\n</pre></div>\n\n\n<p>In the above, <code>WIDTH_SCALE</code> and <code>LENGTH_SCALE</code> are needed to specify the covariance matrix (\\ref{covariance}). The former corresponds to <span class=\"math\">\\(\\sigma\\)</span> and the latter to <span class=\"math\">\\(l\\)</span> in that equation. Increasing <code>WIDTH_SCALE</code> corresponds to asserting less certainty as to the magnitude of unknown function and increasing <code>LENGTH_SCALE</code> corresponds to increasing how smooth we expect the function to be. The figure below illustrates these points: Here, the blue intervals were obtained by setting <code>WIDTH_SCALE = LENGTH_SCALE  = 1</code> and the orange intervals were obtained by setting <code>WIDTH_SCALE = 0.5</code> and <code>LENGTH_SCALE  = 2</code>. The result is that the orange posterior estimate is tighter and smoother than the blue posterior. In both plots, the solid curve is a plot of the mean of the posterior distribution, and the vertical bars are one sigma confidence&nbsp;intervals.</p>\n<p><a href=\"https://efavdb.com/wp-content/uploads/2017/11/intervals.jpg\"><img alt=\"intervals\" src=\"https://efavdb.com/wp-content/uploads/2017/11/intervals.jpg\"></a></p>\n<h4>Posterior&nbsp;samples</h4>\n<p>To sample actual functions from the posterior, we will simply evaluate the mean and covariance matrix in (\\ref{posterior}) again, this time passing in the multiple test point locations at which we would like to know the resulting sampled functions. Once we have the mean and covariance matrix of the posterior at these test points, we can pull samples from (\\ref{posterior}) using an external library for multivariate normal sampling &#8212; for this purpose, we used the python package numpy. The last step in the code snippet below carries out these&nbsp;steps.</p>\n<div class=\"highlight\"><pre><span></span><span class=\"c1\"># Insert observed sample data here.</span>\n<span class=\"n\">sample_x</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mf\">1.5</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mf\">0.7</span><span class=\"p\">,</span> <span class=\"mf\">1.4</span><span class=\"p\">,</span> <span class=\"mf\">2.5</span><span class=\"p\">,</span> <span class=\"mf\">3.0</span><span class=\"p\">]</span>\n<span class=\"n\">sample_y</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"o\">.</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">]</span>\n<span class=\"n\">sample_s</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mf\">0.01</span><span class=\"p\">,</span> <span class=\"mf\">0.25</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mf\">0.01</span><span class=\"p\">,</span> <span class=\"mf\">0.3</span><span class=\"p\">,</span> <span class=\"mf\">0.01</span><span class=\"p\">]</span>\n\n<span class=\"c1\"># Initialize fitter -- set covariance parameters</span>\n<span class=\"n\">WIDTH_SCALE</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>\n<span class=\"n\">LENGTH_SCALE</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>\n<span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">SimpleGP</span><span class=\"p\">(</span><span class=\"n\">WIDTH_SCALE</span><span class=\"p\">,</span> <span class=\"n\">LENGTH_SCALE</span><span class=\"p\">,</span> <span class=\"n\">noise</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">fit</span><span class=\"p\">(</span><span class=\"n\">sample_x</span><span class=\"p\">,</span> <span class=\"n\">sample_y</span><span class=\"p\">,</span> <span class=\"n\">sample_s</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Get the mean and std at each point in test_x</span>\n<span class=\"n\">test_x</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"o\">.</span><span class=\"mi\">05</span><span class=\"p\">)</span>\n<span class=\"n\">means</span><span class=\"p\">,</span> <span class=\"n\">stds</span> <span class=\"o\">=</span> <span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">interval</span><span class=\"p\">(</span><span class=\"n\">test_x</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Sample here</span>\n<span class=\"n\">SAMPLES</span> <span class=\"o\">=</span> <span class=\"mi\">10</span>\n<span class=\"n\">samples</span> <span class=\"o\">=</span> <span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">sample</span><span class=\"p\">(</span><span class=\"n\">test_x</span><span class=\"p\">,</span> <span class=\"n\">SAMPLES</span><span class=\"p\">)</span>\n</pre></div>\n\n\n<p>Notice that in lines 2-4 here, we&#8217;ve added in a few additional function sample locations (for fun). The resulting intervals and posterior samples are shown in the figure below. Notice that near the sampled points, the posterior is fairly well localized. However, on the left side of the plot, the posterior approaches the prior once we have moved a distance <span class=\"math\">\\(\\geq 1\\)</span>, the length scale chosen for the covariance matrix&nbsp;(\\ref{covariance}).</p>\n<p><a href=\"https://efavdb.com/wp-content/uploads/2017/11/samples.jpg\"><img alt=\"samples\" src=\"https://efavdb.com/wp-content/uploads/2017/11/samples.jpg\"></a></p>\n<h3>Selecting the covariance&nbsp;hyper-parameters</h3>\n<p>In the above, we demonstrated that the length scale of our covariance form dramatically affects the posterior &#8212; the shape of the intervals and also of the samples from the posterior. Appropriately setting these parameters is a general problem that can make working with GPs a challenge. Here, we describe two methods that can be used to intelligently set such hyper-parameters, given some sampled&nbsp;data.</p>\n<h4>Cross-validation</h4>\n<p>A standard method for setting hyper-parameters is to make use of a cross-validation scheme. This entails splitting the available sample data into a training set and a test set. One fits the <span class=\"caps\">GP</span> to the training set using one set of hyper-parameters, then evaluates the accuracy of the model on the held out test set. One then repeats this process across many hyper-parameter choices, and selects that set which resulted in the best test set&nbsp;performance.</p>\n<h4>Marginal Likelihood&nbsp;Maximization</h4>\n<p>Often, one is interested in applying GPs in limits where evaluation of samples is expensive. This means that one often works with GPs in limits where only a small number of samples are available. In cases like this, the optimal hyper-parameters can vary quickly as the number of training points is increased. This means that the optimal selections obtained from a cross-validation schema may be far from the optimal set that applies when one trains on the full sample set<span class=\"math\">\\(^3\\)</span>.</p>\n<p>An alternative general approach for setting the hyper-parameters is to maximize the marginal likelihood. That is, we try to maximize the likelihood of seeing the samples we have seen &#8212; optimizing over the choice of available hyper-parameters. Formally, the marginal likelihood is evaluated by integrating out the unknown <span class=\"math\">\\(\\hat{f}^4\\)</span>,\n</p>\n<div class=\"math\">\\begin{eqnarray} \\tag{8}\np(\\{y\\} \\vert \\Sigma) \\equiv \\int p(\\{y\\} \\vert f) p(f \\vert \\Sigma) df.\n\\end{eqnarray}</div>\n<p>\nCarrying out the integral directly can be done just as we have evaluated the posterior distribution in our appendix. However, a faster method is to note that after integrating out the <span class=\"math\">\\(f\\)</span>, the <span class=\"math\">\\(y\\)</span> values must be normally distributed&nbsp;as\n</p>\n<div class=\"math\">\\begin{eqnarray}\\tag{9}\np(\\{y\\} \\vert \\Sigma) \\sim N(0, \\Sigma + \\sigma^2 I_{00}),\n\\end{eqnarray}</div>\n<p>\nwhere <span class=\"math\">\\(\\sigma^2 I_{00}\\)</span> is defined as in (\\ref{sigma_mat}). This&nbsp;gives\n</p>\n<div class=\"math\">\\begin{eqnarray} \\tag{10} \\label{marginallikelihood}\n\\log p(\\{y\\}) \\sim - \\log \\vert \\Sigma + \\sigma^2 I_{00} \\vert - \\textbf{y} \\cdot ( \\Sigma + \\sigma^2 I_{00} )^{-1} \\cdot \\textbf{y}.\n\\end{eqnarray}</div>\n<p>\nThe two terms above compete: The second term is reduced by finding the covariance matrix that maximizes the exponent. Maximizing this alone would tend to result in an overfitting of the data. However, this term is counteracted by the first, which is the normalization for a Gaussian integral. This term becomes larger given short decay lengths and low diagonal variances. It acts as regularization term that suppresses overly complex&nbsp;fits.</p>\n<p>In practice, to maximize (\\ref{marginallikelihood}), one typically makes use of gradient descent, using analytical expressions for the gradient. This is the approach taken by SKLearn. Being able to optimize the hyper-parameters of a <span class=\"caps\">GP</span> is one of this model&#8217;s virtures. Unfortunately, (\\ref{marginallikelihood}) is not guaranteed to be convex and multiple local minima often exist. To obtain a good minimum, one can attempt to initialize at some well-motivated point. Alternatively, one can reinitialize the gradient descent repeatedly at random points, finally selecting the best option at the&nbsp;end.</p>\n<h3>Function minimum search and machine&nbsp;learning</h3>\n<p>We&#8217;re now ready to introduce one of the popular application of GPs: fast, guided function minimum search. In this problem, one is able to iteratively obtain noisy samples of a function, and the aim is to identify as quickly as possible the global minimum of the function. Gradient descent could be applied in cases like this, but this approach generally requires repeated sampling if the function is not convex. To reduce the number of steps / samples required, one can attempt to apply a more general, explore-exploit type strategy &#8212; one balancing the desire to optimize about the current best known minimum with the goal of seeking out new local minima that are potentially even better. <span class=\"caps\">GP</span> posteriors provide a natural starting point for developing such&nbsp;strategies.</p>\n<p>The idea behind the <span class=\"caps\">GP</span>-guided search approach is to develop a score function on top of the <span class=\"caps\">GP</span> posterior. This score function should be chosen to encode some opinion of the value of searching a given point &#8212; preferably one that takes an explore-exploit flavor. Once each point is scored, the point with the largest (or smallest, as appropriate) score is sampled. The process is then repeated iteratively until one is satisfied. Many score functions are possible. We discuss four possible choices below, then give an&nbsp;example.</p>\n<ul>\n<li><strong>Gaussian Lower Confidence Bound (<span class=\"caps\">GLCB</span>)</strong>.\n    The <span class=\"caps\">GLCB</span> scores each point <span class=\"math\">\\(x\\)</span> as\n    <div class=\"math\">\\begin{eqnarray}\\tag{11}\n    s_{\\kappa}(x) = \\mu(x) - \\kappa \\sigma(x).\n    \\end{eqnarray}</div>\n    Here, <span class=\"math\">\\(\\mu\\)</span> and <span class=\"math\">\\(\\sigma\\)</span> are the <span class=\"caps\">GP</span> posterior estimates for the mean and standard deviation for the function at <span class=\"math\">\\(x\\)</span> and <span class=\"math\">\\(\\kappa\\)</span> is a control parameter. Notice that the first <span class=\"math\">\\(\\mu(x)\\)</span> term encourages exploitation around the best known local minimum. Similarly, the second <span class=\"math\">\\(\\kappa \\sigma\\)</span> term encourages exploration &#8212; search at points where the <span class=\"caps\">GP</span> is currently most unsure of the true function&nbsp;value.</li>\n<li><strong>Gaussian Probability of Improvement (<span class=\"caps\">GPI</span>)</strong>.\n    If the smallest value seen so far is <span class=\"math\">\\(y\\)</span>, we can score each point using the probability that the true function value at that point is less than <span class=\"math\">\\(y\\)</span>. That is, we can write\n    <div class=\"math\">\\begin{eqnarray}\\tag{12}\n    s(x) = \\frac{1}{\\sqrt{2 \\pi \\sigma^2}} \\int_{-\\infty}^y e^{-(v - \\mu)^2 / (2 \\sigma^2)} dv.\n    \\end{eqnarray}</div>\n</li>\n<li><strong>Gaussian Expected Improvement (<span class=\"caps\">EI</span>)</strong>.\n    A popular variant of the above is the so-called expected improvement.\n    This is defined as\n    <div class=\"math\">\\begin{eqnarray} \\tag{13}\n    s(x) = \\frac{1}{\\sqrt{2 \\pi \\sigma^2}} \\int_{-\\infty}^y e^{-(v - \\mu)^2 / (2 \\sigma^2)} (y - v) dv.\n    \\end{eqnarray}</div>\n    This score function tends to encourage more exploration than the probability of improvement, since it values uncertainty more&nbsp;highly.</li>\n<li><strong>Probability is minimum</strong>.\n    A final score function of interest is simply the probability that the point in question is the minimum. One way to obtain this score is to sample from the posterior many times. For each sample, we mark its global minimum, then take a majority vote for where to sample&nbsp;next.</li>\n</ul>\n<p>The gif at the top of this page (copied below) illustrates an actual <span class=\"caps\">GP</span>-guided search, carried out in python using the package skopt<span class=\"math\">\\(^5\\)</span>. The red curve at left is the (hidden) curve <span class=\"math\">\\(f\\)</span> whose global minimum is being sought. The red points are the samples that have been obtained so far, and the green shaded curve is the <span class=\"caps\">GP</span> posterior confidence interval for each point &#8212; this gradually improves as more samples are obtained. At right is the Expected Improvement (<span class=\"caps\">EI</span>) score function at each point that results from analysis on top of the <span class=\"caps\">GP</span> posterior &#8212; the score function used to guide search in this example. The process is initialized with five random samples, followed by guided search. Notice that as the process evolves, the first few samples focus on exploitation of known local minima. However, after a handful of iterations, the diminishing returns of continuing to sample these locations loses out to the desire to explore the middle points &#8212; where the actual global minimum sits and is&nbsp;found.</p>\n<p><a href=\"https://efavdb.com/wp-content/uploads/2017/11/full_search.gif\"><img alt=\"full_search\" src=\"https://efavdb.com/wp-content/uploads/2017/11/full_search.gif\"></a></p>\n<h3>Discussion</h3>\n<p>In this post we&#8217;ve overviewed much of the math of GPs: The math needed to get to the posterior, how to sample from the posterior, and finally how to make practical use of the&nbsp;posterior.</p>\n<p>In principle, GPs represent a powerful tool that can be used to fit any function. In practice, the challenge in wielding this tool seems to sit mainly with selection of appropriate hyper-parameters &#8212; the search for appropriate parameters often gets stuck in local minima, causing fits to go off the rails. Nevertheless, when done correctly, application of GPs can provide some valuable performance gains &#8212; and they are always fun to&nbsp;visualize.</p>\n<p>Some additional topics relating to GPs are contained in our appendices. For those interested in even more detail, we can recommend the free online text by Rasmussen and Williams<span class=\"math\">\\(^6\\)</span>.</p>\n<h3>Appendix A: Derivation of&nbsp;posterior</h3>\n<p>In this appendix, we present two methods to derive the posterior&nbsp;(\\ref{posterior}).</p>\n<h4>Method&nbsp;1</h4>\n<p>We will begin by completing the square. Combining (\\ref{prob}) and (\\ref{prior}), a little algebra&nbsp;gives\n</p>\n<div class=\"math\">\\begin{align} \\tag{A1} \\label{square_complete}\n p(f_1, \\ldots, f_N \\vert \\{y\\})  &amp;\\sim \\exp \\left (-\\sum_{i=1}^n \\frac{(y_i - f_i)^2}{2 \\sigma^2_i} - \\frac{1}{2} \\sum_{ij=1}^N f_i \\Sigma^{-1}_{ij} f_j \\right) \\\\\n&amp;\\sim N\\left ( \\frac{1}{\\Sigma^{-1} + \\frac{1}{\\sigma^2} I } \\cdot \\frac{1}{\\sigma^2} I \\cdot \\textbf{y}, \\frac{1}{\\Sigma^{-1} + \\frac{1}{\\sigma^2} I } \\right).\n\\end{align}</div>\n<p>\nHere, <span class=\"math\">\\(\\frac{1}{\\sigma^2} I\\)</span> is defined as in (\\ref{sigma_mat}), but has zeros in all rows outside of the sample set. To obtain the expression (\\ref{posterior}), we must identify the block structure of the inverse matrix that appears&nbsp;above.</p>\n<p>To start, we&nbsp;write\n</p>\n<div class=\"math\">\\begin{align} \\tag{A2} \\label{matrix_to_invert}\n\\frac{1}{\\Sigma^{-1} + \\frac{1}{\\sigma^2}I } &amp;= \\Sigma \\frac{1}{I + \\frac{1}{\\sigma^2}I \\Sigma} \\\\\n&amp;= \\Sigma \\left( \\begin{matrix}\nI_{00} + \\frac{1}{\\sigma^2}I_{00} \\Sigma_{00} &amp; \\frac{1}{\\sigma^2}I_{00} \\Sigma_{01}\\\\\n0 &amp; I_{11}\n\\end{matrix} \\right)^{-1},\n\\end{align}</div>\n<p>\nwhere we are using block notation. To evaluate the inverse that appears above, we will make use of the block matrix inversion&nbsp;formula,\n</p>\n<div class=\"math\">\\begin{align}\n&amp;\\left( \\begin{matrix}\nA &amp; B\\\\\nC &amp; D\n\\end{matrix} \\right)^{-1} = \\\\\n&amp;\\left( \\begin{matrix}\n(A - B D^{-1} C)^{-1} &amp; - (A - B D^{-1} C)^{-1} B D^{-1} \\\\\n-D^{-1} C (A - B D^{-1} C)^{-1} &amp; D^{-1} + D^{-1} C (A - B D^{-1} C) B D^{-1}\n\\end{matrix} \\right).\n\\end{align}</div>\n<p>\nThe matrix (\\ref{matrix_to_invert}) has blocks <span class=\"math\">\\(C = 0\\)</span> and <span class=\"math\">\\(D=I\\)</span>, which simplifies the above significantly. Plugging in, we&nbsp;obtain\n</p>\n<div class=\"math\">\\begin{align} \\label{shifted_cov} \\tag{A3}\n\\frac{1}{\\Sigma^{-1} + \\frac{1}{\\sigma^2}I } =\n\\Sigma \\left( \\begin{matrix}\n\\frac{1}{I_{00} + \\frac{1}{\\sigma^2}I \\Sigma_{00}} &amp; - \\frac{1}{I_{00} + \\frac{1}{\\sigma^2}I \\Sigma_{00}} \\Sigma_{01}\\\\\n0 &amp; I_{11}\n\\end{matrix} \\right)\n\\end{align}</div>\n<p>\nWith this result and (\\ref{square_complete}), we can read off the mean of the test set&nbsp;as\n</p>\n<div class=\"math\">\\begin{align} \\tag{A4} \\label{mean_test}\n&amp; \\left [ [ \\Sigma^{-1} + \\frac{1}{\\sigma^2} I_{00} ]^{-1} \\cdot \\frac{1}{\\sigma^2} I_{00} \\cdot \\textbf{y} \\right ]_1 \\\\\n&amp;= \\Sigma_{10} \\frac{1}{I_{00} + \\frac{1}{\\sigma^2}I_{00} \\Sigma_{00}} \\frac{1}{\\sigma^2} I_{00} \\cdot \\textbf{y} \\\\\n&amp;= \\Sigma_{10} \\frac{1}{\\sigma^2 I_{00} + \\Sigma_{00}} \\cdot \\textbf{y},\n\\end{align}</div>\n<p>\nwhere we have multiplied the numerator and denominator by the inverse of <span class=\"math\">\\(\\frac{1}{\\sigma^2}I_{00}\\)</span> in the second line. Similarly, the covariance of the test set is given by the lower right block of (\\ref{shifted_cov}). This&nbsp;is,\n</p>\n<div class=\"math\">\\begin{align}\\tag{A5} \\label{covariance_test}\n\\Sigma_{11} - \\Sigma_{10} \\cdot \\frac{1}{\\sigma^2 I_{00} + \\Sigma_{00}} \\cdot \\Sigma_{01}.\n\\end{align}</div>\n<p>\nThe results (\\ref{mean_test}) and (\\ref{covariance_test}) give&nbsp;(\\ref{posterior}).</p>\n<h4>Method&nbsp;2</h4>\n<p>In this second method, we consider the joint distribution of a set of test points <span class=\"math\">\\(\\textbf{f}_1\\)</span> and the set of observed samples <span class=\"math\">\\(\\textbf{f}_0\\)</span>. Again, we assume that the function density has mean zero. The joint probability density for the two is&nbsp;then\n</p>\n<div class=\"math\">\\begin{align}\\tag{A6}\np(\\textbf{f}_0, \\textbf{f}_1) \\sim N \\left (\n\\left ( \\begin{matrix}\n0 \\\\\n0\n\\end{matrix} \\right),\n\\left ( \\begin{matrix}{cc}\n\\Sigma_{0,0} &amp; \\Sigma_{0,1} \\\\\n\\Sigma_{1,0} &amp; \\Sigma_{11}\n\\end{matrix} \\right )\n\\right )\n\\end{align}</div>\n<p>\nNow, we use the&nbsp;result\n</p>\n<div class=\"math\">\\begin{align} \\tag{A7}\np( \\textbf{f}_1 \\vert \\textbf{f}_0) &amp;=&amp; \\frac{p( \\textbf{f}_0, \\textbf{f}_1)}{p( \\textbf{f}_0)}.\n\\end{align}</div>\n<p>\nThe last two expressions are all that are needed to derive (\\ref{posterior}). The main challenge involves completing the square, and this can be done with the block matrix inversion formula, as in the previous&nbsp;derivation.</p>\n<h3>Appendix B: SKLearn implementation and other&nbsp;kernels</h3>\n<p><a href=\"https://efavdb.com/wp-content/uploads/2017/11/sklearn.jpg\"><img alt=\"sklearn\" src=\"https://efavdb.com/wp-content/uploads/2017/11/sklearn.jpg\"></a></p>\n<p>SKLearn provides contains the <code>GaussianProcessRegressor</code> class. This allows one to carry out fits and sampling in any dimension &#8212; i.e., it is more general than our minimal class in that it can fit feature vectors in more than one dimension. In addition, the <code>fit</code> method of the SKLearn class attempts to find an optimal set of hyper-parameters for a given set of data. This is done through maximization of the marginal likelihood, as described above. Here, we provide some basic notes on this class and the built in kernels that one can use to define the covariance matrix <span class=\"math\">\\(\\Sigma\\)</span> in (\\ref{prior}). We also include a simple code snippet illustrating&nbsp;calls.</p>\n<h4>Pre-defined&nbsp;Kernels</h4>\n<ul>\n<li>Radial-basis function (<span class=\"caps\">RBF</span>): This is the default &#8212; equivalent to our (\\ref{covariance}). The <span class=\"caps\">RBF</span> is characterized by a scale parameter, <span class=\"math\">\\(l\\)</span>. In more than one dimension, this can be a vector, allowing for anisotropic correlation&nbsp;lengths.</li>\n<li>White kernel : The White Kernel is used for noise estimation &#8212; docs suggest useful for estimating the global noise level, but not&nbsp;pointwise.</li>\n<li>Matern: This is a generalized exponential decay, where the exponents is a powerlaw in separation distance. Special limits include the <span class=\"caps\">RBF</span> and also an absolute distance exponential decay. Some special parameter choices allow for existence of single or double&nbsp;derivatives.</li>\n<li>Rational quadratic: This is <span class=\"math\">\\((1 + (d / l)^2)^{\\alpha}\\)</span>.</li>\n<li>Exp-Sine-Squared: This allows one to model periodic functions. This is just like the <span class=\"caps\">RBF</span>, but the distance that gets plugged in is the sine of the actual distance. A periodicity parameter exists, as well as a &#8220;variance&#8221;\n    &#8212; the scale of the Gaussian&nbsp;suppression.</li>\n<li>Dot product kernel : This takes form <span class=\"math\">\\(1 + x_i \\cdot x_j\\)</span>. It&#8217;s not stationary, in the sense that the result changes if a constant translation is added in. They state that you get this result from linear regression analysis if you place <span class=\"math\">\\(N(0,1)\\)</span> priors on the&nbsp;coefficients.</li>\n<li>Kernels as objects : The kernels are objects, but support binary operations between them to create more complicated kernels, eg addition, multiplication, and exponentiation (latter simply raises initial kernel to a power). They all support analytic gradient evaluation. You can access all of the parameters in a kernel that you define via some helper functions &#8212; eg, <code>kernel.get_params()</code>. <code>kernel.hyperparameters</code> is a list of all the&nbsp;hyper-parameters.</li>\n</ul>\n<h4>Parameters</h4>\n<ul>\n<li><code>n_restarts_optimizer</code>: This is the number of times to restart the fit &#8212; useful for exploration of multiple local minima. The default is&nbsp;zero.</li>\n<li><code>alpha</code>: This optional argument allows one to pass in uncertainties for each&nbsp;measurement.</li>\n<li><code>normalize_y</code>: This is used to indicate that the mean of the <span class=\"math\">\\(y\\)</span>-values we&#8217;re looking for is not necessarily&nbsp;zero.</li>\n</ul>\n<h4>Example&nbsp;call</h4>\n<p>The code snippet below carries out a simple fit. The result is the plot shown at the top of this&nbsp;section.</p>\n<div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">sklearn.gaussian_process.kernels</span> <span class=\"kn\">import</span> <span class=\"n\">RBF</span><span class=\"p\">,</span> <span class=\"n\">ConstantKernel</span> <span class=\"k\">as</span> <span class=\"n\">C</span>\n<span class=\"kn\">from</span> <span class=\"nn\">sklearn.gaussian_process</span> <span class=\"kn\">import</span> <span class=\"n\">GaussianProcessRegressor</span>\n<span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n\n<span class=\"c1\"># Build a model</span>\n<span class=\"n\">kernel</span> <span class=\"o\">=</span> <span class=\"n\">C</span><span class=\"p\">(</span><span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"mf\">1e-3</span><span class=\"p\">,</span> <span class=\"mf\">1e3</span><span class=\"p\">))</span> <span class=\"o\">*</span> <span class=\"n\">RBF</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">))</span>\n<span class=\"n\">gp</span> <span class=\"o\">=</span> <span class=\"n\">GaussianProcessRegressor</span><span class=\"p\">(</span><span class=\"n\">kernel</span><span class=\"o\">=</span><span class=\"n\">kernel</span><span class=\"p\">,</span> <span class=\"n\">n_restarts_optimizer</span><span class=\"o\">=</span><span class=\"mi\">9</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Some data</span>\n<span class=\"n\">xobs</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mf\">1.5</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">3</span><span class=\"p\">]])</span>\n<span class=\"n\">yobs</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">])</span>\n\n<span class=\"c1\"># Fit the model to the data (optimize hyper parameters)</span>\n<span class=\"n\">gp</span><span class=\"o\">.</span><span class=\"n\">fit</span><span class=\"p\">(</span><span class=\"n\">xobs</span><span class=\"p\">,</span> <span class=\"n\">yobs</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Plot points and predictions</span>\n<span class=\"n\">x_set</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">6</span><span class=\"p\">,</span> <span class=\"mi\">6</span><span class=\"p\">,</span> <span class=\"mf\">0.1</span><span class=\"p\">)</span>\n<span class=\"n\">x_set</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"n\">x_set</span><span class=\"p\">])</span>\n<span class=\"n\">means</span><span class=\"p\">,</span> <span class=\"n\">sigmas</span> <span class=\"o\">=</span> <span class=\"n\">gp</span><span class=\"o\">.</span><span class=\"n\">predict</span><span class=\"p\">(</span><span class=\"n\">x_set</span><span class=\"p\">,</span> <span class=\"n\">return_std</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">figure</span><span class=\"p\">(</span><span class=\"n\">figsize</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">))</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">errorbar</span><span class=\"p\">(</span><span class=\"n\">x_set</span><span class=\"p\">,</span> <span class=\"n\">means</span><span class=\"p\">,</span> <span class=\"n\">yerr</span><span class=\"o\">=</span><span class=\"n\">sigmas</span><span class=\"p\">,</span> <span class=\"n\">alpha</span><span class=\"o\">=</span><span class=\"mf\">0.5</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">x_set</span><span class=\"p\">,</span> <span class=\"n\">means</span><span class=\"p\">,</span> <span class=\"s1\">&#39;g&#39;</span><span class=\"p\">,</span> <span class=\"n\">linewidth</span><span class=\"o\">=</span><span class=\"mi\">4</span><span class=\"p\">)</span>\n<span class=\"n\">colors</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">&#39;g&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;r&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;b&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;k&#39;</span><span class=\"p\">]</span>\n<span class=\"k\">for</span> <span class=\"n\">c</span> <span class=\"ow\">in</span> <span class=\"n\">colors</span><span class=\"p\">:</span>\n    <span class=\"n\">y_set</span> <span class=\"o\">=</span> <span class=\"n\">gp</span><span class=\"o\">.</span><span class=\"n\">sample_y</span><span class=\"p\">(</span><span class=\"n\">x_set</span><span class=\"p\">,</span> <span class=\"n\">random_state</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">randint</span><span class=\"p\">(</span><span class=\"mi\">1000</span><span class=\"p\">))</span>\n    <span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">x_set</span><span class=\"p\">,</span> <span class=\"n\">y_set</span><span class=\"p\">,</span> <span class=\"n\">c</span> <span class=\"o\">+</span> <span class=\"s1\">&#39;--&#39;</span><span class=\"p\">,</span> <span class=\"n\">alpha</span><span class=\"o\">=</span><span class=\"mf\">0.5</span><span class=\"p\">)</span>\n</pre></div>\n\n\n<p>More details on the sklearn implementation can be found <a href=\"http://scikit-learn.org/stable/modules/generated/sklearn.gaussian_process.GaussianProcessRegressor.html\">here</a>.</p>\n<h3>Appendix C: <span class=\"caps\">GP</span>&nbsp;Classifiers</h3>\n<p>Here, we describe how GPs are often used to fit binary classification data &#8212; data where the response variable <span class=\"math\">\\(y\\)</span> can take on values of either <span class=\"math\">\\(0\\)</span> or <span class=\"math\">\\(1\\)</span>. The mathematics for <span class=\"caps\">GP</span> Classifiers does not work out as cleanly as it does for <span class=\"caps\">GP</span> Regressors. The reason is that the <span class=\"math\">\\(0 / 1\\)</span> response is not Gaussian-distributed, which means that the posterior is not either. To make use of the program, one approximates the posterior as normal, via the Laplace&nbsp;approximation.</p>\n<p>The starting point is to write down a form for the probability of seeing a given <span class=\"math\">\\(y\\)</span> value at <span class=\"math\">\\(x\\)</span>. This, ones takes as the&nbsp;form,\n</p>\n<div class=\"math\">\\begin{align} \\tag{A8} \\label{classifier}\np(y \\vert f(x)) = \\frac{1}{1 + \\exp\\left (- y \\times f(x)\\right)}.\n\\end{align}</div>\n<p>\nThis form is a natural non-linear generalization of logistic regression &#8212; see our post on this topic, <a href=\"http://efavdb.github.io/logistic-regression\">here</a>.</p>\n<p>To proceed, the prior for <span class=\"math\">\\(f\\)</span> is taken to once again have form (\\ref{prior}). Using this and (\\ref{classifier}), we obtain the posterior for <span class=\"math\">\\(f\\)</span>\n</p>\n<div class=\"math\">\\begin{align}\np(f \\vert y) &amp;\\sim \\frac{1}{1 + \\exp\\left (- y \\times f(x)\\right)} \\exp \\left ( - \\frac{1}{2} \\sum_{ij=1}^N f_i \\Sigma^{-1}_{ij} f_j \\right) \\\\\n&amp;\\approx N(\\mu, \\Sigma^{\\prime}) \\tag{A9}\n\\end{align}</div>\n<p>\nHere, the last line is the Laplace / Normal approximation to the line above it. Using this form, one can easily obtain confidence intervals and samples from the approximate posterior, as was done for&nbsp;regressors.</p>\n<h3>Footnotes</h3>\n<p>[1] The size of the <span class=\"math\">\\(\\sigma_i\\)</span> determines how precisely we know the function value at each of the <span class=\"math\">\\(x_i\\)</span> points sampled &#8212; if they are all <span class=\"math\">\\(0\\)</span>, we know the function exactly at these points, but not anywhere&nbsp;else.</p>\n<p>[2] One might wonder whether introducing more points to the analysis would change the posterior statistics for the original <span class=\"math\">\\(N\\)</span> points in question. It turns out that this is not the case for GPs: If one is interested only in the joint-statistics of these <span class=\"math\">\\(N\\)</span> points, all others integrate out. For example, consider the goal of identifying the posterior distribution of <span class=\"math\">\\(f\\)</span> at only a single test point <span class=\"math\">\\(x\\)</span>. In this case, the posterior for the <span class=\"math\">\\(N = n+1\\)</span> points follows from Bayes&#8217;s&nbsp;rule,\n</p>\n<div class=\"math\">\\begin{align} \\tag{f1}\np(f(x_1), \\ldots, f(x_n), f(x_{n+1}) \\vert \\{y\\}) = \\frac{p(\\{y\\} \\vert f) p(f)}{p(\\{y\\})}.\n\\end{align}</div>\n<p>\nNow, by assumption, <span class=\"math\">\\(p(\\{y\\} \\vert f)\\)</span> depends only on <span class=\"math\">\\(f(x_1),\\ldots, f(x_n)\\)</span> &#8212; the values of <span class=\"math\">\\(f\\)</span> where <span class=\"math\">\\(y\\)</span> was sampled. Integrating over all points except the sample set and test point <span class=\"math\">\\(x\\)</span>&nbsp;gives\n</p>\n<div class=\"math\">\\begin{align} \\tag{f2}\n&amp;p(f(x_1), \\ldots, f(x_{n+1}) \\vert \\{y\\}) =\\\\\n&amp; \\frac{p(\\{y\\} \\vert f(x_1),\\ldots,f(x_n))}{p(\\{y\\})} \\int p(f) \\prod_{i \\not \\in \\{x_1, \\ldots, x_N\\}} df_i\n\\end{align}</div>\n<p>\nThe result of the integral above is a Normal distribution &#8212; one with covariance given by the original covariance function evaluated only at the points <span class=\"math\">\\(\\{x_1, \\ldots, x_{N} \\}\\)</span>. This fact is proven in our post on Normal distributions &#8212; see equation (22) of that post, <a href=\"http://efavdb.github.io/normal-distributions\">here</a>. The result implies that we can get the correct sampling statistics on any set of test points, simply by analyzing these alongside the sampled points. This fact is what allows us to tractably treat the formally-infinite number of degrees of freedom associated with&nbsp;GPs.</p>\n<p>[3] We have a prior post illustrating this point &#8212; see <a href=\"http://efavdb.github.io/model-selection\">here</a>.</p>\n<p>[4] The marginal likelihood is equal to the denominator of (\\ref{Bayes}), which we previously&nbsp;ignored.</p>\n<p>[5] We made this gif through adapting the skopt tutorial code, <a href=\"https://scikit-optimize.github.io/notebooks/bayesian-optimization.html\">here</a>.</p>\n<p>[6] For the free text by Rasmussen and Williams, see <a href=\"http://www.gaussianprocess.org/\">here</a>.</p>\n<script type=\"text/javascript\">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {\n    var align = \"center\",\n        indent = \"0em\",\n        linebreak = \"false\";\n\n    if (false) {\n        align = (screen.width < 768) ? \"left\" : align;\n        indent = (screen.width < 768) ? \"0em\" : indent;\n        linebreak = (screen.width < 768) ? 'true' : linebreak;\n    }\n\n    var mathjaxscript = document.createElement('script');\n    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';\n    mathjaxscript.type = 'text/javascript';\n    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';\n\n    var configscript = document.createElement('script');\n    configscript.type = 'text/x-mathjax-config';\n    configscript[(window.opera ? \"innerHTML\" : \"text\")] =\n        \"MathJax.Hub.Config({\" +\n        \"    config: ['MMLorHTML.js'],\" +\n        \"    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } },\" +\n        \"    jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" +\n        \"    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" +\n        \"    displayAlign: '\"+ align +\"',\" +\n        \"    displayIndent: '\"+ indent +\"',\" +\n        \"    showMathMenu: true,\" +\n        \"    messageStyle: 'normal',\" +\n        \"    tex2jax: { \" +\n        \"        inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" +\n        \"        displayMath: [ ['$$','$$'] ],\" +\n        \"        processEscapes: true,\" +\n        \"        preview: 'TeX',\" +\n        \"    }, \" +\n        \"    'HTML-CSS': { \" +\n        \"        availableFonts: ['STIX', 'TeX'],\" +\n        \"        preferredFont: 'STIX',\" +\n        \"        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" +\n        \"        linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" +\n        \"    }, \" +\n        \"}); \" +\n        \"if ('default' !== 'default') {\" +\n            \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" +\n                \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" +\n                \"VARIANT['normal'].fonts.unshift('MathJax_default');\" +\n                \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" +\n                \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" +\n                \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" +\n            \"});\" +\n            \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" +\n                \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" +\n                \"VARIANT['normal'].fonts.unshift('MathJax_default');\" +\n                \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" +\n                \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" +\n                \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" +\n            \"});\" +\n        \"}\";\n\n    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);\n    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);\n}\n</script>",
  "category": [
    "",
    "",
    "",
    "",
    ""
  ]
}