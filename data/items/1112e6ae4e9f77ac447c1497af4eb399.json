{
  "title": "Streaming Python Prototype",
  "link": "",
  "updated": "2017-04-13T00:00:00+00:00",
  "id": "https://mrocklin.github.io/blog/work/2017/04/13/streaming",
  "content": "<p><em>This work is supported by <a href=\"http://continuum.io\">Continuum Analytics</a>, and the\nData Driven Discovery Initiative from the <a href=\"https://www.moore.org/\">Moore\nFoundation</a>.</em></p>\n\n<p><em>This blogpost is about experimental software.  The project may change or be\nabandoned without warning.  You should not depend on anything within this\nblogpost.</em></p>\n\n<p>This week I built a <a href=\"https://github.com/mrocklin/streams\">small streaming\nlibrary</a> for Python.  This was originally\nan exercise to help me understand streaming systems like Storm, Flink,\nSpark-Streaming, and Beam, but the end result of this experiment is not\nentirely useless, so I thought I’d share it.  This blogpost will talk about my\nexperience building such a system and what I valued when using it.  Hopefully\nit elevates interest in streaming systems among the Python community.</p>\n\n<h2 id=\"background-with-iterators\">Background with Iterators</h2>\n\n<p>Python has sequences and iterators.  We’re used to mapping, filtering and\naggregating over lists and generators happily.</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">seq</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">]</span>\n<span class=\"n\">seq</span> <span class=\"o\">=</span> <span class=\"nb\">map</span><span class=\"p\">(</span><span class=\"n\">inc</span><span class=\"p\">,</span> <span class=\"n\">L</span><span class=\"p\">)</span>\n<span class=\"n\">seq</span> <span class=\"o\">=</span> <span class=\"nb\">filter</span><span class=\"p\">(</span><span class=\"n\">iseven</span><span class=\"p\">,</span> <span class=\"n\">L</span><span class=\"p\">)</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"n\">seq</span><span class=\"p\">)</span> <span class=\"c1\"># 2 + 4 + 6\n</span><span class=\"mi\">12</span>\n</code></pre></div></div>\n\n<p>If these iterators are infinite, for example if they are coming from some\ninfinite data feed like a hardware sensor or stock market signal then most of\nthese pieces still work except for the final aggregation, which we replace with\nan accumulating aggregation.</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">get_data</span><span class=\"p\">():</span>\n    <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n    <span class=\"k\">while</span> <span class=\"bp\">True</span><span class=\"p\">:</span>\n        <span class=\"n\">i</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n        <span class=\"k\">yield</span> <span class=\"n\">i</span>\n\n<span class=\"n\">seq</span> <span class=\"o\">=</span> <span class=\"n\">get_data</span><span class=\"p\">()</span>\n<span class=\"n\">seq</span> <span class=\"o\">=</span> <span class=\"nb\">map</span><span class=\"p\">(</span><span class=\"n\">inc</span><span class=\"p\">,</span> <span class=\"n\">seq</span><span class=\"p\">)</span>\n<span class=\"n\">seq</span> <span class=\"o\">=</span> <span class=\"nb\">filter</span><span class=\"p\">(</span><span class=\"n\">iseven</span><span class=\"p\">,</span> <span class=\"n\">seq</span><span class=\"p\">)</span>\n<span class=\"n\">seq</span> <span class=\"o\">=</span> <span class=\"n\">accumulate</span><span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"n\">total</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">total</span> <span class=\"o\">+</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">seq</span><span class=\"p\">)</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">next</span><span class=\"p\">(</span><span class=\"n\">seq</span><span class=\"p\">)</span>  <span class=\"c1\"># 2\n</span><span class=\"mi\">2</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">next</span><span class=\"p\">(</span><span class=\"n\">seq</span><span class=\"p\">)</span>  <span class=\"c1\"># 2 + 4\n</span><span class=\"mi\">6</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">next</span><span class=\"p\">(</span><span class=\"n\">seq</span><span class=\"p\">)</span>  <span class=\"c1\"># 2 + 4 + 6\n</span><span class=\"mi\">12</span>\n</code></pre></div></div>\n\n<p>This is usually a fine way to handle infinite data streams.  However this\napproach becomes awkward if you don’t want to block on calling <code class=\"language-plaintext highlighter-rouge\">next(seq)</code> and\nhave your program hang until new data comes in.   This approach also becomes\nawkward when you want to branch off your sequence to multiple outputs and\nconsume from multiple inputs.  Additionally there are operations like rate\nlimiting, time windowing, etc. that occur frequently but are tricky to\nimplement if you are not comfortable using threads and queues.  These\ncomplications often push people to a computation model that goes by the name\n<em>streaming</em>.</p>\n\n<p>To introduce streaming systems in this blogpost I’ll use my new tiny library,\ncurrently called <a href=\"https://github.com/mrocklin/streams\">streams</a> (better name to\ncome in the future).  However if you decide to use streaming systems in your\nworkplace then you should probably use some other more mature library instead.\nCommon recommendations include the following:</p>\n\n<ul>\n  <li>ReactiveX (RxPy)</li>\n  <li>Flink</li>\n  <li>Storm (Streamparse)</li>\n  <li>Beam</li>\n  <li>Spark Streaming</li>\n</ul>\n\n<h2 id=\"streams\">Streams</h2>\n\n<p>We make a stream, which is an infinite sequence of data into which we can emit\nvalues and from which we can subscribe to make new streams.</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">from</span> <span class=\"nn\">streams</span> <span class=\"kn\">import</span> <span class=\"n\">Stream</span>\n<span class=\"n\">source</span> <span class=\"o\">=</span> <span class=\"n\">Stream</span><span class=\"p\">()</span>\n</code></pre></div></div>\n\n<p>From here we replicate our example above.  This follows the standard\nmap/filter/reduce chaining API.</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">source</span><span class=\"p\">.</span><span class=\"nb\">map</span><span class=\"p\">(</span><span class=\"n\">inc</span><span class=\"p\">)</span>\n           <span class=\"p\">.</span><span class=\"nb\">filter</span><span class=\"p\">(</span><span class=\"n\">iseven</span><span class=\"p\">)</span>\n           <span class=\"p\">.</span><span class=\"n\">accumulate</span><span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"n\">total</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">total</span> <span class=\"o\">+</span> <span class=\"n\">x</span><span class=\"p\">))</span>\n</code></pre></div></div>\n\n<p>Note that we haven’t pushed any data into this stream yet, nor have we said\nwhat should happen when data leaves.  So that we can look at results, lets make\na list and push data into it when data leaves the stream.</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">results</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n<span class=\"n\">s</span><span class=\"p\">.</span><span class=\"n\">sink</span><span class=\"p\">(</span><span class=\"n\">results</span><span class=\"p\">.</span><span class=\"n\">append</span><span class=\"p\">)</span>  <span class=\"c1\"># call the append method on every element leaving the stream\n</span></code></pre></div></div>\n\n<p>And now lets push some data in at the source and see it arrive at the sink:</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">for</span> <span class=\"n\">x</span> <span class=\"ow\">in</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">]:</span>\n<span class=\"p\">...</span>     <span class=\"n\">source</span><span class=\"p\">.</span><span class=\"n\">emit</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">results</span>\n<span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">6</span><span class=\"p\">,</span> <span class=\"mi\">12</span><span class=\"p\">]</span>\n</code></pre></div></div>\n\n<p>We’ve accomplished the same result as our infinite iterator, except that rather\nthan <em>pulling</em> data with <code class=\"language-plaintext highlighter-rouge\">next</code> we push data through with <code class=\"language-plaintext highlighter-rouge\">source.emit</code>.  And\nwe’ve done all of this at only a 10x slowdown over normal Python iteators :)\n(this library takes a few microseconds per element rather than CPython’s normal\n100ns overhead).</p>\n\n<p>This will get more interesting in the next few sections.</p>\n\n<h2 id=\"branching\">Branching</h2>\n\n<p>This approach becomes more interesting if we add multiple inputs and outputs.</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">source</span> <span class=\"o\">=</span> <span class=\"n\">Stream</span><span class=\"p\">()</span>\n<span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"n\">source</span><span class=\"p\">.</span><span class=\"nb\">map</span><span class=\"p\">(</span><span class=\"n\">inc</span><span class=\"p\">)</span>\n<span class=\"n\">evens</span> <span class=\"o\">=</span> <span class=\"n\">s</span><span class=\"p\">.</span><span class=\"nb\">filter</span><span class=\"p\">(</span><span class=\"n\">iseven</span><span class=\"p\">)</span>\n<span class=\"n\">evens</span><span class=\"p\">.</span><span class=\"n\">accumulate</span><span class=\"p\">(</span><span class=\"n\">add</span><span class=\"p\">)</span>\n\n<span class=\"n\">odds</span> <span class=\"o\">=</span> <span class=\"n\">s</span><span class=\"p\">.</span><span class=\"nb\">filter</span><span class=\"p\">(</span><span class=\"n\">isodd</span><span class=\"p\">)</span>\n<span class=\"n\">odds</span><span class=\"p\">.</span><span class=\"n\">accumulate</span><span class=\"p\">(</span><span class=\"n\">sub</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<p>Or we can combine streams together</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">second_source</span> <span class=\"o\">=</span> <span class=\"n\">Stream</span><span class=\"p\">()</span>\n<span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"n\">combine_latest</span><span class=\"p\">(</span><span class=\"n\">second_source</span><span class=\"p\">,</span> <span class=\"n\">odds</span><span class=\"p\">).</span><span class=\"nb\">map</span><span class=\"p\">(</span><span class=\"nb\">sum</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<p>So you may have multiple different input sources updating at different rates\nand you may have multiple outputs, perhaps some going to a diagnostics\ndashboard, others going to long-term storage, others going to a database, etc..\nA streaming library makes it relatively easy to set up infrastructure and pipe\neverything to the right locations.</p>\n\n<h2 id=\"time-and-back-pressure\">Time and Back Pressure</h2>\n\n<p>When dealing with systems that produce and consume data continuously you often\nwant to control the flow so that the rates of production are not greater than\nthe rates of consumption.  For example if you can only write data to a database\nat 10MB/s or if you can only make 5000 web requests an hour then you want to\nmake sure that the other parts of the pipeline don’t feed you too much data,\ntoo quickly, which would eventually lead to a buildup in one place.</p>\n\n<p>To deal with this, as our operations push data forward they also accept Tornado\nFutures as a receipt.</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Upstream: Hey Downstream! Here is some data for you\nDownstream: Thanks Upstream!  Let me give you a Tornado future in return.\n            Make sure you don't send me any more data until that future\n            finishes.\nUpstream: Got it, Thanks!  I will pass this to the person who gave me the\n          data that I just gave to you.\n</code></pre></div></div>\n\n<p>Under normal operation you don’t need to think about Tornado futures at all\n(many Python users aren’t familiar with asynchronous programming) but it’s nice\nto know that the library will keep track of balancing out flow.  The code below\nuses <code class=\"language-plaintext highlighter-rouge\">@gen.coroutine</code> and <code class=\"language-plaintext highlighter-rouge\">yield</code> common for Tornado coroutines.  This is\nsimilar to the async/await syntax in Python 3.  Again, you can safely ignore it\nif you’re not familiar with asynchronous programming.</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"o\">@</span><span class=\"n\">gen</span><span class=\"p\">.</span><span class=\"n\">coroutine</span>\n<span class=\"k\">def</span> <span class=\"nf\">write_to_database</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">):</span>\n    <span class=\"k\">with</span> <span class=\"n\">connect</span><span class=\"p\">(</span><span class=\"s\">'my-database:1234/table'</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">db</span><span class=\"p\">:</span>\n        <span class=\"k\">yield</span> <span class=\"n\">db</span><span class=\"p\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">)</span>\n\n<span class=\"n\">source</span> <span class=\"o\">=</span> <span class=\"n\">Stream</span><span class=\"p\">()</span>\n<span class=\"p\">(</span><span class=\"n\">source</span><span class=\"p\">.</span><span class=\"nb\">map</span><span class=\"p\">(...)</span>\n       <span class=\"p\">.</span><span class=\"n\">accumulate</span><span class=\"p\">(...)</span>\n       <span class=\"p\">.</span><span class=\"n\">sink</span><span class=\"p\">(</span><span class=\"n\">write_to_database</span><span class=\"p\">))</span>  <span class=\"c1\"># &lt;- sink produces a Tornado future\n</span>\n<span class=\"k\">for</span> <span class=\"n\">data</span> <span class=\"ow\">in</span> <span class=\"n\">infinite_feed</span><span class=\"p\">:</span>\n    <span class=\"k\">yield</span> <span class=\"n\">source</span><span class=\"p\">.</span><span class=\"n\">emit</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">)</span>       <span class=\"c1\"># &lt;- that future passes through everything\n</span>                                  <span class=\"c1\">#    and ends up here to be waited on\n</span></code></pre></div></div>\n\n<p>There are also a number of operations to help you buffer flow in the right\nspots, control rate limiting, etc..</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">source</span> <span class=\"o\">=</span> <span class=\"n\">Stream</span><span class=\"p\">()</span>\n<span class=\"n\">source</span><span class=\"p\">.</span><span class=\"n\">timed_window</span><span class=\"p\">(</span><span class=\"n\">interval</span><span class=\"o\">=</span><span class=\"mf\">0.050</span><span class=\"p\">)</span>  <span class=\"c1\"># Capture all records of the last 50ms into batches\n</span>      <span class=\"p\">.</span><span class=\"nb\">filter</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">)</span>                   <span class=\"c1\"># Remove empty batches\n</span>      <span class=\"p\">.</span><span class=\"nb\">map</span><span class=\"p\">(...)</span>                      <span class=\"c1\"># Do work on each batch\n</span>      <span class=\"p\">.</span><span class=\"nb\">buffer</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">)</span>                    <span class=\"c1\"># Allow ten batches to pile up here\n</span>      <span class=\"p\">.</span><span class=\"n\">sink</span><span class=\"p\">(</span><span class=\"n\">write_to_database</span><span class=\"p\">)</span>       <span class=\"c1\"># Potentially rate-limiting stage\n</span></code></pre></div></div>\n\n<p>I’ve written enough little utilities like <code class=\"language-plaintext highlighter-rouge\">timed_window</code> and <code class=\"language-plaintext highlighter-rouge\">buffer</code> to\ndiscover both that in a full system you would want more of these, and that they\nare easy to write.  Here is the definition of <code class=\"language-plaintext highlighter-rouge\">timed_window</code></p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">timed_window</span><span class=\"p\">(</span><span class=\"n\">Stream</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">interval</span><span class=\"p\">,</span> <span class=\"n\">child</span><span class=\"p\">,</span> <span class=\"n\">loop</span><span class=\"o\">=</span><span class=\"bp\">None</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">interval</span> <span class=\"o\">=</span> <span class=\"n\">interval</span>\n        <span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"nb\">buffer</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n        <span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">last</span> <span class=\"o\">=</span> <span class=\"n\">gen</span><span class=\"p\">.</span><span class=\"n\">moment</span>\n\n        <span class=\"n\">Stream</span><span class=\"p\">.</span><span class=\"n\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">child</span><span class=\"p\">,</span> <span class=\"n\">loop</span><span class=\"o\">=</span><span class=\"n\">loop</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">loop</span><span class=\"p\">.</span><span class=\"n\">add_callback</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">cb</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">update</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">who</span><span class=\"o\">=</span><span class=\"bp\">None</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"nb\">buffer</span><span class=\"p\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">last</span>\n\n    <span class=\"o\">@</span><span class=\"n\">gen</span><span class=\"p\">.</span><span class=\"n\">coroutine</span>\n    <span class=\"k\">def</span> <span class=\"nf\">cb</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">while</span> <span class=\"bp\">True</span><span class=\"p\">:</span>\n            <span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"nb\">buffer</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"nb\">buffer</span><span class=\"p\">,</span> <span class=\"p\">[]</span>\n            <span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">last</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">emit</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">)</span>\n            <span class=\"k\">yield</span> <span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">last</span>\n            <span class=\"k\">yield</span> <span class=\"n\">gen</span><span class=\"p\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">interval</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<p>If you are comfortable with Tornado coroutines or asyncio then my hope is that\nthis should feel natural.</p>\n\n<h2 id=\"recursion-and-feedback\">Recursion and Feedback</h2>\n\n<p>By connecting the sink of one stream to the emit function of another we can\ncreate feedback loops.  Here is stream that produces the Fibonnacci sequence.\nTo stop it from overwhelming our local process we added in a rate limiting step:</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">from</span> <span class=\"nn\">streams</span> <span class=\"kn\">import</span> <span class=\"n\">Stream</span>\n<span class=\"n\">source</span> <span class=\"o\">=</span> <span class=\"n\">Stream</span><span class=\"p\">()</span>\n<span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"n\">source</span><span class=\"p\">.</span><span class=\"n\">sliding_window</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">).</span><span class=\"nb\">map</span><span class=\"p\">(</span><span class=\"nb\">sum</span><span class=\"p\">)</span>\n<span class=\"n\">L</span> <span class=\"o\">=</span> <span class=\"n\">s</span><span class=\"p\">.</span><span class=\"n\">sink_to_list</span><span class=\"p\">()</span>  <span class=\"c1\"># store result in a list\n</span>\n<span class=\"n\">s</span><span class=\"p\">.</span><span class=\"n\">rate_limit</span><span class=\"p\">(</span><span class=\"mf\">0.5</span><span class=\"p\">).</span><span class=\"n\">sink</span><span class=\"p\">(</span><span class=\"n\">source</span><span class=\"p\">.</span><span class=\"n\">emit</span><span class=\"p\">)</span>  <span class=\"c1\"># pipe output back to input\n</span>\n<span class=\"n\">source</span><span class=\"p\">.</span><span class=\"n\">emit</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>  <span class=\"c1\"># seed with initial values\n</span><span class=\"n\">source</span><span class=\"p\">.</span><span class=\"n\">emit</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">L</span>\n<span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">]</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">L</span>  <span class=\"c1\"># wait a couple seconds, then check again\n</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"mi\">13</span><span class=\"p\">,</span> <span class=\"mi\">21</span><span class=\"p\">,</span> <span class=\"mi\">34</span><span class=\"p\">]</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">L</span>  <span class=\"c1\"># wait a couple seconds, then check again\n</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"mi\">13</span><span class=\"p\">,</span> <span class=\"mi\">21</span><span class=\"p\">,</span> <span class=\"mi\">34</span><span class=\"p\">,</span> <span class=\"mi\">55</span><span class=\"p\">,</span> <span class=\"mi\">89</span><span class=\"p\">]</span>\n</code></pre></div></div>\n\n<p><em>Note: due to the time rate-limiting functionality this example relied on an\nevent loop running somewhere in another thread.  This is the case for example\nin a Jupyter notebook, or if you have a Dask Client running.</em></p>\n\n<h2 id=\"things-that-this-doesnt-do\">Things that this doesn’t do</h2>\n\n<p>If you are familiar with streaming systems then you may say the following:</p>\n\n<p><em>Lets not get ahead of ourselves; there’s way more to a good streaming\nsystem than what is presented here.  You need to handle parallelism, fault\ntolerance, out-of-order elements, event/processing times, etc..</em></p>\n\n<p>… and you would be entirely correct.  What is presented here is not in any\nway a competitor to existing systems like Flink for production-level data\nengineering problems.  There is a <em>lot</em> of logic that hasn’t been built here\n(and its good to remember that this project was built at night over a week).</p>\n\n<p>Although some of those things, and in particular the distributed computing\nbits, we may get for free.</p>\n\n<h2 id=\"distributed-computing\">Distributed computing</h2>\n\n<p>So, during the day I work on <a href=\"http://dask.pydata.org/en/latest/\">Dask</a>, a\nPython library for parallel and distributed computing.  The core task\nschedulers within Dask are more than capable of running these kinds of\nreal-time computations.  They handle far more complex real-time systems every\nday including few-millisecond latencies, node failures, asynchronous\ncomputation, etc..  People use these features today inside companies, but they\ntend to roll their own system rather than use a high-level API (indeed, they\nchose Dask because their system was complex enough or private enough that\nrolling their own was a necessity).  Dask lacks any kind of high-level\nstreaming API today.</p>\n\n<p>Fortunately, the system we described above can be modified fairly easily to use\na Dask Client to submit functions rather than run them locally.</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">from</span> <span class=\"nn\">dask.distributed</span> <span class=\"kn\">import</span> <span class=\"n\">Client</span>\n<span class=\"n\">client</span> <span class=\"o\">=</span> <span class=\"n\">Client</span><span class=\"p\">()</span>       <span class=\"c1\"># start Dask in the background\n</span>\n<span class=\"n\">source</span><span class=\"p\">.</span><span class=\"n\">to_dask</span><span class=\"p\">()</span>\n      <span class=\"p\">.</span><span class=\"n\">scatter</span><span class=\"p\">()</span>        <span class=\"c1\"># send data to a cluster\n</span>      <span class=\"p\">.</span><span class=\"nb\">map</span><span class=\"p\">(...)</span>         <span class=\"c1\"># this happens on the cluster\n</span>      <span class=\"p\">.</span><span class=\"n\">accumulate</span><span class=\"p\">(...)</span>  <span class=\"c1\"># this happens on the cluster\n</span>      <span class=\"p\">.</span><span class=\"n\">gather</span><span class=\"p\">()</span>         <span class=\"c1\"># gather results back to local machine\n</span>      <span class=\"p\">.</span><span class=\"n\">sink</span><span class=\"p\">(...)</span>        <span class=\"c1\"># This happens locally\n</span></code></pre></div></div>\n\n<h2 id=\"other-things-that-this-doesnt-do-but-could-with-modest-effort\">Other things that this doesn’t do, but could with modest effort</h2>\n\n<p>There are a variety of ways that we could improve this with modest cost:</p>\n\n<ol>\n  <li><strong>Streams of sequences</strong>:  We can be more efficient if we pass not individual\nelements through a Stream, but rather lists of elements.  This will let us\nlose the microseconds of overhead that we have now per element and let us\noperate at pure Python (100ns) speeds.</li>\n  <li><strong>Streams of NumPy arrays / Pandas dataframes</strong>:  Rather than pass individual\nrecords we might pass bits of Pandas dataframes through the stream.  So for\nexample rather than filtering elements we would filter out rows of the\ndataframe.  Rather than compute at Python speeds we can compute at C\nspeeds.  We’ve built a lot of this logic before for dask.dataframe.  Doing\nthis again is straightforward but somewhat time consuming.</li>\n  <li><strong>Annotate elements</strong>: we want to pass through event time, processing time, and\npresumably other metadata</li>\n  <li><strong>Convenient Data IO utilities</strong>:  We would need some convenient way to move\ndata in and out of Kafka and other common continuous data streams.</li>\n</ol>\n\n<p>None of these things are hard.  Many of them are afternoon or weekend projects\nif anyone wants to pitch in.</p>\n\n<h2 id=\"reasons-i-like-this-project\">Reasons I like this project</h2>\n\n<p>This was originally built strictly for educational purposes.  I (and hopefully\nyou) now know a bit more about streaming systems, so I’m calling it a success.\nIt wasn’t designed to compete with existing streaming systems, but still there\nare some aspects of it that I like quite a bit and want to highlight.</p>\n\n<ol>\n  <li><strong>Lightweight setup:</strong> You can import it and go without setting up any\ninfrastructure.  It <em>can</em> run (in a limited way) on a Dask cluster or on an\nevent loop, but it’s also fully operational in your local Python thread.\nThere is no magic in the common case.  Everything up until time-handling\nruns with tools that you learn in an introductory programming class.</li>\n  <li>\n    <p><strong>Small and maintainable:</strong> <a href=\"https://github.com/mrocklin/streams\">The codebase</a> is currently a few hundred lines.\nIt is also, I claim, easy for other people to understand.  Here is the code\nfor filter:</p>\n\n    <div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">filter</span><span class=\"p\">(</span><span class=\"n\">Stream</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">predicate</span><span class=\"p\">,</span> <span class=\"n\">child</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">predicate</span> <span class=\"o\">=</span> <span class=\"n\">predicate</span>\n        <span class=\"n\">Stream</span><span class=\"p\">.</span><span class=\"n\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">child</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">update</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">who</span><span class=\"o\">=</span><span class=\"bp\">None</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">predicate</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span>\n            <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">emit</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n</code></pre></div>    </div>\n  </li>\n  <li><strong>Composable with Dask:</strong> Handling distributed computing is tricky to do\nwell.  Fortunately this project can offload much of that worry to Dask.\nThe dividing line between the two systems is pretty clear and, I think,\ncould lead to a decently powerful and maintainable system if we spend time\nhere.</li>\n  <li><strong>Low performance overhead:</strong> Because this project is so simple it has\noverheads in the few-microseconds range when in a single process.</li>\n  <li><strong>Pythonic:</strong> All other streaming systems were originally designed for\nJava/Scala engineers.  While they have APIs that are clearly well thought\nthrough they are sometimes not ideal for Python users or common Python\napplications.</li>\n</ol>\n\n<h2 id=\"future-work\">Future Work</h2>\n\n<p>This project needs both users and developers.</p>\n\n<p>I find it fun and satisfying to work on and so encourage others to play around.\n<a href=\"https://github.com/mrocklin/streams\">The codebase</a> is short and, I think,\neasily digestible in an hour or two.</p>\n\n<p>This project was built without a real use case (see the project’s <a href=\"https://github.com/mrocklin/streams/tree/master/examples\">examples\ndirectory</a> for a\nbasic Daskified web crawler).  It could use patient users with real-world use\ncases to test-drive things and hopefully provide PRs adding necessary features.</p>\n\n<p>I genuinely don’t know if this project is worth pursuing.  This blogpost is a\ntest to see if people have sufficient interest to use and contribute to such a\nlibrary or if the best solution is to carry on with any of the fine solutions\nthat already exist.</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>pip install git+https://github.com/mrocklin/streams\n</code></pre></div></div>"
}