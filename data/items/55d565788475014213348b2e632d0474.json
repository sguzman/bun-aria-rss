{
  "guid": "tag:blogger.com,1999:blog-6300367579216018061.post-2426424856649856926",
  "pubDate": "Tue, 19 Apr 2016 13:57:00 +0000",
  "atom:updated": "2016-08-30T18:18:41.945-07:00",
  "category": [
    "cloud native java",
    "data",
    "docker",
    "event sourcing",
    "eventual consistency",
    "microservices",
    "reactive streaming",
    "reactor",
    "spring boot",
    "spring cloud"
  ],
  "title": "Event Sourcing in Microservices Using Spring Cloud and Reactor",
  "description": "<link rel=\"stylesheet\" href=\"https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans:400,700\"><style>.hljs-title, .hljs-id, .scss .hljs-preprocessor {    font-weight: 400 !important; } .hljs-class .hljs-title, .hljs-type, .vhdl .hljs-literal, .tex .hljs-command {    font-weight: 400 !important; } .hljs-keyword, .css .rule .hljs-keyword, .hljs-winutils, .nginx .hljs-title, .hljs-subst, .hljs-request, .hljs-status {    font-weight: 400 !important; } .sect1{padding-bottom:0!important} .sect1+.sect1{border:0!important} .conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:\"Open Sans\",\"DejaVu Sans\",sans-serif;font-style:normal;font-weight:bold} .conum[data-value] *{color:#fff!important} .conum[data-value]+b{display:none} .conum[data-value]:after{content:attr(data-value)} .fa-caret-up {     color: green;     text-shadow: 1px 1px 1px #ccc;     font-size: 1.75em !important; }  .fa-caret-down {     color: red;     text-shadow: 1px 1px 1px #ccc;     font-size: 1.75em !important; }  .fa-minus {     color: #999;     text-shadow: 1px 1px 1px #ccc;     font-size: 1em !important; }  .fa-plus {     font-size: 1em !important;     color: green;     text-shadow: 1px 1px 1px #ccc; }   @media screen and (min-width: 768px) { .table-responsive { font-size: 0.8em; max-width: 50em; } }  @media screen and (max-width: 768px) {     .table-responsive {     font-size: 0.65em; } }  .table-responsive th, .table-responsive tr, .table-responsive td { padding: 4px 4px 4px 4px !important; } p {     margin-bottom: 1.25em !important; line-height: 1.4; } li p { line-height: 1.4 !important; margin: 0 !important; } .blog-post-asciidoc .content img {  max-height: none; } .admonitionblock > table {     background: rgba(0, 0, 0, 0) none repeat scroll 0 0;     border: 0 none;     border-collapse: separate;     width: 100%; } table {     background: #fff none repeat scroll 0 0;     border: 1px solid #dedede;     margin-bottom: 1.25em; } pre .conum[data-value]{position:relative;top:-.125em} b.conum *{color:inherit!important} .conum:not([data-value]):empty{display:none} .hdlist>table,.colist>table{border:0;background:none} .hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none} td.hdlist1{padding-right:.75em;font-weight:bold} td.hdlist1,td.hdlist2{vertical-align:top} .literalblock+.colist,.listingblock+.colist{margin-top:-.5em} .colist>table tr>td:first-of-type{padding:0 .75em;line-height:1} .colist>table tr>td:last-of-type{padding:.25em 0} h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h3,h4,h6{font-family:\"Open Sans\",sans-serif;font-style:normal;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;} .blog-post-asciidoc p{margin-bottom:1.25rem} @media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}.sect1+.sect1{border-top:1px solid #efefed} pre, pre > code {     -moz-osx-font-smoothing: auto;     color: rgba(0, 0, 0, 0.9);     font-family: monospace,monospace;     font-weight: 400;     line-height: 1.45;     text-rendering: optimizelegibility; } .blog-post-asciidoc code,kbd,pre,samp{font-size:.9em;font-weight:400;} .blog-post-asciidoc .admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%} .blog-post-asciidoc .admonitionblock>table td.icon{text-align:center;width:80px} .blog-post-asciidoc .admonitionblock>table td.icon img{max-width:none} .blog-post-asciidoc .admonitionblock>table td.icon .title{font-weight:bold;font-family:\"Open Sans\",\"DejaVu Sans\",sans-serif;text-transform:uppercase} .blog-post-asciidoc .admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)} .blog-post-asciidoc .admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0} .blog-post-asciidoc .admonitionblock td.icon [class^=\"fa icon-\"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default} .blog-post-asciidoc .admonitionblock td.icon .icon-note:before{content:\"\\f05a\";color:#19407c} .blog-post-asciidoc .admonitionblock td.icon .icon-tip:before{content:\"\\f0eb\";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111} .blog-post-asciidoc .admonitionblock td.icon .icon-warning:before{content:\"\\f071\";color:#bf6900} .blog-post-asciidoc .admonitionblock td.icon .icon-caution:before{content:\"\\f06d\";color:#bf3400} .blog-post-asciidoc .admonitionblock td.icon .icon-important:before{content:\"\\f06a\";color:#bf0000} #personDataTable td {     vertical-align: middle; } .rank-col {     text-align: center; } #personDataTable img {     max-width: 35px;     padding: 0; } .table-responsive {     font-weight: 400; } .table > thead > tr > th {     border-bottom: 2px solid #ddd;     font-weight: 400;     padding: 8px !important;     vertical-align: bottom; } .table-responsive {     font-family: Helvetica,sans-serif; } .exampleblock pre {     margin-top: auto; } .exampleblock .content {     margin-top: auto; } blockquote {     border-left: 5px solid #eee;     color: #666;     font-size: 16px;     margin: 0;     padding: 10px 20px; } .attribution {     font-size: small;     text-align: right; } .table-responsive p { margin: 0 !important; } p.tableblock {   font-size: 14px;   margin: 0 !important; } table.tableblock { max-width: 100%; border-collapse: separate; } table.tableblock td > .paragraph:last-child p > p:last-child, table.tableblock th > p:last-child, table.tableblock td > p:last-child { margin-bottom: 0; }  table.tableblock, th.tableblock, td.tableblock { border: 0 solid #dddddd; }  table.grid-all th.tableblock, table.grid-all td.tableblock { border-width: 0 1px 1px 0; }  table.grid-all tfoot > tr > th.tableblock, table.grid-all tfoot > tr > td.tableblock { border-width: 1px 1px 0 0; }  table.grid-cols th.tableblock, table.grid-cols td.tableblock { border-width: 0 1px 0 0; }  table.grid-all * > tr > .tableblock:last-child, table.grid-cols * > tr > .tableblock:last-child { border-right-width: 0; }  table.grid-rows th.tableblock, table.grid-rows td.tableblock { border-width: 0 0 1px 0; }  table.grid-all tbody > tr:last-child > th.tableblock, table.grid-all tbody > tr:last-child > td.tableblock, table.grid-all thead:last-child > tr > th.tableblock, table.grid-rows tbody > tr:last-child > th.tableblock, table.grid-rows tbody > tr:last-child > td.tableblock, table.grid-rows thead:last-child > tr > th.tableblock { border-bottom-width: 0; }  table.grid-rows tfoot > tr > th.tableblock, table.grid-rows tfoot > tr > td.tableblock { border-width: 1px 0 0 0; }  table.frame-all { border-width: 1px; }  table.frame-sides { border-width: 0 1px; }  table.frame-topbot { border-width: 1px 0; }  th.halign-left, td.halign-left { text-align: left; }  th.halign-right, td.halign-right { text-align: right; }  th.halign-center, td.halign-center { text-align: center; }  th.valign-top, td.valign-top { vertical-align: top; }  th.valign-bottom, td.valign-bottom { vertical-align: bottom; }  th.valign-middle, td.valign-middle { vertical-align: middle; }  table thead th, table tfoot th { font-weight: bold; }  tbody tr th { display: table-cell; line-height: 1.4; background: whitesmoke; }  tbody tr th, tbody tr th p, tfoot tr th, tfoot tr th p { color: #222222; font-weight: bold; }  p.tableblock > code:only-child { background: none; padding: 0; }  table tr.even, table tr.alt, table tr:nth-of-type(2n) {     background: #f9f9f9 none repeat scroll 0 0; } div.table-responsive {  border: 0; }  .sql p {  font-family: courier; } </style><link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.2.0/css/font-awesome.min.css\"><div id=\"content\" class=\"blog-post-asciidoc\"> <div id=\"preamble\"><div class=\"sectionbody\"><div class=\"paragraph\"><p>When building applications in a microservice architecture, managing state becomes a distributed systems problem. Instead of being able to manage state as transactions inside the boundaries of a single monolithic application, a microservice must be able to manage consistency using transactions that are distributed across a network of many different applications and databases.</p></div><div class=\"paragraph\"><p>In this article we will explore the problems of data consistency and high availability in microservices. We will start by taking a look at some of the important concepts and themes behind handling data consistency in distributed systems.</p></div><div class=\"paragraph\"><p>Throughout this article we will use a <a href=\"https://github.com/kbastani/spring-cloud-event-sourcing-example\" target=\"_blank\">reference application of an online store</a> that is built with microservices using <a href=\"http://projects.spring.io/spring-boot/\" target=\"_blank\">Spring Boot</a> and <a href=\"http://projects.spring.io/spring-cloud/\" target=\"_blank\">Spring Cloud</a>. We’ll then look at how to use <a href=\"http://www.reactive-streams.org/\" target=\"_blank\">reactive streams</a> with <a href=\"https://projectreactor.io/\" target=\"_blank\">Project Reactor</a> to implement event sourcing in a microservice architecture. Finally, we’ll use <a href=\"https://www.docker.com/\" target=\"_blank\">Docker</a> and Maven to build, run, and orchestrate the multi-container reference application.</p></div></div></div><div class=\"sect2\"><h3 id=\"_eventual_consistency\">Eventual Consistency</h3><div class=\"paragraph\"><p>When building microservices, we are forced to start reasoning about state in an architecture where data is eventually consistent. This is because each microservice exclusively exposes resources from a database that it owns. Further, each of these databases would be configured for high availability, with different consistency guarantees for each type of database.</p></div><div class=\"paragraph\"><p><a href=\"https://en.wikipedia.org/wiki/Eventual_consistency\" target=\"_blank\">Eventual consistency</a> is a model that is used to describe some operations on data in a distributed system—where state is replicated and stored across multiple nodes of a network. Typically, eventual consistency is talked about when running a database in <a href=\"https://en.wikipedia.org/wiki/High_availability\" target=\"_blank\">high availability mode</a>, where replicas are maintained by coordinating writes between multiple nodes of a database cluster. The challenge of the database cluster is that writes must be coordinated to all replicas in the exact order that they were received. When this happens, each replica is considered to be eventually consistent—that the state of all replicas are guaranteed to converge towards a consistent state at some point in the future.</p></div><div class=\"paragraph\"><p>When first building microservices, eventual consistency is a frequent point of contention between developers, DBAs, and architects. The head scratching starts to occur more frequently when the architecture design discussions begin to turn to the topic of data and handling state in a distributed system. The head scratching usually boils down to one question.</p></div><div class=\"quoteblock\"><blockquote><div class=\"paragraph\"><p>How can we guarantee high availability while also guaranteeing data consistency?</p></div></blockquote></div><div class=\"paragraph\"><p>To answer this question we need to understand how to best handle transactions in a distributed system. It just so happens that most distributed databases have this problem nailed down with a healthy helping of science.</p></div></div><div class=\"sect2\"><h3 id=\"_transaction_logs\">Transaction Logs</h3><div class=\"paragraph\"><p>Mostly all databases today support some form of high availability clustering. Most database products will provide a list of easy to understand guarantees about a system’s consistency model. A first step to achieving safety guarantees for stronger consistency models is to maintain an ordered log of database transactions. This approach is pretty simple in theory. A transaction log is an ordered record of all updates that were transacted by the database. When transactions are replayed in the exact order they were recorded, an exact replica of a database can be generated.</p></div><div style=\"display: block;\" class=\"imageblock\"><div style=\"text-align: center; margin: auto;\" class=\"content\"><img style=\"margin: auto !important;\" src=\"http://imgur.com/1KWW64x.png\" alt=\"Eventual consistency diagram\" width=\"100%\"></div></div><div class=\"paragraph\"><p>The diagram above represents three databases in a cluster that are replicating data using a shared transaction log. The zipper labeled <em>Primary</em> is the authority in this case and has the most current view of the database. The difference between the zippers represent the consistency of each replica, and as the transactions are replayed, each replica converges to a consistent state with the <em>Primary</em>. The basic idea here is that with eventual consistency, all zippers will eventually be zipped all the way up.</p></div><a name='more'></a><div class=\"paragraph\"><p>The transaction logs that databases use actually have deep roots in history that pre-dates computing. The fundamental approach for managing an ordered log of transactions was first used by Venetian merchants as far back as the <em>15th century</em>. The method that these Venetian merchants started using was called the <a href=\"https://en.wikipedia.org/wiki/Double-entry_bookkeeping_system\" target=\"_blank\">double-entry bookkeeping system</a>—which is a system of bookkeeping that requires two side-by-side entries for each transaction. For each of these transactions, both a credit and a debit are specified from an origin account to a destination account. To calculate the balance of an account, any merchant could simply replicate the current state of all accounts by replaying the events recorded in the ledger. This same fundamental practice of bookkeeping is still used today, and to some extent its a basic concept for transaction management in modern database systems.</p></div><div class=\"paragraph\"><p>For databases that claim to have eventual consistency, it’s guaranteed that each node in the database cluster will converge towards a globally consistent state by simply replaying the transaction log that resulted from a merge of write transactions across replicas. This claim, however, is only a guarantee of a database’s <em>liveness</em> properties, ignoring any guarantees about its <em>safety</em> properties. The difference between <em>safety</em> and <em>liveness</em> here is that with eventual consistency we can only be guaranteed that all updates will be observed eventually, with no guarantee about correctness.</p></div><div class=\"paragraph\"><p>Most content available today that attempts to educate us on the benefits of microservices will contain a very sparse explanation behind the saying that \"<em>microservices use eventual consistency</em>\"—sometimes referencing <a href=\"https://en.wikipedia.org/wiki/CAP_theorem\" target=\"_blank\">CAP theorem</a> to bolster any sense of existing confusion. This tends to be a shallow explanation that leads to more questions than answers. A more appropriate explanation of eventual consistency in microservices would be the following statement.</p></div><div class=\"quoteblock\"><blockquote><div class=\"paragraph\"><p>Microservice architectures provide no guarantees about the correctness of your data.</p></div></blockquote></div><div class=\"paragraph\"><p>The only consistency guarantee you’ll get with microservices is that all microservices will eventually agree on something—<em>correct or not</em>.</p></div><div class=\"paragraph\"><p>Cutting through the vast hype that exists on the road to building microservices is not only important, it is an assured eventuality that all developers must face. This is because when it comes to building software, a distributed system is a <em>distributed system</em>. A collection of communicating microservices are no exception. The good news is, there are tried and true patterns for how to successfully build and maintain complex distributed systems, and that’s the main theme of the rest of this article.</p></div></div><div class=\"sect2\"><h3 id=\"_event_sourcing\">Event Sourcing</h3><div class=\"paragraph\"><p><a href=\"http://martinfowler.com/eaaDev/EventSourcing.html\" target=\"_blank\">Event sourcing</a> is a method of data persistence that borrows similar ideas behind a database’s transaction log. For event sourcing, the unit of a transaction becomes much more granular, using a sequence of ordered events to represent the state of a domain object stored in a database. Once an event has been added to to the event log, it cannot be removed or re-ordered. Events are considered to be <em>immutable</em> and the sequence of events that are stored are append-only.</p></div><div class=\"paragraph\"><p>There are multiple benefits for handling state in a microservice architecture using event sourcing.</p></div><div class=\"ulist\"><ul><li><p><em>Aggregates</em> can be used to generate the consistent state of any object</p></li><li><p>It provides an <em>audit trail</em> that can be replayed to generate the state of an object from any point in time</p></li><li><p>It provides the many inputs necessary for analyzing data using <a href=\"https://en.wikipedia.org/wiki/Event_stream_processing\" target=\"_blank\"><em>event stream processing</em></a></p></li><li><p>It enables the use of <a href=\"https://en.wikipedia.org/wiki/Compensating_transaction\" target=\"_blank\"><em>compensating transactions</em></a> to rollback events leading to an inconsistent application state</p></li><li><p>It also avoids complex synchronization between microservices, paving the way for asynchronous <em>non-blocking operations</em> between microservices</p></li></ul></div><div class=\"paragraph\"><p>In this article we’re going to look at a JVM-based implementation of event sourcing that uses Spring Cloud and Spring Boot. As with <a href=\"http://www.kennybastani.com/search/label/spring%20cloud\" target=\"_blank\">most of the articles you’ll find on this blog</a>, we’re going to take a tour of a realistic sample application that you can run and deploy. This time I’ve put together an example of an end-to-end cloud native application using microservices. I’ve even included an <a href=\"https://angularjs.org/\" target=\"_blank\">AngularJS</a> frontend, <a href=\"https://spring.io/guides/tutorials/spring-security-and-angular-js/\" target=\"_blank\">thanks to some very clever ground work</a> by <a href=\"https://spring.io/team/dsyer/\" target=\"_blank\">Dr. Dave Syer</a> on the Spring Engineering team. <em>(Thanks Dr. Syer!)</em></p></div></div><div class=\"sect1\"><h2 id=\"_reference_application\">Reference Application</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p>As I mentioned earlier, this reference application was designed as a cloud native application. Cloud native applications and architectures are designed and built using a set of standard methodologies that maximize the utility of a cloud platform. Cloud native applications use something called <a href=\"http://12factor.net/\" target=\"_blank\"><em>twelve-factor application methodology</em></a>. The twelve-factor methodology is a set of practices and useful guidelines that were compiled by the engineers behind Heroku, which have become a standard reference for creating applications suitable to be deployed to a cloud platform.</p></div><div class=\"paragraph\"><p>Cloud native application architectures will typically embrace scale-out infrastructure principles, such as horizontal scaling of applications and databases. Applications also focus on building in resiliency and auto-healing to prevent downtime. Through the use of a platform, availability can be automatically adjusted as necessary using a set of policies. Also, load balancing for services are shifted to the client-side, and handled between applications, preventing the need to configure load balancers for new application instances.</p></div><div class=\"sect2\"><h3 id=\"_online_store_web\">Online Store Web</h3><div class=\"paragraph\"><p>I’ve taken big leaps from the other microservice reference applications you’ll find here on this blog. This application was created to demonstrate a fully formed microservice architecture that implements the core functionality of an online store.</p></div><div style=\"display: block;\" class=\"imageblock\"><div style=\"text-align: center; margin: auto;\" class=\"content\"><img style=\"margin: auto !important;\" src=\"http://imgur.com/zqzmAzi.png\" alt=\"Online store microservice architecture\" width=\"100%\"></div></div><div class=\"paragraph\"><p>Users of this online store application will be interacting with a front-end website that is hosted on <a href=\"https://github.com/kbastani/spring-cloud-event-sourcing-example/tree/master/online-store-web\" target=\"_blank\">Online Store Web</a>, which is a Spring Boot application, and is the service colored purple in the diagram above. This application houses the static content of an AngularJS site.</p></div><div class=\"paragraph\"><p>The main challenge with writing a front-end application on a back-end of microservices, when using a client-side JavaScript framework like AngularJS, is how to safely expose REST APIs on the same host that houses the static JS content. We need to solve this challenge in order to prevent security vulnerabilities that could result from making our back-end REST APIs publicly accessible from multiple domains. If we were to host these microservices on separate domains, we would be required to enable <a href=\"https://en.wikipedia.org/wiki/Cross-origin_resource_sharing\" target=\"_blank\"><em>Cross-origin resource sharing</em></a> (CORS), which would make our application’s backend vulnerable to various forms of attack.</p></div><div class=\"paragraph\"><p>In order to solve the problem of CORS, we have a suite of excellent tools at our disposal, all of which are a part of the <em>Spring Cloud</em> project ecosystem.</p></div></div><div class=\"sect2\"><h3 id=\"_spring_cloud_backing_services\">Spring Cloud Backing Services</h3><div class=\"paragraph\"><p>Looking back at the reference architecture’s diagram, we see that <code>Online Store Web</code> has direct HTTP connections to 4 other applications in the middle layer. These services are:</p></div><div class=\"ulist\"><ul><li><p><a href=\"https://github.com/kbastani/spring-cloud-event-sourcing-example/tree/master/user-service\" target=\"_blank\">User Service</a></p></li><li><p><a href=\"https://github.com/kbastani/spring-cloud-event-sourcing-example/tree/master/edge-service\" target=\"_blank\">Edge Service</a></p></li><li><p><a href=\"https://github.com/kbastani/spring-cloud-event-sourcing-example/tree/master/discovery-service\" target=\"_blank\">Discovery Service</a></p></li><li><p><a href=\"https://github.com/kbastani/spring-cloud-event-sourcing-example/tree/master/config-service\" target=\"_blank\">Configuration Server</a></p></li></ul></div><div style=\"display: block;\" class=\"imageblock\"><div style=\"text-align: center; margin: auto;\" class=\"content\"><img style=\"margin: auto !important;\" src=\"http://imgur.com/yFKE0re.png\" alt=\"Spring Cloud services\" width=\"100%\"></div></div><div class=\"paragraph\"><p>Each of these Spring Boot applications are considered to be <em>backing services</em> to the <code>Online Store Web</code> application. The <a href=\"http://12factor.net/backing-services\" target=\"_blank\"><em>Backing service</em></a> is a term that was popularized in the twelve-factor methodology. The premise is that there are third-party service dependencies that should be treated as attached resources to your cloud native applications. The key trait of backing services are that they are provided as bindings to an application in its deployment environment by a cloud platform.</p></div><div class=\"paragraph\"><p>The 4 backing services in the diagram will be bound to the <code>Online Store Web</code> when it is run in the deployment’s target environment. A cloud platform, such as the popular open source <a href=\"https://www.cloudfoundry.org/\" target=\"_blank\">PaaS Cloud Foundry</a>, will <a href=\"http://docs.cloudfoundry.org/services/binding-credentials.html\" target=\"_blank\">provide the application with secure credentials</a> and URIs as externalized configuration properties that take the form of injected <em>environment variables</em>.</p></div><div class=\"paragraph\"><p>The reason these backing services differ from the bottom layer in the diagram is that each of the backing services must be located using a statically defined route that can be injected as an environment variable to the <code>Online Store Web</code> application’s container. Backing services always have this defining trait. This approach is considered a standard practice for providing a production application with secure credentials to connect to a database or service. The rule here is: if it cannot be discovered using a discovery service and has a statically defined route that one of your application deployments will depend on, then it’s considered to be a backing service for that environment.</p></div><div class=\"paragraph\"><p>Going back to the diagram, the services in the bottom layer do not need to have any statically defined route to be located. As long as the four backing services are locatable with an address, the bottom layer services can all be discovered through the backing services using the <code>Discovery Service</code> and the <code>Edge Service</code>.</p></div><div class=\"sect3\"><h4 id=\"_user_service\">User Service</h4><div class=\"paragraph\"><p>The <code>User Service</code> is the authentication gateway that protects back-end resources in the application’s microservice architecture. There are two methods in which resources are exposed to a front-end application: protected and unprotected. A protected resource is one that requires user-level authentication. An unprotected resource is usually a read-only set of resources that can be viewed by users who are not authenticated, such as a product catalog.</p></div><div style=\"display: block;\" class=\"imageblock\"><div style=\"text-align: center; margin: auto;\" class=\"content\"><img style=\"margin: auto !important;\" src=\"http://i.imgur.com/7ha54Ka.png\" alt=\"User service\" width=\"100%\"></div></div><div class=\"paragraph\"><p>The <code>User Service</code> also houses a <a href=\"http://cloud.spring.io/spring-cloud-security/\" target=\"_blank\"><em>Spring Cloud OAuth2</em></a> authorization server as well as a resource server. It is this service that all other applications in the target environment will be able to use to retrieve and validate token information. The token information that is validated will automatically be provided in the headers of requests to protected resources and used to authenticate a user’s session.</p></div><div class=\"paragraph\"><p>If the user does not provide authentication details in the header of a request to protected resources, they will be redirected to the <code>User Service</code> login page where they will be able to sign in securely and authorize a grant to obtain an access token.</p></div></div><div class=\"sect3\"><h4 id=\"_edge_service\">Edge Service</h4><div class=\"paragraph\"><p>The <code>Edge Service</code> is a Spring Cloud application that is responsible for securely exposing HTTP routes from backend microservices. The <code>Edge Service</code> is a very important component in a Spring Cloud microservices architecture, as it provides frontend applications a way to expose every API from the backend services as a single unified REST API.</p></div><div style=\"display: block;\" class=\"imageblock\"><div style=\"text-align: center; margin: auto;\" class=\"content\"><img style=\"margin: auto !important;\" src=\"http://i.imgur.com/n443oQx.png\" alt=\"Edge service\" width=\"100%\"></div></div><div class=\"paragraph\"><p>To take advantage of the <code>Edge Service</code>, a Spring Boot application would simply attach it as a backing service in the target environment. In doing this, the <code>Edge Service</code> will provide secure authenticated access to all REST APIs that are exposed by the backend services. To be able to do this, the <code>Edge Service</code> matches a request route’s URL fragment from a front-end application to a back-end microservice through a reverse proxy to retrieve the remote REST API response.</p></div><div class=\"paragraph\"><p>The end result is that the <code>Edge Service</code> provides a seamless REST API that will become embedded in any Spring Boot application that attaches it as a backing service using <a href=\"http://cloud.spring.io/spring-cloud-netflix/spring-cloud-netflix.html#_router_and_filter_zuul\" target=\"_blank\">Spring Cloud Netflix’s Zuul</a> starter project.</p></div></div><div class=\"sect3\"><h4 id=\"_discovery_service\">Discovery Service</h4><div class=\"paragraph\"><p>The <code>Discovery Service</code> is a Spring Cloud application that is responsible for maintaining a registry of service information in a target environment. Each service application will subscribe to a <code>Discovery Service</code> application in the target environment at start-up. The subscribing application will then provide its local networking information, which includes its network address. By doing this, all other applications in the environment will be able to locate other subscribers by downloading a service registry and caching it locally. The local service registry will be used on an as-needed basis to retrieve the network address of other services that an application depends on in the target environment.</p></div><div style=\"display: block;\" class=\"imageblock\"><div style=\"text-align: center; margin: auto;\" class=\"content\"><img style=\"margin: auto !important;\" src=\"http://i.imgur.com/VM3Bduc.png\" alt=\"Discovery and config services\" width=\"100%\"></div></div></div><div class=\"sect3\"><h4 id=\"_configuration_server\">Configuration Server</h4><div class=\"paragraph\"><p>The <code>Configuration Server</code> is a Spring Cloud application that centralizes external configurations using various methodologies of building twelve-factor applications. The <a href=\"http://12factor.net/config\" target=\"_blank\">twelve-factor app stores configurations</a> in the environment and not in the project’s source code. This service will allow other applications to retrieve their tailored configurations for the target environment.</p></div></div></div></div></div><div class=\"sect1\"><h2 id=\"_backend_microservices\">Backend Microservices</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p>While the backing services in the middle layer are still considered to be microservices, they solve a set of concerns that are purely operational and security-related. The business logic of this application sits almost entirely in our bottom layer. These applications are designed around business capabilities of the fictitious online store, which I’ve gone ahead and branded as <em>Cloud Native Outfitters</em>–a hypothetical Silicon Valley startup that sells 4 really clever t-shirts and hoodies.</p></div><div class=\"paragraph\"><p>As a part of the business capabilities of the online store, we have the following 5 microservices that will serve as our backend REST API. The main consumer of these APIs is the <code>Online Store Web</code>, as well as other planned customer facing applications that may never see the light of day in the case that <em>Cloud Native Outfitters</em> is unable to secure a seed round of investment from one of the top-tier venture capital firms on Sand Hill Road.</p></div><div class=\"paragraph\"><p>Each of these microservices will be exposed as a seamless REST API via the <code>Edge Service</code> application in the middle layer. The <code>Edge Service</code> uses Spring Cloud Netflix’s Zuul proxy to map request routes from the <code>Online Store Web</code> application to the appropriate backend microservice’s REST API.</p></div><div class=\"paragraph\"><p>These applications can be found at:</p></div><div class=\"ulist\"><ul><li><p><a href=\"https://github.com/kbastani/spring-cloud-event-sourcing-example/tree/master/catalog-service\" target=\"_blank\">Catalog Service</a></p></li><li><p><a href=\"https://github.com/kbastani/spring-cloud-event-sourcing-example/tree/master/account-service\" target=\"_blank\">Account Service</a></p></li><li><p><a href=\"https://github.com/kbastani/spring-cloud-event-sourcing-example/tree/master/inventory-service\" target=\"_blank\">Inventory Service</a></p></li><li><p><a href=\"https://github.com/kbastani/spring-cloud-event-sourcing-example/tree/master/shopping-cart-service\" target=\"_blank\">Cart Service</a></p></li><li><p><a href=\"https://github.com/kbastani/spring-cloud-event-sourcing-example/tree/master/order-service\" target=\"_blank\">Order Service</a></p></li></ul></div><div style=\"display: block;\" class=\"imageblock\"><div style=\"text-align: center; margin: auto;\" class=\"content\"><img style=\"margin: auto !important;\" src=\"http://imgur.com/RRKoSI0.png\" alt=\"Online store microservice backend\" width=\"100%\"></div></div><div class=\"paragraph\"><p>A description of the role of each of these microservices is explained in the <a href=\"https://github.com/kbastani/spring-cloud-event-sourcing-example\" target=\"_blank\">GitHub repository for this sample project</a>. I’ll be regularly contributing to the applications in this project’s repository for future articles that will focus on more of the <a href=\"http://microservices.io\" target=\"_blank\">patterns and best practices of microservice architectures</a>.</p></div><div class=\"paragraph\"><p>The next part of this article is going to focus on the original topic of event sourcing in microservices using <em>Spring Boot</em>, <em>Spring Cloud</em>, and <em>Project Reactor</em>.</p></div></div></div><div class=\"sect1\"><h2 id=\"_project_reactor\">Project Reactor</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p><a href=\"http://projectreactor.io/\" target=\"_blank\">Project Reactor</a> is an open source library for building JVM applications based on the <a href=\"http://www.reactive-streams.org/\" target=\"_blank\">Reactive Streams Specification</a> and is a member of the Spring ecosystem of maintained open source libraries. The purpose of Reactor is to provide developers that are building JVM-based applications with a <em>Reactive</em> library that is dedicated to building non-blocking applications—and as a result help us tackle the problem of unnecessary latency.</p></div><div class=\"paragraph\"><p>It is very common for applications interfacing with microservices to call multiple other microservices during the same execution context. As we talked about earlier, one of the key traits of a microservice architecture is eventual consistency. While eventual consistency does not provide any guarantees about the safety of our data, it does provide us with the option to use asynchronous non-blocking operations when communicating with other microservices in the same execution context. This is where the Reactor libraries become very useful.</p></div><div class=\"paragraph\"><p>There are some rare situations, <em>if any</em>, where the state of a domain object must be shared across microservices. When using <em>Event Sourcing</em> in microservices we will only store a log of strictly ordered events. By taking this approach there should be very limited situations where there is a requirement to store the state of a domain object in a database. Instead, we are resolved to only store a stream of ordered events representing the aggregate state of an object. By doing this, it means we will have eliminated a majority of scenarios where we need to synchronize state with other microservices using RESTful APIs that use HTTP. These types of blocking operations are at the root of a variety of latency issues when communicating between microservices.</p></div><div class=\"sect2\"><h3 id=\"_event_sourcing_with_reactor_core\">Event Sourcing with Reactor Core</h3><div class=\"paragraph\"><p>One of the microservices in the online store is the <code>Shopping Cart Service</code>. Authenticated users browse the product catalog from the user interface of the <code>Online Store Web</code> application. The users are able to add and remove product line items from their shopping cart as well as clear their cart or checkout.</p></div><div style=\"display: block;\" class=\"imageblock\"><div style=\"text-align: center; margin: auto;\" class=\"content\"><img style=\"margin: auto !important;\" src=\"http://i.imgur.com/GNwbQzZ.png.png\" alt=\"Online store microservice backend\" width=\"100%\"></div></div><div class=\"paragraph\"><p>A user’s shopping cart paints a simple picture of how event sourcing works. The <code>Shopping Cart Service</code> is the owner of a MySQL database that has a table called <code>cart_event</code>. This table contains an ordered log of events that a user has generated in the response to an action, with the purpose of managing the items in their shopping cart.</p></div><div class=\"exampleblock\"><div class=\"title\">Example 1. <a href=\"https://github.com/kbastani/spring-cloud-event-sourcing-example/blob/master/shopping-cart-service/src/main/java/demo/cart/CartEventType.java\" target=\"_blank\">CartEventType.java</a></div><div class=\"content\"><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-java hljs\" data-lang=\"java\"><span class=\"hljs-comment\">// These will be the events that are stored in the event log for a cart</span><br /><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">enum</span> CartEventType {<br />    ADD_ITEM,<br />    REMOVE_ITEM,<br />    CLEAR_CART,<br />    CHECKOUT<br />}</code></pre></div></div></div></div><div class=\"paragraph\"><p>Let’s consider that the <code>CartEventType</code> is an enum that has a list of 4 different event types. Each of these event types represent an action performed by a user on their shopping cart. With event sourcing, these cart events can each impact the outcome of the final state of a user’s shopping cart. When a user adds or removes an item to their cart, the action produces an event that increments or decrements the aggregate quantity of a line item. When these events are replayed in the same order as they were received, a list of product line items are created, each with a corresponding quantity value.</p></div><div class=\"paragraph\"><p>The following table is an export of an event log that represents a user’s actions on their shopping cart.</p></div><div class=\"table-responsive\">  <table class=\"table table-striped\">  <tbody><tr><th>id</th><th>created_at</th><th>last_modified</th><th>cart_event_type</th><th>product_id</th><th>quantity</th><th>user_id</th></tr>  <tr><td>1</td><td>1460990971645</td><td>1460990971645</td><td>0</td><td>SKU-12464</td><td>2</td><td>0</td></tr>  <tr><td>2</td><td>1460992816398</td><td>1460992816398</td><td>1</td><td>SKU-12464</td><td>1</td><td>0</td></tr>  <tr><td>3</td><td>1460992826474</td><td>1460992826474</td><td>0</td><td>SKU-12464</td><td>2</td><td>0</td></tr>  <tr><td>4</td><td>1460992832872</td><td>1460992832872</td><td>0</td><td>SKU-12464</td><td>2</td><td>0</td></tr>  <tr><td>5</td><td>1460992836027</td><td>1460992836027</td><td>1</td><td>SKU-12464</td><td>5</td><td>0</td></tr>  </tbody></table>  </div><div class=\"paragraph\"><p>We see from this table that each row has a unique timestamp to ensure strict ordering. We also see an integer representing the 4 <code>CartEventType</code> enum types. There is also some meta-data that is stored in this table. The columns <code>product_id</code> and <code>quantity</code> are both used to generate the aggregate shopping cart and product line items.</p></div><div style=\"display: block;\" class=\"imageblock\"><div style=\"text-align: center; margin: auto;\" class=\"content\"><img style=\"margin: auto !important;\" src=\"http://i.imgur.com/QmAehTS.png.png\" alt=\"Online store microservice backend\" width=\"100%\"></div></div><div class=\"paragraph\"><p>The result of this is shown in the above screenshot. Here we see a user’s shopping cart that was generated as an aggregate object.</p></div><div class=\"sect3\"><h4 id=\"_choosing_an_event_store\">Choosing an Event Store</h4><div class=\"paragraph\"><p>There are many options available when choosing an appropriate storage option for event sourcing. Mostly all databases today that provide streaming query capabilities will work. There are however some popular open source projects that stand out for this use case. One example of a project that is increasingly becoming the standard for event sourcing architectures is <a href=\"http://kafka.apache.org/\" target=\"_blank\">Apache Kafka</a>, which is a subject of a future blog post. For this example we’re going to use MySQL, which is a fine choice for implementing event sourcing for an online shopping cart.</p></div><div class=\"admonitionblock tip\"><table><tbody><tr><td class=\"icon\"><i class=\"fa icon-tip\" title=\"Tip\"></i></td><td class=\"content\">The choice of technology for your event store will always depend on the volume of writes and the throughput of your database. A project like Apache Kafka was designed for this exact use case but it requires us to take on some additional operational responsibility to scale it in production, including running an <a href=\"https://zookeeper.apache.org/\" target=\"_blank\">Apache ZooKeeper</a> cluster. </td></tr></tbody></table></div></div><div class=\"sect3\"><h4 id=\"_generating_aggregates\">Generating Aggregates</h4><div class=\"paragraph\"><p>In the <code>Shopping Cart Service</code> we will provide a versioned REST API that implements a method for accepting new events from the <code>Online Store Web</code> application.</p></div><div class=\"exampleblock\"><div class=\"title\">Example 2. <a href=\"https://github.com/kbastani/spring-cloud-event-sourcing-example/blob/master/shopping-cart-service/src/main/java/demo/api/v1/ShoppingCartControllerV1.java#L25\" target=\"_blank\">ShoppingCartControllerV1.java</a></div><div class=\"content\"><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-java hljs\" data-lang=\"java\"><span class=\"hljs-annotation\">@RequestMapping</span>(path = <span class=\"hljs-string\">\"/events\"</span>, method = RequestMethod.POST)<br /><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> ResponseEntity <span class=\"hljs-title\">addCartEvent</span><span class=\"hljs-params\">(@RequestBody CartEvent cartEvent)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{<br />    <span class=\"hljs-keyword\">return</span> Optional.ofNullable(shoppingCartService.addCartEvent(cartEvent))<br />            .map(event -&gt; <span class=\"hljs-keyword\">new</span> ResponseEntity(HttpStatus.NO_CONTENT))<br />            .orElseThrow(() -&gt; <span class=\"hljs-keyword\">new</span> Exception(<span class=\"hljs-string\">\"Could not find shopping cart\"</span>));<br />}</code></pre></div></div></div></div><div class=\"paragraph\"><p>In the code example above we define a controller method for collecting new <code>CartEvent</code> objects from clients. The purpose of this method will be to append additional cart events to the event log in our <code>cart_event</code> table. The result is that when clients then call the REST API method for retrieving a user’s shopping cart, it will be generated as an aggregate that incorporates all cart events using reactive streaming.</p></div><div class=\"paragraph\"><p>The next step is generating the aggregate of cart events using Reactor.</p></div><div class=\"exampleblock\"><div class=\"title\">Example 3. <a href=\"https://github.com/kbastani/spring-cloud-event-sourcing-example/blob/master/shopping-cart-service/src/main/java/demo/api/v1/ShoppingCartServiceV1.java#L116\" target=\"_blank\">ShoppingCartServiceV1.java</a></div><div class=\"content\"><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-java hljs\" data-lang=\"java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> ShoppingCart <span class=\"hljs-title\">aggregateCartEvents</span><span class=\"hljs-params\">(User user, Catalog catalog)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{<br /><br />    <span class=\"hljs-comment\">// Create a reactive streams publisher by streaming ordered events from the database</span><br />    Flux&lt;CartEvent&gt; cartEvents =<br />            Flux.fromStream(cartEventRepository.getCartEventStreamByUser(user.getId()));<br /><br />    <span class=\"hljs-comment\">// Aggregate the current state of the shopping cart until arriving at a terminal state in the stream</span><br />    ShoppingCart shoppingCart = cartEvents<br />            .takeWhile(cartEvent -&gt; !ShoppingCart.isTerminal(cartEvent.getCartEventType()))<br />            .reduceWith(() -&gt; <span class=\"hljs-keyword\">new</span> ShoppingCart(catalog), ShoppingCart::incorporate)<br />            .get();<br /><br />    <span class=\"hljs-comment\">// Generate the list of line items in the cart from the aggregate</span><br />    shoppingCart.getLineItems();<br /><br />    <span class=\"hljs-keyword\">return</span> shoppingCart;<br />}</code></pre></div></div></div></div><div class=\"paragraph\"><p>In the code example above we see three steps to generate the shopping cart object and return it back to a client. The first step is to create a reactive stream from the data source of the event store for cart events. Once the stream has been established, we can begin to incorporate each event in the stream to generate our aggregate. The reactive stream that is created will take each event from the data store and mutate the state of the <code>ShoppingCart</code> until it eventually arrives at the terminating state, which gives us our final aggregate view of the user’s shopping cart.</p></div><div class=\"paragraph\"><p>In the reduce phase of the reactive stream’s aggregation we use a method called <code>incorporate</code> that belongs to the <code>ShoppingCart</code> class. This method accepts a <code>CartEvent</code> object which is used to mutate the state of the <code>ShoppingCart</code>.</p></div><div class=\"exampleblock\"><div class=\"title\">Example 4. <a href=\"https://github.com/kbastani/spring-cloud-event-sourcing-example/blob/master/shopping-cart-service/src/main/java/demo/cart/ShoppingCart.java#L77\" target=\"_blank\">ShoppingCart.java</a></div><div class=\"content\"><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-java hljs\" data-lang=\"java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> ShoppingCart <span class=\"hljs-title\">incorporate</span><span class=\"hljs-params\">(CartEvent cartEvent)</span> </span>{<br /><br />    <span class=\"hljs-comment\">// Remember that thing about safety properties in microservices?</span><br />    Flux&lt;CartEventType&gt; validCartEventTypes =<br />            Flux.fromStream(Stream.of(CartEventType.ADD_ITEM,<br />                    CartEventType.REMOVE_ITEM));<br /><br />    <span class=\"hljs-comment\">// The CartEvent's type must be either ADD_ITEM or REMOVE_ITEM</span><br />    <span class=\"hljs-keyword\">if</span> (validCartEventTypes.exists(cartEventType -&gt;<br />            cartEvent.getCartEventType().equals(cartEventType)).get()) {<br /><br />        <span class=\"hljs-comment\">// Update the aggregate view of each line item's quantity from the event type</span><br />        productMap.put(cartEvent.getProductId(),<br />                productMap.getOrDefault(cartEvent.getProductId(), <span class=\"hljs-number\">0</span>) +<br />                        (cartEvent.getQuantity() * (cartEvent.getCartEventType()<br />                                .equals(CartEventType.ADD_ITEM) ? <span class=\"hljs-number\">1</span> : -<span class=\"hljs-number\">1</span>)));<br />    }<br /><br />    <span class=\"hljs-comment\">// Return the updated state of the aggregate to the reactive stream's reduce method</span><br />    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>;<br />}</code></pre></div></div></div></div><div class=\"paragraph\"><p>In the code example above we see the implementation of the <code>incorporate</code> method for a <code>ShoppingCart</code>. Here we accept a <code>CartEvent</code> object and then take a very important step to ensure data safety by validating that the event’s type. This is where microservices need to be liberal with their unit testing to ensure that state mutation will ensure data correctness in an eventually consistent architecture. In this case, we ensure that the event types are either <code>ADD_ITEM</code> or <code>REMOVE_ITEM</code>.</p></div><div class=\"paragraph\"><p>The next step is to update the aggregate view of each line item in the shopping cart by mapping the corresponding event types to an increment or decrement value that can be applied to the line item’s quantity. Finally, we return the current view back to the client with the mutated state that resulted in incorporating the new event.</p></div></div></div></div></div><div class=\"sect1\"><h2 id=\"_docker_compose_demo\">Docker Compose Demo</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p>The example project uses <a href=\"https://docs.docker.com/compose/\" target=\"_blank\">Docker Compose</a> to build and run a container image of each of our microservices as a part of the Maven build process.</p></div><div class=\"sect2\"><h3 id=\"_getting_started\">Getting Started</h3><div class=\"paragraph\"><p>To get started, visit the <a href=\"https://github.com/kbastani/spring-cloud-event-sourcing-example\" target=\"_blank\">GitHub repository</a> for this example project.</p></div><div class=\"exampleblock\"><div class=\"content\"><div class=\"paragraph\"><p><a href=\"https://github.com/kbastani/spring-cloud-event-sourcing-example\" target=\"_blank\">https://github.com/kbastani/spring-cloud-event-sourcing-example</a></p></div></div></div><div class=\"paragraph\"><p>Clone or fork the project and download the repository to your machine. After downloading, you will need to use both Maven and Docker to compile and build the images locally.</p></div></div><div class=\"sect2\"><h3 id=\"_download_docker\">Download Docker</h3><div class=\"paragraph\"><p>First, download Docker if you haven’t already. Follow the <a href=\"https://www.docker.com/docker-toolbox\" target=\"_blank\">instructions found here</a>, to get Docker toolbox up and running on your development machine.</p></div><div class=\"paragraph\"><p>After you’ve installed Docker toolbox, run the following command to initialize a new virtualbox VM for this sample application.</p></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-bash hljs\" data-lang=\"bash\">$ docker-machine create event-source-demo --driver virtualbox --virtualbox-memory <span class=\"hljs-string\">\"11000\"</span> --virtualbox-disk-size <span class=\"hljs-string\">\"100000\"</span><br />$ <span class=\"hljs-built_in\">eval</span> <span class=\"hljs-string\">\"<span class=\"hljs-variable\">$(docker-machine env event-source-demo)</span>\"</span></code></pre></div></div></div><div class=\"sect2\"><h3 id=\"_requirements\">Requirements</h3><div class=\"paragraph\"><p>The requirements for running this demo on your machine are found below.</p></div><div class=\"ulist\"><ul><li><p>Maven 3</p></li><li><p>Java 8</p></li><li><p>Docker</p></li><li><p>Docker Compose</p></li></ul></div></div><div class=\"sect2\"><h3 id=\"_building_the_project\">Building the project</h3><div class=\"paragraph\"><p>To build the project, from the terminal, run the following command at the root of the project.</p></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-bash hljs\" data-lang=\"bash\">$ sh run.sh</code></pre></div></div><div class=\"paragraph\"><p>The project will then download all of the needed dependencies and compile each of the project artifacts. Each service will be built, and then a Maven Docker plugin will automatically build each of the images into your local Docker registry. Docker must be running and available from the command line where you run the <code>sh run.sh</code> command for the build to succeed.</p></div></div><div class=\"sect2\"><h3 id=\"_start_the_cluster_with_docker_compose\">Start the Cluster with Docker Compose</h3><div class=\"paragraph\"><p>Now that each of the images has been built successfully, we can using Docker Compose to spin up our cluster. The <code>run.sh</code> script will build each of the projects and Docker containers which will be used by Docker Compose to start each of the services. The services that need to be started first are the <code>Configuration Service</code> and the <code>Discovery Service</code>. The rest of the services will then begin to start up and eventually begin to communicate with each other.</p></div><div class=\"admonitionblock caution\"><table><tbody><tr><td class=\"icon\"><i class=\"fa icon-caution\" title=\"Caution\"></i></td><td class=\"content\">I highly recommend that you run this sample on a machine with at least 16GB of system memory. </td></tr></tbody></table></div><div class=\"paragraph\"><p>Once the startup sequence is completed, you can navigate to the Eureka host and see which services have registered with the discovery service.</p></div><div class=\"paragraph\"><p>Copy and paste the following command into the terminal where Docker can be accessed using the <code>$DOCKER_HOST</code> environment variable.</p></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-bash hljs\" data-lang=\"bash\">$ open $(<span class=\"hljs-built_in\">echo</span> \\<span class=\"hljs-string\">\"<span class=\"hljs-variable\">$(echo $DOCKER_HOST)</span>\\\"|<br />            \\sed 's/tcp:\\/\\//http:\\/\\//g'|<br />            \\sed 's/[0-9]\\{4,\\}/8761/g'|<br />            \\sed 's/\\\"//g')</span></code></pre></div></div><div class=\"paragraph\"><p>When the user interface successfully loads for Eureka, you’ll see the list of services that have registered as a Eureka discovery client.</p></div><div style=\"display: block;\" class=\"imageblock\"><div style=\"text-align: center; margin: auto;\" class=\"content\"><img style=\"margin: auto !important;\" src=\"http://i.imgur.com/3OUOmK3.png\" alt=\"Eureka discovery service\" width=\"100%\"></div></div><div class=\"paragraph\"><p>When all applications have finished starting and are registered with Eureka, you can access the <code>Online Store Web</code> application using the following command.</p></div><div class=\"listingblock\"><div class=\"content\"><pre class=\"highlightjs highlight\"><code class=\"language-bash hljs\" data-lang=\"bash\">$ open $(<span class=\"hljs-built_in\">echo</span> \\<span class=\"hljs-string\">\"<span class=\"hljs-variable\">$(echo $DOCKER_HOST)</span>\\\"|<br />            \\sed 's/tcp:\\/\\//http:\\/\\//g'|<br />            \\sed 's/[0-9]\\{4,\\}/8787/g'|<br />            \\sed 's/\\\"//g')</span></code></pre></div></div><div class=\"admonitionblock tip\"><table><tbody><tr><td class=\"icon\"><i class=\"fa icon-tip\" title=\"Tip\"></i></td><td class=\"content\">It may take some time for the application to start up, so make sure you refresh the UI every few minutes until the product catalog becomes visible. </td></tr></tbody></table></div><div style=\"display: block;\" class=\"imageblock\"><div style=\"text-align: center; margin: auto;\" class=\"content\"><img style=\"margin: auto !important;\" src=\"http://i.imgur.com/lyDmoZ7.png\" alt=\"Load the home page\" width=\"100%\"></div></div><div class=\"paragraph\"><p>To start adding products to the shopping cart, you’ll need to login with the default user. Click <code>Login</code> and you’ll be redirected to the authentication gateway. Use the default credentials of <code>user</code> and <code>password</code> to login.</p></div><div style=\"display: block;\" class=\"imageblock\"><div style=\"text-align: center; margin: auto;\" class=\"content\"><img style=\"margin: auto !important;\" src=\"http://imgur.com/sbZBaE1.png\" alt=\"Login to the application\" width=\"100%\"></div></div><div class=\"paragraph\"><p>You’ll be redirected to the home page where you will now be authenticated and can begin to manage items in your shopping cart.</p></div><div style=\"display: block;\" class=\"imageblock\"><div style=\"text-align: center; margin: auto;\" class=\"content\"><img style=\"margin: auto !important;\" src=\"http://i.imgur.com/e4VBBkN.png\" alt=\"Now you're authenticated\" width=\"100%\"></div></div></div></div></div><div class=\"sect1\"><h2 id=\"_conclusion\">Conclusion</h2><div class=\"sectionbody\"><div class=\"paragraph\"><p>In this article we took a hard look at the challenges of high availability and data consistency in microservice architectures. We looked at a full cloud native application of an online store as a collection of microservices that use event sourcing to maintain a consistent view of the world while still guaranteeing high availability.</p></div><div class=\"paragraph\"><p>In upcoming blog posts I will be exploring how to use <a href=\"http://cloud.spring.io/spring-cloud-stream/\" target=\"_blank\">Spring Cloud Stream</a> for both event sourcing and event stream processing using Apache Kafka.</p></div><div class=\"sect2\"><h3 id=\"_special_thanks\">Special Thanks</h3><div class=\"paragraph\"><p>This article was a real challenge to put together, and because of that, I do want to thank a few people who helped it all come together.</p></div><div class=\"paragraph\"><p>First, I want to thank <a href=\"https://twitter.com/crichardson\" target=\"_blank\">Chris Richardson</a> for already contributing a majority of the existing content out there about event sourcing in microservices. I first started planning to put this project together a few months back after speaking at the Oakland Java User Group about Spring Cloud and microservices. Chris is the organizer of that group and he was in the audience during my talk. The audience was kind to me in the Q/A (which I appreciated!) and there were several questions about eventual consistency and how to share state between microservices. Chris was kind enough to bail me out for a few questions and provided details on many of the key points that I started researching as a part of this article and project. Chris has open source event sourcing examples available which I recommend taking a look at  <a href=\"https://github.com/cer/event-sourcing-examples\" target=\"_blank\">and you can find them here</a>.</p></div><div class=\"paragraph\"><p>I also want to thank <a href=\"https://spring.io/team/bhale\" target=\"_blank\">Ben Hale</a> of the <a href=\"https://spring.io/team\" target=\"_blank\">Spring Engineering team</a> at Pivotal for being my guide when it came to putting together the reactive streaming examples for event sourcing using Project Reactor. I am fortunate to be able to have the privilege to work with so many brilliant minds behind the Spring open source ecosystem when I am putting together these articles and reference projects. If you want to get more involved with this amazing open source community please come visit us at our annual <a href=\"http://springoneplatform.io/\" target=\"_blank\">SpringOne Platform conference</a> this August in Las Vegas.</p></div></div></div></div> </div>",
  "link": "https://www.kennybastani.com/2016/04/event-sourcing-microservices-spring-cloud.html",
  "author": "noreply@blogger.com (Kenny Bastani)",
  "thr:total": 0
}