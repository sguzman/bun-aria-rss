{
  "title": "Cost efficient ML inference with multi-framework models on Amazon SageMaker",
  "link": "https://aws.amazon.com/blogs/machine-learning/cost-efficient-ml-inference-with-multi-framework-models-on-amazon-sagemaker/",
  "dc:creator": "Dhawalkumar Patel",
  "pubDate": "Mon, 31 Oct 2022 20:33:07 +0000",
  "category": [
    "Advanced (300)",
    "Amazon SageMaker",
    "Artificial Intelligence"
  ],
  "guid": "c9d304ece72f07807af72f9c7eff25f7a4057144",
  "description": "Machine learning (ML) has proven to be one of the most successful and widespread applications of technology, affecting a wide range of industries and impacting billions of users every day. With this rapid adoption of ML into every industry, companies are facing challenges in supporting low-latency predictions and with high availability while maximizing resource utilization […]",
  "content:encoded": "<p>Machine learning (ML) has proven to be one of the most successful and widespread applications of technology, affecting a wide range of industries and impacting billions of users every day. With this rapid adoption of ML into every industry, companies are facing challenges in supporting low-latency predictions and with high availability while maximizing resource utilization and reducing associated costs. Because each ML framework has its own dependencies, and deployment steps for each framework are different, deploying models built in different frameworks in production and managing each of the endpoints becomes more and more complex.</p> \n<p><a href=\"https://aws.amazon.com/sagemaker/\" target=\"_blank\" rel=\"noopener noreferrer\">Amazon SageMaker</a> multi-container endpoints (MCEs) enables us to group models on different frameworks and deploy them to the same host, creating a single endpoint. You can provide containers for the different frameworks that you’re using to build the models, and SageMaker takes all of these containers and puts them behind one endpoint. For instance, you could have a PyTorch and a TensorFlow model loaded up on two dedicated endpoints serving the same or entirely different use cases, and both of these models have intermittent incoming traffic not utilizing resources to its limit. In such a scenario, you could club them together using containers into one endpoint using an MCE, improving the resource utilization while reducing the costs incurred in having both the models serving from different endpoints.</p> \n<p>Multi-container endpoints provide a scalable and cost-effective solution to deploy up to 15 models built on different ML frameworks, model servers, and algorithms serving the same or different use case, meaning that you can have models built on diverse ML frameworks or intermediary steps across all of these containers and models. All these models can be accessed individually via direct invocation or stitched into a pipeline using serial invocation, where the output of one model is the input for the next one.</p> \n<p>In this post, we discuss how to perform cost-efficient ML inference with multi-framework models on SageMaker.</p> \n<h2>MCE invocation patterns</h2> \n<p>SageMaker MCE direct invocation is useful in cases where you have clubbed unrelated models into an MCE endpoint or you’re running an A/B test between the models behind an MCE endpoint to gauge their performance. You can call the specific container directly in the API call and get the prediction from that model.</p> \n<p>With serial invocation, you can stitch together 2–15 containers, and the output of one becomes the input of the next container in sequence. This is an ideal use case if, for example, you have a multi-step prediction pipeline where a Scikit-learn model is used for an intermediate prediction and the result is fed to a TensorFlow model for final inference. Instead of having them deployed as different endpoints and another application or job orchestrating them and making multiple API calls, you can deploy them as a SageMaker MCE, abstracting the logic and setting them up for serial invocation, where SageMaker manages the data transfer between one container to another automatically and emits the output of the final container to the client making the API request.</p> \n<p>SageMaker MCE serial invocation is fundamentally different from a SageMaker serial inference pipeline (more details in the sections below). A serial inference pipeline is targeted more to orchestrate complex ML workflows such as data preprocessing, building a model ensemble, implementing conditional checks to determine which model to invoke, or postprocessing the prediction, involving business logic before the prediction is sent out to the downstream applications. In contrast, MCE serial invocation is designed to stitch 2–14 models into a pipeline for inference, each model taking the prediction of the previous model as input.</p> \n<p>All the containers in an MCE are always in service and in memory, so there is no cold start while invoking the endpoint. MCEs also improve endpoint utilization and improve costs because models are deployed behind one endpoint and share the underlying compute instance, instead of each model occupying individual compute resources.</p> \n<p>Let’s look at a few use cases and see how you can use SageMaker MCEs to optimize ML inference.</p> \n<h2>Use cases for SageMaker MCEs</h2> \n<p>Suppose you have two models for sentiment classification, one for English language and other for German language, and these models are serving different geographies with traffic coming in at different times in a day. Instead of having two endpoints running 24/7, you can deploy both of them into one endpoint using an MCE and access them using direct invocation, thereby optimizing your resource utilization and costs. See the following code:</p> \n<div class=\"hide-language\"> \n <pre><code class=\"lang-bash\">englishModel = {\n   'Image': container1,\n   'ContainerHostname': englishModel }; ...\n \ngermanModel = {\n   'Image': container2,\n   'ContainerHostname': germanModel }; ...\n \nsm.create_model(\n   InferenceExecutionConfig = {'Mode': 'Direct'},\n   Containers = [englishModel, germanModel], ...)\nsm.create_endpoint_config(EndpointConfigName = ‘my-mce-epc’,\n    ProductionVariants=[{\n        'InstanceType':        ‘ml.m4.xlarge’,\n        'InitialInstanceCount': 2,\n        'InitialVariantWeight': 1,\n        'ModelName':            ‘my-multi-model-name’,\n        'VariantName':          'AllTraffic'}])\nsm.create_endpoint(EndpointName = ‘my-mce-endpoint’, \n                  EndpointConfigName = ‘my-mce-epc’)</code></pre> \n</div> \n<p>In this example, we have two models (<code>englishModel</code> and <code>germanModel</code>), and we define the containers in the SageMaker <code>create_model</code> construct and define the <code>InferenceExecutionConfig</code> as ‘Direct’. Now we can call the endpoint for inference and define the <code>TargetContainerHostname</code> as either <code>englishModel</code> or <code>germanModel</code> depending on the client making the API call:</p> \n<div class=\"hide-language\"> \n <pre><code class=\"lang-bash\">sm.invoke_endpoint(        \n   EndpointName = endpoint_name,\n   TargetContainerHostname = englishModel,\n   Body = body, ...)</code></pre> \n</div> \n<p>You can also use direct invocation within the MCE to run A/B tests to compare the performance between the models.</p> \n<p>The following diagram illustrates our architecture.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2022/10/21/ML-9275-image001.png\"><img loading=\"lazy\" class=\"alignnone size-full wp-image-44632\" src=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2022/10/21/ML-9275-image001.png\" alt=\"\" width=\"2048\" height=\"889\"></a></p> \n<p>Similarly, in other ML use cases, when the trained model is used for processing a request, the model receives data in a format that needs to be preprocessed (for example, featurized) before it can be passed to the algorithm for inference. When ML algorithms are chained together, the output of one model serves as input for the next one before reaching the final result. In this case, you can build a SageMaker MCE serial pipeline, where the containers talk to each other in the sequence defined in the <code>create_model</code> construct instead of you deploying each of the models into different endpoints and writing an independent logic to facilitate the flow of data between all these models and API calls. The following diagram illustrates this architecture.</p> \n<p><a href=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2022/10/21/ML-9275-image003.png\"><img loading=\"lazy\" class=\"alignnone size-full wp-image-44633\" src=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2022/10/21/ML-9275-image003.png\" alt=\"\" width=\"1188\" height=\"760\"></a></p> \n<p>For this use case, we use the following code:</p> \n<div class=\"hide-language\"> \n <pre><code class=\"lang-bash\">sm_model = PipelineModel(name=model_name, role=aws_role, models=[Processing-1, Processing-2, Inference-1, Inference-2]) \n\npredictor = sm_model.deploy(initial_instance_count=1, instance_type=\"ml.c4.xlarge\")                  \nresponse = runtime.invoke_endpoint( \nEndpointName=predictor.endpoint,                                \n    Body=body,...)</code></pre> \n</div> \n<p>In this example, we have two processing containers (<code>Processing-1</code> and <code>Processing-2</code>) for feature processing and data transformations, and two inference containers (<code>Inference-1</code> and <code>Inference-2</code>) to run ML model predictions on the preprocessed data. The <code>PipelineModel</code> instance allows you to define the inference pipeline composed of a linear sequence of four containers that process requests for inference on data. The containers are co-located on the same instance, enabling you to run inference with low latency.</p> \n<h2>Scale multi-model endpoints for large numbers of models</h2> \n<p>The benefits of SageMaker multi-model endpoints increase based on the scale of model consolidation. You can see cost savings when hosting two models with one endpoint, and for use cases with hundreds or thousands of models, the savings are much greater.</p> \n<p>Scaling the MCE endpoints is also straightforward using the <code>SageMakerVariantInvocationsPerInstance</code> predefined metric, which gives the average number of times per minute that each instance for a model endpoint is invoked to define a <code>TargetScaling</code> policy. SageMaker dynamically adjusts the number of instances provisioned for a model in response to changes in your workload. When the workload increases, autoscaling brings more instances online and loads with the target models and containers to keep up serving the requests. When the workload decreases, autoscaling removes unnecessary instances and offloads the model containers so that the containers don’t eat up the resources, and you don’t pay for instances that you aren’t using. The time to complete the first request against a given model experiences additional latency (called a cold start) to download the model from <a href=\"http://aws.amazon.com/s3\" target=\"_blank\" rel=\"noopener noreferrer\">Amazon Simple Storage Service</a> (Amazon S3) and load it into memory. Subsequent calls finish with no additional overhead because the model is already loaded. See the following code:</p> \n<div class=\"hide-language\"> \n <pre><code class=\"lang-bash\"># AutoScaling client\nasg = boto3.client('application-autoscaling')\n\n# Resource type is variant and the unique identifier is the resource ID.\nresource_id=f\"endpoint/{endpoint_name}/variant/AllTraffic\"\n\n# scaling configuration\nresponse = asg.register_scalable_target(\n    ServiceNamespace='sagemaker', #\n    ResourceId=resource_id,\n    ScalableDimension='sagemaker:variant:DesiredInstanceCount', \n    MinCapacity=1,\n    MaxCapacity=4\n)\n#Target Scaling\nresponse = asg.put_scaling_policy(\n    PolicyName=f'Request-ScalingPolicy-{endpoint_name}',\n    ServiceNamespace='sagemaker',\n    ResourceId=resource_id,\n    ScalableDimension='sagemaker:variant:DesiredInstanceCount',\n    PolicyType='TargetTrackingScaling',\n    TargetTrackingScalingPolicyConfiguration={\n        'TargetValue': 70.0, # Threshold\n        'PredefinedMetricSpecification': {\n            'PredefinedMetricType': 'SageMakerVariantInvocationsPerInstance',\n        },\n        'ScaleInCooldown': 300, # duration until scale in\n        'ScaleOutCooldown': 60 # duration between scale out\n    }\n)</code></pre> \n</div> \n<p>Following the preceding example policy configuration, we use the <code>SageMakerVariantInvocationsPerInstance</code> predefined metric to adjust the number of variant instances so that each instance has an <code>InvocationsPerInstance</code> metric of 70.</p> \n<p>We can also scale SageMaker MCEs based on our own custom metric, such as <code>CPUUtilization</code>, <code>MemoryUtilization</code>, <code>GPUUtilization</code>, <code>GPUMemoryUtilization</code>, or <code>DiskUtilization</code>, to scale up or down the number of instances based on utilization of a specific resource. For more information, refer to <a href=\"https://docs.aws.amazon.com/sagemaker/latest/dg/endpoint-auto-scaling.html\" target=\"_blank\" rel=\"noopener noreferrer\">Automatically Scale Amazon SageMaker Models</a>.</p> \n<p>It’s recommended that the model in each container exhibits similar compute and latency requirements on each inference request, because if traffic to the MCE shifts from a high CPU utilization model to a low CPU utilization model, but the overall call volume remains the same, the endpoint doesn’t scale out and there may not be enough instances to handle all the requests to the high CPU utilization model.</p> \n<h2>Secure MCEs</h2> \n<p>For MCEs with direct invocation, multiple containers are hosted in a single instance by sharing memory and a storage volume. It’s important to secure the containers, maintain the correct mapping of requests to target containers, and provide users with the correct access to target containers. You can restrict <code>invoke_endpoint</code> access to a limited set of containers inside an MCE using the <code>sagemaker:TargetContainerHostname</code> <a href=\"http://aws.amazon.com/iam\" target=\"_blank\" rel=\"noopener noreferrer\">AWS Identity and Access Management</a> (IAM) condition key. SageMaker uses <a href=\"https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html\" target=\"_blank\" rel=\"noopener noreferrer\">IAM roles</a> to provide IAM identity-based policies that you use to specify allowed or denied actions and resources and the conditions under which actions are allowed or denied. The following policies show how to limit calls to specific containers within an endpoint:</p> \n<div class=\"hide-language\"> \n <pre><code class=\"lang-code\">{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"sagemaker:InvokeEndpoint\"\n            ],\n            \"Effect\": \"Allow\",\n            \"Resource\": \"arn:aws:sagemaker:region:account-id:endpoint/endpoint_name\",\n            \"Condition\": {\n                \"StringLike\": {\n                    \"sagemaker:TargetContainerHostname\": [\"customIps*\", \"common*\"]\n                }\n            }\n        }\n    ]\n}</code></pre> \n</div> \n<h2>Monitor multi-model endpoints using Amazon CloudWatch metrics</h2> \n<p>To make price and performance trade-offs, you’ll want to test multi-model endpoints with models and representative traffic from your own application. SageMaker provides additional metrics in <a href=\"http://aws.amazon.com/cloudwatch\" target=\"_blank\" rel=\"noopener noreferrer\">Amazon CloudWatch</a> for multi-model endpoints so you can determine the endpoint usage and the cache hit rate and optimize your endpoint. The metrics are as follows:</p> \n<ul> \n <li><strong>ModelLoadingWaitTime</strong> – The interval of time that an invocation request waits for the target model to be downloaded or loaded to perform the inference.</li> \n <li><strong>ModelUnloadingTime</strong> – The interval of time that it takes to unload the model through the container’s <code>UnloadModel</code> API call.</li> \n <li><strong>ModelDownloadingTime</strong> – The interval of time that it takes to download the model from Amazon S3.</li> \n <li><strong>ModelLoadingTime</strong> – The interval of time that it takes to load the model through the container’s <code>LoadModel</code> API call.</li> \n <li><strong>ModelCacheHit</strong> – The number of <code>InvokeEndpoint</code> requests sent to the endpoint where the model was already loaded. Taking the <code>Average</code> statistic shows the ratio of requests in which the model was already loaded.</li> \n <li><strong>LoadedModelCount</strong> – The number of models loaded in the containers in the endpoint. This metric is emitted per instance. The <code>Average</code> statistic with a period of 1 minute tells you the average number of models loaded per instance, and the <code>Sum</code> statistic tells you the total number of models loaded across all instances in the endpoint. The models that this metric tracks aren’t necessarily unique because you can load a model in multiple containers in the endpoint.</li> \n</ul> \n<p>There are also several other metrics that are used by each container running on an instance, such as <code>Invocations</code> indicating the number of <code>InvokeEndpoint</code> requests sent to a container inside an endpoint, <code>ContainerLatency</code> giving the time an endpoint took for the target container or all the containers in a serial invocation to respond as viewed from SageMaker, and <code>CPUUtilization</code> and <code>MemoryUtilizaton</code> indicating the CPU units and percentage of memory.</p> \n<h2>Conclusion</h2> \n<p>In the post, we discussed how SageMaker multi-container endpoints can be helpful in optimizing costs and resource utilization. Examples of when to utilize MCEs include, but are not limited to, the following:</p> \n<ul> \n <li>Hosting models across different frameworks (such as TensorFlow, PyTorch, and Scikit-learn) that don’t have sufficient traffic to saturate the full capacity of an instance</li> \n <li>Hosting models from the same framework with different ML algorithms (such as recommendations, forecasting, or classification) and handler functions</li> \n <li>Comparisons of similar architectures running on different framework versions (such as TensorFlow 1.x vs. TensorFlow 2.x) for scenarios like A/B testing</li> \n</ul> \n<p>SageMaker MCEs support deploying up to 15 containers on real-time endpoints and invoking them independently for low-latency inference and cost savings. The models can be completely heterogenous, with their own independent serving stack. You can either invoke these containers sequentially or independently for each request. Securely hosting multiple models, from different frameworks, on a single instance could save you up to 90% in cost compared to hosting models in dedicated single-instance endpoints.</p> \n<hr> \n<h3>About the authors</h3> \n<p style=\"clear: both\"><strong><a href=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2020/07/29/Dhawalkumar-Patel-100.jpg\"><img loading=\"lazy\" class=\"size-full wp-image-14282 alignleft\" src=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2020/07/29/Dhawalkumar-Patel-100.jpg\" alt=\"\" width=\"100\" height=\"136\"></a>Dhawal Patel</strong> is a Principal Machine Learning Architect at AWS. He has worked with organizations ranging from large enterprises to mid-sized startups on problems related to distributed computing and artificial intelligence. He focuses on deep learning, including NLP and computer vision domains. He helps customers achieve high-performance model inference on Amazon SageMaker.</p> \n<p style=\"clear: both\"><strong><a href=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2022/01/13/Vikram-Elango.png\"><img loading=\"lazy\" class=\"size-full wp-image-32331 alignleft\" src=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2022/01/13/Vikram-Elango.png\" alt=\"\" width=\"100\" height=\"119\"></a>Vikram Elango</strong> is a Senior AI/ML Specialist Solutions Architect at Amazon Web Services, based in Virginia, US. Vikram helps global financial and insurance industry customers with design and thought leadership to build and deploy machine learning applications at scale. He is currently focused on natural language processing, responsible AI, inference optimization, and scaling ML across the enterprise. In his spare time, he enjoys traveling, hiking, cooking, and camping with his family.</p> \n<p style=\"clear: both\"><strong><a href=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2022/09/22/1574906389253.jpeg\"><img loading=\"lazy\" class=\"size-full wp-image-43014 alignleft\" src=\"https://d2908q01vomqb2.cloudfront.net/f1f836cb4ea6efb2a0b1b99f41ad8b103eff4b59/2022/09/22/1574906389253.jpeg\" alt=\"\" width=\"100\" height=\"127\"></a>Saurabh Trikande</strong> is a Senior Product Manager for Amazon SageMaker Inference. He is passionate about working with customers and is motivated by the goal of democratizing machine learning. He focuses on core challenges related to deploying complex ML applications, multi-tenant ML models, cost optimizations, and making deployment of deep learning models more accessible. In his spare time, Saurabh enjoys hiking, learning about innovative technologies, following TechCrunch, and spending time with his family.</p>"
}