{
  "id": "tag:blogger.com,1999:blog-1176949257541686127.post-2263910864248439853",
  "published": "2022-07-19T12:59:00.001-04:00",
  "updated": "2022-07-19T14:04:59.621-04:00",
  "category": [
    "",
    ""
  ],
  "title": "DNS-over-HTTP/3 in Android",
  "content": "<p><i>Posted by Matthew Maurer and Mike Yu, Android team</i></p> <p>  To help keep Android users’ DNS queries private, Android supports encrypted   DNS. In addition to existing support for DNS-over-TLS, Android now supports   DNS-over-HTTP/3 which has a number of improvements over DNS-over-TLS. </p><p>  Most network connections begin with a DNS lookup. While transport security may   be applied to the connection itself, that DNS lookup has traditionally not   been private by default: the base DNS protocol is raw UDP with no encryption.   While the internet has migrated to TLS over time, DNS has a bootstrapping   problem. Certificate verification relies on the domain of the other party,   which requires either DNS itself, or moves the problem to DHCP (which may be   maliciously controlled). This issue is mitigated by central resolvers like   Google, Cloudflare, OpenDNS and Quad9, which allow devices to configure a   single DNS resolver locally for every network, overriding what is offered   through DHCP. </p><p>  In Android 9.0, we   <a href=\"https://android-developers.googleblog.com/2018/04/dns-over-tls-support-in-android-p.html\">announced</a>  the Private DNS feature, which uses   <a href=\"https://tools.ietf.org/html/rfc8310\">DNS-over-TLS</a> (DoT) to   protect DNS queries when enabled and supported by the server. Unfortunately,   DoT incurs overhead for every DNS request. An alternative encrypted DNS   protocol,   <a href=\"https://tools.ietf.org/html/rfc8484\">DNS-over-HTTPS</a> (DoH), is   rapidly gaining traction within the industry as DoH has already been deployed   by most public DNS operators, including the   <a href=\"https://developers.cloudflare.com/1.1.1.1/dns-over-https/cloudflared-proxy/\">Cloudflare Resolver</a>  and   <a href=\"https://developers.google.com/speed/public-dns/docs/doh/\">Google Public DNS</a>. While using HTTPS alone will not reduce the overhead significantly, HTTP/3   uses <a href=\"https://datatracker.ietf.org/doc/html/rfc9000\">QUIC</a>, a   transport that efficiently multiplexes multiple streams over UDP using a   single TLS session with session resumption. All of these features are crucial   to efficient operation on mobile devices. </p><p>  DNS-over-HTTP/3 (DoH3) support was released as part of a   <a href=\"https://source.android.com/devices/architecture/modular-system\">Google Play system update</a>, so by the time you’re reading this, Android devices from Android 11   onwards<sup id=\"fnref1\"><a href=\"#fn1\" rel=\"footnote\">1</a></sup> will use   DoH3 instead of DoT for well-known<sup id=\"fnref2\"><a href=\"#fn2\" rel=\"footnote\">2</a></sup>  DNS servers which support it. Which DNS service you are using is unaffected by   this change; only the transport will be upgraded. In the future, we aim to   support   <a href=\"https://datatracker.ietf.org/doc/draft-ietf-add-ddr/\">DDR</a> which   will allow us to dynamically select the correct configuration for any server.   This feature should decrease the performance impact of encrypted DNS. </p><h2>Performance</h2> <p>  DNS-over-HTTP/3 avoids several problems that can occur with DNS-over-TLS   operation: </p><ul>  <li>    As DoT operates on a single stream of requests and responses,     <a href=\"https://www.dit.upm.es/~fcuadrado/publication/imc-19-doh/imc-19-doh.pdf\">many</a>    server implementations suffer from     <a href=\"https://en.wikipedia.org/wiki/Head-of-line_blocking\">head-of-line blocking</a><sup id=\"fnref3\"><a href=\"#fn3\" rel=\"footnote\">3</a></sup>. This means that if the request at the front of the line takes a while to     resolve (possibly because a recursive resolution is necessary), responses     for subsequent requests that would have otherwise been resolved quickly are     blocked waiting on that first request. DoH3 by comparison runs each request     over a separate     <a href=\"https://tools.ietf.org/id/draft-ietf-quic-transport-24.html#rfc.section.2\">logical stream</a>, which means implementations will resolve requests out-of-order by     default.   </li>  <li>    Mobile devices change networks frequently as the user moves around. With     DoT, these events require a full renegotiation of the connection. By     contrast, the QUIC transport HTTP/3 is based on can resume a suspended     connection in a single RTT.   </li>  <li>    DoT intends for many queries to use the same connection to amortize the cost     of TCP and TLS handshakes at the start. Unfortunately, in practice several     factors (such as network disconnects or server TCP connection management)     make these connections less long-lived than we might like. Once a connection     is closed, establishing the connection again requires at least 1 RTT.     <p>      In unreliable networks, DoH3 may even outperform traditional DNS. While       unintuitive, this is because the flow control mechanisms in QUIC can alert       either party that packets weren’t received. In traditional DNS, the       timeout for a query needs to be based on expected time for the entire       query, not just for the resolver to receive the packet.     </p>    <p></p><div class=\"separator\" style=\"clear: both;\"><a href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgNr6mnniVosUy4Qn1ogtfiDF7et400HsodQ06Ku8cZSAKpENH1-YqbjrIdJWo78j-YAXmM19hMbmk4rozArKUaYKli6kM1UENf-GQRwR0Y4cORrt8mDLJghZTYqk53WiiF8k1wuXrwLTeYoN4rrjeaC_bGxoru5A9W803WvokCAxLb1_iEMW_wzSLwFw/s1600/Screenshot%202022-07-19%207.39.02%20AM.png\" style=\"display: block; padding: 1em 0px; text-align: center;\"><img alt=\"\" border=\"0\" data-original-height=\"381\" data-original-width=\"710\" height=\"297\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgNr6mnniVosUy4Qn1ogtfiDF7et400HsodQ06Ku8cZSAKpENH1-YqbjrIdJWo78j-YAXmM19hMbmk4rozArKUaYKli6kM1UENf-GQRwR0Y4cORrt8mDLJghZTYqk53WiiF8k1wuXrwLTeYoN4rrjeaC_bGxoru5A9W803WvokCAxLb1_iEMW_wzSLwFw/w553-h297/Screenshot%202022-07-19%207.39.02%20AM.png\" width=\"553\" /></a></div>    </li></ul>     <p></p>    <p>      Field measurements during the initial limited rollout of this feature show       that DoH3 significantly improves on DoT’s performance. For successful       queries, our studies showed that replacing DoT with DoH3 reduces median       query time by 24%, and 95th percentile query time by 44%. While it might       seem suspect that the reported data is conditioned on successful queries,       both DoT and DoH3 resolve 97% of queries successfully, so their metrics       are directly comparable. UDP resolves only 83% of queries successfully. As       a result, UDP latency is not directly comparable to TLS/HTTP3 latency       because non-connection-oriented protocols have a different notion of what       a \"query\" is. We have still included it for rough comparison.     </p>    <h2>Memory Safety</h2>     <p>      The DNS resolver processes input that could potentially be controlled by       an attacker, both from the network and from apps on the device. To reduce       the risk of security vulnerabilities, we chose to use a memory safe       language for the implementation.     </p>    <p>      Fortunately, we’ve been adding       <a href=\"https://security.googleblog.com/2021/04/rust-in-android-platform.html\">Rust support</a>      to the Android platform. This effort is intended exactly for cases like       this — system level features which need to be performant or low level       (both in this case) and which would carry risk to implement in C++. While       we’ve previously launched Keystore 2.0, this represents our first foray       into Rust in Mainline Modules. Cloudflare maintains an HTTP/3 library       called <a href=\"https://github.com/cloudflare/quiche\">quiche</a>, which       fits our use case well, as it has a memory-safe implementation, few       dependencies, and a small code size. Quiche also       <a href=\"https://github.com/cloudflare/quiche#calling-quiche-from-cc\">supports use directly from C++</a>. We considered this, but even the request dispatching service had       sufficient complexity that we chose to implement that portion in Rust as       well.     </p>    <p>      We built the query engine using the       <a href=\"https://github.com/tokio-rs/tokio\">Tokio</a> async framework to       simultaneously handle new requests, incoming packet events, control       signals, and timers. In C++, this would likely have required multiple       threads or a carefully crafted event loop. By leveraging asynchronous in       Rust, this occurs on a single thread with minimal locking<sup id=\"fnref4\"><a href=\"#fn4\" rel=\"footnote\">4</a></sup>. The DoH3 implementation is 1,640 lines and uses a single runtime       thread. By comparison, DoT takes 1,680 lines while managing less and using       up to 4 threads per DoT server in use.     </p>    <h2>Safety and Performance — Together at Last</h2>     <p>      With the introduction of Rust, we are able to improve both security and       the performance at the same time. Likewise, QUIC allows us to improve       network performance and privacy simultaneously. Finally, Mainline ensures       that such improvements are able to make their way to more Android users       sooner.     </p>    <h2>Acknowledgements</h2>     <p>      Special thanks to Luke Huang who greatly contributed to the development of       this feature, and Lorenzo Colitti for his in-depth review of the technical       aspects of this post.     </p>    <hr />    <p></p>    <p></p>    <p></p> <h3></h3><div class=\"footnotes\"><ol style=\"text-align: left;\"><li id=\"fn1\"><p><i>     Some Android 10 devices which adopted Google Play system updates early will also receive this feature.&nbsp;<a href=\"#fnref1\" rev=\"footnote\">↩</a></i></p></li><li id=\"fn2\"><p><i>     Google DNS and Cloudflare DNS at launch, others may be added in the future.&nbsp;<a href=\"#fnref2\" rev=\"footnote\">↩</a></i></p></li><li id=\"fn3\"> <p><i>     DoT can be implemented in a way that avoids this problem, as the client must accept server responses out of order. However, in practice most servers do not implement this reordering.&nbsp;<a href=\"#fnref3\" rev=\"footnote\">↩</a></i></p></li><li id=\"fn4\"><p><i>     There is a lock used for the SSL context which is accessed once per DNS server, and another on the FFI when issuing a request. The FFI lock could be removed with changes to the C++ side, but has remained because it is low contention.&nbsp;<a href=\"#fnref4\" rev=\"footnote\">↩</a></i> </p></li><p></p><p></p><p></p></ol></div>",
  "link": [
    "",
    "",
    "",
    "",
    ""
  ],
  "author": {
    "name": "Edward Fernandez",
    "uri": "http://www.blogger.com/profile/03784424747198152685",
    "email": "noreply@blogger.com",
    "gd:image": ""
  },
  "media:thumbnail": "",
  "thr:total": 0
}