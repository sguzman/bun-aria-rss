{
  "id": "tag:blogger.com,1999:blog-6755709643044947179.post-5101999626203147742",
  "published": "2022-10-27T07:30:00.018-07:00",
  "updated": "2022-10-28T11:27:22.115-07:00",
  "title": "Optimize for Android (Go edition): Lessons from Google apps Part 3",
  "content": "<meta content=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgzsvGgdblkrLi-FXfRwrL0c-Sk-4Kv_fMRSVm5cSeKqaxPD49Zi_aDSpEDk3M0TOGX9vl9AGUnnB2n_BZb8u3Mvb7Z3kmsQjHatG9P3TH2S0ED_kbYZEzQU7udz4ePQucdgguroG6KTslJ_a8e1EQSjPgG6Xm7TZOCYJdHdlsbYaPwb0UkNwHkg6uq/s1600/Android-making-sense-of-intent-filters-social.png\" name=\"twitter:image\"></meta>\n<img src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgzsvGgdblkrLi-FXfRwrL0c-Sk-4Kv_fMRSVm5cSeKqaxPD49Zi_aDSpEDk3M0TOGX9vl9AGUnnB2n_BZb8u3Mvb7Z3kmsQjHatG9P3TH2S0ED_kbYZEzQU7udz4ePQucdgguroG6KTslJ_a8e1EQSjPgG6Xm7TZOCYJdHdlsbYaPwb0UkNwHkg6uq/s1600/Android-making-sense-of-intent-filters-social.png\" style=\"display: none;\" />\n\n<p><em>Posted by </em><i><a href=\"https://twitter.com/theDroidLady\" target=\"_blank\">Niharika Arora</a>, Developer Relations Engineer</i></p><p>\n\n<a href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgTAjAPOnSxXz-2bHppUG7wQFEHOFwFC8WdkV9_X9-jaSqBnBolvpgtpFEi7phcUBaMWQK1yXDW01p9uQ-EBh87cfWRWLTkK_FUrUFXccNlL2q7xvg5LJSHXe5XRieOO0f95QAMe7_UZvQ-Am1Rag-FZyRfPqK-V9n6VWfxCL-4dVYI9vtNK6_pUZyf/s1600/Android-making-sense-of-intent-filters-header.png\"><img border=\"0\" data-original-height=\"800\" data-original-width=\"1058\" height=\"204\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgTAjAPOnSxXz-2bHppUG7wQFEHOFwFC8WdkV9_X9-jaSqBnBolvpgtpFEi7phcUBaMWQK1yXDW01p9uQ-EBh87cfWRWLTkK_FUrUFXccNlL2q7xvg5LJSHXe5XRieOO0f95QAMe7_UZvQ-Am1Rag-FZyRfPqK-V9n6VWfxCL-4dVYI9vtNK6_pUZyf/s1600/Android-making-sense-of-intent-filters-header.png\" width=\"689\" /></a>\n  \n  </p><p>\nIn <a href=\"https://android-developers.googleblog.com/2022/09/optimize-for-android-go-lessons-from-google-apps-part-1.html\" target=\"_blank\">Part 1</a> and <a href=\"https://android-developers.googleblog.com/2022/09/optimize-for-android-go-lessons-from-google-apps-part-2.html\" target=\"_blank\">Part 2</a> of our “Optimizing for Android Go” blog series, we discussed why we should consider building for Android Go and how to optimize your app to perform well on Go devices. In this blog, we will talk about the tools which helped Google optimize their Google apps performance.   \n</p>\n<h2 style=\"text-align: left;\"><strong>Tools</strong></h2>\n\n\n<h2 style=\"text-align: left;\">Monitoring Memory</h2><h3 style=\"text-align: left;\">\n\n\nAnalyze Memory Footprint&nbsp;</h3><div>&nbsp;1.<span>&nbsp;&nbsp; &nbsp;</span>To determine the memory footprint for an application, any of the following metrics may be used:<br /><ul style=\"text-align: left;\"><ul><li>Resident Set Size (RSS): The number of shared and non-shared pages used by the app</li><li>Proportional Set Size (PSS): The number of non-shared pages used by the app and an even distribution of the shared pages (for example, if three processes are sharing 3MB, each process gets 1MB in PSS)</li><ul><li>Note: Private Set Size (PSS) = Private memory + (shared memory / the number of processes sharing).</li></ul><li>Unique Set Size (USS): The number of non-shared pages used by the app (shared pages are not included)</li></ul></ul><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px;\"><p>PSS is useful for the operating system when it wants to know how much memory is used by all processes since pages don’t get counted multiple times. PSS takes a long time to calculate because the system needs to determine which pages are shared and by how many processes. RSS doesn't distinguish between shared and non-shared pages (making it faster to calculate) and is better for tracking changes in memory allocation.</p></blockquote><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px; text-align: left;\"><p>\n\n    So, which method should you choose? The choice depends on the <strong>usage of shared memory.</strong></p><p>\n\n    For example, if the shared memory is being used by the application only then we should use the RSS approach. While, if the shared memory is taken by the Google Play Services then we should use the USS approach. For more understanding, please read <a href=\"https://developer.android.com/topic/performance/memory-management#memory_pages\">here</a>.&nbsp;</p>\n\n\n</blockquote>2.<span>&nbsp;&nbsp; &nbsp;</span>Take a heap dump and analyze how much memory is utilized by the running processes. Follow<div style=\"text-align: left;\"><ul style=\"text-align: left;\">\n  <ul><li>Review the Prerequisites.&nbsp;</li>\n    <ul><li style=\"text-align: left;\">Developer options <strong>Don't keep activities</strong> must be OFF.&nbsp;</li>\n      <li style=\"text-align: left;\">Use recent release builds for testing.</li></ul>\n    <li>Execute the user journey you desire to measure.</li>\n    <li>Run the following command:</li></ul></ul><span>&nbsp;&nbsp; &nbsp;</span><span>&nbsp;&nbsp; &nbsp;</span><span>&nbsp;&nbsp; &nbsp;</span><span>&nbsp;&nbsp; &nbsp;</span><span>&nbsp;&nbsp; &nbsp;</span>adb shell am dumpheap &lt;You Android App Process ID&gt; &lt;output-file-name&gt;</div><div style=\"text-align: left;\"><ul style=\"text-align: left;\"><ul><li>In a second terminal, run the following command and wait for message indicating that the “<strong>heap dump has completed</strong>”:</li></ul></ul></div>\n<blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px;\"><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px; text-align: left;\"><div style=\"text-align: left;\">adb logcat | grep hprof</div></blockquote></blockquote>\n<div style=\"text-align: left;\"><ul style=\"text-align: left;\"><ul><li>Run:</li></ul></ul></div><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px;\"><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px; text-align: left;\"><div style=\"text-align: left;\">adb pull &lt;output-file-name&gt;&nbsp;</div></blockquote></blockquote><div style=\"text-align: left;\">&nbsp;</div><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px;\"><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px;\"><div style=\"text-align: left;\">This will <b>pull</b> the generated file to your machine for analysis.</div></blockquote></blockquote>\n<div><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px; text-align: left;\"><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px; text-align: left;\">&nbsp;</blockquote></blockquote></div><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px;\"><div style=\"text-align: left;\">To get info on native heap, read here :</div></blockquote><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px;\"><div><div><div style=\"text-align: left;\"><a href=\"https://perfetto.dev/docs/data-sources/native-heap-profiler\">https://perfetto.dev/docs/data-sources/native-heap-profiler</a></div></div></div></blockquote><div><div><div><br /></div></div></div><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px;\"><div><div><div style=\"text-align: left;\">To know about Java heap, read here :</div></div></div></blockquote><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px;\"><div><div><div style=\"text-align: left;\"><a href=\"https://perfetto.dev/docs/data-sources/java-heap-profiler\">https://perfetto.dev/docs/data-sources/java-heap-profiler</a></div></div></div></blockquote><div><p style=\"text-align: left;\">3.<span>&nbsp;&nbsp; &nbsp;</span>Understand low-memory killer</p>\n<blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px; text-align: left;\">In Android, we have a process called <b>low memory killer</b>, and this will pick a process from the device and will kill that process when the device is under low RAM, the thresholds can be tuned by OEMs. By doing so, you will get back all the memory that the process was using.<br />  But what if the <b>low memory killer</b> kills the process that the user cares about?<div>&nbsp; </div><div>In Android, we have a priority list of applications and based on that priority list we remove the app when the <b>low memory killer</b> comes into play. Read more <a href=\"https://android.googlesource.com/platform/system/memory/lmkd/+/refs/heads/master/README.md\">here</a>.</div><div><div style=\"text-align: left;\"><br /></div></div><div><div style=\"text-align: left;\">\n            You can run this command and know :</div></div><div><div style=\"text-align: left;\"><strong>adb shell dumpsys activity oom</strong></div></div><div><div style=\"text-align: left;\"><br /></div></div><div><div style=\"text-align: left;\">To check stats on low memory killer :</div></div><div><div style=\"text-align: left;\"><strong>adb shell dumpsys activity lmk</strong></div></div><div><div style=\"text-align: left;\"><br /></div></div><div><div style=\"text-align: left;\">\nFor more information, please check <a href=\"https://perfetto.dev/docs/data-sources/memory-counters#oom-adj\">Perfetto documentation for Memory</a>.</div></div></blockquote><div style=\"text-align: left;\">&nbsp;</div><h3 style=\"text-align: left;\">Tools&nbsp;</h3><div>&nbsp;1.&nbsp;&nbsp;<b> &nbsp;Debug Memory usage using Perfetto </b>\n</div><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px;\"><div style=\"text-align: left;\">\n\n    This is one the best tools to find where all your app memory is consumed. Use <a href=\"https://perfetto.dev/docs/case-studies/memory\">Perfetto</a> to get information about memory management events from the kernel. Deep dive and understand how to profile native and Java heap <a href=\"https://perfetto.dev/docs/data-sources/memory-counters\">here</a>.&nbsp;</div></blockquote><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px;\"><div style=\"text-align: left;\">&nbsp;</div></blockquote><div>2.&nbsp;<b>&nbsp; &nbsp;Inspect your memory usage using Memory Profiler </b>\n</div><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px;\"><div style=\"text-align: left;\">\n\n    The <a href=\"https://developer.android.com/studio/profile/memory-profiler\">Memory Profiler</a> is a component in the <a href=\"https://developer.android.com/studio/preview/features/android-profiler\">Android Profiler</a> that helps you identify memory leaks and memory churn that can lead to stutter, freezes, and even app crashes. It shows a real time graph of your app's memory use and lets you capture a heap dump, force garbage collections, and track memory allocations. To learn more about inspecting performance, please check MAD skills videos <a href=\"https://www.youtube.com/watch?v=PB-hZVTScUg&amp;list=PLWz5rJ2EKKc91i2QT8qfrfKgLNlJiG1z7\">here</a>.&nbsp;</div></blockquote><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px;\"><div style=\"text-align: left;\">&nbsp;</div></blockquote><div>3.<span style=\"font-weight: bold;\">&nbsp;&nbsp; &nbsp;</span><b>Utilize</b>&nbsp;<strong>meminfo</strong></div><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px;\"><div style=\"text-align: left;\">You may want to observe how your app's memory is divided between different types of RAM allocation with the following <a href=\"https://android-doc.github.io/tools/help/adb.html\">adb</a> command:&nbsp;</div></blockquote><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px;\"><div style=\"text-align: left;\"><span id=\"docs-internal-guid-5bf9f1bd-7fff-c575-4663-82e83b1838c6\"><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-top: 12pt;\"><span style=\"background-color: #f0f0f0; color: #444444; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\"><span style=\"font-family: courier;\">adb shell dumpsys meminfo &lt;package_name|pid&gt; [-d]</span></span></p><div><span style=\"background-color: #f0f0f0; color: #444444; font-family: Arial; font-size: 10pt; font-variant-east-asian: normal; font-variant-numeric: normal; font-weight: 700; vertical-align: baseline; white-space: pre-wrap;\"><br /></span></div></span></div></blockquote><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px;\"><div style=\"text-align: left;\">You can view the following seven memory categories with Meminfo:</div></blockquote><div>\n<ul style=\"text-align: left;\">\n\n<ul><li><strong>Java heap</strong> – memory allocated by Java code\n\n</li><li><strong>Native heap</strong> – memory allocated by native code. These are best understood using debug malloc. Allocations made by the application from C or C++ code using malloc or new.\n\n</li><li><strong>Code</strong> – memory used for Java, native code and some resources, including dex bytecode, shared libraries and fonts\n\n</li><li><strong>Stack</strong> – memory used for both native and Java stacks. This usually has to do with how many threads your application is running.\n\n</li><li><strong>Graphics</strong> – Memory used for graphics buffer queues to display pixels to the screen, GL surfaces and textures and such.\n\n</li><li><strong>Private Other</strong> – uncategorized private memory\n\n</li><li><strong>System</strong> – memory shared with the system or otherwise under the control of the system.\n</li></ul>\n</ul>\n</div><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px;\"><div><p style=\"text-align: left;\">Key memory terms:\n</p></div></blockquote><div>\n<ul style=\"text-align: left;\">\n\n<ul><li><strong>Private</strong> – Memory used only by the process.\n\n</li><li><strong>Shared</strong> – System memory shared with other processes.\n\n</li><li><strong>Clean</strong> – Memory-mapped pages that can be reclaimed when under memory pressure.</li><li><strong>Dirty</strong> – Memory-mapped page modified by a process. These pages may be written to file/swap and then reclaimed when under memory pressure.</li></ul></ul></div><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px;\"><div><p style=\"display: inline; text-align: left;\"><strong>Note : </strong></p></div></blockquote><ul style=\"text-align: left;\"><ul><li><strong style=\"font-weight: bold;\">Debug</strong> class is super useful and provides different methods for Android applications, including tracing and allocation counts. You can read about usage <a href=\"Private\">here</a>.</li><li>For deeper understanding and tracking allocations for each page, read about page owner <a href=\"https://www.kernel.org/doc/html/v4.19/vm/page_owner.html\">here</a>.</li></ul></ul><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px; text-align: left;\"></blockquote><div style=\"text-align: left;\">4.<span>&nbsp;&nbsp; &nbsp;</span><b>Detailed analysis using showmap</b></div><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px;\"><div style=\"text-align: left;\">The showmap command provides a much more detailed breakdown of memory than friendly meminfo. It lists the name and sizes of memory maps used by a process. This is a summary of the information available at /proc/&lt;pid&gt;/smaps, which is the primary source of information used in dumpsys meminfo, except for some graphics memory.</div></blockquote><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px; text-align: left;\">$adb root<br /> $ adb shell pgrep &lt;process&gt;<br />Output - process id<br />$ adb shell showmap &lt;process id&gt;</blockquote><div style=\"text-align: left;\">&nbsp;</div><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px;\"><div style=\"text-align: left;\">Sample Output :&nbsp;</div></blockquote></div></div><blockquote style=\"border: none; margin: 0 0 0 40px; padding: 0px;\"><div><div><div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjKl8IGLUgY86pW35eJsA42ap_8Jjl2w7eHcOhimnCuyiCAmK9d9IxztcNbTML6kR_ZEFYVyz3Sr5baCET6pKnyunAP6ruwYgkFb9fOSmV182gtS_YZjJoh3dhdR0Gj2XRbTpHEHQeQtOzw3dv0khh051t8c3w6nsP9xLwTqvTlxFnxLXAfb-63CEzf/s1998/Screen%20Shot%202022-10-28%20at%201.02.44%20PM.png\" imageanchor=\"1\" style=\"clear: left; float: left; margin-bottom: 1em; margin-left: 1em;\"><img border=\"0\" data-original-height=\"484\" data-original-width=\"1998\" height=\"173\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjKl8IGLUgY86pW35eJsA42ap_8Jjl2w7eHcOhimnCuyiCAmK9d9IxztcNbTML6kR_ZEFYVyz3Sr5baCET6pKnyunAP6ruwYgkFb9fOSmV182gtS_YZjJoh3dhdR0Gj2XRbTpHEHQeQtOzw3dv0khh051t8c3w6nsP9xLwTqvTlxFnxLXAfb-63CEzf/w714-h173/Screen%20Shot%202022-10-28%20at%201.02.44%20PM.png\" width=\"714\" /></a></div></div></div></blockquote><div><br /></div><blockquote style=\"border: none; margin: 0 0 0 40px; padding: 0px;\"><div><div><p style=\"text-align: left;\">&nbsp;Common memory mappings are:</p></div></div></blockquote><div><div>\n<ul style=\"text-align: left;\">\n\n<ul><li>[anon:libc_malloc] - Allocations made from C/C++ code using malloc or new.\n\n</li><li>*boot*.art - The boot image. A Java heap that is pre-initialized by loading and running static initializers where possible for common frameworks classes.\n\n</li><li>/dev/ashmem/dalvik-main space <em>N</em> - The main Java heap.\n\n</li><li>/dev/ashmem/dalvik-zygote space - The main Java heap of the zygote before forking a child process. Also known as the zygote heap.\n\n</li><li>/dev/ashmem/dalvik-[free list ] large object space - Heap used for Java objects larger than ~12KB. This tends to be filled with bitmap pixel data and other large primitive arrays.\n\n</li><li>*.so - Executable code from shared native libraries loaded into memory. \n\n</li><li>*.{oat,dex,odex,vdex} - Compiled dex bytecode, including optimized dex bytecode and metadata, native machine code, or a mix of both.</li></ul></ul>5.<span style=\"font-weight: bold;\">&nbsp;&nbsp; &nbsp;</span><b>Analyze native memory allocations using malloc debug</b></div><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px;\"><div style=\"text-align: left;\">Malloc debug is a method of debugging native memory problems. It can help detect memory corruption, memory leaks, and use after free issues. You can check this documentation for more understanding and <a href=\"https://android.googlesource.com/platform/bionic/+/master/libc/malloc_debug/README.md\">usage</a>.&nbsp;&nbsp;</div></blockquote><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px;\"><div style=\"text-align: left;\">&nbsp;</div></blockquote><div style=\"text-align: left;\">6.<span>&nbsp;&nbsp; &nbsp;</span><strong>Use <a href=\"https://developer.android.com/ndk/guides/asan\">Address Sanitizer</a> to detect memory errors in C/C++ code</strong></div><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px;\"><div style=\"text-align: left;\">Beginning with Android 27, Android NDK supports Address Sanitizer which is a fast compiler-based tool for detecting memory bugs in native code. ASan detects:</div></blockquote><div><ol style=\"text-align: left;\"></ol><ul style=\"text-align: left;\"><ul><li>Stack and heap buffer overflow/underflow</li><li>Heap use after free</li><li>Stack use outside scope</li><li>Double free/wild free</li></ul></ul><ol style=\"text-align: left;\"></ol><ol style=\"text-align: left;\"></ol><ol style=\"text-align: left;\"></ol><ol style=\"text-align: left;\"></ol></div><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px; text-align: left;\"><div><p style=\"display: inline; text-align: left;\">ASan runs on both 32-bit and 64-bit ARM, plus x86 and x86-64. ASan's CPU overhead is roughly 2x, code size overhead is between 50% and 2x, and the memory overhead is large (dependent on your allocation patterns, but on the order of 2x). To learn more, read <a href=\"https://developer.android.com/ndk/guides/asan\">here</a>. \n</p></div><div><p>\n\n    Camera from the Google team used it and automated the process that would run and get back to them in the form of alerts in case of Asan issues, and found it really convenient to fix memory issues missed during code authoring/review.</p></div></blockquote><div><ol>\n</ol>\n<h2 style=\"text-align: left;\">Monitoring Startup</h2>\n\n\n<h3 style=\"text-align: left;\">Analyze Startup</h3>\n\n\n1.<span style=\"font-weight: bold;\">&nbsp;&nbsp; &nbsp;</span><b>Measure and analyze time spent in major operations</b>\n</div><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px; text-align: left;\">Once you have a complete app startup trace, look at the trace and measure time taken for  major operations like bindApplication, activitystart etc.<div style=\"text-align: left;\"><p>\n\n    Look at overall time spent to</p></div></blockquote><div><ul style=\"text-align: left;\"><ul><li>Identify which operations occupy large time frames and can be optimized\n\n</li><li>Identify which operations consume high time where it is not expected. \n\n</li><li>Identify which operations cause the main thread to be blocked</li></ul></ul>2.<span style=\"font-weight: bold;\">&nbsp;&nbsp; &nbsp;</span><b>Analyze and identify different time consuming operations and their possible solutions</b></div><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px; text-align: left;\"></blockquote><ul style=\"text-align: left;\"><ul><li>Identify all  time consuming operations.</li><li>Identify any operations which are not supposed to be executed during startup (Ideally there are a lot of legacy code operations which we are not aware about and not easily visible when looking at our app code for performance)</li><li>Identify which all operations are absolutely needed OR could be delayed until your first frame is drawn.</li></ul></ul><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px; text-align: left;\"></blockquote><div>3.<span style=\"font-weight: bold;\">&nbsp;&nbsp; &nbsp;</span><b>Check Home activity load time</b></div><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px;\"><div style=\"text-align: left;\">This is your app’s home page and often performance will depend on the loading of this page. For most apps, there is a lot of data displayed on this page, spanning multiple layouts and processes running in background. Check the home activity layout and specifically look at the Choreographer.onDraw method of the home activity.</div></blockquote><div><ol>\n</ol>\n<ul style=\"text-align: left;\">\n\n<ul><li>Measure time taken for overall operations of measure, draw,inflate,animate etc.\n\n</li><li>Look at frame drops.\n\n</li><li>Identify layouts taking high time to render or measure. \n\n</li><li>Identify assets taking a long time to load.\n\n</li><li>Identify layouts not needed but still getting inflated.\n</li></ul>\n</ul>\n<h3 style=\"text-align: left;\">Tools&nbsp;</h3></div><div>&nbsp;1.&nbsp;<b>&nbsp; &nbsp;Perfetto</b><br /><ul style=\"text-align: left;\"><ul><li>To know CPU usage, thread activity, frame rendering time, Perfetto will be the best tool.</li><li>Record trace either by using command line or UI tools like Perfetto. Add app package name with the -a tag, to filter data for your app. Some ways to capture trace :</li><ul><li><a href=\"https://developer.android.com/topic/performance/tracing/on-device\">Capture a system trace through command line</a></li><li><a href=\"https://developer.android.com/topic/performance/tracing/on-device#quick-settings\">Record using a quick settings tile</a></li></ul><li>Produces a report combining data from the Android kernel, such as the CPU scheduler, disk activity, and app threads.</li><li>Best when enabled with <a href=\"https://developer.android.com/topic/performance/tracing/custom-events\">custom tracing</a> to know which method or part of code is taking how long and then develop can dig deep accordingly.</li><li>Understand <a href=\"https://perfetto.dev/docs/data-sources/atrace\">Atrace</a>, and <a href=\"https://www.kernel.org/doc/Documentation/trace/ftrace.txt\">ftrace</a> while analyzing traces through Perfetto.</li></ul></ul>2.&nbsp;<b>&nbsp; &nbsp;App Startup library</b>\n</div><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px;\"><div style=\"text-align: left;\">\n\n    The App Startup library provides a straightforward, performant way to initialize components at application startup. Both library developers and app developers can use App Startup to streamline startup sequences and explicitly set the order of initialization. Instead of defining separate content providers for each component you need to initialize, App Startup allows you to define component initializers that share a single content provider. This can significantly improve app startup time. To find how to use it in your app, refer <a href=\"https://developer.android.com/topic/libraries/app-startup\">here</a>.&nbsp;</div></blockquote><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px;\"><div style=\"text-align: left;\">&nbsp;</div></blockquote><div>3.&nbsp;&nbsp;<b> &nbsp;Baseline Profiles</b>\n</div><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px; text-align: left;\"><div><div style=\"text-align: left;\">\n\n    Baseline Profiles are a list of classes and methods included in an APK used by <a href=\"https://source.android.com/devices/tech/dalvik\">Android Runtime (ART)</a> during installation to pre-compile critical paths to machine code. This is a form of profile guided optimization (PGO) that lets apps optimize startup, reduce jank, and improve performance for end users.  Profile rules are compiled into a binary form in the APK, in assets/dexopt/baseline.prof.\n</div></div></blockquote><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px; text-align: left;\"><div><p>\n\n    During installation, ART performs Ahead-of-time (AOT) compilation of methods in the profile, resulting in those methods executing faster. If the profile contains methods used in app launch or during frame rendering, the user experiences faster launch times and/or reduced jank. For more information on usage and advantages, refer <a href=\"https://developer.android.com/topic/performance/baselineprofiles\">here</a>.&nbsp;&nbsp;</p></div></blockquote><div><div style=\"text-align: left;\">4.<span style=\"font-weight: bold;\">&nbsp;&nbsp; &nbsp;</span><b>Android CPU Profiler</b></div></div><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px;\"><div><div style=\"text-align: left;\">You can use the <a href=\"https://developer.android.com/studio/profile/cpu-profiler\">CPU Profiler</a> to inspect your app’s CPU usage and thread activity in real time while interacting with your app, or you can inspect the details in recorded method traces, function traces, and system traces. The detailed information that the CPU Profiler records and shows is determined by which recording configuration you choose:</div></div></blockquote><div><ul style=\"text-align: left;\"><ul><li><strong>System Trace:</strong> Captures fine-grained details that allow you to inspect how your app interacts with system resources.\n\n</li><li><strong>Method and function traces:</strong> For each thread in your app process, you can find out which methods (Java) or functions (C/C++) are executed over a period, and the CPU resources each method or function consumes during its execution.</li></ul></ul>5.&nbsp;<b>&nbsp; &nbsp;Debug API  + CPU Profiler</b></div><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px;\"><div style=\"text-align: left;\">To give apps the ability to start and stop recording CPU profiling and then inspect in CPU profiler is what <a href=\"https://developer.android.com/reference/android/os/Debug\">Debug API</a> is all about. It provides information about tracing and allocation counts the same way using <strong>startMethodTracing()</strong> and <strong>stopMethodTracing().</strong></div></blockquote><div style=\"text-align: left;\">&nbsp;</div><div><span id=\"docs-internal-guid-4d7beab1-7fff-f7e4-d5b2-fcd0cfb1ac2b\"><div align=\"left\" dir=\"ltr\" style=\"margin-left: 33.75pt;\"><table style=\"border-collapse: collapse; border: none;\"><colgroup><col width=\"644\"></col></colgroup><tbody><tr style=\"height: 120.75pt;\"><td style=\"background-color: #f2f2f2; border-bottom: solid #000000 1pt; border-color: rgb(0, 0, 0); border-left: solid #000000 1pt; border-right: solid #000000 1pt; border-style: solid; border-top: solid #000000 1pt; border-width: 1pt; overflow-wrap: break-word; overflow: hidden; padding: 5pt; vertical-align: top;\"><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-left: 36pt; margin-top: 0pt;\"><span face=\"&quot;Proxima Nova&quot;, sans-serif\" style=\"background-color: transparent; color: #666666; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\"> </span><span face=\"&quot;Proxima Nova&quot;, sans-serif\" style=\"background-color: transparent; color: #9900ff; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\">Debug</span><span face=\"&quot;Proxima Nova&quot;, sans-serif\" style=\"background-color: transparent; color: #666666; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\">.</span><span face=\"&quot;Proxima Nova&quot;, sans-serif\" style=\"background-color: transparent; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\">startMethodTracing(\"sample\")</span><span face=\"&quot;Proxima Nova&quot;, sans-serif\" style=\"background-color: transparent; color: #666666; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\"> - Starts recording a trace log with the name you provide</span></p><br /><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-left: 36pt; margin-top: 0pt;\"><span face=\"&quot;Proxima Nova&quot;, sans-serif\" style=\"background-color: transparent; color: #666666; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\">&nbsp;</span><span face=\"&quot;Proxima Nova&quot;, sans-serif\" style=\"background-color: transparent; color: #9c27b0; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\">Debug</span><span face=\"&quot;Proxima Nova&quot;, sans-serif\" style=\"background-color: transparent; color: #666666; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\">.</span><span face=\"&quot;Proxima Nova&quot;, sans-serif\" style=\"background-color: transparent; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\">stopMethodTracing()</span><span face=\"&quot;Proxima Nova&quot;, sans-serif\" style=\"background-color: transparent; color: #666666; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\"> - he system begins buffering the generated trace data, until the</span></p><p dir=\"ltr\" style=\"line-height: 1.38; margin-bottom: 0pt; margin-left: 36pt; margin-top: 0pt;\"><span face=\"&quot;Proxima Nova&quot;, sans-serif\" style=\"background-color: transparent; color: #666666; font-size: 11pt; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;\">&nbsp;application calls this method.</span></p></td></tr></tbody></table></div></span></div><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px;\"><div><p style=\"text-align: left;\">Usage\n</p></div></blockquote><div><ul style=\"text-align: left;\"><ul><li>Debug API is designed for <strong>short</strong> intervals or scenarios that are hard to start/stop recording manually. (Used it once to find the lock contention happening due to some library)</li></ul></ul><ul style=\"text-align: left;\"><ul><li>To generate a method trace of an app's execution, we can <a href=\"https://developer.android.com/studio/profile/generate-trace-logs\">instrument the app</a> using the <a href=\"https://developer.android.com/reference/android/os/Debug\">Debug</a> class. This way developers get more control over exactly when the device starts and stops recording tracing information.</li></ul></ul>6.<span>&nbsp;&nbsp; &nbsp;</span><a href=\"https://www.youtube.com/watch?v=0adLO2VRJtc&amp;list=PLWz5rJ2EKKc8dQ8oYOANI4qto-0jj9CQ_&amp;index=19&amp;t=2s\">MacroBenchmark</a></div><div><ul style=\"text-align: left;\"><ul><li>Measures Scrolling / Animation rendering time.</li><li>Use a <strong>UiAutomator</strong> to trigger a scroll or animation. (It captures frame timing / janks for whatever the app is doing. Scroll and animations are just the easiest ways to produce frames where jank is noticeable)</li><li>Requires Android 10 or higher to run the tests.</li><li>Can view traces on Systrace/Perfetto Traces.</li><li><strong>FrameTimingMetric</strong> is the API reporting frame time in ms.</li></ul></ul></div><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px;\"><div style=\"text-align: left;\">This <a href=\"https://github.com/android/performance-samples/blob/main/MacrobenchmarkSample/macrobenchmark/src/main/java/com/example/macrobenchmark/FrameTimingBenchmark.kt\">sample</a> can be used for app instrumentation.&nbsp;</div></blockquote><div style=\"text-align: left;\">&nbsp;</div><div style=\"text-align: left;\">7.<span>&nbsp;&nbsp; &nbsp;</span><a href=\"https://developer.android.com/guide/topics/manifest/profileable-element\">Profiling Release Builds</a></div><p></p><ul style=\"text-align: left;\"><ul><li>Added in API level 30 and supported in the latest Studio Bumblebee preview (2021.1)</li><li>Uses simpleperf with customized build scripts for profiling.</li><li>Simpleperf supports profiling java code on Android &gt;M.</li><li>Profiling a release build requires one of following:</li><ul><li>Device to be rooted</li><li>Android &gt;=O, use a script <a href=\"https://developer.android.com/ndk/guides/wrap-script.html\">wrap.sh</a> and make android::debuggable=“true” to enable profiling.</li><li>Android &gt;=Q, add <strong>profileable</strong> in manifest flag.</li></ul></ul></ul><p></p><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px;\"><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px;\"><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px;\"><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px;\"><p style=\"text-align: left;\">&lt;profileable android:<a href=\"https://developer.android.com/guide/topics/manifest/profileable-element#shell\">shell</a>=[\"true\" | \"false\"] android:<a href=\"https://developer.android.com/guide/topics/manifest/profileable-element#enable\">enable</a>=[\"true\" | \"false\"] /&gt;</p></blockquote></blockquote></blockquote></blockquote><div><ul style=\"text-align: left;\"><ul><li>Helpful in app <strong>instrumentation</strong> with Macrobenchmark.</li></ul></ul>\n8.<span>&nbsp;&nbsp; &nbsp;</span><a href=\"https://developer.android.com/topic/performance/benchmarking/microbenchmark-overview\">MicroBenchmark</a>\n</div><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px;\"><div style=\"text-align: left;\">\n\n    The Jetpack Microbenchmark library allows you to quickly benchmark your Android native code (Kotlin or Java) from within Android Studio. The library handles warmup, measures your code performance and allocation counts, and outputs benchmarking results to both the <a href=\"https://developer.android.com/studio/profile/microbenchmark-write#benchmark-results\">Android Studio console</a> and a <a href=\"https://developer.android.com/studio/profile/benchmarking-in-ci#benchmark-data-example\">JSON file</a> with more detail. Read more <a href=\"https://developer.android.com/topic/performance/benchmarking/microbenchmark-overview\">here</a>.</div></blockquote><div><ol>\n</ol>\n<h3 style=\"text-align: left;\">Monitoring App size</h3>\n\n\n<p>\nNo user wants to download a large APK that might consume most of their Network/Wifi Bandwidth, also most importantly, space inside the mobile device.\n</p>\n<p>\nThe size of your APK has an impact on how fast your app loads, how much memory it uses, and how much power it consumes. Reducing your app's download size enables more users to download your app.\n</p><div style=\"text-align: left;\"><br /></div>\n<h3 style=\"text-align: left;\">Tools</h3><ul style=\"text-align: left;\"><li><strong>Use the Android Size Analyzer</strong></li></ul></div><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px;\"><div style=\"text-align: left;\">The <a href=\"https://developer.android.com/topic/performance/reduce-apk-size#size-analyzer\">Android Size Analyze</a>r tool is an easy way to identify and implement many strategies for reducing the size of your app. It is available as both an Android Studio plugin as well as a standalone JAR</div></blockquote><div><ul style=\"text-align: left;\"><li><strong>Remove unused resources using Lint</strong></li></ul></div><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px;\"><div style=\"text-align: left;\">The <a href=\"https://developer.android.com/studio/write/lint\">lint</a> tool, a static code analyzer included in Android Studio, detects resources in your res/ folder that your code doesn't reference. When the lint tool discovers a potentially unused resource in your project, it prints a message like the following example.</div></blockquote><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px; text-align: left;\"><div><p style=\"text-align: left;\">\n\n    Note : Libraries that you add to your code may include unused resources. Gradle can automatically remove resources on your behalf if you enable <a href=\"https://developer.android.com/studio/build/shrink-code#shrink-resources\">shrinkResources</a> in your app's build.gradle file.\n</p></div></blockquote><div><ul style=\"text-align: left;\"><li><strong>Native animated image decoding</strong></li></ul></div><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px;\"><div style=\"text-align: left;\">In Android 12 (API level 31), the NDK <a href=\"https://developer.android.com/ndk/reference/group/image-decoder\">ImageDecoder</a> API has been expanded to decode all frames and timing data from images that use the animated <a href=\"https://en.wikipedia.org/wiki/GIF\">GIF</a> and animated <a href=\"https://developers.google.com/speed/webp\">WebP</a> file formats. When it was introduced in Android 11, this API decoded only the first image from animations in these formats.&nbsp;</div></blockquote><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px;\"><div style=\"text-align: left;\">&nbsp;</div></blockquote><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px; text-align: left;\"><div style=\"text-align: left;\">Use ImageDecoder instead of third-party libraries to further <a href=\"https://developer.android.com/topic/performance/reduce-apk-size#minimize\">decrease APK size</a> and benefit from future updates related to security and performance.&nbsp;</div></blockquote><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px; text-align: left;\"><div style=\"text-align: left;\">&nbsp;</div></blockquote><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px; text-align: left;\"><div><div style=\"text-align: left;\">\n\n    For more details on the API, refer to the <a href=\"https://developer.android.com/ndk/reference/group/image-decoder\">API reference</a> and the <a href=\"https://github.com/android/ndk-samples/tree/develop/webp/image-decoder\">sample on GitHub</a>. \n</div></div></blockquote><div><ul style=\"text-align: left;\"><li><strong>Crunch PNG files using aapt</strong></li></ul></div><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px;\"><div style=\"text-align: left;\">The <strong>aapt</strong> tool can optimize the image resources placed in <strong>res/drawable/ </strong>with lossless compression during the build process. For example, the aapt tool can convert a true-color PNG that does not require more than 256 colors to an 8-bit PNG with a color palette. Doing so results in an image of equal quality but a smaller memory footprint. Read more <a href=\"https://developer.android.com/topic/performance/reduce-apk-size#crunch\">here</a>.</div></blockquote><blockquote style=\"border: none; margin: 0px 0px 0px 40px; padding: 0px;\"><div><p style=\"text-align: left;\"><strong>Note</strong> : Please check Android developer <a href=\"https://developer.android.com/topic/performance\">documentation</a> for all the useful tools which can help you identify and help fix such performance issues. \n</p></div></blockquote><div>\n\n<h2 style=\"text-align: left;\"><strong>Recap</strong></h2>\n\n\n<p>\nThis part of the blog captures the tools used by Google to identify and fix performance issues in their apps. They saw great improvements in their metrics. Most Android Go apps could benefit from applying the strategies described above. Optimize and make your app delightful and fast for your users!\n</p><ul style=\"text-align: left;\"><li><a href=\"https://android-developers.googleblog.com/2022/09/optimize-for-android-go-lessons-from-google-apps-part-1.html\" target=\"_blank\">Optimize for Android (Go edition): Lessons from Google apps – Part 1</a></li><li><a href=\"https://android-developers.googleblog.com/2022/09/optimize-for-android-go-lessons-from-google-apps-part-2.html\" target=\"_blank\">Optimize for Android (Go edition): Lessons from Google apps – Part 2</a></li><li>Optimize for Android (Go edition): Lessons from Google apps – Part 3&nbsp;</li></ul><p></p></div><p></p></div>",
  "link": [
    "",
    "",
    ""
  ],
  "author": {
    "name": "Android Developers",
    "uri": "http://www.blogger.com/profile/08588467489110681140",
    "email": "noreply@blogger.com",
    "gd:image": ""
  },
  "media:thumbnail": ""
}