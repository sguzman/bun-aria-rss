{
  "id": "tag:blogger.com,1999:blog-8474926331452026626.post-5711145003816917897",
  "published": "2022-08-25T09:55:00.001-07:00",
  "updated": "2022-10-21T06:31:27.948-07:00",
  "category": [
    "",
    "",
    ""
  ],
  "title": "High-Definition Segmentation in Google Meet",
  "content": "<span class=\"byline-author\">Posted by Tingbo Hou and Juhyun Lee, Software Engineers, Google</span> <p>In recent years video conferencing has played an increasingly important role in both work and personal communication for many users. Over the past two years, we have enhanced this experience in Google Meet by introducing privacy-preserving machine learning (ML) powered <a href=\"https://ai.googleblog.com/2020/10/background-features-in-google-meet.html\">background features</a>, also known as “virtual green screen”, which allows users to blur their backgrounds or replace them with other images. What is unique about this solution is that it runs directly in the browser without the need to install additional software.  </p><a name='more'></a><p>So far, these ML-powered features have relied on CPU inference made possible by leveraging neural network <a href=\"https://ai.googleblog.com/2021/03/accelerating-neural-networks-on-mobile.html\">sparsity</a>, a common solution that works across devices, from entry level computers to high-end workstations. This enables our features to reach the widest audience. However, mid-tier and high-end devices often have powerful GPUs that remain untapped for ML inference, and existing functionality allows web browsers to access GPUs via shaders (WebGL).  </p><p>With the <a href=\"https://workspaceupdates.googleblog.com/2022/08/improved-performance-for-google-meet-effects-web.html\">latest update</a> to Google Meet, we are now harnessing the power of GPUs to significantly improve the fidelity and performance of these background effects. As we detail in “<a href=\"https://arxiv.org/abs/2208.11666\">Efficient Heterogeneous Video Segmentation at the Edge</a>”, these advances are powered by two major components: 1) a novel real-time video segmentation model and 2) a new, highly efficient approach for in-browser ML acceleration using <a href=\"https://www.khronos.org/webgl/\">WebGL</a>. We leverage this capability to develop fast ML inference via fragment shaders. This combination results in substantial gains in accuracy and latency, leading to crisper foreground boundaries. </p><table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto;\"><tbody><tr><td style=\"text-align: center;\"><a href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgYoFEI9Z1DT05sxKHuaDFkHeKOIKkULJ1BzzZWxjfWOf9DhNpu5BtMpFkiaE6amDrRkrOd8rlNj0_gkMisp4JRm1JfiHMF6AgYl_7Eu_8OtfuBqE10z8sx79XetxiwkUrOIxX372pYOaXQGywTzCKGMPb1XI80BWd1WgKOlkOfRVbnPePh4pGTCunWsg/s960/image2.gif\" imageanchor=\"1\" style=\"margin-left: auto; margin-right: auto;\"><img border=\"0\" data-original-height=\"540\" data-original-width=\"960\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgYoFEI9Z1DT05sxKHuaDFkHeKOIKkULJ1BzzZWxjfWOf9DhNpu5BtMpFkiaE6amDrRkrOd8rlNj0_gkMisp4JRm1JfiHMF6AgYl_7Eu_8OtfuBqE10z8sx79XetxiwkUrOIxX372pYOaXQGywTzCKGMPb1XI80BWd1WgKOlkOfRVbnPePh4pGTCunWsg/s16000/image2.gif\" /></a></td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\">CPU segmentation vs. HD segmentation in Meet.</td></tr></tbody></table><p><b>Moving Towards Higher Quality Video Segmentation Models</b><br>To predict finer details, our new segmentation model now operates on high definition (HD) input images, rather than lower-resolution images, effectively doubling the resolution over the previous model. To accommodate this, the model must be of higher capacity to extract features with sufficient detail. Roughly speaking, doubling the input resolution quadruples the computation cost during inference.  </p><p>Inference of high-resolution models using the CPU is not feasible for many devices. The CPU may have a few high-performance cores that enable it to execute arbitrary complex code efficiently, but it is limited in its ability for the parallel computation required for HD segmentation. In contrast, GPUs have many, relatively low-performance cores coupled with a wide memory interface, making them uniquely suitable for high-resolution convolutional models. Therefore, for mid-tier and high-end devices, we adopt a significantly faster pure GPU pipeline, which is integrated using WebGL. </p><p>This change inspired us to revisit some of the <a href=\"https://ai.googleblog.com/2020/10/background-features-in-google-meet.html\">prior design decisions</a> for the model architecture. </p><ul><li><i>Backbone</i>: We compared several widely-used backbones for on-device networks and found <a href=\"https://ai.googleblog.com/2021/03/accelerating-neural-networks-on-mobile.html\">EfficientNet-Lite</a> to be a better fit for the GPU because it removes the <a href=\"https://towardsdatascience.com/squeeze-and-excitation-networks-9ef5e71eacd7\">squeeze-and-excitation</a> block, a component that is inefficient on WebGL (more below).  </li>  <li><i>Decoder</i>: We switched to a <a href=\"https://en.wikipedia.org/wiki/Multilayer_perceptron\">multi-layer perceptron</a> (MLP) decoder consisting of 1x1 convolutions instead of using simple <a href=\"https://en.wikipedia.org/wiki/Bilinear_interpolation\">bilinear upsampling</a> or the more expensive squeeze-and-excitation blocks. MLP has been successfully adopted in other segmentation architectures, like <a href=\"https://arxiv.org/pdf/1606.00915v2.pdf\">DeepLab</a> and <a href=\"https://arxiv.org/abs/1912.08193\">PointRend</a>, and is efficient to compute on both CPU and GPU. </li>  <li><i>Model size</i>: With our new WebGL inference and the GPU-friendly model architecture, we were able to afford a larger model without sacrificing the real-time frame rate necessary for smooth video segmentation. We explored the width and the depth parameters using a <a href=\"https://en.wikipedia.org/wiki/Neural_architecture_search\">neural architecture search</a>. </li></ul><table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto;\"><tbody><tr><td style=\"text-align: center;\"><a href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEifJcsUJGVS17V9XcmV2GKC7eXFp5QB7SdifP16D6J_Ga_cIDYncUM1mnfy84c4JFyy0iejTsKI1ih7Kfn2keYY8p57gCQM4htLRwbQ5FRVkSYsRZqjy9C8TXaErH9-CFadH5y20ZzT5N3BgDjft7YkqlXskd2UYX3YzXFsDEUjDgSfMdGgNXnXfGT5Vg/s1065/image3.jpg\" imageanchor=\"1\" style=\"margin-left: auto; margin-right: auto;\"><img border=\"0\" data-original-height=\"295\" data-original-width=\"1065\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEifJcsUJGVS17V9XcmV2GKC7eXFp5QB7SdifP16D6J_Ga_cIDYncUM1mnfy84c4JFyy0iejTsKI1ih7Kfn2keYY8p57gCQM4htLRwbQ5FRVkSYsRZqjy9C8TXaErH9-CFadH5y20ZzT5N3BgDjft7YkqlXskd2UYX3YzXFsDEUjDgSfMdGgNXnXfGT5Vg/s16000/image3.jpg\" /></a></td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\">HD segmentation model architecture.</td></tr></tbody></table><p>In aggregate, these changes substantially improve the mean <a href=\"https://en.wikipedia.org/wiki/Jaccard_index\">Intersection over Union</a> (IoU) metric by 3%, resulting in less uncertainty and crisper boundaries around hair and fingers. <br /><br />We have also released the accompanying <a href=\"https://mediapipe.page.link/meet-hd-segmentation-mc\">model card</a> for this segmentation model, which details our fairness evaluations. Our analysis shows that the model is consistent in its performance across the various regions, skin-tones, and genders, with only small deviations in IoU metrics. </p><table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto;\"><tbody><tr>   <td><b>Model</b>   </td>  <td>&nbsp;&nbsp;&nbsp;</td>   <td><b>Resolution</b>   </td>    <td>&nbsp;&nbsp;&nbsp;</td>   <td><b>Inference</b>   </td>  <td>&nbsp;&nbsp;&nbsp;</td>   <td><b>IoU</b>   </td>  <td>&nbsp;&nbsp;&nbsp;</td>   <td><b>Latency (ms)</b>   </td>  </tr>  <tr>    <td><i>CPU segmenter</i>   </td>    <td>&nbsp;&nbsp;&nbsp;</td>   <td>256×144    </td>    <td>&nbsp;&nbsp;&nbsp;</td>   <td><a href=\"https://ai.googleblog.com/2020/10/background-features-in-google-meet.html\">Wasm SIMD</a>   </td>    <td>&nbsp;&nbsp;&nbsp;</td>   <td>94.0%    </td>    <td>&nbsp;&nbsp;&nbsp;</td>   <td>8.7    </td>  </tr>  <tr>    <td><i>GPU segmenter</i>   </td>    <td>&nbsp;&nbsp;&nbsp;</td>   <td>512×288    </td>    <td>&nbsp;&nbsp;&nbsp;</td>   <td>WebGL    </td>    <td>&nbsp;&nbsp;&nbsp;</td>   <td>96.9%    </td>    <td>&nbsp;&nbsp;&nbsp;</td>   <td>4.3    </td>  </tr></tbody></table><table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto;\"><tbody><tr><td class=\"tr-caption\" style=\"text-align: center;\">Comparison of the previous segmentation model vs. the new HD segmentation model on a Macbook Pro (2018).</td></tr></tbody></table><p><b>Accelerating Web ML with WebGL</b><br>One common challenge for web-based inference is that web technologies can incur a performance penalty when compared to apps running natively on-device. For GPUs, this penalty is substantial, only achieving around 25% of native <a href=\"https://en.wikipedia.org/wiki/OpenGL\">OpenGL</a> performance. This is because WebGL, the current GPU standard for Web-based inference, was primarily designed for image rendering, not arbitrary ML workloads. In particular, WebGL does not include <a href=\"https://en.wikipedia.org/wiki/Compute_kernel\">compute shaders</a>, which allow for general purpose computation and enable ML workloads in mobile and native apps. </p><p>To overcome this challenge, we accelerated low-level neural network kernels with <a href=\"https://en.wikipedia.org/wiki/Shader#Pixel_shaders\">fragment shaders</a> that typically compute the output properties of a pixel like color and depth, and then applied novel optimizations inspired by the graphics community. As ML workloads on GPUs are often bound by memory bandwidth rather than compute, we focused on rendering techniques that would improve the memory access, such as <a href=\"https://en.wikipedia.org/wiki/Multiple_Render_Targets\">Multiple Render Targets</a> (MRT). </p><p>MRT is a feature in modern GPUs that allows rendering images to multiple output textures (OpenGL objects that represent images) at once. While MRT was originally designed to support advanced graphics rendering such as <a href=\"https://en.wikipedia.org/wiki/Deferred_shading\">deferred shading</a>, we found that we could leverage this feature to drastically reduce the memory bandwidth usage of our fragment shader implementations for critical operations, like convolutions and fully connected layers. We do so by treating intermediate tensors as multiple OpenGL textures. </p><p>In the figure below, we show an example of intermediate tensors having four underlying GL textures each. With MRT, the number of GPU threads, and thus effectively the number of memory requests for weights, is reduced by a factor of four and saves memory bandwidth usage. Although this introduces considerable complexities in the code, it helps us reach over 90% of native OpenGL performance,<strong> </strong>closing the gap with native applications. </p><table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto;\"><tbody><tr><td style=\"text-align: center;\"><a href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjT_kMDy1cnR_15fZjXbHnEdTbZPKse_UrnG_9L4iZ2Az8EM8ng_2benILGrAZJ4OpIS9NR22gv09Zgzb_DR6PhLW_AkHEcWMihfJ55PWDmzGsKRNDSmqFQbbQJtFV9vQSp6YdOFMQI7kI-plLL-KVWBo6qeQZSw7UlSvOhzYDxnlsBfgxlZuA72IllLw/s1762/image1.png\" imageanchor=\"1\" style=\"margin-left: auto; margin-right: auto;\"><img border=\"0\" data-original-height=\"1214\" data-original-width=\"1762\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjT_kMDy1cnR_15fZjXbHnEdTbZPKse_UrnG_9L4iZ2Az8EM8ng_2benILGrAZJ4OpIS9NR22gv09Zgzb_DR6PhLW_AkHEcWMihfJ55PWDmzGsKRNDSmqFQbbQJtFV9vQSp6YdOFMQI7kI-plLL-KVWBo6qeQZSw7UlSvOhzYDxnlsBfgxlZuA72IllLw/s16000/image1.png\" /></a></td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\">Left: A classic implementation of Conv2D with 1-to-1 correspondence of tensor and an OpenGL texture.  Red, yellow, green, and blue boxes denote different locations in a single texture each for intermediate tensor A and B. Right: Our implementation of Conv2D with MRT where intermediate tensors A and B are realized with a set of 4 GL textures each, depicted as red, yellow, green, and blue boxes. Note that this reduces the request count for weights by 4x.</td></tr></tbody></table><p><b>Conclusion</b><br>We have made rapid strides in improving the quality of real-time segmentation models by leveraging the GPU on mid-tier and high-end devices for use with Google Meet. We look forward to the possibilities that will be enabled by upcoming technologies like <a href=\"https://en.wikipedia.org/wiki/WebGPU\">WebGPU</a>, which bring compute shaders to the web. Beyond GPU inference, we're also working on improving the segmentation quality for lower powered devices with quantized inference via <a href=\"https://github.com/google/XNNPACK\">XNNPACK</a> <a href=\"https://webassembly.org/\">WebAssembly</a>. </p><p><b>Acknowledgements</b><br><em>Special thanks to those on the Meet team and others who worked on this project, in particular Sebastian Jansson, Sami Kalliomäki, Rikard Lundmark, Stephan Reiter, Fabian Bergmark, Ben Wagner, Stefan Holmer, Dan Gunnarsson, Stéphane Hulaud, and to all our team members who made this possible: Siargey Pisarchyk, Raman Sarokin, Artsiom Ablavatski, Jamie Lin, Tyler Mullen, Gregory Karpiak, Andrei Kulik, Karthik Raveendran, Trent Tolley, and Matthias Grundmann.</em></p>",
  "link": [
    "",
    "",
    "",
    "",
    ""
  ],
  "author": {
    "name": "Google AI",
    "uri": "http://www.blogger.com/profile/12098626514775266161",
    "email": "noreply@blogger.com",
    "gd:image": ""
  },
  "media:thumbnail": "",
  "thr:total": 0
}