{
  "title": "Is it time to stop using sentinel values for null / \"NA\" values?",
  "link": "",
  "published": "2018-10-12T00:00:00-07:00",
  "updated": "2018-10-12T00:00:00-07:00",
  "author": {
    "name": "Wes McKinney"
  },
  "id": "tag:wesmckinney.com,2018-10-12:/blog/bitmaps-vs-sentinel-values/",
  "summary": "<p>This blog posts discusses the design and performance implications of using\nbitmaps to mark null values instead of sentinel values (or special values like\n<code>NaN</code>).</p>\n<h1>How Apache Arrow's columnar format handles null values</h1>\n<p>Depending on who you talk to, one controversial aspect of the <a href=\"http://arrow.apache.org\">Apache Arrow</a>\ncolumnar format is the â€¦</p>",
  "content": "<p>This blog posts discusses the design and performance implications of using\nbitmaps to mark null values instead of sentinel values (or special values like\n<code>NaN</code>).</p>\n<h1>How Apache Arrow's columnar format handles null values</h1>\n<p>Depending on who you talk to, one controversial aspect of the <a href=\"http://arrow.apache.org\">Apache Arrow</a>\ncolumnar format is the fact that it uses a <strong>validity bitmap</strong> to mark value as\nnull or not null. Here's the basic idea:</p>\n<ul>\n<li>The number of nulls is a property of an array, generally computed once then\n  stored</li>\n<li>If an array has any null values at all, then a bitmap must be allocated</li>\n<li>If the value at bit <em>i</em> is 0, then the value is null, otherwise it is not\n  null</li>\n</ul>\n<p>There's some nice benefits of the bitmap approach:</p>\n<ul>\n<li>If an array has no nulls, then the bitmap can be ignored or simply not\n  allocated at all</li>\n<li>Nulls can be propagated in algorithms by using word-wise AND or OR\n  operations, processing 32 or 64 values at a time</li>\n</ul>\n<p>Still, for systems like R which use special values to mark nulls, bitmaps can\nbe controversial. The argument sometimes centers on the performance\nimplications of having to check bits rather than comparing a value with\n<code>INT32_MIN</code> or checking if it is <code>NaN</code>. It is also noted that <code>NaN</code> values are\npropagated automatically by the CPU in arithmetic operations, so propagating\nnulls in the bitmap case will be necessarily slower.</p>\n<h1>The database perspective</h1>\n<p>From the perspective of databases and data warehousing, reserving certain\nvalues to mark a null (or NA) is widely considered unacceptable. <code>NaN</code> is valid\ndata, as is <code>INT32_MIN</code> and other common values used as sentinels.</p>\n<p>Most SQL systems store the null-ness of value using an extra bit or byte. File\nformats like Apache Avro and Parquet have a separate null/not-null encoding.</p>\n<h1>Are sentinel values faster than bitmaps (for analytics)?</h1>\n<p>To show that the performance argument against bitmaps is not persuasive, I\nwrote some in-memory performance benchmarks (I would like to do some\nexperiments with large memory-mapped datasets). To keep things simple, let's\nconsider the <code>sum</code> operation which must aggregate all of the non-null values in\nan array. We also will track the non-null count.</p>\n<p>We are interested in a few typical cases:</p>\n<ul>\n<li>Data with no nulls</li>\n<li>Data with a small percentage of nulls, say 10%</li>\n<li>Data with a high percentage of nulls, say 50%</li>\n</ul>\n<p>To keep track of the results of a sum, I use a simple struct, templated on the\ntype of the values:</p>\n<div class=\"github\"><pre><span></span><code><span class=\"k\">template</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"k\">typename</span><span class=\"w\"> </span><span class=\"nc\">T</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">SumState</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">SumState</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">total</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">valid_count</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">total</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kt\">int64_t</span><span class=\"w\"> </span><span class=\"n\">valid_count</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n\n<p>The naive sum looks like this</p>\n<div class=\"github\"><pre><span></span><code><span class=\"k\">template</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"k\">typename</span><span class=\"w\"> </span><span class=\"nc\">T</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">SumNoNulls</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">static</span><span class=\"w\"> </span><span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"nf\">Sum</span><span class=\"p\">(</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">values</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">int64_t</span><span class=\"w\"> </span><span class=\"n\">length</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">SumState</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;*</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">int64_t</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"w\"> </span><span class=\"n\">length</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"o\">++</span><span class=\"n\">i</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"n\">state</span><span class=\"o\">-&gt;</span><span class=\"n\">total</span><span class=\"w\"> </span><span class=\"o\">+=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">values</span><span class=\"o\">++</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">state</span><span class=\"o\">-&gt;</span><span class=\"n\">valid_count</span><span class=\"w\"> </span><span class=\"o\">+=</span><span class=\"w\"> </span><span class=\"n\">length</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n\n<p>Let's consider double precision floating point values, where <code>NaN</code> is a common\nsentinel value. So a sum function for <code>double</code> is:</p>\n<div class=\"github\"><pre><span></span><code><span class=\"k\">template</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"k\">typename</span><span class=\"w\"> </span><span class=\"nc\">T</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">SumWithNaN</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">static</span><span class=\"w\"> </span><span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"nf\">Sum</span><span class=\"p\">(</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">values</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">int64_t</span><span class=\"w\"> </span><span class=\"n\">length</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">SumState</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;*</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">int64_t</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"w\"> </span><span class=\"n\">length</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"o\">++</span><span class=\"n\">i</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">values</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">values</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// NaN is not equal to itself</span>\n<span class=\"w\">        </span><span class=\"n\">state</span><span class=\"o\">-&gt;</span><span class=\"n\">total</span><span class=\"w\"> </span><span class=\"o\">+=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">values</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">++</span><span class=\"n\">state</span><span class=\"o\">-&gt;</span><span class=\"n\">valid_count</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"o\">++</span><span class=\"n\">values</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n\n<p>If we represent nulls with bits, we could write the sum naively like so:</p>\n<div class=\"github\"><pre><span></span><code><span class=\"cp\">#include</span><span class=\"w\"> </span><span class=\"cpf\">&quot;arrow/util/bit-util.h&quot;</span><span class=\"cp\"></span>\n\n<span class=\"k\">template</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"k\">typename</span><span class=\"w\"> </span><span class=\"nc\">T</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">SumBitmapNaive</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">static</span><span class=\"w\"> </span><span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"nf\">Sum</span><span class=\"p\">(</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">values</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">uint8_t</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">valid_bitmap</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                  </span><span class=\"kt\">int64_t</span><span class=\"w\"> </span><span class=\"n\">length</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">SumState</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;*</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">int64_t</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"w\"> </span><span class=\"n\">length</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"o\">++</span><span class=\"n\">i</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">BitUtil</span><span class=\"o\">::</span><span class=\"n\">GetBit</span><span class=\"p\">(</span><span class=\"n\">valid_bitmap</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">state</span><span class=\"o\">-&gt;</span><span class=\"n\">total</span><span class=\"w\"> </span><span class=\"o\">+=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">values</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">++</span><span class=\"n\">state</span><span class=\"o\">-&gt;</span><span class=\"n\">valid_count</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"o\">++</span><span class=\"n\">values</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n\n<h1>Summing much faster: eliminate branching, unroll loops, pre-compute popcounts</h1>\n<p>It's possible to go much faster using bitmaps with a few optimization\ntechniques:</p>\n<ul>\n<li>Eliminate the \"if\" statements by using floating point operations to\nconditionally add the non-null values</li>\n<li>\"Unroll\" part of the for loop to sum 8 values at a time</li>\n<li>Skip null checking for groups of 8 values with no nulls. This is made faster\n  still by generating a pre-populated table of bit popcounts for <code>uint8_t</code>\n  values.</li>\n</ul>\n<p>Here's the meat of this new vectorized sum algorithm:</p>\n<div class=\"github\"><pre><span></span><code><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">int64_t</span><span class=\"w\"> </span><span class=\"n\">whole_bytes</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"o\">/</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">for</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">int64_t</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"w\"> </span><span class=\"n\">whole_bytes</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"o\">++</span><span class=\"n\">i</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">uint8_t</span><span class=\"w\"> </span><span class=\"n\">valid_byte</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">valid_bitmap</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">];</span><span class=\"w\"></span>\n\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">valid_byte</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"w\"> </span><span class=\"mh\">0xFF</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// Some nulls</span>\n<span class=\"w\">    </span><span class=\"n\">state</span><span class=\"o\">-&gt;</span><span class=\"n\">total</span><span class=\"w\"> </span><span class=\"o\">+=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">values</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">valid_byte</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"p\">(</span><span class=\"n\">values</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"p\">((</span><span class=\"n\">valid_byte</span><span class=\"w\"> </span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"p\">(</span><span class=\"n\">values</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"p\">((</span><span class=\"n\">valid_byte</span><span class=\"w\"> </span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"p\">(</span><span class=\"n\">values</span><span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"p\">((</span><span class=\"n\">valid_byte</span><span class=\"w\"> </span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"p\">(</span><span class=\"n\">values</span><span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"p\">((</span><span class=\"n\">valid_byte</span><span class=\"w\"> </span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"p\">(</span><span class=\"n\">values</span><span class=\"p\">[</span><span class=\"mi\">5</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"p\">((</span><span class=\"n\">valid_byte</span><span class=\"w\"> </span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"p\">(</span><span class=\"n\">values</span><span class=\"p\">[</span><span class=\"mi\">6</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"p\">((</span><span class=\"n\">valid_byte</span><span class=\"w\"> </span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"p\">(</span><span class=\"n\">values</span><span class=\"p\">[</span><span class=\"mi\">7</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"p\">((</span><span class=\"n\">valid_byte</span><span class=\"w\"> </span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"mi\">7</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">state</span><span class=\"o\">-&gt;</span><span class=\"n\">valid_count</span><span class=\"w\"> </span><span class=\"o\">+=</span><span class=\"w\"> </span><span class=\"n\">kBytePopcount</span><span class=\"p\">[</span><span class=\"n\">valid_byte</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// No nulls</span>\n<span class=\"w\">    </span><span class=\"n\">state</span><span class=\"o\">-&gt;</span><span class=\"n\">total</span><span class=\"w\"> </span><span class=\"o\">+=</span><span class=\"w\"> </span><span class=\"n\">values</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">values</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">values</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">values</span><span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">values</span><span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">values</span><span class=\"p\">[</span><span class=\"mi\">5</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">values</span><span class=\"p\">[</span><span class=\"mi\">6</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">values</span><span class=\"p\">[</span><span class=\"mi\">7</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">state</span><span class=\"o\">-&gt;</span><span class=\"n\">valid_count</span><span class=\"w\"> </span><span class=\"o\">+=</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">values</span><span class=\"w\"> </span><span class=\"o\">+=</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n<p>To give a fair comparison with a sum without nulls, I also wrote similar\nversions of this that sums 8 values at a time in the non-nullable case and\n<code>NaN</code> sentinel value case. I also added the same benchmark with <code>int64</code> values\nusing <code>INT64_MIN</code> as the sentinel value in case integer operations perform\ndifferently from floating point operations.</p>\n<p><a href=\"http://github.com/wesm/bitmaps-vs-sentinels\"><strong>Complete benchmarking code is here</strong></a>. Here are the performance results\nfor the 3 cases there there are 0%, 10%, and 50% nulls, respectively. The size\nof the array being summed is 10 million values. The machine is my Xeon E3-1505M\nLinux laptop.</p>\n<blockquote>\n<p>It's definitely possible that I'm doing something suboptimal in my\n  implementations. I would love to hear from algorithms experts!</p>\n</blockquote>\n<p><center>\n<img src=\"../../images/bitmaps_vs_sentinels.png\" alt=\"Benchmark results\" width=\"100%\"/>\n</center></p>\n<p>Some observations on these benchmark results:</p>\n<ul>\n<li>The \"no nulls\" sum functions, both vectorized and not, perform the same for\n  all 3 cases, since it does no null checking at all</li>\n<li>When there are no nulls, there is no performance penality with the optimized\n  bitmap sum</li>\n<li>When there are 10% nulls, the bitmap sum is about 30% faster than the\n  sentinel-based sum. The performance gap widens when the percentage of nulls\n  is higher.</li>\n<li>The vectorized bitmap sum is faster when there are 50% nulls than when there\n  are 10% nulls. I am not sure why this is; I would speculate that because on\n  average many of the terms in the sum are 0 that the processor is able to\n  avoid some floating point operations. It might be possible to further\n  optimize by reducing the number of possible FP operations using a \"binary\n  tree\" sum.</li>\n<li>Vectorization / batching brings little benefit to the sentinel-based algorithm</li>\n</ul>\n<h1>Conclusions</h1>\n<p>Using a bit- or byte-based masked null representation is a requirement for a\ncommon memory format to be accepted by database systems as well as data science\nlibraries, so using sentinel values at all is not really an option in a project\nlike Apache Arrow. But, in many cases, using bitmaps allows faster algorithms\nto be developed that are not possible with the sentinel value-based null\nrepresentation used in pandas and R.</p>\n<p>I'm not a perfect programmer, so I'll be interested to see what other kinds of\noptimizations others can cook up. Take a look at the <a href=\"http://github.com/wesm/bitmaps-vs-sentinels\">benchmark code</a>!</p>"
}