<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>R2RT</title><link href="https://r2rt.com/" rel="alternate"></link><link href="https://r2rt.com/feeds/all.atom.xml" rel="self"></link><id>https://r2rt.com/</id><updated>2018-04-08T00:00:00-04:00</updated><entry><title>Synthetic Gradients with Tensorflow</title><link href="https://r2rt.com/synthetic-gradients-with-tensorflow.html" rel="alternate"></link><published>2018-04-08T00:00:00-04:00</published><updated>2018-04-08T00:00:00-04:00</updated><author><name>Silviu Pitis</name></author><id>tag:r2rt.com,2018-04-08:/synthetic-gradients-with-tensorflow.html</id><summary type="html">I stumbled upon Max Jaderberg's Synthetic Gradients paper while thinking about different forms of communication between neural modules. It's a simple idea: rather than compute gradients through backpropagation, we can train a model to predict what those gradients will be, and use our prediction to update our weights. I wanted to try using this in my own work and didn't find a Tensorflow implementation to my liking, so here is mine. I also take this opportunity to (attempt to) answer one of the questions I had while reading the paper: why not use synthetic loss instead of synthetic gradients?</summary><content type="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;meta name="generator" content="pandoc"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes"&gt;
  &lt;title&gt;&lt;/title&gt;
  &lt;style type="text/css"&gt;code{white-space: pre;}&lt;/style&gt;
  &lt;style type="text/css"&gt;
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code &gt; span.kw { color: #007020; font-weight: bold; } /* Keyword */
code &gt; span.dt { color: #902000; } /* DataType */
code &gt; span.dv { color: #40a070; } /* DecVal */
code &gt; span.bn { color: #40a070; } /* BaseN */
code &gt; span.fl { color: #40a070; } /* Float */
code &gt; span.ch { color: #4070a0; } /* Char */
code &gt; span.st { color: #4070a0; } /* String */
code &gt; span.co { color: #60a0b0; font-style: italic; } /* Comment */
code &gt; span.ot { color: #007020; } /* Other */
code &gt; span.al { color: #ff0000; font-weight: bold; } /* Alert */
code &gt; span.fu { color: #06287e; } /* Function */
code &gt; span.er { color: #ff0000; font-weight: bold; } /* Error */
code &gt; span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code &gt; span.cn { color: #880000; } /* Constant */
code &gt; span.sc { color: #4070a0; } /* SpecialChar */
code &gt; span.vs { color: #4070a0; } /* VerbatimString */
code &gt; span.ss { color: #bb6688; } /* SpecialString */
code &gt; span.im { } /* Import */
code &gt; span.va { color: #19177c; } /* Variable */
code &gt; span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code &gt; span.op { color: #666666; } /* Operator */
code &gt; span.bu { } /* BuiltIn */
code &gt; span.ex { } /* Extension */
code &gt; span.pp { color: #bc7a00; } /* Preprocessor */
code &gt; span.at { color: #7d9029; } /* Attribute */
code &gt; span.do { color: #ba2121; font-style: italic; } /* Documentation */
code &gt; span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code &gt; span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code &gt; span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  &lt;/style&gt;
  &lt;!--[if lt IE 9]&gt;
    &lt;script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"&gt;&lt;/script&gt;
  &lt;![endif]--&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;I stumbled upon Max Jaderberg’s &lt;a href="https://arxiv.org/abs/1703.00522"&gt;Synthetic Gradients paper&lt;/a&gt; while thinking about different forms of communication between neural modules. It’s a simple idea: rather than compute gradients through backpropagation, we can train a model to predict what those gradients will be, and use our prediction to update our weights. It’s dynamic programming for neural networks.&lt;/p&gt;
&lt;p&gt;This is the kind of idea I like because, if it works, it expands our modeling capabilities substantially. It would allow us to connect and train various neural modules asynchronously. Whether this turns out to be useful remains to be seen. I wanted to try using this in my own work and didn’t find a Tensorflow implementation to my liking, so here is mine. I also take this opportunity to (attempt to) answer one of the questions I had while reading the paper: why not use synthetic loss instead of synthetic gradients? Supposing we had multiple paths in a DAG architecture—then a synthetic loss (or better, advantage) would give us an interpretable measure of the “quality” of a part of the input, whereas synthetic gradients do not (without additional assumptions).&lt;/p&gt;
&lt;p&gt;Below, we use Tensorflow to implement the fully-connected MNIST experiment, as well as the convolutional CIFAR 10 experiment. The &lt;a href="https://arxiv.org/abs/1703.00522"&gt;Synthetic Gradients paper&lt;/a&gt; itself is a non-technical and easy read, so I’m not going go into any detail about what exactly it is we’re doing. Jaderberg’s &lt;a href="https://deepmind.com/blog/decoupled-neural-networks-using-synthetic-gradients/"&gt;blog post&lt;/a&gt; may be helpful on this front. I also enjoyed Delip Rao’s &lt;a href="http://deliprao.com/archives/187"&gt;blog post&lt;/a&gt; and &lt;a href="http://deliprao.com/archives/191"&gt;follow-up&lt;/a&gt;.&lt;br /&gt;
### Implementation&lt;/p&gt;
&lt;h4 id="imports-and-data"&gt;Imports and data&lt;/h4&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="im"&gt;import&lt;/span&gt; tensorflow &lt;span class="im"&gt;as&lt;/span&gt; tf, numpy &lt;span class="im"&gt;as&lt;/span&gt; np, time
&lt;span class="im"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class="im"&gt;as&lt;/span&gt; plt, seaborn &lt;span class="im"&gt;as&lt;/span&gt; sns
&lt;span class="im"&gt;from&lt;/span&gt; sklearn.utils &lt;span class="im"&gt;import&lt;/span&gt; shuffle
&lt;span class="op"&gt;%&lt;/span&gt;matplotlib inline
sns.&lt;span class="bu"&gt;set&lt;/span&gt;(color_codes&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;(xtr, ytr), (xte, yte) &lt;span class="op"&gt;=&lt;/span&gt; tf.keras.datasets.mnist.load_data(path&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;mnist.npz&amp;#39;&lt;/span&gt;)
xtr &lt;span class="op"&gt;=&lt;/span&gt; xtr.reshape([&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;784&lt;/span&gt;]).astype(np.float32) &lt;span class="op"&gt;/&lt;/span&gt; &lt;span class="fl"&gt;255.&lt;/span&gt;
xte &lt;span class="op"&gt;=&lt;/span&gt; xte.reshape([&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;784&lt;/span&gt;]).astype(np.float32) &lt;span class="op"&gt;/&lt;/span&gt; &lt;span class="fl"&gt;255.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="utility-functions"&gt;Utility functions&lt;/h4&gt;
&lt;p&gt;Note that the layer and model functions below return their variables. This is so we can do selectively compute gradients for different variables as appropriate.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; reset_graph():
    &lt;span class="cf"&gt;if&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;sess&amp;#39;&lt;/span&gt; &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;globals&lt;/span&gt;() &lt;span class="kw"&gt;and&lt;/span&gt; sess:
        sess.close()
    tf.reset_default_graph()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; layer_dense_bn_relu(h, size, training&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;):
  l &lt;span class="op"&gt;=&lt;/span&gt; tf.layers.Dense(size)
  h &lt;span class="op"&gt;=&lt;/span&gt; tf.layers.batch_normalization(l(h), training&lt;span class="op"&gt;=&lt;/span&gt;training)
  
  &lt;span class="cf"&gt;return&lt;/span&gt; tf.nn.relu(h), l.trainable_variables

&lt;span class="kw"&gt;def&lt;/span&gt; model_linear(h, output_dim, output_activation&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;None&lt;/span&gt;, 
                    kernel_initializer&lt;span class="op"&gt;=&lt;/span&gt;tf.zeros_initializer, other_inputs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;None&lt;/span&gt;):
  &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="co"&gt;  h is input that gets mapped to output_dim dims&lt;/span&gt;
&lt;span class="co"&gt;  other_inputs is vector of other inputs&lt;/span&gt;
&lt;span class="co"&gt;  &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
  &lt;span class="cf"&gt;if&lt;/span&gt; other_inputs &lt;span class="kw"&gt;is&lt;/span&gt; &lt;span class="kw"&gt;not&lt;/span&gt; &lt;span class="va"&gt;None&lt;/span&gt;:
    h &lt;span class="op"&gt;=&lt;/span&gt; tf.concat([h, other_inputs], axis&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="bu"&gt;len&lt;/span&gt;(h.get_shape())&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;)

  l &lt;span class="op"&gt;=&lt;/span&gt; tf.layers.Dense(output_dim, activation&lt;span class="op"&gt;=&lt;/span&gt;output_activation, 
                      kernel_initializer&lt;span class="op"&gt;=&lt;/span&gt;kernel_initializer)
    
  &lt;span class="cf"&gt;return&lt;/span&gt; l(h), l.trainable_variables

&lt;span class="kw"&gt;def&lt;/span&gt; model_two_layer(h, output_dim, output_activation&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;None&lt;/span&gt;, 
                    kernel_initializer&lt;span class="op"&gt;=&lt;/span&gt;tf.zeros_initializer, other_inputs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;None&lt;/span&gt;):
  &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="co"&gt;  h is input that gets mapped to output_dim dims&lt;/span&gt;
&lt;span class="co"&gt;  other_inputs is vector of other inputs&lt;/span&gt;
&lt;span class="co"&gt;  &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
  &lt;span class="cf"&gt;if&lt;/span&gt; other_inputs &lt;span class="kw"&gt;is&lt;/span&gt; &lt;span class="kw"&gt;not&lt;/span&gt; &lt;span class="va"&gt;None&lt;/span&gt;:
    h &lt;span class="op"&gt;=&lt;/span&gt; tf.concat([h, other_inputs], axis&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="bu"&gt;len&lt;/span&gt;(h.get_shape())&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;)
  
  h, v1 &lt;span class="op"&gt;=&lt;/span&gt; layer_dense_bn_relu(h, &lt;span class="dv"&gt;1024&lt;/span&gt;)
  h, v2 &lt;span class="op"&gt;=&lt;/span&gt; layer_dense_bn_relu(h, &lt;span class="dv"&gt;1024&lt;/span&gt;)
  
  l &lt;span class="op"&gt;=&lt;/span&gt; tf.layers.Dense(output_dim, activation&lt;span class="op"&gt;=&lt;/span&gt;output_activation, 
                      kernel_initializer&lt;span class="op"&gt;=&lt;/span&gt;kernel_initializer)
  
  &lt;span class="cf"&gt;return&lt;/span&gt; l(h), v1 &lt;span class="op"&gt;+&lt;/span&gt; v2 &lt;span class="op"&gt;+&lt;/span&gt; l.trainable_variables&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="synthetic-grad-loss-wrappers-and-more-utilities"&gt;Synthetic grad / loss wrappers and more utilities&lt;/h4&gt;
&lt;p&gt;Synthetic loss is just like synthetic gradients except we are predicting a scalar loss and then computing the gradients with respect to that loss. I thought this work similarly to the synthetic gradients, but it doesn’t seem to work at all (discussed below).&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; sg_wrapper(x, h, hvs, model, other_inputs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;None&lt;/span&gt;): 
  &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="co"&gt;  Predicts grads for x, h, and hvs (vars between x and h) using model.&lt;/span&gt;
&lt;span class="co"&gt;  Returns:&lt;/span&gt;
&lt;span class="co"&gt;  - synth grad for x&lt;/span&gt;
&lt;span class="co"&gt;  - synth grad for h&lt;/span&gt;
&lt;span class="co"&gt;  - synth grads &amp;amp; vars for hvs&lt;/span&gt;
&lt;span class="co"&gt;  - sg model variables (so they can be trained)&lt;/span&gt;
&lt;span class="co"&gt;  &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
  sg, sg_vars &lt;span class="op"&gt;=&lt;/span&gt; model(h, h.get_shape()[&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;], other_inputs&lt;span class="op"&gt;=&lt;/span&gt;other_inputs)
  
  xs &lt;span class="op"&gt;=&lt;/span&gt; hvs &lt;span class="op"&gt;+&lt;/span&gt; [x]
  gvs &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;list&lt;/span&gt;(&lt;span class="bu"&gt;zip&lt;/span&gt;(tf.gradients(h, xs, grad_ys&lt;span class="op"&gt;=&lt;/span&gt;sg), xs))
  
  &lt;span class="cf"&gt;return&lt;/span&gt; gvs[&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;][&lt;span class="dv"&gt;0&lt;/span&gt;], sg, gvs[:&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;], sg_vars

&lt;span class="kw"&gt;def&lt;/span&gt; sl_wrapper(h, hvs, model, other_inputs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;None&lt;/span&gt;): 
  &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="co"&gt;  Predicts loss given h, and produces grads_and_vars for hvs, using model.&lt;/span&gt;
&lt;span class="co"&gt;  Returns:&lt;/span&gt;
&lt;span class="co"&gt;  - synth loss for h&lt;/span&gt;
&lt;span class="co"&gt;  - synth grads &amp;amp; vars for hvs&lt;/span&gt;
&lt;span class="co"&gt;  - model variables (so they can be trained)&lt;/span&gt;
&lt;span class="co"&gt;  &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
  sl, sl_vars &lt;span class="op"&gt;=&lt;/span&gt; model(h, &lt;span class="dv"&gt;1&lt;/span&gt;, tf.square, &lt;span class="va"&gt;None&lt;/span&gt;, other_inputs)
  
  gvs &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;list&lt;/span&gt;(&lt;span class="bu"&gt;zip&lt;/span&gt;(tf.gradients(sl, hvs), hvs))
  
  &lt;span class="cf"&gt;return&lt;/span&gt; sl, gvs, sl_vars

&lt;span class="kw"&gt;def&lt;/span&gt; loss_grads_with_target(loss, vs, target):
  &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="co"&gt;  Returns grad and vars for vs and target with respect to loss. &lt;/span&gt;
&lt;span class="co"&gt;  &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
  xs &lt;span class="op"&gt;=&lt;/span&gt; vs &lt;span class="op"&gt;+&lt;/span&gt; [target]
  gvs &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;list&lt;/span&gt;(&lt;span class="bu"&gt;zip&lt;/span&gt;(tf.gradients(loss, xs), xs))
  &lt;span class="cf"&gt;return&lt;/span&gt; gvs[&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;][&lt;span class="dv"&gt;0&lt;/span&gt;], gvs[:&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;]

&lt;span class="kw"&gt;def&lt;/span&gt; model_grads(output_target_vars_tuple):
  &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="co"&gt;  Returns grads and vars for models given an iterable of tuples of&lt;/span&gt;
&lt;span class="co"&gt;    (model output, model target, model variables).&lt;/span&gt;
&lt;span class="co"&gt;  &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
  gvs &lt;span class="op"&gt;=&lt;/span&gt; []
  &lt;span class="cf"&gt;for&lt;/span&gt; prediction, target, vs &lt;span class="kw"&gt;in&lt;/span&gt; output_target_vars_tuple:
    loss &lt;span class="op"&gt;=&lt;/span&gt; tf.losses.mean_squared_error(prediction, target)
    gvs &lt;span class="op"&gt;+=&lt;/span&gt; &lt;span class="bu"&gt;list&lt;/span&gt;(&lt;span class="bu"&gt;zip&lt;/span&gt;(tf.gradients(loss, vs), vs))
  
  &lt;span class="cf"&gt;return&lt;/span&gt; gvs&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="mnist-experiment"&gt;MNIST Experiment&lt;/h4&gt;
&lt;p&gt;Note: the paper claims that the learning rate was not optimized, but I found that the results are quite sensitive to changes in the learning rate.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; build_graph_mnist_fcn(sg&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;, sl&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;, conditioned&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;, no_bprop&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;):
  reset_graph()
  g &lt;span class="op"&gt;=&lt;/span&gt; {}
  
  g[&lt;span class="st"&gt;&amp;#39;training&amp;#39;&lt;/span&gt;] &lt;span class="op"&gt;=&lt;/span&gt; training &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder_with_default(&lt;span class="va"&gt;True&lt;/span&gt;, [])
   
  g[&lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;] &lt;span class="op"&gt;=&lt;/span&gt; x &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(tf.float32, [&lt;span class="va"&gt;None&lt;/span&gt;, &lt;span class="dv"&gt;784&lt;/span&gt;], name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;x_placeholder&amp;#39;&lt;/span&gt;)
  g[&lt;span class="st"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;] &lt;span class="op"&gt;=&lt;/span&gt; y &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(tf.int64, [&lt;span class="va"&gt;None&lt;/span&gt;], name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;y_placeholder&amp;#39;&lt;/span&gt;)
  other_inputs &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="va"&gt;None&lt;/span&gt;
  &lt;span class="cf"&gt;if&lt;/span&gt; conditioned:
    other_inputs &lt;span class="op"&gt;=&lt;/span&gt; tf.one_hot(y, &lt;span class="dv"&gt;10&lt;/span&gt;)
  
  h1, h1vs &lt;span class="op"&gt;=&lt;/span&gt; layer_dense_bn_relu(x, &lt;span class="dv"&gt;256&lt;/span&gt;, training)
  &lt;span class="cf"&gt;if&lt;/span&gt; sg:
    _, sg1, gvs1, svars1 &lt;span class="op"&gt;=&lt;/span&gt; sg_wrapper(x, h1, h1vs, model_two_layer, other_inputs)
  &lt;span class="cf"&gt;elif&lt;/span&gt; sl:
    sl1, gvs1, svars1 &lt;span class="op"&gt;=&lt;/span&gt; sl_wrapper(h1, h1vs, model_two_layer, other_inputs)
  
  h2, h2vs &lt;span class="op"&gt;=&lt;/span&gt; layer_dense_bn_relu(h1, &lt;span class="dv"&gt;256&lt;/span&gt;, training)
  &lt;span class="cf"&gt;if&lt;/span&gt; sg:
    sg1_target, sg2, gvs2, svars2 &lt;span class="op"&gt;=&lt;/span&gt; sg_wrapper(h1, h2, h2vs, model_two_layer, other_inputs)
  &lt;span class="cf"&gt;elif&lt;/span&gt; sl:
    sl2, gvs2, svars2 &lt;span class="op"&gt;=&lt;/span&gt; sl_wrapper(h2, h2vs, model_two_layer, other_inputs)
  
  logit_layer &lt;span class="op"&gt;=&lt;/span&gt; tf.layers.Dense(&lt;span class="dv"&gt;10&lt;/span&gt;)
  logits &lt;span class="op"&gt;=&lt;/span&gt; logit_layer(h2)
  logit_vs &lt;span class="op"&gt;=&lt;/span&gt; logit_layer.trainable_variables
  
  g[&lt;span class="st"&gt;&amp;#39;loss&amp;#39;&lt;/span&gt;] &lt;span class="op"&gt;=&lt;/span&gt; loss &lt;span class="op"&gt;=\&lt;/span&gt;
    tf.nn.sparse_softmax_cross_entropy_with_logits(logits&lt;span class="op"&gt;=&lt;/span&gt;logits, labels&lt;span class="op"&gt;=&lt;/span&gt;y)
  
  &lt;span class="cf"&gt;if&lt;/span&gt; sg:
    sg2_target, gvs3 &lt;span class="op"&gt;=&lt;/span&gt; loss_grads_with_target(loss, logit_vs, h2)
    gvs_sg &lt;span class="op"&gt;=&lt;/span&gt; model_grads([(sg1, sg1_target, svars1), 
                          (sg2, sg2_target, svars2)])
  &lt;span class="cf"&gt;elif&lt;/span&gt; sl:
    gvs3 &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;list&lt;/span&gt;(&lt;span class="bu"&gt;zip&lt;/span&gt;(tf.gradients(loss, logit_vs), logit_vs))
    gvs_sl &lt;span class="op"&gt;=&lt;/span&gt; model_grads([(sl1, sl2, svars1),
                          (sl2, tf.expand_dims(loss, &lt;span class="dv"&gt;1&lt;/span&gt;), svars2)])
  &lt;span class="cf"&gt;elif&lt;/span&gt; no_bprop:
    gvs3 &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;list&lt;/span&gt;(&lt;span class="bu"&gt;zip&lt;/span&gt;(tf.gradients(loss, logit_vs), logit_vs))
    
  &lt;span class="cf"&gt;with&lt;/span&gt; tf.control_dependencies(tf.get_collection(tf.GraphKeys.UPDATE_OPS)):
    opt &lt;span class="op"&gt;=&lt;/span&gt; tf.train.AdamOptimizer(&lt;span class="fl"&gt;3e-5&lt;/span&gt;)
    &lt;span class="cf"&gt;if&lt;/span&gt; sg:
      g[&lt;span class="st"&gt;&amp;#39;ts&amp;#39;&lt;/span&gt;] &lt;span class="op"&gt;=\&lt;/span&gt;
        opt.apply_gradients(gvs1 &lt;span class="op"&gt;+&lt;/span&gt; gvs2 &lt;span class="op"&gt;+&lt;/span&gt; gvs3 &lt;span class="op"&gt;+&lt;/span&gt; gvs_sg)
    &lt;span class="cf"&gt;elif&lt;/span&gt; sl:
      g[&lt;span class="st"&gt;&amp;#39;ts&amp;#39;&lt;/span&gt;] &lt;span class="op"&gt;=\&lt;/span&gt;
        opt.apply_gradients(gvs1 &lt;span class="op"&gt;+&lt;/span&gt; gvs2 &lt;span class="op"&gt;+&lt;/span&gt; gvs3 &lt;span class="op"&gt;+&lt;/span&gt; gvs_sl)
    &lt;span class="cf"&gt;elif&lt;/span&gt; no_bprop:
      g[&lt;span class="st"&gt;&amp;#39;ts&amp;#39;&lt;/span&gt;] &lt;span class="op"&gt;=\&lt;/span&gt;
        opt.apply_gradients(gvs3)
    &lt;span class="cf"&gt;else&lt;/span&gt;:
      g[&lt;span class="st"&gt;&amp;#39;ts&amp;#39;&lt;/span&gt;] &lt;span class="op"&gt;=\&lt;/span&gt;
        opt.minimize(loss)
    
  g[&lt;span class="st"&gt;&amp;#39;accuracy&amp;#39;&lt;/span&gt;] &lt;span class="op"&gt;=&lt;/span&gt; tf.reduce_mean(tf.cast(tf.equal(tf.argmax(logits, &lt;span class="dv"&gt;1&lt;/span&gt;), y), tf.float32))
  g[&lt;span class="st"&gt;&amp;#39;init&amp;#39;&lt;/span&gt;] &lt;span class="op"&gt;=&lt;/span&gt; tf.global_variables_initializer()
  
  &lt;span class="cf"&gt;return&lt;/span&gt; g&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; train(graph, iters &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;25000&lt;/span&gt;, batch_size &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;256&lt;/span&gt;):
  g &lt;span class="op"&gt;=&lt;/span&gt; graph
  res_tr &lt;span class="op"&gt;=&lt;/span&gt; []
  res_te &lt;span class="op"&gt;=&lt;/span&gt; []
  batches_per_epoch &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;len&lt;/span&gt;(xtr)&lt;span class="op"&gt;//&lt;/span&gt;batch_size
  num_epochs &lt;span class="op"&gt;=&lt;/span&gt; iters &lt;span class="op"&gt;//&lt;/span&gt; batches_per_epoch
  &lt;span class="cf"&gt;with&lt;/span&gt; tf.Session() &lt;span class="im"&gt;as&lt;/span&gt; sess:
    sess.run(g[&lt;span class="st"&gt;&amp;#39;init&amp;#39;&lt;/span&gt;])
    &lt;span class="cf"&gt;for&lt;/span&gt; epoch &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(num_epochs):
      x, y &lt;span class="op"&gt;=&lt;/span&gt; shuffle(xtr, ytr)
      acc &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;
      &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(batches_per_epoch): 
        feed_dict &lt;span class="op"&gt;=&lt;/span&gt; {g[&lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;]: x[i&lt;span class="op"&gt;*&lt;/span&gt;batch_size:(i&lt;span class="op"&gt;+&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;)&lt;span class="op"&gt;*&lt;/span&gt;batch_size],
                     g[&lt;span class="st"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;]: y[i&lt;span class="op"&gt;*&lt;/span&gt;batch_size:(i&lt;span class="op"&gt;+&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;)&lt;span class="op"&gt;*&lt;/span&gt;batch_size]}
        acc_, _ &lt;span class="op"&gt;=&lt;/span&gt; sess.run([g[&lt;span class="st"&gt;&amp;#39;accuracy&amp;#39;&lt;/span&gt;], g[&lt;span class="st"&gt;&amp;#39;ts&amp;#39;&lt;/span&gt;]], feed_dict)
        acc &lt;span class="op"&gt;+=&lt;/span&gt; acc_
        &lt;span class="cf"&gt;if&lt;/span&gt; (i&lt;span class="op"&gt;+&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;) &lt;span class="op"&gt;%&lt;/span&gt; batches_per_epoch &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;:
          res_tr.append(acc &lt;span class="op"&gt;/&lt;/span&gt; batches_per_epoch)
          
          acc_te &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;
          &lt;span class="cf"&gt;for&lt;/span&gt; j &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;10&lt;/span&gt;):
            feed_dict &lt;span class="op"&gt;=&lt;/span&gt; {g[&lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;]: xte[j&lt;span class="op"&gt;*&lt;/span&gt;&lt;span class="dv"&gt;1000&lt;/span&gt;:(j&lt;span class="op"&gt;+&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;)&lt;span class="op"&gt;*&lt;/span&gt;&lt;span class="dv"&gt;1000&lt;/span&gt;],
                         g[&lt;span class="st"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;]: yte[j&lt;span class="op"&gt;*&lt;/span&gt;&lt;span class="dv"&gt;1000&lt;/span&gt;:(j&lt;span class="op"&gt;+&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;)&lt;span class="op"&gt;*&lt;/span&gt;&lt;span class="dv"&gt;1000&lt;/span&gt;],
                         g[&lt;span class="st"&gt;&amp;#39;training&amp;#39;&lt;/span&gt;]: &lt;span class="va"&gt;False&lt;/span&gt;}
            acc_te &lt;span class="op"&gt;+=&lt;/span&gt; sess.run(g[&lt;span class="st"&gt;&amp;#39;accuracy&amp;#39;&lt;/span&gt;], feed_dict)
          acc_te &lt;span class="op"&gt;/=&lt;/span&gt; &lt;span class="fl"&gt;10.&lt;/span&gt;
          
          res_te.append(acc_te)

          &lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;&lt;span class="ch"&gt;\r&lt;/span&gt;&lt;span class="st"&gt;Epoch &lt;/span&gt;&lt;span class="sc"&gt;{}&lt;/span&gt;&lt;span class="st"&gt;/&lt;/span&gt;&lt;span class="sc"&gt;{}&lt;/span&gt;&lt;span class="st"&gt;: &lt;/span&gt;&lt;span class="sc"&gt;{:4f}&lt;/span&gt;&lt;span class="st"&gt; (TR) &lt;/span&gt;&lt;span class="sc"&gt;{:4f}&lt;/span&gt;&lt;span class="st"&gt; (TE)&amp;quot;&lt;/span&gt;\
                .&lt;span class="bu"&gt;format&lt;/span&gt;(epoch, num_epochs, acc&lt;span class="op"&gt;/&lt;/span&gt;batches_per_epoch, acc_te), end&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;)
          acc &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;

  &lt;span class="cf"&gt;return&lt;/span&gt; res_tr, res_te&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="results"&gt;Results&lt;/h4&gt;
&lt;p&gt;Below we are running only 25k iterations, which is enough to get the point (the 500k from the paper is quite excessive!).&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;t &lt;span class="op"&gt;=&lt;/span&gt; time.time()
g &lt;span class="op"&gt;=&lt;/span&gt; build_graph_mnist_fcn() &lt;span class="co"&gt;# baseline&lt;/span&gt;
_, res_baseline &lt;span class="op"&gt;=&lt;/span&gt; train(g)
&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;&lt;span class="ch"&gt;\n&lt;/span&gt;&lt;span class="st"&gt;Took &lt;/span&gt;&lt;span class="sc"&gt;{}&lt;/span&gt;&lt;span class="st"&gt; seconds!&amp;quot;&lt;/span&gt;.&lt;span class="bu"&gt;format&lt;/span&gt;(time.time() &lt;span class="op"&gt;-&lt;/span&gt; t))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Epoch 105/106: 1.000000 (TR) 0.980100 (TE)
Took 54.59836196899414 seconds!&lt;/code&gt;&lt;/pre&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;t &lt;span class="op"&gt;=&lt;/span&gt; time.time()
g &lt;span class="op"&gt;=&lt;/span&gt; build_graph_mnist_fcn(no_bprop&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)
_, res_no_bprop &lt;span class="op"&gt;=&lt;/span&gt; train(g)
&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;&lt;span class="ch"&gt;\n&lt;/span&gt;&lt;span class="st"&gt;Took &lt;/span&gt;&lt;span class="sc"&gt;{}&lt;/span&gt;&lt;span class="st"&gt; seconds!&amp;quot;&lt;/span&gt;.&lt;span class="bu"&gt;format&lt;/span&gt;(time.time() &lt;span class="op"&gt;-&lt;/span&gt; t))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Epoch 105/106: 0.881460 (TR) 0.889000 (TE)
Took 33.66543793678284 seconds!&lt;/code&gt;&lt;/pre&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;t &lt;span class="op"&gt;=&lt;/span&gt; time.time()
g &lt;span class="op"&gt;=&lt;/span&gt; build_graph_mnist_fcn(sl&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)
_, res_sl &lt;span class="op"&gt;=&lt;/span&gt; train(g)
&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;&lt;span class="ch"&gt;\n&lt;/span&gt;&lt;span class="st"&gt;Took &lt;/span&gt;&lt;span class="sc"&gt;{}&lt;/span&gt;&lt;span class="st"&gt; seconds!&amp;quot;&lt;/span&gt;.&lt;span class="bu"&gt;format&lt;/span&gt;(time.time() &lt;span class="op"&gt;-&lt;/span&gt; t))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Epoch 105/106: 0.832816 (TR) 0.842900 (TE)
Took 137.18904900550842 seconds!&lt;/code&gt;&lt;/pre&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;t &lt;span class="op"&gt;=&lt;/span&gt; time.time()
g &lt;span class="op"&gt;=&lt;/span&gt; build_graph_mnist_fcn(sg&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)
_, res_sg &lt;span class="op"&gt;=&lt;/span&gt; train(g)
&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;&lt;span class="ch"&gt;\n&lt;/span&gt;&lt;span class="st"&gt;Took &lt;/span&gt;&lt;span class="sc"&gt;{}&lt;/span&gt;&lt;span class="st"&gt; seconds!&amp;quot;&lt;/span&gt;.&lt;span class="bu"&gt;format&lt;/span&gt;(time.time() &lt;span class="op"&gt;-&lt;/span&gt; t))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Epoch 105/106: 0.997162 (TR) 0.977700 (TE)
Took 115.9250328540802 seconds!&lt;/code&gt;&lt;/pre&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;t &lt;span class="op"&gt;=&lt;/span&gt; time.time()
g &lt;span class="op"&gt;=&lt;/span&gt; build_graph_mnist_fcn(sg&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;, conditioned&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)
_, res_sgc &lt;span class="op"&gt;=&lt;/span&gt; train(g)
&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;&lt;span class="ch"&gt;\n&lt;/span&gt;&lt;span class="st"&gt;Took &lt;/span&gt;&lt;span class="sc"&gt;{}&lt;/span&gt;&lt;span class="st"&gt; seconds!&amp;quot;&lt;/span&gt;.&lt;span class="bu"&gt;format&lt;/span&gt;(time.time() &lt;span class="op"&gt;-&lt;/span&gt; t))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Epoch 105/106: 0.999983 (TR) 0.980100 (TE)
Took 117.7770209312439 seconds!&lt;/code&gt;&lt;/pre&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;plt.figure(figsize&lt;span class="op"&gt;=&lt;/span&gt;(&lt;span class="dv"&gt;10&lt;/span&gt;,&lt;span class="dv"&gt;6&lt;/span&gt;))
plt.plot(res_baseline, label&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;backprop&amp;quot;&lt;/span&gt;)
plt.plot(res_no_bprop, label&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;no bprop&amp;quot;&lt;/span&gt;)
plt.plot(res_sg, label&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;sg&amp;quot;&lt;/span&gt;)
plt.plot(res_sgc, label&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;sg + c&amp;quot;&lt;/span&gt;)
plt.plot(res_sl, label&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;sl&amp;quot;&lt;/span&gt;)
plt.title(&lt;span class="st"&gt;&amp;quot;Synthetic Gradients on MNIST&amp;quot;&lt;/span&gt;)
plt.xlabel(&lt;span class="st"&gt;&amp;quot;Epoch&amp;quot;&lt;/span&gt;)
plt.ylabel(&lt;span class="st"&gt;&amp;quot;Accuracy&amp;quot;&lt;/span&gt;)
plt.ylim([&lt;span class="fl"&gt;0.5&lt;/span&gt;,&lt;span class="fl"&gt;1.&lt;/span&gt;])
plt.legend()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/synthetic_gradients/output_19_1.png" alt="MNIST FCN Results" /&gt;&lt;figcaption&gt;MNIST FCN Results&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;The results for synthetic gradients are similar to those in the paper over the first 100 epochs (25k mini-batches).&lt;/p&gt;
&lt;p&gt;We see that synthetic loss failed—doing worse than even the “no backpropagation” baseline (it is also the slowest approach!). This could be the result of a number of things (e.g., the loss distribution is bi-modal and hard to model, or perhaps I made a mistake in my implementation, as I did not debug extensively); I think, however, that there is something fundamentally wrong with doing gradient descent with respect to an approximated loss function. Though we might get a reasonable estimate of the loss, there is no guarantee that the gradient of our model will match the gradient of the actual loss. Imagine, for example, approximating a line with a zig-zag: one could get arbitrary good approximations but the gradient would always be wrong).&lt;/p&gt;
&lt;h2 id="cifar-10-cnn-experiment"&gt;CIFAR 10 CNN Experiment&lt;/h2&gt;
&lt;p&gt;This is just to show how the implementation works with a CNN architecture. Once again, results match the paper.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;(xtr, ytr), (xte, yte) &lt;span class="op"&gt;=&lt;/span&gt; tf.keras.datasets.cifar10.load_data()
xtr &lt;span class="op"&gt;=&lt;/span&gt; xtr.astype(np.float32) &lt;span class="op"&gt;/&lt;/span&gt; &lt;span class="fl"&gt;255.&lt;/span&gt;
ytr &lt;span class="op"&gt;=&lt;/span&gt; ytr.reshape([&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;])
xte &lt;span class="op"&gt;=&lt;/span&gt; xte.astype(np.float32) &lt;span class="op"&gt;/&lt;/span&gt; &lt;span class="fl"&gt;255.&lt;/span&gt;
yte &lt;span class="op"&gt;=&lt;/span&gt; yte.reshape([&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; layer_conv_bn_relu(h, num_filters, filter_dim, padding&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;same&amp;quot;&lt;/span&gt;, pooling&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;None&lt;/span&gt;, training&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;):
  l &lt;span class="op"&gt;=&lt;/span&gt; tf.layers.Conv2D(num_filters, filter_dim, padding&lt;span class="op"&gt;=&lt;/span&gt;padding)
  h &lt;span class="op"&gt;=&lt;/span&gt; tf.layers.batch_normalization(l(h), training&lt;span class="op"&gt;=&lt;/span&gt;training)
  h &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.relu(h)
  
  &lt;span class="cf"&gt;if&lt;/span&gt; pooling &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;max&amp;quot;&lt;/span&gt;:
    h &lt;span class="op"&gt;=&lt;/span&gt; tf.layers.max_pooling2d(h, &lt;span class="dv"&gt;3&lt;/span&gt;, &lt;span class="dv"&gt;3&lt;/span&gt;)
  &lt;span class="cf"&gt;elif&lt;/span&gt; pooling &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;avg&amp;quot;&lt;/span&gt;:
    h &lt;span class="op"&gt;=&lt;/span&gt; tf.layers.average_pooling2d(h, &lt;span class="dv"&gt;3&lt;/span&gt;, &lt;span class="dv"&gt;3&lt;/span&gt;)
    
  &lt;span class="cf"&gt;return&lt;/span&gt; h, l.trainable_variables

&lt;span class="kw"&gt;def&lt;/span&gt; model_two_layer_conv(h, output_dim, other_inputs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;None&lt;/span&gt;):
  &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="co"&gt;  h is what we are computing the synth grads for, channels last data format&lt;/span&gt;
&lt;span class="co"&gt;  other_inputs is vector of other inputs, assumed to have same non-channel dims&lt;/span&gt;
&lt;span class="co"&gt;  &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
  &lt;span class="cf"&gt;if&lt;/span&gt; other_inputs &lt;span class="kw"&gt;is&lt;/span&gt; &lt;span class="kw"&gt;not&lt;/span&gt; &lt;span class="va"&gt;None&lt;/span&gt;:
    h &lt;span class="op"&gt;=&lt;/span&gt; tf.concat([h, other_inputs], axis&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="bu"&gt;len&lt;/span&gt;(h.get_shape())&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;)
  
  h, v1 &lt;span class="op"&gt;=&lt;/span&gt; layer_conv_bn_relu(h, &lt;span class="dv"&gt;128&lt;/span&gt;, &lt;span class="dv"&gt;5&lt;/span&gt;, padding&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;same&amp;quot;&lt;/span&gt;)
  h, v2 &lt;span class="op"&gt;=&lt;/span&gt; layer_conv_bn_relu(h, &lt;span class="dv"&gt;128&lt;/span&gt;, &lt;span class="dv"&gt;5&lt;/span&gt;, padding&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;same&amp;quot;&lt;/span&gt;)
  
  l &lt;span class="op"&gt;=&lt;/span&gt; tf.layers.Conv2D(output_dim, &lt;span class="dv"&gt;5&lt;/span&gt;, padding&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;same&amp;quot;&lt;/span&gt;, kernel_initializer&lt;span class="op"&gt;=&lt;/span&gt;tf.zeros_initializer)
    
  &lt;span class="cf"&gt;return&lt;/span&gt; l(h), v1 &lt;span class="op"&gt;+&lt;/span&gt; v2 &lt;span class="op"&gt;+&lt;/span&gt; l.trainable_variables&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; build_graph_cifar_cnn(sg&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;):
  reset_graph()
  g &lt;span class="op"&gt;=&lt;/span&gt; {}
  
  g[&lt;span class="st"&gt;&amp;#39;training&amp;#39;&lt;/span&gt;] &lt;span class="op"&gt;=&lt;/span&gt; training &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder_with_default(&lt;span class="va"&gt;True&lt;/span&gt;, [])
   
  g[&lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;] &lt;span class="op"&gt;=&lt;/span&gt; x &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(tf.float32, [&lt;span class="va"&gt;None&lt;/span&gt;, &lt;span class="dv"&gt;32&lt;/span&gt;, &lt;span class="dv"&gt;32&lt;/span&gt;, &lt;span class="dv"&gt;3&lt;/span&gt;], name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;x_placeholder&amp;#39;&lt;/span&gt;)
  g[&lt;span class="st"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;] &lt;span class="op"&gt;=&lt;/span&gt; y &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(tf.int64, [&lt;span class="va"&gt;None&lt;/span&gt;], name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;y_placeholder&amp;#39;&lt;/span&gt;)

  h1, h1vs &lt;span class="op"&gt;=&lt;/span&gt; layer_conv_bn_relu(x, &lt;span class="dv"&gt;128&lt;/span&gt;, &lt;span class="dv"&gt;5&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;same&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;max&amp;#39;&lt;/span&gt;, training&lt;span class="op"&gt;=&lt;/span&gt;training)
  &lt;span class="cf"&gt;if&lt;/span&gt; sg:
    _, sg1, gvs1, svars1 &lt;span class="op"&gt;=&lt;/span&gt; sg_wrapper(x, h1, h1vs, model_two_layer_conv)
  
  h2, h2vs &lt;span class="op"&gt;=&lt;/span&gt; layer_conv_bn_relu(h1, &lt;span class="dv"&gt;128&lt;/span&gt;, &lt;span class="dv"&gt;5&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;same&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;avg&amp;#39;&lt;/span&gt;, training&lt;span class="op"&gt;=&lt;/span&gt;training)
  &lt;span class="cf"&gt;if&lt;/span&gt; sg:
    sg1_target, sg2, gvs2, svars2 &lt;span class="op"&gt;=&lt;/span&gt; sg_wrapper(h1, h2, h2vs, model_two_layer_conv)
  
  h &lt;span class="op"&gt;=&lt;/span&gt; tf.reshape(h2, [&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="dv"&gt;9&lt;/span&gt;&lt;span class="op"&gt;*&lt;/span&gt;&lt;span class="dv"&gt;128&lt;/span&gt;])
  
  logit_layer &lt;span class="op"&gt;=&lt;/span&gt; tf.layers.Dense(&lt;span class="dv"&gt;10&lt;/span&gt;)
  logits &lt;span class="op"&gt;=&lt;/span&gt; logit_layer(h)
  logit_vs &lt;span class="op"&gt;=&lt;/span&gt; logit_layer.trainable_variables
  
  g[&lt;span class="st"&gt;&amp;#39;loss&amp;#39;&lt;/span&gt;] &lt;span class="op"&gt;=&lt;/span&gt; loss &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.sparse_softmax_cross_entropy_with_logits(logits&lt;span class="op"&gt;=&lt;/span&gt;logits, labels&lt;span class="op"&gt;=&lt;/span&gt;y)
  
  &lt;span class="cf"&gt;if&lt;/span&gt; sg:
    sg2_target, gvs3 &lt;span class="op"&gt;=&lt;/span&gt; loss_grads_with_target(loss, logit_vs, h2)
    gvs_sg &lt;span class="op"&gt;=&lt;/span&gt; model_grads([(sg1, sg1_target, svars1), 
                          (sg2, sg2_target, svars2)])
  
  &lt;span class="cf"&gt;with&lt;/span&gt; tf.control_dependencies(tf.get_collection(tf.GraphKeys.UPDATE_OPS)):
    opt &lt;span class="op"&gt;=&lt;/span&gt; tf.train.AdamOptimizer(&lt;span class="fl"&gt;3e-5&lt;/span&gt;)
    &lt;span class="cf"&gt;if&lt;/span&gt; sg:
      g[&lt;span class="st"&gt;&amp;#39;ts&amp;#39;&lt;/span&gt;] &lt;span class="op"&gt;=\&lt;/span&gt;
        opt.apply_gradients(gvs1 &lt;span class="op"&gt;+&lt;/span&gt; gvs2 &lt;span class="op"&gt;+&lt;/span&gt; gvs3 &lt;span class="op"&gt;+&lt;/span&gt; gvs_sg)
    &lt;span class="cf"&gt;else&lt;/span&gt;:
      g[&lt;span class="st"&gt;&amp;#39;ts&amp;#39;&lt;/span&gt;] &lt;span class="op"&gt;=\&lt;/span&gt;
        opt.minimize(loss)
    
  g[&lt;span class="st"&gt;&amp;#39;accuracy&amp;#39;&lt;/span&gt;] &lt;span class="op"&gt;=&lt;/span&gt; tf.reduce_mean(tf.cast(tf.equal(tf.argmax(logits, &lt;span class="dv"&gt;1&lt;/span&gt;), y), tf.float32))
  g[&lt;span class="st"&gt;&amp;#39;init&amp;#39;&lt;/span&gt;] &lt;span class="op"&gt;=&lt;/span&gt; tf.global_variables_initializer()
  
  &lt;span class="cf"&gt;return&lt;/span&gt; g&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;t &lt;span class="op"&gt;=&lt;/span&gt; time.time()
g &lt;span class="op"&gt;=&lt;/span&gt; build_graph_cifar_cnn(sg&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)
res_tr, res_sg &lt;span class="op"&gt;=&lt;/span&gt; train(g, iters&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;25000&lt;/span&gt;)
&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;&lt;span class="ch"&gt;\n&lt;/span&gt;&lt;span class="st"&gt;Took &lt;/span&gt;&lt;span class="sc"&gt;{}&lt;/span&gt;&lt;span class="st"&gt; seconds&amp;quot;&lt;/span&gt;.&lt;span class="bu"&gt;format&lt;/span&gt;(time.time() &lt;span class="op"&gt;-&lt;/span&gt; t))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Epoch 127/128: 0.774700 (TR) 0.648300 (TE)
Took 943.7978417873383 seconds&lt;/code&gt;&lt;/pre&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;t &lt;span class="op"&gt;=&lt;/span&gt; time.time()
g &lt;span class="op"&gt;=&lt;/span&gt; build_graph_cifar_cnn() &lt;span class="co"&gt;#baseline&lt;/span&gt;
res_tr_backprop, res_backprop &lt;span class="op"&gt;=&lt;/span&gt; train(g, iters&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;25000&lt;/span&gt;)
&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;&lt;span class="ch"&gt;\n&lt;/span&gt;&lt;span class="st"&gt;Took &lt;/span&gt;&lt;span class="sc"&gt;{}&lt;/span&gt;&lt;span class="st"&gt; seconds&amp;quot;&lt;/span&gt;.&lt;span class="bu"&gt;format&lt;/span&gt;(time.time() &lt;span class="op"&gt;-&lt;/span&gt; t))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Epoch 127/128: 0.901683 (TR) 0.752400 (TE)
Took 584.2685778141022 seconds&lt;/code&gt;&lt;/pre&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;plt.figure(figsize&lt;span class="op"&gt;=&lt;/span&gt;(&lt;span class="dv"&gt;10&lt;/span&gt;,&lt;span class="dv"&gt;6&lt;/span&gt;))
plt.plot(res_backprop, label&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;backprop&amp;quot;&lt;/span&gt;)
plt.plot(res_sg, label&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;sg&amp;quot;&lt;/span&gt;)
plt.title(&lt;span class="st"&gt;&amp;quot;Synthetic Gradients on CIFAR (CNN)&amp;quot;&lt;/span&gt;)
plt.xlabel(&lt;span class="st"&gt;&amp;quot;Epoch&amp;quot;&lt;/span&gt;)
plt.ylabel(&lt;span class="st"&gt;&amp;quot;Accuracy&amp;quot;&lt;/span&gt;)
plt.legend()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/synthetic_gradients/output_27_1.png" alt="CIFAR 10 CNN Results" /&gt;&lt;figcaption&gt;CIFAR 10 CNN Results&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/body&gt;
&lt;/html&gt;
</content></entry><entry><title>Deconstruction with Discrete Embeddings</title><link href="https://r2rt.com/deconstruction-with-discrete-embeddings.html" rel="alternate"></link><published>2017-02-15T00:00:00-05:00</published><updated>2017-02-15T00:00:00-05:00</updated><author><name>Silviu Pitis</name></author><id>tag:r2rt.com,2017-02-15:/deconstruction-with-discrete-embeddings.html</id><summary type="html">In my post Beyond Binary, I showed how easy it is to create trainable "one-hot" neurons with the straight-through estimator. My motivation for this is made clear in this post, in which I demonstrate the potential of discrete embeddings. In short, discrete embeddings allow for explicit deconstruction of inherently fuzzy data, which allows us to apply explicit reasoning and algorithms over the data, and communicate fuzzy ideas with concrete symbols. Using discrete embeddings, we can (1) create a language model over the embeddings, which immediately gives us access to RNN-based generation of internal embeddings (and sequences thereof), and (2) index sub-parts of the embeddings, instead of entire embedding vectors, which gives us (i.e., our agents) access to search techniques that go beyond cosine similarity, such as phrase search and search using lightweight structure.</summary><content type="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;meta name="generator" content="pandoc"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes"&gt;
  &lt;title&gt;&lt;/title&gt;
  &lt;style type="text/css"&gt;code{white-space: pre;}&lt;/style&gt;
  &lt;style type="text/css"&gt;
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code &gt; span.kw { color: #007020; font-weight: bold; } /* Keyword */
code &gt; span.dt { color: #902000; } /* DataType */
code &gt; span.dv { color: #40a070; } /* DecVal */
code &gt; span.bn { color: #40a070; } /* BaseN */
code &gt; span.fl { color: #40a070; } /* Float */
code &gt; span.ch { color: #4070a0; } /* Char */
code &gt; span.st { color: #4070a0; } /* String */
code &gt; span.co { color: #60a0b0; font-style: italic; } /* Comment */
code &gt; span.ot { color: #007020; } /* Other */
code &gt; span.al { color: #ff0000; font-weight: bold; } /* Alert */
code &gt; span.fu { color: #06287e; } /* Function */
code &gt; span.er { color: #ff0000; font-weight: bold; } /* Error */
code &gt; span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code &gt; span.cn { color: #880000; } /* Constant */
code &gt; span.sc { color: #4070a0; } /* SpecialChar */
code &gt; span.vs { color: #4070a0; } /* VerbatimString */
code &gt; span.ss { color: #bb6688; } /* SpecialString */
code &gt; span.im { } /* Import */
code &gt; span.va { color: #19177c; } /* Variable */
code &gt; span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code &gt; span.op { color: #666666; } /* Operator */
code &gt; span.bu { } /* BuiltIn */
code &gt; span.ex { } /* Extension */
code &gt; span.pp { color: #bc7a00; } /* Preprocessor */
code &gt; span.at { color: #7d9029; } /* Attribute */
code &gt; span.do { color: #ba2121; font-style: italic; } /* Documentation */
code &gt; span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code &gt; span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code &gt; span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  &lt;/style&gt;
  &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"&gt;&lt;/script&gt;
  &lt;!--[if lt IE 9]&gt;
    &lt;script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"&gt;&lt;/script&gt;
  &lt;![endif]--&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;In my post &lt;a href="http://r2rt.com/beyond-binary-ternary-and-one-hot-neurons.html"&gt;Beyond Binary&lt;/a&gt;, I showed how easy it is to create trainable “one-hot” neurons with the straight-through estimator. My motivation for this is made clear in this post, in which I demonstrate the potential of discrete embeddings. In short, discrete embeddings allow for explicit deconstruction of inherently fuzzy data, which allows us to apply explicit reasoning and algorithms over the data, and communicate fuzzy ideas with concrete symbols. Using discrete embeddings, we can (1) create a language model over the embeddings, which immediately gives us access to RNN-based generation of internal embeddings (and sequences thereof), and (2) index sub-parts of the embeddings, instead of entire embedding vectors, which gives us (i.e., our agents) access to search techniques that go beyond cosine similarity, such as phrase search and search using lightweight structure.&lt;/p&gt;
&lt;p&gt;The ultimate task we will tackle in this post is as follows:&lt;/p&gt;
&lt;p&gt;Suppose we arranged the MNIST training images in a sequence. Does it contain any subsequences of three consecutive digits that have the following three features, respectively, and if so, where:&lt;/p&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/DEE_feature_query.png" alt="png" /&gt;&lt;figcaption&gt;png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;The proposed solution presented does not use class labels, and does not involve any vectors representing sequences of digits such as RNN states. Instead, we will make use of an inverted index over the symbolic language that discrete embeddings provide. The proposed solution is not perfect, and reveals the general challenge that we will face in our quest to enable AIs to represent fuzzy concepts with explicit symbols. It will be interesting to see if the approach presented can be improved to the point where it becomes practical to use as a general technique.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Link to IPython notebook&lt;/strong&gt;: This post is available &lt;a href="https://github.com/spitis/r2rt-deconstruction"&gt;here&lt;/a&gt; as an iPython notebook, together with the supporting code and trained models.&lt;/p&gt;
&lt;h4 id="human-language-and-stage-iii-architectures"&gt;Human language and Stage III architectures&lt;/h4&gt;
&lt;p&gt;A comparison to human language is apt: although our thoughts are generally fuzzy and fraught with ambiguities (like real-valued embeddings (e.g., consider how many reasonable sequences could be decoded from the dense vector representation of a sequence in a sequence autoencoder)), much of our communication is explicit (of course, there is also body language, intonation, etc., which might be considered as real-valued, fuzzy communication channels).&lt;/p&gt;
&lt;p&gt;If we think about the future of AI, I think this comparison is doubly important. In my mind, to date, there have been two major paradigms in AI:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Stage I: Traditional AI based on explicit programming&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;In the 20th century, many advances in AI were based explicit algorithms and data structures, such as &lt;a href="https://en.wikipedia.org/wiki/A*_search_algorithm"&gt;A* search&lt;/a&gt;, &lt;a href="https://en.wikipedia.org/wiki/Frame_(artificial_intelligence)"&gt;frames&lt;/a&gt;, &lt;a href="https://en.wikipedia.org/wiki/Case-based_reasoning"&gt;case-based reasoning&lt;/a&gt;, etc.. A representative computer program based primarily on traditional AI was IBM’s &lt;a href="https://en.wikipedia.org/wiki/Deep_Blue_(chess_computer)"&gt;Deep Blue&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Stage II: Machine learning based on implicit programming&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;More recently, the advances in AI have been primarily based on data, which is used to implicitly program the computer. We tell the computer what we want it to do by defining objectives and rewards, providing it with a general learning algorithm, and feeding it data. It learns on its own how to accomplish those ends: the means are never made explicit. A representative computer program based primarily on machine learning is DeepMind’s &lt;a href="https://en.wikipedia.org/wiki/AlphaGo"&gt;AlphaGo&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Inevitably, I see the third major paradigm of AI to be the following hybrid:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Stage III Implicit programming via explicit symbols, AKA programming via natural language&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;As a prerequisite to strong AI, our computers will need to be able to communicate with humans via a higher-order interface like natural language. If such an interface becomes strong enough, and computers are given sufficient dominion over their internal functionality, we can teach them by talking to them. This requires that the computer be able to represent fuzzy concepts using explicit symbols. A representative (fictional) computer program that employed this approach is Iron Man’s &lt;a href="https://en.wikipedia.org/wiki/Edwin_Jarvis"&gt;J.A.R.V.I.S.&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;One very cool example of an architecture exhibiting stage III abilities is the VAE-GAN, presented in &lt;a href="http://www.jmlr.org/proceedings/papers/v48/larsen16.html"&gt;Larsen et al. (2016)&lt;/a&gt;. The VAE-GAN is able to generate new images and modify old images according to high-order discrete features. Here is the impressive Figure 6 from Larsen et al. (2016):&lt;/p&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/DEE_vaeganfigure6.png" alt="png" /&gt;&lt;figcaption&gt;png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;You can see how given certain discrete features (Bald, Bangs, Black Hair, etc.), the VAE-GAN can modify the input image so as to include those features. In the same way, it can also generate new samples. This is a human-like ability that falls squarely within Stage III.&lt;/p&gt;
&lt;p&gt;This ability is similar in function to, but (per my current understanding) quite different in implementation from, the generative method we explore below. Because I’ve read next to nothing about GANs, I won’t be able to give good commentary in this post. Nevertheless, I think the similarities are strong enough to merit an in-depth analysis. Indeed, a quick scan shows that certain VAE and GAN architectures have already adopted a form of discrete embeddings (e.g., &lt;a href="https://arxiv.org/abs/1606.03657"&gt;this paper (InfoGAN)&lt;/a&gt; and &lt;a href="https://arxiv.org/abs/1609.02200"&gt;this paper (Discrete VAE)&lt;/a&gt;), but I haven’t had a chance to actually read any of these papers yet. I’m not sure how similar/different they are from what I present in this post, and I plan to report back on VAEs/GANs and other architectures after I’ve gotten my hands dirty with them.&lt;a href="#fn1" class="footnoteRef" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Because I only discuss discrete embeddings below, I wanted to emphasize here the dual nature of discrete and real embeddings. Certainly a discrete symbol can be embedded in real space (see, e.g., word2vec). In this post, we are specifically concerned with embedding real vectors in discrete space (maybe I should have titled this post “vec2word”). Each approach has its own advantanges. For example, it is far more difficult to capture continuous features like width, height, weight, angle, etc. with discrete features. There is nothing stopping us from creating models that have both real and discrete internal embeddings (either as a mixed embedding, or as separate/interchangeable &lt;em&gt;dual&lt;/em&gt; embeddings). In fact, we can keep all of our models that use real embeddings exactly the way they are, and add an internal discrete dual of the real embeddings via a discrete autoencoder (a la Part I of this post)—this alone will give us access to the capabilities demonstrated in this post.&lt;/p&gt;
&lt;p&gt;With that said, let’s dive in. The ideas in this post are a long ways away from taking us all the way to Stage III, but I think they’re a step in the right direction. We proceed as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;First, we’ll build a dead simple MNIST autoencoder with an explicit hidden layer and demonstrate that discrete embeddings are sufficiently expressive to achieve good performance. We’ll then visualize the embeddings to get a sense of what each neuron represents.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Then, we’ll show how we can create an RNN-based generative model of MNIST, and demonstrate a few cool things that it can do, including generating samples based on a prototype (i.e., generate “more like this”) and generating samples based on specific feature.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Finally, we’ll show how we can apply traditional information retrieval (IR)—which falls squarely within the Stage I paradigm—to do &lt;em&gt;post-classification&lt;/em&gt; over the features of a Stage II model, and in particular, over sequences of such features.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Throughout our journey, we will repeatedly come face-to-face with the following general challenge:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In order to represent certain fuzzy ideas with explicit codes (words), we need a lot of explicit codes (words). But what happens if the fuzzy ideas are larger than a single word? Then we need to compose words. But no matter how we compose words, we have a line-drawing problem: what is included inside the fuzzy concept, and what is not?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This challenge is inherent to language in general, and is one of the fundamental problems of the legal domain. If it had an easy solution, legalese would not exist, judicial dockets would not be so full, and policy drafting would be a whole lot easier. I will refer to this problem throughout as the problem of &lt;strong&gt;explicit definition&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 id="part-i-an-autocoder-with-discrete-embeddings"&gt;Part I: An autocoder with discrete embeddings&lt;/h2&gt;
&lt;p&gt;The purpose of this part is to (1) prepare us for parts II and III, and (2) to give us some intuitions about how discrete embeddings might represent real-valued embeddings, but also (3) to show that real embeddings and discrete embeddings can effectively be interchanged (we can encode one into the other and back), and can therefore co-exist within the same model. This means that everything we do in Parts II and III can be applied to any layer of a real-valued model by discretely autoencoding that layer.&lt;/p&gt;
&lt;h4 id="imports-and-helper-functions"&gt;Imports and helper functions&lt;/h4&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="im"&gt;import&lt;/span&gt; numpy &lt;span class="im"&gt;as&lt;/span&gt; np, tensorflow &lt;span class="im"&gt;as&lt;/span&gt; tf, matplotlib.pyplot &lt;span class="im"&gt;as&lt;/span&gt; plt
&lt;span class="im"&gt;from&lt;/span&gt; tensorflow.examples.tutorials.mnist &lt;span class="im"&gt;import&lt;/span&gt; input_data
&lt;span class="op"&gt;%&lt;/span&gt;matplotlib inline
mnist &lt;span class="op"&gt;=&lt;/span&gt; input_data.read_data_sets(&lt;span class="st"&gt;&amp;#39;MNIST_data&amp;#39;&lt;/span&gt;, one_hot&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)

&lt;span class="co"&gt;# deconstruction.py: https://github.com/spitis/r2rt-deconstruction/blob/master/deconstruction.py&lt;/span&gt;
&lt;span class="im"&gt;from&lt;/span&gt; deconstruction &lt;span class="im"&gt;import&lt;/span&gt; &lt;span class="op"&gt;*&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="autoencoder-architecture"&gt;Autoencoder architecture&lt;/h4&gt;
&lt;p&gt;The architecture of our autoencoder is very simple. We use a single convolutional layer with 16 5x5 filters, followed by a 2x2 max pooling layer. Then there is the fully-connected (FC) embedding layer, which consists of either explicit (one-hot) neurons, real neurons, or both. The embedding layer is then projected back into the original input space using a fully-connected projection followed by a sigmoid.&lt;/p&gt;
&lt;p&gt;For our explicit autoencoder, we use 80 explicit neurons, each with 8 dimensions. We also enforce, via training, that the first dimension of each neuron is dead by requiring the network to project all 0s when the explicit neurons are all hot in the first dimension (this will be useful for certain visualizations).&lt;/p&gt;
&lt;p&gt;To recap, the layers used are:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;Input&lt;/li&gt;
&lt;li&gt;5x5 Conv (16 dims)&lt;/li&gt;
&lt;li&gt;FC with 8-dimensional one-hot activation (80 neurons, 640 binary dimensions), dead in the first dimension&lt;/li&gt;
&lt;li&gt;FC softmax projection&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We train the network with simple gradient descent with a batch size of 50 and a learning rate of 1e-1, after an initial “warm-up” epoch that uses a learning rate of 1e-4 (so that the one-hot neurons learn to fire more predictably).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Important note on mixed embeddings&lt;/strong&gt;: In case you try this at home with a mix of real and explicit neurons (within the same layer), beware that the explicit neurons are noisy during training. This will cause the model to put its faith in the real neurons (which fire deterministically), and will cause the most important information to be stored in the real neurons. If training a mixed model, it is advised that you either apply heavy noise to the real neurons (e.g., via dropout or gaussian noise) or pretrain the explicit neurons to capture as much information as they can, and then train the real neurons afterwards so that they finetune the explicit neurons (because it makes much more sense, at least to me, to finetune explicit chunks with real values, than vice versa).&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;g &lt;span class="op"&gt;=&lt;/span&gt; build_classifier(onehot_dims &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;8&lt;/span&gt;, explicit_neurons &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;80&lt;/span&gt;)
sess &lt;span class="op"&gt;=&lt;/span&gt; tf.InteractiveSession()
sess.run(tf.global_variables_initializer())

&lt;span class="co"&gt;# Uncomment to run training, or use the below checkpoint to load&lt;/span&gt;
&lt;span class="co"&gt;# tr, va = train_autoencoder(g, sess, num_epochs=30)&lt;/span&gt;

saver &lt;span class="op"&gt;=&lt;/span&gt; tf.train.Saver()
saver.restore(sess, &lt;span class="st"&gt;&amp;#39;./ckpts/trained_80x8_autoencoder&amp;#39;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="autoencoder-results"&gt;Autoencoder results&lt;/h4&gt;
&lt;p&gt;Training for 30 epochs gets us to a loss between 5.5 and 6.0 on the validation set, and with some more training, we can get the loss down to 5.0. By comparison if we train the same architecture using 80 real neurons, we can easily achieve losses under 4.0. Nevertheless, while our 8-dimensional (really 7, because of the dead dimension) one-hot neurons are less expressive, they still have a lot of power: &lt;span class="math inline"&gt;\(7^{80}\)&lt;/span&gt; possible combinations is a big number. A visual comparison of inputs and projections on the first 12 images of the MNIST test set is shown below.&lt;/p&gt;
&lt;h5 id="original-mnist-top-vs-projections-bottom"&gt;Original MNIST (top) vs projections (bottom)&lt;/h5&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;projs &lt;span class="op"&gt;=&lt;/span&gt; sess.run(g[&lt;span class="st"&gt;&amp;#39;projection&amp;#39;&lt;/span&gt;], feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{g[&lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;]: mnist.test.images[:&lt;span class="dv"&gt;12&lt;/span&gt;], g[&lt;span class="st"&gt;&amp;#39;stochastic&amp;#39;&lt;/span&gt;]: &lt;span class="va"&gt;False&lt;/span&gt;})
plot_2xn(&lt;span class="dv"&gt;12&lt;/span&gt;,np.concatenate((mnist.test.images[:&lt;span class="dv"&gt;12&lt;/span&gt;], projs)))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/DEE_output_11_0.png" alt="png" /&gt;&lt;figcaption&gt;png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;As you can see, our projections of the first 12 MNIST test images are only slightly corrupted. The major features of the original images remain, with a few faded portions.&lt;/p&gt;
&lt;h4 id="visualizing-features"&gt;Visualizing features&lt;/h4&gt;
&lt;p&gt;Given that our features are explicit, we can visualize each one precisely. Let’s have a go at it, by setting all neurons in the “off” position (first dimension), except for one, chosen at random. You can view the results below for 24 random samples that have a single random feature of a single random neuron turned on.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;emb_feed &lt;span class="op"&gt;=&lt;/span&gt; np.tile(np.array([[[&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;0&lt;/span&gt;]]]), (&lt;span class="dv"&gt;24&lt;/span&gt;, &lt;span class="dv"&gt;80&lt;/span&gt;, &lt;span class="dv"&gt;1&lt;/span&gt;))
&lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;24&lt;/span&gt;):
    emb_feed[i][i&lt;span class="op"&gt;%&lt;/span&gt;&lt;span class="dv"&gt;80&lt;/span&gt;] &lt;span class="op"&gt;=&lt;/span&gt; np.eye(&lt;span class="dv"&gt;8&lt;/span&gt;)[np.random.randint(&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;8&lt;/span&gt;)]
projs &lt;span class="op"&gt;=&lt;/span&gt; sess.run(g[&lt;span class="st"&gt;&amp;#39;projection&amp;#39;&lt;/span&gt;], feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{g[&lt;span class="st"&gt;&amp;#39;embedding&amp;#39;&lt;/span&gt;]: emb_feed, g[&lt;span class="st"&gt;&amp;#39;stochastic&amp;#39;&lt;/span&gt;]: &lt;span class="va"&gt;False&lt;/span&gt;})
plot_2xn(&lt;span class="dv"&gt;12&lt;/span&gt;,projs)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/DEE_output_14_0.png" alt="png" /&gt;&lt;figcaption&gt;png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;Notice how several of the features are pure noise. This is because some neurons have activations that never fire: despite being able to fire in 7 different live positions, some neurons fire only in a subset of those 7. Let’s see the firing densities of the first 5 neurons on the MNIST validation set:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;embs &lt;span class="op"&gt;=&lt;/span&gt; sess.run(g[&lt;span class="st"&gt;&amp;#39;embedding&amp;#39;&lt;/span&gt;], feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{g[&lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;]: mnist.validation.images, g[&lt;span class="st"&gt;&amp;#39;stochastic&amp;#39;&lt;/span&gt;]: &lt;span class="va"&gt;False&lt;/span&gt;})
densities &lt;span class="op"&gt;=&lt;/span&gt; np.&lt;span class="bu"&gt;sum&lt;/span&gt;(embs, axis&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;0&lt;/span&gt;) &lt;span class="op"&gt;/&lt;/span&gt; np.&lt;span class="bu"&gt;sum&lt;/span&gt;(np.&lt;span class="bu"&gt;sum&lt;/span&gt;(embs, axis&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;0&lt;/span&gt;), axis &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;, keepdims&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)
&lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;5&lt;/span&gt;):
    &lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;&lt;span class="sc"&gt;{:.2f}&lt;/span&gt;&lt;span class="st"&gt; - &lt;/span&gt;&lt;span class="sc"&gt;{:.2f}&lt;/span&gt;&lt;span class="st"&gt; - &lt;/span&gt;&lt;span class="sc"&gt;{:.2f}&lt;/span&gt;&lt;span class="st"&gt; - &lt;/span&gt;&lt;span class="sc"&gt;{:.2f}&lt;/span&gt;&lt;span class="st"&gt; - &lt;/span&gt;&lt;span class="sc"&gt;{:.2f}&lt;/span&gt;&lt;span class="st"&gt; - &lt;/span&gt;&lt;span class="sc"&gt;{:.2f}&lt;/span&gt;&lt;span class="st"&gt; - &lt;/span&gt;&lt;span class="sc"&gt;{:.2f}&lt;/span&gt;&lt;span class="st"&gt; - &lt;/span&gt;&lt;span class="sc"&gt;{:.2f}&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;.&lt;span class="bu"&gt;format&lt;/span&gt;(&lt;span class="op"&gt;*&lt;/span&gt;densities[i]))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;0.00 - 0.16 - 0.21 - 0.17 - 0.16 - 0.18 - 0.00 - 0.12
0.00 - 0.00 - 0.14 - 0.18 - 0.18 - 0.17 - 0.19 - 0.14
0.00 - 0.22 - 0.19 - 0.15 - 0.16 - 0.15 - 0.00 - 0.13
0.00 - 0.26 - 0.20 - 0.00 - 0.23 - 0.12 - 0.07 - 0.11
0.00 - 0.09 - 0.00 - 0.22 - 0.29 - 0.10 - 0.12 - 0.18&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Because we trained our network to consider the first dimension as dead, it never fires. Additionally, we see that the network has learned a few more dead dimensions: the first and third neurons never fire in the 7th position, the second neuron never fires in the 2nd position, the fourth neuron never fires in the 4th position, and the last neuron never fires in the 3rd position.&lt;/p&gt;
&lt;p&gt;These positions correspond to the “noisy” items in the grid above. If we only plot live features according to the densities we just computed, we eliminate the noisy features:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;emb_feed &lt;span class="op"&gt;=&lt;/span&gt; np.tile(np.array([[[&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;0&lt;/span&gt;]]]), (&lt;span class="dv"&gt;100&lt;/span&gt;, &lt;span class="dv"&gt;80&lt;/span&gt;, &lt;span class="dv"&gt;1&lt;/span&gt;))
&lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;100&lt;/span&gt;):
    emb_feed[i][i&lt;span class="op"&gt;%&lt;/span&gt;&lt;span class="dv"&gt;80&lt;/span&gt;] &lt;span class="op"&gt;=&lt;/span&gt; np.eye(&lt;span class="dv"&gt;8&lt;/span&gt;)[np.random.choice([&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;2&lt;/span&gt;,&lt;span class="dv"&gt;3&lt;/span&gt;,&lt;span class="dv"&gt;4&lt;/span&gt;,&lt;span class="dv"&gt;5&lt;/span&gt;,&lt;span class="dv"&gt;6&lt;/span&gt;,&lt;span class="dv"&gt;7&lt;/span&gt;], p&lt;span class="op"&gt;=&lt;/span&gt;densities[i&lt;span class="op"&gt;%&lt;/span&gt;&lt;span class="dv"&gt;80&lt;/span&gt;])]
projs &lt;span class="op"&gt;=&lt;/span&gt; sess.run(g[&lt;span class="st"&gt;&amp;#39;projection&amp;#39;&lt;/span&gt;], feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{g[&lt;span class="st"&gt;&amp;#39;embedding&amp;#39;&lt;/span&gt;]: emb_feed, g[&lt;span class="st"&gt;&amp;#39;stochastic&amp;#39;&lt;/span&gt;]: &lt;span class="va"&gt;False&lt;/span&gt;})
plot_nxn(&lt;span class="dv"&gt;10&lt;/span&gt;,projs)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/DEE_output_18_0.png" alt="png" /&gt;&lt;figcaption&gt;png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;Pretty cool. There seems to be a fairly even distribution between sharp positive features, negative hole features (the ones that look like black holes), and somewhat random features. Note that these features are all very faint individually (the function that plots the images is automatically normalizing the white level), and they only become sharp once you add many of them together.&lt;/p&gt;
&lt;p&gt;In fact, let’s do that now. If we ignore the fact that neurons are dependent (there is a complex joint probability distribution), we can sample them according to their raw densities:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;emb_feed &lt;span class="op"&gt;=&lt;/span&gt; np.tile(np.array([[[&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;0&lt;/span&gt;]]]), (&lt;span class="dv"&gt;100&lt;/span&gt;, &lt;span class="dv"&gt;80&lt;/span&gt;, &lt;span class="dv"&gt;1&lt;/span&gt;))
&lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;100&lt;/span&gt;):
    &lt;span class="cf"&gt;for&lt;/span&gt; j &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;80&lt;/span&gt;):
        emb_feed[i][j] &lt;span class="op"&gt;=&lt;/span&gt; np.eye(&lt;span class="dv"&gt;8&lt;/span&gt;)[np.random.choice([&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;2&lt;/span&gt;,&lt;span class="dv"&gt;3&lt;/span&gt;,&lt;span class="dv"&gt;4&lt;/span&gt;,&lt;span class="dv"&gt;5&lt;/span&gt;,&lt;span class="dv"&gt;6&lt;/span&gt;,&lt;span class="dv"&gt;7&lt;/span&gt;], p&lt;span class="op"&gt;=&lt;/span&gt;densities[j])]

projs &lt;span class="op"&gt;=&lt;/span&gt; sess.run(g[&lt;span class="st"&gt;&amp;#39;projection&amp;#39;&lt;/span&gt;], feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{g[&lt;span class="st"&gt;&amp;#39;embedding&amp;#39;&lt;/span&gt;]: emb_feed, g[&lt;span class="st"&gt;&amp;#39;stochastic&amp;#39;&lt;/span&gt;]: &lt;span class="va"&gt;False&lt;/span&gt;})
plot_nxn(&lt;span class="dv"&gt;10&lt;/span&gt;,projs)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/DEE_output_20_0.png" alt="png" /&gt;&lt;figcaption&gt;png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;This generates some pretty cool looking designs that look more like murky shadows of numbers than numbers themselves.&lt;/p&gt;
&lt;p&gt;Note that despite the almost random appearance of these designs, they can each be precisely communicated in a sparse binary code consisting of exactly 560 zeros and 80 ones.&lt;/p&gt;
&lt;h2 id="part-ii-generating-digits-with-an-rnn"&gt;Part II: Generating digits with an RNN&lt;/h2&gt;
&lt;p&gt;Our neurons are explicit, and so we can think of each neuron as a word in a language, where each MNIST digit is made up of 80 different words. Modeling the joint distribution then, is very much like modeling a language, which is an area in which RNNs shine. In this section we create an RNN-based generator that models the joint distribution of the explicit MNIST embeddings.&lt;/p&gt;
&lt;h4 id="data"&gt;Data&lt;/h4&gt;
&lt;p&gt;We want to feed our RNN sequences of 80 neurons, but our neurons have no predetermined order (query how to give them a heirarchical structure, which would greatly expand their usefulness). Thus, in order to allow the RNN to generate the remainder of an embedding given arbitrary neurons, we randomize the order in which the neurons are presented to the RNN during training. This forces us to use 640-dimensional one-hot vectors for our model inputs and targets (using 8-dimensional vectors would pre-suppose an order).&lt;/p&gt;
&lt;p&gt;To illustrate precisely what our training sequences look like, below is our data generator, and two different training sequences generated by the first image in the MNIST training set (note how they just permutations of each other). Each index indicates where the flattened embedding layer is “hot”.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; imgs_to_indices(imgs):
    embs &lt;span class="op"&gt;=&lt;/span&gt; sess.run(g[&lt;span class="st"&gt;&amp;#39;embedding&amp;#39;&lt;/span&gt;], feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{g[&lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;]: imgs, g[&lt;span class="st"&gt;&amp;#39;stochastic&amp;#39;&lt;/span&gt;]: &lt;span class="va"&gt;False&lt;/span&gt;}) &lt;span class="co"&gt;#[n, 80, 8]&lt;/span&gt;
    idx &lt;span class="op"&gt;=&lt;/span&gt; np.argmax(embs, axis&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;2&lt;/span&gt;) &lt;span class="co"&gt;#[n, 80]&lt;/span&gt;
    res &lt;span class="op"&gt;=&lt;/span&gt; []
    &lt;span class="cf"&gt;for&lt;/span&gt; img &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="bu"&gt;len&lt;/span&gt;(imgs)):
        neuron_perm &lt;span class="op"&gt;=&lt;/span&gt; np.random.permutation(&lt;span class="bu"&gt;list&lt;/span&gt;(&lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;80&lt;/span&gt;))) &lt;span class="co"&gt;#order of neurons we will present&lt;/span&gt;
        res.append(idx[img][neuron_perm] &lt;span class="op"&gt;+&lt;/span&gt; neuron_perm &lt;span class="op"&gt;*&lt;/span&gt; &lt;span class="dv"&gt;8&lt;/span&gt;)
    &lt;span class="cf"&gt;return&lt;/span&gt; np.array(res)

&lt;span class="kw"&gt;def&lt;/span&gt; gen_random_neuron_batch(n):
    x, _ &lt;span class="op"&gt;=&lt;/span&gt; mnist.train.next_batch(n) &lt;span class="co"&gt;# [n, 784]&lt;/span&gt;
    res &lt;span class="op"&gt;=&lt;/span&gt; imgs_to_indices(x)
    &lt;span class="cf"&gt;return&lt;/span&gt; res[:,:&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;], res[:,&lt;span class="dv"&gt;1&lt;/span&gt;:]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;2&lt;/span&gt;):
    &lt;span class="bu"&gt;print&lt;/span&gt;(imgs_to_indices(mnist.train.images[:&lt;span class="dv"&gt;1&lt;/span&gt;]))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;[[ 18 167 116 546 122 180 236 145 563  13 101 249 575 446 475 347  73 194
  583 283 131 354 393 523 204 365 339 469  54 259 187   3 625  37 223 228
   47 457 489 419 242 175  83 385 383 110 518 141 484 589 412 157 305 500
  613 543 291 210  70  90 313 433 594 634 509 299 426  28 404 617 372  58
  329 273 603 325 265 557 451 531]]
[[404  70 339 634 236 223 433 419 329  90  13 583 157 457 110 116 543  37
  523  54  28  83 500 575 283 180 141 451 594 325 347 475 204 393   3 365
  175 291 265 518 259 531 167 228 299 354 305 589 372 187  58 446 625 210
  563 557 249 426 412 101 613 489 469 313  47 617 385 131 242 509 484  18
  603 194  73 122 145 383 273 546]]&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="model"&gt;Model&lt;/h4&gt;
&lt;p&gt;The architecture of our RNN is very simple. We use a 1000-unit GRU cell, with a 100-dimensional (real-valued) embedding layer. The network is trained for 10 epochs with Adam at an initial learning rate 2e-3. As the number of possible input sequences is practically limitless (each of the 55000 training examples can generate 80! permuted sequences), no regularization is used. The norm of the gradient is clipped at 1.0. I did not do a hyperparameter search, or even early stopping, so this is likely far from an optimal generator.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;h &lt;span class="op"&gt;=&lt;/span&gt; build_recurrent_generator()
sess.run(tf.variables_initializer([v &lt;span class="cf"&gt;for&lt;/span&gt; v &lt;span class="kw"&gt;in&lt;/span&gt; tf.global_variables() &lt;span class="cf"&gt;if&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;generator&amp;#39;&lt;/span&gt; &lt;span class="kw"&gt;in&lt;/span&gt; v.name]))

&lt;span class="co"&gt;# Uncomment to run training, or use the below checkpoint to load&lt;/span&gt;
&lt;span class="co"&gt;# train_RNN(h, sess, batch_generator=gen_random_neuron_batch, epochs=10)&lt;/span&gt;

saver &lt;span class="op"&gt;=&lt;/span&gt; tf.train.Saver()
saver.restore(sess, &lt;span class="st"&gt;&amp;#39;./ckpts/gen_80x8_1000state_RANDOMPERM_10epochs_&amp;#39;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="generation"&gt;Generation&lt;/h4&gt;
&lt;p&gt;After some helper functions:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; gen_next_step(current_input, prior_state&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;None&lt;/span&gt;):
    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;Accepts a current input (index) (shape (batch_size, 1)) and a prior_state&lt;/span&gt;
&lt;span class="co"&gt;    (shape (batch_size, 1000)). Returns dist over the next step, and the resulting state.&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="cf"&gt;if&lt;/span&gt; prior_state &lt;span class="kw"&gt;is&lt;/span&gt; &lt;span class="va"&gt;None&lt;/span&gt;:
        feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{h[&lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;]: current_input}
    &lt;span class="cf"&gt;else&lt;/span&gt;:
        feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{h[&lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;]: current_input, h[&lt;span class="st"&gt;&amp;#39;init_state&amp;#39;&lt;/span&gt;]: prior_state}
    &lt;span class="cf"&gt;return&lt;/span&gt; sess.run([h[&lt;span class="st"&gt;&amp;#39;next_y_dist&amp;#39;&lt;/span&gt;], h[&lt;span class="st"&gt;&amp;#39;final_state&amp;#39;&lt;/span&gt;]], feed_dict&lt;span class="op"&gt;=&lt;/span&gt;feed_dict)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; generate_embedding(prompt&lt;span class="op"&gt;=&lt;/span&gt;np.array([&lt;span class="dv"&gt;2&lt;/span&gt;]), top_choices &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;):
    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot; Accepts a prompt, and generates the rest&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    state &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="va"&gt;None&lt;/span&gt;

    &lt;span class="cf"&gt;while&lt;/span&gt; &lt;span class="bu"&gt;len&lt;/span&gt;(prompt) &lt;span class="op"&gt;&amp;lt;&lt;/span&gt; &lt;span class="dv"&gt;80&lt;/span&gt;:
        &lt;span class="cf"&gt;if&lt;/span&gt; state &lt;span class="kw"&gt;is&lt;/span&gt; &lt;span class="kw"&gt;not&lt;/span&gt; &lt;span class="va"&gt;None&lt;/span&gt;:
            y_dist, state &lt;span class="op"&gt;=&lt;/span&gt; gen_next_step(np.expand_dims([prompt[&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;]], &lt;span class="dv"&gt;0&lt;/span&gt;), state)
        &lt;span class="cf"&gt;else&lt;/span&gt;:
            y_dist, state &lt;span class="op"&gt;=&lt;/span&gt; gen_next_step(np.expand_dims(prompt, &lt;span class="dv"&gt;0&lt;/span&gt;))

        p &lt;span class="op"&gt;=&lt;/span&gt; y_dist[&lt;span class="dv"&gt;0&lt;/span&gt;]
        p[np.argsort(p)[:&lt;span class="op"&gt;-&lt;/span&gt;top_choices]] &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;
        p &lt;span class="op"&gt;=&lt;/span&gt; p &lt;span class="op"&gt;/&lt;/span&gt; np.&lt;span class="bu"&gt;sum&lt;/span&gt;(p)
        next_idx &lt;span class="op"&gt;=&lt;/span&gt; np.random.choice(&lt;span class="dv"&gt;640&lt;/span&gt;, p&lt;span class="op"&gt;=&lt;/span&gt;p)

        prompt &lt;span class="op"&gt;=&lt;/span&gt; np.concatenate((prompt, [next_idx]))

    &lt;span class="cf"&gt;return&lt;/span&gt; prompt&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; emb_idx_to_emb(emb_idx):
    emb &lt;span class="op"&gt;=&lt;/span&gt; np.eye(&lt;span class="dv"&gt;8&lt;/span&gt;)[np.array(&lt;span class="bu"&gt;sorted&lt;/span&gt;(emb_idx)) &lt;span class="op"&gt;%&lt;/span&gt; &lt;span class="dv"&gt;8&lt;/span&gt;]
    &lt;span class="cf"&gt;return&lt;/span&gt; np.reshape(emb, (&lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="dv"&gt;80&lt;/span&gt;, &lt;span class="dv"&gt;8&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can now generate some digits. Below, we sample 12 random images from the MNIST validation set, transform them into their neuron indices, randomly permute the indices, and take the first n-indices (for n in {5, 10, 20, 40}) as the prompt to our RNN. The RNN generates the rest, which we convert back into 80x8 embeddings, feed into our decoder, and plot. The top rows of each figure are the orginal digits, and the bottom rows are the digits generated from using their neuron activations as prompts.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; generate_from_originals(size_of_prompt):
    originals, generated &lt;span class="op"&gt;=&lt;/span&gt; [], []
    &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;12&lt;/span&gt;):
        img_idx &lt;span class="op"&gt;=&lt;/span&gt; np.random.randint(&lt;span class="dv"&gt;0&lt;/span&gt;, &lt;span class="dv"&gt;5000&lt;/span&gt;)
        originals.append(mnist.validation.images[img_idx:img_idx&lt;span class="op"&gt;+&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;])
    &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;12&lt;/span&gt;):
        img &lt;span class="op"&gt;=&lt;/span&gt; imgs_to_indices(originals[i])
        emb_idx &lt;span class="op"&gt;=&lt;/span&gt; generate_embedding(img[&lt;span class="dv"&gt;0&lt;/span&gt;][:size_of_prompt], &lt;span class="dv"&gt;3&lt;/span&gt;)
        emb &lt;span class="op"&gt;=&lt;/span&gt; emb_idx_to_emb(emb_idx)
        generated.append(emb)
    originals, generated &lt;span class="op"&gt;=&lt;/span&gt; np.squeeze(originals), np.squeeze(generated)
    projs &lt;span class="op"&gt;=&lt;/span&gt; sess.run(g[&lt;span class="st"&gt;&amp;#39;projection&amp;#39;&lt;/span&gt;], feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{g[&lt;span class="st"&gt;&amp;#39;embedding&amp;#39;&lt;/span&gt;]: generated, g[&lt;span class="st"&gt;&amp;#39;stochastic&amp;#39;&lt;/span&gt;]: &lt;span class="va"&gt;False&lt;/span&gt;})
    plot_2xn(&lt;span class="dv"&gt;12&lt;/span&gt;, np.concatenate((originals, projs)))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;generate_from_originals(size_of_prompt&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;5&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/DEE_output_34_0.png" alt="png" /&gt;&lt;figcaption&gt;png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;generate_from_originals(size_of_prompt&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;10&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/DEE_output_35_0.png" alt="png" /&gt;&lt;figcaption&gt;png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;generate_from_originals(size_of_prompt&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;20&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/DEE_output_36_0.png" alt="png" /&gt;&lt;figcaption&gt;png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;generate_from_originals(size_of_prompt&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;40&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/DEE_output_37_0.png" alt="png" /&gt;&lt;figcaption&gt;png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;From the above, we can see how important each neuron is. With only a 5 neuron prompt, our generator is about 50/50 to generate the same digit vs another digit (again, originals are on the top row, and generated digits are on the bottom). When it generates the same digit, it varies quite a bit from the original. As we ramp up the prompt to 40 neurons from the original, our generator starts to generate samples that look more and more like the original.&lt;/p&gt;
&lt;h4 id="generated-samples-vs.the-prompts-used-to-generate-them"&gt;Generated samples vs. the prompts used to generate them&lt;/h4&gt;
&lt;p&gt;To get an idea of how the prompt conditions the model, we plot some samples (top) against the prompts they were generated from (bottom). All come from the same random image, and the prompt sizes from left to right start are [1, 5, 9 … 37].&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;res, prompts &lt;span class="op"&gt;=&lt;/span&gt; [], []
img_idx &lt;span class="op"&gt;=&lt;/span&gt; np.random.randint(&lt;span class="dv"&gt;0&lt;/span&gt;, &lt;span class="dv"&gt;5000&lt;/span&gt;)
img &lt;span class="op"&gt;=&lt;/span&gt; imgs_to_indices(mnist.validation.images[img_idx:img_idx&lt;span class="op"&gt;+&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;])[&lt;span class="dv"&gt;0&lt;/span&gt;]
&lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;10&lt;/span&gt;):
    prompts.append(np.random.permutation(img))
    emb_idx &lt;span class="op"&gt;=&lt;/span&gt; generate_embedding(prompts[&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;][:(&lt;span class="dv"&gt;4&lt;/span&gt;&lt;span class="op"&gt;*&lt;/span&gt;i)&lt;span class="op"&gt;+&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;],&lt;span class="dv"&gt;3&lt;/span&gt;)
    emb &lt;span class="op"&gt;=&lt;/span&gt; emb_idx_to_emb(emb_idx)
    res.append(emb)
&lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;10&lt;/span&gt;):
    set_neurons &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;set&lt;/span&gt;(prompts[i][:(&lt;span class="dv"&gt;4&lt;/span&gt;&lt;span class="op"&gt;*&lt;/span&gt;i)&lt;span class="op"&gt;+&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;] &lt;span class="op"&gt;//&lt;/span&gt; &lt;span class="dv"&gt;8&lt;/span&gt;)
    neurons_indices &lt;span class="op"&gt;=&lt;/span&gt; np.array([&lt;span class="dv"&gt;8&lt;/span&gt;&lt;span class="op"&gt;*&lt;/span&gt;j &lt;span class="cf"&gt;for&lt;/span&gt; j &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;80&lt;/span&gt;) &lt;span class="cf"&gt;if&lt;/span&gt; j &lt;span class="kw"&gt;not&lt;/span&gt; &lt;span class="kw"&gt;in&lt;/span&gt; set_neurons])
    emb &lt;span class="op"&gt;=&lt;/span&gt; emb_idx_to_emb(np.concatenate((prompts[i][:(&lt;span class="dv"&gt;4&lt;/span&gt;&lt;span class="op"&gt;*&lt;/span&gt;i)&lt;span class="op"&gt;+&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;],neurons_indices)))
    res.append(emb)
res &lt;span class="op"&gt;=&lt;/span&gt; np.squeeze(res)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;projs &lt;span class="op"&gt;=&lt;/span&gt; sess.run(g[&lt;span class="st"&gt;&amp;#39;projection&amp;#39;&lt;/span&gt;], feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{g[&lt;span class="st"&gt;&amp;#39;embedding&amp;#39;&lt;/span&gt;]: res, g[&lt;span class="st"&gt;&amp;#39;stochastic&amp;#39;&lt;/span&gt;]: &lt;span class="va"&gt;False&lt;/span&gt;})
plot_2xn(&lt;span class="dv"&gt;10&lt;/span&gt;, projs)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/DEE_output_41_0.png" alt="png" /&gt;&lt;figcaption&gt;png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h4 id="generating-by-prototype-more-like-this-samples"&gt;Generating by prototype: “more like this” samples&lt;/h4&gt;
&lt;p&gt;Below, we use a prompt of 30 neurons to generate “more like this” of a rather distinctive 7 from the mnist test set. As demonstrated above, we could make our generated samples more similar or less similar by varying the length of our prompt. Note how our generator sometimes generates 9 instead of 7.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;plot_nxn(&lt;span class="dv"&gt;1&lt;/span&gt;, mnist.test.images[&lt;span class="dv"&gt;80&lt;/span&gt;:&lt;span class="dv"&gt;81&lt;/span&gt;])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/DEE_output_44_0.png" alt="png" /&gt;&lt;figcaption&gt;png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;res &lt;span class="op"&gt;=&lt;/span&gt; []
&lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;0&lt;/span&gt;, &lt;span class="dv"&gt;100&lt;/span&gt;):
    img_idx &lt;span class="op"&gt;=&lt;/span&gt; np.random.randint(&lt;span class="dv"&gt;0&lt;/span&gt;, &lt;span class="dv"&gt;5000&lt;/span&gt;)
    img &lt;span class="op"&gt;=&lt;/span&gt; imgs_to_indices(mnist.test.images[&lt;span class="dv"&gt;80&lt;/span&gt;:&lt;span class="dv"&gt;81&lt;/span&gt;])
    emb_idx &lt;span class="op"&gt;=&lt;/span&gt; generate_embedding(img[&lt;span class="dv"&gt;0&lt;/span&gt;][:&lt;span class="dv"&gt;30&lt;/span&gt;], &lt;span class="dv"&gt;2&lt;/span&gt;)
    emb &lt;span class="op"&gt;=&lt;/span&gt; emb_idx_to_emb(emb_idx)
    res.append(emb)
res &lt;span class="op"&gt;=&lt;/span&gt; np.squeeze(res)
projs &lt;span class="op"&gt;=&lt;/span&gt; sess.run(g[&lt;span class="st"&gt;&amp;#39;projection&amp;#39;&lt;/span&gt;], feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{g[&lt;span class="st"&gt;&amp;#39;embedding&amp;#39;&lt;/span&gt;]: res, g[&lt;span class="st"&gt;&amp;#39;stochastic&amp;#39;&lt;/span&gt;]: &lt;span class="va"&gt;False&lt;/span&gt;})
plot_nxn(&lt;span class="dv"&gt;10&lt;/span&gt;, projs)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/DEE_output_45_0.png" alt="png" /&gt;&lt;figcaption&gt;png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h4 id="generating-samples-with-distinct-features"&gt;Generating samples with distinct features&lt;/h4&gt;
&lt;p&gt;Now let’s do something really cool. We’ll draw eight of our own small features, find out which explicit dimensions they correspond to, and then use those dimensions as prompts to generate samples that have that feature.&lt;/p&gt;
&lt;p&gt;Here, we run up against the general challenge of explicit definition for the first time. While we can draw the features, and see the features, when does an MNIST digit have that feature? Given that reasonable people can disagree on the answer, it is unreasonable for us to try expect a single explicit feature specification (in our case, a prompt) to be perfect. Nevertheless, we need to provide our RNN with a prompt in order for it to generate samples.&lt;/p&gt;
&lt;p&gt;The method we use below is more than a little brittle, and takes a bit of trial and error to get right. To find the embeddings that each feature corresponds to we add random noise the image of the feature, and run a batch of the noisy images through our encoder. We then construct our prompts by subsampling the activations that fire often for that feature.&lt;/p&gt;
&lt;p&gt;Based on trial and error, I defined “fire often” to mean firing in more than 5/6 of all noisy samples, and chose to subsample 60% of the activations for each prompt. Obviously, this is not a practical approach for the general case, and additional work will need to be done in order to find something that generalizes well to other cases.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="im"&gt;import&lt;/span&gt; matplotlib.image &lt;span class="im"&gt;as&lt;/span&gt; mpimg&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;features &lt;span class="op"&gt;=&lt;/span&gt; []
&lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;8&lt;/span&gt;):
    features.append(np.reshape(&lt;span class="fl"&gt;1.&lt;/span&gt; &lt;span class="op"&gt;-&lt;/span&gt; mpimg.imread(&lt;span class="st"&gt;&amp;#39;./images/feature_&lt;/span&gt;&lt;span class="sc"&gt;{}&lt;/span&gt;&lt;span class="st"&gt;.png&amp;#39;&lt;/span&gt;.&lt;span class="bu"&gt;format&lt;/span&gt;(i), &lt;span class="bu"&gt;format&lt;/span&gt;&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;grayscale&amp;#39;&lt;/span&gt;)[:,:,&lt;span class="dv"&gt;0&lt;/span&gt;] &lt;span class="op"&gt;/&lt;/span&gt; &lt;span class="fl"&gt;255.&lt;/span&gt;, (&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;784&lt;/span&gt;)))
features &lt;span class="op"&gt;=&lt;/span&gt; np.array(features)
features &lt;span class="op"&gt;*=&lt;/span&gt; &lt;span class="fl"&gt;1.5&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;plot_mxn(&lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="dv"&gt;8&lt;/span&gt;, features)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/DEE_output_49_0.png" alt="png" /&gt;&lt;figcaption&gt;png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; get_noisy_imgs(feature):
    noisy_imgs &lt;span class="op"&gt;=&lt;/span&gt; []
    &lt;span class="cf"&gt;for&lt;/span&gt; img &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;300&lt;/span&gt;):
        noisy_img &lt;span class="op"&gt;=&lt;/span&gt; feature.copy()
        &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;784&lt;/span&gt;):
            &lt;span class="cf"&gt;while&lt;/span&gt; np.random.random() &lt;span class="op"&gt;&amp;gt;&lt;/span&gt; &lt;span class="fl"&gt;0.75&lt;/span&gt;:
                noisy_img[&lt;span class="dv"&gt;0&lt;/span&gt;, i] &lt;span class="op"&gt;+=&lt;/span&gt; &lt;span class="bu"&gt;min&lt;/span&gt;(&lt;span class="fl"&gt;0.2&lt;/span&gt;, &lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="op"&gt;-&lt;/span&gt;noisy_img[&lt;span class="dv"&gt;0&lt;/span&gt;, i])
        noisy_imgs.append(noisy_img)
    &lt;span class="cf"&gt;return&lt;/span&gt; np.squeeze(noisy_imgs)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;first_feature_with_noise &lt;span class="op"&gt;=&lt;/span&gt; get_noisy_imgs(features[&lt;span class="dv"&gt;0&lt;/span&gt;])[:&lt;span class="dv"&gt;20&lt;/span&gt;]
plot_2xn(&lt;span class="dv"&gt;10&lt;/span&gt;, first_feature_with_noise)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/DEE_output_51_0.png" alt="png" /&gt;&lt;figcaption&gt;png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;Just for fun, below are the projections of the first feature. You can see that the autoencoder can’t autoencode the noise properly, as it was trained on regular looking digits, but that the feature we asked for is present in all of them.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;projs &lt;span class="op"&gt;=&lt;/span&gt; sess.run(g[&lt;span class="st"&gt;&amp;#39;projection&amp;#39;&lt;/span&gt;], feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{g[&lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;]: first_feature_with_noise, g[&lt;span class="st"&gt;&amp;#39;stochastic&amp;#39;&lt;/span&gt;]: &lt;span class="va"&gt;False&lt;/span&gt;})
plot_2xn(&lt;span class="dv"&gt;10&lt;/span&gt;, projs[:&lt;span class="dv"&gt;20&lt;/span&gt;])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/DEE_output_53_0.png" alt="png" /&gt;&lt;figcaption&gt;png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;We generate noisy images for each feature, and collect the firing patterns:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;firing_patterns &lt;span class="op"&gt;=&lt;/span&gt; []
&lt;span class="cf"&gt;for&lt;/span&gt; feature &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;8&lt;/span&gt;):
    noisy_imgs &lt;span class="op"&gt;=&lt;/span&gt; get_noisy_imgs(features[feature])
    embs &lt;span class="op"&gt;=&lt;/span&gt; sess.run(g[&lt;span class="st"&gt;&amp;#39;embedding&amp;#39;&lt;/span&gt;], feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{g[&lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;]: noisy_imgs, g[&lt;span class="st"&gt;&amp;#39;stochastic&amp;#39;&lt;/span&gt;]: &lt;span class="va"&gt;False&lt;/span&gt;})
    firing_patterns.append(np.&lt;span class="bu"&gt;sum&lt;/span&gt;(embs, axis&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;0&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For reference, here are the firing patterns for the first three neurons of the first feature:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;firing_patterns[&lt;span class="dv"&gt;0&lt;/span&gt;][:&lt;span class="dv"&gt;3&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;array([[   0.,    0.,    6.,  141.,  130.,   10.,    0.,   13.],
       [   0.,    0.,    5.,    8.,  216.,   64.,    5.,    2.],
       [   0.,   52.,    0.,    1.,    1.,   87.,    0.,  159.]], dtype=float32)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As described above, we use those firing patterns to create prompts. We generate 7 samples for each feature:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;generated_samples &lt;span class="op"&gt;=&lt;/span&gt; []
&lt;span class="cf"&gt;for&lt;/span&gt; feature &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;8&lt;/span&gt;):
    num_common_activations &lt;span class="op"&gt;=&lt;/span&gt; np.&lt;span class="bu"&gt;sum&lt;/span&gt;(firing_patterns[feature] &lt;span class="op"&gt;&amp;gt;&lt;/span&gt; &lt;span class="dv"&gt;250&lt;/span&gt;)
    prompt &lt;span class="op"&gt;=&lt;/span&gt; np.array(&lt;span class="bu"&gt;list&lt;/span&gt;(&lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;640&lt;/span&gt;)))[np.argsort(np.reshape(firing_patterns[feature],
                                                    (&lt;span class="dv"&gt;640&lt;/span&gt;)))[::&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;][:num_common_activations]]
    nums &lt;span class="op"&gt;=&lt;/span&gt; np.sort(np.reshape(firing_patterns[feature], (&lt;span class="dv"&gt;640&lt;/span&gt;)))[::&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;][:num_common_activations]
    den &lt;span class="op"&gt;=&lt;/span&gt; np.&lt;span class="bu"&gt;sum&lt;/span&gt;(nums)
    p &lt;span class="op"&gt;=&lt;/span&gt; nums&lt;span class="op"&gt;/&lt;/span&gt;den
    generated_samples.append([])
    &lt;span class="cf"&gt;for&lt;/span&gt; sample &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;0&lt;/span&gt;, &lt;span class="dv"&gt;7&lt;/span&gt;):
        emb_idx &lt;span class="op"&gt;=&lt;/span&gt; generate_embedding(np.random.choice(prompt,
                            size&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="bu"&gt;max&lt;/span&gt;(&lt;span class="bu"&gt;int&lt;/span&gt;(num_common_activations&lt;span class="op"&gt;*&lt;/span&gt;.&lt;span class="dv"&gt;6&lt;/span&gt;), &lt;span class="bu"&gt;min&lt;/span&gt;(&lt;span class="bu"&gt;int&lt;/span&gt;(num_common_activations), &lt;span class="dv"&gt;5&lt;/span&gt;)),
                                                      replace&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;, p&lt;span class="op"&gt;=&lt;/span&gt;p), &lt;span class="dv"&gt;2&lt;/span&gt;)
        emb &lt;span class="op"&gt;=&lt;/span&gt; emb_idx_to_emb(emb_idx)
        generated_samples[&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;].append(emb)
generated_samples &lt;span class="op"&gt;=&lt;/span&gt; np.squeeze(generated_samples)
generated_samples &lt;span class="op"&gt;=&lt;/span&gt; np.reshape(np.swapaxes(generated_samples, &lt;span class="dv"&gt;0&lt;/span&gt;, &lt;span class="dv"&gt;1&lt;/span&gt;), (&lt;span class="dv"&gt;56&lt;/span&gt;, &lt;span class="dv"&gt;80&lt;/span&gt;, &lt;span class="dv"&gt;8&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;projs &lt;span class="op"&gt;=&lt;/span&gt; sess.run(g[&lt;span class="st"&gt;&amp;#39;projection&amp;#39;&lt;/span&gt;], feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{g[&lt;span class="st"&gt;&amp;#39;embedding&amp;#39;&lt;/span&gt;]: generated_samples, g[&lt;span class="st"&gt;&amp;#39;stochastic&amp;#39;&lt;/span&gt;]: &lt;span class="va"&gt;False&lt;/span&gt;})
plot_nxn(&lt;span class="dv"&gt;8&lt;/span&gt;, np.concatenate((np.squeeze(features), projs)))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/DEE_output_60_0.png" alt="png" /&gt;&lt;figcaption&gt;png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;The original features are shown in the top row, and the samples generated based on that feature are shown below.&lt;/p&gt;
&lt;p&gt;Although most generated samples have the feature we wanted, many do not, and for some features, there is not much diversity in the samples (they seem to be biased towards a single digit, whereas multiple digits might contain the desired feature). We might consider a few techniques to improve the results:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;First, we can make the feature more fuzzy—instead of just adding noise, we can also randomly shift and scale it, so as to capture a more diverse set of neuron activations, and create more diverse samples.&lt;/li&gt;
&lt;li&gt;Second, we might think that instead of sampling neuron activations, we can obtain the networks “confidence” in each neuron activation (e.g., the real number from the softmax activation, before it is turned into a one-hot vector); this might give a better sense of the importance of each neuron activation.&lt;/li&gt;
&lt;li&gt;Third, we might take more care in designing our RNN generator (e.g., actually validate it’s performance, and not just use our first random guess at a workable architecture/hyperparameters).&lt;/li&gt;
&lt;li&gt;Finally, I note that our autoencoder could not be much simpler than it already is. If we had multiple convolutional and deconvolutional layers in both the encoding and decoding sections, I suspect that generated samples would contain the feature in much more abstract and diverse ways.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Below, we’ll see how we can take advantage of memory to create better prompt and improve the generation results.&lt;/p&gt;
&lt;h2 id="part-iii-structured-information-retrieval-using-discrete-embeddings"&gt;Part III: Structured information retrieval using discrete embeddings&lt;/h2&gt;
&lt;p&gt;Now we get to the most interesting part of our little journey. As we noted above, using discrete embeddings to represent data is very much like using a language, which means that everything we know and love above searching for language applies to searching for embeddings.&lt;/p&gt;
&lt;p&gt;We proceed as follows:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;We’ll do a crash course on search, and comment on the relations between search, classification and generation.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;We’ll take a look at the how the memory of the MemNN architecture uses a cosine distance-like measure to achieve impressive results.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;We’ll take a look at the effectiveness of cosine distance-based retrieval of individual MNIST digits. This will help develop an intuition for why cosine distance-based retrieval is effective for MemNNs. We’ll also see how we can use our memory to improve the feature-based generator we made above.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Finally, we’ll get to the point: we’ll look at the effectiveness (or lack thereof) of cosine distance-based retrieval over sequences of MNIST digits, and consider the challenges that sequences of memories pose for cosine distance-based retrieval. This is key, because an agent that cannot deal with sequences is a mere function approximator, not an intelligent actor. We’ll show how retrieval over the explicit embedding space is able to effectively deal with sequences, where cosine distance-based retrieval fails.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="a-crash-course-on-search"&gt;A crash course on search&lt;/h3&gt;
&lt;p&gt;I recently had the pleasure of reading the textbook &lt;a href="http://www.ir.uwaterloo.ca/book/"&gt;Information Retrieval: Implementing and Evaluating Search Engines&lt;/a&gt; by Stefan Büttcher, Charles L. A. Clarke, and Gordon V. Cormack, which this section is heavily based upon. This is a gem among textbooks, up there with great math books like Axler’s Linear Algebra Done Right and Abbott’s Understanding Analysis, and was my inspiration for thinking about discrete embeddings. It’s not short, but it’s a page turner, and I highly recommend it.&lt;/p&gt;
&lt;p&gt;To some extent, we all understand search, because we use it every day. A search engine takes some words (the &lt;em&gt;query&lt;/em&gt;), and finds the documents that contain them. The key data structure used in search is the &lt;a href="https://en.wikipedia.org/wiki/Inverted_index"&gt;&lt;em&gt;Inverted Index&lt;/em&gt;&lt;/a&gt;, which you can consider as a hash table that maps each word to its &lt;em&gt;postings&lt;/em&gt; list. The &lt;em&gt;postings&lt;/em&gt; of a word contain all the positions that the word appears in a document collection. For example, the postings for the word “deconstruction” might look something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;deconstruction&amp;quot;:
    &amp;lt;document: 23, positions: 1, 55 ... 1554&amp;gt;,
    &amp;lt;document: 45, positions: 6, 8&amp;gt;,
    ...,
    &amp;lt;document: 2442, positions: 52&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;where each document, and each position within a document has been given a number. Postings are a &lt;em&gt;sorted&lt;/em&gt; list of those documents and positions. Because they are sorted, postings lists can be merged efficiently during query evaluation, so that we can iterate over the postings to find which documents in our collection contain multiple terms, or, if doing a phrase search, find those documents containing the phrase being searched. In addition to the postings list, most search engines also store some global information about the words and documents themselves, including:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;total documents indexed&lt;/li&gt;
&lt;li&gt;the length of each document&lt;/li&gt;
&lt;li&gt;the frequency of each word within a document (usually included in the postings list itself)&lt;/li&gt;
&lt;li&gt;number of documents in the collection&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Using the above information, search engines can efficiently score each document in the collection according to some scoring function of the document and the query, and return the top results. Scoring functions often treat both the query and the document as a &lt;em&gt;bag of words&lt;/em&gt;, which ignores proximity, order and other relationships between the terms (i.e., each term is treated as independent). Using the &lt;em&gt;bag of words&lt;/em&gt; assumption, we can model each query or document as a &lt;em&gt;term vector&lt;/em&gt; of length |V|, where |V| is the size of our vocabulary. Given the 5-term vocabulary, &lt;span class="math inline"&gt;\(\{t_1, t_2 ... t_5\}\)&lt;/span&gt;, the document or query &lt;span class="math inline"&gt;\(\{t_1, t_2, t_1, t_4\}\)&lt;/span&gt; might have the vector &lt;span class="math inline"&gt;\([2, 1, 0, 1, 0]\)&lt;/span&gt;. Scoring functions in the bag of words paradigm can be expressed in the following form (equation 5.16 from Büttcher et al.):&lt;/p&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[\text{score}(q, d) = \text{quality}(d) + \sum_{t \in q}\text{score}(t, d)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;where q, d, and t refer to a query, document, and term, respectively. An example of a quality function is Google’s &lt;a href="https://en.wikipedia.org/wiki/PageRank"&gt;PageRank&lt;/a&gt; algorithm. In our MNIST example, the quality of an example might be some measure of how characteristic of the dataset a digit is (e.g., how “clean” the digit is). This quality rating is independent of the query. The &lt;span class="math inline"&gt;\(\text{score}(t, d)\)&lt;/span&gt; function in the second term can usually be dissected into the following form:&lt;/p&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[\text{score}(t, d) = TF \cdot IDF\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;where TF is the &lt;em&gt;term frequency&lt;/em&gt; of t in document d, and IDF is t’s &lt;em&gt;inverse document frequency&lt;/em&gt;. Term frequency is a measure (function) of how often the query term appears in a document, and inverse document frequency is a measure of how frequent the term is across all documents. The IDF term appears because, intuitively, if a term is very common across all documents (low IDF), we don’t want it to contribute a lot to the score. Vice versa if the term is very rare across all documents (high IDF)—we want it to contribute a lot to the score if it shows up in a document. IDF usually takes on a “standard form” (equation 2.13 of Büttcher et al.):&lt;/p&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[IDF = \log(N/N_t).\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Let us take a moment to appreciate that summing TF-IDF scores is actually very similar to taking the cosine similarity of the query’s term vector and document’s term vector, given that each vector is adjusted appropriately. Starting with the vector consisting of the count of each term in the query, adjust it by multiplying each entry by the IDF for that term. Starting with the vector consisting of the count of each term in the document, adjust it by the length of the document (i.e., normalize the vector). If we now take their dot product and adjust by the query length, we obtain the cosine similarity between our IDF-adjusted query vector and the document vector. When ranking results, we don’t care about the scores themselves, and only the order, and thus the final step of adjusting the dot product by the query length is unnecessary. Thus, &lt;em&gt;bag of words&lt;/em&gt; scoring models are closely related to cosine distance. Below, we’ll do a visual demonstration of the effectiveness of cosine distance, and adjusted cosine distance (a la TF-IDF), for retrieving relevant memories.&lt;/p&gt;
&lt;p&gt;The above said, it is important to recognize that not all TF-IDF methods can be easily cast to cosine similarity: in particular, the TF component is usually taken as a function of the term frequency, rather than a simple count thereof, resulting in more complex search methods.&lt;/p&gt;
&lt;h3 id="search-vs-classification-and-the-relationship-between-search-and-generation"&gt;Search vs classification, and the relationship between search and generation&lt;/h3&gt;
&lt;p&gt;Search and classification are closely related: whereas classification takes and instance and places it in a category, search takes a category and finds instances in that category. A key point to note here is that information needs during search can be incredibly diverse: whereas classification usually involves only a handful of relevant categories, the number of potential queries in a search is limitless. I like to think of search as &lt;code&gt;post-classification&lt;/code&gt;: We define a category &lt;em&gt;ex-post&lt;/em&gt; (after the fact), and then find examples of that category that are stored in our memory.&lt;/p&gt;
&lt;p&gt;If we think about the way humans search and classify, we note that classification usually occurs at the high levels of abstraction with little subtlety (categories in italics):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;This is a &lt;em&gt;pen&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;The sky is &lt;em&gt;blue&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Boy, was that [thing] &lt;em&gt;cool&lt;/em&gt;!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;On the contrary, when we search our memory (or generate hypotheticals and new ideas) the details become very important:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;That reminds of the time that X, Y, and Z happened, because of A, B, C.&lt;/li&gt;
&lt;li&gt;We could differentiate our product by adding [some specific detail].&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In order for our networks / agents to do the latter, we require them to operate and reason over individual &lt;em&gt;features&lt;/em&gt; or details. I call this &lt;em&gt;deconstruction&lt;/em&gt;, in order to connect it to what humans do (this is related to, but different from, from the more mainstream ML concepts of &lt;em&gt;feature learning&lt;/em&gt; and &lt;em&gt;learned representations&lt;/em&gt;). Humans are very good at calling out explicit details, and this is the point of this post: to give our networks explicit representations that they can operate over.&lt;/p&gt;
&lt;p&gt;Note that generation and memory are very closely related, in that their outcomes are often interchangeable. If we need to come up with an example of something, we often search our memories first, before trying to generate one. We can even go a step further, and say that all of our human memories are “generated”, not remembered—consider what would happen if we overtrained the RNN in Part II above to the point where it “memorized the training set”.&lt;/p&gt;
&lt;p&gt;It will be useful to have a specific example of external memory that is not MNIST, so let us now consider now the MemNN. We’ll examine how its external memory works, and how it might be replaced by an external generator to accomplish similar ends.&lt;/p&gt;
&lt;h3 id="an-introduction-to-memnns"&gt;An Introduction to MemNNs&lt;/h3&gt;
&lt;p&gt;The MemNN, introduced by &lt;a href="https://arxiv.org/abs/1410.3916"&gt;Weston et al. (2014)&lt;/a&gt; and expanded upon in &lt;a href="https://arxiv.org/abs/1502.05698"&gt;Weston et al. (2015)&lt;/a&gt;, is a very basic, memory-augmented neural network that has been proven effective on a variety of question-answering tasks. For our purposes, it will be sufficient to look specifically at the type of task it was used to solve, how the external memory module enabled this, and how we could extend its capabilities by using a memory-generation (mem-gen) module. Below is a description of the most basic MemNN presented in Weston et al. (2014) as it relates to the above—a full description of the architecture is presented in Weston et al. (2014), and improvements thereon, in Weston et al. (2015).&lt;/p&gt;
&lt;p&gt;An example of the basic QA task, and the MemNN’s responses (in CAPS), is shown below (this is a reproduction of Figure 1 from Weston et al. (2014)):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Joe went to the kitchen.
Fred went to the kitchen.
Joe picked up the milk.
Joe travelled to the office.
Joe left the milk.
Joe went to the bathroom.

Where is the milk now?
    OFFICE
Where is Joe?
    BATHROOM
Where was Joe before the office?
    KITCHEN&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Isn’t that awesome? The MemNN is able to answer these questions by (1) retrieving relevant memories (&lt;em&gt;retrieval&lt;/em&gt;), (2) using the retrieved memories together with the input to generate a response (&lt;em&gt;response&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;Each memory of the MemNN is stored as a bag of words representation of a &lt;em&gt;sequence&lt;/em&gt; of text. In the above example, each sentence is such a sequence (“Joe went to the kitchen”). The bag of words representation is as described above in “A crash course on search”: a sparse vector, with a 1 in the indices corresponding to “Joe”, “went”, “to”, “the”, and “kitchen”. Weston et al. also provide a method for dealing with arbitrarily long sequences of text: they propose a “segmenter” to divide long sequences into smaller units (e.g., sentences), and then use the bag of words representations of those sub-sequences as inputs and memories.&lt;/p&gt;
&lt;p&gt;The inputs to the MemNN have the same bag of words representation. Memories are retrieved one-by-one, where earlier memories retrieved impact the search for later memories. A memory is retrieved based on the input (if it is a question) and any previously retrieved memories by:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;Embedding the input into a real-valued vector, &lt;span class="math inline"&gt;\(x\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;Embedding any previously retrieved memories into a real-valued vector, &lt;span class="math inline"&gt;\(m\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;Embedding the each candidate memory, &lt;span class="math inline"&gt;\(i\)&lt;/span&gt;, into a real-valued vector, &lt;span class="math inline"&gt;\(c_i\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;Retrieving the candidate memory whose embedded vector, &lt;span class="math inline"&gt;\(c_i\)&lt;/span&gt;, gives the highest dot product with the vector &lt;span class="math inline"&gt;\(x + m\)&lt;/span&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The embeddings used in Steps 1, 2 and 3 are all different. Step 4 is like taking the cosine similarity (without normalizing for length) between the embeddings of the model’s current concious representation (its query), and each potential memory. The resulting retrieval model is reminscent of the basic TF-IDF retrieval model presented above: we are doing something similar to cosine distance over the bag of words vectors, except that we first adjust the vectors appropriately (by the embeddings (cf. adjustment by IDF above)); in both cases we do not normalize our vectors. The beauty of this retrieval model is that the MemNN can learn effective embeddings for querying and retrieval.&lt;/p&gt;
&lt;p&gt;To bring generation back into the picture, let us consider two more questions about the above story:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Can Joe pick up the milk?
Can Fred pick up the milk?&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Both questions ask about a hypothetical situation. A memory and a generated sample actually serve the same function here: if the MemNN can retrieve an example of Joe/Fred picking up the milk, then it can answer yes; but if it cannot, a high probability generated example will suffice. Thus, we might think of augmenting our architectures with an external generator (and perhaps a paired discriminator to determine the plausibility of generated samples), in addition to an external memory. This would expand the MemNN’s capabilities and allow it to answer hypothetical questions. As noted, these two modules would be complementary, and the memory module would often provide useful information for use during generation.&lt;/p&gt;
&lt;h3 id="retrieval-of-individual-mnist-digits"&gt;Retrieval of Individual MNIST Digits&lt;/h3&gt;
&lt;p&gt;In this part, we’ll show how cosine distance-based retrieval fairs on MNIST digits, which will provide some visual intuitions for why cosine distance-based retrieval works for MemNNs, and in general. We’ll also get to see, visually, the interchangeability of generation and retrieval, and demonstrate the use of memory to improve generation.&lt;/p&gt;
&lt;p&gt;Below, we’ll use numpy to do exhaustive nearest neighbors search using cosine distance over the MNIST training set. We’ll do experiments on both the original input space (784 pixel vectors) and the explicit embedding space (640 sparse binary vectors). We’ll use the same distinctive 7 we used above when generated by prototype.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;normalized_mnist &lt;span class="op"&gt;=&lt;/span&gt; mnist.train.images &lt;span class="op"&gt;/&lt;/span&gt; np.linalg.norm(mnist.train.images, axis&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;, keepdims&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)
nns &lt;span class="op"&gt;=&lt;/span&gt; np.argsort(np.dot(normalized_mnist, mnist.test.images[&lt;span class="dv"&gt;80&lt;/span&gt;]))[::&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;][:&lt;span class="dv"&gt;9&lt;/span&gt;] &lt;span class="co"&gt;# 9 nearest neighbors to first validation image&lt;/span&gt;
res &lt;span class="op"&gt;=&lt;/span&gt; np.array([mnist.test.images[&lt;span class="dv"&gt;80&lt;/span&gt;]] &lt;span class="op"&gt;+&lt;/span&gt; [mnist.train.images[i] &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; nns])
plot_mxn(&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;10&lt;/span&gt;, res)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/DEE_output_66_0.png" alt="png" /&gt;&lt;figcaption&gt;png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;The first image above is the query, and the next 9 are the nearest neighbors from the training set (in order), measured by cosine distance over the 784-pixel input space.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;explicit_mnist &lt;span class="op"&gt;=&lt;/span&gt; []
&lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;550&lt;/span&gt;):
    imgs &lt;span class="op"&gt;=&lt;/span&gt; sess.run(g[&lt;span class="st"&gt;&amp;#39;embedding&amp;#39;&lt;/span&gt;], feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{g[&lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;]: mnist.train.images[i&lt;span class="op"&gt;*&lt;/span&gt;&lt;span class="dv"&gt;100&lt;/span&gt;:(i&lt;span class="op"&gt;+&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;)&lt;span class="op"&gt;*&lt;/span&gt;&lt;span class="dv"&gt;100&lt;/span&gt;], g[&lt;span class="st"&gt;&amp;#39;stochastic&amp;#39;&lt;/span&gt;]: &lt;span class="va"&gt;False&lt;/span&gt;})
    explicit_mnist.append(np.reshape(imgs, (&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="dv"&gt;640&lt;/span&gt;)))
explicit_mnist &lt;span class="op"&gt;=&lt;/span&gt; np.concatenate(explicit_mnist)
normalized_exp_mnist &lt;span class="op"&gt;=&lt;/span&gt; explicit_mnist &lt;span class="op"&gt;/&lt;/span&gt; np.linalg.norm(explicit_mnist, axis&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;, keepdims&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)
query &lt;span class="op"&gt;=&lt;/span&gt; np.reshape(sess.run(g[&lt;span class="st"&gt;&amp;#39;embedding&amp;#39;&lt;/span&gt;], feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{g[&lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;]: mnist.test.images[&lt;span class="dv"&gt;80&lt;/span&gt;:&lt;span class="dv"&gt;81&lt;/span&gt;], g[&lt;span class="st"&gt;&amp;#39;stochastic&amp;#39;&lt;/span&gt;]: &lt;span class="va"&gt;False&lt;/span&gt;}), (&lt;span class="dv"&gt;640&lt;/span&gt;,))

nns &lt;span class="op"&gt;=&lt;/span&gt; np.argsort(np.dot(normalized_exp_mnist, query))[::&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;][:&lt;span class="dv"&gt;9&lt;/span&gt;] &lt;span class="co"&gt;# 9 nearest neighbors to first validation image&lt;/span&gt;
res &lt;span class="op"&gt;=&lt;/span&gt; np.array([mnist.test.images[&lt;span class="dv"&gt;80&lt;/span&gt;]] &lt;span class="op"&gt;+&lt;/span&gt; [mnist.train.images[i] &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; nns])
plot_mxn(&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;10&lt;/span&gt;, res)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/DEE_output_68_0.png" alt="png" /&gt;&lt;figcaption&gt;png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;The first image above is the query, and the next 9 are the nearest neighbors from the training set (in order), measured by cosine distance over the 640-dimensional explicit embedding space.&lt;/p&gt;
&lt;p&gt;We might also see if we can improve this result by modifying our query vector. Our retrieval will no longer be strict cosine distance, but rather cosine distance-based, like the TF-IDF and MemNN retrieval methods described above.&lt;/p&gt;
&lt;p&gt;We adjust our query vector by multiplying each dimension by its “IDF” (the logarithm of the ratio of the number of training samples to the frequency of that dimension in the training set):&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;embs &lt;span class="op"&gt;=&lt;/span&gt;  np.reshape(explicit_mnist, (&lt;span class="dv"&gt;55000&lt;/span&gt;, &lt;span class="dv"&gt;80&lt;/span&gt;, &lt;span class="dv"&gt;8&lt;/span&gt;))
IDF_vector &lt;span class="op"&gt;=&lt;/span&gt; np.log(&lt;span class="dv"&gt;55000&lt;/span&gt; &lt;span class="op"&gt;/&lt;/span&gt; (np.reshape(np.&lt;span class="bu"&gt;sum&lt;/span&gt;(embs, axis&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;0&lt;/span&gt;), (&lt;span class="dv"&gt;640&lt;/span&gt;)) &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;))
query &lt;span class="op"&gt;=&lt;/span&gt; np.reshape(sess.run(g[&lt;span class="st"&gt;&amp;#39;embedding&amp;#39;&lt;/span&gt;],
                            feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{g[&lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;]: mnist.test.images[&lt;span class="dv"&gt;80&lt;/span&gt;:&lt;span class="dv"&gt;81&lt;/span&gt;], g[&lt;span class="st"&gt;&amp;#39;stochastic&amp;#39;&lt;/span&gt;]: &lt;span class="va"&gt;False&lt;/span&gt;}),
                   (&lt;span class="dv"&gt;640&lt;/span&gt;,)) &lt;span class="op"&gt;*&lt;/span&gt; IDF_vector

nns &lt;span class="op"&gt;=&lt;/span&gt; np.argsort(np.dot(normalized_exp_mnist, query))[::&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;][:&lt;span class="dv"&gt;9&lt;/span&gt;] &lt;span class="co"&gt;# 9 nearest neighbors to first validation image&lt;/span&gt;
res &lt;span class="op"&gt;=&lt;/span&gt; np.array([mnist.test.images[&lt;span class="dv"&gt;80&lt;/span&gt;]] &lt;span class="op"&gt;+&lt;/span&gt; [mnist.train.images[i] &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; nns])
plot_mxn(&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;10&lt;/span&gt;, res)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/DEE_output_70_0.png" alt="png" /&gt;&lt;figcaption&gt;png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;The first image above is the query, and the next 9 are the nearest neighbors from the training set (in order), measured by the cosine distance between the modified query (query vector * the IDF vector) and the embedding of each training sample.&lt;/p&gt;
&lt;p&gt;The results of our modified query are not clearly better or worse, so the most we can conclude from this demonstration is that adjusting our query by the IDF of each feature did not seem to hurt.&lt;/p&gt;
&lt;p&gt;Notice how the practical utility of these nearest neighbors would be similar to the generated samples in the generating by prototype example from Part II.&lt;/p&gt;
&lt;h4 id="retrieval-of-individual-mnist-digits-by-feature"&gt;Retrieval of Individual MNIST Digits by Feature&lt;/h4&gt;
&lt;p&gt;Now let’s do the equivalent of generation based on features, first over the original input space, and then over the explicit embedding space. Take note of how the resulting figures are similar to the figure we produced above when generating samples with these same specific features.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;res &lt;span class="op"&gt;=&lt;/span&gt; [f[&lt;span class="dv"&gt;0&lt;/span&gt;] &lt;span class="cf"&gt;for&lt;/span&gt; f &lt;span class="kw"&gt;in&lt;/span&gt; features]
nns &lt;span class="op"&gt;=&lt;/span&gt; []
&lt;span class="cf"&gt;for&lt;/span&gt; idx &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;8&lt;/span&gt;):
    nns.append(np.argsort(np.dot(normalized_mnist, res[idx]))[::&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;][:&lt;span class="dv"&gt;7&lt;/span&gt;])
nns &lt;span class="op"&gt;=&lt;/span&gt; np.array(nns).T.reshape((&lt;span class="dv"&gt;56&lt;/span&gt;))
&lt;span class="cf"&gt;for&lt;/span&gt; n &lt;span class="kw"&gt;in&lt;/span&gt; nns:
    res.append(mnist.train.images[n])
res &lt;span class="op"&gt;=&lt;/span&gt; np.array(res)
plot_nxn(&lt;span class="dv"&gt;8&lt;/span&gt;, res)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Retrieval by feature over the original input space:&lt;/p&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/DEE_output_73_0.png" alt="png" /&gt;&lt;figcaption&gt;png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;firing_patterns &lt;span class="op"&gt;=&lt;/span&gt; []
&lt;span class="cf"&gt;for&lt;/span&gt; feature &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;8&lt;/span&gt;):
    noisy_imgs &lt;span class="op"&gt;=&lt;/span&gt; get_noisy_imgs(features[feature])
    embs &lt;span class="op"&gt;=&lt;/span&gt; sess.run(g[&lt;span class="st"&gt;&amp;#39;embedding&amp;#39;&lt;/span&gt;], feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{g[&lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;]: noisy_imgs, g[&lt;span class="st"&gt;&amp;#39;stochastic&amp;#39;&lt;/span&gt;]: &lt;span class="va"&gt;False&lt;/span&gt;})
    firing_patterns.append(np.&lt;span class="bu"&gt;sum&lt;/span&gt;(embs, axis&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;0&lt;/span&gt;))

feature_embs &lt;span class="op"&gt;=&lt;/span&gt; np.array(firing_patterns)
feature_embs[feature_embs &lt;span class="op"&gt;&amp;lt;&lt;/span&gt; &lt;span class="dv"&gt;200&lt;/span&gt;] &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="fl"&gt;0.&lt;/span&gt; &lt;span class="co"&gt;# get rid of the random neurons that were firing&lt;/span&gt;
feature_embs &lt;span class="op"&gt;=&lt;/span&gt; feature_embs&lt;span class="op"&gt;*&lt;/span&gt;feature_embs &lt;span class="co"&gt;# amplify the effect of the neurons that fire most often&lt;/span&gt;

feature_embs &lt;span class="op"&gt;=&lt;/span&gt; np.reshape(feature_embs, (&lt;span class="dv"&gt;8&lt;/span&gt;, &lt;span class="dv"&gt;640&lt;/span&gt;)) &lt;span class="op"&gt;*&lt;/span&gt; IDF_vector &lt;span class="co"&gt;# adjust the by activation IDFs&lt;/span&gt;

res &lt;span class="op"&gt;=&lt;/span&gt; [f[&lt;span class="dv"&gt;0&lt;/span&gt;] &lt;span class="cf"&gt;for&lt;/span&gt; f &lt;span class="kw"&gt;in&lt;/span&gt; features]
nns &lt;span class="op"&gt;=&lt;/span&gt; []
&lt;span class="cf"&gt;for&lt;/span&gt; idx &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;8&lt;/span&gt;):
    nns.append(np.argsort(np.dot(normalized_exp_mnist, feature_embs[idx]))[::&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;][:&lt;span class="dv"&gt;7&lt;/span&gt;])
nns &lt;span class="op"&gt;=&lt;/span&gt; np.array(nns).T.reshape((&lt;span class="dv"&gt;56&lt;/span&gt;))
&lt;span class="cf"&gt;for&lt;/span&gt; n &lt;span class="kw"&gt;in&lt;/span&gt; nns:
    res.append(mnist.train.images[n])
res &lt;span class="op"&gt;=&lt;/span&gt; np.array(res)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;plot_nxn(&lt;span class="dv"&gt;8&lt;/span&gt;, res)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Retrieval by feature over the explicit embedding space:&lt;/p&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/DEE_output_76_0.png" alt="png" /&gt;&lt;figcaption&gt;png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h4 id="using-memory-for-generation"&gt;Using memory for generation&lt;/h4&gt;
&lt;p&gt;Now that we have a working memory system, we can use it to demonstrate the interaction of memory and generation. Suppose we want to generate samples from features like we did in Part II. Instead of defining prompts for the features by using noise, we can instead use the activations from the nearest neighbors. This is definition by association (e.g., a unknown word that you can nevertheless guess the meaning of, due to its context).&lt;/p&gt;
&lt;p&gt;We find the 30 nearest neighbors, and subsample their most common activations to define each prompt.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;res &lt;span class="op"&gt;=&lt;/span&gt; [f[&lt;span class="dv"&gt;0&lt;/span&gt;] &lt;span class="cf"&gt;for&lt;/span&gt; f &lt;span class="kw"&gt;in&lt;/span&gt; features]
firing_patterns &lt;span class="op"&gt;=&lt;/span&gt; []
&lt;span class="cf"&gt;for&lt;/span&gt; idx &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;8&lt;/span&gt;):
    nns &lt;span class="op"&gt;=&lt;/span&gt; np.argsort(np.dot(normalized_mnist, res[idx]))[::&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;][:&lt;span class="dv"&gt;30&lt;/span&gt;]
    embs &lt;span class="op"&gt;=&lt;/span&gt; sess.run(g[&lt;span class="st"&gt;&amp;#39;embedding&amp;#39;&lt;/span&gt;], feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{g[&lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;]: [mnist.train.images[n] &lt;span class="cf"&gt;for&lt;/span&gt; n &lt;span class="kw"&gt;in&lt;/span&gt; nns], g[&lt;span class="st"&gt;&amp;#39;stochastic&amp;#39;&lt;/span&gt;]: &lt;span class="va"&gt;False&lt;/span&gt;})
    firing_patterns.append(np.&lt;span class="bu"&gt;sum&lt;/span&gt;(embs, axis&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;0&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;generated_samples &lt;span class="op"&gt;=&lt;/span&gt; []
&lt;span class="cf"&gt;for&lt;/span&gt; feature &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;8&lt;/span&gt;):
    num_common_activations &lt;span class="op"&gt;=&lt;/span&gt; np.&lt;span class="bu"&gt;sum&lt;/span&gt;(firing_patterns[feature] &lt;span class="op"&gt;&amp;gt;&lt;/span&gt; &lt;span class="dv"&gt;18&lt;/span&gt;)
    prompt &lt;span class="op"&gt;=&lt;/span&gt; np.array(&lt;span class="bu"&gt;list&lt;/span&gt;(&lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;640&lt;/span&gt;)))[np.argsort(np.reshape(firing_patterns[feature], (&lt;span class="dv"&gt;640&lt;/span&gt;)))[::&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;][:num_common_activations]]
    nums &lt;span class="op"&gt;=&lt;/span&gt; np.sort(np.reshape(firing_patterns[feature], (&lt;span class="dv"&gt;640&lt;/span&gt;)))[::&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;][:num_common_activations]
    den &lt;span class="op"&gt;=&lt;/span&gt; np.&lt;span class="bu"&gt;sum&lt;/span&gt;(nums)
    p &lt;span class="op"&gt;=&lt;/span&gt; nums&lt;span class="op"&gt;/&lt;/span&gt;den
    generated_samples.append([])
    &lt;span class="cf"&gt;for&lt;/span&gt; sample &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;0&lt;/span&gt;, &lt;span class="dv"&gt;7&lt;/span&gt;):
        emb_idx &lt;span class="op"&gt;=&lt;/span&gt; generate_embedding(np.random.choice(prompt, size&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="bu"&gt;min&lt;/span&gt;(&lt;span class="bu"&gt;int&lt;/span&gt;(num_common_activations&lt;span class="op"&gt;*&lt;/span&gt;.&lt;span class="dv"&gt;8&lt;/span&gt;), &lt;span class="dv"&gt;8&lt;/span&gt;), replace&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;, p&lt;span class="op"&gt;=&lt;/span&gt;p), &lt;span class="dv"&gt;3&lt;/span&gt;)
        emb &lt;span class="op"&gt;=&lt;/span&gt; emb_idx_to_emb(emb_idx)
        generated_samples[&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;].append(emb)
generated_samples &lt;span class="op"&gt;=&lt;/span&gt; np.squeeze(generated_samples)
generated_samples &lt;span class="op"&gt;=&lt;/span&gt; np.reshape(np.swapaxes(generated_samples, &lt;span class="dv"&gt;0&lt;/span&gt;, &lt;span class="dv"&gt;1&lt;/span&gt;), (&lt;span class="dv"&gt;56&lt;/span&gt;, &lt;span class="dv"&gt;80&lt;/span&gt;, &lt;span class="dv"&gt;8&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;projs &lt;span class="op"&gt;=&lt;/span&gt; sess.run(g[&lt;span class="st"&gt;&amp;#39;projection&amp;#39;&lt;/span&gt;], feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{g[&lt;span class="st"&gt;&amp;#39;embedding&amp;#39;&lt;/span&gt;]: generated_samples, g[&lt;span class="st"&gt;&amp;#39;stochastic&amp;#39;&lt;/span&gt;]: &lt;span class="va"&gt;False&lt;/span&gt;})
plot_nxn(&lt;span class="dv"&gt;8&lt;/span&gt;, np.concatenate((np.squeeze(features), projs)))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/DEE_output_80_0.png" alt="png" /&gt;&lt;figcaption&gt;png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;Generation by feature with memory-based feature definitions.&lt;/p&gt;
&lt;p&gt;This approach to defining prompts seems to provide a bit more stability, and diversity, than the noise-based approach above. If you’re familiar with information retrieval, this should remind you of &lt;a href="https://en.wikipedia.org/wiki/Relevance_feedback"&gt;pseudo-relevance feedback&lt;/a&gt;.&lt;/p&gt;
&lt;h4 id="some-takeaways"&gt;Some takeaways&lt;/h4&gt;
&lt;p&gt;There are a few key takeaways from the above discussion:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;First, we visually demonstrated the relationship between generation and memory: the outputs are more or less interchangeable (of course, the digits in memory are of superior quality—though as noted in Part II, the generator has a lot of room for improvement).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Second, we visually demonstrated the power of cosine distance: we can retrieve entire images based on only a fragment, which provides us with a content-addressable memory. We can now see why MemNN’s can work effectively: they only need a small fragment of what they are trying to retrieve from memory in order to retrieve it. The embedding layers that are used before taking the cosine distance can amplify the most relevant parts of the query.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Third, using context provided by memory can result in better definitions when facing the general problem of explicit definition. Even so, the definitions used were still brittle, as several of the samples we generated do not match the desired feature at all.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="enter-sequences-where-cosine-distance-fails"&gt;Enter sequences: where cosine distance fails&lt;/h3&gt;
&lt;p&gt;Although this post has so far dealt with MNIST, a non-sequential dataset of individual digits, what I’m truly interested in is how we deal with sequences or sets. We’ve actually already seen two instances of set-based recall:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The first is the MemNN. If you had been paying close attention to my description of the MemNN above, you may have realized that the basic MemNN architecture I described has no way of answering the sample questions provided. This is because each of the sample questions has a sequential component: Where is the milk &lt;strong&gt;now&lt;/strong&gt;? Where is Joe [&lt;strong&gt;now&lt;/strong&gt;]? Where was Joe &lt;strong&gt;before the office&lt;/strong&gt;? In order for the MemNN to answer questions of this nature, Weston et al. augment the basic architecture with a mechanism for modeling the time of each memory. Their approach is described in Section 3.4 of &lt;a href="https://arxiv.org/abs/1410.3916"&gt;Weston et al. (2015)&lt;/a&gt;. Notably, their approach involves iterating over timestamped memories.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The second is actually feature-based generation and retrieval. If we view each MNIST digit as a sum of its features, then we are actually retrieving a set from a subset thereof.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The recall of sequences and sets is critical for agents that experience time (e.g., RNNs), and also has many practical applications (the most notable being plain old text-based search, where we recall documents based on their words (features)). We’ve seen how cosine distance-based search can be extremely effective for set retrieval, if we have a vector that represents the entire set.&lt;/p&gt;
&lt;p&gt;Cosine distance can also be effective for sequence retrieval, &lt;em&gt;if we have a vector that represents the sequence&lt;/em&gt;. For example, the vectors used by the MemNN as memories and inputs are precisely this: vectors representing an entire sentence (sequence of words). For cosine distance to work on sequences, we not only need a vector that represents the sequence, but it must also represent the temporal features of the sequence that we are interested in (if any). The MemNN sequence vectors use a bag of words model and do not contain any temporal features.&lt;/p&gt;
&lt;p&gt;Consider the following toy retrieval tasks:&lt;/p&gt;
&lt;p&gt;If we were to write out the entire MNIST training sequence,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;are there any instances of the consecutive digits “5134” in the sequence, and if so, where?&lt;/li&gt;
&lt;li&gt;how many times does the digit “6” appear within four digits of the digit “3”?&lt;/li&gt;
&lt;li&gt;are there any strings of ten digits that contain all features in some given set of sub-digit features?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For an agent that works only with vector-based memories and cosine distance-based retrieval, all three are quite difficult.&lt;/p&gt;
&lt;p&gt;If we index each digit as a separate memory, all involve multiple queries. For example, in the first instance we would have to (1) retrieve the positions of &lt;em&gt;all&lt;/em&gt; 5s in memory, and (2) filter out the 5s that are not followed by a 1 and a 3, which requires us to either retrieve the positions of all 1s and 3s, or examine the digits following each 5. The second and third tasks are even more difficult.&lt;/p&gt;
&lt;p&gt;If instead we index sequences of digits, we run into a few problems:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;How do we represent sequences in memory? Bag of words (adding individual vectors) might work for problems that ignore order and temporal structure, but will fail for any problem that does not. Use a sequence autoencoder is one solution, but it is fraught with ambiguity and may not contain the necessary information to properly execute the query. How could we design a sequence vector that contains the information required for the second and third tasks above, in addition to other such questions?&lt;/li&gt;
&lt;li&gt;How do we represent the query as a vector? We already ran into some trouble with this when trying to represent small features as entire vectors of discrete embeddings: we ended up simulating a bunch of noisy sets and then finding the most important activations across all simulations. This did OK, but was unprincipled and had lackluster results.&lt;/li&gt;
&lt;li&gt;What length of sequence do we want to index? It is impractical to index all sequence lengths, so we need to make an &lt;em&gt;ex ante&lt;/em&gt; choice. This runs counter to our idea of search as &lt;em&gt;ex post&lt;/em&gt; classification.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These are hard problems, so let us table cosine distance, and instead take a look at what I call &lt;strong&gt;structured information retrieval&lt;/strong&gt;, which, with a little bit of work, we can make work with our discrete embeddings.&lt;/p&gt;
&lt;h3 id="structured-information-retrieval"&gt;Structured information retrieval&lt;/h3&gt;
&lt;p&gt;When you do a phrase search on Google, i.e., a search with “double quotes”, you are doing structured information retrieval. Cosine distance is still in the picture, but it is no longer the critical ingredient: phrase search requires us to first identity all documents that contain the phrase. Recall that query terms are stored in an inverted index together with their postings. The phrase search algorithm operates on the postings list and find all instances of a phrase, without ever needing to retrieve an entire document. You can see the details of the phrase search algorithm in Section 2.1.1 of Büttcher et al..&lt;/p&gt;
&lt;p&gt;Phrase search is just one example of a more general class of constraint-based queries that define a structure on a set of terms. Within this class of queries, we can include Boolean search, passage retrieval, and more general query languages that allow users to define lightweight structure such as “find sentences containing terms X and Y” or the third task above (see Section 5.2 of Büttcher et al. for a detailed discussion).&lt;/p&gt;
&lt;p&gt;Structured information retrieval cannot be done with cosine distance: it requires access to the postings list of each query term. With real-valued embeddings, there is no principled way to create such an index (or at least, none that I could think of). With one-hot embeddings, however, we have some additional flexibility.&lt;/p&gt;
&lt;p&gt;Below we will take a simple approach to information retrieval over the sequence of the MNIST training images. In particular, we will show how discrete embeddings allow us to solve the following problem:&lt;/p&gt;
&lt;p&gt;Does the ordered sequence of MNIST training images (55000 images) contain any subsequences of four consecutive digits that have the following four features, respectively, and if so, where:&lt;/p&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/DEE_feature_query.png" alt="png" /&gt;&lt;figcaption&gt;png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h3 id="indexing-one-hot-features"&gt;Indexing one-hot features&lt;/h3&gt;
&lt;p&gt;To begin, we need to build our index, which is a dictionary mapping features to a &lt;em&gt;positions&lt;/em&gt; vector. We will treat each dimension of our explicit embedding as a feature (so that there are 640 total features), and we will index the entire MNIST training sequence in order. We also define a functions to find the intersection and union of postings lists, which will allow us to compose postings lists to create postings lists for features.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;embs &lt;span class="op"&gt;=&lt;/span&gt; explicit_mnist.T
postings &lt;span class="op"&gt;=&lt;/span&gt; [&lt;span class="va"&gt;None&lt;/span&gt;] &lt;span class="op"&gt;*&lt;/span&gt; &lt;span class="dv"&gt;640&lt;/span&gt;
&lt;span class="cf"&gt;for&lt;/span&gt; i, positions &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;enumerate&lt;/span&gt;(embs):
    postings[i] &lt;span class="op"&gt;=&lt;/span&gt; np.squeeze(np.argwhere(positions))

&lt;span class="im"&gt;from&lt;/span&gt; itertools &lt;span class="im"&gt;import&lt;/span&gt; chain

&lt;span class="kw"&gt;def&lt;/span&gt; ipostings(idx_list):
    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;Gets the intersection of postings for the activations in idx_list&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    res &lt;span class="op"&gt;=&lt;/span&gt; postings[idx_list[&lt;span class="dv"&gt;0&lt;/span&gt;]]
    &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="bu"&gt;len&lt;/span&gt;(idx_list)):
        res &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;list&lt;/span&gt;(intersect_sorted(res, postings[idx_list[i]]))
    &lt;span class="cf"&gt;return&lt;/span&gt; np.array(res)

&lt;span class="kw"&gt;def&lt;/span&gt; upostings(list_of_postings):
    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;Gets the union of postings&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="cf"&gt;return&lt;/span&gt; np.array(&lt;span class="bu"&gt;sorted&lt;/span&gt;(&lt;span class="bu"&gt;set&lt;/span&gt;(chain.from_iterable(list_of_postings))))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="co"&gt;# positions where the activation 1 is hot&lt;/span&gt;
postings[&lt;span class="dv"&gt;1&lt;/span&gt;]

&lt;span class="op"&gt;&amp;gt;&lt;/span&gt; array([    &lt;span class="dv"&gt;4&lt;/span&gt;,     &lt;span class="dv"&gt;6&lt;/span&gt;,    &lt;span class="dv"&gt;18&lt;/span&gt;, ..., &lt;span class="dv"&gt;54972&lt;/span&gt;, &lt;span class="dv"&gt;54974&lt;/span&gt;, &lt;span class="dv"&gt;54980&lt;/span&gt;])


&lt;span class="co"&gt;# positions where activations 1 and 10 co-occur&lt;/span&gt;
ipostings([&lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="dv"&gt;10&lt;/span&gt;])

&lt;span class="op"&gt;&amp;gt;&lt;/span&gt; array([   &lt;span class="dv"&gt;32&lt;/span&gt;,    &lt;span class="dv"&gt;84&lt;/span&gt;,    &lt;span class="dv"&gt;95&lt;/span&gt;, ..., &lt;span class="dv"&gt;54680&lt;/span&gt;, &lt;span class="dv"&gt;54702&lt;/span&gt;, &lt;span class="dv"&gt;54966&lt;/span&gt;])


&lt;span class="co"&gt;# positions where activations 1 and 5 co-occur (empty, because they are from the same neuron)&lt;/span&gt;
ipostings([&lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="dv"&gt;5&lt;/span&gt;])

&lt;span class="op"&gt;&amp;gt;&lt;/span&gt; array([], dtype&lt;span class="op"&gt;=&lt;/span&gt;float64)


&lt;span class="co"&gt;# positions where activation 1 co-occurs with any of the activations 10, 15, or 23&lt;/span&gt;
upostings((ipostings([&lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="dv"&gt;10&lt;/span&gt;]), ipostings([&lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="dv"&gt;15&lt;/span&gt;]), ipostings([&lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="dv"&gt;23&lt;/span&gt;])))

&lt;span class="op"&gt;&amp;gt;&lt;/span&gt; array([   &lt;span class="dv"&gt;18&lt;/span&gt;,    &lt;span class="dv"&gt;32&lt;/span&gt;,    &lt;span class="dv"&gt;38&lt;/span&gt;, ..., &lt;span class="dv"&gt;54972&lt;/span&gt;, &lt;span class="dv"&gt;54974&lt;/span&gt;, &lt;span class="dv"&gt;54980&lt;/span&gt;])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="finding-consecutive-features"&gt;Finding consecutive features&lt;/h4&gt;
&lt;p&gt;To find subsequences with the desired features, we first identify what those feature are, and then run a phrase search using their postings list. We obtain the feature posting lists by (1) finding the posting list for each group of three activations in the five most common activations for that features, (2) taking their union.&lt;/p&gt;
&lt;p&gt;Our definition of the features is extremely brittle. Here we have even less flexibility than we did when retrieving nearest neighbors or generating samples because we need to use exact definitions. Our process is far from perfect: we use the noise-based approach to produce firing patterns, and then define the feature to be any instance where any combination of 4 such common activations fire together. This no doubt misses a lot of digits that do contain the features, but trial and error shows that using less than the intersection of 4 common activations produces very noisy results (we obtain a lot of matches that do not contain the feature).&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;firing_patterns &lt;span class="op"&gt;=&lt;/span&gt; []
&lt;span class="cf"&gt;for&lt;/span&gt; feature &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;8&lt;/span&gt;):
    noisy_imgs &lt;span class="op"&gt;=&lt;/span&gt; get_noisy_imgs(features[feature])
    embs &lt;span class="op"&gt;=&lt;/span&gt; sess.run(g[&lt;span class="st"&gt;&amp;#39;embedding&amp;#39;&lt;/span&gt;], feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{g[&lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;]: noisy_imgs, g[&lt;span class="st"&gt;&amp;#39;stochastic&amp;#39;&lt;/span&gt;]: &lt;span class="va"&gt;False&lt;/span&gt;})
    firing_patterns.append(np.&lt;span class="bu"&gt;sum&lt;/span&gt;(embs, axis&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;0&lt;/span&gt;))

F1, F2, F3 &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="dv"&gt;3&lt;/span&gt;, &lt;span class="dv"&gt;6&lt;/span&gt; &lt;span class="co"&gt;# the indices of the features that make up our query&lt;/span&gt;

&lt;span class="im"&gt;from&lt;/span&gt; itertools &lt;span class="im"&gt;import&lt;/span&gt; combinations

&lt;span class="co"&gt;# Get the common activations&lt;/span&gt;
neuron_lists &lt;span class="op"&gt;=&lt;/span&gt; []
&lt;span class="cf"&gt;for&lt;/span&gt; feature &lt;span class="kw"&gt;in&lt;/span&gt; [F1, F2, F3]:
    num_common_activations &lt;span class="op"&gt;=&lt;/span&gt; np.&lt;span class="bu"&gt;sum&lt;/span&gt;(firing_patterns[feature] &lt;span class="op"&gt;&amp;gt;&lt;/span&gt; &lt;span class="dv"&gt;260&lt;/span&gt;)
    firing_pattern &lt;span class="op"&gt;=&lt;/span&gt; np.reshape(firing_patterns[feature], (&lt;span class="dv"&gt;640&lt;/span&gt;)).astype(np.int32)
    neuron_lists.append(
        np.array(&lt;span class="bu"&gt;list&lt;/span&gt;(&lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;640&lt;/span&gt;)))[np.argsort(firing_pattern)[::&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;][:&lt;span class="bu"&gt;min&lt;/span&gt;(&lt;span class="dv"&gt;10&lt;/span&gt;, num_common_activations)]]
    )

&lt;span class="co"&gt;# Get intersected postings for each combination of 3 activations in the most common&lt;/span&gt;
combo_lists &lt;span class="op"&gt;=&lt;/span&gt; [&lt;span class="bu"&gt;list&lt;/span&gt;(&lt;span class="bu"&gt;map&lt;/span&gt;(ipostings, combinations(l, &lt;span class="bu"&gt;max&lt;/span&gt;(&lt;span class="bu"&gt;len&lt;/span&gt;(l) &lt;span class="op"&gt;-&lt;/span&gt; &lt;span class="dv"&gt;4&lt;/span&gt;, &lt;span class="dv"&gt;4&lt;/span&gt;)))) &lt;span class="cf"&gt;for&lt;/span&gt; l &lt;span class="kw"&gt;in&lt;/span&gt; neuron_lists]
&lt;span class="co"&gt;# Get the union of the above for each feature&lt;/span&gt;
positions &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;list&lt;/span&gt;(&lt;span class="bu"&gt;map&lt;/span&gt;(upostings, combo_lists))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;Because our data is small, we take a naive approach to phrase search.&lt;/span&gt;
&lt;span class="co"&gt;A more efficient algorithm is presented in Section 2.1.1 of Büttcher et al.&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

res12 &lt;span class="op"&gt;=&lt;/span&gt; [np.concatenate([features[F1], features[F2]])]
res123 &lt;span class="op"&gt;=&lt;/span&gt; [np.concatenate([features[F1], features[F2], features[F3]])]
&lt;span class="cf"&gt;for&lt;/span&gt; p &lt;span class="kw"&gt;in&lt;/span&gt; positions[&lt;span class="dv"&gt;0&lt;/span&gt;]:
    &lt;span class="cf"&gt;if&lt;/span&gt; p&lt;span class="op"&gt;+&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="kw"&gt;in&lt;/span&gt; positions[&lt;span class="dv"&gt;1&lt;/span&gt;]:
        &lt;span class="cf"&gt;if&lt;/span&gt; p&lt;span class="op"&gt;+&lt;/span&gt;&lt;span class="dv"&gt;2&lt;/span&gt; &lt;span class="kw"&gt;in&lt;/span&gt; positions[&lt;span class="dv"&gt;2&lt;/span&gt;]:
            &lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;Full phrase match found in positions&amp;quot;&lt;/span&gt;, p, &lt;span class="st"&gt;&amp;quot;to&amp;quot;&lt;/span&gt;, p&lt;span class="op"&gt;+&lt;/span&gt;&lt;span class="dv"&gt;2&lt;/span&gt;)
            res123.append(mnist.train.images[p:p&lt;span class="op"&gt;+&lt;/span&gt;&lt;span class="dv"&gt;3&lt;/span&gt;])
        res12.append(mnist.train.images[p:p&lt;span class="op"&gt;+&lt;/span&gt;&lt;span class="dv"&gt;2&lt;/span&gt;])
        &lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;Partial phrase match of 1st and 2nd query elements found in positions&amp;quot;&lt;/span&gt;, p, &lt;span class="st"&gt;&amp;quot;to&amp;quot;&lt;/span&gt;, p&lt;span class="op"&gt;+&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;)

res23 &lt;span class="op"&gt;=&lt;/span&gt; [np.concatenate([features[F2], features[F3]])]
&lt;span class="cf"&gt;for&lt;/span&gt; p &lt;span class="kw"&gt;in&lt;/span&gt; positions[&lt;span class="dv"&gt;1&lt;/span&gt;]:
    &lt;span class="cf"&gt;if&lt;/span&gt; p&lt;span class="op"&gt;+&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="kw"&gt;in&lt;/span&gt; positions[&lt;span class="dv"&gt;2&lt;/span&gt;]:
        res23.append(mnist.train.images[p:p&lt;span class="op"&gt;+&lt;/span&gt;&lt;span class="dv"&gt;2&lt;/span&gt;])
        &lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;Partial phrase match of 2nd and 3rd query elements found in positions&amp;quot;&lt;/span&gt;, p, &lt;span class="st"&gt;&amp;quot;to&amp;quot;&lt;/span&gt;, p&lt;span class="op"&gt;+&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Partial phrase match of 1st and 2nd query elements found in positions 1151 to 1152
Partial phrase match of 1st and 2nd query elements found in positions 39054 to 39055
Partial phrase match of 2nd and 3rd query elements found in positions 14294 to 14295
Partial phrase match of 2nd and 3rd query elements found in positions 14436 to 14437
Partial phrase match of 2nd and 3rd query elements found in positions 17310 to 17311
Partial phrase match of 2nd and 3rd query elements found in positions 20984 to 20985
Partial phrase match of 2nd and 3rd query elements found in positions 21198 to 21199
Partial phrase match of 2nd and 3rd query elements found in positions 27052 to 27053
Partial phrase match of 2nd and 3rd query elements found in positions 28786 to 28787
Partial phrase match of 2nd and 3rd query elements found in positions 45352 to 45353
Partial phrase match of 2nd and 3rd query elements found in positions 47446 to 47447
Partial phrase match of 2nd and 3rd query elements found in positions 54635 to 54636&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="matches"&gt;Matches&lt;/h3&gt;
&lt;p&gt;Our approach found no matches for three consecutive features. We did, however, find matches for each pair of consecutive features.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="co"&gt;# There are no matches for all three features&lt;/span&gt;
plot_mxn(&lt;span class="bu"&gt;len&lt;/span&gt;(res123), &lt;span class="dv"&gt;3&lt;/span&gt;, np.concatenate(res123))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/DEE_output_99_0.png" alt="png" /&gt;&lt;figcaption&gt;png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="co"&gt;# There are 2 matches for the first and second features&lt;/span&gt;
plot_mxn(&lt;span class="bu"&gt;len&lt;/span&gt;(res12), &lt;span class="dv"&gt;2&lt;/span&gt;, np.concatenate(res12))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/DEE_output_100_0.png" alt="png" /&gt;&lt;figcaption&gt;png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="co"&gt;# There are several matches for the second and third features&lt;/span&gt;
plot_mxn(&lt;span class="bu"&gt;len&lt;/span&gt;(res23), &lt;span class="dv"&gt;2&lt;/span&gt;, np.concatenate(res23))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/DEE_output_101_0.png" alt="png" /&gt;&lt;figcaption&gt;png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;Given that we can obtain the positions vector for individual features, using other structured information retrieval techniques is as straightforward as using them on text. With relative ease we could answer much more complex queries such as: are there any strings of 10 digits that contain the three features in order?&lt;/p&gt;
&lt;p&gt;At the same time, these abilities are limited by the quality of our positions vectors, which are in turn limited by the quality of our feature definitions.&lt;/p&gt;
&lt;h2 id="further-work"&gt;Further work&lt;/h2&gt;
&lt;p&gt;In this post, we played with discrete embeddings and saw that they can be used in much the same way as language. We also ran into several problems as a result of the basic challenge of language, which is semantic ambiguity: what’s in a definition? As a result of this challenge, I do not think the approach presented in this post is practical in its current form. Nevertheless, I think this is a good direction to be thinking about as we try to make progress toward to Stage III architectures.&lt;/p&gt;
&lt;p&gt;Some of the questions I’m interested in working on going forward are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MNIST is perhaps too simple; are the various tasks we carried out (generation and memory) using discrete embeddings practical for more complex datasets?&lt;/li&gt;
&lt;li&gt;Is there a way to create discrete embeddings with fewer activations, but where each activation is more meaningful, so that feature definitions will be easier?&lt;/li&gt;
&lt;li&gt;Is there a useful distribution that we could enforce on discrete embeddings to make feature definitions easier to work with? Is there someway to enforce, e.g., &lt;a href="https://en.wikipedia.org/wiki/Zipf&amp;#39;s_law"&gt;Zipf’s law&lt;/a&gt; on the definitions of certain landmark features?&lt;/li&gt;
&lt;li&gt;Is there a general method for constructing feature definitions in terms of an explicit embedding that will extend to other use cases?&lt;/li&gt;
&lt;li&gt;One of the key motivations behind the use of a symbolic language is communication. But here, all symbols were created intra-agent: they have meaning only within the agent’s mind (we constructed symbolic definitions of our features by feeding the agent real-valued vectors). How could we design a useful inter-agent model, so that agents could use symbols to communicate?&lt;/li&gt;
&lt;li&gt;How do the methods here relate to GANs and VAEs? Can they be combined in a useful way?&lt;/li&gt;
&lt;li&gt;Is there a good way to define a feature discriminator (i.e., to decide whether something is an instance of a feature or not (remember, it has only 1 sample of the feature to learn from)).&lt;/li&gt;
&lt;li&gt;Indexing discrete features requires that representations remain static. Is there a good way to reindex past features so that we can overcome this limitation?&lt;/li&gt;
&lt;li&gt;Is there a way we can take advantage of the distribution of the softmax activations in the embedding layer (before we turn it into a one-hot vector)? For instance, to give us a measure of our network’s confidence in its final predictions, or the quality of the discrete embeddings?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And also two specific questions about particular architectures:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Would adding an external generator to the MemNN increase the range of tasks it can solve? (E.g., to QA about hypothetical scenarios).&lt;/li&gt;
&lt;li&gt;Can we create discrete embeddings of word vectors that behave like word2vec, and perhaps offer some of the advantages of discrete embeddings? Cf. &lt;a href="https://arxiv.org/abs/1506.02004"&gt;Faruqui et al. (2015)&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;If this is something you’re interested in exploring yourself, my planned starting point is this &lt;a href="http://blog.otoro.net/2016/04/01/generating-large-images-from-latent-vectors/"&gt;post&lt;/a&gt; by &lt;a href="https://github.com/hardmaru"&gt;hardmaru&lt;/a&gt; (and the underlying &lt;a href="https://github.com/hardmaru/cppn-gan-vae-tensorflow"&gt;implementation&lt;/a&gt;), which uses a Tensorflow-based VAE-GAN to turn MNIST into something quite beautiful.&lt;a href="#fnref1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
&lt;/body&gt;
&lt;/html&gt;
</content></entry><entry><title>Beyond Binary: Ternary and One-hot Neurons</title><link href="https://r2rt.com/beyond-binary-ternary-and-one-hot-neurons.html" rel="alternate"></link><published>2017-02-08T00:00:00-05:00</published><updated>2017-02-08T00:00:00-05:00</updated><author><name>Silviu Pitis</name></author><id>tag:r2rt.com,2017-02-08:/beyond-binary-ternary-and-one-hot-neurons.html</id><summary type="html">While playing with some applications of binary neurons, I found myself wanting to use explicit activations that go beyond a simple yes/no decision. For example, we might want our neural network to make a choice between several categories (in the form of a one-hot vector) or we might want it to make a choice between ordered categories (e.g., a scale of 1 to 10). It's rather easy to extend the straight-through estimator to work well on both of these cases, and I thought I would share my work in this post. I share code for implementing ternary and one-hot neurons in Tensorflow, and show that they can learn to solve MNIST.</summary><content type="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;meta name="generator" content="pandoc"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes"&gt;
  &lt;title&gt;&lt;/title&gt;
  &lt;style type="text/css"&gt;code{white-space: pre;}&lt;/style&gt;
  &lt;style type="text/css"&gt;
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code &gt; span.kw { color: #007020; font-weight: bold; } /* Keyword */
code &gt; span.dt { color: #902000; } /* DataType */
code &gt; span.dv { color: #40a070; } /* DecVal */
code &gt; span.bn { color: #40a070; } /* BaseN */
code &gt; span.fl { color: #40a070; } /* Float */
code &gt; span.ch { color: #4070a0; } /* Char */
code &gt; span.st { color: #4070a0; } /* String */
code &gt; span.co { color: #60a0b0; font-style: italic; } /* Comment */
code &gt; span.ot { color: #007020; } /* Other */
code &gt; span.al { color: #ff0000; font-weight: bold; } /* Alert */
code &gt; span.fu { color: #06287e; } /* Function */
code &gt; span.er { color: #ff0000; font-weight: bold; } /* Error */
code &gt; span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code &gt; span.cn { color: #880000; } /* Constant */
code &gt; span.sc { color: #4070a0; } /* SpecialChar */
code &gt; span.vs { color: #4070a0; } /* VerbatimString */
code &gt; span.ss { color: #bb6688; } /* SpecialString */
code &gt; span.im { } /* Import */
code &gt; span.va { color: #19177c; } /* Variable */
code &gt; span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code &gt; span.op { color: #666666; } /* Operator */
code &gt; span.bu { } /* BuiltIn */
code &gt; span.ex { } /* Extension */
code &gt; span.pp { color: #bc7a00; } /* Preprocessor */
code &gt; span.at { color: #7d9029; } /* Attribute */
code &gt; span.do { color: #ba2121; font-style: italic; } /* Documentation */
code &gt; span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code &gt; span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code &gt; span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  &lt;/style&gt;
  &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"&gt;&lt;/script&gt;
  &lt;!--[if lt IE 9]&gt;
    &lt;script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"&gt;&lt;/script&gt;
  &lt;![endif]--&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;While playing with some applications of binary neurons, I found myself wanting to use explicit activations that go beyond a simple yes/no decision. For example, we might want our neural network to make a choice between several categories (in the form of a one-hot vector) or we might want it to make a choice between ordered categories (e.g., a scale of 1 to 10). It’s rather easy to extend the straight-through estimator to work well on both of these cases, and I thought I would share my work in this post. I share code for implementing ternary and one-hot neurons in Tensorflow, and show that they can learn to solve MNIST.&lt;/p&gt;
&lt;p&gt;This is a follow-up post to &lt;a href="http://r2rt.com/binary-stochastic-neurons-in-tensorflow.html"&gt;Binary Stochastic Neurons in Tensorflow&lt;/a&gt;, and assumes familiarity with binary neurons and the straight-through estimator discussed therein.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note Feb. 8, 2017&lt;/strong&gt;: I haven’t had a chance to read either of these two papers that I came across after writing this post (they look like they are related to the straight-through softmax activation (I think the first offers up an even better estimator… to be decided)):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://arxiv.org/abs/1611.01144"&gt;Categorical Reparameterization with Gumbel-Softmax&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://arxiv.org/abs/1611.00712"&gt;The Concrete Distribution: A Continuous Relaxation of Discrete Random Variables&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I plan to update this post once I get around to reading them.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IPython Notebook&lt;/strong&gt;: This post is also available as an IPython notebook &lt;a href="https://gist.github.com/spitis/4d600aa019a5689953b1b61a8ddb074d"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="general-n-ary-neurons"&gt;General n-ary neurons&lt;/h2&gt;
&lt;p&gt;Whereas the binary neuron outputs 0 or 1, a ternary neuron might output -1, 0, or 1 (or alternatively, 0, 1 or 2). Similarly, we could create an arbitrary n-ary neuron that outputs ordered categories, such as a scale from 1 to 10. Actually, but for the activation function, the code for all of these neurons is the same as the code for the binary neuron: we either round the real output of the activation function to the nearest integer (deterministic), or use its decimal portion to sample either the integer below or the integer above from a bernoulli distribution (stochastic). Note that this means stochastic choices are made only between two adjacent categories, and never across all categories. On the backward pass, we use the straight-through estimator, which means that we replace the gradient of rounding (deterministic) or sampling (stochastic) with the identity. If our activation function is threshholded to [0, 1], this results in a binary neuron, but if it is threshholded to [-1,1], we can output three ordered values.&lt;/p&gt;
&lt;p&gt;We might be tempted to use tanh, which is threshholded to [-1, 1], to create ternary neurons. Picking the right activation, however, is a bit trickier than finding a function that has the correct range. The standard tanh is not very good here because its slope near 0 is close to 1, so that a neuron outputting 0 will tend to get pushed away from 0. Instead, we want something that looks like a soft set of stairs (where each step is a sigmoid), so that the neuron can learn to consistently output intermediate values.&lt;/p&gt;
&lt;p&gt;With such an activation, a neuron outputting 0 will have a small slope on the backward pass, so that many mistakes (in the same direction) will be required to move it towards 1 or -1.&lt;/p&gt;
&lt;p&gt;For the ternary case, the following function works well:&lt;/p&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[f(x) = 1.5\tanh(x) + 0.5\tanh(-3x).\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Here is its plot drawn by Wolfram Alpha:&lt;/p&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/BB_ternary_activation.png" alt="Ternary activation function" /&gt;&lt;figcaption&gt;Ternary activation function&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;This activation function works well because its slope goes to 0 as it approaches each of the integers in the output range (note that the binary neuron has this property too). Here’s the plot of the derivative for reference:&lt;/p&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/BB_ternary_derivative.png" alt="Ternary activation derivative" /&gt;&lt;figcaption&gt;Ternary activation derivative&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;The above ternary function is implemented below. I’ve been more interested in the one-hot activations, so I haven’t figured out how to make slope annealing work for this ternary neuron, or a general formula for n-ary neurons. If the mathematically-inclined reader would like to leave some ideas in the comments, that would be much appreciated.&lt;/p&gt;
&lt;h2 id="one-hot-neurons"&gt;One-hot neurons&lt;/h2&gt;
&lt;p&gt;N-ary neurons are cool, but restrictive. Binary neurons are restricted to yes/no decisions, and ternary+ neurons express the prior that the output categories are linearly ordered. As an example to illustrate this “ordering” point, consider the categories “dislike”, “neutral” and “like”. There is a natural order between these categories (“like” is closer to “neutral” than to “dislike”). Most categories, however, do not have a natural ordering. For example, there is no natural order between Boston, New York and Toronto. To create a neuron that can decided between unordered categories, we would like it to output a one-hot vector like [1, 0, 0] (Boston) or [0, 0, 1] (Toronto). Luckily, the straight through estimator extends nicely to this scenario.&lt;/p&gt;
&lt;p&gt;We define a d-dimensional one-hot neuron, &lt;span class="math inline"&gt;\(N_d: \mathbb{R}^n \to \mathbb{R}^d\)&lt;/span&gt; as follows. Given an input, &lt;span class="math inline"&gt;\(x \in \mathbb{R}^n\)&lt;/span&gt;, we perform the following steps:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;Compute a d-dimensional vector of logits, &lt;span class="math inline"&gt;\(z = Wx + b\)&lt;/span&gt;, where &lt;span class="math inline"&gt;\(W \in \mathbb{R}^{n \times d}\)&lt;/span&gt; and &lt;span class="math inline"&gt;\(b \in \mathbb{R}^d\)&lt;/span&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Compute softmax activations, &lt;span class="math inline"&gt;\(\hat{y} = \text{softmax}_\tau(z)\)&lt;/span&gt;, whose &lt;span class="math inline"&gt;\(i\)&lt;/span&gt;-th component is&lt;/p&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[\hat{y}_i = \frac{\exp(z_i /\tau)}{\sum_{k=1}^d \exp(z_k / \tau)}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;where &lt;span class="math inline"&gt;\(z_i\)&lt;/span&gt; is the &lt;span class="math inline"&gt;\(i\)&lt;/span&gt;-th component of &lt;span class="math inline"&gt;\(z\)&lt;/span&gt;, and &lt;span class="math inline"&gt;\(\tau \in (0, \infty)\)&lt;/span&gt; is the temperature (used for annealing).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Next, we either sample a one-hot vector according to the distribution defined by &lt;span class="math inline"&gt;\(\hat{y}\)&lt;/span&gt; (stochastic), or simply use the maximum value of &lt;span class="math inline"&gt;\(\hat{y}\)&lt;/span&gt; to determine the one-hot output (deterministic). The result is the output of our neuron, &lt;span class="math inline"&gt;\(y\)&lt;/span&gt;. A formal definition of both of these operations is a bit too ugly for this blog post, but this should be fairly straightforward.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Neither sampling from nor using the maximum of &lt;span class="math inline"&gt;\(\hat{y}\)&lt;/span&gt; have useful (non-zero) gradients. But we can use the straight-through estimator and replace their gradient on the backward pass with the identity. As in the binary case, this leads to a learnable softmax activation.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This definition of one-hot neurons allows for temperature-annealing to be used (note that whereas slope is increased during annealing, temperature is decreased during annealing), which we test below.&lt;/p&gt;
&lt;h2 id="implementation-in-tensorflow"&gt;Implementation in Tensorflow&lt;/h2&gt;
&lt;h4 id="imports-and-helper-functions"&gt;Imports and helper functions&lt;/h4&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="im"&gt;import&lt;/span&gt; numpy &lt;span class="im"&gt;as&lt;/span&gt; np, tensorflow &lt;span class="im"&gt;as&lt;/span&gt; tf, matplotlib.pyplot &lt;span class="im"&gt;as&lt;/span&gt; plt, seaborn &lt;span class="im"&gt;as&lt;/span&gt; sns
&lt;span class="im"&gt;from&lt;/span&gt; tensorflow.examples.tutorials.mnist &lt;span class="im"&gt;import&lt;/span&gt; input_data
&lt;span class="op"&gt;%&lt;/span&gt;matplotlib inline
sns.&lt;span class="bu"&gt;set&lt;/span&gt;(color_codes&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)
mnist &lt;span class="op"&gt;=&lt;/span&gt; input_data.read_data_sets(&lt;span class="st"&gt;&amp;#39;MNIST_data&amp;#39;&lt;/span&gt;, one_hot&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)
&lt;span class="im"&gt;from&lt;/span&gt; tensorflow.python.framework &lt;span class="im"&gt;import&lt;/span&gt; ops
&lt;span class="im"&gt;from&lt;/span&gt; collections &lt;span class="im"&gt;import&lt;/span&gt; Counter

&lt;span class="kw"&gt;def&lt;/span&gt; reset_graph():
    &lt;span class="cf"&gt;if&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;sess&amp;#39;&lt;/span&gt; &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;globals&lt;/span&gt;() &lt;span class="kw"&gt;and&lt;/span&gt; sess:
        sess.close()
    tf.reset_default_graph()

&lt;span class="kw"&gt;def&lt;/span&gt; layer_linear(inputs, shape, scope&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;linear_layer&amp;#39;&lt;/span&gt;):
    &lt;span class="cf"&gt;with&lt;/span&gt; tf.variable_scope(scope):
        w &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;w&amp;#39;&lt;/span&gt;,shape)
        b &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;,shape[&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;:])
    &lt;span class="cf"&gt;return&lt;/span&gt; tf.matmul(inputs,w) &lt;span class="op"&gt;+&lt;/span&gt; b

&lt;span class="kw"&gt;def&lt;/span&gt; layer_softmax(inputs, shape, scope&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;softmax_layer&amp;#39;&lt;/span&gt;):
    &lt;span class="cf"&gt;with&lt;/span&gt; tf.variable_scope(scope):
        w &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;w&amp;#39;&lt;/span&gt;,shape)
        b &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;,shape[&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;:])
    &lt;span class="cf"&gt;return&lt;/span&gt; tf.nn.softmax(tf.matmul(inputs,w) &lt;span class="op"&gt;+&lt;/span&gt; b)

&lt;span class="kw"&gt;def&lt;/span&gt; compute_accuracy(y, pred):
    correct &lt;span class="op"&gt;=&lt;/span&gt; tf.equal(tf.argmax(y,&lt;span class="dv"&gt;1&lt;/span&gt;), tf.argmax(pred,&lt;span class="dv"&gt;1&lt;/span&gt;))
    &lt;span class="cf"&gt;return&lt;/span&gt; tf.reduce_mean(tf.cast(correct, tf.float32))

&lt;span class="kw"&gt;def&lt;/span&gt; plot_n(data_and_labels, lower_y &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="fl"&gt;0.&lt;/span&gt;, title&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;Learning Curves&amp;quot;&lt;/span&gt;):
    fig, ax &lt;span class="op"&gt;=&lt;/span&gt; plt.subplots()
    &lt;span class="cf"&gt;for&lt;/span&gt; data, label &lt;span class="kw"&gt;in&lt;/span&gt; data_and_labels:
        ax.plot(&lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="bu"&gt;len&lt;/span&gt;(data)&lt;span class="op"&gt;*&lt;/span&gt;&lt;span class="dv"&gt;100&lt;/span&gt;,&lt;span class="dv"&gt;100&lt;/span&gt;),data, label&lt;span class="op"&gt;=&lt;/span&gt;label)
    ax.set_xlabel(&lt;span class="st"&gt;&amp;#39;Training steps&amp;#39;&lt;/span&gt;)
    ax.set_ylabel(&lt;span class="st"&gt;&amp;#39;Accuracy&amp;#39;&lt;/span&gt;)
    ax.set_ylim([lower_y,&lt;span class="dv"&gt;1&lt;/span&gt;])
    ax.set_title(title)
    ax.legend(loc&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;4&lt;/span&gt;)
    plt.show()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="functions-for-ternary-and-n-ary-neurons"&gt;Functions for ternary and n-ary neurons&lt;/h4&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; st_round(x):
    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;Rounds a tensor using the straight through estimator for the gradient.&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    g &lt;span class="op"&gt;=&lt;/span&gt; tf.get_default_graph()

    &lt;span class="cf"&gt;with&lt;/span&gt; ops.name_scope(&lt;span class="st"&gt;&amp;quot;StRound&amp;quot;&lt;/span&gt;) &lt;span class="im"&gt;as&lt;/span&gt; name:
        &lt;span class="cf"&gt;with&lt;/span&gt; g.gradient_override_map({&lt;span class="st"&gt;&amp;quot;Round&amp;quot;&lt;/span&gt;: &lt;span class="st"&gt;&amp;quot;Identity&amp;quot;&lt;/span&gt;}):
            &lt;span class="cf"&gt;return&lt;/span&gt; tf.&lt;span class="bu"&gt;round&lt;/span&gt;(x, name&lt;span class="op"&gt;=&lt;/span&gt;name)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; sample_closest_ints(x):
    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;If x is a float, then samples floor(x) with probability x - floor(x), and ceil(x) with&lt;/span&gt;
&lt;span class="co"&gt;    probability ceil(x) - x, using the straight through estimator for the gradient.&lt;/span&gt;

&lt;span class="co"&gt;    E.g.,:&lt;/span&gt;
&lt;span class="co"&gt;    if x is 0.6, sample_closest_ints(x) will be 1 with probability 0.6, and 0 otherwise,&lt;/span&gt;
&lt;span class="co"&gt;    and the gradient will be pass-through (identity).&lt;/span&gt;
&lt;span class="co"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="cf"&gt;with&lt;/span&gt; ops.name_scope(&lt;span class="st"&gt;&amp;quot;SampleClosestInts&amp;quot;&lt;/span&gt;) &lt;span class="im"&gt;as&lt;/span&gt; name:
        &lt;span class="cf"&gt;with&lt;/span&gt; tf.get_default_graph().gradient_override_map({&lt;span class="st"&gt;&amp;quot;Ceil&amp;quot;&lt;/span&gt;: &lt;span class="st"&gt;&amp;quot;Identity&amp;quot;&lt;/span&gt;,&lt;span class="st"&gt;&amp;quot;Sub&amp;quot;&lt;/span&gt;: &lt;span class="st"&gt;&amp;quot;SampleClosestInts&amp;quot;&lt;/span&gt;}):
            &lt;span class="cf"&gt;return&lt;/span&gt; tf.ceil(x &lt;span class="op"&gt;-&lt;/span&gt; tf.random_uniform(tf.shape(x)), name&lt;span class="op"&gt;=&lt;/span&gt;name)

&lt;span class="at"&gt;@ops.RegisterGradient&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;SampleClosestInts&amp;quot;&lt;/span&gt;)
&lt;span class="kw"&gt;def&lt;/span&gt; sample_closest_ints_grad(op, grad):
    &lt;span class="cf"&gt;return&lt;/span&gt; [grad, tf.zeros(tf.shape(op.inputs[&lt;span class="dv"&gt;1&lt;/span&gt;]))]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; binary_activation(x, slope_tensor):
    &lt;span class="cf"&gt;return&lt;/span&gt; tf.cond(tf.equal(&lt;span class="fl"&gt;1.&lt;/span&gt;, slope_tensor),
                &lt;span class="kw"&gt;lambda&lt;/span&gt;: tf.sigmoid(x),
                &lt;span class="kw"&gt;lambda&lt;/span&gt;: tf.sigmoid(slope_tensor &lt;span class="op"&gt;*&lt;/span&gt; x))

&lt;span class="kw"&gt;def&lt;/span&gt; ternary_activation(x, slope_tensor &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="va"&gt;None&lt;/span&gt;, alpha &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;):
    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="co"&gt;    Does not support slope annealing (slope_tensor is ignored)&lt;/span&gt;
&lt;span class="co"&gt;    Wolfram Alpha plot:&lt;/span&gt;
&lt;span class="co"&gt;    https://www.wolframalpha.com/input/?i=plot+(1.5*tanh(x)+%2B+0.5(tanh(-(3-1e-2)*x))),+x%3D+-2+to+2&lt;/span&gt;
&lt;span class="co"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="cf"&gt;return&lt;/span&gt; &lt;span class="fl"&gt;1.5&lt;/span&gt;&lt;span class="op"&gt;*&lt;/span&gt;tf.tanh(alpha&lt;span class="op"&gt;*&lt;/span&gt;x) &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="fl"&gt;0.5&lt;/span&gt;&lt;span class="op"&gt;*&lt;/span&gt;(tf.tanh(&lt;span class="op"&gt;-&lt;/span&gt;(&lt;span class="dv"&gt;3&lt;/span&gt;&lt;span class="op"&gt;/&lt;/span&gt;alpha)&lt;span class="op"&gt;*&lt;/span&gt;x))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; n_ary_activation(x, activation&lt;span class="op"&gt;=&lt;/span&gt;binary_activation, slope_tensor&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;None&lt;/span&gt;, stochastic_tensor&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;None&lt;/span&gt;):
    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="co"&gt;    n-ary activation for creating binary and ternary neurons (and n-ary neurons, if you can&lt;/span&gt;
&lt;span class="co"&gt;    create the right activation function). Given a tensor and an activation, it applies the&lt;/span&gt;
&lt;span class="co"&gt;    activation to the tensor, and then either samples the results (if stochastic tensor is&lt;/span&gt;
&lt;span class="co"&gt;    true), or rounds the results (if stochastic_tensor is false) to the closest integer&lt;/span&gt;
&lt;span class="co"&gt;    values. The default activation is a sigmoid (when slope_tensor = 1), which results in a&lt;/span&gt;
&lt;span class="co"&gt;    binary neuron, as in http://r2rt.com/binary-stochastic-neurons-in-tensorflow.html.&lt;/span&gt;
&lt;span class="co"&gt;    Uses the straight through estimator during backprop. See https://arxiv.org/abs/1308.3432.&lt;/span&gt;

&lt;span class="co"&gt;    Arguments:&lt;/span&gt;
&lt;span class="co"&gt;    * x: the pre-activation / logit tensor&lt;/span&gt;
&lt;span class="co"&gt;    * activation: sigmoid, hard sigmoid, or n-ary activation&lt;/span&gt;
&lt;span class="co"&gt;    * slope_tensor: slope adjusts the slope of the activation function, for purposes of the&lt;/span&gt;
&lt;span class="co"&gt;        Slope Annealing Trick (see http://arxiv.org/abs/1609.01704)&lt;/span&gt;
&lt;span class="co"&gt;    * stochastic_tensor: whether to sample the closest integer, or round to it.&lt;/span&gt;
&lt;span class="co"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="cf"&gt;if&lt;/span&gt; slope_tensor &lt;span class="kw"&gt;is&lt;/span&gt; &lt;span class="va"&gt;None&lt;/span&gt;:
        slope_tensor &lt;span class="op"&gt;=&lt;/span&gt; tf.constant(&lt;span class="fl"&gt;1.0&lt;/span&gt;)
    &lt;span class="cf"&gt;if&lt;/span&gt; stochastic_tensor &lt;span class="kw"&gt;is&lt;/span&gt; &lt;span class="va"&gt;None&lt;/span&gt;:
        stochastic_tensor &lt;span class="op"&gt;=&lt;/span&gt; tf.constant(&lt;span class="va"&gt;True&lt;/span&gt;)

    p &lt;span class="op"&gt;=&lt;/span&gt; activation(x, slope_tensor)

    &lt;span class="cf"&gt;return&lt;/span&gt; tf.cond(stochastic_tensor,
        &lt;span class="kw"&gt;lambda&lt;/span&gt;: sample_closest_ints(p),
        &lt;span class="kw"&gt;lambda&lt;/span&gt;: st_round(p))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="functions-to-make-a-layer-of-one-hot-neurons"&gt;Functions to make a layer of one-hot neurons&lt;/h4&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; st_sampled_softmax(logits):
    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;Takes logits and samples a one-hot vector according to them, using the straight&lt;/span&gt;
&lt;span class="co"&gt;    through estimator on the backward pass.&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="cf"&gt;with&lt;/span&gt; ops.name_scope(&lt;span class="st"&gt;&amp;quot;STSampledSoftmax&amp;quot;&lt;/span&gt;) &lt;span class="im"&gt;as&lt;/span&gt; name:
        probs &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.softmax(logits)
        onehot_dims &lt;span class="op"&gt;=&lt;/span&gt; logits.get_shape().as_list()[&lt;span class="dv"&gt;1&lt;/span&gt;]
        res &lt;span class="op"&gt;=&lt;/span&gt; tf.one_hot(tf.squeeze(tf.multinomial(logits, &lt;span class="dv"&gt;1&lt;/span&gt;), &lt;span class="dv"&gt;1&lt;/span&gt;), onehot_dims, &lt;span class="fl"&gt;1.0&lt;/span&gt;, &lt;span class="fl"&gt;0.0&lt;/span&gt;)
        &lt;span class="cf"&gt;with&lt;/span&gt; tf.get_default_graph().gradient_override_map({&lt;span class="st"&gt;&amp;#39;Ceil&amp;#39;&lt;/span&gt;: &lt;span class="st"&gt;&amp;#39;Identity&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;Mul&amp;#39;&lt;/span&gt;: &lt;span class="st"&gt;&amp;#39;STMul&amp;#39;&lt;/span&gt;}):
            &lt;span class="cf"&gt;return&lt;/span&gt; tf.ceil(res&lt;span class="op"&gt;*&lt;/span&gt;probs)

&lt;span class="kw"&gt;def&lt;/span&gt; st_hardmax_softmax(logits):
    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;Takes logits and creates a one-hot vector with a 1 in the position of the maximum&lt;/span&gt;
&lt;span class="co"&gt;    logit, using the straight through estimator on the backward pass.&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="cf"&gt;with&lt;/span&gt; ops.name_scope(&lt;span class="st"&gt;&amp;quot;STHardmaxSoftmax&amp;quot;&lt;/span&gt;) &lt;span class="im"&gt;as&lt;/span&gt; name:
        probs &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.softmax(logits)
        onehot_dims &lt;span class="op"&gt;=&lt;/span&gt; logits.get_shape().as_list()[&lt;span class="dv"&gt;1&lt;/span&gt;]
        res &lt;span class="op"&gt;=&lt;/span&gt; tf.one_hot(tf.argmax(probs, &lt;span class="dv"&gt;1&lt;/span&gt;), onehot_dims, &lt;span class="fl"&gt;1.0&lt;/span&gt;, &lt;span class="fl"&gt;0.0&lt;/span&gt;)
        &lt;span class="cf"&gt;with&lt;/span&gt; tf.get_default_graph().gradient_override_map({&lt;span class="st"&gt;&amp;#39;Ceil&amp;#39;&lt;/span&gt;: &lt;span class="st"&gt;&amp;#39;Identity&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;Mul&amp;#39;&lt;/span&gt;: &lt;span class="st"&gt;&amp;#39;STMul&amp;#39;&lt;/span&gt;}):
            &lt;span class="cf"&gt;return&lt;/span&gt; tf.ceil(res&lt;span class="op"&gt;*&lt;/span&gt;probs)

&lt;span class="at"&gt;@ops.RegisterGradient&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;STMul&amp;quot;&lt;/span&gt;)
&lt;span class="kw"&gt;def&lt;/span&gt; st_mul(op, grad):
    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;Straight-through replacement for Mul gradient (does not support broadcasting).&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="cf"&gt;return&lt;/span&gt; [grad, grad]

&lt;span class="kw"&gt;def&lt;/span&gt; layer_hard_softmax(x, shape, onehot_dims, temperature_tensor&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;None&lt;/span&gt;, stochastic_tensor&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;None&lt;/span&gt;,
                       scope&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;hard_softmax_layer&amp;#39;&lt;/span&gt;):
    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="co"&gt;    Creates a layer of one-hot neurons. Note that the neurons are flattened before returning,&lt;/span&gt;
&lt;span class="co"&gt;    so that the shape of the layer needs to be a multiple of the dimension of the one-hot outputs.&lt;/span&gt;

&lt;span class="co"&gt;    Arguments:&lt;/span&gt;
&lt;span class="co"&gt;    * x: the layer inputs / previous layer&lt;/span&gt;
&lt;span class="co"&gt;    * shape: the tuple of [size_previous, layer_size]. Layer_size must be a multiple of onehot_dims,&lt;/span&gt;
&lt;span class="co"&gt;        since each neuron&amp;#39;s output is flattened (i.e., the number of neurons will only be&lt;/span&gt;
&lt;span class="co"&gt;        layer_size / onehot_dims)&lt;/span&gt;
&lt;span class="co"&gt;    * onehot_dims: the size of each neuron&amp;#39;s output&lt;/span&gt;
&lt;span class="co"&gt;    * temperature_tensor: the temperature for the softmax&lt;/span&gt;
&lt;span class="co"&gt;    * stochastic_tensor: whether the one hot outputs are sampled from the softmax distribution&lt;/span&gt;
&lt;span class="co"&gt;        (stochastic - recommended for training), or chosen according to its maximal element&lt;/span&gt;
&lt;span class="co"&gt;        (deterministic - recommended for inference)&lt;/span&gt;
&lt;span class="co"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="cf"&gt;assert&lt;/span&gt;(&lt;span class="bu"&gt;len&lt;/span&gt;(shape) &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt;)
    &lt;span class="cf"&gt;assert&lt;/span&gt;(shape[&lt;span class="dv"&gt;1&lt;/span&gt;] &lt;span class="op"&gt;%&lt;/span&gt; onehot_dims &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;)
    &lt;span class="cf"&gt;if&lt;/span&gt; temperature_tensor &lt;span class="kw"&gt;is&lt;/span&gt; &lt;span class="va"&gt;None&lt;/span&gt;:
        temperature_tensor &lt;span class="op"&gt;=&lt;/span&gt; tf.constant(&lt;span class="fl"&gt;1.&lt;/span&gt;)
    &lt;span class="cf"&gt;if&lt;/span&gt; stochastic_tensor &lt;span class="kw"&gt;is&lt;/span&gt; &lt;span class="va"&gt;None&lt;/span&gt;:
        stochastic_tensor &lt;span class="op"&gt;=&lt;/span&gt; tf.constant(&lt;span class="va"&gt;True&lt;/span&gt;)

    &lt;span class="cf"&gt;with&lt;/span&gt; tf.variable_scope(scope):
        w &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;w&amp;#39;&lt;/span&gt;,shape)
        b &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;,shape[&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;:])
    logits &lt;span class="op"&gt;=&lt;/span&gt; tf.reshape((tf.matmul(x, w) &lt;span class="op"&gt;+&lt;/span&gt; b) &lt;span class="op"&gt;/&lt;/span&gt; temperature_tensor,
                        [&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;, onehot_dims])

    &lt;span class="cf"&gt;return&lt;/span&gt; tf.cond(stochastic_tensor,
                &lt;span class="kw"&gt;lambda&lt;/span&gt;: tf.reshape(st_sampled_softmax(logits), [&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;, shape[&lt;span class="dv"&gt;1&lt;/span&gt;]]),
                &lt;span class="kw"&gt;lambda&lt;/span&gt;: tf.reshape(st_hardmax_softmax(logits), [&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;, shape[&lt;span class="dv"&gt;1&lt;/span&gt;]]))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="function-to-build-graph-for-mnist-classifier"&gt;Function to build graph for MNIST classifier&lt;/h4&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; build_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;100&lt;/span&gt;],
                     lr &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="fl"&gt;0.5&lt;/span&gt;,
                     activation&lt;span class="op"&gt;=&lt;/span&gt;binary_activation,
                     onehot_dims &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;):
    reset_graph()

    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;Placeholders&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    x &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(tf.float32, [&lt;span class="va"&gt;None&lt;/span&gt;, &lt;span class="dv"&gt;784&lt;/span&gt;], name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;x_placeholder&amp;#39;&lt;/span&gt;)
    y &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(tf.float32, [&lt;span class="va"&gt;None&lt;/span&gt;, &lt;span class="dv"&gt;10&lt;/span&gt;], name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;y_placeholder&amp;#39;&lt;/span&gt;)
    stochastic_tensor &lt;span class="op"&gt;=&lt;/span&gt; tf.constant(&lt;span class="va"&gt;True&lt;/span&gt;)
    slope_tensor &lt;span class="op"&gt;=&lt;/span&gt; tf.constant(&lt;span class="fl"&gt;1.0&lt;/span&gt;)
    temperature_tensor &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="op"&gt;/&lt;/span&gt; slope_tensor

    layers &lt;span class="op"&gt;=&lt;/span&gt; {&lt;span class="dv"&gt;0&lt;/span&gt;: x}
    num_hidden_layers &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;len&lt;/span&gt;(hidden_dims)
    dims &lt;span class="op"&gt;=&lt;/span&gt; [&lt;span class="dv"&gt;784&lt;/span&gt;] &lt;span class="op"&gt;+&lt;/span&gt; hidden_dims

    &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;1&lt;/span&gt;, num_hidden_layers&lt;span class="op"&gt;+&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;):
        &lt;span class="cf"&gt;with&lt;/span&gt; tf.variable_scope(&lt;span class="st"&gt;&amp;quot;layer_&amp;quot;&lt;/span&gt; &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="bu"&gt;str&lt;/span&gt;(i)):
            &lt;span class="cf"&gt;if&lt;/span&gt; onehot_dims:
                layers[i] &lt;span class="op"&gt;=&lt;/span&gt; layer_hard_softmax(layers[i&lt;span class="dv"&gt;-1&lt;/span&gt;],
                                              dims[i&lt;span class="dv"&gt;-1&lt;/span&gt;:i&lt;span class="op"&gt;+&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;],
                                              onehot_dims,
                                              temperature_tensor,
                                              stochastic_tensor)
            &lt;span class="cf"&gt;else&lt;/span&gt;:
                pre_activations &lt;span class="op"&gt;=&lt;/span&gt; layer_linear(layers[i&lt;span class="dv"&gt;-1&lt;/span&gt;], dims[i&lt;span class="dv"&gt;-1&lt;/span&gt;:i&lt;span class="op"&gt;+&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;], scope&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;layer_&amp;#39;&lt;/span&gt; &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="bu"&gt;str&lt;/span&gt;(i))
                &lt;span class="cf"&gt;if&lt;/span&gt; activation &lt;span class="kw"&gt;is&lt;/span&gt; tf.tanh &lt;span class="kw"&gt;or&lt;/span&gt; activation &lt;span class="kw"&gt;is&lt;/span&gt; tf.sigmoid:
                    layers[i] &lt;span class="op"&gt;=&lt;/span&gt; activation(pre_activations)
                &lt;span class="cf"&gt;else&lt;/span&gt;:
                    layers[i] &lt;span class="op"&gt;=&lt;/span&gt; n_ary_activation(pre_activations,
                                               activation,
                                               slope_tensor,
                                               stochastic_tensor)

    final_hidden_layer &lt;span class="op"&gt;=&lt;/span&gt; layers[num_hidden_layers]
    preds &lt;span class="op"&gt;=&lt;/span&gt; layer_softmax(final_hidden_layer, [dims[&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;], &lt;span class="dv"&gt;10&lt;/span&gt;])
    loss &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="op"&gt;-&lt;/span&gt;tf.reduce_mean(y &lt;span class="op"&gt;*&lt;/span&gt; tf.log(preds), reduction_indices&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;)
    ts &lt;span class="op"&gt;=&lt;/span&gt; tf.train.GradientDescentOptimizer(lr).minimize(loss)

    accuracy &lt;span class="op"&gt;=&lt;/span&gt; compute_accuracy(y, preds)

    &lt;span class="cf"&gt;return&lt;/span&gt; &lt;span class="bu"&gt;dict&lt;/span&gt;(
        x&lt;span class="op"&gt;=&lt;/span&gt;x,
        y&lt;span class="op"&gt;=&lt;/span&gt;y,
        stochastic&lt;span class="op"&gt;=&lt;/span&gt;stochastic_tensor,
        slope&lt;span class="op"&gt;=&lt;/span&gt;slope_tensor,
        final_hidden_layer &lt;span class="op"&gt;=&lt;/span&gt; final_hidden_layer,
        loss&lt;span class="op"&gt;=&lt;/span&gt;loss,
        ts&lt;span class="op"&gt;=&lt;/span&gt;ts,
        accuracy&lt;span class="op"&gt;=&lt;/span&gt;accuracy,
        init_op&lt;span class="op"&gt;=&lt;/span&gt;tf.global_variables_initializer()
    )&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="function-to-train-the-classifier"&gt;Function to train the classifier&lt;/h4&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; train_classifier(&lt;span class="op"&gt;\&lt;/span&gt;
        hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;100&lt;/span&gt;,&lt;span class="dv"&gt;100&lt;/span&gt;],
        activation&lt;span class="op"&gt;=&lt;/span&gt;binary_activation,
        onehot_dims &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;,
        stochastic_train&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;,
        stochastic_eval&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;,
        slope_annealing_rate&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;None&lt;/span&gt;,
        epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;20&lt;/span&gt;,
        lr&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.5&lt;/span&gt;,
        verbose&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;,
        label&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;None&lt;/span&gt;):
    g &lt;span class="op"&gt;=&lt;/span&gt; build_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;hidden_dims, lr&lt;span class="op"&gt;=&lt;/span&gt;lr,
        activation&lt;span class="op"&gt;=&lt;/span&gt;activation, onehot_dims&lt;span class="op"&gt;=&lt;/span&gt;onehot_dims)

    &lt;span class="cf"&gt;with&lt;/span&gt; tf.Session() &lt;span class="im"&gt;as&lt;/span&gt; sess:
        sess.run(g[&lt;span class="st"&gt;&amp;#39;init_op&amp;#39;&lt;/span&gt;])
        slope &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;
        res_tr, res_val, sample_layers &lt;span class="op"&gt;=&lt;/span&gt; [], [], []
        &lt;span class="cf"&gt;for&lt;/span&gt; epoch &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(epochs):
            feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{g[&lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;]: mnist.validation.images,
                       g[&lt;span class="st"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;]: mnist.validation.labels,
                       g[&lt;span class="st"&gt;&amp;#39;stochastic&amp;#39;&lt;/span&gt;]: stochastic_eval,
                       g[&lt;span class="st"&gt;&amp;#39;slope&amp;#39;&lt;/span&gt;]: slope}
            acc, final_hidden &lt;span class="op"&gt;=&lt;/span&gt; sess.run([g[&lt;span class="st"&gt;&amp;#39;accuracy&amp;#39;&lt;/span&gt;], g[&lt;span class="st"&gt;&amp;#39;final_hidden_layer&amp;#39;&lt;/span&gt;]],
                                            feed_dict&lt;span class="op"&gt;=&lt;/span&gt;feed_dict)
            sample_layers.append(final_hidden)
            &lt;span class="cf"&gt;if&lt;/span&gt; verbose:
                &lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;Epoch&amp;quot;&lt;/span&gt;, epoch, acc)
            &lt;span class="cf"&gt;else&lt;/span&gt;:
                &lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;#39;.&amp;#39;&lt;/span&gt;, end&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;)

            accuracy &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;
            &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;1001&lt;/span&gt;):
                x, y &lt;span class="op"&gt;=&lt;/span&gt; mnist.train.next_batch(&lt;span class="dv"&gt;50&lt;/span&gt;)
                feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{g[&lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;]: x, g[&lt;span class="st"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;]: y, g[&lt;span class="st"&gt;&amp;#39;stochastic&amp;#39;&lt;/span&gt;]: stochastic_train}
                acc, _ &lt;span class="op"&gt;=&lt;/span&gt; sess.run([g[&lt;span class="st"&gt;&amp;#39;accuracy&amp;#39;&lt;/span&gt;],g[&lt;span class="st"&gt;&amp;#39;ts&amp;#39;&lt;/span&gt;]], feed_dict&lt;span class="op"&gt;=&lt;/span&gt;feed_dict)
                accuracy &lt;span class="op"&gt;+=&lt;/span&gt; acc
                &lt;span class="cf"&gt;if&lt;/span&gt; i &lt;span class="op"&gt;%&lt;/span&gt; &lt;span class="dv"&gt;100&lt;/span&gt; &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt; &lt;span class="kw"&gt;and&lt;/span&gt; i &lt;span class="op"&gt;&amp;gt;&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;:
                    res_tr.append(accuracy&lt;span class="op"&gt;/&lt;/span&gt;&lt;span class="dv"&gt;100&lt;/span&gt;)
                    accuracy &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;
                    feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{g[&lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;]: mnist.validation.images,
                               g[&lt;span class="st"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;]: mnist.validation.labels,
                               g[&lt;span class="st"&gt;&amp;#39;stochastic&amp;#39;&lt;/span&gt;]: stochastic_eval,
                               g[&lt;span class="st"&gt;&amp;#39;slope&amp;#39;&lt;/span&gt;]: slope}
                    res_val.append(sess.run(g[&lt;span class="st"&gt;&amp;#39;accuracy&amp;#39;&lt;/span&gt;], feed_dict&lt;span class="op"&gt;=&lt;/span&gt;feed_dict))

            &lt;span class="cf"&gt;if&lt;/span&gt; slope_annealing_rate &lt;span class="kw"&gt;is&lt;/span&gt; &lt;span class="kw"&gt;not&lt;/span&gt; &lt;span class="va"&gt;None&lt;/span&gt;:
                slope &lt;span class="op"&gt;=&lt;/span&gt; slope&lt;span class="op"&gt;*&lt;/span&gt;slope_annealing_rate
                &lt;span class="cf"&gt;if&lt;/span&gt; verbose:
                    &lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;Annealed slope:&amp;quot;&lt;/span&gt;, slope, &lt;span class="st"&gt;&amp;quot;| Annealed temperature:&amp;quot;&lt;/span&gt;, &lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="op"&gt;/&lt;/span&gt; slope)

        feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{g[&lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;]: mnist.validation.images, g[&lt;span class="st"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;]: mnist.validation.labels,
                   g[&lt;span class="st"&gt;&amp;#39;stochastic&amp;#39;&lt;/span&gt;]: stochastic_eval, g[&lt;span class="st"&gt;&amp;#39;slope&amp;#39;&lt;/span&gt;]: slope}
        &lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;&lt;span class="ch"&gt;\n&lt;/span&gt;&lt;span class="st"&gt;Final epoch, epoch&amp;quot;&lt;/span&gt;, epoch&lt;span class="op"&gt;+&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;:&amp;quot;&lt;/span&gt;, sess.run(g[&lt;span class="st"&gt;&amp;#39;accuracy&amp;#39;&lt;/span&gt;], feed_dict&lt;span class="op"&gt;=&lt;/span&gt;feed_dict))

        &lt;span class="cf"&gt;if&lt;/span&gt; label &lt;span class="kw"&gt;is&lt;/span&gt; &lt;span class="kw"&gt;not&lt;/span&gt; &lt;span class="va"&gt;None&lt;/span&gt;:
            &lt;span class="cf"&gt;return&lt;/span&gt; (res_tr, label &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="st"&gt;&amp;quot; - Training&amp;quot;&lt;/span&gt;), (res_val, label &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="st"&gt;&amp;quot; - Validation&amp;quot;&lt;/span&gt;)
        &lt;span class="cf"&gt;else&lt;/span&gt;:
            &lt;span class="cf"&gt;return&lt;/span&gt; [(res_tr, &lt;span class="st"&gt;&amp;quot;Training&amp;quot;&lt;/span&gt;), (res_val, &lt;span class="st"&gt;&amp;quot;Validation&amp;quot;&lt;/span&gt;)], sample_layers&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="experiments"&gt;Experiments&lt;/h3&gt;
&lt;p&gt;Let us now demonstrate that the above neurons train on MNIST, and can achieve reasonably good results. I’m not hunting for hyperparameters here, so the below may not be optimal. All training is done over 20 epochs with a learning rate of 0.1.&lt;/p&gt;
&lt;h4 id="tanh-baseline-real-valued-activations"&gt;Tanh baseline (real-valued activations)&lt;/h4&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;res, _ &lt;span class="op"&gt;=&lt;/span&gt; train_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;100&lt;/span&gt;], activation&lt;span class="op"&gt;=&lt;/span&gt;tf.tanh, epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;20&lt;/span&gt;, lr&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.1&lt;/span&gt;, verbose&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;)
plot_n(res, lower_y&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.8&lt;/span&gt;, title&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;Tanh Baseline&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;....................
Final epoch, epoch 20 : 0.9772&lt;/code&gt;&lt;/pre&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/BB_output_21_1.png" alt="png" /&gt;&lt;figcaption&gt;png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h4 id="binary-neurons-with-slope-annealing-baseline"&gt;Binary neurons with slope annealing baseline&lt;/h4&gt;
&lt;p&gt;More results on binary neurons available in my prior &lt;a href="http://r2rt.com/binary-stochastic-neurons-in-tensorflow.html"&gt;post&lt;/a&gt;.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;res, _ &lt;span class="op"&gt;=&lt;/span&gt; train_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;100&lt;/span&gt;], activation&lt;span class="op"&gt;=&lt;/span&gt;binary_activation, epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;20&lt;/span&gt;, lr&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.1&lt;/span&gt;,
                                      slope_annealing_rate&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;1.1&lt;/span&gt;, stochastic_eval&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;, verbose&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;)
plot_n(res, lower_y&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.8&lt;/span&gt;, title&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;Binary Stochastic w/ Slope Annealing Baseline&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;....................
Final epoch, epoch 20 : 0.9732&lt;/code&gt;&lt;/pre&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/BB_output_23_1.png" alt="png" /&gt;&lt;figcaption&gt;png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h4 id="ternary-neurons"&gt;Ternary neurons&lt;/h4&gt;
&lt;p&gt;As noted above, I didn’t spend the time to figure out a good way to slope-anneal the ternary activation, so the below is not slope-annealed.&lt;/p&gt;
&lt;p&gt;The interesting thing to note is that these neurons are more expressive than the binary neurons, and so they not only get closer to the tanh baseline, but they also offer less regularization / overfit more quickly.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;res, sample_layers &lt;span class="op"&gt;=&lt;/span&gt; train_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;100&lt;/span&gt;], activation&lt;span class="op"&gt;=&lt;/span&gt;ternary_activation, epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;20&lt;/span&gt;, lr&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.1&lt;/span&gt;,
                                      stochastic_eval&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;, verbose&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;)
plot_n(res, lower_y&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.8&lt;/span&gt;, title&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;Ternary Stochastic&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;....................
Final epoch, epoch 20 : 0.9764&lt;/code&gt;&lt;/pre&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/BB_output_26_1.png" alt="png" /&gt;&lt;figcaption&gt;png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;If you’re curious as to the distribution of outputs, here it is:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;c &lt;span class="op"&gt;=&lt;/span&gt; Counter(np.reshape(sample_layers[&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;], [&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;]))
g &lt;span class="op"&gt;=&lt;/span&gt; sns.barplot(x &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;list&lt;/span&gt;(c.keys()), y &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;list&lt;/span&gt;(c.values()))
sns.plt.title(&lt;span class="st"&gt;&amp;#39;Distribution of ternary outputs on MNIST&amp;#39;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/BB_output_28_1.png" alt="png" /&gt;&lt;figcaption&gt;png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h4 id="one-hot-neurons-1"&gt;One-hot neurons&lt;/h4&gt;
&lt;p&gt;First, let’s take a look at what the layer activations look like, in case my description above wasn’t super clear. We’ll pull out the last layer of a network that uses 100 5-dimensional one-hot neurons, and then “unflatten” it into shape [100, 5].&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;res, sample_layers &lt;span class="op"&gt;=&lt;/span&gt; train_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;500&lt;/span&gt;], onehot_dims&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;5&lt;/span&gt;, epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;20&lt;/span&gt;, lr&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.1&lt;/span&gt;,
                                      stochastic_eval&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;, verbose&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;....................
Final epoch, epoch 20 : 0.9794&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here is what the activations of the first 10 neurons of the first sample in the validation set look like. As discussed, each neuron outputs a 5D one-hot vector:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;np.reshape(sample_layers[&lt;span class="dv"&gt;0&lt;/span&gt;][&lt;span class="dv"&gt;0&lt;/span&gt;], [&lt;span class="dv"&gt;100&lt;/span&gt;, &lt;span class="dv"&gt;5&lt;/span&gt;])[:&lt;span class="dv"&gt;10&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;array([[ 0.,  0.,  0.,  0.,  1.],
       [ 0.,  1.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  1.,  0.],
       [ 0.,  0.,  1.,  0.,  0.],
       [ 1.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  1.,  0.,  0.],
       [ 0.,  0.,  1.,  0.,  0.],
       [ 0.,  1.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  1.,  0.],
       [ 0.,  1.,  0.,  0.,  0.]], dtype=float32)&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="one-hot-neurons-temperature-annealing"&gt;One-hot neurons: temperature annealing&lt;/h4&gt;
&lt;p&gt;Now, let’s test some 5D neurons to see if temperature annealing does anything. Looks like not really:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;_, res1 &lt;span class="op"&gt;=&lt;/span&gt; train_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;500&lt;/span&gt;], onehot_dims&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;5&lt;/span&gt;, epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;20&lt;/span&gt;, lr&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.1&lt;/span&gt;,
                                      stochastic_eval&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;,
                                      label&lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;No temperature annealing&amp;quot;&lt;/span&gt;, verbose&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;)
_, res2 &lt;span class="op"&gt;=&lt;/span&gt; train_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;500&lt;/span&gt;], onehot_dims&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;5&lt;/span&gt;, epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;20&lt;/span&gt;, lr&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.1&lt;/span&gt;,
                                      slope_annealing_rate&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;1.2&lt;/span&gt;, stochastic_eval&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;,
                                      label&lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Annealing rate 1.2&amp;quot;&lt;/span&gt;, verbose&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;)
_, res3 &lt;span class="op"&gt;=&lt;/span&gt; train_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;500&lt;/span&gt;], onehot_dims&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;5&lt;/span&gt;, epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;20&lt;/span&gt;, lr&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.1&lt;/span&gt;,
                                      slope_annealing_rate&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;1.5&lt;/span&gt;, stochastic_eval&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;,
                                      label&lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Annealing rate 1.5&amp;quot;&lt;/span&gt;, verbose&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;)
plot_n([res1] &lt;span class="op"&gt;+&lt;/span&gt; [res2] &lt;span class="op"&gt;+&lt;/span&gt; [res3], lower_y&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.8&lt;/span&gt;, title&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;5D one-hot neurons, temperature annealing (validation)&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;....................
Final epoch, epoch 20 : 0.981
....................
Final epoch, epoch 20 : 0.9796
....................
Final epoch, epoch 20 : 0.9798&lt;/code&gt;&lt;/pre&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/BB_output_34_1.png" alt="png" /&gt;&lt;figcaption&gt;png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h4 id="one-hot-neurons-number-of-dimensions"&gt;One-hot neurons: number of dimensions&lt;/h4&gt;
&lt;p&gt;We can also easily change with the number of dimensions of each neuron. I keep the layer size constant in terms of the number of neurons, but make them progressively more expressive and see what happens (because layers are flattened, it appears that the layer size is growing, but the number of neurons stays the same). Looks like not much happens, but maybe this has to do with the simplicity of the dataset. Query whether more expressive one-hot neurons would make a difference on a harder dataset. Note: I plotted the training curves locally, and they show the same result (I would have thought higher dimensional neurons would fit the training data better, but apparently not – perhaps due to stochasticity).&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;_, res1 &lt;span class="op"&gt;=&lt;/span&gt; train_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;300&lt;/span&gt;], onehot_dims&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;3&lt;/span&gt;, epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;20&lt;/span&gt;, lr&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.1&lt;/span&gt;, stochastic_eval&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;,
                                      label&lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;3 dimensions&amp;quot;&lt;/span&gt;, verbose&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;)
_, res2 &lt;span class="op"&gt;=&lt;/span&gt; train_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;500&lt;/span&gt;], onehot_dims&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;5&lt;/span&gt;, epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;20&lt;/span&gt;, lr&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.1&lt;/span&gt;, stochastic_eval&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;,
                                      label&lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;5 dimensions&amp;quot;&lt;/span&gt;, verbose&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;)
_, res3 &lt;span class="op"&gt;=&lt;/span&gt; train_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;700&lt;/span&gt;], onehot_dims&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;7&lt;/span&gt;, epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;20&lt;/span&gt;, lr&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.1&lt;/span&gt;, stochastic_eval&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;,
                                       label&lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;7 dimensions&amp;quot;&lt;/span&gt;, verbose&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;)
_, res4 &lt;span class="op"&gt;=&lt;/span&gt; train_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;1000&lt;/span&gt;], onehot_dims&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;10&lt;/span&gt;, epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;20&lt;/span&gt;, lr&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.1&lt;/span&gt;, stochastic_eval&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;,
                                       label&lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;10 dimensions&amp;quot;&lt;/span&gt;, verbose&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;)
plot_n([res1] &lt;span class="op"&gt;+&lt;/span&gt; [res2] &lt;span class="op"&gt;+&lt;/span&gt; [res3] &lt;span class="op"&gt;+&lt;/span&gt; [res4], lower_y&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.8&lt;/span&gt;, title&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;N-dimensional one-hot neurons&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;....................
Final epoch, epoch 20 : 0.9772
....................
Final epoch, epoch 20 : 0.98
....................
Final epoch, epoch 20 : 0.981
....................
Final epoch, epoch 20 : 0.9754&lt;/code&gt;&lt;/pre&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/BB_output_36_1.png" alt="png" /&gt;&lt;figcaption&gt;png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;That’s it for now! In this post we saw how we can use the straight-through estimator to create expressive trainable explicit neurons. In particular, we coded up neurons that can represent more than 2 ordered categories (the ternary, or general n-ary neuron), and also neurons that can represent 3 or more unordered categories (the one-hot neuron). Moreover, we showed that they are all competitive with a real-valued tanh baseline on MNIST, and that they provide strong built-in regularization.&lt;/p&gt;
&lt;p&gt;I discuss any applications in this post, but I’m hoping to show you something really cool using one-hot neurons in the next one.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</content></entry><entry><title>Non-Zero Initial States for Recurrent Neural Networks</title><link href="https://r2rt.com/non-zero-initial-states-for-recurrent-neural-networks.html" rel="alternate"></link><published>2016-11-20T00:00:00-05:00</published><updated>2016-11-20T00:00:00-05:00</updated><author><name>Silviu Pitis</name></author><id>tag:r2rt.com,2016-11-20:/non-zero-initial-states-for-recurrent-neural-networks.html</id><summary type="html">The default approach to initializing the state of an RNN is to use a zero state. This often works well, particularly for sequence-to-sequence tasks like language modeling where the proportion of outputs that are significantly impacted by the initial state is small. In some cases, however, it makes sense to (1) train the initial state as a model parameter, (2) use a noisy initial state, or (3) both. This post examines the rationale behind trained and noisy intial states briefly, and presents drop-in Tensorflow implementations.</summary><content type="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;meta name="generator" content="pandoc"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes"&gt;
  &lt;title&gt;&lt;/title&gt;
  &lt;style type="text/css"&gt;code{white-space: pre;}&lt;/style&gt;
  &lt;style type="text/css"&gt;
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code &gt; span.kw { color: #007020; font-weight: bold; } /* Keyword */
code &gt; span.dt { color: #902000; } /* DataType */
code &gt; span.dv { color: #40a070; } /* DecVal */
code &gt; span.bn { color: #40a070; } /* BaseN */
code &gt; span.fl { color: #40a070; } /* Float */
code &gt; span.ch { color: #4070a0; } /* Char */
code &gt; span.st { color: #4070a0; } /* String */
code &gt; span.co { color: #60a0b0; font-style: italic; } /* Comment */
code &gt; span.ot { color: #007020; } /* Other */
code &gt; span.al { color: #ff0000; font-weight: bold; } /* Alert */
code &gt; span.fu { color: #06287e; } /* Function */
code &gt; span.er { color: #ff0000; font-weight: bold; } /* Error */
code &gt; span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code &gt; span.cn { color: #880000; } /* Constant */
code &gt; span.sc { color: #4070a0; } /* SpecialChar */
code &gt; span.vs { color: #4070a0; } /* VerbatimString */
code &gt; span.ss { color: #bb6688; } /* SpecialString */
code &gt; span.im { } /* Import */
code &gt; span.va { color: #19177c; } /* Variable */
code &gt; span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code &gt; span.op { color: #666666; } /* Operator */
code &gt; span.bu { } /* BuiltIn */
code &gt; span.ex { } /* Extension */
code &gt; span.pp { color: #bc7a00; } /* Preprocessor */
code &gt; span.at { color: #7d9029; } /* Attribute */
code &gt; span.do { color: #ba2121; font-style: italic; } /* Documentation */
code &gt; span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code &gt; span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code &gt; span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  &lt;/style&gt;
  &lt;!--[if lt IE 9]&gt;
    &lt;script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"&gt;&lt;/script&gt;
  &lt;![endif]--&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;The default approach to initializing the state of an RNN is to use a zero state. This often works well, particularly for sequence-to-sequence tasks like language modeling where the proportion of outputs that are significantly impacted by the initial state is small. In some cases, however, it makes sense to (1) train the initial state as a model parameter, (2) use a noisy initial state, or (3) both. This post examines the rationale behind trained and noisy intial states briefly, and presents drop-in Tensorflow implementations.&lt;/p&gt;
&lt;h3 id="training-the-initial-state"&gt;Training the initial state&lt;/h3&gt;
&lt;p&gt;If there are enough sequences or state resets in the training data (e.g., this will often be the case if we are doing sequence classification), it may make sense to train the initial state as a variable. This way, the model can learn a good default state. If we have only a few state resets, however, training the initial state as a variable may result in overfitting on the start of each sequence. To see this, consider that with n-step truncated backpropagation, only the first n-steps of each sequence will contribute to the gradient of the initial state, so that even if our single training sequence has one million steps, only thirty of them will be used to train the initial state.&lt;/p&gt;
&lt;p&gt;I haven’t seen anyone evaluate this technique (edit 11/22/16: though it appears to be common knowledge), and so I don’t have a good citation for empirical results. Instead, please see the experimental results in this post.&lt;/p&gt;
&lt;h3 id="using-a-noisy-initial-state"&gt;Using a noisy initial state&lt;/h3&gt;
&lt;p&gt;Using a zero-valued initial state can also result in overfitting, though in a different way. Ordinarily, losses at the early steps of a sequence-to-sequence model (i.e., those immediately after a state reset) will be larger than those at later steps, because there is less history. Thus, their contribution to the gradient during learning will be relatively higher. But if all state resets are associated with a zero-state, the model can (and will) learn how to compensate for precisely this. As the ratio of state resets to total observations increases, the model parameters will become increasingly tuned to this zero state, which may affect performance on later time steps.&lt;/p&gt;
&lt;p&gt;One simple solution is to make the initial state noisy. This is the approach suggested by &lt;a href="http://www.scs-europe.net/conf/ecms2015/invited/Contribution_Zimmermann_Grothmann_Tietz.pdf"&gt;Zimmerman et al. (2012)&lt;/a&gt;, who take it even a step further by making the magnitude of the initial state noise change according to the backpropagated error. This post will only take the first step of making the initial state noisy.&lt;/p&gt;
&lt;h2 id="tensorflow-implementations"&gt;Tensorflow implementations&lt;/h2&gt;
&lt;p&gt;In some cases, e.g., as in my post on &lt;a href="https://r2rt.com/recurrent-neural-networks-in-tensorflow-iii-variable-length-sequences.html"&gt;variable length sequences&lt;/a&gt;, creating a variable or noisy initial state to match the cell state is straightforward. However, we often want to switch out the RNN cell or build complicated cells with nested states. My motivation for writing this post was to provide a method like the &lt;code&gt;zero_state&lt;/code&gt; method of Tensorflow’s base RNNCell class that automatically constructs a variable or noisy intitial state.&lt;/p&gt;
&lt;h5 id="implementation-model"&gt;Implementation model&lt;/h5&gt;
&lt;p&gt;We’ll model the implementation after the &lt;code&gt;zero_state&lt;/code&gt; method of Tensorflow’s base RNNCell class, shown below with minor modifications to make it a top-level function. You can view the original &lt;code&gt;zero_state&lt;/code&gt; method &lt;a href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/ops/rnn_cell.py"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="im"&gt;import&lt;/span&gt; numpy &lt;span class="im"&gt;as&lt;/span&gt; np, tensorflow &lt;span class="im"&gt;as&lt;/span&gt; tf
&lt;span class="im"&gt;from&lt;/span&gt; tensorflow.python.util &lt;span class="im"&gt;import&lt;/span&gt; nest
_state_size_with_prefix &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.rnn_cell._state_size_with_prefix

&lt;span class="kw"&gt;def&lt;/span&gt; zero_state(cell, batch_size, dtype):
    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;Return zero-filled state tensor(s).&lt;/span&gt;
&lt;span class="co"&gt;    Args:&lt;/span&gt;
&lt;span class="co"&gt;      cell: RNNCell.&lt;/span&gt;
&lt;span class="co"&gt;      batch_size: int, float, or unit Tensor representing the batch size.&lt;/span&gt;
&lt;span class="co"&gt;      dtype: the data type to use for the state.&lt;/span&gt;
&lt;span class="co"&gt;    Returns:&lt;/span&gt;
&lt;span class="co"&gt;      If `state_size` is an int or TensorShape, then the return value is a&lt;/span&gt;
&lt;span class="co"&gt;      `N-D` tensor of shape `[batch_size x state_size]` filled with zeros.&lt;/span&gt;
&lt;span class="co"&gt;      If `state_size` is a nested list or tuple, then the return value is&lt;/span&gt;
&lt;span class="co"&gt;      a nested list or tuple (of the same structure) of `2-D` tensors with&lt;/span&gt;
&lt;span class="co"&gt;    the shapes `[batch_size x s]` for each s in `state_size`.&lt;/span&gt;
&lt;span class="co"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    state_size &lt;span class="op"&gt;=&lt;/span&gt; cell.state_size
    &lt;span class="cf"&gt;if&lt;/span&gt; nest.is_sequence(state_size):
        state_size_flat &lt;span class="op"&gt;=&lt;/span&gt; nest.flatten(state_size)
        zeros_flat &lt;span class="op"&gt;=&lt;/span&gt; [
            tf.zeros(
              tf.pack(_state_size_with_prefix(s, prefix&lt;span class="op"&gt;=&lt;/span&gt;[batch_size])),
              dtype&lt;span class="op"&gt;=&lt;/span&gt;dtype)
            &lt;span class="cf"&gt;for&lt;/span&gt; s &lt;span class="kw"&gt;in&lt;/span&gt; state_size_flat]
        &lt;span class="cf"&gt;for&lt;/span&gt; s, z &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;zip&lt;/span&gt;(state_size_flat, zeros_flat):
            z.set_shape(_state_size_with_prefix(s, prefix&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="va"&gt;None&lt;/span&gt;]))
        zeros &lt;span class="op"&gt;=&lt;/span&gt; nest.pack_sequence_as(structure&lt;span class="op"&gt;=&lt;/span&gt;state_size,
                                    flat_sequence&lt;span class="op"&gt;=&lt;/span&gt;zeros_flat)
    &lt;span class="cf"&gt;else&lt;/span&gt;:
        zeros_size &lt;span class="op"&gt;=&lt;/span&gt; _state_size_with_prefix(state_size, prefix&lt;span class="op"&gt;=&lt;/span&gt;[batch_size])
        zeros &lt;span class="op"&gt;=&lt;/span&gt; tf.zeros(tf.pack(zeros_size), dtype&lt;span class="op"&gt;=&lt;/span&gt;dtype)
        zeros.set_shape(_state_size_with_prefix(state_size, prefix&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="va"&gt;None&lt;/span&gt;]))

    &lt;span class="cf"&gt;return&lt;/span&gt; zeros&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h5 id="implementation"&gt;Implementation&lt;/h5&gt;
&lt;p&gt;Rather than rewriting the &lt;code&gt;zero_state&lt;/code&gt; method to initialize the state with a variable (or with noise) directly, we will abstract out the &lt;code&gt;tf.zeros&lt;/code&gt; function, to make the method more flexible. Our abstracted function, &lt;code&gt;get_initial_cell_state&lt;/code&gt;, takes an additional &lt;code&gt;initializer&lt;/code&gt; argument, which takes the place of &lt;code&gt;tf.zeros&lt;/code&gt; and determines how the state is initialized. This would be a simple modification, but for the fact that we need to be careful with how variable states are created (e.g., we don’t want a different variable for each sample in the batch), which pushes some of the complexity into the &lt;code&gt;initializer&lt;/code&gt; function.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; get_initial_cell_state(cell, initializer, batch_size, dtype):
    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;Return state tensor(s), initialized with initializer.&lt;/span&gt;
&lt;span class="co"&gt;    Args:&lt;/span&gt;
&lt;span class="co"&gt;      cell: RNNCell.&lt;/span&gt;
&lt;span class="co"&gt;      batch_size: int, float, or unit Tensor representing the batch size.&lt;/span&gt;
&lt;span class="co"&gt;      initializer: function with two arguments, shape and dtype, that&lt;/span&gt;
&lt;span class="co"&gt;          determines how the state is initialized.&lt;/span&gt;
&lt;span class="co"&gt;      dtype: the data type to use for the state.&lt;/span&gt;
&lt;span class="co"&gt;    Returns:&lt;/span&gt;
&lt;span class="co"&gt;      If `state_size` is an int or TensorShape, then the return value is a&lt;/span&gt;
&lt;span class="co"&gt;      `N-D` tensor of shape `[batch_size x state_size]` initialized&lt;/span&gt;
&lt;span class="co"&gt;      according to the initializer.&lt;/span&gt;
&lt;span class="co"&gt;      If `state_size` is a nested list or tuple, then the return value is&lt;/span&gt;
&lt;span class="co"&gt;      a nested list or tuple (of the same structure) of `2-D` tensors with&lt;/span&gt;
&lt;span class="co"&gt;    the shapes `[batch_size x s]` for each s in `state_size`.&lt;/span&gt;
&lt;span class="co"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    state_size &lt;span class="op"&gt;=&lt;/span&gt; cell.state_size
    &lt;span class="cf"&gt;if&lt;/span&gt; nest.is_sequence(state_size):
        state_size_flat &lt;span class="op"&gt;=&lt;/span&gt; nest.flatten(state_size)
        init_state_flat &lt;span class="op"&gt;=&lt;/span&gt; [
            initializer(_state_size_with_prefix(s), batch_size, dtype, i)
                &lt;span class="cf"&gt;for&lt;/span&gt; i, s &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;enumerate&lt;/span&gt;(state_size_flat)]
        init_state &lt;span class="op"&gt;=&lt;/span&gt; nest.pack_sequence_as(structure&lt;span class="op"&gt;=&lt;/span&gt;state_size,
                                    flat_sequence&lt;span class="op"&gt;=&lt;/span&gt;init_state_flat)
    &lt;span class="cf"&gt;else&lt;/span&gt;:
        init_state_size &lt;span class="op"&gt;=&lt;/span&gt; _state_size_with_prefix(state_size)
        init_state &lt;span class="op"&gt;=&lt;/span&gt; initializer(init_state_size, batch_size, dtype, &lt;span class="va"&gt;None&lt;/span&gt;)

    &lt;span class="cf"&gt;return&lt;/span&gt; init_state&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;initializer&lt;/code&gt; must be a function with four arguments: &lt;code&gt;shape&lt;/code&gt; and &lt;code&gt;dtype&lt;/code&gt;, a la &lt;code&gt;tf.zeros&lt;/code&gt;, and additionally &lt;code&gt;batch_size&lt;/code&gt; and &lt;code&gt;index&lt;/code&gt;, which are introduced to play nice with variables. We can achieve the same behavior as the original &lt;code&gt;zero_state&lt;/code&gt; method with the following &lt;code&gt;initializer&lt;/code&gt; function:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; zero_state_initializer(shape, batch_size, dtype, index):
    z &lt;span class="op"&gt;=&lt;/span&gt; tf.zeros(tf.pack(_state_size_with_prefix(shape, [batch_size])), dtype)
    z.set_shape(_state_size_with_prefix(shape, prefix&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="va"&gt;None&lt;/span&gt;]))
    &lt;span class="cf"&gt;return&lt;/span&gt; z&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then calling &lt;code&gt;get_initial_cell_state(cell, zero_state_initializer, batch_size, tf.float32)&lt;/code&gt; does the same thing as calling &lt;code&gt;zero_state(cell, batch_size, tf.float32)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Given this abstraction, we add support for a variable initializer like so:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; make_variable_state_initializer(&lt;span class="op"&gt;**&lt;/span&gt;kwargs):
    &lt;span class="kw"&gt;def&lt;/span&gt; variable_state_initializer(shape, batch_size, dtype, index):
        args &lt;span class="op"&gt;=&lt;/span&gt; kwargs.copy()

        &lt;span class="cf"&gt;if&lt;/span&gt; args.get(&lt;span class="st"&gt;&amp;#39;name&amp;#39;&lt;/span&gt;):
            args[&lt;span class="st"&gt;&amp;#39;name&amp;#39;&lt;/span&gt;] &lt;span class="op"&gt;=&lt;/span&gt; args[&lt;span class="st"&gt;&amp;#39;name&amp;#39;&lt;/span&gt;] &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;_&amp;#39;&lt;/span&gt; &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="bu"&gt;str&lt;/span&gt;(index)
        &lt;span class="cf"&gt;else&lt;/span&gt;:
            args[&lt;span class="st"&gt;&amp;#39;name&amp;#39;&lt;/span&gt;] &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;init_state_&amp;#39;&lt;/span&gt; &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="bu"&gt;str&lt;/span&gt;(index)

        args[&lt;span class="st"&gt;&amp;#39;shape&amp;#39;&lt;/span&gt;] &lt;span class="op"&gt;=&lt;/span&gt; shape
        args[&lt;span class="st"&gt;&amp;#39;dtype&amp;#39;&lt;/span&gt;] &lt;span class="op"&gt;=&lt;/span&gt; dtype

        var &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="op"&gt;**&lt;/span&gt;args)
        var &lt;span class="op"&gt;=&lt;/span&gt; tf.expand_dims(var, &lt;span class="dv"&gt;0&lt;/span&gt;)
        var &lt;span class="op"&gt;=&lt;/span&gt; tf.tile(var, tf.pack([batch_size] &lt;span class="op"&gt;+&lt;/span&gt; [&lt;span class="dv"&gt;1&lt;/span&gt;] &lt;span class="op"&gt;*&lt;/span&gt; &lt;span class="bu"&gt;len&lt;/span&gt;(shape)))
        var.set_shape(_state_size_with_prefix(shape, prefix&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="va"&gt;None&lt;/span&gt;]))
        &lt;span class="cf"&gt;return&lt;/span&gt; var

    &lt;span class="cf"&gt;return&lt;/span&gt; variable_state_initializer&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can now get a variable initial state by calling &lt;code&gt;get_initial_cell_state(cell, make_variable_initializer(), batch_size, tf.float32)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Finally, we can add a noisy wrapper for our zero or variable state intializers like so:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; make_gaussian_state_initializer(initializer, deterministic_tensor&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;None&lt;/span&gt;, stddev&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.3&lt;/span&gt;):
    &lt;span class="kw"&gt;def&lt;/span&gt; gaussian_state_initializer(shape, batch_size, dtype, index):
        init_state &lt;span class="op"&gt;=&lt;/span&gt; initializer(shape, batch_size, dtype, index)
        &lt;span class="cf"&gt;if&lt;/span&gt; deterministic_tensor &lt;span class="kw"&gt;is&lt;/span&gt; &lt;span class="kw"&gt;not&lt;/span&gt; &lt;span class="va"&gt;None&lt;/span&gt;:
            &lt;span class="cf"&gt;return&lt;/span&gt; tf.cond(deterministic_tensor,
                &lt;span class="kw"&gt;lambda&lt;/span&gt;: init_state,
                &lt;span class="kw"&gt;lambda&lt;/span&gt;: init_state &lt;span class="op"&gt;+&lt;/span&gt; tf.random_normal(tf.shape(init_state), stddev&lt;span class="op"&gt;=&lt;/span&gt;stddev))
        &lt;span class="cf"&gt;else&lt;/span&gt;:
            &lt;span class="cf"&gt;return&lt;/span&gt; init_state &lt;span class="op"&gt;+&lt;/span&gt; tf.random_normal(tf.shape(init_state), stddev&lt;span class="op"&gt;=&lt;/span&gt;stddev)
    &lt;span class="cf"&gt;return&lt;/span&gt; gaussian_state_initializer&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This wrapper adds gaussian noise to the underlying initial_state. E.g., to create an initializer function that initializes the state with a mean of zero and standard deviation of 0.1, we call &lt;code&gt;make_gaussian_state_initializer(zero_state_initializer, stddev=0.01)&lt;/code&gt;. The deterministic_tensor is an optional boolean tensor that can be used to disable added noise at test time (recommended).&lt;/p&gt;
&lt;h2 id="an-experiment-on-the-truncated-ptb-dataset"&gt;An experiment on the truncated PTB dataset&lt;/h2&gt;
&lt;p&gt;Now let us test our initializers on a “truncated” PTB language modeling task. This will be the same as the regular PTB dataset, except that we will modify the usual training routine so as to &lt;em&gt;not&lt;/em&gt; propagate the final state forward (i.e., it will truncate the state propagation). By reseting the state between each training step, we make the PTB dataset behave like a dataset with many state resets.&lt;/p&gt;
&lt;h5 id="helper-functions"&gt;Helper functions&lt;/h5&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="im"&gt;from&lt;/span&gt; tensorflow.models.rnn.ptb &lt;span class="im"&gt;import&lt;/span&gt; reader
&lt;span class="im"&gt;from&lt;/span&gt; enum &lt;span class="im"&gt;import&lt;/span&gt; Enum

&lt;span class="co"&gt;#data from http://www.fit.vutbr.cz/~imikolov/rnnlm/simple-examples.tgz&lt;/span&gt;
raw_data &lt;span class="op"&gt;=&lt;/span&gt; reader.ptb_raw_data(&lt;span class="st"&gt;&amp;#39;ptb_data&amp;#39;&lt;/span&gt;)
train_data, val_data, test_data, num_classes &lt;span class="op"&gt;=&lt;/span&gt; raw_data
batch_size, num_steps &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;30&lt;/span&gt;, &lt;span class="dv"&gt;50&lt;/span&gt;

&lt;span class="kw"&gt;def&lt;/span&gt; gen_epochs(n, num_steps, batch_size, dataset&lt;span class="op"&gt;=&lt;/span&gt;train_data):
    &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(n):
        &lt;span class="cf"&gt;yield&lt;/span&gt; reader.ptb_iterator(dataset, batch_size, num_steps)

&lt;span class="kw"&gt;def&lt;/span&gt; reset_graph():
    &lt;span class="cf"&gt;if&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;sess&amp;#39;&lt;/span&gt; &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;globals&lt;/span&gt;() &lt;span class="kw"&gt;and&lt;/span&gt; sess:
        sess.close()
    tf.reset_default_graph()

&lt;span class="kw"&gt;def&lt;/span&gt; eval_network(sess, g, num_steps &lt;span class="op"&gt;=&lt;/span&gt; num_steps, batch_size &lt;span class="op"&gt;=&lt;/span&gt; batch_size):
    losses &lt;span class="op"&gt;=&lt;/span&gt; []
    &lt;span class="cf"&gt;for&lt;/span&gt; X, Y &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;next&lt;/span&gt;(gen_epochs(&lt;span class="dv"&gt;1&lt;/span&gt;, num_steps, batch_size, dataset&lt;span class="op"&gt;=&lt;/span&gt;val_data&lt;span class="op"&gt;+&lt;/span&gt;test_data)):
        feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{g[&lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;]: X, g[&lt;span class="st"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;]: Y, g[&lt;span class="st"&gt;&amp;#39;deterministic&amp;#39;&lt;/span&gt;]: &lt;span class="va"&gt;True&lt;/span&gt;}
        loss_ &lt;span class="op"&gt;=&lt;/span&gt; sess.run([g[&lt;span class="st"&gt;&amp;#39;loss&amp;#39;&lt;/span&gt;]], feed_dict)[&lt;span class="dv"&gt;0&lt;/span&gt;]
        losses.append(loss_)
    &lt;span class="cf"&gt;return&lt;/span&gt; np.mean(losses, axis&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;0&lt;/span&gt;)

&lt;span class="kw"&gt;def&lt;/span&gt; train_network(sess, g, num_epochs, num_steps &lt;span class="op"&gt;=&lt;/span&gt; num_steps, batch_size &lt;span class="op"&gt;=&lt;/span&gt; batch_size):
    sess.run(tf.initialize_all_variables())
    losses &lt;span class="op"&gt;=&lt;/span&gt; []
    val_losses &lt;span class="op"&gt;=&lt;/span&gt; []
    &lt;span class="cf"&gt;for&lt;/span&gt; idx, epoch &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;enumerate&lt;/span&gt;(gen_epochs(num_epochs, num_steps, batch_size)):
        loss &lt;span class="op"&gt;=&lt;/span&gt; []
        &lt;span class="cf"&gt;for&lt;/span&gt; X, Y &lt;span class="kw"&gt;in&lt;/span&gt; epoch:
            feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{g[&lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;]: X, g[&lt;span class="st"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;]: Y}
            loss_, _ &lt;span class="op"&gt;=&lt;/span&gt; sess.run([g[&lt;span class="st"&gt;&amp;#39;loss&amp;#39;&lt;/span&gt;], g[&lt;span class="st"&gt;&amp;#39;train_step&amp;#39;&lt;/span&gt;]], feed_dict)
            loss.append(loss_)

        val_loss &lt;span class="op"&gt;=&lt;/span&gt; eval_network(sess, g)
        &lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;Average perplexity for Epoch&amp;quot;&lt;/span&gt;, idx,
              &lt;span class="st"&gt;&amp;quot;: Training -&amp;quot;&lt;/span&gt;, np.exp(np.mean(loss)),
              &lt;span class="st"&gt;&amp;quot;Validation -&amp;quot;&lt;/span&gt;, np.exp(np.mean(val_loss)))
        losses.append(np.mean(loss, axis&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;0&lt;/span&gt;))
        val_losses.append(val_loss)
    &lt;span class="cf"&gt;return&lt;/span&gt; np.array(losses), np.array(val_losses)

&lt;span class="kw"&gt;class&lt;/span&gt; StateInitializer(Enum):
    ZERO_STATE &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;
    VARIABLE_STATE &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt;
    NOISY_ZERO_STATE &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;3&lt;/span&gt;
    NOISY_VARIABLE_STATE &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;4&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h5 id="graph"&gt;Graph&lt;/h5&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; build_graph(
    state_initializer,
    state_size &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;200&lt;/span&gt;,
    num_classes &lt;span class="op"&gt;=&lt;/span&gt; num_classes,
    batch_size &lt;span class="op"&gt;=&lt;/span&gt; batch_size,
    num_steps &lt;span class="op"&gt;=&lt;/span&gt; num_steps,
    num_layers &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt;):

    reset_graph()

    x &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(tf.int32, [batch_size, num_steps], name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;input_placeholder&amp;#39;&lt;/span&gt;)
    y &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(tf.int32, [batch_size, num_steps], name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;labels_placeholder&amp;#39;&lt;/span&gt;)
    lr &lt;span class="op"&gt;=&lt;/span&gt; tf.constant(&lt;span class="fl"&gt;1.&lt;/span&gt;)
    deterministic &lt;span class="op"&gt;=&lt;/span&gt; tf.constant(&lt;span class="va"&gt;False&lt;/span&gt;)

    embeddings &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;embedding_matrix&amp;#39;&lt;/span&gt;, [num_classes, state_size])

    rnn_inputs &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.embedding_lookup(embeddings, x)

    cell &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.rnn_cell.LSTMCell(state_size, state_is_tuple&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)
    cell &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.rnn_cell.MultiRNNCell([cell] &lt;span class="op"&gt;*&lt;/span&gt; num_layers, state_is_tuple&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)

    &lt;span class="cf"&gt;if&lt;/span&gt; state_initializer &lt;span class="op"&gt;==&lt;/span&gt; StateInitializer.ZERO_STATE:
        initializer &lt;span class="op"&gt;=&lt;/span&gt; zero_state_initializer
    &lt;span class="cf"&gt;elif&lt;/span&gt; state_initializer &lt;span class="op"&gt;==&lt;/span&gt; StateInitializer.VARIABLE_STATE:
        initializer &lt;span class="op"&gt;=&lt;/span&gt; make_variable_state_initializer()
    &lt;span class="cf"&gt;elif&lt;/span&gt; state_initializer &lt;span class="op"&gt;==&lt;/span&gt; StateInitializer.NOISY_ZERO_STATE:
        initializer &lt;span class="op"&gt;=&lt;/span&gt; make_gaussian_state_initializer(zero_state_initializer,
                                                     deterministic)
    &lt;span class="cf"&gt;elif&lt;/span&gt; state_initializer &lt;span class="op"&gt;==&lt;/span&gt; StateInitializer.NOISY_VARIABLE_STATE:
        initializer &lt;span class="op"&gt;=&lt;/span&gt; make_gaussian_state_initializer(make_variable_state_initializer(),
                                                      deterministic)

    init_state &lt;span class="op"&gt;=&lt;/span&gt; get_initial_cell_state(cell, initializer, batch_size, tf.float32)
    rnn_outputs, final_state &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.dynamic_rnn(cell, rnn_inputs, initial_state&lt;span class="op"&gt;=&lt;/span&gt;init_state)

    &lt;span class="cf"&gt;with&lt;/span&gt; tf.variable_scope(&lt;span class="st"&gt;&amp;#39;softmax&amp;#39;&lt;/span&gt;):
        W &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;W&amp;#39;&lt;/span&gt;, [state_size, num_classes])
        b &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;, [num_classes], initializer&lt;span class="op"&gt;=&lt;/span&gt;tf.constant_initializer(&lt;span class="fl"&gt;0.0&lt;/span&gt;))

    &lt;span class="co"&gt;#reshape rnn_outputs and y so we can get the logits in a single matmul&lt;/span&gt;
    rnn_outputs &lt;span class="op"&gt;=&lt;/span&gt; tf.reshape(rnn_outputs, [&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;, state_size])
    y_reshaped &lt;span class="op"&gt;=&lt;/span&gt; tf.reshape(y, [&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;])

    logits &lt;span class="op"&gt;=&lt;/span&gt; tf.matmul(rnn_outputs, W) &lt;span class="op"&gt;+&lt;/span&gt; b

    losses &lt;span class="op"&gt;=&lt;/span&gt; tf.reshape(tf.nn.sparse_softmax_cross_entropy_with_logits(logits, y_reshaped),
                        [batch_size, num_steps])

    loss_by_timestep &lt;span class="op"&gt;=&lt;/span&gt; tf.reduce_mean(losses, reduction_indices&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;0&lt;/span&gt;)
    train_step &lt;span class="op"&gt;=&lt;/span&gt; tf.train.AdamOptimizer().minimize(loss_by_timestep)

    &lt;span class="cf"&gt;return&lt;/span&gt; &lt;span class="bu"&gt;dict&lt;/span&gt;(
        x &lt;span class="op"&gt;=&lt;/span&gt; x,
        y &lt;span class="op"&gt;=&lt;/span&gt; y,
        lr &lt;span class="op"&gt;=&lt;/span&gt; lr,
        deterministic &lt;span class="op"&gt;=&lt;/span&gt; deterministic,
        init_state &lt;span class="op"&gt;=&lt;/span&gt; init_state,
        final_state &lt;span class="op"&gt;=&lt;/span&gt; final_state,
        loss &lt;span class="op"&gt;=&lt;/span&gt; loss_by_timestep,
        train_step &lt;span class="op"&gt;=&lt;/span&gt; train_step
    )&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h5 id="experiment"&gt;Experiment&lt;/h5&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;tr_losses, val_losses &lt;span class="op"&gt;=&lt;/span&gt; [&lt;span class="va"&gt;None&lt;/span&gt;] &lt;span class="op"&gt;*&lt;/span&gt; &lt;span class="dv"&gt;4&lt;/span&gt;, [&lt;span class="va"&gt;None&lt;/span&gt;] &lt;span class="op"&gt;*&lt;/span&gt; &lt;span class="dv"&gt;4&lt;/span&gt;
g &lt;span class="op"&gt;=&lt;/span&gt; build_graph(state_initializer&lt;span class="op"&gt;=&lt;/span&gt;StateInitializer.ZERO_STATE)
sess &lt;span class="op"&gt;=&lt;/span&gt; tf.InteractiveSession()
tr_losses[&lt;span class="dv"&gt;0&lt;/span&gt;], val_losses[&lt;span class="dv"&gt;0&lt;/span&gt;] &lt;span class="op"&gt;=&lt;/span&gt; train_network(sess, g, num_epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;20&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Average perplexity for Epoch 0 : Training - 674.599 Validation - 483.888
Average perplexity for Epoch 1 : Training - 421.366 Validation - 348.751
Average perplexity for Epoch 2 : Training - 305.943 Validation - 272.674
Average perplexity for Epoch 3 : Training - 241.748 Validation - 235.801
Average perplexity for Epoch 4 : Training - 205.29 Validation - 212.853
Average perplexity for Epoch 5 : Training - 180.5 Validation - 198.029
Average perplexity for Epoch 6 : Training - 160.867 Validation - 186.862
Average perplexity for Epoch 7 : Training - 145.657 Validation - 179.394
Average perplexity for Epoch 8 : Training - 133.973 Validation - 173.399
Average perplexity for Epoch 9 : Training - 124.281 Validation - 169.236
Average perplexity for Epoch 10 : Training - 115.586 Validation - 166.216
Average perplexity for Epoch 11 : Training - 108.34 Validation - 163.99
Average perplexity for Epoch 12 : Training - 101.959 Validation - 162.627
Average perplexity for Epoch 13 : Training - 96.3985 Validation - 162.423
Average perplexity for Epoch 14 : Training - 91.6309 Validation - 163.904
Average perplexity for Epoch 15 : Training - 87.29 Validation - 163.679
Average perplexity for Epoch 16 : Training - 83.2224 Validation - 164.169
Average perplexity for Epoch 17 : Training - 79.5156 Validation - 165.162
Average perplexity for Epoch 18 : Training - 76.1198 Validation - 166.714
Average perplexity for Epoch 19 : Training - 73.1628 Validation - 168.515&lt;/code&gt;&lt;/pre&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;g &lt;span class="op"&gt;=&lt;/span&gt; build_graph(state_initializer&lt;span class="op"&gt;=&lt;/span&gt;StateInitializer.VARIABLE_STATE)
sess &lt;span class="op"&gt;=&lt;/span&gt; tf.InteractiveSession()
tr_losses[&lt;span class="dv"&gt;1&lt;/span&gt;], val_losses[&lt;span class="dv"&gt;1&lt;/span&gt;] &lt;span class="op"&gt;=&lt;/span&gt; train_network(sess, g, num_epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;20&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Average perplexity for Epoch 0 : Training - 525.724 Validation - 325.364
Average perplexity for Epoch 1 : Training - 275.811 Validation - 239.312
Average perplexity for Epoch 2 : Training - 210.521 Validation - 204.103
Average perplexity for Epoch 3 : Training - 176.135 Validation - 184.352
Average perplexity for Epoch 4 : Training - 153.307 Validation - 171.528
Average perplexity for Epoch 5 : Training - 136.591 Validation - 162.493
Average perplexity for Epoch 6 : Training - 123.592 Validation - 156.533
Average perplexity for Epoch 7 : Training - 113.033 Validation - 152.028
Average perplexity for Epoch 8 : Training - 104.201 Validation - 149.743
Average perplexity for Epoch 9 : Training - 96.7272 Validation - 148.263
Average perplexity for Epoch 10 : Training - 90.313 Validation - 147.438
Average perplexity for Epoch 11 : Training - 84.7536 Validation - 147.409
Average perplexity for Epoch 12 : Training - 79.8758 Validation - 147.533
Average perplexity for Epoch 13 : Training - 75.5331 Validation - 148.11
Average perplexity for Epoch 14 : Training - 71.5848 Validation - 149.513
Average perplexity for Epoch 15 : Training - 67.9394 Validation - 151.243
Average perplexity for Epoch 16 : Training - 64.6299 Validation - 153.503
Average perplexity for Epoch 17 : Training - 61.6355 Validation - 156.37
Average perplexity for Epoch 18 : Training - 58.9116 Validation - 160.145
Average perplexity for Epoch 19 : Training - 56.4397 Validation - 164.863&lt;/code&gt;&lt;/pre&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;g &lt;span class="op"&gt;=&lt;/span&gt; build_graph(state_initializer&lt;span class="op"&gt;=&lt;/span&gt;StateInitializer.NOISY_ZERO_STATE)
sess &lt;span class="op"&gt;=&lt;/span&gt; tf.InteractiveSession()
tr_losses[&lt;span class="dv"&gt;2&lt;/span&gt;], val_losses[&lt;span class="dv"&gt;2&lt;/span&gt;] &lt;span class="op"&gt;=&lt;/span&gt; train_network(sess, g, num_epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;20&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Average perplexity for Epoch 0 : Training - 625.676 Validation - 407.948
Average perplexity for Epoch 1 : Training - 337.045 Validation - 277.074
Average perplexity for Epoch 2 : Training - 245.198 Validation - 230.573
Average perplexity for Epoch 3 : Training - 202.941 Validation - 205.394
Average perplexity for Epoch 4 : Training - 175.752 Validation - 189.294
Average perplexity for Epoch 5 : Training - 156.077 Validation - 178.006
Average perplexity for Epoch 6 : Training - 141.035 Validation - 170.011
Average perplexity for Epoch 7 : Training - 128.985 Validation - 164.033
Average perplexity for Epoch 8 : Training - 118.946 Validation - 160.09
Average perplexity for Epoch 9 : Training - 110.475 Validation - 157.405
Average perplexity for Epoch 10 : Training - 103.191 Validation - 155.624
Average perplexity for Epoch 11 : Training - 96.9187 Validation - 154.584
Average perplexity for Epoch 12 : Training - 91.4146 Validation - 154.25
Average perplexity for Epoch 13 : Training - 86.494 Validation - 154.48
Average perplexity for Epoch 14 : Training - 82.1429 Validation - 155.172
Average perplexity for Epoch 15 : Training - 78.1957 Validation - 156.681
Average perplexity for Epoch 16 : Training - 74.6005 Validation - 158.523
Average perplexity for Epoch 17 : Training - 71.3612 Validation - 160.869
Average perplexity for Epoch 18 : Training - 68.3056 Validation - 163.278
Average perplexity for Epoch 19 : Training - 65.4805 Validation - 165.645&lt;/code&gt;&lt;/pre&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;g &lt;span class="op"&gt;=&lt;/span&gt; build_graph(state_initializer&lt;span class="op"&gt;=&lt;/span&gt;StateInitializer.NOISY_VARIABLE_STATE)
sess &lt;span class="op"&gt;=&lt;/span&gt; tf.InteractiveSession()
tr_losses[&lt;span class="dv"&gt;3&lt;/span&gt;], val_losses[&lt;span class="dv"&gt;3&lt;/span&gt;] &lt;span class="op"&gt;=&lt;/span&gt; train_network(sess, g, num_epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;20&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Average perplexity for Epoch 0 : Training - 517.27 Validation - 331.341
Average perplexity for Epoch 1 : Training - 278.846 Validation - 239.6
Average perplexity for Epoch 2 : Training - 210.333 Validation - 203.027
Average perplexity for Epoch 3 : Training - 174.959 Validation - 182.456
Average perplexity for Epoch 4 : Training - 151.81 Validation - 169.388
Average perplexity for Epoch 5 : Training - 135.121 Validation - 160.613
Average perplexity for Epoch 6 : Training - 122.301 Validation - 154.474
Average perplexity for Epoch 7 : Training - 111.991 Validation - 150.337
Average perplexity for Epoch 8 : Training - 103.425 Validation - 147.664
Average perplexity for Epoch 9 : Training - 96.1806 Validation - 145.957
Average perplexity for Epoch 10 : Training - 89.8921 Validation - 145.308
Average perplexity for Epoch 11 : Training - 84.3145 Validation - 145.255
Average perplexity for Epoch 12 : Training - 79.3745 Validation - 146.052
Average perplexity for Epoch 13 : Training - 74.96 Validation - 147.01
Average perplexity for Epoch 14 : Training - 71.0005 Validation - 148.22
Average perplexity for Epoch 15 : Training - 67.3658 Validation - 150.713
Average perplexity for Epoch 16 : Training - 64.0655 Validation - 153.78
Average perplexity for Epoch 17 : Training - 61.0874 Validation - 157.101
Average perplexity for Epoch 18 : Training - 58.3892 Validation - 160.376
Average perplexity for Epoch 19 : Training - 55.9478 Validation - 164.157&lt;/code&gt;&lt;/pre&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="im"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class="im"&gt;as&lt;/span&gt; plt
&lt;span class="op"&gt;%&lt;/span&gt;matplotlib inline
&lt;span class="im"&gt;import&lt;/span&gt; seaborn &lt;span class="im"&gt;as&lt;/span&gt; sns
sns.&lt;span class="bu"&gt;set&lt;/span&gt;(color_codes&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)

&lt;span class="kw"&gt;def&lt;/span&gt; best_epoch(val_losses):
    &lt;span class="cf"&gt;return&lt;/span&gt; np.argmin(np.mean(val_losses, axis&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;))

labels &lt;span class="op"&gt;=&lt;/span&gt; [&lt;span class="st"&gt;&amp;#39;Zero&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;Variable&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;Noisy&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;Noisy Variable&amp;#39;&lt;/span&gt;]

&lt;span class="kw"&gt;def&lt;/span&gt; plot_losses(losses, title, y_range):
    &lt;span class="kw"&gt;global&lt;/span&gt; val_losses
    fig, ax &lt;span class="op"&gt;=&lt;/span&gt; plt.subplots()
    &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="bu"&gt;len&lt;/span&gt;(losses)):
        data &lt;span class="op"&gt;=&lt;/span&gt; np.exp(losses[i][best_epoch(val_losses[i])])
        ax.plot(&lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;0&lt;/span&gt;,num_steps),data,label&lt;span class="op"&gt;=&lt;/span&gt;labels[i])
    ax.set_xlabel(&lt;span class="st"&gt;&amp;#39;Step number&amp;#39;&lt;/span&gt;)
    ax.set_ylabel(&lt;span class="st"&gt;&amp;#39;Average loss&amp;#39;&lt;/span&gt;)
    ax.set_ylim(y_range)
    ax.set_title(title)
    ax.legend(loc&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;)
    plt.show()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;plot_losses(tr_losses, &lt;span class="st"&gt;&amp;#39;Best epoch training perplexities&amp;#39;&lt;/span&gt;, [&lt;span class="dv"&gt;70&lt;/span&gt;, &lt;span class="dv"&gt;110&lt;/span&gt;])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/NonzeroStateInit_output_25_0.png" alt="png" /&gt;&lt;figcaption&gt;png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;plot_losses(val_losses, &lt;span class="st"&gt;&amp;#39;Best epoch validation perplexities&amp;#39;&lt;/span&gt;, [&lt;span class="dv"&gt;120&lt;/span&gt;, &lt;span class="dv"&gt;200&lt;/span&gt;])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/NonzeroStateInit_output_26_0.png" alt="png" /&gt;&lt;figcaption&gt;png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h3 id="empirical-results"&gt;Empirical results&lt;/h3&gt;
&lt;p&gt;From the above experiment we make the following observations:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;All non-zero state intializations sped up training and improved generalization.&lt;/li&gt;
&lt;li&gt;Training the initial state as a variable was more effective than using a noisy zero-mean initial state.&lt;/li&gt;
&lt;li&gt;Adding noise to a variable initial state provided only marginal benefit.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Finally, I would note that “truncating” the PTB dataset produced worse results than would be obtained if the dataset were not truncated, even if we use noisy or variable state initializations. We can see this by comparing the above results to the “non-regularized LSTM” from &lt;a href="https://arxiv.org/pdf/1409.2329v5.pdf"&gt;Zaremba et al. (2015)&lt;/a&gt;, which had a very similar architecture, but did not truncate the sequences in the dataset. I would expect truncation will have this effect in general, so that these non-zero state initializations will only really be useful for datasets that have many naturally-occuring state resets.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</content></entry><entry><title>Recurrent Neural Networks in Tensorflow III - Variable Length Sequences</title><link href="https://r2rt.com/recurrent-neural-networks-in-tensorflow-iii-variable-length-sequences.html" rel="alternate"></link><published>2016-11-15T00:00:00-05:00</published><updated>2016-11-15T00:00:00-05:00</updated><author><name>Silviu Pitis</name></author><id>tag:r2rt.com,2016-11-15:/recurrent-neural-networks-in-tensorflow-iii-variable-length-sequences.html</id><summary type="html">This is the third in a series of posts about recurrent neural networks in Tensorflow. In this post, we'll use Tensorflow to construct an RNN that operates on input sequences of variable lengths.</summary><content type="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;meta name="generator" content="pandoc"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes"&gt;
  &lt;title&gt;&lt;/title&gt;
  &lt;style type="text/css"&gt;code{white-space: pre;}&lt;/style&gt;
  &lt;style type="text/css"&gt;
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code &gt; span.kw { color: #007020; font-weight: bold; } /* Keyword */
code &gt; span.dt { color: #902000; } /* DataType */
code &gt; span.dv { color: #40a070; } /* DecVal */
code &gt; span.bn { color: #40a070; } /* BaseN */
code &gt; span.fl { color: #40a070; } /* Float */
code &gt; span.ch { color: #4070a0; } /* Char */
code &gt; span.st { color: #4070a0; } /* String */
code &gt; span.co { color: #60a0b0; font-style: italic; } /* Comment */
code &gt; span.ot { color: #007020; } /* Other */
code &gt; span.al { color: #ff0000; font-weight: bold; } /* Alert */
code &gt; span.fu { color: #06287e; } /* Function */
code &gt; span.er { color: #ff0000; font-weight: bold; } /* Error */
code &gt; span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code &gt; span.cn { color: #880000; } /* Constant */
code &gt; span.sc { color: #4070a0; } /* SpecialChar */
code &gt; span.vs { color: #4070a0; } /* VerbatimString */
code &gt; span.ss { color: #bb6688; } /* SpecialString */
code &gt; span.im { } /* Import */
code &gt; span.va { color: #19177c; } /* Variable */
code &gt; span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code &gt; span.op { color: #666666; } /* Operator */
code &gt; span.bu { } /* BuiltIn */
code &gt; span.ex { } /* Extension */
code &gt; span.pp { color: #bc7a00; } /* Preprocessor */
code &gt; span.at { color: #7d9029; } /* Attribute */
code &gt; span.do { color: #ba2121; font-style: italic; } /* Documentation */
code &gt; span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code &gt; span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code &gt; span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  &lt;/style&gt;
  &lt;!--[if lt IE 9]&gt;
    &lt;script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"&gt;&lt;/script&gt;
  &lt;![endif]--&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h2 id="task"&gt;Task&lt;/h2&gt;
&lt;p&gt;In this post, we’ll use Tensorflow to construct an RNN that operates on input sequences of variable lengths. We’ll use this RNN to classify bloggers by age bracket and gender using sentence-long writing samples. One time step will represent a single word, with the complete input sequence representing a single sentence. The challenge is to build a model that can classify multiple sentences of different lengths at the same time.&lt;/p&gt;
&lt;h3 id="other-tutorials-on-variable-length-sequences"&gt;Other tutorials on variable length sequences&lt;/h3&gt;
&lt;p&gt;There are a couple other tutorials on this topic. For example, the &lt;a href="https://www.tensorflow.org/versions/master/tutorials/seq2seq/index.html"&gt;official Tensorflow seq2seq tutorial model&lt;/a&gt; accomodates variable length sequences. This official model, however, is a bit advanced for a first exposure and a little too specialized to be easily portable to other contexts. Danijar Hafner has written a more approachable guide &lt;a href="http://danijar.com/variable-sequence-lengths-in-tensorflow/"&gt;here&lt;/a&gt;, which I recommend. In contrast to Danijar’s post, this post is written a linear ipython notebook-style to make it easy for you to follow along step-by-step. This post also includes a section on bucketing, a technique that can significantly improve your model’s training time.&lt;/p&gt;
&lt;h2 id="data"&gt;Data&lt;/h2&gt;
&lt;p&gt;The data for this post is sourced from the “Blog Authorship Corpus”, available &lt;a href="http://u.cs.biu.ac.il/~koppel/BlogCorpus.htm"&gt;here&lt;/a&gt;. The original dataset was tokenized and split into sentences using &lt;a href="https://spacy.io/"&gt;spacy&lt;/a&gt;. Sentences with less than 5 tokens and sentences with more than 30 tokens were discarded. Number-like tokens were replaced by “&amp;lt;#&amp;gt;”. Tokens other than the 9999 most common tokens were replaced by “&amp;lt; UNK &amp;gt;”, for a 10000 token vocabulary. Sentences were tagged with the gender (0 for male, 1 for female) and age bracket (0 for teens, 1 for 20s, 2 for 30s) and placed into a pandas dataframe. The modified data and code to import can be found &lt;a href="https://github.com/spitis/blogs_data"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Below is the head of the dataframe (tokens in “string” are delimited by spaces):&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="im"&gt;import&lt;/span&gt; pandas &lt;span class="im"&gt;as&lt;/span&gt; pd, numpy &lt;span class="im"&gt;as&lt;/span&gt; np, tensorflow &lt;span class="im"&gt;as&lt;/span&gt; tf
&lt;span class="im"&gt;import&lt;/span&gt; blogs_data &lt;span class="co"&gt;#available at https://github.com/spitis/blogs_data&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;df &lt;span class="op"&gt;=&lt;/span&gt; blogs_data.loadBlogs().sample(frac&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;).reset_index(drop&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)
vocab, reverse_vocab &lt;span class="op"&gt;=&lt;/span&gt; blogs_data.loadVocab()
train_len, test_len &lt;span class="op"&gt;=&lt;/span&gt; np.floor(&lt;span class="bu"&gt;len&lt;/span&gt;(df)&lt;span class="op"&gt;*&lt;/span&gt;&lt;span class="fl"&gt;0.8&lt;/span&gt;), np.floor(&lt;span class="bu"&gt;len&lt;/span&gt;(df)&lt;span class="op"&gt;*&lt;/span&gt;&lt;span class="fl"&gt;0.2&lt;/span&gt;)
train, test &lt;span class="op"&gt;=&lt;/span&gt; df.ix[:train_len&lt;span class="dv"&gt;-1&lt;/span&gt;], df.ix[train_len:train_len &lt;span class="op"&gt;+&lt;/span&gt; test_len]
df &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="va"&gt;None&lt;/span&gt;
train.head()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;table&gt;
&lt;colgroup&gt;
&lt;col style="width: 2%" /&gt;
&lt;col style="width: 6%" /&gt;
&lt;col style="width: 6%" /&gt;
&lt;col style="width: 9%" /&gt;
&lt;col style="width: 34%" /&gt;
&lt;col style="width: 34%" /&gt;
&lt;col style="width: 6%" /&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr class="header"&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;post_id&lt;/th&gt;
&lt;th&gt;gender&lt;/th&gt;
&lt;th&gt;age&lt;/th&gt;
&lt;th&gt;string&lt;/th&gt;
&lt;th&gt;as_numbers&lt;/th&gt;
&lt;th&gt;length&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;118860&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;the last time i checked the constitution of th…&lt;/td&gt;
&lt;td&gt;[4, 127, 63, 3, 1837, 4, 3871, 8, 4, 1236, 927…&lt;/td&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;178031&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;but i do wish more people were so &lt;UNK&gt; ( star…&lt;/td&gt;
&lt;td&gt;[20, 3, 31, 360, 77, 79, 88, 27, 0, 43, 631, 2…&lt;/td&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;182592&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;it came back to me right away and i was off .&lt;/td&gt;
&lt;td&gt;[10, 209, 93, 5, 19, 136, 192, 6, 3, 17, 129, 2]&lt;/td&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;144982&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;day &amp;lt;#&amp;gt; - get to class &amp;lt;#&amp;gt; min . early .&lt;/td&gt;
&lt;td&gt;[94, 12, 33, 59, 5, 320, 12, 2703, 2, 457, 2]&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;43048&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;cause you do n’t know how much i , i need you …&lt;/td&gt;
&lt;td&gt;[332, 15, 31, 28, 64, 86, 96, 3, 1, 3, 157, 15…&lt;/td&gt;
&lt;td&gt;21&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;We’re going to build an RNN that accepts batches of data from the “as_numbers” column and predicts the “gender” and “age_bracket” columns. The first step is to construct a simple iterator that returns batches of inputs along with their targets, and the length of each input:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;class&lt;/span&gt; SimpleDataIterator():
    &lt;span class="kw"&gt;def&lt;/span&gt; &lt;span class="fu"&gt;__init__&lt;/span&gt;(&lt;span class="va"&gt;self&lt;/span&gt;, df):
        &lt;span class="va"&gt;self&lt;/span&gt;.df &lt;span class="op"&gt;=&lt;/span&gt; df
        &lt;span class="va"&gt;self&lt;/span&gt;.size &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;len&lt;/span&gt;(&lt;span class="va"&gt;self&lt;/span&gt;.df)
        &lt;span class="va"&gt;self&lt;/span&gt;.epochs &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;
        &lt;span class="va"&gt;self&lt;/span&gt;.shuffle()

    &lt;span class="kw"&gt;def&lt;/span&gt; shuffle(&lt;span class="va"&gt;self&lt;/span&gt;):
        &lt;span class="va"&gt;self&lt;/span&gt;.df &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="va"&gt;self&lt;/span&gt;.df.sample(frac&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;).reset_index(drop&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)
        &lt;span class="va"&gt;self&lt;/span&gt;.cursor &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;

    &lt;span class="kw"&gt;def&lt;/span&gt; next_batch(&lt;span class="va"&gt;self&lt;/span&gt;, n):
        &lt;span class="cf"&gt;if&lt;/span&gt; &lt;span class="va"&gt;self&lt;/span&gt;.cursor&lt;span class="op"&gt;+&lt;/span&gt;n&lt;span class="dv"&gt;-1&lt;/span&gt; &lt;span class="op"&gt;&amp;gt;&lt;/span&gt; &lt;span class="va"&gt;self&lt;/span&gt;.size:
            &lt;span class="va"&gt;self&lt;/span&gt;.epochs &lt;span class="op"&gt;+=&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;
            &lt;span class="va"&gt;self&lt;/span&gt;.shuffle()
        res &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="va"&gt;self&lt;/span&gt;.df.ix[&lt;span class="va"&gt;self&lt;/span&gt;.cursor:&lt;span class="va"&gt;self&lt;/span&gt;.cursor&lt;span class="op"&gt;+&lt;/span&gt;n&lt;span class="dv"&gt;-1&lt;/span&gt;]
        &lt;span class="va"&gt;self&lt;/span&gt;.cursor &lt;span class="op"&gt;+=&lt;/span&gt; n
        &lt;span class="cf"&gt;return&lt;/span&gt; res[&lt;span class="st"&gt;&amp;#39;as_numbers&amp;#39;&lt;/span&gt;], res[&lt;span class="st"&gt;&amp;#39;gender&amp;#39;&lt;/span&gt;]&lt;span class="op"&gt;*&lt;/span&gt;&lt;span class="dv"&gt;3&lt;/span&gt; &lt;span class="op"&gt;+&lt;/span&gt; res[&lt;span class="st"&gt;&amp;#39;age_bracket&amp;#39;&lt;/span&gt;], res[&lt;span class="st"&gt;&amp;#39;length&amp;#39;&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;data &lt;span class="op"&gt;=&lt;/span&gt; SimpleDataIterator(train)
d &lt;span class="op"&gt;=&lt;/span&gt; data.next_batch(&lt;span class="dv"&gt;3&lt;/span&gt;)
&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;#39;Input sequences&lt;/span&gt;&lt;span class="ch"&gt;\n&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;&lt;/span&gt;, d[&lt;span class="dv"&gt;0&lt;/span&gt;], end&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ch"&gt;\n\n&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;&lt;/span&gt;)
&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;#39;Target values&lt;/span&gt;&lt;span class="ch"&gt;\n&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;&lt;/span&gt;, d[&lt;span class="dv"&gt;1&lt;/span&gt;], end&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ch"&gt;\n\n&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;&lt;/span&gt;)
&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;#39;Sequence lengths&lt;/span&gt;&lt;span class="ch"&gt;\n&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;&lt;/span&gt;, d[&lt;span class="dv"&gt;2&lt;/span&gt;])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Input sequences
0    [27, 3, 576, 146, 13, 204, 37, 150, 6, 804, 94...
1    [10, 210, 30, 1554, 10, 22, 325, 6240, 11, 4, ...
2    [2927, 78, 9324, 5, 2273, 4, 5937, 8, 1058, 4,...

Target values
0    4
1    4
2    1

Sequence lengths
0    13
1    18
2    22&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We are immediately faced with a problem, in that our 3 sequences are of different lengths: we cannot feed them into a Tensorflow graph as is, unless we create a different tensor for each (inefficient, and hard!). To solve this, we &lt;strong&gt;pad shorter sequences so that all sequences are the same length&lt;/strong&gt;. Then all sequences will fit into a single tensor.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;class&lt;/span&gt; PaddedDataIterator(SimpleDataIterator):
    &lt;span class="kw"&gt;def&lt;/span&gt; next_batch(&lt;span class="va"&gt;self&lt;/span&gt;, n):
        &lt;span class="cf"&gt;if&lt;/span&gt; &lt;span class="va"&gt;self&lt;/span&gt;.cursor&lt;span class="op"&gt;+&lt;/span&gt;n &lt;span class="op"&gt;&amp;gt;&lt;/span&gt; &lt;span class="va"&gt;self&lt;/span&gt;.size:
            &lt;span class="va"&gt;self&lt;/span&gt;.epochs &lt;span class="op"&gt;+=&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;
            &lt;span class="va"&gt;self&lt;/span&gt;.shuffle()
        res &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="va"&gt;self&lt;/span&gt;.df.ix[&lt;span class="va"&gt;self&lt;/span&gt;.cursor:&lt;span class="va"&gt;self&lt;/span&gt;.cursor&lt;span class="op"&gt;+&lt;/span&gt;n&lt;span class="dv"&gt;-1&lt;/span&gt;]
        &lt;span class="va"&gt;self&lt;/span&gt;.cursor &lt;span class="op"&gt;+=&lt;/span&gt; n

        &lt;span class="co"&gt;# Pad sequences with 0s so they are all the same length&lt;/span&gt;
        maxlen &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;max&lt;/span&gt;(res[&lt;span class="st"&gt;&amp;#39;length&amp;#39;&lt;/span&gt;])
        x &lt;span class="op"&gt;=&lt;/span&gt; np.zeros([n, maxlen], dtype&lt;span class="op"&gt;=&lt;/span&gt;np.int32)
        &lt;span class="cf"&gt;for&lt;/span&gt; i, x_i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;enumerate&lt;/span&gt;(x):
            x_i[:res[&lt;span class="st"&gt;&amp;#39;length&amp;#39;&lt;/span&gt;].values[i]] &lt;span class="op"&gt;=&lt;/span&gt; res[&lt;span class="st"&gt;&amp;#39;as_numbers&amp;#39;&lt;/span&gt;].values[i]

        &lt;span class="cf"&gt;return&lt;/span&gt; x, res[&lt;span class="st"&gt;&amp;#39;gender&amp;#39;&lt;/span&gt;]&lt;span class="op"&gt;*&lt;/span&gt;&lt;span class="dv"&gt;3&lt;/span&gt; &lt;span class="op"&gt;+&lt;/span&gt; res[&lt;span class="st"&gt;&amp;#39;age_bracket&amp;#39;&lt;/span&gt;], res[&lt;span class="st"&gt;&amp;#39;length&amp;#39;&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;data &lt;span class="op"&gt;=&lt;/span&gt; PaddedDataIterator(train)
d &lt;span class="op"&gt;=&lt;/span&gt; data.next_batch(&lt;span class="dv"&gt;3&lt;/span&gt;)
&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;#39;Input sequences&lt;/span&gt;&lt;span class="ch"&gt;\n&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;&lt;/span&gt;, d[&lt;span class="dv"&gt;0&lt;/span&gt;], end&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ch"&gt;\n\n&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Input sequences
 [[  34   90    5  470   16   19   16    7  159    2    0    0    0    0
     0    0    0    0    0    0    0    0    0    0    0    0    0    0]
 [  82    1  109    7  377    8  421    8    0   33  124    3   69  180
    17   90    5  133   16   19   33   34   12 3819   85  164  129   25]
 [1786 5570    1   13 7817  235   60 6168   19    2    0    0    0    0
     0    0    0    0    0    0    0    0    0    0    0    0    0    0]]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our padded iterator now returns a single input matrix of dimension [batch_size, max_sequence_length], where shorter sequences have been padded with zeros.&lt;/p&gt;
&lt;h4 id="a-note-on-pad-symbols"&gt;A note on PAD symbols&lt;/h4&gt;
&lt;p&gt;For this model, the zero that we used to pad our input sequences with is the index of the “&amp;lt; UNK &amp;gt;” symbol (representing UNKnown words) in our vocabulary. In this case, what we pad with doesn’t affect the outcome, and so I chose to keep it simple, but there are cases in which we might want to introduce a special “PAD” symbol. For example, here we will be feeding in a length tensor that holds information about our input sequence lengths, but suppose instead that we want to have Tensorflow calculate our sequence lengths; in that case, using 0 to represent both &amp;lt; UNK &amp;gt; and PAD would make it impossible for the graph to disambiguate between a sentence ending in &amp;lt; UNK &amp;gt; and a padded sentence. If we were to add a special PAD symbol, it would likely want to represent it as zero, and so it would have to displace the &amp;lt; UNK &amp;gt; symbol, which would then need to be represented by a different index.&lt;/p&gt;
&lt;p&gt;The advantage of the approach shown here (zero-padding with no special PAD symbol) is that it generalizes better to sequences with multi-dimensional continuous input (e.g., stock price data). In such cases, it does not really make sense to have a separate PAD symbol.&lt;/p&gt;
&lt;h2 id="a-basic-model-for-sequence-classification"&gt;A basic model for sequence classification&lt;/h2&gt;
&lt;p&gt;We’ll now construct a &lt;strong&gt;sequence classification&lt;/strong&gt; model using this data that assigns a single label to an entire input sequence. Later, we’ll look at how we can instead construct a sequence-to-sequence model that predicts the authors age and gender at each time step.&lt;/p&gt;
&lt;p&gt;Our model makes use of Tensorflow’s &lt;code&gt;dynamic_rnn&lt;/code&gt;, specifying a &lt;code&gt;sequence_length&lt;/code&gt; parameter, which is fed into the model along with the data. Calling &lt;code&gt;dynamic_rnn&lt;/code&gt; with a &lt;code&gt;sequence_length&lt;/code&gt; parameter returns padded outputs: e.g., if the maximum sequence length is 10, but a specific example in the batch has a sequence length of only 4 followed by 6 zero steps for padding, the output for that time step will also have a length of only 4, with 6 additional zero steps for padding.&lt;/p&gt;
&lt;p&gt;This introduces some added complexity, since for sequence classification we only care about the final output of each sequence. This could be solved in one line using &lt;code&gt;tf.gather_nd&lt;/code&gt;, as commented below, however, the gradient for &lt;code&gt;tf.gather_nd&lt;/code&gt; is not yet implemented as of this writing. It is expected to be implemented shortly (you can view the status on Github &lt;a href="https://github.com/tensorflow/tensorflow/issues/5342"&gt;here&lt;/a&gt;). In the interim, I have adopted Danijar Hafner’s solution, which you can read more about in his &lt;a href="http://danijar.com/variable-sequence-lengths-in-tensorflow/"&gt;post&lt;/a&gt; under the heading “Select the Last Relevant Output”.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; reset_graph():
    &lt;span class="cf"&gt;if&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;sess&amp;#39;&lt;/span&gt; &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;globals&lt;/span&gt;() &lt;span class="kw"&gt;and&lt;/span&gt; sess:
        sess.close()
    tf.reset_default_graph()

&lt;span class="kw"&gt;def&lt;/span&gt; build_graph(
    vocab_size &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;len&lt;/span&gt;(vocab),
    state_size &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;64&lt;/span&gt;,
    batch_size &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;256&lt;/span&gt;,
    num_classes &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;6&lt;/span&gt;):

    reset_graph()

    &lt;span class="co"&gt;# Placeholders&lt;/span&gt;
    x &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(tf.int32, [batch_size, &lt;span class="va"&gt;None&lt;/span&gt;]) &lt;span class="co"&gt;# [batch_size, num_steps]&lt;/span&gt;
    seqlen &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(tf.int32, [batch_size])
    y &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(tf.int32, [batch_size])
    keep_prob &lt;span class="op"&gt;=&lt;/span&gt; tf.constant(&lt;span class="fl"&gt;1.0&lt;/span&gt;)

    &lt;span class="co"&gt;# Embedding layer&lt;/span&gt;
    embeddings &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;embedding_matrix&amp;#39;&lt;/span&gt;, [vocab_size, state_size])
    rnn_inputs &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.embedding_lookup(embeddings, x)

    &lt;span class="co"&gt;# RNN&lt;/span&gt;
    cell &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.rnn_cell.GRUCell(state_size)
    init_state &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;init_state&amp;#39;&lt;/span&gt;, [&lt;span class="dv"&gt;1&lt;/span&gt;, state_size],
                                 initializer&lt;span class="op"&gt;=&lt;/span&gt;tf.constant_initializer(&lt;span class="fl"&gt;0.0&lt;/span&gt;))
    init_state &lt;span class="op"&gt;=&lt;/span&gt; tf.tile(init_state, [batch_size, &lt;span class="dv"&gt;1&lt;/span&gt;])
    rnn_outputs, final_state &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.dynamic_rnn(cell, rnn_inputs, sequence_length&lt;span class="op"&gt;=&lt;/span&gt;seqlen,
                                                 initial_state&lt;span class="op"&gt;=&lt;/span&gt;init_state)

    &lt;span class="co"&gt;# Add dropout, as the model otherwise quickly overfits&lt;/span&gt;
    rnn_outputs &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.dropout(rnn_outputs, keep_prob)

    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="co"&gt;    Obtain the last relevant output. The best approach in the future will be to use:&lt;/span&gt;

&lt;span class="co"&gt;        last_rnn_output = tf.gather_nd(rnn_outputs, tf.pack([tf.range(batch_size), seqlen-1], axis=1))&lt;/span&gt;

&lt;span class="co"&gt;    which is the Tensorflow equivalent of numpy&amp;#39;s rnn_outputs[range(30), seqlen-1, :], but the&lt;/span&gt;
&lt;span class="co"&gt;    gradient for this op has not been implemented as of this writing.&lt;/span&gt;

&lt;span class="co"&gt;    The below solution works, but throws a UserWarning re: the gradient.&lt;/span&gt;
&lt;span class="co"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    idx &lt;span class="op"&gt;=&lt;/span&gt; tf.&lt;span class="bu"&gt;range&lt;/span&gt;(batch_size)&lt;span class="op"&gt;*&lt;/span&gt;tf.shape(rnn_outputs)[&lt;span class="dv"&gt;1&lt;/span&gt;] &lt;span class="op"&gt;+&lt;/span&gt; (seqlen &lt;span class="op"&gt;-&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;)
    last_rnn_output &lt;span class="op"&gt;=&lt;/span&gt; tf.gather(tf.reshape(rnn_outputs, [&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;, state_size]), idx)

    &lt;span class="co"&gt;# Softmax layer&lt;/span&gt;
    &lt;span class="cf"&gt;with&lt;/span&gt; tf.variable_scope(&lt;span class="st"&gt;&amp;#39;softmax&amp;#39;&lt;/span&gt;):
        W &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;W&amp;#39;&lt;/span&gt;, [state_size, num_classes])
        b &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;, [num_classes], initializer&lt;span class="op"&gt;=&lt;/span&gt;tf.constant_initializer(&lt;span class="fl"&gt;0.0&lt;/span&gt;))
    logits &lt;span class="op"&gt;=&lt;/span&gt; tf.matmul(last_rnn_output, W) &lt;span class="op"&gt;+&lt;/span&gt; b
    preds &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.softmax(logits)
    correct &lt;span class="op"&gt;=&lt;/span&gt; tf.equal(tf.cast(tf.argmax(preds,&lt;span class="dv"&gt;1&lt;/span&gt;),tf.int32), y)
    accuracy &lt;span class="op"&gt;=&lt;/span&gt; tf.reduce_mean(tf.cast(correct, tf.float32))

    loss &lt;span class="op"&gt;=&lt;/span&gt; tf.reduce_mean(tf.nn.sparse_softmax_cross_entropy_with_logits(logits, y))
    train_step &lt;span class="op"&gt;=&lt;/span&gt; tf.train.AdamOptimizer(&lt;span class="fl"&gt;1e-4&lt;/span&gt;).minimize(loss)

    &lt;span class="cf"&gt;return&lt;/span&gt; {
        &lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;: x,
        &lt;span class="st"&gt;&amp;#39;seqlen&amp;#39;&lt;/span&gt;: seqlen,
        &lt;span class="st"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;: y,
        &lt;span class="st"&gt;&amp;#39;dropout&amp;#39;&lt;/span&gt;: keep_prob,
        &lt;span class="st"&gt;&amp;#39;loss&amp;#39;&lt;/span&gt;: loss,
        &lt;span class="st"&gt;&amp;#39;ts&amp;#39;&lt;/span&gt;: train_step,
        &lt;span class="st"&gt;&amp;#39;preds&amp;#39;&lt;/span&gt;: preds,
        &lt;span class="st"&gt;&amp;#39;accuracy&amp;#39;&lt;/span&gt;: accuracy
    }

&lt;span class="kw"&gt;def&lt;/span&gt; train_graph(graph, batch_size &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;256&lt;/span&gt;, num_epochs &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;10&lt;/span&gt;, iterator &lt;span class="op"&gt;=&lt;/span&gt; PaddedDataIterator):
    &lt;span class="cf"&gt;with&lt;/span&gt; tf.Session() &lt;span class="im"&gt;as&lt;/span&gt; sess:
        sess.run(tf.initialize_all_variables())
        tr &lt;span class="op"&gt;=&lt;/span&gt; iterator(train)
        te &lt;span class="op"&gt;=&lt;/span&gt; iterator(test)

        step, accuracy &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;, &lt;span class="dv"&gt;0&lt;/span&gt;
        tr_losses, te_losses &lt;span class="op"&gt;=&lt;/span&gt; [], []
        current_epoch &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;
        &lt;span class="cf"&gt;while&lt;/span&gt; current_epoch &lt;span class="op"&gt;&amp;lt;&lt;/span&gt; num_epochs:
            step &lt;span class="op"&gt;+=&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;
            batch &lt;span class="op"&gt;=&lt;/span&gt; tr.next_batch(batch_size)
            feed &lt;span class="op"&gt;=&lt;/span&gt; {g[&lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;]: batch[&lt;span class="dv"&gt;0&lt;/span&gt;], g[&lt;span class="st"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;]: batch[&lt;span class="dv"&gt;1&lt;/span&gt;], g[&lt;span class="st"&gt;&amp;#39;seqlen&amp;#39;&lt;/span&gt;]: batch[&lt;span class="dv"&gt;2&lt;/span&gt;], g[&lt;span class="st"&gt;&amp;#39;dropout&amp;#39;&lt;/span&gt;]: &lt;span class="fl"&gt;0.6&lt;/span&gt;}
            accuracy_, _ &lt;span class="op"&gt;=&lt;/span&gt; sess.run([g[&lt;span class="st"&gt;&amp;#39;accuracy&amp;#39;&lt;/span&gt;], g[&lt;span class="st"&gt;&amp;#39;ts&amp;#39;&lt;/span&gt;]], feed_dict&lt;span class="op"&gt;=&lt;/span&gt;feed)
            accuracy &lt;span class="op"&gt;+=&lt;/span&gt; accuracy_

            &lt;span class="cf"&gt;if&lt;/span&gt; tr.epochs &lt;span class="op"&gt;&amp;gt;&lt;/span&gt; current_epoch:
                current_epoch &lt;span class="op"&gt;+=&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;
                tr_losses.append(accuracy &lt;span class="op"&gt;/&lt;/span&gt; step)
                step, accuracy &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;, &lt;span class="dv"&gt;0&lt;/span&gt;

                &lt;span class="co"&gt;#eval test set&lt;/span&gt;
                te_epoch &lt;span class="op"&gt;=&lt;/span&gt; te.epochs
                &lt;span class="cf"&gt;while&lt;/span&gt; te.epochs &lt;span class="op"&gt;==&lt;/span&gt; te_epoch:
                    step &lt;span class="op"&gt;+=&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;
                    batch &lt;span class="op"&gt;=&lt;/span&gt; te.next_batch(batch_size)
                    feed &lt;span class="op"&gt;=&lt;/span&gt; {g[&lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;]: batch[&lt;span class="dv"&gt;0&lt;/span&gt;], g[&lt;span class="st"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;]: batch[&lt;span class="dv"&gt;1&lt;/span&gt;], g[&lt;span class="st"&gt;&amp;#39;seqlen&amp;#39;&lt;/span&gt;]: batch[&lt;span class="dv"&gt;2&lt;/span&gt;]}
                    accuracy_ &lt;span class="op"&gt;=&lt;/span&gt; sess.run([g[&lt;span class="st"&gt;&amp;#39;accuracy&amp;#39;&lt;/span&gt;]], feed_dict&lt;span class="op"&gt;=&lt;/span&gt;feed)[&lt;span class="dv"&gt;0&lt;/span&gt;]
                    accuracy &lt;span class="op"&gt;+=&lt;/span&gt; accuracy_

                te_losses.append(accuracy &lt;span class="op"&gt;/&lt;/span&gt; step)
                step, accuracy &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;0&lt;/span&gt;
                &lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;Accuracy after epoch&amp;quot;&lt;/span&gt;, current_epoch, &lt;span class="st"&gt;&amp;quot; - tr:&amp;quot;&lt;/span&gt;, tr_losses[&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;], &lt;span class="st"&gt;&amp;quot;- te:&amp;quot;&lt;/span&gt;, te_losses[&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;])

    &lt;span class="cf"&gt;return&lt;/span&gt; tr_losses, te_losses&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;g &lt;span class="op"&gt;=&lt;/span&gt; build_graph()
tr_losses, te_losses &lt;span class="op"&gt;=&lt;/span&gt; train_graph(g)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Accuracy after epoch 1  - tr: 0.319347791963 - te: 0.351068906904
Accuracy after epoch 2  - tr: 0.355731238225 - te: 0.357366258375
Accuracy after epoch 3  - tr: 0.361505161451 - te: 0.358625811348
Accuracy after epoch 4  - tr: 0.363629598859 - te: 0.359358642169
Accuracy after epoch 5  - tr: 0.365078599278 - te: 0.358609453518
Accuracy after epoch 6  - tr: 0.365907767689 - te: 0.359358642169
Accuracy after epoch 7  - tr: 0.367192406322 - te: 0.359833019263
Accuracy after epoch 8  - tr: 0.368336397059 - te: 0.360304124791
Accuracy after epoch 9  - tr: 0.369028188455 - te: 0.360434987437
Accuracy after epoch 10  - tr: 0.37021715381 - te: 0.36041535804&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After 10 epochs, our network has an accuracy of about 36%, about twice as good as chance–not bad for predicting age and gender from a single sentence!&lt;/p&gt;
&lt;h2 id="improving-training-speed-using-bucketing"&gt;Improving training speed using bucketing&lt;/h2&gt;
&lt;p&gt;For the network above, we used a batch_size of 256. But each example in the batch had a different length ranging from 5 to 30. As the maximum length for each batch is usually very close to 30, short sequences required a lot of padding (e.g., all sequences of length 5 in the batch are padded with up to 25 zeros). Given this dataset, each batch is padded with an average of over 3000 zeros, or over 10 padding symbols per sample:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;tr &lt;span class="op"&gt;=&lt;/span&gt; PaddedDataIterator(train)
padding &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;
&lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;100&lt;/span&gt;):
    lengths &lt;span class="op"&gt;=&lt;/span&gt; tr.next_batch(&lt;span class="dv"&gt;256&lt;/span&gt;)[&lt;span class="dv"&gt;2&lt;/span&gt;].values
    max_len &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;max&lt;/span&gt;(lengths)
    padding &lt;span class="op"&gt;+=&lt;/span&gt; np.&lt;span class="bu"&gt;sum&lt;/span&gt;(max_len &lt;span class="op"&gt;-&lt;/span&gt; lengths)
&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;Average padding / batch:&amp;quot;&lt;/span&gt;, padding&lt;span class="op"&gt;/&lt;/span&gt;&lt;span class="dv"&gt;100&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Average padding / batch: 3279.9&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This leads to a lot of excess computation, and we can improve upon it by “bucketing” our training samples. If we select our batches such that the lengths of the samples in each batch are within, say, 5 of each other, then the amount of padding in a batch of 256 is bounded by 256 * 5 = 1280. This would make our worst case outcome more than twice as good as previous average case outcome.&lt;/p&gt;
&lt;p&gt;To take advantage of bucketing, we simply modify our DataIterator. There are many ways one might implement this, but the key point to keep in mind is that we should not “bias” the order in which different sequence lengths are sampled any more than necessary to achieve bucketing. E.g., sorting our data by sequence length might seem like a good solution, but then each epoch would be trained on short sequences before longer sequences, which could harm results. Here is one solution, which uses a predetermined batch_size:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;class&lt;/span&gt; BucketedDataIterator():
    &lt;span class="kw"&gt;def&lt;/span&gt; &lt;span class="fu"&gt;__init__&lt;/span&gt;(&lt;span class="va"&gt;self&lt;/span&gt;, df, num_buckets &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;5&lt;/span&gt;):
        df &lt;span class="op"&gt;=&lt;/span&gt; df.sort_values(&lt;span class="st"&gt;&amp;#39;length&amp;#39;&lt;/span&gt;).reset_index(drop&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)
        &lt;span class="va"&gt;self&lt;/span&gt;.size &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;len&lt;/span&gt;(df) &lt;span class="op"&gt;/&lt;/span&gt; num_buckets
        &lt;span class="va"&gt;self&lt;/span&gt;.dfs &lt;span class="op"&gt;=&lt;/span&gt; []
        &lt;span class="cf"&gt;for&lt;/span&gt; bucket &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(num_buckets):
            &lt;span class="va"&gt;self&lt;/span&gt;.dfs.append(df.ix[bucket&lt;span class="op"&gt;*&lt;/span&gt;&lt;span class="va"&gt;self&lt;/span&gt;.size: (bucket&lt;span class="op"&gt;+&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;)&lt;span class="op"&gt;*&lt;/span&gt;&lt;span class="va"&gt;self&lt;/span&gt;.size &lt;span class="op"&gt;-&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;])
        &lt;span class="va"&gt;self&lt;/span&gt;.num_buckets &lt;span class="op"&gt;=&lt;/span&gt; num_buckets

        &lt;span class="co"&gt;# cursor[i] will be the cursor for the ith bucket&lt;/span&gt;
        &lt;span class="va"&gt;self&lt;/span&gt;.cursor &lt;span class="op"&gt;=&lt;/span&gt; np.array([&lt;span class="dv"&gt;0&lt;/span&gt;] &lt;span class="op"&gt;*&lt;/span&gt; num_buckets)
        &lt;span class="va"&gt;self&lt;/span&gt;.shuffle()

        &lt;span class="va"&gt;self&lt;/span&gt;.epochs &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;

    &lt;span class="kw"&gt;def&lt;/span&gt; shuffle(&lt;span class="va"&gt;self&lt;/span&gt;):
        &lt;span class="co"&gt;#sorts dataframe by sequence length, but keeps it random within the same length&lt;/span&gt;
        &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="va"&gt;self&lt;/span&gt;.num_buckets):
            &lt;span class="va"&gt;self&lt;/span&gt;.dfs[i] &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="va"&gt;self&lt;/span&gt;.dfs[i].sample(frac&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;).reset_index(drop&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)
            &lt;span class="va"&gt;self&lt;/span&gt;.cursor[i] &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;

    &lt;span class="kw"&gt;def&lt;/span&gt; next_batch(&lt;span class="va"&gt;self&lt;/span&gt;, n):
        &lt;span class="cf"&gt;if&lt;/span&gt; np.&lt;span class="bu"&gt;any&lt;/span&gt;(&lt;span class="va"&gt;self&lt;/span&gt;.cursor&lt;span class="op"&gt;+&lt;/span&gt;n&lt;span class="op"&gt;+&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="op"&gt;&amp;gt;&lt;/span&gt; &lt;span class="va"&gt;self&lt;/span&gt;.size):
            &lt;span class="va"&gt;self&lt;/span&gt;.epochs &lt;span class="op"&gt;+=&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;
            &lt;span class="va"&gt;self&lt;/span&gt;.shuffle()

        i &lt;span class="op"&gt;=&lt;/span&gt; np.random.randint(&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="va"&gt;self&lt;/span&gt;.num_buckets)

        res &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="va"&gt;self&lt;/span&gt;.dfs[i].ix[&lt;span class="va"&gt;self&lt;/span&gt;.cursor[i]:&lt;span class="va"&gt;self&lt;/span&gt;.cursor[i]&lt;span class="op"&gt;+&lt;/span&gt;n&lt;span class="dv"&gt;-1&lt;/span&gt;]
        &lt;span class="va"&gt;self&lt;/span&gt;.cursor[i] &lt;span class="op"&gt;+=&lt;/span&gt; n

        &lt;span class="co"&gt;# Pad sequences with 0s so they are all the same length&lt;/span&gt;
        maxlen &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;max&lt;/span&gt;(res[&lt;span class="st"&gt;&amp;#39;length&amp;#39;&lt;/span&gt;])
        x &lt;span class="op"&gt;=&lt;/span&gt; np.zeros([n, maxlen], dtype&lt;span class="op"&gt;=&lt;/span&gt;np.int32)
        &lt;span class="cf"&gt;for&lt;/span&gt; i, x_i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;enumerate&lt;/span&gt;(x):
            x_i[:res[&lt;span class="st"&gt;&amp;#39;length&amp;#39;&lt;/span&gt;].values[i]] &lt;span class="op"&gt;=&lt;/span&gt; res[&lt;span class="st"&gt;&amp;#39;as_numbers&amp;#39;&lt;/span&gt;].values[i]

        &lt;span class="cf"&gt;return&lt;/span&gt; x, res[&lt;span class="st"&gt;&amp;#39;gender&amp;#39;&lt;/span&gt;]&lt;span class="op"&gt;*&lt;/span&gt;&lt;span class="dv"&gt;3&lt;/span&gt; &lt;span class="op"&gt;+&lt;/span&gt; res[&lt;span class="st"&gt;&amp;#39;age_bracket&amp;#39;&lt;/span&gt;], res[&lt;span class="st"&gt;&amp;#39;length&amp;#39;&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With this modified iterator, we improve the average padding / batch by a factor of about 6:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;tr &lt;span class="op"&gt;=&lt;/span&gt; BucketedDataIterator(train, &lt;span class="dv"&gt;5&lt;/span&gt;)
padding &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;
&lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;100&lt;/span&gt;):
    lengths &lt;span class="op"&gt;=&lt;/span&gt; tr.next_batch(&lt;span class="dv"&gt;256&lt;/span&gt;)[&lt;span class="dv"&gt;2&lt;/span&gt;].values
    max_len &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;max&lt;/span&gt;(lengths)
    padding &lt;span class="op"&gt;+=&lt;/span&gt; np.&lt;span class="bu"&gt;sum&lt;/span&gt;(max_len &lt;span class="op"&gt;-&lt;/span&gt; lengths)
&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;Average padding / batch:&amp;quot;&lt;/span&gt;, padding&lt;span class="op"&gt;/&lt;/span&gt;&lt;span class="dv"&gt;100&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Average padding / batch: 573.49&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can also compare the difference in training speed, and observe that this bucketing strategy speeds up training by about 30%:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="im"&gt;from&lt;/span&gt; time &lt;span class="im"&gt;import&lt;/span&gt; time
g &lt;span class="op"&gt;=&lt;/span&gt; build_graph()
t &lt;span class="op"&gt;=&lt;/span&gt; time()
tr_losses, te_losses &lt;span class="op"&gt;=&lt;/span&gt; train_graph(g, num_epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;, iterator&lt;span class="op"&gt;=&lt;/span&gt;PaddedDataIterator)
&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;Total time for 1 epoch with PaddedDataIterator:&amp;quot;&lt;/span&gt;, time() &lt;span class="op"&gt;-&lt;/span&gt; t)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Accuracy after epoch 1  - tr: 0.310819936427 - te: 0.341703713389
Total time for 1 epoch with PaddedDataIterator: 100.90330529212952&lt;/code&gt;&lt;/pre&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;g &lt;span class="op"&gt;=&lt;/span&gt; build_graph()
t &lt;span class="op"&gt;=&lt;/span&gt; time()
tr_losses, te_losses &lt;span class="op"&gt;=&lt;/span&gt; train_graph(g, num_epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;, iterator&lt;span class="op"&gt;=&lt;/span&gt;BucketedDataIterator)
&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;Total time for 1 epoch with BucketedDataIterator:&amp;quot;&lt;/span&gt;, time() &lt;span class="op"&gt;-&lt;/span&gt; t)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Accuracy after epoch 1  - tr: 0.31359524197 - te: 0.349176362254
Total time for 1 epoch with BucketedDataIterator: 71.45360088348389&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note how easy it was to move to a bucketed model–all we had to do was change our data generator. This was made possible by the use of a partially-known shape for our input placeholder, with the num_steps dimension unknown. Contrast this to the more complicated approach in Tensorflow’s &lt;a href="https://www.tensorflow.org/versions/r0.11/tutorials/seq2seq/index.html"&gt;seq2seq tutorial&lt;/a&gt;, which builds a different graph for each of four buckets.&lt;/p&gt;
&lt;h4 id="a-note-on-awkward-sequence-lengths"&gt;A note on awkward sequence lengths&lt;/h4&gt;
&lt;p&gt;Suppose we had a dataset with awkward sequence lengths that made even a bucketed approach inefficient. For example, we might have lots of very short sequences of lengths 1, 2 and 3. Alternatively, we might have a few very long sequences among our shorter ones; we want to propagate the internal state forward through time for the long sequences, but don’t have enough of them to train efficiently in parallel. One solution in both of these scenarios is to combine short sequences into longer ones, but have the internal state of the RNN reset in between each such sequence. I believe this is not possible to do with Tensorflow’s default RNN functions (e.g., &lt;code&gt;dynamic_rnn&lt;/code&gt;), so if you’re looking for a way to do this, I would look into writing a custom RNN method using &lt;code&gt;tf.scan&lt;/code&gt;. I show how to use &lt;code&gt;tf.scan&lt;/code&gt; to build a custom RNN in my post, &lt;a href="http://r2rt.com/recurrent-neural-networks-in-tensorflow-ii.html"&gt;Recurrent Neural Networks in Tensorflow II&lt;/a&gt;. With the right accumulator function, you could program in the state resets dynamically based on either a special PAD symbol, or an auxiliary input sequence that indicates where the state should be reset.&lt;/p&gt;
&lt;h2 id="a-basic-model-for-sequence-to-sequence-learning"&gt;A basic model for sequence to sequence learning&lt;/h2&gt;
&lt;p&gt;Finally, we extend our sequence classification model to do &lt;strong&gt;sequence-to-sequence learning&lt;/strong&gt;. We’ll use the same dataset, but instead of having our model guess the author’s age bracket and gender at the end of the sequence (i.e., only once), we’ll have it guess at every timestep.&lt;/p&gt;
&lt;p&gt;The added wrinkle when moving to a sequence-to-sequence model is that we need to make sure that time-steps with a PAD symbol do not contribute to our loss, since they are just there as filler. We do so by zeroing the loss at these time steps, which is known as applying a “mask” or “masking” the loss. This is achieved by pointwise multiplying the loss tensor (with each entry representing a time step), by a tensor of 1s and 0s, where 1s represent valid steps and 0s represent PAD steps. A similar modification is made to the “accuracy” calculation below, as noted in the comments.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; build_seq2seq_graph(
    vocab_size &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;len&lt;/span&gt;(vocab),
    state_size &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;64&lt;/span&gt;,
    batch_size &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;256&lt;/span&gt;,
    num_classes &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;6&lt;/span&gt;):

    reset_graph()

    &lt;span class="co"&gt;# Placeholders&lt;/span&gt;
    x &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(tf.int32, [batch_size, &lt;span class="va"&gt;None&lt;/span&gt;]) &lt;span class="co"&gt;# [batch_size, num_steps]&lt;/span&gt;
    seqlen &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(tf.int32, [batch_size])
    y &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(tf.int32, [batch_size])
    keep_prob &lt;span class="op"&gt;=&lt;/span&gt; tf.constant(&lt;span class="fl"&gt;1.0&lt;/span&gt;)

    &lt;span class="co"&gt;# Tile the target indices&lt;/span&gt;
    &lt;span class="co"&gt;# (in a regular seq2seq model, our targets placeholder might have this shape)&lt;/span&gt;
    y_ &lt;span class="op"&gt;=&lt;/span&gt; tf.tile(tf.expand_dims(y, &lt;span class="dv"&gt;1&lt;/span&gt;), [&lt;span class="dv"&gt;1&lt;/span&gt;, tf.shape(x)[&lt;span class="dv"&gt;1&lt;/span&gt;]]) &lt;span class="co"&gt;# [batch_size, num_steps]&lt;/span&gt;

    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="co"&gt;    Create a mask that we will use for the cost function&lt;/span&gt;

&lt;span class="co"&gt;    This mask is the same shape as x and y_, and is equal to 1 for all non-PAD time&lt;/span&gt;
&lt;span class="co"&gt;    steps (where a prediction is made), and 0 for all PAD time steps (no pred -&amp;gt; no loss)&lt;/span&gt;
&lt;span class="co"&gt;    The number 30, used when creating the lower_triangle_ones matrix, is the maximum&lt;/span&gt;
&lt;span class="co"&gt;    sequence length in our dataset&lt;/span&gt;
&lt;span class="co"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    lower_triangular_ones &lt;span class="op"&gt;=&lt;/span&gt; tf.constant(np.tril(np.ones([&lt;span class="dv"&gt;30&lt;/span&gt;,&lt;span class="dv"&gt;30&lt;/span&gt;])),dtype&lt;span class="op"&gt;=&lt;/span&gt;tf.float32)
    seqlen_mask &lt;span class="op"&gt;=&lt;/span&gt; tf.&lt;span class="bu"&gt;slice&lt;/span&gt;(tf.gather(lower_triangular_ones, seqlen &lt;span class="op"&gt;-&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;),&lt;span class="op"&gt;\&lt;/span&gt;
                           [&lt;span class="dv"&gt;0&lt;/span&gt;, &lt;span class="dv"&gt;0&lt;/span&gt;], [batch_size, tf.reduce_max(seqlen)])

    &lt;span class="co"&gt;# Embedding layer&lt;/span&gt;
    embeddings &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;embedding_matrix&amp;#39;&lt;/span&gt;, [vocab_size, state_size])
    rnn_inputs &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.embedding_lookup(embeddings, x)

    &lt;span class="co"&gt;# RNN&lt;/span&gt;
    cell &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.rnn_cell.GRUCell(state_size)
    init_state &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;init_state&amp;#39;&lt;/span&gt;, [&lt;span class="dv"&gt;1&lt;/span&gt;, state_size],
                                 initializer&lt;span class="op"&gt;=&lt;/span&gt;tf.constant_initializer(&lt;span class="fl"&gt;0.0&lt;/span&gt;))
    init_state &lt;span class="op"&gt;=&lt;/span&gt; tf.tile(init_state, [batch_size, &lt;span class="dv"&gt;1&lt;/span&gt;])
    rnn_outputs, final_state &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.dynamic_rnn(cell, rnn_inputs, sequence_length&lt;span class="op"&gt;=&lt;/span&gt;seqlen,
                                                 initial_state&lt;span class="op"&gt;=&lt;/span&gt;init_state)

    &lt;span class="co"&gt;# Add dropout, as the model otherwise quickly overfits&lt;/span&gt;
    rnn_outputs &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.dropout(rnn_outputs, keep_prob)

    &lt;span class="co"&gt;#reshape rnn_outputs and y&lt;/span&gt;
    rnn_outputs &lt;span class="op"&gt;=&lt;/span&gt; tf.reshape(rnn_outputs, [&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;, state_size])
    y_reshaped &lt;span class="op"&gt;=&lt;/span&gt; tf.reshape(y_, [&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;])

    &lt;span class="co"&gt;# Softmax layer&lt;/span&gt;
    &lt;span class="cf"&gt;with&lt;/span&gt; tf.variable_scope(&lt;span class="st"&gt;&amp;#39;softmax&amp;#39;&lt;/span&gt;):
        W &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;W&amp;#39;&lt;/span&gt;, [state_size, num_classes])
        b &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;, [num_classes], initializer&lt;span class="op"&gt;=&lt;/span&gt;tf.constant_initializer(&lt;span class="fl"&gt;0.0&lt;/span&gt;))
    logits &lt;span class="op"&gt;=&lt;/span&gt; tf.matmul(rnn_outputs, W) &lt;span class="op"&gt;+&lt;/span&gt; b

    preds &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.softmax(logits)

    &lt;span class="co"&gt;# To calculate the number correct, we want to count padded steps as incorrect&lt;/span&gt;
    correct &lt;span class="op"&gt;=&lt;/span&gt; tf.cast(tf.equal(tf.cast(tf.argmax(preds,&lt;span class="dv"&gt;1&lt;/span&gt;),tf.int32), y_reshaped),tf.int32) &lt;span class="op"&gt;*\&lt;/span&gt;
                tf.cast(tf.reshape(seqlen_mask, [&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;]),tf.int32)

    &lt;span class="co"&gt;# To calculate accuracy we want to divide by the number of non-padded time-steps,&lt;/span&gt;
    &lt;span class="co"&gt;# rather than taking the mean&lt;/span&gt;
    accuracy &lt;span class="op"&gt;=&lt;/span&gt; tf.reduce_sum(tf.cast(correct, tf.float32)) &lt;span class="op"&gt;/&lt;/span&gt; tf.reduce_sum(tf.cast(seqlen, tf.float32))

    loss &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.sparse_softmax_cross_entropy_with_logits(logits, y_reshaped)
    loss &lt;span class="op"&gt;=&lt;/span&gt; loss &lt;span class="op"&gt;*&lt;/span&gt; tf.reshape(seqlen_mask, [&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;])

    &lt;span class="co"&gt;# To calculate average loss, we need to divide by number of non-padded time-steps,&lt;/span&gt;
    &lt;span class="co"&gt;# rather than taking the mean&lt;/span&gt;
    loss &lt;span class="op"&gt;=&lt;/span&gt; tf.reduce_sum(loss) &lt;span class="op"&gt;/&lt;/span&gt; tf.reduce_sum(seqlen_mask)

    train_step &lt;span class="op"&gt;=&lt;/span&gt; tf.train.AdamOptimizer(&lt;span class="fl"&gt;1e-4&lt;/span&gt;).minimize(loss)

    &lt;span class="cf"&gt;return&lt;/span&gt; {
        &lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;: x,
        &lt;span class="st"&gt;&amp;#39;seqlen&amp;#39;&lt;/span&gt;: seqlen,
        &lt;span class="st"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;: y,
        &lt;span class="st"&gt;&amp;#39;dropout&amp;#39;&lt;/span&gt;: keep_prob,
        &lt;span class="st"&gt;&amp;#39;loss&amp;#39;&lt;/span&gt;: loss,
        &lt;span class="st"&gt;&amp;#39;ts&amp;#39;&lt;/span&gt;: train_step,
        &lt;span class="st"&gt;&amp;#39;preds&amp;#39;&lt;/span&gt;: preds,
        &lt;span class="st"&gt;&amp;#39;accuracy&amp;#39;&lt;/span&gt;: accuracy
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;g &lt;span class="op"&gt;=&lt;/span&gt; build_seq2seq_graph()
tr_losses, te_losses &lt;span class="op"&gt;=&lt;/span&gt; train_graph(g, iterator&lt;span class="op"&gt;=&lt;/span&gt;BucketedDataIterator)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Accuracy after epoch 1  - tr: 0.292434578401 - te: 0.316306242085
Accuracy after epoch 2  - tr: 0.320437548276 - te: 0.322733865921
Accuracy after epoch 3  - tr: 0.325227848205 - te: 0.322927395211
Accuracy after epoch 4  - tr: 0.327002136049 - te: 0.324078651696
Accuracy after epoch 5  - tr: 0.327847927489 - te: 0.324469006651
Accuracy after epoch 6  - tr: 0.328276157813 - te: 0.324198486081
Accuracy after epoch 7  - tr: 0.329078430968 - te: 0.324715245167
Accuracy after epoch 8  - tr: 0.330095707002 - te: 0.325317926384
Accuracy after epoch 9  - tr: 0.330612316872 - te: 0.32550007953
Accuracy after epoch 10  - tr: 0.331520609485 - te: 0.326069803531&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As expected, our sequence-to-sequence model has slightly worse accuracy than our sequence classification model (because it’s early guesses are nearly random and reduce the accuracy).&lt;/p&gt;
&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;In this post, we learned four concepts, all related to building RNNs that work with variable length sequences. First, we learned how to pad input sequences so that we can feed in a single zero-padded input tensor. Second, we learned how to get the last relevant output in a sequence classification model. Third, we learned how to use bucketing to get a significantly boost in training time. Finally, we learned how to “mask” our loss function so that we can train sequence-to-sequence models with variable length sequences.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</content></entry><entry><title>Binary Stochastic Neurons in Tensorflow</title><link href="https://r2rt.com/binary-stochastic-neurons-in-tensorflow.html" rel="alternate"></link><published>2016-09-24T00:00:00-04:00</published><updated>2016-09-24T00:00:00-04:00</updated><author><name>Silviu Pitis</name></author><id>tag:r2rt.com,2016-09-24:/binary-stochastic-neurons-in-tensorflow.html</id><summary type="html">In this post, I introduce and discuss binary stochastic neurons, implement trainable binary stochastic neurons in Tensorflow, and conduct several simple experiments on the MNIST dataset to get a feel for their behavior. Binary stochastic neurons offer two advantages over real-valued neurons: they can act as a regularizer and they enable conditional computation by enabling a network to make yes/no decisions. Conditional computation opens the door to new and exciting neural network architectures, such as the choice of experts architecture and heirarchical multiscale neural networks.</summary><content type="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;meta name="generator" content="pandoc"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes"&gt;
  &lt;title&gt;&lt;/title&gt;
  &lt;style type="text/css"&gt;code{white-space: pre;}&lt;/style&gt;
  &lt;style type="text/css"&gt;
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code &gt; span.kw { color: #007020; font-weight: bold; } /* Keyword */
code &gt; span.dt { color: #902000; } /* DataType */
code &gt; span.dv { color: #40a070; } /* DecVal */
code &gt; span.bn { color: #40a070; } /* BaseN */
code &gt; span.fl { color: #40a070; } /* Float */
code &gt; span.ch { color: #4070a0; } /* Char */
code &gt; span.st { color: #4070a0; } /* String */
code &gt; span.co { color: #60a0b0; font-style: italic; } /* Comment */
code &gt; span.ot { color: #007020; } /* Other */
code &gt; span.al { color: #ff0000; font-weight: bold; } /* Alert */
code &gt; span.fu { color: #06287e; } /* Function */
code &gt; span.er { color: #ff0000; font-weight: bold; } /* Error */
code &gt; span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code &gt; span.cn { color: #880000; } /* Constant */
code &gt; span.sc { color: #4070a0; } /* SpecialChar */
code &gt; span.vs { color: #4070a0; } /* VerbatimString */
code &gt; span.ss { color: #bb6688; } /* SpecialString */
code &gt; span.im { } /* Import */
code &gt; span.va { color: #19177c; } /* Variable */
code &gt; span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code &gt; span.op { color: #666666; } /* Operator */
code &gt; span.bu { } /* BuiltIn */
code &gt; span.ex { } /* Extension */
code &gt; span.pp { color: #bc7a00; } /* Preprocessor */
code &gt; span.at { color: #7d9029; } /* Attribute */
code &gt; span.do { color: #ba2121; font-style: italic; } /* Documentation */
code &gt; span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code &gt; span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code &gt; span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  &lt;/style&gt;
  &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"&gt;&lt;/script&gt;
  &lt;!--[if lt IE 9]&gt;
    &lt;script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"&gt;&lt;/script&gt;
  &lt;![endif]--&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;In this post, I introduce and discuss binary stochastic neurons, implement trainable binary stochastic neurons in Tensorflow, and conduct several simple experiments on the MNIST dataset to get a feel for their behavior. Binary stochastic neurons offer two advantages over real-valued neurons: they can act as a regularizer and they enable conditional computation by enabling a network to make yes/no decisions. Conditional computation opens the door to new and exciting neural network architectures, such as the choice of experts architecture and heirarchical multiscale neural networks, which I plan to discuss in future posts.&lt;/p&gt;
&lt;h3 id="the-binary-stochastic-neuron"&gt;The binary stochastic neuron&lt;/h3&gt;
&lt;p&gt;A binary stochastic neuron is a neuron with a noisy output: some proportion &lt;span class="math inline"&gt;\(p\)&lt;/span&gt; of the time it outputs 1, otherwise 0. An easy way to turn a real-valued input, &lt;span class="math inline"&gt;\(a\)&lt;/span&gt;, into this proportion, &lt;span class="math inline"&gt;\(p\)&lt;/span&gt;, is to set &lt;span class="math inline"&gt;\(p = \text{sigm}(a)\)&lt;/span&gt;, where &lt;span class="math inline"&gt;\(\text{sigm}\)&lt;/span&gt; is the logistic sigmoid, &lt;span class="math inline"&gt;\(\text{sigm}(x) = \frac{1}{1 + \exp(-x)}\)&lt;/span&gt;. Thus, we define the binary stochastic neuron, &lt;span class="math inline"&gt;\(\text{BSN}\)&lt;/span&gt;, as:&lt;/p&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[\text{BSN}(a) = \textbf{1}_{z\ \lt\ \text{sigm}(a)}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;where &lt;span class="math inline"&gt;\(\textbf{1}_{x}\)&lt;/span&gt; is the &lt;a href="https://en.wikipedia.org/wiki/Indicator_function"&gt;indicator function&lt;/a&gt; on the truth value of &lt;span class="math inline"&gt;\(x\)&lt;/span&gt; and &lt;span class="math inline"&gt;\(z \sim U[0,1]\)&lt;/span&gt;.&lt;/p&gt;
&lt;h3 id="advantages-of-the-binary-stochastic-neuron"&gt;Advantages of the binary stochastic neuron&lt;/h3&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;A binary stochastic neuron is a noisy modification of the logistic sigmoid: instead of outputting &lt;span class="math inline"&gt;\(p\)&lt;/span&gt;, it outputs 1 with probability &lt;span class="math inline"&gt;\(p\)&lt;/span&gt; and 0 otherwise. Noise generally serves as a regularizer (see, e.g., &lt;a href="http://www.jmlr.org/papers/v15/srivastava14a.html"&gt;Srivastava et al. (2014)&lt;/a&gt; and &lt;a href="https://arxiv.org/abs/1511.06807"&gt;Neelakantan et al. (2015)&lt;/a&gt;), and so we might expect the same from binary stochastic neurons as compared to the logistic neurons. Indeed, this is the claimed “unpublished result” from the end of &lt;a href="https://www.youtube.com/watch?v=LN0xtUuJsEI&amp;amp;list=PLoRl3Ht4JOcdU872GhiYWf6jwrk_SNhz9&amp;amp;index=41"&gt;Hinton et al.’s Coursera Lecture 9c&lt;/a&gt;, which I demonstrate empirically in this post.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Further, by enabling networks to make binary decisions, the binary stochastic neuron allows for conditional computation. This opens the door to some interesting new architectures. For example, instead of a mixture of experts architecture, which weights the outputs of several “expert” sub-networks and requires that all subnetworks be computed, we could use a &lt;em&gt;choice&lt;/em&gt; of experts architecture, which conditionally uses expert sub-networks as needed. This architecture is implicitly proposed in &lt;a href="https://arxiv.org/abs/1308.3432"&gt;Bengio et al. (2013)&lt;/a&gt;, wherein the experiments use a choice of expert units architecture (i.e., a gated architecture where gates must be 1 or 0). Another example, proposed in &lt;a href="https://arxiv.org/abs/1308.3432"&gt;Bengio et al. (2013)&lt;/a&gt; and implemented by &lt;a href="https://arxiv.org/abs/1609.01704"&gt;Chung et al. (2016)&lt;/a&gt;, is the Heirarchical Multiscale Recurrent Neural Network (HM-RNN) architecture, which achieves great results on language modelling tasks.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="training-the-binary-stochastic-neuron"&gt;Training the binary stochastic neuron&lt;/h3&gt;
&lt;p&gt;For any single trial, the binary stochastic neuron generally has a derivative of 0 and cannot be trained by simple backpropagation. To see this, consider that if &lt;span class="math inline"&gt;\(z \neq \text{sigm}(a)\)&lt;/span&gt; in the &lt;span class="math inline"&gt;\(\text{BSN}\)&lt;/span&gt; function above, there exists a &lt;a href="https://en.wikipedia.org/wiki/Neighbourhood_(mathematics)"&gt;neighborhood&lt;/a&gt; around &lt;span class="math inline"&gt;\(a\)&lt;/span&gt; such that the output of &lt;span class="math inline"&gt;\(\text{BSN}(a)\)&lt;/span&gt; is unchanged (i.e., the derivative is 0). We get around this by &lt;em&gt;estimating&lt;/em&gt; the derivative with respect to the &lt;em&gt;expected&lt;/em&gt; loss, rather than calculating the derivative with respect to the outcome of a single trial. We can only estimate this derivative, because in any given trial, we only see the loss value with respect to the given noise – we don’t know what the loss would have been given another level of noise. We call a method that provides such an estimate an “estimator”. An estimator is &lt;em&gt;unbiased&lt;/em&gt; if the expectation of its estimate equals the expectation of the derivative it is estimating; otherwise, it is &lt;em&gt;biased&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;In this post we implement the two estimators discussed in &lt;a href="https://arxiv.org/abs/1308.3432"&gt;Bengio et al. (2013)&lt;/a&gt;:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;The REINFORCE estimator, which is an unbiased estimator and a special case of the REINFORCE algorithm discussed in &lt;a href="http://link.springer.com/article/10.1007/BF00992696"&gt;Williams (1992)&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The REINFORCE estimator estimates the expectation of &lt;span class="math inline"&gt;\(\frac{\partial L}{\partial a}\)&lt;/span&gt; as &lt;span class="math inline"&gt;\((\text{BSN}(a) - \text{sigm}(a))(L - c)\)&lt;/span&gt;, where &lt;span class="math inline"&gt;\(c\)&lt;/span&gt; is a constant. &lt;a href="https://arxiv.org/abs/1308.3432"&gt;Bengio et al. (2013)&lt;/a&gt; proves that:&lt;/p&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[\mathbb{E}[(\text{BSN}(a) - \text{sigm}(a))(L - c)] = \mathbb{E}\big[\frac{\partial L}{\partial a}\big].\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://arxiv.org/abs/1308.3432"&gt;Bengio et al. (2013)&lt;/a&gt; further shows that to minimize the variance of the estimation, we choose:&lt;/p&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[c = \bar L = \frac{\mathbb{E}[\text{BSN}(a) - \text{sigm}(a))^2L]}{\mathbb{E}[\text{BSN}(a) - \text{sigm}(a))^2]}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;which we can practically implement by keeping track of the numerator and denominator as a moving average. Interestingly, the REINFORCE estimator does not require any backpropagated loss gradient–it operates directly on the loss of the network.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The straight through (ST) estimator, which is a biased estimator that was first proposed by &lt;a href="https://www.youtube.com/watch?v=LN0xtUuJsEI&amp;amp;list=PLoRl3Ht4JOcdU872GhiYWf6jwrk_SNhz9&amp;amp;index=41"&gt;Hinton et al.’s Coursera Lecture 9c&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The ST estimator simply replaces the derivative factor used during backpropagation, &lt;span class="math inline"&gt;\(\frac{d\text{BSN}(a)}{da} = 0\)&lt;/span&gt;, with the identity function &lt;span class="math inline"&gt;\(\frac{d\text{BSN}(a)}{da} = 1\)&lt;/span&gt;.&lt;a href="#fn1" class="footnoteRef" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; A variant of the ST estimator replaces the derivative factor with &lt;span class="math inline"&gt;\(\frac{d\text{BSN}(a)}{da} = \frac{d\text{sigm}(a)}{da}\)&lt;/span&gt;. Whereas &lt;a href="https://arxiv.org/abs/1308.3432"&gt;Bengio et al. (2013)&lt;/a&gt; found that the former is more effective, the latter variant was successfully used in &lt;a href="https://arxiv.org/abs/1609.01704"&gt;Chung et al. (2016)&lt;/a&gt; in combination with the &lt;em&gt;slope-annealing trick&lt;/em&gt; and deterministic binary neurons (which we will see perform very similarly to, if not better than, stochastic binary neurons when used with slope-annealing). The slope-anealing trick modifies &lt;span class="math inline"&gt;\(\text{BSN}(a)\)&lt;/span&gt; by first multiplying the input &lt;span class="math inline"&gt;\(a\)&lt;/span&gt; by a slope &lt;span class="math inline"&gt;\(m\)&lt;/span&gt; as follows:&lt;/p&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[\text{BSN}_{\text{SL}(m)}(a) = \textbf{1}_{z \lt \text{sigm}(ma)}.\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Then, we increase the slope as training progresses and use &lt;span class="math inline"&gt;\(\frac{d\text{BSN}_{\text{SL}(m)}(a)}{da} = \frac{d\text{sigm}(ma)}{da}\)&lt;/span&gt; when computing the gradient. The idea behind this is that as the slope increases, the logistic sigmoid approaches a step function, so that it’s derivative approaches the true derivative. All three variants are tested in this post.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="implementing-the-binary-stochastic-neuron-in-tensorflow"&gt;Implementing the binary stochastic neuron in Tensorflow&lt;/h3&gt;
&lt;p&gt;The tricky part of implementing a binary stochastic neuron in Tensorflow is not the forward computation, but the implementation of the REINFORCE and straight through estimators. Each requires replacing the gradient of one or more Tensorflow operations. The &lt;a href="https://www.tensorflow.org/how_tos/adding_an_op/"&gt;official approach&lt;/a&gt; to this is to write a new op in C++, which seems wholly unnecessary. There are, however, two workable unofficial approaches, one of which is &lt;a href="http://stackoverflow.com/questions/36456436/how-can-i-define-only-the-gradient-for-a-tensorflow-subgraph/36480182"&gt;a trick credited to Sergey Ioffe&lt;/a&gt;, and another that uses &lt;code&gt;gradient_override_map&lt;/code&gt;, an experimental feature of Tensorflow that is documented &lt;a href="https://www.tensorflow.org/api_docs/python/framework/core_graph_data_structures#Graph.gradient_override_map"&gt;here&lt;/a&gt;. We will use &lt;code&gt;gradient_override_map&lt;/code&gt;, which works well for our purposes.&lt;/p&gt;
&lt;h4 id="imports-and-utility-functions"&gt;Imports and Utility Functions&lt;/h4&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="im"&gt;import&lt;/span&gt; numpy &lt;span class="im"&gt;as&lt;/span&gt; np
&lt;span class="im"&gt;import&lt;/span&gt; tensorflow &lt;span class="im"&gt;as&lt;/span&gt; tf
&lt;span class="im"&gt;from&lt;/span&gt; tensorflow.examples.tutorials.mnist &lt;span class="im"&gt;import&lt;/span&gt; input_data
&lt;span class="im"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class="im"&gt;as&lt;/span&gt; plt
&lt;span class="op"&gt;%&lt;/span&gt;matplotlib inline
mnist &lt;span class="op"&gt;=&lt;/span&gt; input_data.read_data_sets(&lt;span class="st"&gt;&amp;#39;MNIST_data&amp;#39;&lt;/span&gt;, one_hot&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)
&lt;span class="im"&gt;from&lt;/span&gt; tensorflow.python.framework &lt;span class="im"&gt;import&lt;/span&gt; ops
&lt;span class="im"&gt;from&lt;/span&gt; enum &lt;span class="im"&gt;import&lt;/span&gt; Enum
&lt;span class="im"&gt;import&lt;/span&gt; seaborn &lt;span class="im"&gt;as&lt;/span&gt; sns
sns.&lt;span class="bu"&gt;set&lt;/span&gt;(color_codes&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)

&lt;span class="kw"&gt;def&lt;/span&gt; reset_graph():
    &lt;span class="cf"&gt;if&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;sess&amp;#39;&lt;/span&gt; &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;globals&lt;/span&gt;() &lt;span class="kw"&gt;and&lt;/span&gt; sess:
        sess.close()
    tf.reset_default_graph()

&lt;span class="kw"&gt;def&lt;/span&gt; layer_linear(inputs, shape, scope&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;linear_layer&amp;#39;&lt;/span&gt;):
    &lt;span class="cf"&gt;with&lt;/span&gt; tf.variable_scope(scope):
        w &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;w&amp;#39;&lt;/span&gt;,shape)
        b &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;,shape[&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;:])
    &lt;span class="cf"&gt;return&lt;/span&gt; tf.matmul(inputs,w) &lt;span class="op"&gt;+&lt;/span&gt; b

&lt;span class="kw"&gt;def&lt;/span&gt; layer_softmax(inputs, shape, scope&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;softmax_layer&amp;#39;&lt;/span&gt;):
    &lt;span class="cf"&gt;with&lt;/span&gt; tf.variable_scope(scope):
        w &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;w&amp;#39;&lt;/span&gt;,shape)
        b &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;,shape[&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;:])
    &lt;span class="cf"&gt;return&lt;/span&gt; tf.nn.softmax(tf.matmul(inputs,w) &lt;span class="op"&gt;+&lt;/span&gt; b)

&lt;span class="kw"&gt;def&lt;/span&gt; accuracy(y, pred):
    correct &lt;span class="op"&gt;=&lt;/span&gt; tf.equal(tf.argmax(y,&lt;span class="dv"&gt;1&lt;/span&gt;), tf.argmax(pred,&lt;span class="dv"&gt;1&lt;/span&gt;))
    &lt;span class="cf"&gt;return&lt;/span&gt; tf.reduce_mean(tf.cast(correct, tf.float32))

&lt;span class="kw"&gt;def&lt;/span&gt; plot_n(data_and_labels, lower_y &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="fl"&gt;0.&lt;/span&gt;, title&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;Learning Curves&amp;quot;&lt;/span&gt;):
    fig, ax &lt;span class="op"&gt;=&lt;/span&gt; plt.subplots()
    &lt;span class="cf"&gt;for&lt;/span&gt; data, label &lt;span class="kw"&gt;in&lt;/span&gt; data_and_labels:
        ax.plot(&lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="bu"&gt;len&lt;/span&gt;(data)&lt;span class="op"&gt;*&lt;/span&gt;&lt;span class="dv"&gt;100&lt;/span&gt;,&lt;span class="dv"&gt;100&lt;/span&gt;),data, label&lt;span class="op"&gt;=&lt;/span&gt;label)
    ax.set_xlabel(&lt;span class="st"&gt;&amp;#39;Training steps&amp;#39;&lt;/span&gt;)
    ax.set_ylabel(&lt;span class="st"&gt;&amp;#39;Accuracy&amp;#39;&lt;/span&gt;)
    ax.set_ylim([lower_y,&lt;span class="dv"&gt;1&lt;/span&gt;])
    ax.set_title(title)
    ax.legend(loc&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;4&lt;/span&gt;)
    plt.show()

&lt;span class="kw"&gt;class&lt;/span&gt; StochasticGradientEstimator(Enum):
    ST &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;
    REINFORCE &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Extracting MNIST_data/train-images-idx3-ubyte.gz
Extracting MNIST_data/train-labels-idx1-ubyte.gz
Extracting MNIST_data/t10k-images-idx3-ubyte.gz
Extracting MNIST_data/t10k-labels-idx1-ubyte.gz&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="binary-stochastic-neuron-with-straight-through-estimator"&gt;Binary stochastic neuron with straight through estimator&lt;/h4&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; binaryRound(x):
    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="co"&gt;    Rounds a tensor whose values are in [0,1] to a tensor with values in {0, 1},&lt;/span&gt;
&lt;span class="co"&gt;    using the straight through estimator for the gradient.&lt;/span&gt;
&lt;span class="co"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    g &lt;span class="op"&gt;=&lt;/span&gt; tf.get_default_graph()

    &lt;span class="cf"&gt;with&lt;/span&gt; ops.name_scope(&lt;span class="st"&gt;&amp;quot;BinaryRound&amp;quot;&lt;/span&gt;) &lt;span class="im"&gt;as&lt;/span&gt; name:
        &lt;span class="cf"&gt;with&lt;/span&gt; g.gradient_override_map({&lt;span class="st"&gt;&amp;quot;Round&amp;quot;&lt;/span&gt;: &lt;span class="st"&gt;&amp;quot;Identity&amp;quot;&lt;/span&gt;}):
            &lt;span class="cf"&gt;return&lt;/span&gt; tf.&lt;span class="bu"&gt;round&lt;/span&gt;(x, name&lt;span class="op"&gt;=&lt;/span&gt;name)

        &lt;span class="co"&gt;# For Tensorflow v0.11 and below use:&lt;/span&gt;
        &lt;span class="co"&gt;#with g.gradient_override_map({&amp;quot;Floor&amp;quot;: &amp;quot;Identity&amp;quot;}):&lt;/span&gt;
        &lt;span class="co"&gt;#    return tf.round(x, name=name)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; bernoulliSample(x):
    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="co"&gt;    Uses a tensor whose values are in [0,1] to sample a tensor with values in {0, 1},&lt;/span&gt;
&lt;span class="co"&gt;    using the straight through estimator for the gradient.&lt;/span&gt;

&lt;span class="co"&gt;    E.g.,:&lt;/span&gt;
&lt;span class="co"&gt;    if x is 0.6, bernoulliSample(x) will be 1 with probability 0.6, and 0 otherwise,&lt;/span&gt;
&lt;span class="co"&gt;    and the gradient will be pass-through (identity).&lt;/span&gt;
&lt;span class="co"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    g &lt;span class="op"&gt;=&lt;/span&gt; tf.get_default_graph()

    &lt;span class="cf"&gt;with&lt;/span&gt; ops.name_scope(&lt;span class="st"&gt;&amp;quot;BernoulliSample&amp;quot;&lt;/span&gt;) &lt;span class="im"&gt;as&lt;/span&gt; name:
        &lt;span class="cf"&gt;with&lt;/span&gt; g.gradient_override_map({&lt;span class="st"&gt;&amp;quot;Ceil&amp;quot;&lt;/span&gt;: &lt;span class="st"&gt;&amp;quot;Identity&amp;quot;&lt;/span&gt;,&lt;span class="st"&gt;&amp;quot;Sub&amp;quot;&lt;/span&gt;: &lt;span class="st"&gt;&amp;quot;BernoulliSample_ST&amp;quot;&lt;/span&gt;}):
            &lt;span class="cf"&gt;return&lt;/span&gt; tf.ceil(x &lt;span class="op"&gt;-&lt;/span&gt; tf.random_uniform(tf.shape(x)), name&lt;span class="op"&gt;=&lt;/span&gt;name)

&lt;span class="at"&gt;@ops.RegisterGradient&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;BernoulliSample_ST&amp;quot;&lt;/span&gt;)
&lt;span class="kw"&gt;def&lt;/span&gt; bernoulliSample_ST(op, grad):
    &lt;span class="cf"&gt;return&lt;/span&gt; [grad, tf.zeros(tf.shape(op.inputs[&lt;span class="dv"&gt;1&lt;/span&gt;]))]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; passThroughSigmoid(x, slope&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;):
    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;Sigmoid that uses identity function as its gradient&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    g &lt;span class="op"&gt;=&lt;/span&gt; tf.get_default_graph()
    &lt;span class="cf"&gt;with&lt;/span&gt; ops.name_scope(&lt;span class="st"&gt;&amp;quot;PassThroughSigmoid&amp;quot;&lt;/span&gt;) &lt;span class="im"&gt;as&lt;/span&gt; name:
        &lt;span class="cf"&gt;with&lt;/span&gt; g.gradient_override_map({&lt;span class="st"&gt;&amp;quot;Sigmoid&amp;quot;&lt;/span&gt;: &lt;span class="st"&gt;&amp;quot;Identity&amp;quot;&lt;/span&gt;}):
            &lt;span class="cf"&gt;return&lt;/span&gt; tf.sigmoid(x, name&lt;span class="op"&gt;=&lt;/span&gt;name)

&lt;span class="kw"&gt;def&lt;/span&gt; binaryStochastic_ST(x, slope_tensor&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;None&lt;/span&gt;, pass_through&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;, stochastic&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;):
    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="co"&gt;    Sigmoid followed by either a random sample from a bernoulli distribution according&lt;/span&gt;
&lt;span class="co"&gt;    to the result (binary stochastic neuron) (default), or a sigmoid followed by a binary&lt;/span&gt;
&lt;span class="co"&gt;    step function (if stochastic == False). Uses the straight through estimator.&lt;/span&gt;
&lt;span class="co"&gt;    See https://arxiv.org/abs/1308.3432.&lt;/span&gt;

&lt;span class="co"&gt;    Arguments:&lt;/span&gt;
&lt;span class="co"&gt;    * x: the pre-activation / logit tensor&lt;/span&gt;
&lt;span class="co"&gt;    * slope_tensor: if passThrough==False, slope adjusts the slope of the sigmoid function&lt;/span&gt;
&lt;span class="co"&gt;        for purposes of the Slope Annealing Trick (see http://arxiv.org/abs/1609.01704)&lt;/span&gt;
&lt;span class="co"&gt;    * pass_through: if True (default), gradient of the entire function is 1 or 0;&lt;/span&gt;
&lt;span class="co"&gt;        if False, gradient of 1 is scaled by the gradient of the sigmoid (required if&lt;/span&gt;
&lt;span class="co"&gt;        Slope Annealing Trick is used)&lt;/span&gt;
&lt;span class="co"&gt;    * stochastic: binary stochastic neuron if True (default), or step function if False&lt;/span&gt;
&lt;span class="co"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="cf"&gt;if&lt;/span&gt; slope_tensor &lt;span class="kw"&gt;is&lt;/span&gt; &lt;span class="va"&gt;None&lt;/span&gt;:
        slope_tensor &lt;span class="op"&gt;=&lt;/span&gt; tf.constant(&lt;span class="fl"&gt;1.0&lt;/span&gt;)

    &lt;span class="cf"&gt;if&lt;/span&gt; pass_through:
        p &lt;span class="op"&gt;=&lt;/span&gt; passThroughSigmoid(x)
    &lt;span class="cf"&gt;else&lt;/span&gt;:
        p &lt;span class="op"&gt;=&lt;/span&gt; tf.sigmoid(slope_tensor&lt;span class="op"&gt;*&lt;/span&gt;x)

    &lt;span class="cf"&gt;if&lt;/span&gt; stochastic:
        &lt;span class="cf"&gt;return&lt;/span&gt; bernoulliSample(p)
    &lt;span class="cf"&gt;else&lt;/span&gt;:
        &lt;span class="cf"&gt;return&lt;/span&gt; binaryRound(p)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="binary-stochastic-neuron-with-reinforce-estimator"&gt;Binary stochastic neuron with REINFORCE estimator&lt;/h4&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; binaryStochastic_REINFORCE(x, stochastic &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="va"&gt;True&lt;/span&gt;, loss_op_name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;loss_by_example&amp;quot;&lt;/span&gt;):
    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="co"&gt;    Sigmoid followed by a random sample from a bernoulli distribution according&lt;/span&gt;
&lt;span class="co"&gt;    to the result (binary stochastic neuron). Uses the REINFORCE estimator.&lt;/span&gt;
&lt;span class="co"&gt;    See https://arxiv.org/abs/1308.3432.&lt;/span&gt;

&lt;span class="co"&gt;    &lt;/span&gt;&lt;span class="al"&gt;NOTE&lt;/span&gt;&lt;span class="co"&gt;: Requires a loss operation with name matching the argument for loss_op_name&lt;/span&gt;
&lt;span class="co"&gt;    in the graph. This loss operation should be broken out by example (i.e., not a&lt;/span&gt;
&lt;span class="co"&gt;    single number for the entire batch).&lt;/span&gt;
&lt;span class="co"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    g &lt;span class="op"&gt;=&lt;/span&gt; tf.get_default_graph()

    &lt;span class="cf"&gt;with&lt;/span&gt; ops.name_scope(&lt;span class="st"&gt;&amp;quot;BinaryStochasticREINFORCE&amp;quot;&lt;/span&gt;):
        &lt;span class="cf"&gt;with&lt;/span&gt; g.gradient_override_map({&lt;span class="st"&gt;&amp;quot;Sigmoid&amp;quot;&lt;/span&gt;: &lt;span class="st"&gt;&amp;quot;BinaryStochastic_REINFORCE&amp;quot;&lt;/span&gt;,
                                      &lt;span class="st"&gt;&amp;quot;Ceil&amp;quot;&lt;/span&gt;: &lt;span class="st"&gt;&amp;quot;Identity&amp;quot;&lt;/span&gt;}):
            p &lt;span class="op"&gt;=&lt;/span&gt; tf.sigmoid(x)

            reinforce_collection &lt;span class="op"&gt;=&lt;/span&gt; g.get_collection(&lt;span class="st"&gt;&amp;quot;REINFORCE&amp;quot;&lt;/span&gt;)
            &lt;span class="cf"&gt;if&lt;/span&gt; &lt;span class="kw"&gt;not&lt;/span&gt; reinforce_collection:
                g.add_to_collection(&lt;span class="st"&gt;&amp;quot;REINFORCE&amp;quot;&lt;/span&gt;, {})
                reinforce_collection &lt;span class="op"&gt;=&lt;/span&gt; g.get_collection(&lt;span class="st"&gt;&amp;quot;REINFORCE&amp;quot;&lt;/span&gt;)
            reinforce_collection[&lt;span class="dv"&gt;0&lt;/span&gt;][p.op.name] &lt;span class="op"&gt;=&lt;/span&gt; loss_op_name

            &lt;span class="cf"&gt;return&lt;/span&gt; tf.ceil(p &lt;span class="op"&gt;-&lt;/span&gt; tf.random_uniform(tf.shape(x)))


&lt;span class="at"&gt;@ops.RegisterGradient&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;BinaryStochastic_REINFORCE&amp;quot;&lt;/span&gt;)
&lt;span class="kw"&gt;def&lt;/span&gt; _binaryStochastic_REINFORCE(op, _):
    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;Unbiased estimator for binary stochastic function based on REINFORCE.&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    loss_op_name &lt;span class="op"&gt;=&lt;/span&gt; op.graph.get_collection(&lt;span class="st"&gt;&amp;quot;REINFORCE&amp;quot;&lt;/span&gt;)[&lt;span class="dv"&gt;0&lt;/span&gt;][op.name]
    loss_tensor &lt;span class="op"&gt;=&lt;/span&gt; op.graph.get_operation_by_name(loss_op_name).outputs[&lt;span class="dv"&gt;0&lt;/span&gt;]

    sub_tensor &lt;span class="op"&gt;=&lt;/span&gt; op.outputs[&lt;span class="dv"&gt;0&lt;/span&gt;].consumers()[&lt;span class="dv"&gt;0&lt;/span&gt;].outputs[&lt;span class="dv"&gt;0&lt;/span&gt;] &lt;span class="co"&gt;#subtraction tensor&lt;/span&gt;
    ceil_tensor &lt;span class="op"&gt;=&lt;/span&gt; sub_tensor.consumers()[&lt;span class="dv"&gt;0&lt;/span&gt;].outputs[&lt;span class="dv"&gt;0&lt;/span&gt;] &lt;span class="co"&gt;#ceiling tensor&lt;/span&gt;

    outcome_diff &lt;span class="op"&gt;=&lt;/span&gt; (ceil_tensor &lt;span class="op"&gt;-&lt;/span&gt; op.outputs[&lt;span class="dv"&gt;0&lt;/span&gt;])

    &lt;span class="co"&gt;# Provides an early out if we want to avoid variance adjustment for&lt;/span&gt;
    &lt;span class="co"&gt;# whatever reason (e.g., to show that variance adjustment helps)&lt;/span&gt;
    &lt;span class="cf"&gt;if&lt;/span&gt; op.graph.get_collection(&lt;span class="st"&gt;&amp;quot;REINFORCE&amp;quot;&lt;/span&gt;)[&lt;span class="dv"&gt;0&lt;/span&gt;].get(&lt;span class="st"&gt;&amp;quot;no_variance_adj&amp;quot;&lt;/span&gt;):
        &lt;span class="cf"&gt;return&lt;/span&gt; outcome_diff &lt;span class="op"&gt;*&lt;/span&gt; tf.expand_dims(loss_tensor, &lt;span class="dv"&gt;1&lt;/span&gt;)

    outcome_diff_sq &lt;span class="op"&gt;=&lt;/span&gt; tf.square(outcome_diff)
    outcome_diff_sq_r &lt;span class="op"&gt;=&lt;/span&gt; tf.reduce_mean(outcome_diff_sq, reduction_indices&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;0&lt;/span&gt;)
    outcome_diff_sq_loss_r &lt;span class="op"&gt;=&lt;/span&gt; tf.reduce_mean(outcome_diff_sq &lt;span class="op"&gt;*&lt;/span&gt; tf.expand_dims(loss_tensor, &lt;span class="dv"&gt;1&lt;/span&gt;),
                                            reduction_indices&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;0&lt;/span&gt;)

    L_bar_num &lt;span class="op"&gt;=&lt;/span&gt; tf.Variable(tf.zeros(outcome_diff_sq_r.get_shape()), trainable&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;)
    L_bar_den &lt;span class="op"&gt;=&lt;/span&gt; tf.Variable(tf.ones(outcome_diff_sq_r.get_shape()), trainable&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;)

    &lt;span class="co"&gt;#Note: we already get a decent estimate of the average from the minibatch&lt;/span&gt;
    decay &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="fl"&gt;0.95&lt;/span&gt;
    train_L_bar_num &lt;span class="op"&gt;=&lt;/span&gt; tf.assign(L_bar_num, L_bar_num&lt;span class="op"&gt;*&lt;/span&gt;decay &lt;span class="op"&gt;+\&lt;/span&gt;
                                            outcome_diff_sq_loss_r&lt;span class="op"&gt;*&lt;/span&gt;(&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="op"&gt;-&lt;/span&gt;decay))
    train_L_bar_den &lt;span class="op"&gt;=&lt;/span&gt; tf.assign(L_bar_den, L_bar_den&lt;span class="op"&gt;*&lt;/span&gt;decay &lt;span class="op"&gt;+\&lt;/span&gt;
                                            outcome_diff_sq_r&lt;span class="op"&gt;*&lt;/span&gt;(&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="op"&gt;-&lt;/span&gt;decay))


    &lt;span class="cf"&gt;with&lt;/span&gt; tf.control_dependencies([train_L_bar_num, train_L_bar_den]):
        L_bar &lt;span class="op"&gt;=&lt;/span&gt; train_L_bar_num&lt;span class="op"&gt;/&lt;/span&gt;(train_L_bar_den&lt;span class="fl"&gt;+1e-4&lt;/span&gt;)
        L &lt;span class="op"&gt;=&lt;/span&gt; tf.tile(tf.expand_dims(loss_tensor,&lt;span class="dv"&gt;1&lt;/span&gt;),
                    tf.constant([&lt;span class="dv"&gt;1&lt;/span&gt;,L_bar.get_shape().as_list()[&lt;span class="dv"&gt;0&lt;/span&gt;]]))
        &lt;span class="cf"&gt;return&lt;/span&gt; outcome_diff &lt;span class="op"&gt;*&lt;/span&gt; (L &lt;span class="op"&gt;-&lt;/span&gt; L_bar)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="wrapper-to-create-layer-of-binary-stochastic-neurons"&gt;Wrapper to create layer of binary stochastic neurons&lt;/h4&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; binary_wrapper(&lt;span class="op"&gt;\&lt;/span&gt;
                pre_activations_tensor,
                estimator&lt;span class="op"&gt;=&lt;/span&gt;StochasticGradientEstimator.ST,
                stochastic_tensor&lt;span class="op"&gt;=&lt;/span&gt;tf.constant(&lt;span class="va"&gt;True&lt;/span&gt;),
                pass_through&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;,
                slope_tensor&lt;span class="op"&gt;=&lt;/span&gt;tf.constant(&lt;span class="fl"&gt;1.0&lt;/span&gt;)):
    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="co"&gt;    Turns a layer of pre-activations (logits) into a layer of binary stochastic neurons&lt;/span&gt;

&lt;span class="co"&gt;    Keyword arguments:&lt;/span&gt;
&lt;span class="co"&gt;    *estimator: either ST or REINFORCE&lt;/span&gt;
&lt;span class="co"&gt;    *stochastic_tensor: a boolean tensor indicating whether to sample from a bernoulli&lt;/span&gt;
&lt;span class="co"&gt;        distribution (True, default) or use a step_function (e.g., for inference)&lt;/span&gt;
&lt;span class="co"&gt;    *pass_through: for ST only - boolean as to whether to substitute identity derivative on the&lt;/span&gt;
&lt;span class="co"&gt;        backprop (True, default), or whether to use the derivative of the sigmoid&lt;/span&gt;
&lt;span class="co"&gt;    *slope_tensor: for ST only - tensor specifying the slope for purposes of slope annealing&lt;/span&gt;
&lt;span class="co"&gt;        trick&lt;/span&gt;
&lt;span class="co"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

    &lt;span class="cf"&gt;if&lt;/span&gt; estimator &lt;span class="op"&gt;==&lt;/span&gt; StochasticGradientEstimator.ST:
        &lt;span class="cf"&gt;if&lt;/span&gt; pass_through:
            &lt;span class="cf"&gt;return&lt;/span&gt; tf.cond(stochastic_tensor,
                    &lt;span class="kw"&gt;lambda&lt;/span&gt;: binaryStochastic_ST(pre_activations_tensor),
                    &lt;span class="kw"&gt;lambda&lt;/span&gt;: binaryStochastic_ST(pre_activations_tensor, stochastic&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;))
        &lt;span class="cf"&gt;else&lt;/span&gt;:
            &lt;span class="cf"&gt;return&lt;/span&gt; tf.cond(stochastic_tensor,
                    &lt;span class="kw"&gt;lambda&lt;/span&gt;: binaryStochastic_ST(pre_activations_tensor, slope_tensor &lt;span class="op"&gt;=&lt;/span&gt; slope_tensor,
                                             pass_through&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;),
                    &lt;span class="kw"&gt;lambda&lt;/span&gt;: binaryStochastic_ST(pre_activations_tensor, slope_tensor &lt;span class="op"&gt;=&lt;/span&gt; slope_tensor,
                                             pass_through&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;, stochastic&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;))
    &lt;span class="cf"&gt;elif&lt;/span&gt; estimator &lt;span class="op"&gt;==&lt;/span&gt; StochasticGradientEstimator.REINFORCE:
        &lt;span class="co"&gt;# binaryStochastic_REINFORCE was designed to only be stochastic, so using the ST version&lt;/span&gt;
        &lt;span class="co"&gt;# for the step fn for purposes of using step fn at evaluation / not for training&lt;/span&gt;
        &lt;span class="cf"&gt;return&lt;/span&gt; tf.cond(stochastic_tensor,
                &lt;span class="kw"&gt;lambda&lt;/span&gt;: binaryStochastic_REINFORCE(pre_activations_tensor),
                &lt;span class="kw"&gt;lambda&lt;/span&gt;: binaryStochastic_ST(pre_activations_tensor, stochastic&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;))

    &lt;span class="cf"&gt;else&lt;/span&gt;:
        &lt;span class="cf"&gt;raise&lt;/span&gt; &lt;span class="pp"&gt;ValueError&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;Unrecognized estimator.&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="function-to-build-graph-for-mnist-classifier"&gt;Function to build graph for MNIST classifier&lt;/h4&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; build_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;100&lt;/span&gt;],
                        lr &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="fl"&gt;0.5&lt;/span&gt;,
                        pass_through &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="va"&gt;True&lt;/span&gt;,
                        non_binary &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="va"&gt;False&lt;/span&gt;,
                        estimator &lt;span class="op"&gt;=&lt;/span&gt; StochasticGradientEstimator.ST,
                        no_var_adj&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;):
    reset_graph()
    g &lt;span class="op"&gt;=&lt;/span&gt; {}

    &lt;span class="cf"&gt;if&lt;/span&gt; no_var_adj:
        tf.get_default_graph().add_to_collection(&lt;span class="st"&gt;&amp;quot;REINFORCE&amp;quot;&lt;/span&gt;, {&lt;span class="st"&gt;&amp;quot;no_variance_adj&amp;quot;&lt;/span&gt;: no_var_adj})

    g[&lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;] &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(tf.float32, [&lt;span class="va"&gt;None&lt;/span&gt;, &lt;span class="dv"&gt;784&lt;/span&gt;], name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;x_placeholder&amp;#39;&lt;/span&gt;)
    g[&lt;span class="st"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;] &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(tf.float32, [&lt;span class="va"&gt;None&lt;/span&gt;, &lt;span class="dv"&gt;10&lt;/span&gt;], name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;y_placeholder&amp;#39;&lt;/span&gt;)
    g[&lt;span class="st"&gt;&amp;#39;stochastic&amp;#39;&lt;/span&gt;] &lt;span class="op"&gt;=&lt;/span&gt; tf.constant(&lt;span class="va"&gt;True&lt;/span&gt;)
    g[&lt;span class="st"&gt;&amp;#39;slope&amp;#39;&lt;/span&gt;] &lt;span class="op"&gt;=&lt;/span&gt; tf.constant(&lt;span class="fl"&gt;1.0&lt;/span&gt;)

    g[&lt;span class="st"&gt;&amp;#39;layers&amp;#39;&lt;/span&gt;] &lt;span class="op"&gt;=&lt;/span&gt; {&lt;span class="dv"&gt;0&lt;/span&gt;: g[&lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;]}
    hidden_layers &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;len&lt;/span&gt;(hidden_dims)
    dims &lt;span class="op"&gt;=&lt;/span&gt; [&lt;span class="dv"&gt;784&lt;/span&gt;] &lt;span class="op"&gt;+&lt;/span&gt; hidden_dims

    &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;1&lt;/span&gt;, hidden_layers&lt;span class="op"&gt;+&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;):
        &lt;span class="cf"&gt;with&lt;/span&gt; tf.variable_scope(&lt;span class="st"&gt;&amp;quot;layer_&amp;quot;&lt;/span&gt; &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="bu"&gt;str&lt;/span&gt;(i)):
            pre_activations &lt;span class="op"&gt;=&lt;/span&gt; layer_linear(g[&lt;span class="st"&gt;&amp;#39;layers&amp;#39;&lt;/span&gt;][i&lt;span class="dv"&gt;-1&lt;/span&gt;], dims[i&lt;span class="dv"&gt;-1&lt;/span&gt;:i&lt;span class="op"&gt;+&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;], scope&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;layer_&amp;#39;&lt;/span&gt; &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="bu"&gt;str&lt;/span&gt;(i))
            &lt;span class="cf"&gt;if&lt;/span&gt; non_binary:
                g[&lt;span class="st"&gt;&amp;#39;layers&amp;#39;&lt;/span&gt;][i] &lt;span class="op"&gt;=&lt;/span&gt; tf.sigmoid(pre_activations)
            &lt;span class="cf"&gt;else&lt;/span&gt;:
                g[&lt;span class="st"&gt;&amp;#39;layers&amp;#39;&lt;/span&gt;][i] &lt;span class="op"&gt;=&lt;/span&gt; binary_wrapper(pre_activations,
                                              estimator &lt;span class="op"&gt;=&lt;/span&gt; estimator,
                                              pass_through &lt;span class="op"&gt;=&lt;/span&gt; pass_through,
                                              stochastic_tensor &lt;span class="op"&gt;=&lt;/span&gt; g[&lt;span class="st"&gt;&amp;#39;stochastic&amp;#39;&lt;/span&gt;],
                                              slope_tensor &lt;span class="op"&gt;=&lt;/span&gt; g[&lt;span class="st"&gt;&amp;#39;slope&amp;#39;&lt;/span&gt;])

    g[&lt;span class="st"&gt;&amp;#39;pred&amp;#39;&lt;/span&gt;] &lt;span class="op"&gt;=&lt;/span&gt; layer_softmax(g[&lt;span class="st"&gt;&amp;#39;layers&amp;#39;&lt;/span&gt;][hidden_layers], [dims[&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;], &lt;span class="dv"&gt;10&lt;/span&gt;])

    g[&lt;span class="st"&gt;&amp;#39;loss&amp;#39;&lt;/span&gt;] &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="op"&gt;-&lt;/span&gt;tf.reduce_mean(g[&lt;span class="st"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;] &lt;span class="op"&gt;*&lt;/span&gt; tf.log(g[&lt;span class="st"&gt;&amp;#39;pred&amp;#39;&lt;/span&gt;]),reduction_indices&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;)

    &lt;span class="co"&gt;# named loss_by_example necessary for REINFORCE estimator&lt;/span&gt;
    tf.identity(g[&lt;span class="st"&gt;&amp;#39;loss&amp;#39;&lt;/span&gt;], name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;loss_by_example&amp;quot;&lt;/span&gt;)

    g[&lt;span class="st"&gt;&amp;#39;ts&amp;#39;&lt;/span&gt;] &lt;span class="op"&gt;=&lt;/span&gt; tf.train.GradientDescentOptimizer(lr).minimize(g[&lt;span class="st"&gt;&amp;#39;loss&amp;#39;&lt;/span&gt;])

    g[&lt;span class="st"&gt;&amp;#39;accuracy&amp;#39;&lt;/span&gt;] &lt;span class="op"&gt;=&lt;/span&gt; accuracy(g[&lt;span class="st"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;], g[&lt;span class="st"&gt;&amp;#39;pred&amp;#39;&lt;/span&gt;])

    g[&lt;span class="st"&gt;&amp;#39;init_op&amp;#39;&lt;/span&gt;] &lt;span class="op"&gt;=&lt;/span&gt; tf.global_variables_initializer()
    &lt;span class="cf"&gt;return&lt;/span&gt; g&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="function-to-train-the-classifier"&gt;Function to train the classifier&lt;/h4&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; train_classifier(&lt;span class="op"&gt;\&lt;/span&gt;
        hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;100&lt;/span&gt;,&lt;span class="dv"&gt;100&lt;/span&gt;],
        estimator&lt;span class="op"&gt;=&lt;/span&gt;StochasticGradientEstimator.ST,
        stochastic_train&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;,
        stochastic_eval&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;,
        slope_annealing_rate&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;None&lt;/span&gt;,
        epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;10&lt;/span&gt;,
        lr&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.5&lt;/span&gt;,
        non_binary&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;,
        no_var_adj&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;,
        train_set &lt;span class="op"&gt;=&lt;/span&gt; mnist.train,
        val_set &lt;span class="op"&gt;=&lt;/span&gt; mnist.validation,
        verbose&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;,
        label&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;None&lt;/span&gt;):
    &lt;span class="cf"&gt;if&lt;/span&gt; slope_annealing_rate &lt;span class="kw"&gt;is&lt;/span&gt; &lt;span class="va"&gt;None&lt;/span&gt;:
        g &lt;span class="op"&gt;=&lt;/span&gt; build_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;hidden_dims, lr&lt;span class="op"&gt;=&lt;/span&gt;lr, pass_through&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;,
                                non_binary&lt;span class="op"&gt;=&lt;/span&gt;non_binary, estimator&lt;span class="op"&gt;=&lt;/span&gt;estimator, no_var_adj&lt;span class="op"&gt;=&lt;/span&gt;no_var_adj)
    &lt;span class="cf"&gt;else&lt;/span&gt;:
        g &lt;span class="op"&gt;=&lt;/span&gt; build_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;hidden_dims, lr&lt;span class="op"&gt;=&lt;/span&gt;lr, pass_through&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;,
                                non_binary&lt;span class="op"&gt;=&lt;/span&gt;non_binary, estimator&lt;span class="op"&gt;=&lt;/span&gt;estimator, no_var_adj&lt;span class="op"&gt;=&lt;/span&gt;no_var_adj)

    &lt;span class="cf"&gt;with&lt;/span&gt; tf.Session() &lt;span class="im"&gt;as&lt;/span&gt; sess:
        sess.run(g[&lt;span class="st"&gt;&amp;#39;init_op&amp;#39;&lt;/span&gt;])
        slope &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;
        res_tr, res_val &lt;span class="op"&gt;=&lt;/span&gt; [], []
        &lt;span class="cf"&gt;for&lt;/span&gt; epoch &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(epochs):
            feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{g[&lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;]: val_set.images,
                       g[&lt;span class="st"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;]: val_set.labels,
                       g[&lt;span class="st"&gt;&amp;#39;stochastic&amp;#39;&lt;/span&gt;]: stochastic_eval,
                       g[&lt;span class="st"&gt;&amp;#39;slope&amp;#39;&lt;/span&gt;]: slope}
            &lt;span class="cf"&gt;if&lt;/span&gt; verbose:
                &lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;Epoch&amp;quot;&lt;/span&gt;, epoch, sess.run(g[&lt;span class="st"&gt;&amp;#39;accuracy&amp;#39;&lt;/span&gt;], feed_dict&lt;span class="op"&gt;=&lt;/span&gt;feed_dict))

            accuracy &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;
            &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;1001&lt;/span&gt;):
                x, y &lt;span class="op"&gt;=&lt;/span&gt; train_set.next_batch(&lt;span class="dv"&gt;50&lt;/span&gt;)
                feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{g[&lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;]: x, g[&lt;span class="st"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;]: y, g[&lt;span class="st"&gt;&amp;#39;stochastic&amp;#39;&lt;/span&gt;]: stochastic_train}
                acc, _ &lt;span class="op"&gt;=&lt;/span&gt; sess.run([g[&lt;span class="st"&gt;&amp;#39;accuracy&amp;#39;&lt;/span&gt;],g[&lt;span class="st"&gt;&amp;#39;ts&amp;#39;&lt;/span&gt;]], feed_dict&lt;span class="op"&gt;=&lt;/span&gt;feed_dict)
                accuracy &lt;span class="op"&gt;+=&lt;/span&gt; acc
                &lt;span class="cf"&gt;if&lt;/span&gt; i &lt;span class="op"&gt;%&lt;/span&gt; &lt;span class="dv"&gt;100&lt;/span&gt; &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt; &lt;span class="kw"&gt;and&lt;/span&gt; i &lt;span class="op"&gt;&amp;gt;&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;:
                    res_tr.append(accuracy&lt;span class="op"&gt;/&lt;/span&gt;&lt;span class="dv"&gt;100&lt;/span&gt;)
                    accuracy &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;
                    feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{g[&lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;]: val_set.images,
                               g[&lt;span class="st"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;]: val_set.labels,
                               g[&lt;span class="st"&gt;&amp;#39;stochastic&amp;#39;&lt;/span&gt;]: stochastic_eval,
                               g[&lt;span class="st"&gt;&amp;#39;slope&amp;#39;&lt;/span&gt;]: slope}
                    res_val.append(sess.run(g[&lt;span class="st"&gt;&amp;#39;accuracy&amp;#39;&lt;/span&gt;], feed_dict&lt;span class="op"&gt;=&lt;/span&gt;feed_dict))

            &lt;span class="cf"&gt;if&lt;/span&gt; slope_annealing_rate &lt;span class="kw"&gt;is&lt;/span&gt; &lt;span class="kw"&gt;not&lt;/span&gt; &lt;span class="va"&gt;None&lt;/span&gt;:
                slope &lt;span class="op"&gt;=&lt;/span&gt; slope&lt;span class="op"&gt;*&lt;/span&gt;slope_annealing_rate
                &lt;span class="cf"&gt;if&lt;/span&gt; verbose:
                    &lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;Sigmoid slope:&amp;quot;&lt;/span&gt;, slope)

        feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{g[&lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;]: val_set.images, g[&lt;span class="st"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;]: val_set.labels,
                   g[&lt;span class="st"&gt;&amp;#39;stochastic&amp;#39;&lt;/span&gt;]: stochastic_eval, g[&lt;span class="st"&gt;&amp;#39;slope&amp;#39;&lt;/span&gt;]: slope}
        &lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;Epoch&amp;quot;&lt;/span&gt;, epoch&lt;span class="op"&gt;+&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;, sess.run(g[&lt;span class="st"&gt;&amp;#39;accuracy&amp;#39;&lt;/span&gt;], feed_dict&lt;span class="op"&gt;=&lt;/span&gt;feed_dict))
        &lt;span class="cf"&gt;if&lt;/span&gt; label &lt;span class="kw"&gt;is&lt;/span&gt; &lt;span class="kw"&gt;not&lt;/span&gt; &lt;span class="va"&gt;None&lt;/span&gt;:
            &lt;span class="cf"&gt;return&lt;/span&gt; (res_tr, label &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="st"&gt;&amp;quot; - Training&amp;quot;&lt;/span&gt;), (res_val, label &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="st"&gt;&amp;quot; - Validation&amp;quot;&lt;/span&gt;)
        &lt;span class="cf"&gt;else&lt;/span&gt;:
            &lt;span class="cf"&gt;return&lt;/span&gt; [(res_tr, &lt;span class="st"&gt;&amp;quot;Training&amp;quot;&lt;/span&gt;), (res_val, &lt;span class="st"&gt;&amp;quot;Validation&amp;quot;&lt;/span&gt;)]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="experiments"&gt;Experiments&lt;/h3&gt;
&lt;p&gt;We’ve now set up a good foundation from which we can run a number of simple experiments. The experiments are as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Experiment 0&lt;/strong&gt;: A non-stochastic, non-binary baseline.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Experiment 1&lt;/strong&gt;: A comparison of variance-adjusted REINFORCE and non-variance adjusted REINFORCE, which shows that the variance adjustment allows for faster learning and higher learning rates.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Experiment 2&lt;/strong&gt;: A comparison of pass-through ST and sigmoid-adjusted ST, which shows that the sigmoid-adjusted ST estimator obtains better results, a result that does not agree with the findings of &lt;a href="https://arxiv.org/abs/1308.3432"&gt;Bengio et al. (2013&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Experiment 3&lt;/strong&gt;: A comparison of sigmoid-adjusted ST and slope-annealed sigmoid-adjusted ST, which shows that a well-tuned slope-annealed ST outperforms the base sigmoid-adjusted ST.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Experiment 4&lt;/strong&gt;: A direct comparison of variance-adjusted REINFORCE and slope-annealed ST, which shows that ST performs significantly better than REINFORCE.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Experiment 5&lt;/strong&gt;: A look at the deterministic step function, during training and evaluation, which shows that deterministic evaluation can provide a slight boost at inference, and that with slope annealing, deterministic training is just as effective, if not more effective than stochastic training.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Experiment 6&lt;/strong&gt;: A look at how network depth affects performance, which shows that deep stochastic networks can be difficult to train.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Experiment 7&lt;/strong&gt;: A look at using binary stochastic neurons as a regularizer, which validates Hinton’s claim that stochastic neurons can serve as effective regularizers.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="experiment-0-a-non-stochastic-non-binary-baseline"&gt;Experiment 0: A non-stochastic, non-binary baseline&lt;/h4&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;res &lt;span class="op"&gt;=&lt;/span&gt; train_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;100&lt;/span&gt;], epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;20&lt;/span&gt;, lr&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;1.0&lt;/span&gt;, non_binary&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)
plot_n(res, lower_y&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.8&lt;/span&gt;, title&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;Logistic Sigmoid Baseline&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Epoch 20 0.9698&lt;/code&gt;&lt;/pre&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/BSN_output_16_1.png" alt="png" /&gt;&lt;figcaption&gt;png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h4 id="experiment-1-variance-adjusted-vs.not-variance-adjusted-reinforce"&gt;Experiment 1: Variance-adjusted vs. not variance-adjusted REINFORCE&lt;/h4&gt;
&lt;p&gt;Recall that the REINFORCE estimator estimates the expectation of &lt;span class="math inline"&gt;\(\frac{\partial L}{\partial a}\)&lt;/span&gt; as &lt;span class="math inline"&gt;\((\text{BSN}(a) - \text{sigm}(a))(L - c)\)&lt;/span&gt;, where &lt;span class="math inline"&gt;\(c\)&lt;/span&gt; is a constant. The non-variance-adjusted form of REINFORCE uses &lt;span class="math inline"&gt;\(c = 0\)&lt;/span&gt;, whereas the variance-adjusted form uses the variance minimizing result stated above. Naturally we should prefer the least variance, and the experimental results below agree.&lt;/p&gt;
&lt;p&gt;It seems that both forms of REINFORCE often break down for learning rates greater than or equal to 0.3 (compare to the learning rate of 1.0 that used in Experiment 0). After a few trials, variance-adjusted REINFORCE appears to be more resistant to such failures.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;Variance-adjusted:&amp;quot;&lt;/span&gt;)
res1 &lt;span class="op"&gt;=&lt;/span&gt; train_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;100&lt;/span&gt;], estimator&lt;span class="op"&gt;=&lt;/span&gt;StochasticGradientEstimator.REINFORCE, epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;3&lt;/span&gt;,
                       lr&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.3&lt;/span&gt;, verbose&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)
&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;Not variance-adjusted:&amp;quot;&lt;/span&gt;)&lt;span class="kw"&gt;and&lt;/span&gt;
res2&lt;span class="op"&gt;=&lt;/span&gt; train_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;100&lt;/span&gt;], estimator&lt;span class="op"&gt;=&lt;/span&gt;StochasticGradientEstimator.REINFORCE, epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;3&lt;/span&gt;,
                       lr&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.3&lt;/span&gt;, no_var_adj&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;, verbose&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Variance-adjusted:
Epoch 0 0.1026
Epoch 1 0.4466
Epoch 2 0.511
Epoch 3 0.575
Not variance-adjusted:
Epoch 0 0.0964
Epoch 1 0.0958
Epoch 2 0.0958
Epoch 3 0.0958&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In terms of performance at lower learning rates, a learning rate of about 0.05 provided the best results. The results show that the variance-adjusted REINFORCE learns faster, but that its non-variance adjusted eventually catches up. This result is consistent with the mathematical result that they are both unbiased estimators. Performance is predictably worse than it was for the plain logistic sigmoid in Experiment 0, although there is almost no generalization gap, consistent with the hypothesis that binary stochastic neurons can act as regularizers.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;res1 &lt;span class="op"&gt;=&lt;/span&gt; train_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;100&lt;/span&gt;], estimator&lt;span class="op"&gt;=&lt;/span&gt;StochasticGradientEstimator.REINFORCE, epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;20&lt;/span&gt;,
                       lr&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.05&lt;/span&gt;, label &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Variance-adjusted&amp;quot;&lt;/span&gt;)
res2&lt;span class="op"&gt;=&lt;/span&gt; train_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;100&lt;/span&gt;], estimator&lt;span class="op"&gt;=&lt;/span&gt;StochasticGradientEstimator.REINFORCE, epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;20&lt;/span&gt;,
                       lr&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.05&lt;/span&gt;, no_var_adj&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;, label &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Not variance-adjusted&amp;quot;&lt;/span&gt;)

plot_n(res1 &lt;span class="op"&gt;+&lt;/span&gt; res2, lower_y&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.6&lt;/span&gt;, title&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;Experiment 1: REINFORCE variance adjustment&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Epoch 20 0.9274
Epoch 20 0.923&lt;/code&gt;&lt;/pre&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/BSN_output_20_1.png" alt="png" /&gt;&lt;figcaption&gt;png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h4 id="experiment-2-pass-through-vs.sigmoid-adjusted-st-estimation"&gt;Experiment 2: Pass-through vs. sigmoid-adjusted ST estimation&lt;/h4&gt;
&lt;p&gt;Recall that one variant of the straight-through estimator uses the identity function as the backpropagated gradient (pass-through), and another variant multiplies that by the gradient of the logistic sigmoid that the neuron calculates (sigmoid-adjusted). In &lt;a href="https://arxiv.org/abs/1308.3432"&gt;Bengio et al. (2013)&lt;/a&gt;, it was remarked that, surprisingly, the former performs better. My results below disagree, and by a surprisingly wide margin.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;res1 &lt;span class="op"&gt;=&lt;/span&gt; train_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;100&lt;/span&gt;], estimator&lt;span class="op"&gt;=&lt;/span&gt;StochasticGradientEstimator.ST, epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;20&lt;/span&gt;,
                       lr&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.1&lt;/span&gt;, label &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Pass-through - 0.1&amp;quot;&lt;/span&gt;)
res2 &lt;span class="op"&gt;=&lt;/span&gt; train_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;100&lt;/span&gt;], estimator&lt;span class="op"&gt;=&lt;/span&gt;StochasticGradientEstimator.ST, epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;20&lt;/span&gt;,
                       lr&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.1&lt;/span&gt;, slope_annealing_rate &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="fl"&gt;1.0&lt;/span&gt;, label &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Sigmoid-adjusted - 0.1&amp;quot;&lt;/span&gt;)

res3 &lt;span class="op"&gt;=&lt;/span&gt; train_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;100&lt;/span&gt;], estimator&lt;span class="op"&gt;=&lt;/span&gt;StochasticGradientEstimator.ST, epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;20&lt;/span&gt;,
                       lr&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.3&lt;/span&gt;, label &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Pass-through - 0.3&amp;quot;&lt;/span&gt;)
res4 &lt;span class="op"&gt;=&lt;/span&gt; train_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;100&lt;/span&gt;], estimator&lt;span class="op"&gt;=&lt;/span&gt;StochasticGradientEstimator.ST, epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;20&lt;/span&gt;,
                       lr&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.3&lt;/span&gt;, slope_annealing_rate &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="fl"&gt;1.0&lt;/span&gt;, label &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Sigmoid-adjusted - 0.3&amp;quot;&lt;/span&gt;)

res5 &lt;span class="op"&gt;=&lt;/span&gt; train_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;100&lt;/span&gt;], estimator&lt;span class="op"&gt;=&lt;/span&gt;StochasticGradientEstimator.ST, epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;20&lt;/span&gt;,
                       lr&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;1.0&lt;/span&gt;, label &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Pass-through - 1.0&amp;quot;&lt;/span&gt;)
res6 &lt;span class="op"&gt;=&lt;/span&gt; train_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;100&lt;/span&gt;], estimator&lt;span class="op"&gt;=&lt;/span&gt;StochasticGradientEstimator.ST, epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;20&lt;/span&gt;,
                       lr&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;1.0&lt;/span&gt;, slope_annealing_rate &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="fl"&gt;1.0&lt;/span&gt;, label &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Sigmoid-adjusted - 1.0&amp;quot;&lt;/span&gt;)

plot_n(res1[&lt;span class="dv"&gt;1&lt;/span&gt;:] &lt;span class="op"&gt;+&lt;/span&gt; res2[&lt;span class="dv"&gt;1&lt;/span&gt;:] &lt;span class="op"&gt;+&lt;/span&gt; res3[&lt;span class="dv"&gt;1&lt;/span&gt;:] &lt;span class="op"&gt;+&lt;/span&gt; res4[&lt;span class="dv"&gt;1&lt;/span&gt;:] &lt;span class="op"&gt;+&lt;/span&gt; res5[&lt;span class="dv"&gt;1&lt;/span&gt;:] &lt;span class="op"&gt;+&lt;/span&gt; res6[&lt;span class="dv"&gt;1&lt;/span&gt;:],
       lower_y&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.4&lt;/span&gt;, title&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;Experiment 2: Pass-through vs sigmoid-adjusted ST&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Epoch 20 0.8334
Epoch 20 0.9566
Epoch 20 0.8828
Epoch 20 0.9668
Epoch 20 0.0958
Epoch 20 0.9572&lt;/code&gt;&lt;/pre&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/BSN_output_22_1.png" alt="png" /&gt;&lt;figcaption&gt;png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h4 id="experiment-3-pass-through-vs.slope-annealed-st-estimation"&gt;Experiment 3: Pass-through vs. slope-annealed ST estimation&lt;/h4&gt;
&lt;p&gt;Recall that &lt;a href="https://arxiv.org/abs/1609.01704"&gt;Chung et al. (2016)&lt;/a&gt; improves upon the sigmoid-adjusted variant of the ST estimator by using the &lt;em&gt;slope-annealing trick&lt;/em&gt;, which slowly increases the slope of the logistic sigmoid as training progresses. Using the slope-annealing trick with an annealing rate of 1.1 times per epoch (so the slope at epoch 20 is &lt;span class="math inline"&gt;\(1.1^{19} \approx 6.1\)&lt;/span&gt;), we’re able to improve upon the sigmoid-adjusted ST estimator, and even beat our non-stochastic, non-binary baseline! Note that the slope annealed neuron used here is not the same as the one used by &lt;a href="https://arxiv.org/abs/1609.01704"&gt;Chung et al. (2016)&lt;/a&gt;, who employ a deterministic step function and use a hard sigmoid in place of a sigmoid for the backpropagation.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;res1 &lt;span class="op"&gt;=&lt;/span&gt; train_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;100&lt;/span&gt;], estimator&lt;span class="op"&gt;=&lt;/span&gt;StochasticGradientEstimator.ST, epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;20&lt;/span&gt;,
                       lr&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.1&lt;/span&gt;, slope_annealing_rate &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="fl"&gt;1.0&lt;/span&gt;, label &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Sigmoid-adjusted - 0.1&amp;quot;&lt;/span&gt;)
res2 &lt;span class="op"&gt;=&lt;/span&gt; train_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;100&lt;/span&gt;], estimator&lt;span class="op"&gt;=&lt;/span&gt;StochasticGradientEstimator.ST, epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;20&lt;/span&gt;,
                       lr&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.1&lt;/span&gt;, slope_annealing_rate &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="fl"&gt;1.1&lt;/span&gt;, label &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Slope-annealed - 0.1&amp;quot;&lt;/span&gt;)

res3 &lt;span class="op"&gt;=&lt;/span&gt; train_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;100&lt;/span&gt;], estimator&lt;span class="op"&gt;=&lt;/span&gt;StochasticGradientEstimator.ST, epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;20&lt;/span&gt;,
                       lr&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.3&lt;/span&gt;, slope_annealing_rate &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="fl"&gt;1.0&lt;/span&gt;, label &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Sigmoid-adjusted - 0.3&amp;quot;&lt;/span&gt;)
res4 &lt;span class="op"&gt;=&lt;/span&gt; train_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;100&lt;/span&gt;], estimator&lt;span class="op"&gt;=&lt;/span&gt;StochasticGradientEstimator.ST, epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;20&lt;/span&gt;,
                       lr&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.3&lt;/span&gt;, slope_annealing_rate &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="fl"&gt;1.1&lt;/span&gt;, label &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Slope-annealed - 0.3&amp;quot;&lt;/span&gt;)

res5 &lt;span class="op"&gt;=&lt;/span&gt; train_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;100&lt;/span&gt;], estimator&lt;span class="op"&gt;=&lt;/span&gt;StochasticGradientEstimator.ST, epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;20&lt;/span&gt;,
                       lr&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;1.0&lt;/span&gt;, slope_annealing_rate &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="fl"&gt;1.0&lt;/span&gt;, label &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Sigmoid-adjusted - 1.0&amp;quot;&lt;/span&gt;)
res6 &lt;span class="op"&gt;=&lt;/span&gt; train_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;100&lt;/span&gt;], estimator&lt;span class="op"&gt;=&lt;/span&gt;StochasticGradientEstimator.ST, epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;20&lt;/span&gt;,
                       lr&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;1.0&lt;/span&gt;, slope_annealing_rate &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="fl"&gt;1.1&lt;/span&gt;, label &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Slope-annealed - 1.0&amp;quot;&lt;/span&gt;)

plot_n(res1[&lt;span class="dv"&gt;1&lt;/span&gt;:] &lt;span class="op"&gt;+&lt;/span&gt; res2[&lt;span class="dv"&gt;1&lt;/span&gt;:] &lt;span class="op"&gt;+&lt;/span&gt; res3[&lt;span class="dv"&gt;1&lt;/span&gt;:] &lt;span class="op"&gt;+&lt;/span&gt; res4[&lt;span class="dv"&gt;1&lt;/span&gt;:] &lt;span class="op"&gt;+&lt;/span&gt; res5[&lt;span class="dv"&gt;1&lt;/span&gt;:] &lt;span class="op"&gt;+&lt;/span&gt; res6[&lt;span class="dv"&gt;1&lt;/span&gt;:],
       lower_y&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.6&lt;/span&gt;, title&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;Experiment 3: Sigmoid-adjusted vs slope-annealed ST&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Epoch 20 0.9548
Epoch 20 0.974
Epoch 20 0.9704
Epoch 20 0.9764
Epoch 20 0.9608
Epoch 20 0.9624&lt;/code&gt;&lt;/pre&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/BSN_output_24_1.png" alt="png" /&gt;&lt;figcaption&gt;png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h4 id="experiment-4-variance-adjusted-reinforce-vs-slope-annealed-st"&gt;Experiment 4: Variance-adjusted REINFORCE vs slope-annealed ST&lt;/h4&gt;
&lt;p&gt;We now directly compare the variance-adjusted REINFORCE and slope-annealed ST, both at their best learning rates. In this setting, despite being a biased estimator, the straight-through estimator displays faster learning, less variance, and better overall results than the variance-adjusted REINFORCE estimator.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;res1 &lt;span class="op"&gt;=&lt;/span&gt; train_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;100&lt;/span&gt;], estimator&lt;span class="op"&gt;=&lt;/span&gt;StochasticGradientEstimator.REINFORCE, epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;20&lt;/span&gt;,
                       lr&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.05&lt;/span&gt;, label &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Variance-adjusted REINFORCE&amp;quot;&lt;/span&gt;)

res2 &lt;span class="op"&gt;=&lt;/span&gt; train_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;100&lt;/span&gt;], estimator&lt;span class="op"&gt;=&lt;/span&gt;StochasticGradientEstimator.ST, epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;20&lt;/span&gt;,
                       lr&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.3&lt;/span&gt;, slope_annealing_rate &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="fl"&gt;1.1&lt;/span&gt;, label &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Slope-annealed ST&amp;quot;&lt;/span&gt;)

plot_n(res1[&lt;span class="dv"&gt;1&lt;/span&gt;:] &lt;span class="op"&gt;+&lt;/span&gt; res2[&lt;span class="dv"&gt;1&lt;/span&gt;:],
       lower_y&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.6&lt;/span&gt;, title&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;Experiment 4: Variance-adjusted REINFORCE vs slope-annealed ST&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Epoch 20 0.926
Epoch 20 0.9782&lt;/code&gt;&lt;/pre&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/BSN_output_26_1.png" alt="png" /&gt;&lt;figcaption&gt;png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h4 id="experiment-5-a-look-at-the-deterministic-step-function-during-training-and-evaluation"&gt;Experiment 5: A look at the deterministic step function, during training and evaluation&lt;/h4&gt;
&lt;p&gt;Similar to how dropout is not applied at inference when using dropout for training, it makes sense that we might replace the stochastic sigmoid with a deterministic step function at inference when using binary neurons. We might go even further than that, and use deterministic neurons during training, which is the approach taken by &lt;a href="https://arxiv.org/abs/1609.01704"&gt;Chung et al. (2016)&lt;/a&gt;. The following three combinations are compared below, using the slope-annealed straight through estimator, without slope annealing:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;stochastic during training, stochastic during test&lt;/li&gt;
&lt;li&gt;stochastic during training, deterministic during test&lt;/li&gt;
&lt;li&gt;deterministic during training, deterministic during test&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The results show that deterministic neurons train the fastest, but also display more overfitting and may not achieve the best final results. Stochastic inference and deterministic inference, when combined with stochastic training, are closely comparable. Similar results hold for the REINFORCE estimator.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;res1 &lt;span class="op"&gt;=&lt;/span&gt; train_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;100&lt;/span&gt;], estimator&lt;span class="op"&gt;=&lt;/span&gt;StochasticGradientEstimator.ST, epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;20&lt;/span&gt;,
                        lr&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.3&lt;/span&gt;, slope_annealing_rate &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="fl"&gt;1.1&lt;/span&gt;, label &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Stochastic, Stochastic&amp;quot;&lt;/span&gt;)
res2 &lt;span class="op"&gt;=&lt;/span&gt; train_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;100&lt;/span&gt;], estimator&lt;span class="op"&gt;=&lt;/span&gt;StochasticGradientEstimator.ST, epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;20&lt;/span&gt;,
                        lr&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.3&lt;/span&gt;, slope_annealing_rate &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="fl"&gt;1.1&lt;/span&gt;, stochastic_eval&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;, label &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Stochastic, Deterministic&amp;quot;&lt;/span&gt;)
res3 &lt;span class="op"&gt;=&lt;/span&gt; train_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;100&lt;/span&gt;], estimator&lt;span class="op"&gt;=&lt;/span&gt;StochasticGradientEstimator.ST, epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;20&lt;/span&gt;,
                        lr&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.3&lt;/span&gt;, slope_annealing_rate &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="fl"&gt;1.1&lt;/span&gt;, stochastic_train&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;, stochastic_eval&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;,
                        label &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Deterministic, Deterministic&amp;quot;&lt;/span&gt;)

plot_n(res1 &lt;span class="op"&gt;+&lt;/span&gt; res2 &lt;span class="op"&gt;+&lt;/span&gt; res3,
       lower_y&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.6&lt;/span&gt;, title&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;Experiment 5: Stochastic vs Deterministic (Slope-annealed ST)&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Epoch 20 0.9776
Epoch 20 0.977
Epoch 20 0.9704&lt;/code&gt;&lt;/pre&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/BSN_output_28_1.png" alt="png" /&gt;&lt;figcaption&gt;png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h4 id="experiment-6-the-effect-of-depth-on-reinforce-and-st-estimators"&gt;Experiment 6: The effect of depth on REINFORCE and ST estimators&lt;/h4&gt;
&lt;p&gt;Next, I look at how each estimator interacts with depth. From a theoretical perpective, there is reason to think the straight-through estimator will suffer from depth; as noted by &lt;a href="https://arxiv.org/abs/1308.3432"&gt;Bengio et al. (2013)&lt;/a&gt;, it is not even guaranteed to have the same sign as the expected gradient during backpropagation. It turns out that the slope-annealed straight-through estimator is resilient to depth, even at a reasonable learning rate. The REINFORCE estimator, on the other hand, starts to fail as depth is introduced. However, if we lower the learning rate dramatically (25x), we can start to get the deeper networks to train with the REINFORCE estimator.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;res1 &lt;span class="op"&gt;=&lt;/span&gt; train_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;100&lt;/span&gt;], estimator&lt;span class="op"&gt;=&lt;/span&gt;StochasticGradientEstimator.ST, epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;20&lt;/span&gt;,
                        lr&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.3&lt;/span&gt;, slope_annealing_rate&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;1.1&lt;/span&gt;, label &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;1 hidden layer&amp;quot;&lt;/span&gt;)
res2 &lt;span class="op"&gt;=&lt;/span&gt; train_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;100&lt;/span&gt;, &lt;span class="dv"&gt;100&lt;/span&gt;], estimator&lt;span class="op"&gt;=&lt;/span&gt;StochasticGradientEstimator.ST, epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;20&lt;/span&gt;,
                        lr&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.3&lt;/span&gt;, slope_annealing_rate&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;1.1&lt;/span&gt;, label &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;2 hidden layers&amp;quot;&lt;/span&gt;)
res3 &lt;span class="op"&gt;=&lt;/span&gt; train_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;100&lt;/span&gt;, &lt;span class="dv"&gt;100&lt;/span&gt;, &lt;span class="dv"&gt;100&lt;/span&gt;], estimator&lt;span class="op"&gt;=&lt;/span&gt;StochasticGradientEstimator.ST, epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;20&lt;/span&gt;,
                        lr&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.3&lt;/span&gt;, slope_annealing_rate&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;1.1&lt;/span&gt;, label &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;3 hidden layers&amp;quot;&lt;/span&gt;)

plot_n(res1[&lt;span class="dv"&gt;1&lt;/span&gt;:] &lt;span class="op"&gt;+&lt;/span&gt; res2[&lt;span class="dv"&gt;1&lt;/span&gt;:] &lt;span class="op"&gt;+&lt;/span&gt; res3[&lt;span class="dv"&gt;1&lt;/span&gt;:], title&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;Experiment 6: The effect of depth (straight-through)&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Epoch 20 0.9774
Epoch 20 0.9738
Epoch 20 0.9728&lt;/code&gt;&lt;/pre&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/BSN_output_30_1.png" alt="png" /&gt;&lt;figcaption&gt;png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;res1 &lt;span class="op"&gt;=&lt;/span&gt; train_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;100&lt;/span&gt;], estimator&lt;span class="op"&gt;=&lt;/span&gt;StochasticGradientEstimator.REINFORCE, epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;20&lt;/span&gt;,
                       lr&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.05&lt;/span&gt;, label &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;1 hidden layer&amp;quot;&lt;/span&gt;)
res2 &lt;span class="op"&gt;=&lt;/span&gt; train_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;100&lt;/span&gt;,&lt;span class="dv"&gt;100&lt;/span&gt;], estimator&lt;span class="op"&gt;=&lt;/span&gt;StochasticGradientEstimator.REINFORCE, epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;20&lt;/span&gt;,
                       lr&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.05&lt;/span&gt;, label &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;2 hidden layers&amp;quot;&lt;/span&gt;)
res3 &lt;span class="op"&gt;=&lt;/span&gt; train_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;100&lt;/span&gt;,&lt;span class="dv"&gt;100&lt;/span&gt;,&lt;span class="dv"&gt;100&lt;/span&gt;], estimator&lt;span class="op"&gt;=&lt;/span&gt;StochasticGradientEstimator.REINFORCE, epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;20&lt;/span&gt;,
                       lr&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.05&lt;/span&gt;, label &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;3 hidden layers&amp;quot;&lt;/span&gt;)

plot_n(res1[&lt;span class="dv"&gt;1&lt;/span&gt;:] &lt;span class="op"&gt;+&lt;/span&gt; res2[&lt;span class="dv"&gt;1&lt;/span&gt;:] &lt;span class="op"&gt;+&lt;/span&gt; res3[&lt;span class="dv"&gt;1&lt;/span&gt;:], title&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;Experiment 6: The effect of depth (REINFORCE)&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Epoch 20 0.9302
Epoch 20 0.8788
Epoch 20 0.2904&lt;/code&gt;&lt;/pre&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/BSN_output_31_1.png" alt="png" /&gt;&lt;figcaption&gt;png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;res1 &lt;span class="op"&gt;=&lt;/span&gt; train_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;100&lt;/span&gt;], epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;50&lt;/span&gt;, non_binary&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;,
                       lr&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.002&lt;/span&gt;, label &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;1 hidden layer&amp;quot;&lt;/span&gt;)
res2 &lt;span class="op"&gt;=&lt;/span&gt; train_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;100&lt;/span&gt;,&lt;span class="dv"&gt;100&lt;/span&gt;], epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;50&lt;/span&gt;, non_binary&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;,
                       lr&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.002&lt;/span&gt;, label &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;2 hidden layers&amp;quot;&lt;/span&gt;)
res3 &lt;span class="op"&gt;=&lt;/span&gt; train_classifier(hidden_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;100&lt;/span&gt;,&lt;span class="dv"&gt;100&lt;/span&gt;,&lt;span class="dv"&gt;100&lt;/span&gt;], epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;50&lt;/span&gt;, non_binary&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;,
                       lr&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.002&lt;/span&gt;, label &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;3 hidden layers&amp;quot;&lt;/span&gt;)

plot_n(res1[&lt;span class="dv"&gt;1&lt;/span&gt;:] &lt;span class="op"&gt;+&lt;/span&gt; res2[&lt;span class="dv"&gt;1&lt;/span&gt;:] &lt;span class="op"&gt;+&lt;/span&gt; res3[&lt;span class="dv"&gt;1&lt;/span&gt;:], title&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;Experiment 6: The effect of depth (REINFORCE) (LR = 0.002)&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Epoch 50 0.931
Epoch 50 0.9294
Epoch 50 0.9096&lt;/code&gt;&lt;/pre&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/BSN_output_32_1.png" alt="png" /&gt;&lt;figcaption&gt;png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h4 id="experiment-7-using-binary-stochastic-neurons-as-a-regularizer."&gt;Experiment 7: Using binary stochastic neurons as a regularizer.&lt;/h4&gt;
&lt;p&gt;I now test the “unpublished result” put forth at the end of &lt;a href="https://www.youtube.com/watch?v=LN0xtUuJsEI&amp;amp;list=PLoRl3Ht4JOcdU872GhiYWf6jwrk_SNhz9&amp;amp;index=41"&gt;Hinton et al.’s Coursera Lecture 9c&lt;/a&gt;, which states that we can improve upon the performance of an overfitting multi-layer sigmoid net by turning its neurons binary stochastic neurons with a straight-through estimator.&lt;/p&gt;
&lt;p&gt;To test the claim, we will need a dataset that is easier to overfit than MNIST, and so the following experiment uses the MNIST validation set for training (10x smaller than the MNIST training set and therefore much easier to overfit). The hidden layer size is also increased by a factor of 2 to increase overfitting.&lt;/p&gt;
&lt;p&gt;We can see below that the stochastic net has a clear advantage in terms of both the generalization gap and training speed, ultimately resulting in a better final fit.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;res1 &lt;span class="op"&gt;=&lt;/span&gt; train_classifier(hidden_dims &lt;span class="op"&gt;=&lt;/span&gt; [&lt;span class="dv"&gt;200&lt;/span&gt;], epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;20&lt;/span&gt;, train_set&lt;span class="op"&gt;=&lt;/span&gt;mnist.validation, val_set&lt;span class="op"&gt;=&lt;/span&gt;mnist.test,
                        lr &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="fl"&gt;0.03&lt;/span&gt;, non_binary &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="va"&gt;True&lt;/span&gt;, label &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Deterministic sigmoid net&amp;quot;&lt;/span&gt;)

res2 &lt;span class="op"&gt;=&lt;/span&gt; train_classifier(hidden_dims &lt;span class="op"&gt;=&lt;/span&gt; [&lt;span class="dv"&gt;200&lt;/span&gt;], epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;20&lt;/span&gt;, stochastic_eval&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;, train_set&lt;span class="op"&gt;=&lt;/span&gt;mnist.validation,
                        val_set&lt;span class="op"&gt;=&lt;/span&gt;mnist.test, slope_annealing_rate&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;1.1&lt;/span&gt;, estimator&lt;span class="op"&gt;=&lt;/span&gt;StochasticGradientEstimator.ST,
                        lr &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="fl"&gt;0.3&lt;/span&gt;, label &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Binary stochastic net&amp;quot;&lt;/span&gt;)

plot_n(res1 &lt;span class="op"&gt;+&lt;/span&gt; res2, lower_y&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.8&lt;/span&gt;, title&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;Experiment 8: Using binary stochastic neurons as a regularizer&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Epoch 20 0.9276
Epoch 20 0.941&lt;/code&gt;&lt;/pre&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/BSN_output_34_1.png" alt="png" /&gt;&lt;figcaption&gt;png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h3 id="conclusion"&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;In this post we introduced, implemented and experimented with binary stochastic neurons in Tensorflow. We saw that the biased straight-through estimator generally outperforms the unbiased REINFORCE estimator, and can even outperform a non-stochastic, non-binary sigmoid net. We explored the variants of each estimator, and showed that the slope-annealed straight through estimator is better than other straight through variants, and that it is worth using the variance-adjusted REINFORCE estimator over the not variance-adjusted REINFORCE estimator. Finally, we explored the potential use for binary stochastic neurons as regularizers, and demonstrated that a stochastic binary network trained with the slope-annealed straight through estimator trains faster and generalizes better than an ordinary sigmoid net.&lt;/p&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: In a previous version of this post, I had instead used &lt;span class="math inline"&gt;\(\frac{d\text{BSN}(a)}{da} = \text{BSN}(a)\)&lt;/span&gt;. This formulation would return the identity if the binary neuron evaluated to 1, and 0 otherwise. I had similarly multiplied the derivatives of the two variants (sigmoid-adjusted and slope-annealed) by a factor of &lt;span class="math inline"&gt;\(\text{BSN}(a)\)&lt;/span&gt;. This prior formulation was consistent with my reading of Bengio et al. (2013) and achieved respectable results, but in light of a comment made on this post, and upon review of Hinton’s Coursera lecture where the straight-through estimator is first proposed, I believe the version now reflected in the post, &lt;span class="math inline"&gt;\(\frac{d\text{BSN}(a)}{da} = 1\)&lt;/span&gt;, is more correct. Although the pass-through variant performs worse with the revised derivative, the sigmoid-adjusted and slope-annealed variants benefit greatly from this change, outperforming both new and old pass-through formulations by a respectable margin.&lt;a href="#fnref1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
&lt;/body&gt;
&lt;/html&gt;
</content></entry><entry><title>Preliminary Note on the Complexity of a Neural Network</title><link href="https://r2rt.com/preliminary-note-on-the-complexity-of-a-neural-network.html" rel="alternate"></link><published>2016-08-16T00:00:00-04:00</published><updated>2016-08-16T00:00:00-04:00</updated><author><name>Silviu Pitis</name></author><id>tag:r2rt.com,2016-08-16:/preliminary-note-on-the-complexity-of-a-neural-network.html</id><summary type="html">This post is a preliminary note on the "complexity" of neural networks. It's a topic that has not gotten much attention in the literature, yet is of central importance to the general understanding of neural networks. In this post I discuss complexity and generalization in broad terms, and make the argument that network structure (including parameter counts), the training methodology, and the regularizers used, though each different in concept, all contribute to this notion of neural network "complexity".</summary><content type="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;meta name="generator" content="pandoc"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes"&gt;
  &lt;title&gt;&lt;/title&gt;
  &lt;style type="text/css"&gt;code{white-space: pre;}&lt;/style&gt;
  &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"&gt;&lt;/script&gt;
  &lt;!--[if lt IE 9]&gt;
    &lt;script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"&gt;&lt;/script&gt;
  &lt;![endif]--&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;This post is a preliminary note on the “complexity” of neural networks. It’s a topic that has not gotten much attention in the literature, yet is of central importance to our general understanding of neural networks. In this post I discuss complexity and generalization in broad terms, and make the argument that network structure (including parameter counts), the training methodology, and the regularizers used, though each different in concept, all contribute to this notion of neural network “complexity”.&lt;/p&gt;
&lt;h3 id="model-complexity-and-selection"&gt;Model complexity and selection&lt;/h3&gt;
&lt;p&gt;In designing neural networks there is an inevitable trade-off between model complexity and generalization performance. On one hand, we want the model to be expressive and have the ability to model highly complex non-linear relationships. On the other hand, the more expressive the model, the more capable it is of memorizing the training data. This is the problem of &lt;strong&gt;model selection&lt;/strong&gt; and it is closely related to the “complexity” of the model: pick a model that is too simple and it will “underfit” the data, but pick a model that is too complex and it will “overfit” the data.&lt;/p&gt;
&lt;p&gt;There is no consistent analytical definition of complexity, but one reasonable way of to think about it is the effective number of distinct hypotheses the model could potentially represent after training; i.e., the effective number of patterns that the model is capable of describing. See, e.g., &lt;a href="http://amlbook.com/"&gt;Abu-Mostafa eta al.&lt;/a&gt; or &lt;a href="http://www.pnas.org/content/97/21/11170.long"&gt;Myung et al. (2000)&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;When it comes to neural networks, this notion of complexity and the problem of model selection are delicate subjects. Whereas certain analytical criteria exist for balancing complexity and generalization in traditional statistical models, these criteria have not been extended in any compelling, generally applicable way to the analysis neural networks.&lt;a href="#fn1" class="footnoteRef" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; As a result, the primary approach for neural network model selection has not been analytical, but rather empirical: cross-validation.&lt;/p&gt;
&lt;p&gt;This is unfortunate because it is difficult to compare neural network architectures using only empirical tests. One reason for this is that the effects of different architectural features and hyperparameters on complexity are not necessarily independent, which means that the size of the search grows exponentially in the number of features or hyperparameters (including, e.g., the choice of regularizers). Furthermore, these effects are not necessarily independent of the dataset (e.g., a feature that is ineffective on a small dataset may be very effective on a large one), and so results may not generalize across tasks. As a single state of the art model can take hours, days or even weeks to train on modern hardware, this spells bad news for finding the “best” model. Cf., e.g., &lt;a href="https://arxiv.org/abs/1412.3555"&gt;Chung et al. (2014)&lt;/a&gt; (conducts an empirical comparison of the GRU and LSTM and is unable to determine whether one architecture is superior to the other).&lt;/p&gt;
&lt;p&gt;This difficulty is not restricted to comparing entire architectures: the fact that adding or removing a feature changes the model complexity makes it difficult to evaluate the efficacy of that single feature. This generally affects the strength of results favoring proposed features in the literature.&lt;/p&gt;
&lt;p&gt;But not all hope is lost. In some cases, we can put forth theoretical grounds for the superiority of one architecture over another. See, e.g., my post on &lt;a href="https://r2rt.com/written-memories-understanding-deriving-and-extending-the-lstm.html"&gt;Written Memories&lt;/a&gt;, which argues that the proposed pseudo LSTM is objectively better than the basic LSTM. In other cases, an architecture or feature overwhelmingly outperforms the competition in a wide range of configurations. In these cases, we can assume the position that one architecture is superior than another, while keeping in the back of our minds the possibility that our conclusion may not generalize to all cases. Sometimes (and ideally), a proposed feature has both strong theoretical grounds and undeniably empirical performance. See, e.g., &lt;a href="https://arxiv.org/abs/1502.03167"&gt;Ioffe and Szegedy (2015)&lt;/a&gt;, which introduced batch normalization for feedforward neural networks.&lt;/p&gt;
&lt;p&gt;Yet in most cases, we are stuck with many alternatives and little guidance as to how to choose between them, or as to whether such choices even matter. If we had some broadly applicable and theoretically grounded measure of model complexity at our disposal, it would be incredibly useful for making such determinations. I am planning a follow-up post to explore this problem in more detail. For this preliminary note, however, I want to make a few comments on the factors that contribute to model complexity, which include the network structure, the training methodology and the regularization methods used.&lt;/p&gt;
&lt;h4 id="network-structure"&gt;Network structure&lt;/h4&gt;
&lt;p&gt;It’s quite common for authors to use the “number of parameters” as a proxy for model complexity to support the inference that one architecture is better than another (with fewer parameters being better). See e.g., &lt;a href="https://arxiv.org/abs/1607.03474"&gt;Zilly et al. (2016)&lt;/a&gt; (“[Our model] outperforms [the competing model] using less than half the parameters…”), &lt;a href="https://arxiv.org/abs/1508.06615"&gt;Kim et al. (2015)&lt;/a&gt; (“[Our model] is on par with the existing state-of-the-art despite having 60% fewer parameters.”), and &lt;a href="https://arxiv.org/abs/1606.06630"&gt;Wu et al. (2016)&lt;/a&gt;(“… the number of parameters [is] largely reduced, which makes our model more practical for large scale problems, while &lt;em&gt;avoiding overfitting&lt;/em&gt;.” (&lt;em&gt;emphasis added&lt;/em&gt;)), among many others. I sympathize with the approach, if only because there exists no established criteria for measuring parametric complexity of neural networks, but using simple parameter counts for this purpose is misleading.&lt;a href="#fn2" class="footnoteRef" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;In particular, different models with the same number of parameters may have quite different complexities as result of the model’s functional form. This is true for all models, not just neural networks. As a trivial example, consider that the double biases in the model &lt;span class="math inline"&gt;\(\alpha_0 x + \alpha_1 + \alpha_2\)&lt;/span&gt; are really one parameter masquerading as two. See &lt;a href="http://www.pnas.org/content/97/21/11170.long"&gt;Myung et al. (2000)&lt;/a&gt; for a non-trivial example and a more detailed discussion of the “geometric complexity”. As compared to traditional statistical models, however, neural networks are particularly succeptible to this kind of structural complexity; the number of hidden layers, the connectivity between them, and the activation functions used are just a few examples of structural features that impact network complexity. That said, if the network structure of two models is similar (e.g., same number of layers and same activation functions), the complexity of the model will generally be a monotonically increasing function of the number of parameters.&lt;/p&gt;
&lt;h4 id="training-method"&gt;Training method&lt;/h4&gt;
&lt;p&gt;It might be surprising that the training method (e.g., the combination of initialization method, loss function and optimization algorithm) can be viewed as a factor in model complexity. To see this, consider that the complexity of a model can be interpretted as the effective number of patterns the model can represent after training, but that even if some choice of parameters could represent pattern A, pattern A may not be reachable gradient descent (or, more likely, pattern A could be very difficult to reach relative to pattern B). Here is an illustration:&lt;/p&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/RR_unreachable_pattern.png" alt="Unreachable pattern" /&gt;&lt;figcaption&gt;Unreachable pattern&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;Note that this illustration is oversimplified, in that we would have to consider the “reachableness” of pattern A under all potential datasets, not just this one dataset.&lt;/p&gt;
&lt;p&gt;This is an interesting perspective that has a slightly different flavor than criteria such as Rissanen’s &lt;a href="https://en.wikipedia.org/wiki/Minimum_description_length"&gt;minimum description length&lt;/a&gt;. Taking this broad view of complexity, we see that the learning rate, which is the first hyperparameter we tune when training neural networks, directly impacts the model’s complexity. E.g., a high learning rate will bias our model away from local minima that are located in narrow valleys. This same argument applies to batch size and truncated backpropagation steps.&lt;/p&gt;
&lt;h4 id="regularization"&gt;Regularization&lt;/h4&gt;
&lt;p&gt;Finally, somewhere in between structural features and the training method lie regularizers. Consider that dropout can be viewed as a modification to the training method (since the model’s architecture is unchanged at test time) or as an ensemble method (see, e.g., &lt;a href="https://papers.nips.cc/paper/4878-understanding-dropout"&gt;Baldi and Sadowski (2013)&lt;/a&gt;). Similarly, weight decay might be viewed as a direct modification to the loss function that modifies the training method, or as a structural feature. To see how weight decay can be interpretted as a structural feature, compare it to a hard “cap” on the parameters, say a restriction to the interval [-0.5, 0.5]. This is a structural change that impacts the number of representable hypotheses, but the function of weight decay is very similar, only that it serves as a soft cap.&lt;/p&gt;
&lt;h3 id="future-work"&gt;Future Work&lt;/h3&gt;
&lt;p&gt;This topic has been on my mind recently as I wrestle with the question of how to justify an argument that one architecture is better than another. I’m currently working toward a couple preliminary ideas for an analytical approach to neural network complexity, which I will write about in case they pan out. In the meantime, if you are aware of any research in this area, I would greatly appreciate if you could share it in the comments!&lt;/p&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;There have, however, been specific applications of these analytical criteria. See, e.g., &lt;a href="http://www.cs.toronto.edu/~fritz/absps/colt93.pdf"&gt;Hinton and van Camp (1993)&lt;/a&gt;, which shows how weight decay and weight noise can be justified using the minimum description length (MDL) criteria.&lt;a href="#fnref1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;It’s true that models with fewer parameters will be smaller in size (memory footprint / space), which could be advantageous for large models. The intent of pointing out a lower parameter count, however, is usually to signify that the model is less complex and therefore less prone to overfitting.&lt;a href="#fnref2"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
&lt;/body&gt;
&lt;/html&gt;
</content></entry><entry><title>Written Memories: Understanding, Deriving and Extending the LSTM</title><link href="https://r2rt.com/written-memories-understanding-deriving-and-extending-the-lstm.html" rel="alternate"></link><published>2016-07-26T00:00:00-04:00</published><updated>2016-07-26T00:00:00-04:00</updated><author><name>Silviu Pitis</name></author><id>tag:r2rt.com,2016-07-26:/written-memories-understanding-deriving-and-extending-the-lstm.html</id><summary type="html">When I was first introduced to Long Short-Term Memory networks (LSTMs), it was hard to look past their complexity. I didn't understand why they were designed the way they were designed, just that they worked. It turns out that LSTMs can be understood, and that, despite their superficial complexity, LSTMs are actually based on a couple incredibly simple, even beautiful, insights into neural networks. This post is what I wish I had when first learning about recurrent neural networks (RNNs).</summary><content type="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;meta name="generator" content="pandoc"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes"&gt;
  &lt;title&gt;&lt;/title&gt;
  &lt;style type="text/css"&gt;code{white-space: pre;}&lt;/style&gt;
  &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"&gt;&lt;/script&gt;
  &lt;!--[if lt IE 9]&gt;
    &lt;script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"&gt;&lt;/script&gt;
  &lt;![endif]--&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;When I was first introduced to Long Short-Term Memory networks (LSTMs), it was hard to look past their complexity. I didn’t understand why they were designed the way they were designed, just that they worked. It turns out that LSTMs can be understood, and that, despite their superficial complexity, LSTMs are actually based on a couple incredibly simple, even beautiful, insights into neural networks. This post is what I wish I had when first learning about recurrent neural networks (RNNs).&lt;/p&gt;
&lt;p&gt;In this post, we do a few things:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;We’ll define and describe RNNs generally, focusing on the limitations of vanilla RNNs that led to the development of the LSTM.&lt;/li&gt;
&lt;li&gt;We’ll describe the intuitions behind the LSTM architecture, which will enable us to build up to and derive the LSTM. Along the way we will derive the GRU. We’ll also derive a pseudo LSTM, which we’ll see is better in principle and performance to the standard LSTM.&lt;/li&gt;
&lt;li&gt;We’ll then extend these intuitions to show how they lead directly to a few recent and exciting architectures: highway and residual networks, and Neural Turing Machines.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This is a post about theory, not implementations. For how to implement RNNs using Tensorflow, check out my posts &lt;a href="https://r2rt.com/recurrent-neural-networks-in-tensorflow-i.html"&gt;Recurrent Neural Networks in Tensorflow I&lt;/a&gt; and &lt;a href="https://r2rt.com/recurrent-neural-networks-in-tensorflow-ii.html"&gt;Recurrent Neural Networks in Tensorflow II&lt;/a&gt;.&lt;/p&gt;
&lt;h4 id="contents-quick-links"&gt;Contents / quick links:&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#recurrent-neural-networks"&gt;Recurrent neural networks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#what-rnns-can-do-choosing-the-time-step"&gt;What RNNs can do; choosing the time step&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#the-vanilla-rnn"&gt;The vanilla RNN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#information-morphing-and-vanishing-and-exploding-sensitivity"&gt;Information morphing and vanishing and exploding sensitivity&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#a-mathematically-sufficient-condition-for-vanishing-sensitivity"&gt;A mathematically sufficient condition for vanishing sensitivity&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#a-minimum-weight-initialization-for-avoid-vanishing-gradients"&gt;A minimum weight initialization for avoid vanishing gradients&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#backpropagation-through-time-and-vanishing-sensitivity"&gt;Backpropagation through time and vanishing sensitivity&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#dealing-with-vanishing-and-exploding-gradients"&gt;Dealing with vanishing and exploding gradients&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#written-memories-the-intuition-behind-lstms"&gt;Written memories: the intuition behind LSTMs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#using-selectivity-to-control-and-coordinate-writing"&gt;Using selectivity to control and coordinate writing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#gates-as-a-mechanism-for-selectivity"&gt;Gates as a mechanism for selectivity&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#gluing-gates-together-to-derive-a-prototype-lstm"&gt;Gluing gates together to derive a prototype LSTM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#three-working-models-the-normalized-prototype-the-gru-and-the-pseudo-lstm"&gt;Three working models: the normalized prototype, the GRU and the pseudo LSTM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#deriving-the-lstm"&gt;Deriving the LSTM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#the-lstm-with-peepholes"&gt;The LSTM with peepholes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#an-empirical-comparison-of-the-basic-lstm-and-the-pseudo-lstm"&gt;An empirical comparison of the basic LSTM and the pseudo LSTM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#extending-the-lstm"&gt;Extending the LSTM&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="prerequisites"&gt;Prerequisites&lt;a href="#fn1" class="footnoteRef" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;This post assumes the reader is already familiar with:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;Feedforward neural networks&lt;/li&gt;
&lt;li&gt;Backpropagation&lt;/li&gt;
&lt;li&gt;Basic linear algebra&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We’ll review everything else, starting with RNNs in general.&lt;/p&gt;
&lt;h3 id="recurrent-neural-networks"&gt;Recurrent neural networks&lt;/h3&gt;
&lt;p&gt;From one moment to the next, our brain operates as a function: it accepts inputs from our senses (external) and our thoughts (internal) and produces outputs in the form of actions (external) and new thoughts (internal). We see a bear and then think “bear”. We can model this behavior with a feedforward neural network: we can teach a feedforward neural network to think “bear” when it is shown an image of a bear.&lt;/p&gt;
&lt;p&gt;But our brain is not a one-shot function. It runs repeatedly through time. We see a bear, then think “bear”, then think “run”.&lt;a href="#fn2" class="footnoteRef" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; Importantly, the very same function that transforms the image of a bear into the thought “bear” also transforms the thought “bear” into the thought “run”. It is a &lt;em&gt;recurring&lt;/em&gt; function, which we can model with a &lt;em&gt;recurrent&lt;/em&gt; neural network (RNN).&lt;/p&gt;
&lt;p&gt;An RNN is a composition of identical feedforward neural networks, one for each moment, or step in time, which we will refer to as “RNN cells”. Note that this is a much broader definition of an RNN than that usually given (the “vanilla” RNN is covered later on as a precursor to the LSTM). These cells operate on their own output, allowing them to be composed. They can also operate on external input and produce external output. Here is a diagram of a single RNN cell:&lt;/p&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/NH_SingleRNNcell.png" alt="Single RNN Cell" /&gt;&lt;figcaption&gt;Single RNN Cell&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;Here is a diagram of three composed RNN cells:&lt;/p&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/NH_ComposedRNNcells.png" alt="Composed RNN Cells" /&gt;&lt;figcaption&gt;Composed RNN Cells&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;You can think of the recurrent outputs as a “state” that is passed to the next timestep. Thus an RNN cell accepts a prior state and an (optional) current input and produces a current state and an (optional) current output.&lt;/p&gt;
&lt;p&gt;Here is the algebraic description of the RNN cell:&lt;/p&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[\left(\begin{matrix}
      s_t \\
      o_t \\
    \end{matrix}\right) =
    f\left(\begin{matrix}
          s_{t-1} \\
          x_t \\
        \end{matrix}\right)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;where:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math inline"&gt;\(s_t\)&lt;/span&gt; and &lt;span class="math inline"&gt;\(s_{t-1}\)&lt;/span&gt; are our current and prior states,&lt;/li&gt;
&lt;li&gt;&lt;span class="math inline"&gt;\(o_t\)&lt;/span&gt; is our (possibly empty) current output,&lt;/li&gt;
&lt;li&gt;&lt;span class="math inline"&gt;\(x_t\)&lt;/span&gt; is our (possibly empty) current input, and&lt;/li&gt;
&lt;li&gt;&lt;span class="math inline"&gt;\(f\)&lt;/span&gt; is our recurrent function.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Our brain operates in place: current neural activity takes the place of past neural activity. We can see RNNs as operating in place as well: because RNN cells are identical, they can all be viewed as the same object, with the “state” of the RNN cell being overwritten at each time step. Here is a diagram of this framing:&lt;/p&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/NH_StateLoop.png" alt="RNN State Loop" /&gt;&lt;figcaption&gt;RNN State Loop&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;Most introductions to RNNs start with this “single cell loop” framing, but I think you’ll find the sequential frame more intuitive, particularly when thinking about backpropagation. When starting with the single cell loop framing, RNN’s are said to “unrolled” to obtain the sequential framing above.&lt;/p&gt;
&lt;h3 id="what-rnns-can-do-choosing-the-time-step"&gt;What RNNs can do; choosing the time step&lt;/h3&gt;
&lt;p&gt;The RNN structure described above is incredibly general. In theory, it can do anything: if we give the neural network inside each cell at least one hidden layer, each cell becomes a universal function approximator.&lt;a href="#fn3" class="footnoteRef" id="fnref3"&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; This means that an RNN cell can emulate any function, from which it follows that an RNN could, in theory, emulate our brain perfectly. Though we know that the brain can theoretically be modeled this way, it’s an entirely different matter to actually design and train an RNN to do this. We are, however, making good progress.&lt;/p&gt;
&lt;p&gt;With this analogy of the brain in mind, all we need to do to see how we can use an RNN to handle a task is to ask how a human would handle the same task.&lt;/p&gt;
&lt;p&gt;Consider, for example, English-to-French translation. A human reads an English sentence (“the cat sat on the mat”), pauses, and then writes out the French translation (“le chat s’assit sur le tapis”). To emulate this behavior with an RNN, the only choice we have to make (other than designing the RNN cell itself, which for now we treat as a black box) is deciding what the time steps used should be, which determines the form the inputs and outputs, or how the RNN interacts with the external world.&lt;/p&gt;
&lt;p&gt;One option is to set the time step according to the content. That is, we might use the entire sentence as a time step, in which case our RNN is just a feed-forward network:&lt;/p&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/NH_SentenceTimeStep.png" alt="Translation using sentence-based time step" /&gt;&lt;figcaption&gt;Translation using sentence-based time step&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;The final state does not matter when translating a single sentence. It might matter, however, if the sentence were part of a paragraph being translated, since it would contain information about the prior sentences. Note that the intial state is indicated above as blank, but when evaluating individual sequences, it can useful to train the initial state as a variable. It may be that the best “a sequence is starting” state representation might not be the blank zero state.&lt;/p&gt;
&lt;p&gt;Alternatively, we might say that each word or each character is a time step. Here is an illustration of what an RNN translating “the cat sat” on a per word basis might look like:&lt;/p&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/NH_WordTimeStep.png" alt="Translation using word-based time step" /&gt;&lt;figcaption&gt;Translation using word-based time step&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;After the first time step, the state contains an internal representation of “the”; after the second, of “the cat”; after the the third, “the cat sat”. The network does not produce any outputs at the first three time steps. It starts producing outputs when it receives a blank input, at which point it knows the input has terminated. When it is done producing outputs, it produces a blank output to signal that it’s finished.&lt;/p&gt;
&lt;p&gt;In practice, even powerful RNN architectures like deep LSTMs might not perform well on multiple tasks (here there are two: reading, then translating). To accomodate this, we can split the network into multiple RNNs, each of which specializes in one task. In this example, we would use an “encoder” network that reads in the English (blue) and a separate “decoder” network that reads in the French (orange):&lt;/p&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/NH_WordTimeStep_SeparateRNNs.png" alt="Translation using word-based time step and two RNNs" /&gt;&lt;figcaption&gt;Translation using word-based time step and two RNNs&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;Additionally, as shown in the above diagram, the decoder network is being fed in the last true value (i.e., the target value during training, and the network’s prior choice of translated word during testing). For an example of an RNN encoder-decoder model, see &lt;a href="https://arxiv.org/pdf/1406.1078v3.pdf"&gt;Cho et al. (2014)&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Notice that having two separate networks still fits the definition of a single RNN: we can define the recurring function as a split function that takes, alongside its other inputs, an input specifying which split of the function to use.&lt;/p&gt;
&lt;p&gt;The time step does not have to be content-based; it can be an actual unit of time. For example, we might consider the time step to be one second, and enforce a reading rate of 5 characters per second. The inputs for the first three time steps would be &lt;code&gt;the c&lt;/code&gt;, &lt;code&gt;at sa&lt;/code&gt; and &lt;code&gt;t on&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We could also do something more interesting: we can let the RNN decide when its ready to move on to the next input, and even what that input should be. This is similar to how a human might focus on certain words or phrases for an extended period of time to translate them or might double back through the source. To do this, we use the RNN’s output (an external action) to determine its next input dynamically. For example, we might have the RNN output actions like “read the last input again”, “backtrack 5 timesteps of input”, etc. Successful attention-based translation models are a play on this: they accept the entire English sequence at each time step and their RNN cell decides which parts are most relevant to the current French word they are producing.&lt;/p&gt;
&lt;p&gt;There is nothing special about this English-to-French translation example. Whatever the human task we choose, we can build different RNN models by choosing different time steps. We can even reframe something like handwritten digit recognition, for which a one-shot function (single time step) is the typical approach, as a many-time step task. Indeed, take a look at some of the MNIST digits yourself and observe how you need to focus on some longer than others. Feedforward neural networks cannot exhibit that behavior; RNNs can.&lt;/p&gt;
&lt;h3 id="the-vanilla-rnn"&gt;The vanilla RNN&lt;/h3&gt;
&lt;p&gt;Now that we’ve covered the big picture, lets take a look inside the RNN cell. The most basic RNN cell is a single layer neural network, the output of which is used as both the RNN cell’s current (external) output and the RNN cell’s current state:&lt;/p&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/NH_VanillaRNNcell.png" alt="Vanilla RNN Cell" /&gt;&lt;figcaption&gt;Vanilla RNN Cell&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;Note how the prior state vector is the same size as the current state vector. As discussed above, this is critical for composition of RNN cells. Here is the algebraic description of the vanilla RNN cell:&lt;/p&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[s_t = \phi(Ws_{t-1} + Ux_t + b)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;where:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math inline"&gt;\(\phi\)&lt;/span&gt; is the activation function (e.g., sigmoid, tanh, ReLU),&lt;/li&gt;
&lt;li&gt;&lt;span class="math inline"&gt;\(s_t \in \Bbb{R}^n\)&lt;/span&gt; is the current state (and current output),&lt;/li&gt;
&lt;li&gt;&lt;span class="math inline"&gt;\(s_{t-1} \in \Bbb{R}^n\)&lt;/span&gt; is the prior state,&lt;/li&gt;
&lt;li&gt;&lt;span class="math inline"&gt;\(x_t \in \Bbb{R}^m\)&lt;/span&gt; is the current input,&lt;/li&gt;
&lt;li&gt;&lt;span class="math inline"&gt;\(W \in \Bbb{R}^{n \times n}\)&lt;/span&gt;, &lt;span class="math inline"&gt;\(U \in \Bbb{R}^{m \times n}\)&lt;/span&gt;, and &lt;span class="math inline"&gt;\(b \in \Bbb{R}^n\)&lt;/span&gt; are the weights and biases, and&lt;/li&gt;
&lt;li&gt;&lt;span class="math inline"&gt;\(n\)&lt;/span&gt; and &lt;span class="math inline"&gt;\(m\)&lt;/span&gt; are the state and input sizes.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Even this basic RNN cell is quite powerful. Though it does not meet the criteria for universal function approximation within a single cell, it is known that a series of composed vanilla RNN cells is Turing complete and can therefore implement any algorithm. See &lt;a href="http://binds.cs.umass.edu/papers/1995_Siegelmann_JComSysSci.pdf"&gt;Siegelmann and Sontag (1992)&lt;/a&gt;. This is nice, in theory, but there is a problem in practice: training vanilla RNNs with backpropagation algorithm turns out to be quite difficult, even more so than training very deep feedforward neural networks. This difficulty is due to the problems of information morphing and vanishing and exploding sensitivity caused by repeated application of the same nonlinear function.&lt;/p&gt;
&lt;h3 id="information-morphing-and-vanishing-and-exploding-sensitivity"&gt;Information morphing and vanishing and exploding sensitivity&lt;a href="#fn4" class="footnoteRef" id="fnref4"&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Instead of the brain, consider modeling the entire world as an RNN: from each moment to the next, the state of the world is modified by a fantastically complex recurring function called time. Now consider how a small change today will affect the world in one hundred years. It could be that something as small as the flutter of a butterfly’s wing will ultimately cause a typhoon halfway around the world.&lt;a href="#fn5" class="footnoteRef" id="fnref5"&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt; But it could also be that our actions today ultimately do not matter. So Einstein wasn’t around to discover relativity? This would have made a difference in the 1950s, but maybe then someone else discovers relativity, so that the difference becomes smaller by the 2000s, and ultimately approaches zero by the year 2050. Finally, it could be that the importance of a small change fluctuates: perhaps Einstein’s discovery was in fact caused by a comment his wife made in response to a butteryfly that happened to flutter by, so that the butterfly exploded into a big change during the 20th century that then quickly vanished.&lt;/p&gt;
&lt;p&gt;In the Einstein example, note that the past change is the introduction of new information (the theory of relativity), and more generally that the introduction of this new information was a direct result of our recurring function (the flow of time). Thus, we can consider information itself as a change that is morphed by the recurring function such that its effects vanish, explode or simply fluctuate.&lt;/p&gt;
&lt;p&gt;This discussion shows that the state of the world (or an RNN) is constantly changing and that the present can be either extremely sensitive or extremely insensitive to past changes: effects can compound or dissolve. These are problems, and they extend to RNNs (and feedforward neural networks) in general:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;Information Morphing&lt;/p&gt;
&lt;p&gt;First, if information constantly morphs, it is difficult to exploit past information properly when we need it. The best usable state of the information may have occured at some point in the past. On top of learning how to exploit the information today (if it were around in its original, usable form), we must also learn how to decode the original state from the current state, if that is even possible. This leads to difficult learning and poor results.&lt;a href="#fn6" class="footnoteRef" id="fnref6"&gt;&lt;sup&gt;6&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;It’s very easy to show that information morphing occurs in a vanilla RNN. Indeed, suppose it were possible for an RNN cell to maintain its prior state completely in the absence of external inputs. Then &lt;span class="math inline"&gt;\(F(x) = \phi(Ws_{t-1} + b)\)&lt;/span&gt; is the identity function with respect to &lt;span class="math inline"&gt;\(s_{t-1}\)&lt;/span&gt;. But the identity function is linear and &lt;span class="math inline"&gt;\(F(x)\)&lt;/span&gt; is nonlinear, so we have a contradiction. Therefore, an RNN cell inevitably morphs the state from one time step to the next. Even the trivial task of outputting &lt;span class="math inline"&gt;\(s_t = x_t\)&lt;/span&gt; is impossible for a vanilla RNN.&lt;/p&gt;
&lt;p&gt;This is the root cause of what is known in some circles as the &lt;em&gt;degradation&lt;/em&gt; problem. See, e.g., &lt;a href="https://arxiv.org/abs/1512.03385"&gt;He et al. (2015)&lt;/a&gt;. The authors of He et al. claims this is “unexpected” and “counterintuitive”, but I hope this discussion shows that the degradation problem, or information morphing, is actually quite natural (and in many cases desirable). We’ll see below that although information morphing was not among the original motivations for introducing LSTMs, the principle behind LSTMs happens to solve the problem effectively. In fact, the effectiveness of the residual networks used by He at al. (2015) is a result of the fundamental principle of LSTMs.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Vanishing and Exploding Gradients&lt;/p&gt;
&lt;p&gt;Second, we train RNNs using the backpropagation algorithm. But backpropagation is a gradient-based algorithm, and vanishing and exploding “sensitivity” is just another way of saying vanishing and exploding gradients (the latter is the accepted term, but I find the former more descriptive). If the gradients explode, we can’t train our model. If they vanish, it’s difficult for us to learn long-term dependencies, since backpropagation will be too sensitive to recent distractions. This makes training difficult.&lt;/p&gt;
&lt;p&gt;I’ll come back to the difficulty of training RNNs via backpropagation in a second, but first I’d like to give a short mathematical demonstration of how easy it is for the vanilla RNN to suffer from the vanishing gradients and what we can do to help avoid this at the start of training.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="a-mathematically-sufficient-condition-for-vanishing-sensitivity"&gt;A mathematically sufficient condition for vanishing sensitivity&lt;/h3&gt;
&lt;p&gt;In this section I give a mathematical proof of a sufficient condition for vanishing sensitivity in vanilla RNNs. This section is a bit mathy, and you can safely skip the details of the proof. It is essentially the same as the proof of the similar result in &lt;a href="http://www.jmlr.org/proceedings/papers/v28/pascanu13.pdf"&gt;Pascanu et al. (2013)&lt;/a&gt;, but I think you will find this presentation easier to follow. The proof here also takes advantage of the mean value theorem to go one step further than Pascanu et al. and reach a slightly stronger result, effectively showing vanishing &lt;em&gt;causation&lt;/em&gt; rather than vanishing sensitivity.&lt;a href="#fn7" class="footnoteRef" id="fnref7"&gt;&lt;sup&gt;7&lt;/sup&gt;&lt;/a&gt; Note that mathematical analyses of vanishing and exploding gradients date back to the early 1990s, in &lt;a href="http://www.dsi.unifi.it/~paolo/ps/tnn-94-gradient.pdf"&gt;Bengio et al. (1994)&lt;/a&gt; and &lt;a href="http://people.idsia.ch/~juergen/SeppHochreiter1991ThesisAdvisorSchmidhuber.pdf"&gt;Hochreiter (1991)&lt;/a&gt; (original in German, relevant portions summarized in &lt;a href="http://isle.illinois.edu/sst/meetings/2015/hochreiter-lstm.pdf"&gt;Hochreiter and Schmidhuber (1997)&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Let &lt;span class="math inline"&gt;\(s_t\)&lt;/span&gt; be our state vector at time &lt;span class="math inline"&gt;\(t\)&lt;/span&gt; and let &lt;span class="math inline"&gt;\(\Delta v\)&lt;/span&gt; be the change in a vector &lt;span class="math inline"&gt;\(v\)&lt;/span&gt; induced by a change in the state vector, &lt;span class="math inline"&gt;\(\Delta s_t\)&lt;/span&gt;, at time &lt;span class="math inline"&gt;\(t\)&lt;/span&gt;. Our objective is to provide a mathematically sufficient condition so that the change in state at time step &lt;span class="math inline"&gt;\(t + k\)&lt;/span&gt; caused by a change in state at time step &lt;span class="math inline"&gt;\(t\)&lt;/span&gt; vanishes as &lt;span class="math inline"&gt;\(n \to \infty\)&lt;/span&gt;; i.e., we will prove a sufficient condition for:&lt;/p&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[\lim_{k \to \infty}\frac{\Delta s_{t+k}}{\Delta s_t} = 0.\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;By constrast, Pascanu et al. (2013) proved the same sufficient condition for the following result, which can easily be extended to obtain the above:&lt;/p&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[\lim_{k \to \infty}\frac{\partial s_{t+k}}{\partial s_t} = 0.\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;To begin, from our definition of a vanilla RNN cell, we have:&lt;/p&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[s_{t+1} = \phi(z_t)
\hspace{30px} \text{where} \hspace{30px}
z_t = Ws_{t} + Ux_{t+1} + b.\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Applying the mean value theorem in several variables, we get that there exists &lt;span class="math inline"&gt;\(c \in [z_t,\ z_t + \Delta z_t]\)&lt;/span&gt; such that:&lt;/p&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[\begin{split}
\Delta s_{t+1} &amp;amp; = [\phi&amp;#39;(c)] \Delta z_t\\
 &amp;amp; = [\phi&amp;#39;(c)]\Delta(W s_t).\\
 &amp;amp; = [\phi&amp;#39;(c)]W\Delta s_t.\\
\end{split}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Now let &lt;span class="math inline"&gt;\(\Vert A \Vert\)&lt;/span&gt; represent the matrix 2-norm, &lt;span class="math inline"&gt;\(\rvert v\rvert\)&lt;/span&gt; the Euclidean vector norm, and define:&lt;/p&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[\gamma = \sup_{c \in [z_t,\ z_t + \Delta z_t]}\Vert [\phi&amp;#39;(c)] \Vert \\\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Note that for the logistic sigmoid, &lt;span class="math inline"&gt;\(\gamma \leq \frac{1}{4}\)&lt;/span&gt;, and for tanh, &lt;span class="math inline"&gt;\(\gamma \leq 1\)&lt;/span&gt;.&lt;a href="#fn8" class="footnoteRef" id="fnref8"&gt;&lt;sup&gt;8&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Taking the vector norm of each side, we obtain, where the first inequality comes from the definition of the 2-norm (applied twice), and second from the definition of supremum:&lt;/p&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[
\begin{equation}
\begin{split}
\rvert\Delta s_{t+1}\rvert &amp;amp; = \rvert[\phi&amp;#39;(c)]W\Delta s_t\rvert\\
&amp;amp; \leq \Vert [\phi&amp;#39;(c)] \Vert \Vert W \Vert \rvert\Delta s_{t}\rvert\\
&amp;amp; \leq \gamma \Vert W \Vert \rvert\Delta s_{t}\rvert\\
&amp;amp; = \Vert \gamma W \Vert \rvert\Delta s_{t}\rvert.
\end{split}
\end{equation}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;By expanding this formula over &lt;span class="math inline"&gt;\(k\)&lt;/span&gt; time steps we get &lt;span class="math inline"&gt;\(\rvert\Delta s_{t+k}\rvert \leq \Vert \gamma W \Vert^k \rvert\Delta s_{t}\rvert\)&lt;/span&gt; so that:&lt;/p&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[
\frac{\rvert\Delta s_{t+k}\rvert}{\rvert\Delta s_t\rvert} \leq \Vert \gamma W \Vert^k.
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Therefore, if &lt;span class="math inline"&gt;\(\Vert \gamma W \Vert &amp;lt; 1\)&lt;/span&gt;, we have that &lt;span class="math inline"&gt;\(\frac{\rvert\Delta s_{t+k}\rvert}{\rvert\Delta s_t\rvert}\)&lt;/span&gt; decreases exponentially in time, and have proven a sufficient condition for:&lt;/p&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[\lim_{k \to \infty}\frac{\Delta s_{t+k}}{\Delta s_t} = 0.\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;When will &lt;span class="math inline"&gt;\(\Vert \gamma W \Vert &amp;lt; 1\)&lt;/span&gt;? &lt;span class="math inline"&gt;\(\gamma\)&lt;/span&gt; is bounded to &lt;span class="math inline"&gt;\(\frac{1}{4}\)&lt;/span&gt; for the logistic sigmoid and to 1 for tanh, which tells us that the sufficient condition for vanishing gradients is for &lt;span class="math inline"&gt;\(\Vert W \Vert\)&lt;/span&gt; to be less than 4 or 1, respectively.&lt;/p&gt;
&lt;p&gt;An immediate lesson from this is that if our weight initializations for &lt;span class="math inline"&gt;\(W\)&lt;/span&gt; are too small, our RNN may be unable to learn anything right off the bat, due to vanishing gradients. Let’s now extend this analysis to determine a desirable weight initialization.&lt;/p&gt;
&lt;h3 id="a-minimum-weight-initialization-for-avoid-vanishing-gradients"&gt;A minimum weight initialization for avoid vanishing gradients&lt;/h3&gt;
&lt;p&gt;It is beneficial to find a weight initialization that will not immediately suffer from this problem. Extending the above analysis to find the initialization of &lt;span class="math inline"&gt;\(W\)&lt;/span&gt; that gets us as close to equality as possible leads to a nice result.&lt;/p&gt;
&lt;p&gt;First, let us assume that &lt;span class="math inline"&gt;\(\phi = \tanh\)&lt;/span&gt; and take &lt;span class="math inline"&gt;\(\gamma = 1\)&lt;/span&gt;,&lt;a href="#fn9" class="footnoteRef" id="fnref9"&gt;&lt;sup&gt;9&lt;/sup&gt;&lt;/a&gt; but you could just as easily assume that &lt;span class="math inline"&gt;\(\phi = \sigma\)&lt;/span&gt; and take &lt;span class="math inline"&gt;\(\gamma = \frac{1}{4}\)&lt;/span&gt; to reach a different result.&lt;/p&gt;
&lt;p&gt;Our goal is to find an initialization of W for which:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;span class="math inline"&gt;\(\Vert \gamma W \Vert = 1\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;We get as close to equality as possible in equation (1).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;From point 1, since we took &lt;span class="math inline"&gt;\(\gamma\)&lt;/span&gt; to be 1, we have &lt;span class="math inline"&gt;\(\Vert W \Vert = 1\)&lt;/span&gt;. From point 2, we get that we should try to set all singular values of &lt;span class="math inline"&gt;\(W\)&lt;/span&gt; to 1, not just the largest. Then, if all singular values of &lt;span class="math inline"&gt;\(W\)&lt;/span&gt; equal 1, that means that the norm of each column of &lt;span class="math inline"&gt;\(W\)&lt;/span&gt; is 1 (since each column is &lt;span class="math inline"&gt;\(We_i\)&lt;/span&gt; for some elementary basis vector &lt;span class="math inline"&gt;\(e_i\)&lt;/span&gt; and we have &lt;span class="math inline"&gt;\(\rvert We_i\rvert = \rvert e_i\rvert = 1\)&lt;/span&gt;). That means that for column &lt;span class="math inline"&gt;\(j\)&lt;/span&gt; we have:&lt;/p&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[\Sigma_{i}w_{ij}^2 = 1\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;There are &lt;span class="math inline"&gt;\(n\)&lt;/span&gt; entries in column &lt;span class="math inline"&gt;\(j\)&lt;/span&gt;, and we are choosing each from the same random distribution, so let us find a distribution for a random weight &lt;span class="math inline"&gt;\(w\)&lt;/span&gt; for which:&lt;/p&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[n\mathbb{E}(w^2) = 1\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Now let’s suppose we want to initialize &lt;span class="math inline"&gt;\(w\)&lt;/span&gt; uniformly in the interval &lt;span class="math inline"&gt;\([-R,\ R]\)&lt;/span&gt;. Then the mean of &lt;span class="math inline"&gt;\(w\)&lt;/span&gt; is 0, so that, by definition, &lt;span class="math inline"&gt;\(\mathbb{E}(w^2)\)&lt;/span&gt; is its variance, &lt;span class="math inline"&gt;\(\mathbb{V}(w)\)&lt;/span&gt;. The variance of a uniform distribution over the interval &lt;span class="math inline"&gt;\([a,\ b]\)&lt;/span&gt; is given by &lt;span class="math inline"&gt;\(\frac{(b-a)^2}{12}\)&lt;/span&gt;, from which we get &lt;span class="math inline"&gt;\(\mathbb{V}(w) = \frac{R^2}{3}\)&lt;/span&gt;. Substituting this into our equation we get:&lt;/p&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[n\frac{R^2}{3} = 1\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;So that:&lt;/p&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[R = \frac{\sqrt{3}}{\sqrt{n}}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;This suggests that we initialize our weights from the uniform distribution over the interval: &lt;span class="math display"&gt;\[\bigg[ -\frac{\sqrt{3}}{\sqrt{n}},\ \frac{\sqrt{3}}{\sqrt{n}}\bigg].\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;This is a nice result because it is the Xavier-Glorot initialization for a square weight matrix, yet was motivated by a different idea. The Xavier-Glorot initialization, introduced by &lt;a href="http://jmlr.org/proceedings/papers/v9/glorot10a/glorot10a.pdf"&gt;Glorot and Bengio (2010)&lt;/a&gt;, has proven to be an effective weight initialization prescription in practice. More generally, the Xavier-Glorot prescription applies to &lt;span class="math inline"&gt;\(m\)&lt;/span&gt;-by-&lt;span class="math inline"&gt;\(n\)&lt;/span&gt; weight matrices used in a layer that has an activation function whose derivative is near one at the origin (like &lt;span class="math inline"&gt;\(\tanh\)&lt;/span&gt;), and says that we should initialize our weights according to a uniform distribution of the interval: &lt;span class="math display"&gt;\[\bigg[-\frac{\sqrt{6}}{\sqrt{m + n}},\ \frac{\sqrt{6}}{\sqrt{m + n}}\bigg].\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;You can easily modify the above analysis to obtain initialization prescriptions when using the logistic sigmoid (use &lt;span class="math inline"&gt;\(\gamma = \frac{1}{4}\)&lt;/span&gt;) and when initializing the weights according to a different random distribution (e.g., a Gaussian distribution).&lt;/p&gt;
&lt;h3 id="backpropagation-through-time-and-vanishing-sensitivity"&gt;Backpropagation through time and vanishing sensitivity&lt;/h3&gt;
&lt;p&gt;Training an RNN with backpropagation is very similar to training a feedforward network with backpropagation. Since it is assumed you are already familiar with backpropagation generally, there are only a few comments to make:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;We backpropagate errors through time&lt;/p&gt;
&lt;p&gt;For RNNs we need to backpropagate errors from the current RNN cell back through the state, back through time, to prior RNN cells. This allows the RNN to learn to capture long term time dependencies. Because the model’s parameters are shared across RNN cells (each RNN cell has identical weights and biases), we need to calculate the gradient with respect to each time step separately and then add them up. This is similar to the way we backpropagate errors to shared parameters in other models, such as convolutional networks.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;There is a trade-off between weight update frequency and accurate gradients&lt;/p&gt;
&lt;p&gt;For all gradient-based training algorithms, there is an unavoidable trade-off between (1) frequency of parameter updates (backward passes), and (2) accurate long-term gradients. To see this, consider what happens when we update the gradients at each step, but backpropagate errors more than one step back:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;At time &lt;span class="math inline"&gt;\(t\)&lt;/span&gt; we use our current weights, &lt;span class="math inline"&gt;\(W_t\)&lt;/span&gt;, to calculate the current output and current state, &lt;span class="math inline"&gt;\(o_t\)&lt;/span&gt; and &lt;span class="math inline"&gt;\(s_t\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;Second, we use &lt;span class="math inline"&gt;\(o_t\)&lt;/span&gt; to run a backward pass and update &lt;span class="math inline"&gt;\(W_t\)&lt;/span&gt; to &lt;span class="math inline"&gt;\(W_{t+1}\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;Third, at time &lt;span class="math inline"&gt;\(t+1\)&lt;/span&gt;, we use &lt;span class="math inline"&gt;\(W_{t+1}\)&lt;/span&gt; and &lt;span class="math inline"&gt;\(s_t\)&lt;/span&gt;, as calculated in step 1 using the original &lt;span class="math inline"&gt;\(W_t\)&lt;/span&gt;, to calculate &lt;span class="math inline"&gt;\(o_{t+1}\)&lt;/span&gt; and &lt;span class="math inline"&gt;\(s_{t+1}\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;Finally, we use &lt;span class="math inline"&gt;\(o_{t+1}\)&lt;/span&gt; to run a backward pass. But &lt;span class="math inline"&gt;\(o_{t+1}\)&lt;/span&gt; was computed using &lt;span class="math inline"&gt;\(s_t\)&lt;/span&gt;, which was computed using &lt;span class="math inline"&gt;\(W_t\)&lt;/span&gt; (not &lt;span class="math inline"&gt;\(W_{t+1}\)&lt;/span&gt;), which means the gradients we compute for weights at time step &lt;span class="math inline"&gt;\(t\)&lt;/span&gt; are evaluated at our old weights, &lt;span class="math inline"&gt;\(W_t\)&lt;/span&gt;, and not the current weights, &lt;span class="math inline"&gt;\(W_{t+1}\)&lt;/span&gt;. They are thus only an estimate of the gradient, if it were computed with respect to the current weights. This effect will only compound as we backpropagate errors even further.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We could compute more accurate gradients by doing fewer parameter updates (backward passes), but then we might be giving up training speed (which can be particularly harmful at the start of training). Note the similarity to the trade off to the one faces by choosing a mini-batch size for mini-batch gradient descent: the larger the batch size, the more accurate the estimate of the gradient, but also the fewer gradient updates.&lt;/p&gt;
&lt;p&gt;We could also choose to not propagate errors back more steps than the frequency of our parameter updates, but then we are not calculating the full gradient of the cost with respect to the weights and this is just the flip-side of the coin; the same trade-off occurs.&lt;/p&gt;
&lt;p&gt;This effect is discussed in &lt;a href="https://web.stanford.edu/class/psych209a/ReadingsByDate/02_25/Williams%20Zipser95RecNets.pdf"&gt;Williams and Zipser (1995)&lt;/a&gt;, which provides an excellent overview of the options for calculating gradients for gradient-based training algorithms.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Vanishing gradients plus shared parameters means unbalanced gradient flow and oversensitivity to recent distractions&lt;/p&gt;
&lt;p&gt;Consider a feedforward neural network. Exponentially vanishing gradients mean that changes made to the weights in the earlier layers will be exponentially smaller than those made to the weights in later layers. This is bad, even if we train the network for exponentially longer, so that the early layers eventually learn. To see this, consider that during training the early layers and later layers learn how to communicate with each other. The early layers initially send crude signals, so the later layers quickly become very good at interpretting these crude signals. But then the early laters are encouraged to learn how to produce better crude symbols rather than producing more sophisticated ones.&lt;/p&gt;
&lt;p&gt;RNNs have it worse, because unlike for feedforward nets, the weights in early layers and later layers are shared. This means that instead of simply miscommunicating, they can directly conflict: the gradient to a particular weight might be positive in the early layers but negative in the later layers, resulting in a negative overall gradient, so that the early layers are unlearning faster than they can learn. In the words of Hochreiter and Schmidhuber (1997): “Backpropagation through time is too sensitive to recent distractions.”&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Therefore it makes sense to truncate backpropagation&lt;/p&gt;
&lt;p&gt;Limiting the number of steps that we backpropagate errors in training is called truncating the backpropagation. Notice immediately that if the input/output sequence we are fitting is infinitely long we must truncate the backpropagation, else our algorithm would halt on the backward pass. If the sequence is finite but very long, we may still need to truncate the backpropagation due to computation infeasability.&lt;/p&gt;
&lt;p&gt;However, &lt;em&gt;even if&lt;/em&gt; we had a supercomputer that could instantly backpropagate an error an infinite number of timesteps, point 2 above tells us that we need to truncate our backpropagation due to our gradients becoming inaccurate as a result of weight updates.&lt;/p&gt;
&lt;p&gt;Finally, vanishing gradients create yet another reason for us truncate our backpropagation. If our gradients vanish, then gradients that are backpropagated many steps will be very small and have a negligible effect on training.&lt;/p&gt;
&lt;p&gt;Note that we choose not only how often to truncate backpropagation, but also how often to update our model parameters. See my post on &lt;a href="https://r2rt.com/styles-of-truncated-backpropagation.html"&gt;Styles of Truncated Backpropagation&lt;/a&gt; for an empirical comparison of two possible methods of truncation, or refer to the discussion in &lt;a href="https://web.stanford.edu/class/psych209a/ReadingsByDate/02_25/Williams%20Zipser95RecNets.pdf"&gt;Williams and Zipser (1995)&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;There is also such thing as forward propagation of gradient components&lt;/p&gt;
&lt;p&gt;Something useful to know (in case you come up with the idea yourself), is that backpropagation is not our only choice for training RNNs. Instead of backpropagating errors, we can also propagate gradient components forward, allowing us to compute the error gradient with respect to the weights at each time step. This alternate algorithm is called “real-time recurrent learning (RTRL)”. Full RTRL is too computationally expensive to be practical, running in &lt;span class="math inline"&gt;\(O(n^4)\)&lt;/span&gt; time (as compared to truncated backpropagation, which is &lt;span class="math inline"&gt;\(O(n^2)\)&lt;/span&gt; when parameters are updated with the same frequency as backward passes). Similar to how truncated backpropagation approximates full backpropagation (whose time complexity, &lt;span class="math inline"&gt;\(O(n^2L)\)&lt;/span&gt;, can be much higher than RTRL when the number of time steps, &lt;span class="math inline"&gt;\(L\)&lt;/span&gt;, is large), there exists an approximate version of RTRL called subgrouped RTRL. It promises the same time complexity as truncated backpropagation (&lt;span class="math inline"&gt;\(O(n^2)\)&lt;/span&gt;) when the size of the subgroups is fixed, but is qualitatively different in how it approximates the gradient. Note that RTRL is a gradient-based algorithm and therefore suffers from the vanishing and exploding gradient problem. You can learn more about RTRL in &lt;a href="https://web.stanford.edu/class/psych209a/ReadingsByDate/02_25/Williams%20Zipser95RecNets.pdf"&gt;Williams and Zipser (1995)&lt;/a&gt;. RTRL is just something I wanted to bring to your attention, and beyond our scope; in this post, I assume the use of truncated backpropagation to calculate our gradients.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="dealing-with-vanishing-and-exploding-gradients"&gt;Dealing with vanishing and exploding gradients&lt;/h3&gt;
&lt;p&gt;If our gradient explodes backpropagation will not work because we will get &lt;code&gt;NaN&lt;/code&gt; values for the gradient at early layers. An easy solution for this is to clip the gradient to a maximum value, as proposed by &lt;a href="http://www.fit.vutbr.cz/~imikolov/rnnlm/thesis.pdf"&gt;Mikolov (2012)&lt;/a&gt; and reasserted in &lt;a href="http://www.jmlr.org/proceedings/papers/v28/pascanu13.pdf"&gt;Pascanu et al. (2013)&lt;/a&gt;. This works in practice to prevent &lt;code&gt;NaN&lt;/code&gt; values and allows training to continue.&lt;/p&gt;
&lt;p&gt;Vanishing gradients are tricker to deal with in vanilla RNNs. We saw above that good weight initializations are crucial, but this only impacts the start of training – what about the middle of training? The approach suggested in &lt;a href="http://www.jmlr.org/proceedings/papers/v28/pascanu13.pdf"&gt;Pascanu et al. (2013)&lt;/a&gt; is to introduce a regularization term that enforces constant backwards error flow. This is an easy solution that seems to work for the few experiments on which it was tested in Pascanu et al. (2013). Unfortunately, it is difficult to find a justification for why this should work &lt;em&gt;all the time&lt;/em&gt;, because we are imposing an opinion about the way gradients should flow on the model. This opinion may be correct for some tasks, in which case our imposition will help achieve better results. However, it may be that for some tasks we want gradients to vanish completely, and for others, it may be that we want them to grow. In these cases, the regularizer would detract from the model’s performance, and there doesn’t seem to be any justification for saying that one situation is more common than the other. LSTMs avoid this issue altogether.&lt;/p&gt;
&lt;h3 id="written-memories-the-intuition-behind-lstms"&gt;Written memories: the intuition behind LSTMs&lt;/h3&gt;
&lt;p&gt;Very much like the messages passed by children playing a game of &lt;a href="https://en.wikipedia.org/wiki/Chinese_whispers"&gt;broken telephone&lt;/a&gt;, information is morphed by RNN cells and the original message is lost. A small change in the original message may not have made any difference in the final message, or it may have resulted in something completely different.&lt;/p&gt;
&lt;p&gt;How can we protect the integrity of messages? This is the fundamental principle of LSTMs: to ensure the integrity of our messages in the real world, we write them down. Writing is a &lt;em&gt;delta to the current state&lt;/em&gt;: it is an act of creation (pen on paper) or destruction (carving in stone); the subject itself does not morph when you write on it and the error gradient on the backward-pass is constant.&lt;/p&gt;
&lt;p&gt;This is precisely what was proposed by the landmark paper of &lt;a href="http://isle.illinois.edu/sst/meetings/2015/hochreiter-lstm.pdf"&gt;Hocreiter and Schmidhuber (1997)&lt;/a&gt;, which introduced the LSTM. They asked: “how can we achieve constant error flow through a single unit with a single connection to itself [i.e., a single piece of isolated information]?”&lt;/p&gt;
&lt;p&gt;The answer, quite simply, is to avoid information morphing: changes to the state of an LSTM are explicitly written in, by an explicit addition or subtraction, so that each element of the state stays constant without outside interference: “the unit’s activation has to remain constant … this will be ensured by using the identity function”.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;The fundamental principle of LSTMs: Write it down.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;To ensure the integrity of our messages in the real world, we write them down. Writing is an incremental change that can be additive (pen on paper) or subtractive (carving in rock), and which remains unchanged absent outside interference. In LSTMs, everything is written down and, assuming no interference from other state units or external inputs, carries its prior state forward.&lt;/p&gt;
&lt;p&gt;Practically speaking, this means that any state changes are incremental, so that &lt;span class="math inline"&gt;\(s_{t+1} = s_t + \Delta s_{t+1}\)&lt;/span&gt;.&lt;a href="#fn10" class="footnoteRef" id="fnref10"&gt;&lt;sup&gt;10&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Now Hochreiter and Schmidhuber observed that just “writing it down” had been tried before, but hadn’t worked so well. To see why, consider what happens when we keep writing in changes:&lt;/p&gt;
&lt;p&gt;Some of our writes are positive, and some are negative, so it’s not true that our canvas necessarily blows up: our writes could theoretically cancel each other out. However, it turns out that it’s quite hard to learn how to coordinate this. In particular, at the start of training, we start with random initializations and our network is making some fairly random writes. From the very start of training, we end up with something that looks like this:&lt;/p&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/NH_Pollock_5.jpg" alt="Pollock No. 5" /&gt;&lt;figcaption&gt;Pollock No. 5&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;Even if we eventually learn to coordinate our writes properly, it’s very difficult to record anything useful on top of that chaos (albeit, in this example, very pretty and somewhat regular chaos that was &lt;a href="https://en.wikipedia.org/wiki/No._5,_1948"&gt;worth $140 million&lt;/a&gt; about 10 years ago). This is the fundamental challenge of LSTMs: Uncontrolled and uncoordinated writing causes chaos and overflow from which it can be very hard to recover.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;The fundamental challenge of LSTMs: Uncontrolled and uncoordinated writing.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Uncontrolled and uncoordinated writes, particularly at the start of training when writes are completely random, create a chaotic state that leads to bad results and from which it can be difficult to recover.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Hochreiter and Schmidhuber recognized this problem, splitting it into several subproblems, which they termed “input weight conflict”, “output weight conflict”, the “abuse problem”, and “internal state drift”. The LSTM architecture was carefully designed in order to overcome these problems, starting with the idea of selectivity.&lt;/p&gt;
&lt;h3 id="using-selectivity-to-control-and-coordinate-writing"&gt;Using selectivity to control and coordinate writing&lt;/h3&gt;
&lt;p&gt;According to the early literature on LSTMs, the key to overcoming the fundamental challenge of LSTMs and keeping our state under control is to be selective in &lt;strong&gt;three things&lt;/strong&gt;: what we write, what we read (because we need to read something to know what to write), and what we forget (because obselete information is a distraction and should be forgotten).&lt;/p&gt;
&lt;p&gt;Part of the reason our state can become so chaotic is that the base RNN writes to every element of the state. This is a problem I suffer from a lot. I have a paper in front of my computer and I write down a lot of things on the same paper. When it fills I take out the paper under it and start writing on that one. The cycle repeats and I end up with a bunch of papers on my desk that contain an overwhelming amount of gibberish.&lt;/p&gt;
&lt;p&gt;Hochreiter and Schmidhuber describe this as “input weight conflict”: if each unit is being written to by all units at each time step, it will collect a lot of useless information, rendering its original state unusable. Thus, the RNN must learn how to use some of its units to cancel out other incoming writes and “protect” the state, which results in difficult learning.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;First form of selectivity: Write selectively.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;To get the most out of our writings in the real world, we need to be selective about what we write; when taking class notes, we only record the most important points and we certainly don’t write our new notes on top of our old notes. In order for our RNN cells to do this, they need a mechanism for selective writing.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The second reason our state can become chaotic is the flip side of the first: for each write it makes, the base RNN reads from every element of the state. As a mild example: if I’m writing a blog post on the intuition behind LSTMs while on vacation in a national park with a wild bear on the loose, I might include the things I’ve been reading about bear safety in my blog post. This is just one thing, and only mildly chaotic, but imagine what this post would look like if I included all the things…&lt;/p&gt;
&lt;p&gt;Hochreiter and Schmidhuber describe this as “output weight conflict”: if irrelevant units are read by all other units at each time step, they produce a potentially huge influx of irrelevant information. Thus, the RNN must learn how to use some of its units to cancel out the irrelevant information, which results in difficult learning.&lt;/p&gt;
&lt;p&gt;Note the difference between reads and writes: If we choose not to read from a unit, it cannot affect any element of our state and our read decision impacts the entire state. If we choose not to write to a unit, that impacts only that single element of our state. This does not mean the impact of selective reads is more significant than the impact of selective writes: reads are summed together and squashed by a non-linearity, whereas writes are absolute, so that the impact of a read decision is broad but shallow, and the impact of a write decision is narrow but deep.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Second form of selectivity: Read selectively.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;In order to perform well in the real-world, we need to apply the most relevant knowledge by being selective in what we read or consume. In order for our RNN cells to do this, they need a mechanism for selective reading.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The third form of selectivity relates to how we dispose of information that is no longer needed. My old paper notes get thrown out. Otherwise I end up with an overwhelming number of papers, even if I were to be selective in writing them. Unused files in my Dropbox get overwritten, else I would run out of space, even if I were to be selective in creating them.&lt;/p&gt;
&lt;p&gt;This intuition was not introduced in the original LSTM paper, which led the original LSTM model to have trouble with simple tasks involving long sequences. Rather, it was introduced by &lt;a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.55.5709&amp;amp;rep=rep1&amp;amp;type=pdf"&gt;Gers et al. (2000)&lt;/a&gt;. According to Gers et al., in some cases the state of the original LSTM model would grow indefinitely, eventually causing the network to break down. In other words, the original LSTM suffered from information overload.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Third form of selectivity: Forget selectively.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;In the real-world, we can only keep so many things in mind at once; in order to make room for new information, we need to selectively forget the least relevant old information. In order for our RNN cells to do this, they need a mechanism for selective forgetting.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;With that, there are just two more steps to deriving the LSTM:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;we need to determine a mechanism for selectivity, and&lt;/li&gt;
&lt;li&gt;we need to glue the pieces together.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="gates-as-a-mechanism-for-selectivity"&gt;Gates as a mechanism for selectivity&lt;/h3&gt;
&lt;p&gt;Selective reading, writing and forgetting involves separate read, write and forget decisions for each element of the state. We will make these decisions by taking advantage of state-sized read, write and forget vectors with values between 0 and 1 specifying the percentage of reading, writing and forgetting that we do for each state element. Note that while it may be more natural to think of reading, writing and forgetting as binary decisions, we need our decisions to be implemented via a differentiable function. The logistic sigmoid is a natural choice since it is differentiable and produces continuous values between 0 and 1.&lt;/p&gt;
&lt;p&gt;We call these read, write and forget vectors “gates”, and we can compute them using the simplest function we have, as we did for the vanilla RNN: the single-layer neural network. Our three gates at time step &lt;span class="math inline"&gt;\(t\)&lt;/span&gt; are denoted &lt;span class="math inline"&gt;\(i_t\)&lt;/span&gt;, the input gate (for writing), &lt;span class="math inline"&gt;\(o_t\)&lt;/span&gt;, the output gate (for reading) and &lt;span class="math inline"&gt;\(f_t\)&lt;/span&gt;, the forget gate (for remembering). From the names, we immediately notice that two things are backwards for LSTMs:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Admittedly this is a bit of a chicken and egg, but I would usually think of first reading then writing. Indeed, this ordering is strongly suggested by the RNN cell specification–we need to read the prior state before we can write to a new one, so that even if we are starting with a blank initial state, we are reading from it. The names input gate and output gate suggest the opposite temporal relationship, which the LSTM adopts. We’ll see that this complicates the architecture.&lt;/li&gt;
&lt;li&gt;The forget gate is used for forgetting, but it actually operates as a remember gate. E.g., a 1 in a forget gate vector means remember everything, not forget everything. This makes no practical difference, but might be confusing.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Here are the mathematical definitions of the gates (notice the similarities):&lt;/p&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[
\begin{equation}
\begin{split}
i_t &amp;amp;= \sigma(W_is_{t-1} + U_ix_t + b_i) \\
o_t &amp;amp;= \sigma(W_os_{t-1} + U_ox_t + b_o) \\
f_t &amp;amp;= \sigma(W_fs_{t-1} + U_fx_t + b_f) \\
\end{split}
\end{equation}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;We could use more complicated functions for the gates as well. A simple yet effective recent example is the use of “multiplicative integration”. See &lt;a href="https://arxiv.org/abs/1606.06630"&gt;Wu et al. (2016)&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Let’s now take a closer look at how our gates interact.&lt;/p&gt;
&lt;h3 id="gluing-gates-together-to-derive-a-prototype-lstm"&gt;Gluing gates together to derive a prototype LSTM&lt;/h3&gt;
&lt;p&gt;If there were no write gate, read selectivity says that we should use the read gate when reading the prior state in order to produce the next write to the state (as discussed above, the read naturally comes before the write when we are zoomed in on a single RNN cell). The fundamental principle of LSTMs says that our write will be incremental to the prior state; therefore, we are calculating &lt;span class="math inline"&gt;\(\Delta s_t\)&lt;/span&gt;, not &lt;span class="math inline"&gt;\(s_t\)&lt;/span&gt;. Let’s call this would-be &lt;span class="math inline"&gt;\(\Delta s_t\)&lt;/span&gt; our &lt;em&gt;candidate write&lt;/em&gt;, and denote it &lt;span class="math inline"&gt;\(\tilde{s}_t\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;We calculate &lt;span class="math inline"&gt;\(\tilde{s}_t\)&lt;/span&gt; the same way we would calculate the state in a vanilla RNN, except that instead of using the prior state, &lt;span class="math inline"&gt;\(s_{t-1}\)&lt;/span&gt;, we first multiply the prior state element-wise by the read gate to get the &lt;em&gt;gated prior state&lt;/em&gt;, &lt;span class="math inline"&gt;\(o_t \odot s_{t-1}\)&lt;/span&gt;:&lt;/p&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[\tilde{s_t} = \phi(W(o_t \odot s_{t-1}) + Ux_t + b)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Note that &lt;span class="math inline"&gt;\(\odot\)&lt;/span&gt; denotes element-wise multiplication, and &lt;span class="math inline"&gt;\(o_t\)&lt;/span&gt; is our read gate (output gate).&lt;/p&gt;
&lt;p&gt;&lt;span class="math inline"&gt;\(\tilde{s}_t\)&lt;/span&gt; is only a candidate write because we are applying selective writing and have a write gate. Thus, we multiply &lt;span class="math inline"&gt;\(\tilde{s}_t\)&lt;/span&gt; element-wise by our write gate, &lt;span class="math inline"&gt;\(i_t\)&lt;/span&gt;, to obtain our true write, &lt;span class="math inline"&gt;\(i_t \odot \tilde{s}_t\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;The final step is to add this to our prior state, but forget selectivity says that we need to have a mechanism for forgetting. So before we add anything to our prior state, we multiply it (element-wise) by the forget gate (which actually operates as a remember gate). Our final prototype LSTM equation is:&lt;/p&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[s_t = f_t \odot s_{t-1} + i_t \odot \tilde{s}_t\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;If we gather all of our equations together, we get the full spec for our prototype LSTM cell (note that &lt;span class="math inline"&gt;\(s_t\)&lt;/span&gt; is also the cell’s external output at each time step):&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The Prototype LSTM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[
\begin{equation}
\begin{split}
i_t &amp;amp;= \sigma(W_is_{t-1} + U_ix_t + b_i) \\
o_t &amp;amp;= \sigma(W_os_{t-1} + U_ox_t + b_o) \\
f_t &amp;amp;= \sigma(W_fs_{t-1} + U_fx_t + b_f) \\
\\
\tilde{s_t}&amp;amp; = \phi(W(o_t \odot s_{t-1}) + Ux_t + b)\\
s_t &amp;amp;= f_t \odot s_{t-1} + i_t \odot \tilde{s}_t
\end{split}
\end{equation}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;At the risk of distracting you from the equations (which are far more descriptive), here is what the data flow looks like:&lt;/p&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/NH_PrototypeLSTMCell.png" alt="Prototype LSTM Cell" /&gt;&lt;figcaption&gt;Prototype LSTM Cell&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;In theory, this prototype &lt;em&gt;should&lt;/em&gt; work, and it would be quite beautiful if it did. In practice, the selectivity measures taken are not (usually) enough to overcome the fundamental challenge of LSTMs: the selective forgets and the selective writes are not coordinated at the start of training which can cause the state to quickly become large and chaotic. Further, since the state is potentially unbounded, the gates and the candidate write will often become saturated, which causes problems for training.&lt;/p&gt;
&lt;p&gt;This was observed by Hochreiter and Schmidhuber (1997), who termed the problem “internal state drift”, because “if the [writes] are mostly positive or mostly negative, then the internal state will tend to drift away over time”. It turns out that this problem is so severe that the prototype we created above tends to fail in practice, even with very small initial learning rates and carefully chosen bias initializations. The clearest empirical demonstration of this can be found in &lt;a href="https://arxiv.org/abs/1503.04069"&gt;Greff et al. (2015)&lt;/a&gt;, which contains an empirical comparison of 8 LSTM variants. The worst performing variant, often failing to converge, is substantially similar to the prototype above.&lt;/p&gt;
&lt;p&gt;By enforcing a bound on the state to prevent it from blowing up, we can overcome this problem. There are a few ways to do this, which lead to different models of the LSTM.&lt;/p&gt;
&lt;h3 id="three-working-models-the-normalized-prototype-the-gru-and-the-pseudo-lstm"&gt;Three working models: the normalized prototype, the GRU and the pseudo LSTM&lt;/h3&gt;
&lt;p&gt;The selectivity measures taken in our prototype LSTM were not powerful enough to overcome the fundamental challenge of LSTMs. In particular, the state, which is used to compute both the gates and the candidate write can grow unbounded.&lt;/p&gt;
&lt;p&gt;I’ll cover three options, each of which bounds the state in order to give us a working LSTM:&lt;/p&gt;
&lt;h4 id="the-normalized-prototype-a-soft-bound-via-normalization"&gt;The normalized prototype: a soft bound via normalization&lt;/h4&gt;
&lt;p&gt;We can impose a soft bound by normalizing the state. One method that has worked for me in preliminary tests is simply dividing &lt;span class="math inline"&gt;\(s_t\)&lt;/span&gt; by &lt;span class="math inline"&gt;\(\sqrt{\text{Var}(s_t) + 1}\)&lt;/span&gt;, where we add 1 to prevent the initially zero state from blowing up. We might also subtract the mean state before dividing out the variance, but this did not seem to help in preliminary tests. We might then consider adding in scale and shift factors for expressiveness, a la layer normalization&lt;a href="#fn11" class="footnoteRef" id="fnref11"&gt;&lt;sup&gt;11&lt;/sup&gt;&lt;/a&gt;, but then the model ventures into layer normalized LSTM territory (and we may want to compare it to other layer normalized LSTM models).&lt;/p&gt;
&lt;p&gt;In any case, this provides a method for creating a soft bound on the state, and has performed slightly better for me in preliminary tests than regular LSTMs (including the pseudo LSTM derived below).&lt;/p&gt;
&lt;h4 id="the-gru-a-hard-bound-via-write-forget-coupling-or-overwriting"&gt;The GRU: a hard bound via write-forget coupling, or overwriting&lt;/h4&gt;
&lt;p&gt;One way to impose a hard bound on the state and coordinate our writes and forgets is to explicitly link them; in other words, instead of doing selective writes and selective forgets, we forego some expressiveness and do selective overwrites by setting our forget gate equal to 1 minus our write gate, so that:&lt;/p&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[s_t = (1-i_t) \odot s_{t-1} + i_t \odot \tilde{s}_t\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;This works because it turns &lt;span class="math inline"&gt;\(s_t\)&lt;/span&gt; into an element-wise weighted average of &lt;span class="math inline"&gt;\(s_{t-1}\)&lt;/span&gt; and &lt;span class="math inline"&gt;\(\tilde{s}_t\)&lt;/span&gt;, which is bounded if both &lt;span class="math inline"&gt;\(s_{t-1}\)&lt;/span&gt; and &lt;span class="math inline"&gt;\(\tilde{s}_t\)&lt;/span&gt; are bounded. This is the case if we use &lt;span class="math inline"&gt;\(\phi = \tanh\)&lt;/span&gt; (whose output is bound to (-1, 1)).&lt;/p&gt;
&lt;p&gt;We’ve now derived the gated recurrent unit (GRU). To conform for the GRU terminology used in the literature, we call the overwrite gate an update gate and label it &lt;span class="math inline"&gt;\(z_t\)&lt;/span&gt;. Note that although called an “update” gate, it operates as “do-not-update” gate by specifying the percentage of the prior state that we don’t want to overwrite. Thus, the update gate, &lt;span class="math inline"&gt;\(z_t\)&lt;/span&gt;, is the same as the forget gate from our prototype LSTM, &lt;span class="math inline"&gt;\(f_t\)&lt;/span&gt;, and the write gate is calculated by &lt;span class="math inline"&gt;\(1 - z_t\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Note that, for whatever reason, the authors who introduced the GRU called their read gate a reset gate (at least we get to use &lt;span class="math inline"&gt;\(r_t\)&lt;/span&gt; for it!).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The GRU&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[
\begin{equation}
\begin{split}
r_t &amp;amp;= \sigma(W_rs_{t-1} + U_rx_t + b_r) \\
z_t &amp;amp;= \sigma(W_zs_{t-1} + U_zx_t + b_z) \\
\\
\tilde{s_t}&amp;amp; = \phi(W(r_t \odot s_{t-1}) + Ux_t + b)\\
s_t &amp;amp;= z_t \odot s_{t-1} + (1 - z_t) \odot \tilde{s}_t
\end{split}
\end{equation}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;At the risk of distracting you from the equations (which are far more descriptive), here is what the data flow looks like:&lt;/p&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/NH_GRUCell.png" alt="GRU Cell" /&gt;&lt;figcaption&gt;GRU Cell&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;This is the GRU cell first introduced by &lt;a href="http://emnlp2014.org/papers/pdf/EMNLP2014179.pdf"&gt;Cho et al. (2014)&lt;/a&gt;. I hope you agree that the derivation of the GRU in this post was motivated at every step. There hasn’t been a single arbitrary “hiccup” in our logic, as there will be in order for us to arrive at the LSTM. Contrary to what some authors have written (e.g., “The GRU is an alternative to the LSTM which is similarly difficult to justify” - &lt;a href="http://jmlr.org/proceedings/papers/v37/jozefowicz15.pdf"&gt;Jozefowicz et al. (2015)&lt;/a&gt;), we see that the GRU is a very natural architecture.&lt;/p&gt;
&lt;h4 id="the-pseudo-lstm-a-hard-bound-via-non-linear-squashing"&gt;The Pseudo LSTM: a hard bound via non-linear squashing&lt;/h4&gt;
&lt;p&gt;We now take the second-to-last step on our journey to full LSTMs, by using a third method to bind our state: we pass the state through a squashing function (e.g., the logistic sigmoid or tanh). The hiccup here is that we cannot apply the squashing function to the state itself (for this would result in information morphing and violate our fundamental principle of LSTMs). Instead, we pass the state through the squashing function every time we need to use it for anything except making incremental writes to it. By doing this, our gates and candidate write don’t become saturated and we maintain good gradient flow.&lt;/p&gt;
&lt;p&gt;To this point, our external output has been the same as our state, but here, the only time we don’t squash the state is when we make incremental writes to it. Thus, our cell’s output and state are different.&lt;/p&gt;
&lt;p&gt;This is an easy enough modification to our prototype. Denoting our new squashing function by &lt;span class="math inline"&gt;\(\phi\)&lt;/span&gt; (it does not have to be the same as the nonlinearity we use to compute the candidate write but tanh is generally used for both in practice):&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The Pseudo LSTM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[
\begin{equation}
\begin{split}
i_t &amp;amp;= \sigma(W_i(\phi(s_{t-1})) + U_ix_t + b_i) \\
o_t &amp;amp;= \sigma(W_o(\phi(s_{t-1})) + U_ox_t + b_o) \\
f_t &amp;amp;= \sigma(W_f(\phi(s_{t-1})) + U_fx_t + b_f) \\
\\
\tilde{s_t}&amp;amp; = \phi(W(o_t \odot \phi(s_{t-1})) + Ux_t + b)\\
s_t &amp;amp;= f_t \odot s_{t-1} + i_t \odot \tilde{s}_t\\
\\
\text{rnn}_{out} &amp;amp; = \phi(s_t)
\end{split}
\end{equation}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;At the risk of distracting you from the equations (which are far more descriptive), here is what the data flow looks like:&lt;/p&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/NH_PseudoLSTMCell.png" alt="Pseudo LSTM Cell" /&gt;&lt;figcaption&gt;Pseudo LSTM Cell&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;The pseudo LSTM is almost an LSTM - it’s just backwards. From this presentation, we see clearly that the only motivated difference between the GRU and the LSTM is the approach they take to bounding the state. We’ll see that this pseudo LSTM has some advantages over the standard LSTM.&lt;/p&gt;
&lt;h3 id="deriving-the-lstm"&gt;Deriving the LSTM&lt;/h3&gt;
&lt;p&gt;There are a number of LSTM variants used in the literature, but the differences between them are not so important for our purposes. They all share one key difference with our pseudo LSTM: the real LSTM places the read operation &lt;em&gt;after&lt;/em&gt; the write operation.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;LSTM Diff 1 (the LSTM hiccup)&lt;/strong&gt;: Read comes &lt;em&gt;after&lt;/em&gt; write. This forces the LSTM to pass a shadow state between time steps.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;If you read Hochreiter and Schmidhuber (1997) you will observe that they were thinking of the state (as we’ve been using state so far) as being separate from the rest of the RNN cell.&lt;a href="#fn12" class="footnoteRef" id="fnref12"&gt;&lt;sup&gt;12&lt;/sup&gt;&lt;/a&gt; Hochreiter and Schmidhuber thought of the state as a “memory cell” that had a “constant error” (because absent reading and writing, it carries the state forward and has a constant gradient during backpropagation). Perhaps this is why, viewing the state as a separate memory cell, they saw the order of operations as inputs (writes) followed by outputs (reads). Indeed, most diagrams of the LSTM, including the ones in Hochreiter and Schmidhuber (1997) and &lt;a href="https://arxiv.org/abs/1308.0850"&gt;Graves (2013)&lt;/a&gt; are confusing because they focus on this “memory cell” rather than on the LSTM cell as a whole.&lt;a href="#fn13" class="footnoteRef" id="fnref13"&gt;&lt;sup&gt;13&lt;/sup&gt;&lt;/a&gt; I don’t include examples here so as to not distract from raw understanding.&lt;/p&gt;
&lt;p&gt;This difference in read-write order has the following important implication: We need to read the state in order to create a candidate write. But if creating the candidate write comes before the read operation inside our RNN cell, we can’t do that unless we pass a pre-gated “shadow state” from one time step to the next along with our normal state. The write-then-read order thus forces the LSTM to pass a shadow state from RNN cell to RNN cell.&lt;/p&gt;
&lt;p&gt;Going forward, to conform to the common letters used in describing the LSTM, we rename the main state, &lt;span class="math inline"&gt;\(s_t\)&lt;/span&gt;, to &lt;span class="math inline"&gt;\(c_t\)&lt;/span&gt; (c is for cell, or constant error). We’ll make the corresponding change to our candidate write, which will now be &lt;span class="math inline"&gt;\(\tilde{c}_t\)&lt;/span&gt;. We will also introduce a separate shadow state, &lt;span class="math inline"&gt;\(h_t\)&lt;/span&gt; (h is for hidden state) that will has the same size as our regular state. &lt;span class="math inline"&gt;\(h_{t-1}\)&lt;/span&gt; is analogous to the &lt;em&gt;gated prior state&lt;/em&gt; from our prototype LSTM, &lt;span class="math inline"&gt;\(o_t \odot s_{t-1}\)&lt;/span&gt;, except that it is squashed by a non-linearity (to impose a bound on the values used to compute the candidate write). Thus the prior state our LSTM receives at time step &lt;span class="math inline"&gt;\(t\)&lt;/span&gt; is a tuple of closely-related vectors: &lt;span class="math inline"&gt;\((c_{t-1},\ h_{t-1})\)&lt;/span&gt;, where &lt;span class="math inline"&gt;\(h_{t-1} = o_{t-1} \odot \phi(c_{t-1})\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;This is truly a hiccup, and not because it makes things more complicated (which it does). It’s a hiccup because we end up using a read gate calculated at time &lt;span class="math inline"&gt;\(t-1\)&lt;/span&gt;, using the shadow state from time &lt;span class="math inline"&gt;\(t-2\)&lt;/span&gt; and the the inputs from time &lt;span class="math inline"&gt;\(t-1\)&lt;/span&gt;, in order to gate the relevant state information for use at time &lt;span class="math inline"&gt;\(t\)&lt;/span&gt;. This is like day trading based on yesterday’s news.&lt;/p&gt;
&lt;p&gt;Our hiccup created an &lt;span class="math inline"&gt;\(h_{t-1}\)&lt;/span&gt;, the presence of which goes on to create two more differences to our pseudo LSTM:&lt;/p&gt;
&lt;p&gt;First, instead of using the (squashed) ungated prior state, &lt;span class="math inline"&gt;\(\phi(c_{t-1})\)&lt;/span&gt;, to compute the gates, the standard LSTM uses &lt;span class="math inline"&gt;\(h_{t-1} = o_{t-1} \odot \phi(c_{t-1})\)&lt;/span&gt;, which has been subjected to a read gate, and an outdated read gate at that.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;LSTM Diff 2&lt;/strong&gt;: Gates are computed using the gated shadow state, &lt;span class="math inline"&gt;\(h_{t-1} = o_{t-1} \odot \phi(c_{t-1})\)&lt;/span&gt;, instead of a squashed main state, &lt;span class="math inline"&gt;\(\phi(c_{t-1})\)&lt;/span&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Second, instead of using the (squashed) ungated state, &lt;span class="math inline"&gt;\(\phi(c_{t})\)&lt;/span&gt; as the LSTM’s external output, the standard LSTM uses &lt;span class="math inline"&gt;\(h_{t} = o_{t} \odot \phi(c_{t})\)&lt;/span&gt;, which has been subjected to a read gate.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;LSTM Diff 3&lt;/strong&gt;: The LSTM’s external output is the gated shadow state, &lt;span class="math inline"&gt;\(h_{t} = o_{t} \odot \phi(c_{t})\)&lt;/span&gt;, instead of a squashed main state, &lt;span class="math inline"&gt;\(\phi(c_{t})\)&lt;/span&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;While we can see how these differences came to be, as a result of the “memory cell” view of the LSTM’s true state, at least the first and third lack a principled motivation (the second can be interpreted as asserting that information that is irrelevant for the candidate write is also irrelevant for gate computations, which makes sense). Thus, while I strongly disagreed above with &lt;a href="http://jmlr.org/proceedings/papers/v37/jozefowicz15.pdf"&gt;Jozefowicz et al. (2015)&lt;/a&gt; about the GRU being “difficult to justify”, I agree with them that there are LSTM components whose “purpose is not immediately apparent”.&lt;/p&gt;
&lt;p&gt;We will now rewrite our pseudo LSTM backwards, taking into account all three differences, to get a real LSTM. It now receives two quantities as the prior state, &lt;span class="math inline"&gt;\(c_{t-1}\)&lt;/span&gt; and &lt;span class="math inline"&gt;\(h_{t-1}\)&lt;/span&gt;, and produces two quantities which it will pass to the next time step, &lt;span class="math inline"&gt;\(c_{t}\)&lt;/span&gt; and &lt;span class="math inline"&gt;\(h_{t}\)&lt;/span&gt;. The LSTM we get is quite “normal”: this is the version of the LSTM you will find implemented as the “BasicLSTMCell” in Tensorflow.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The basic LSTM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[
\begin{equation}
\begin{split}
i_t &amp;amp;= \sigma(W_ih_{t-1} + U_ix_t + b_i) \\
o_t &amp;amp;= \sigma(W_oh_{t-1} + U_ox_t + b_o) \\
f_t &amp;amp;= \sigma(W_fh_{t-1} + U_fx_t + b_f) \\
\\
\tilde{c_t}&amp;amp; = \phi(Wh_{t-1} + Ux_t + b)\\
c_t &amp;amp;= f_t \odot c_{t-1} + i_t \odot \tilde{c}_t\\
\\
h_t &amp;amp;= o_t \odot \phi(c_t)\\
\\
\text{rnn}_{out} &amp;amp; = h_t
\end{split}
\end{equation}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;At the risk of distracting you from the equations (which are far more descriptive), here is what the data flow looks like:&lt;/p&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/NH_BasicLSTMCell.png" alt="Basic LSTM Cell" /&gt;&lt;figcaption&gt;Basic LSTM Cell&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h3 id="the-lstm-with-peepholes"&gt;The LSTM with peepholes&lt;/h3&gt;
&lt;p&gt;The potential downside of LSTM Diff 2 (hiding of potentially relevant information) was recognized by &lt;a href="ftp://ftp.idsia.ch/pub/juergen/TimeCount-IJCNN2000.pdf"&gt;Gers and Schmidhuber (2000)&lt;/a&gt;, who introduced “peephole” connections in response. Peepholes connections include the original unmodified prior state, &lt;span class="math inline"&gt;\(c_{t-1}\)&lt;/span&gt; in the calculation of the gates. In introducing these peepholes, Gers and Schmidhuber (2000) also noticed the outdated input to the read gate (due to LSTM Diff 1), and partially fixed it by moving the calculation of the read gate, &lt;span class="math inline"&gt;\(o_t\)&lt;/span&gt;, to come after the calculation of &lt;span class="math inline"&gt;\(c_t\)&lt;/span&gt;, so that &lt;span class="math inline"&gt;\(o_t\)&lt;/span&gt; uses &lt;span class="math inline"&gt;\(c_t\)&lt;/span&gt; instead of &lt;span class="math inline"&gt;\(c_{t-1}\)&lt;/span&gt; in its peephole connection.&lt;/p&gt;
&lt;p&gt;Making these changes, we get one of the most common variants of the LSTM. This is the architecture used in &lt;a href="http://arxiv.org/pdf/1308.0850v5.pdf"&gt;Graves (2013)&lt;/a&gt;. Note that each &lt;span class="math inline"&gt;\(P_x\)&lt;/span&gt; is an &lt;span class="math inline"&gt;\(n \times n\)&lt;/span&gt; matrix (a peephole matrix), much like each &lt;span class="math inline"&gt;\(W_x\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The LSTM with peepholes&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[
\begin{equation}
\begin{split}
i_t &amp;amp;= \sigma(W_ih_{t-1} + U_ix_t + P_ic_{t-1} + b_i) \\
f_t &amp;amp;= \sigma(W_fh_{t-1} + U_fx_t + P_fc_{t-1} + b_f) \\
\\
\tilde{c_t}&amp;amp; = \phi(Wh_{t-1} + Ux_t + b)\\
c_t &amp;amp;= f_t \odot c_{t-1} + i_t \odot \tilde{c}_t\\
\\
o_t &amp;amp;= \sigma(W_oh_{t-1} + U_ox_t + P_oc_{t} + b_o) \\
\\
h_t &amp;amp;= o_t \odot \phi(c_t)\\
\\
\text{rnn}_{out} &amp;amp; = h_t
\end{split}
\end{equation}\]&lt;/span&gt;&lt;/p&gt;
&lt;h3 id="an-empirical-comparison-of-the-basic-lstm-and-the-pseudo-lstm"&gt;An empirical comparison of the basic LSTM and the pseudo LSTM&lt;/h3&gt;
&lt;p&gt;I now compare the basic LSTM to our pseudo LSTM to see if LSTM Diffs 1, 2 and 3 really are harmful. All combinations of the three differences are tested, for a total of 8 possible architectures:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;Pseudo LSTM: as above.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Pseudo LSTM plus LSTM Diff 1: Shadow state containing read-gated squashed state, &lt;span class="math inline"&gt;\(o_{t-1} \odot \phi(c_{t-1})\)&lt;/span&gt;, is passed to time step &lt;span class="math inline"&gt;\(t\)&lt;/span&gt;, where it used in computation of the candidate write only. Gates and outputs are calculated using the ungated squashed state.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Pseudo LSTM plus LSTM Diffs 1 and 2: Shadow state containing read-gated squashed state, &lt;span class="math inline"&gt;\(o_{t-1} \odot \phi(c_{t-1})\)&lt;/span&gt;, is passed to time step &lt;span class="math inline"&gt;\(t\)&lt;/span&gt;, where it used in computation of the candidate write and each of the three gates.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Pseudo LSTM plus LSTM Diffs 1 and 3: Shadow state containing read-gated squashed state, &lt;span class="math inline"&gt;\(o_{t-1} \odot \phi(c_{t-1})\)&lt;/span&gt;, is passed to time step &lt;span class="math inline"&gt;\(t\)&lt;/span&gt;, where it used in computation of the candidate write only. The shadow state, &lt;span class="math inline"&gt;\(o_t \odot \phi(c_t)\)&lt;/span&gt;, is also used as the cell output at time step &lt;span class="math inline"&gt;\(t\)&lt;/span&gt; (i.e., the cell output is read-gated).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Pseudo LSTM plus LSTM Diff 2: Read-gated squashed prior state, &lt;span class="math inline"&gt;\(o_t \odot \phi(s_{t-1})\)&lt;/span&gt;, is used in place of squashed prior state, &lt;span class="math inline"&gt;\(\phi(s_{t-1})\)&lt;/span&gt;, to compute the write gate and forget gate.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Pseudo LSTM plus LSTM Diffs 2 and 3: Read-gated squashed prior state, &lt;span class="math inline"&gt;\(o_t \odot \phi(s_{t-1})\)&lt;/span&gt;, is used in place of squashed prior state, &lt;span class="math inline"&gt;\(\phi(s_{t-1})\)&lt;/span&gt;, to compute the write gate and forget gate, and also to gate the cell output.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Pseudo LSTM plus LSTM Diff 3: Pseudo LSTM using read-gated squashed state as its external output, &lt;span class="math inline"&gt;\(o_t \odot \phi(s_t)\)&lt;/span&gt;, instead of squashed state, &lt;span class="math inline"&gt;\(\phi(s_t)\)&lt;/span&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Basic LSTM: as above.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In architectures 5-7, the read gate is calculated at time &lt;span class="math inline"&gt;\(t\)&lt;/span&gt; (i.e., they do not incorporate the time delay caused by LSTM Diff 1). All architectures use a forget gate bias of 1, and read/write gate biases of 0.&lt;/p&gt;
&lt;p&gt;Using the PTB dataset, I run 5 trials of up to 20 epochs of each. Training is cut short if the loss does not fall after 2 epochs, and the minimum epoch validation loss is reported. Gradients are calculated with respect to a softmax/cross-entropy loss via backpropagation truncated to 30 steps, and learning is performed in batches of 30 with an AdamOptimizer and learning rates of 3e-3, 1e-3, 3e-4, and 1e-4. The state size used is 250. No dropout, layer normalization or other features are added. Architectures are composed of a single layer of RNN cells (i.e., this is not a comparison of deep architectures). RNN inputs are passed through an embedding layer, and RNN outputs are passed through a softmax.&lt;/p&gt;
&lt;p&gt;The best epoch validation losses, shown as the average of 5 runs with a 95% confidence interval, are as follows (lower is better):&lt;/p&gt;
&lt;div style="font-size: 0.8em; margin: 20px"&gt;
&lt;table style="width:25%;"&gt;
&lt;colgroup&gt;
&lt;col style="width: 2%" /&gt;
&lt;col style="width: 2%" /&gt;
&lt;col style="width: 2%" /&gt;
&lt;col style="width: 2%" /&gt;
&lt;col style="width: 2%" /&gt;
&lt;col style="width: 2%" /&gt;
&lt;col style="width: 2%" /&gt;
&lt;col style="width: 2%" /&gt;
&lt;col style="width: 2%" /&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr class="header"&gt;
&lt;th&gt;LR&lt;/th&gt;
&lt;th&gt;1 (pseudo)&lt;/th&gt;
&lt;th&gt;2 {1}&lt;/th&gt;
&lt;th&gt;3 {1,2}&lt;/th&gt;
&lt;th&gt;4 {1,3}&lt;/th&gt;
&lt;th&gt;5 {2}&lt;/th&gt;
&lt;th&gt;6 {2,3}&lt;/th&gt;
&lt;th&gt;7 {3}&lt;/th&gt;
&lt;th&gt;8 (basic)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;&lt;strong&gt;3e-03&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;433.7 ± 10.6&lt;/td&gt;
&lt;td&gt;430.6 ± 6.1&lt;/td&gt;
&lt;td&gt;390.3 ± 1.2&lt;/td&gt;
&lt;td&gt;424.5 ± 3.5&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;em&gt;389.0 ± 1.4&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;399.1 ± 2.4&lt;/td&gt;
&lt;td&gt;425.7 ± 1.4&lt;/td&gt;
&lt;td&gt;396.2 ± 1.6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td&gt;&lt;strong&gt;1e-03&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;387.2 ± 0.8&lt;/td&gt;
&lt;td&gt;388.6 ± 1.0&lt;/td&gt;
&lt;td&gt;388.7 ± 0.6&lt;/td&gt;
&lt;td&gt;414.3 ± 2.5&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;em&gt;386.0 ± 0.8&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;396.3 ± 1.9&lt;/td&gt;
&lt;td&gt;413.9 ± 2.4&lt;/td&gt;
&lt;td&gt;396.6 ± 0.9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;&lt;strong&gt;3e-04&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;389.2 ± 0.6&lt;/td&gt;
&lt;td&gt;391.1 ± 0.8&lt;/td&gt;
&lt;td&gt;391.3 ± 0.8&lt;/td&gt;
&lt;td&gt;407.9 ± 4.3&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;em&gt;388.8 ± 0.6&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;397.7 ± 1.5&lt;/td&gt;
&lt;td&gt;408.7 ± 1.7&lt;/td&gt;
&lt;td&gt;398.8 ± 2.1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td&gt;&lt;strong&gt;1e-04&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;403.9 ± 1.0&lt;/td&gt;
&lt;td&gt;403.9 ± 0.8&lt;/td&gt;
&lt;td&gt;404.2 ± 1.3&lt;/td&gt;
&lt;td&gt;419.7 ± 0.4&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;em&gt;403.1 ± 1.2&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;416.8 ± 1.4&lt;/td&gt;
&lt;td&gt;419.9 ± 1.4&lt;/td&gt;
&lt;td&gt;418.1 ± 1.2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;We see that LSTM Diff 2 (using a read gated state for write and forget gate computations) is actually slightly beneficial as compared to the pseudo LSTM. In fact, LSTM Diff 2 is neutral or beneficial in all cases where it is added. It turns out (at least for this task), that information is that irrelevant to the candidate write computation is also irrelevant to the gate computations.&lt;/p&gt;
&lt;p&gt;We see that LSTM Diff 1 (using a prior state for the candidate write that was gated using a read gate computed at the prior time step) is not significant, though it tends to be slightly harmful.&lt;/p&gt;
&lt;p&gt;Finally, we see that LSTM Diff 3 (using a read gated state for the cell outputs) significantly harms performance, but that LSTM Diff 2 does a good job of recovering the loss.&lt;/p&gt;
&lt;p&gt;Thus, we conclude that LSTM Diff 2 is a worthwhile solo addition to the pseudo LSTM. The pseudo LSTM + LSTM Diff 2 was the winner for all tested learning rates and outperformed the basic LSTM by a significant margin on the full range of tested learning rates.&lt;/p&gt;
&lt;h3 id="extending-the-lstm"&gt;Extending the LSTM&lt;/h3&gt;
&lt;p&gt;At this point, we’ve completely derived the LSTM, we know why it works, and we know why each component of the LSTM is the way it is. We’ve also used our intuitions to create an LSTM variant that is empirically better than the basic LSTM on tests, and objectively better in the sense that it uses the most recent available information.&lt;/p&gt;
&lt;p&gt;We’ll now (very) briefly take a look at how this knowledge was applied in two recent and exciting innovations: highway and residual networks, and memory-augmented recurrent architectures.&lt;/p&gt;
&lt;h4 id="highway-networks-and-residual-networks"&gt;Highway networks and residual networks&lt;/h4&gt;
&lt;p&gt;Two new architectures, highway networks and residual networks, draw on the intuitions of LSTMs to produce state of the art results on tasks using feedforward networks. Very deep feedforward nets have historically been difficult to train for the very same reasons as recurrent architectures: even in the absence of a recurring function, gradients vanish and information morphs. A residual network, introduced by &lt;a href="https://arxiv.org/abs/1512.03385"&gt;He et al. (2015)&lt;/a&gt;, won the ImageNet 2015 classification task by enabling the training of a very deep feedforward network. Highway networks, introduced by &lt;a href="https://arxiv.org/abs/1505.00387"&gt;Srivastava et al. (2015)&lt;/a&gt; demonstrate a similar ability, and have shown impressive experimental results. Both residual networks and highway networks are an application of the fundamental principle of LSTMs to feedforward neural networks.&lt;/p&gt;
&lt;p&gt;Their derivation begins as a direct application of the fundamental principle of LSTMs:&lt;/p&gt;
&lt;p&gt;Let &lt;span class="math inline"&gt;\(x_l\)&lt;/span&gt; represent the network’s representation of the network inputs, &lt;span class="math inline"&gt;\(x_0\)&lt;/span&gt;, at layer &lt;span class="math inline"&gt;\(l\)&lt;/span&gt;. Then instead of transforming the current representation at each layer, &lt;span class="math inline"&gt;\(x_{n+1} = T(x_n)\)&lt;/span&gt;, we compute the delta to the current state: &lt;span class="math inline"&gt;\(x_{n+1} = x_n + \Delta x_{n+1}\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;However, in doing this, we run into the fundamental challenge of LSTMs: uncontrolled and uncoordinated deltas. Intuitively, the fundamental challenge is not as much of a challenge for feedforward networks. Even if the representation progresses uncontrollably as we move deeper through the network, the layers are no longer linked (there is no parameter sharing between layers), so that deeper layers can adapt to the increasing average level of chaos (and, if we apply batch normalization, the magnitude and variance of the chaos becomes less relevant). In any case, the fundamental challenge is still an issue, and just as the GRU and LSTM diverge in their treatment of this issue, so too do highway networks and residual networks.&lt;/p&gt;
&lt;p&gt;Highway networks overcome the challenge as does the LSTM: they train a write gate and a forget gate at each layer (in the absence of a recurring function, parameters are not shared across layers). In Srivastava et al. (2015), the two gates are merged, as per the GRU, into a single overwrite gate. This does a good enough job of overcoming the fundamental challenge of LSTMs and enables the training of very deep feedforward networks.&lt;/p&gt;
&lt;p&gt;Residual networks take a slightly different approach. In order to control the deltas being written, residual networks use a multi-layer neural network to calculate them. This is a form of selectivity: it enables a much more precise delta calculation and is expressive enough to replace gating mechanisms entirely (observe that both are second order mechanisms that differ in how they are calculated). It’s likely that we can apply this same approach to an LSTM architecture in order to overcome the fundamental challenge of LSTMs in an RNN context (query whether it is more effective than using gates).&lt;/p&gt;
&lt;h4 id="neural-turing-machine"&gt;Neural Turing Machine&lt;/h4&gt;
&lt;p&gt;As a second extension of the LSTM, consider the Neural Turing Machine (NTM), introduced in &lt;a href="https://arxiv.org/abs/1410.5401"&gt;Graves et al. (2014)&lt;/a&gt;, which is a example of a memory-augmented recurrent architecture.&lt;/p&gt;
&lt;p&gt;Recall that the reason the LSTM is backwards from our pseudo LSTM was that the main state was viewed as a memory cell separate from the rest of the RNN cell. The problem was that the rest of the cell’s state was represented by a mere shadow of the LSTM’s memory cell. NTMs take this memory cell view but fix the shadow state problem, by introducing three key architectural changes to the LSTM:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Instead of a memory cell (represented by a state vector), they use a memory bank (represented by a state matrix), which is a “long” memory cell, in that instead of a state unit having a single real value, it has a vector of real values. This forces the memory bank to coordinate reads and writes to write entire memories and to retrieve entire memories at once. In short, it is an opinionated approach that enforces organization within the state.&lt;/li&gt;
&lt;li&gt;The read, write and forget gates, now called read and write “heads” (where the write head represents both write and forget gates), are much more sophisticated and include several opinionated decisions as to their functionality. For example, a sparsity constraint is employed so that there is a limit to the amount of reading and writing done at each time step. To get around the limits of sparsity on each head, Graves et al. allow for multiple read and write heads.&lt;/li&gt;
&lt;li&gt;Instead of a shadow state, which is a mere image of the memory cell, NTMs have a “controller”, which coordinates the interaction between the RNN cell’s external inputs and outputs and the internal memory bank. The controller can be, e.g., an LSTM itself, thereby maintaining an independent state. In this sense, the NTM’s memory bank truly is separate from the rest of the RNN cell.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The power of this architecture should be immediately clear: instead of reading and writing single numbers, we write vectors of numbers. This frees the rest of the network from having to coordinate groups of reads and writes, allowing it to focus on higher order tasks instead.&lt;/p&gt;
&lt;p&gt;This was a very brief introduction to a topic that I am not myself well acquainted to, so I encourage you to read the source: &lt;a href="https://arxiv.org/abs/1410.5401"&gt;Graves et al. (2014)&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="conclusion"&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;In this post, we’ve covered a lot of material, which has hopefully provided some powerful intuitions into recurrent architectures and neural networks generally. You should now have a solid understanding of LSTMs and the motivations behind them, and hopefully have gotten some ideas about how to apply the principles of LSTMs to building deep recurrent and feedforward archictures.&lt;/p&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;A great introductory resource for the prerequisites is Andrew Ng’s &lt;a href="https://www.coursera.org/learn/machine-learning/"&gt;machine learning&lt;/a&gt; (first 5 weeks). A great intermediate resource is Andrej Karpathy’s &lt;a href="http://cs231n.github.io/"&gt;CS231n&lt;/a&gt;.&lt;a href="#fnref1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;Do educate yourself on &lt;a href="http://www.bearsmart.com/play/bear-encounters/"&gt;bear safety&lt;/a&gt;; your first thought may be think “run”, but that’s not a good idea.&lt;a href="#fnref2"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn3"&gt;&lt;p&gt;A universal function approximator can emulate any (Borel measurable) function. Some smart people have proven mathematically that feedforward neural networks with a single, large hidden layer operate as universal function approximators. See &lt;a href="http://neuralnetworksanddeeplearning.com/chap4.html"&gt;Michael Nielson’s writeup&lt;/a&gt; for the visual intuitions behind this, or refer to the original papers by &lt;a href="http://deeplearning.cs.cmu.edu/pdfs/Kornick_et_al.pdf"&gt;Hornik et al. (1989)&lt;/a&gt; and &lt;a href="https://www.dartmouth.edu/~gvc/Cybenko_MCSS.pdf"&gt;Cybenko (1989)&lt;/a&gt; for formal proofs.&lt;a href="#fnref3"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn4"&gt;&lt;p&gt;While commonly known as the vanishing and exploding gradient problem, in my view this name hides the true nature of the problem. The alternate name, vanishing and exploding &lt;em&gt;sensitivity&lt;/em&gt;, is borrowed from &lt;a href="https://arxiv.org/pdf/1410.5401.pdf"&gt;Graves et al. (2014), Neural Turing Machines&lt;/a&gt;&lt;a href="#fnref4"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn5"&gt;&lt;p&gt;Credit to &lt;a href="http://www.cs.utoronto.ca/~ilya/pubs/ilya_sutskever_phd_thesis.pdf"&gt;Ilya Sutskever’s thesis&lt;/a&gt; for the butterfly effect reference.&lt;a href="#fnref5"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn6"&gt;&lt;p&gt;It is worth noting that there is a type of RNN, the “echo state” network, designed to take advantage of information morphing. It works by choosing an initial recurring function that is regular in the way information morphs, so that the state today is an “echo” of the past. In echo state networks, we don’t train the initial function (for that would change the way information morphs, making it unpredictable). Rather, we learn to interpret the state of the network from its outputs. Essentially, these networks take advantage of information morphing to impose a time signature on the morphing data, and we learn to be archeologists (e.g., in real life, we know how long ago dinosaurs lived by looking at the radioactive decay of the rocks surrounding their fossils).&lt;a href="#fnref6"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn7"&gt;&lt;p&gt;Pascanu et al. (2013) mention this stronger result in passing in Section 2.2 of their paper, but it is never explicitly justified.&lt;a href="#fnref7"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn8"&gt;&lt;p&gt;To see why this is the case, consider the following argument: &lt;span class="math inline"&gt;\(\gamma\)&lt;/span&gt; is the largest singular value of &lt;span class="math inline"&gt;\([\phi&amp;#39;(c)]\)&lt;/span&gt; (the Jacobian of &lt;span class="math inline"&gt;\(\phi\)&lt;/span&gt; evaluated at some vector &lt;span class="math inline"&gt;\(c\)&lt;/span&gt;) for all vectors &lt;span class="math inline"&gt;\(c\)&lt;/span&gt; on the interval &lt;span class="math inline"&gt;\([z_t,\ z_t + \Delta z_t]\)&lt;/span&gt;. For point-wise non-linearities like the logistic sigmoid and tanh, &lt;span class="math inline"&gt;\([\phi&amp;#39;(c)]\)&lt;/span&gt; will be a diagonal matrix whose entry in row &lt;span class="math inline"&gt;\(i\)&lt;/span&gt;, column &lt;span class="math inline"&gt;\(i\)&lt;/span&gt; will be the derivative of &lt;span class="math inline"&gt;\(\phi\)&lt;/span&gt; evaluated at the &lt;span class="math inline"&gt;\(i\)&lt;/span&gt;th element of &lt;span class="math inline"&gt;\(c\)&lt;/span&gt;. Since &lt;span class="math inline"&gt;\([\phi&amp;#39;(c)]\)&lt;/span&gt; is a diagonal matrix, the absolute values of its diagonal entries are its singular values. Therefore, if &lt;span class="math inline"&gt;\(\phi&amp;#39;(x)\)&lt;/span&gt; is bounded for all real numbers &lt;span class="math inline"&gt;\(x\)&lt;/span&gt;, so too will be the singular values of &lt;span class="math inline"&gt;\([\phi&amp;#39;(c)]\)&lt;/span&gt;, regardless of what &lt;span class="math inline"&gt;\(c\)&lt;/span&gt; is. The derivatives of the logistic sigmoid and tanh both reach their maximum values (upper bounds) of &lt;span class="math inline"&gt;\(\frac{1}{4}\)&lt;/span&gt; and &lt;span class="math inline"&gt;\(1\)&lt;/span&gt; respectively when evaluated at 0. Therefore, it follows that for the logistic sigmoid, &lt;span class="math inline"&gt;\(\gamma \leq \frac{1}{4}\)&lt;/span&gt;, and for tanh, &lt;span class="math inline"&gt;\(\gamma \leq 1\)&lt;/span&gt;.&lt;a href="#fnref8"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn9"&gt;&lt;p&gt;This is a more or less fair assumption, since our initial weights will be small and at least some of our activations will not be saturated to start, so that &lt;span class="math inline"&gt;\(\gamma\)&lt;/span&gt;, the supremum of the norm of the Jacobian of &lt;span class="math inline"&gt;\(\tanh(z(s_t))\)&lt;/span&gt; should be very close to 1.&lt;a href="#fnref9"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn10"&gt;&lt;p&gt;Note that the usage of &lt;span class="math inline"&gt;\(\Delta\)&lt;/span&gt; here is different than in the discussion of vanishing gradients above. Here the delta is from one timestep to the next; above the deltas are two state vectors at the same time step.&lt;a href="#fnref10"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn11"&gt;&lt;p&gt;See my post &lt;a href="https://r2rt.com/recurrent-neural-networks-in-tensorflow-ii.html"&gt;RNNs in Tensorflow II&lt;/a&gt; for more on layer normalization, which is a recent RNN add-on introduced by &lt;a href="http://arxiv.org/abs/1607.06450"&gt;Lei Ba et al. (2016)&lt;/a&gt;&lt;a href="#fnref11"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn12"&gt;&lt;p&gt;This is actually quite natural once we get to the pseudo LSTM: any time the state interacts with anything but its own delta (i.e., writes to the state), it is squashed.&lt;a href="#fnref12"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn13"&gt;&lt;p&gt;The one &lt;em&gt;good&lt;/em&gt; diagram of LSTMs includes the whole LSTM cell and can be found in &lt;a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/"&gt;Christopher Olah’s post on LSTMs&lt;/a&gt;.&lt;a href="#fnref13"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
&lt;/body&gt;
&lt;/html&gt;
</content></entry><entry><title>Recurrent Neural Networks in Tensorflow II</title><link href="https://r2rt.com/recurrent-neural-networks-in-tensorflow-ii.html" rel="alternate"></link><published>2016-07-25T00:00:00-04:00</published><updated>2016-07-25T00:00:00-04:00</updated><author><name>Silviu Pitis</name></author><id>tag:r2rt.com,2016-07-25:/recurrent-neural-networks-in-tensorflow-ii.html</id><summary type="html">This is the second in a series of posts about recurrent neural networks in Tensorflow. In this post, we will build upon our vanilla RNN by learning how to use Tensorflow's scan and dynamic_rnn models, upgrading the RNN cell and stacking multiple RNNs, and adding dropout and layer normalization. We will then use our upgraded RNN to generate some text, character by character.</summary><content type="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;meta name="generator" content="pandoc"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes"&gt;
  &lt;title&gt;&lt;/title&gt;
  &lt;style type="text/css"&gt;code{white-space: pre;}&lt;/style&gt;
  &lt;style type="text/css"&gt;
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code &gt; span.kw { color: #007020; font-weight: bold; } /* Keyword */
code &gt; span.dt { color: #902000; } /* DataType */
code &gt; span.dv { color: #40a070; } /* DecVal */
code &gt; span.bn { color: #40a070; } /* BaseN */
code &gt; span.fl { color: #40a070; } /* Float */
code &gt; span.ch { color: #4070a0; } /* Char */
code &gt; span.st { color: #4070a0; } /* String */
code &gt; span.co { color: #60a0b0; font-style: italic; } /* Comment */
code &gt; span.ot { color: #007020; } /* Other */
code &gt; span.al { color: #ff0000; font-weight: bold; } /* Alert */
code &gt; span.fu { color: #06287e; } /* Function */
code &gt; span.er { color: #ff0000; font-weight: bold; } /* Error */
code &gt; span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code &gt; span.cn { color: #880000; } /* Constant */
code &gt; span.sc { color: #4070a0; } /* SpecialChar */
code &gt; span.vs { color: #4070a0; } /* VerbatimString */
code &gt; span.ss { color: #bb6688; } /* SpecialString */
code &gt; span.im { } /* Import */
code &gt; span.va { color: #19177c; } /* Variable */
code &gt; span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code &gt; span.op { color: #666666; } /* Operator */
code &gt; span.bu { } /* BuiltIn */
code &gt; span.ex { } /* Extension */
code &gt; span.pp { color: #bc7a00; } /* Preprocessor */
code &gt; span.at { color: #7d9029; } /* Attribute */
code &gt; span.do { color: #ba2121; font-style: italic; } /* Documentation */
code &gt; span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code &gt; span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code &gt; span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  &lt;/style&gt;
  &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"&gt;&lt;/script&gt;
  &lt;!--[if lt IE 9]&gt;
    &lt;script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"&gt;&lt;/script&gt;
  &lt;![endif]--&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;This is the second in a series of posts about recurrent neural networks in Tensorflow. The first post lives &lt;a href="https://r2rt.com/recurrent-neural-networks-in-tensorflow-i.html"&gt;here&lt;/a&gt;. In this post, we will build upon our vanilla RNN by learning how to use Tensorflow’s scan and dynamic_rnn models, upgrading the RNN cell and stacking multiple RNNs, and adding dropout and layer normalization. We will then use our upgraded RNN to generate some text, character by character.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note 3/14/2017&lt;/strong&gt;: This tutorial is quite a bit deprecated by changes to the TF api. Leaving it up since it may still be useful, and most changes to the API are cosmetic (biggest change is that many of the RNN cells and functions are in the tf.contrib.rnn module). There was also a change to the ptb_iterator. A (slightly modified) copy of the old version which should work until I update this tutorial is uploaded &lt;a href="https://gist.github.com/spitis/2dd1720850154b25d2cec58d4b75c4a0"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="recap-of-our-model"&gt;Recap of our model&lt;/h3&gt;
&lt;p&gt;In the last post, we built a very simple, no frills RNN that was quickly able to learn to solve the toy task we created for it.&lt;/p&gt;
&lt;p&gt;Here is the formal statement of our model from last time:&lt;/p&gt;
&lt;p&gt;&lt;span class="math inline"&gt;\(S_t = \text{tanh}(W(X_t \ @ \ S_{t-1}) + b_s)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="math inline"&gt;\(P_t = \text{softmax}(US_t + b_p)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;where &lt;span class="math inline"&gt;\(@\)&lt;/span&gt; represents vector concatenation, &lt;span class="math inline"&gt;\(X_t \in R^n\)&lt;/span&gt; is an input vector, &lt;span class="math inline"&gt;\(W \in R^{d \times (n + d)}, \  b_s \in R^d, \ U \in R^{n \times d}\)&lt;/span&gt;, &lt;span class="math inline"&gt;\(b_p \in R^n\)&lt;/span&gt;, &lt;span class="math inline"&gt;\(n\)&lt;/span&gt; is the size of the input and output vectors, and d is the size of the hidden state vector. At time step 0, &lt;span class="math inline"&gt;\(S_{-1}\)&lt;/span&gt; (the initial state) is initialized as a vector of zeros.&lt;/p&gt;
&lt;h3 id="task-and-data"&gt;Task and data&lt;/h3&gt;
&lt;p&gt;This time around we will be building a character-level language model to generate character sequences, a la Andrej Karpathy’s &lt;a href="https://github.com/karpathy/char-rnn"&gt;char-rnn&lt;/a&gt; (and see, e.g., a Tensorflow implementation by Sherjil Ozair &lt;a href="https://github.com/sherjilozair/char-rnn-tensorflow"&gt;here&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Why do something that’s already been done? Well, this is a much harder task than the toy model from last time. This model needs to handle long sequences and learn long time dependencies. That makes a great task for learning about adding features to our RNN, and seeing how our changes affect the results as we go.&lt;/p&gt;
&lt;p&gt;To start, let’s create our data generator. We’ll use the tiny-shakespeare corpus as our data, though we could use any plain text file. We’ll choose to use all of the characters in the text file as our vocabulary, treating lowercase and capital letters are separate characters. In practice, there may be some advantage to forcing the network to use similar representations for capital and lowercase letters by using the same one-hot representations for each, plus a binary flag to indicate whether or not the letter is a capital. Additionally, it is likely a good idea to restrict the vocabulary (i.e., the set of characters) used, by replacing uncommon characters with an UNK token (like a square: □).&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="co"&gt;Imports&lt;/span&gt;
&lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="im"&gt;import&lt;/span&gt; numpy &lt;span class="im"&gt;as&lt;/span&gt; np
&lt;span class="im"&gt;import&lt;/span&gt; tensorflow &lt;span class="im"&gt;as&lt;/span&gt; tf
&lt;span class="op"&gt;%&lt;/span&gt;matplotlib inline
&lt;span class="im"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class="im"&gt;as&lt;/span&gt; plt
&lt;span class="im"&gt;import&lt;/span&gt; time
&lt;span class="im"&gt;import&lt;/span&gt; os
&lt;span class="im"&gt;import&lt;/span&gt; urllib.request
&lt;span class="im"&gt;from&lt;/span&gt; tensorflow.models.rnn.ptb &lt;span class="im"&gt;import&lt;/span&gt; reader&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="co"&gt;Load and process data, utility functions&lt;/span&gt;
&lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

file_url &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;https://raw.githubusercontent.com/jcjohnson/torch-rnn/master/data/tiny-shakespeare.txt&amp;#39;&lt;/span&gt;
file_name &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;tinyshakespeare.txt&amp;#39;&lt;/span&gt;
&lt;span class="cf"&gt;if&lt;/span&gt; &lt;span class="kw"&gt;not&lt;/span&gt; os.path.exists(file_name):
    urllib.request.urlretrieve(file_url, file_name)

&lt;span class="cf"&gt;with&lt;/span&gt; &lt;span class="bu"&gt;open&lt;/span&gt;(file_name,&lt;span class="st"&gt;&amp;#39;r&amp;#39;&lt;/span&gt;) &lt;span class="im"&gt;as&lt;/span&gt; f:
    raw_data &lt;span class="op"&gt;=&lt;/span&gt; f.read()
    &lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;Data length:&amp;quot;&lt;/span&gt;, &lt;span class="bu"&gt;len&lt;/span&gt;(raw_data))

vocab &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;set&lt;/span&gt;(raw_data)
vocab_size &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;len&lt;/span&gt;(vocab)
idx_to_vocab &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;dict&lt;/span&gt;(&lt;span class="bu"&gt;enumerate&lt;/span&gt;(vocab))
vocab_to_idx &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;dict&lt;/span&gt;(&lt;span class="bu"&gt;zip&lt;/span&gt;(idx_to_vocab.values(), idx_to_vocab.keys()))

data &lt;span class="op"&gt;=&lt;/span&gt; [vocab_to_idx[c] &lt;span class="cf"&gt;for&lt;/span&gt; c &lt;span class="kw"&gt;in&lt;/span&gt; raw_data]
&lt;span class="kw"&gt;del&lt;/span&gt; raw_data

&lt;span class="kw"&gt;def&lt;/span&gt; gen_epochs(n, num_steps, batch_size):
    &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(n):
        &lt;span class="cf"&gt;yield&lt;/span&gt; reader.ptb_iterator(data, batch_size, num_steps)

&lt;span class="kw"&gt;def&lt;/span&gt; reset_graph():
    &lt;span class="cf"&gt;if&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;sess&amp;#39;&lt;/span&gt; &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;globals&lt;/span&gt;() &lt;span class="kw"&gt;and&lt;/span&gt; sess:
        sess.close()
    tf.reset_default_graph()

&lt;span class="kw"&gt;def&lt;/span&gt; train_network(g, num_epochs, num_steps &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;200&lt;/span&gt;, batch_size &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;32&lt;/span&gt;, verbose &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="va"&gt;True&lt;/span&gt;, save&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;):
    tf.set_random_seed(&lt;span class="dv"&gt;2345&lt;/span&gt;)
    &lt;span class="cf"&gt;with&lt;/span&gt; tf.Session() &lt;span class="im"&gt;as&lt;/span&gt; sess:
        sess.run(tf.initialize_all_variables())
        training_losses &lt;span class="op"&gt;=&lt;/span&gt; []
        &lt;span class="cf"&gt;for&lt;/span&gt; idx, epoch &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;enumerate&lt;/span&gt;(gen_epochs(num_epochs, num_steps, batch_size)):
            training_loss &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;
            steps &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;
            training_state &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="va"&gt;None&lt;/span&gt;
            &lt;span class="cf"&gt;for&lt;/span&gt; X, Y &lt;span class="kw"&gt;in&lt;/span&gt; epoch:
                steps &lt;span class="op"&gt;+=&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;

                feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{g[&lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;]: X, g[&lt;span class="st"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;]: Y}
                &lt;span class="cf"&gt;if&lt;/span&gt; training_state &lt;span class="kw"&gt;is&lt;/span&gt; &lt;span class="kw"&gt;not&lt;/span&gt; &lt;span class="va"&gt;None&lt;/span&gt;:
                    feed_dict[g[&lt;span class="st"&gt;&amp;#39;init_state&amp;#39;&lt;/span&gt;]] &lt;span class="op"&gt;=&lt;/span&gt; training_state
                training_loss_, training_state, _ &lt;span class="op"&gt;=&lt;/span&gt; sess.run([g[&lt;span class="st"&gt;&amp;#39;total_loss&amp;#39;&lt;/span&gt;],
                                                      g[&lt;span class="st"&gt;&amp;#39;final_state&amp;#39;&lt;/span&gt;],
                                                      g[&lt;span class="st"&gt;&amp;#39;train_step&amp;#39;&lt;/span&gt;]],
                                                             feed_dict)
                training_loss &lt;span class="op"&gt;+=&lt;/span&gt; training_loss_
            &lt;span class="cf"&gt;if&lt;/span&gt; verbose:
                &lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;Average training loss for Epoch&amp;quot;&lt;/span&gt;, idx, &lt;span class="st"&gt;&amp;quot;:&amp;quot;&lt;/span&gt;, training_loss&lt;span class="op"&gt;/&lt;/span&gt;steps)
            training_losses.append(training_loss&lt;span class="op"&gt;/&lt;/span&gt;steps)

        &lt;span class="cf"&gt;if&lt;/span&gt; &lt;span class="bu"&gt;isinstance&lt;/span&gt;(save, &lt;span class="bu"&gt;str&lt;/span&gt;):
            g[&lt;span class="st"&gt;&amp;#39;saver&amp;#39;&lt;/span&gt;].save(sess, save)

    &lt;span class="cf"&gt;return&lt;/span&gt; training_losses&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Data length: 1115394&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="using-tf.scan-and-dynamic_rnn-to-speed-things-up"&gt;Using tf.scan and dynamic_rnn to speed things up&lt;/h3&gt;
&lt;p&gt;Recall from &lt;a href="https://r2rt.com/recurrent-neural-networks-in-tensorflow-i.html"&gt;last post&lt;/a&gt; that we represented each duplicate tensor of our RNN (e.g., the rnn inputs, rnn outputs, the predictions and the loss) as a &lt;em&gt;list&lt;/em&gt; of tensors:&lt;/p&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/BasicRNNLabeled.png" alt="Diagram of Basic RNN - Labeled" /&gt;&lt;figcaption&gt;Diagram of Basic RNN - Labeled&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;This worked quite well for our toy task, because our longest dependency was 7 steps back and we never really needed to backpropagate errors more than 10 steps. Even with a word-level RNN, using lists will probably be sufficient. See, e.g., my post on &lt;a href="http://r2rt.com/styles-of-truncated-backpropagation.html"&gt;Styles of Truncated Backpropagation&lt;/a&gt;, where I build a 40-step graph with no problems. But for a character-level model, 40 characters isn’t a whole lot. We might want to capture much longer dependencies. So let’s see what happens when we build a graph that is 200 time steps wide:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; build_basic_rnn_graph_with_list(
    state_size &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;100&lt;/span&gt;,
    num_classes &lt;span class="op"&gt;=&lt;/span&gt; vocab_size,
    batch_size &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;32&lt;/span&gt;,
    num_steps &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;200&lt;/span&gt;,
    learning_rate &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="fl"&gt;1e-4&lt;/span&gt;):

    reset_graph()

    x &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(tf.int32, [batch_size, num_steps], name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;input_placeholder&amp;#39;&lt;/span&gt;)
    y &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(tf.int32, [batch_size, num_steps], name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;labels_placeholder&amp;#39;&lt;/span&gt;)

    x_one_hot &lt;span class="op"&gt;=&lt;/span&gt; tf.one_hot(x, num_classes)
    rnn_inputs &lt;span class="op"&gt;=&lt;/span&gt; [tf.squeeze(i,squeeze_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;1&lt;/span&gt;]) &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; tf.split(&lt;span class="dv"&gt;1&lt;/span&gt;, num_steps, x_one_hot)]

    cell &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.rnn_cell.BasicRNNCell(state_size)
    init_state &lt;span class="op"&gt;=&lt;/span&gt; cell.zero_state(batch_size, tf.float32)
    rnn_outputs, final_state &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.rnn(cell, rnn_inputs, initial_state&lt;span class="op"&gt;=&lt;/span&gt;init_state)

    &lt;span class="cf"&gt;with&lt;/span&gt; tf.variable_scope(&lt;span class="st"&gt;&amp;#39;softmax&amp;#39;&lt;/span&gt;):
        W &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;W&amp;#39;&lt;/span&gt;, [state_size, num_classes])
        b &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;, [num_classes], initializer&lt;span class="op"&gt;=&lt;/span&gt;tf.constant_initializer(&lt;span class="fl"&gt;0.0&lt;/span&gt;))
    logits &lt;span class="op"&gt;=&lt;/span&gt; [tf.matmul(rnn_output, W) &lt;span class="op"&gt;+&lt;/span&gt; b &lt;span class="cf"&gt;for&lt;/span&gt; rnn_output &lt;span class="kw"&gt;in&lt;/span&gt; rnn_outputs]

    y_as_list &lt;span class="op"&gt;=&lt;/span&gt; [tf.squeeze(i, squeeze_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;1&lt;/span&gt;]) &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; tf.split(&lt;span class="dv"&gt;1&lt;/span&gt;, num_steps, y)]

    loss_weights &lt;span class="op"&gt;=&lt;/span&gt; [tf.ones([batch_size]) &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(num_steps)]
    losses &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.seq2seq.sequence_loss_by_example(logits, y_as_list, loss_weights)
    total_loss &lt;span class="op"&gt;=&lt;/span&gt; tf.reduce_mean(losses)
    train_step &lt;span class="op"&gt;=&lt;/span&gt; tf.train.AdamOptimizer(learning_rate).minimize(total_loss)

    &lt;span class="cf"&gt;return&lt;/span&gt; &lt;span class="bu"&gt;dict&lt;/span&gt;(
        x &lt;span class="op"&gt;=&lt;/span&gt; x,
        y &lt;span class="op"&gt;=&lt;/span&gt; y,
        init_state &lt;span class="op"&gt;=&lt;/span&gt; init_state,
        final_state &lt;span class="op"&gt;=&lt;/span&gt; final_state,
        total_loss &lt;span class="op"&gt;=&lt;/span&gt; total_loss,
        train_step &lt;span class="op"&gt;=&lt;/span&gt; train_step
    )&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;t &lt;span class="op"&gt;=&lt;/span&gt; time.time()
build_basic_rnn_graph_with_list()
&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;It took&amp;quot;&lt;/span&gt;, time.time() &lt;span class="op"&gt;-&lt;/span&gt; t, &lt;span class="st"&gt;&amp;quot;seconds to build the graph.&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;It took 5.626644849777222 seconds to build the graph.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It took over 5 seconds to build the graph of the most basic RNN model! This could bad… what happens when we move up to a 3-layer LSTM?&lt;/p&gt;
&lt;p&gt;Below, we switch out the RNN cell for a Multi-layer LSTM cell. We’ll go over the details of how to do this in the next section.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; build_multilayer_lstm_graph_with_list(
    state_size &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;100&lt;/span&gt;,
    num_classes &lt;span class="op"&gt;=&lt;/span&gt; vocab_size,
    batch_size &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;32&lt;/span&gt;,
    num_steps &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;200&lt;/span&gt;,
    num_layers &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;3&lt;/span&gt;,
    learning_rate &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="fl"&gt;1e-4&lt;/span&gt;):

    reset_graph()

    x &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(tf.int32, [batch_size, num_steps], name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;input_placeholder&amp;#39;&lt;/span&gt;)
    y &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(tf.int32, [batch_size, num_steps], name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;labels_placeholder&amp;#39;&lt;/span&gt;)

    embeddings &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;embedding_matrix&amp;#39;&lt;/span&gt;, [num_classes, state_size])
    rnn_inputs &lt;span class="op"&gt;=&lt;/span&gt; [tf.squeeze(i) &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; tf.split(&lt;span class="dv"&gt;1&lt;/span&gt;,
                                num_steps, tf.nn.embedding_lookup(embeddings, x))]

    cell &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.rnn_cell.LSTMCell(state_size, state_is_tuple&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)
    cell &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.rnn_cell.MultiRNNCell([cell] &lt;span class="op"&gt;*&lt;/span&gt; num_layers, state_is_tuple&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)
    init_state &lt;span class="op"&gt;=&lt;/span&gt; cell.zero_state(batch_size, tf.float32)
    rnn_outputs, final_state &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.rnn(cell, rnn_inputs, initial_state&lt;span class="op"&gt;=&lt;/span&gt;init_state)

    &lt;span class="cf"&gt;with&lt;/span&gt; tf.variable_scope(&lt;span class="st"&gt;&amp;#39;softmax&amp;#39;&lt;/span&gt;):
        W &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;W&amp;#39;&lt;/span&gt;, [state_size, num_classes])
        b &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;, [num_classes], initializer&lt;span class="op"&gt;=&lt;/span&gt;tf.constant_initializer(&lt;span class="fl"&gt;0.0&lt;/span&gt;))
    logits &lt;span class="op"&gt;=&lt;/span&gt; [tf.matmul(rnn_output, W) &lt;span class="op"&gt;+&lt;/span&gt; b &lt;span class="cf"&gt;for&lt;/span&gt; rnn_output &lt;span class="kw"&gt;in&lt;/span&gt; rnn_outputs]

    y_as_list &lt;span class="op"&gt;=&lt;/span&gt; [tf.squeeze(i, squeeze_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;1&lt;/span&gt;]) &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; tf.split(&lt;span class="dv"&gt;1&lt;/span&gt;, num_steps, y)]

    loss_weights &lt;span class="op"&gt;=&lt;/span&gt; [tf.ones([batch_size]) &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(num_steps)]
    losses &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.seq2seq.sequence_loss_by_example(logits, y_as_list, loss_weights)
    total_loss &lt;span class="op"&gt;=&lt;/span&gt; tf.reduce_mean(losses)
    train_step &lt;span class="op"&gt;=&lt;/span&gt; tf.train.AdamOptimizer(learning_rate).minimize(total_loss)

    &lt;span class="cf"&gt;return&lt;/span&gt; &lt;span class="bu"&gt;dict&lt;/span&gt;(
        x &lt;span class="op"&gt;=&lt;/span&gt; x,
        y &lt;span class="op"&gt;=&lt;/span&gt; y,
        init_state &lt;span class="op"&gt;=&lt;/span&gt; init_state,
        final_state &lt;span class="op"&gt;=&lt;/span&gt; final_state,
        total_loss &lt;span class="op"&gt;=&lt;/span&gt; total_loss,
        train_step &lt;span class="op"&gt;=&lt;/span&gt; train_step
    )&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;t &lt;span class="op"&gt;=&lt;/span&gt; time.time()
build_multilayer_lstm_graph_with_list()
&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;It took&amp;quot;&lt;/span&gt;, time.time() &lt;span class="op"&gt;-&lt;/span&gt; t, &lt;span class="st"&gt;&amp;quot;seconds to build the graph.&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;It took 25.640846967697144 seconds to build the graph.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Yikes, almost 30 seconds.&lt;/p&gt;
&lt;p&gt;Now this isn’t that big of an issue for training, because we only need to build the graph once. It could be a big issue, however, if we need to build the graph multiple times at test time.&lt;/p&gt;
&lt;p&gt;To get around this long compile time, Tensorflow allows us to create the graph at runtime. Here is a quick demonstration of the difference, using Tensorflow’s dynamic_rnn function:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; build_multilayer_lstm_graph_with_dynamic_rnn(
    state_size &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;100&lt;/span&gt;,
    num_classes &lt;span class="op"&gt;=&lt;/span&gt; vocab_size,
    batch_size &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;32&lt;/span&gt;,
    num_steps &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;200&lt;/span&gt;,
    num_layers &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;3&lt;/span&gt;,
    learning_rate &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="fl"&gt;1e-4&lt;/span&gt;):

    reset_graph()

    x &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(tf.int32, [batch_size, num_steps], name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;input_placeholder&amp;#39;&lt;/span&gt;)
    y &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(tf.int32, [batch_size, num_steps], name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;labels_placeholder&amp;#39;&lt;/span&gt;)

    embeddings &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;embedding_matrix&amp;#39;&lt;/span&gt;, [num_classes, state_size])

    &lt;span class="co"&gt;# Note that our inputs are no longer a list, but a tensor of dims batch_size x num_steps x state_size&lt;/span&gt;
    rnn_inputs &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.embedding_lookup(embeddings, x)

    cell &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.rnn_cell.LSTMCell(state_size, state_is_tuple&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)
    cell &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.rnn_cell.MultiRNNCell([cell] &lt;span class="op"&gt;*&lt;/span&gt; num_layers, state_is_tuple&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)
    init_state &lt;span class="op"&gt;=&lt;/span&gt; cell.zero_state(batch_size, tf.float32)
    rnn_outputs, final_state &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.dynamic_rnn(cell, rnn_inputs, initial_state&lt;span class="op"&gt;=&lt;/span&gt;init_state)

    &lt;span class="cf"&gt;with&lt;/span&gt; tf.variable_scope(&lt;span class="st"&gt;&amp;#39;softmax&amp;#39;&lt;/span&gt;):
        W &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;W&amp;#39;&lt;/span&gt;, [state_size, num_classes])
        b &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;, [num_classes], initializer&lt;span class="op"&gt;=&lt;/span&gt;tf.constant_initializer(&lt;span class="fl"&gt;0.0&lt;/span&gt;))

    &lt;span class="co"&gt;#reshape rnn_outputs and y so we can get the logits in a single matmul&lt;/span&gt;
    rnn_outputs &lt;span class="op"&gt;=&lt;/span&gt; tf.reshape(rnn_outputs, [&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;, state_size])
    y_reshaped &lt;span class="op"&gt;=&lt;/span&gt; tf.reshape(y, [&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;])

    logits &lt;span class="op"&gt;=&lt;/span&gt; tf.matmul(rnn_outputs, W) &lt;span class="op"&gt;+&lt;/span&gt; b

    total_loss &lt;span class="op"&gt;=&lt;/span&gt; tf.reduce_mean(tf.nn.sparse_softmax_cross_entropy_with_logits(logits, y_reshaped))
    train_step &lt;span class="op"&gt;=&lt;/span&gt; tf.train.AdamOptimizer(learning_rate).minimize(total_loss)

    &lt;span class="cf"&gt;return&lt;/span&gt; &lt;span class="bu"&gt;dict&lt;/span&gt;(
        x &lt;span class="op"&gt;=&lt;/span&gt; x,
        y &lt;span class="op"&gt;=&lt;/span&gt; y,
        init_state &lt;span class="op"&gt;=&lt;/span&gt; init_state,
        final_state &lt;span class="op"&gt;=&lt;/span&gt; final_state,
        total_loss &lt;span class="op"&gt;=&lt;/span&gt; total_loss,
        train_step &lt;span class="op"&gt;=&lt;/span&gt; train_step
    )&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;t &lt;span class="op"&gt;=&lt;/span&gt; time.time()
build_multilayer_lstm_graph_with_dynamic_rnn()
&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;It took&amp;quot;&lt;/span&gt;, time.time() &lt;span class="op"&gt;-&lt;/span&gt; t, &lt;span class="st"&gt;&amp;quot;seconds to build the graph.&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;It took 0.5314393043518066 seconds to build the graph.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Much better. One would think that pushing the graph construction to execution time would cause execution of the graph to go slower, but in this case, using dynamic_rnn actually speeds things up:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;g &lt;span class="op"&gt;=&lt;/span&gt; build_multilayer_lstm_graph_with_list()
t &lt;span class="op"&gt;=&lt;/span&gt; time.time()
train_network(g, &lt;span class="dv"&gt;3&lt;/span&gt;)
&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;It took&amp;quot;&lt;/span&gt;, time.time() &lt;span class="op"&gt;-&lt;/span&gt; t, &lt;span class="st"&gt;&amp;quot;seconds to train for 3 epochs.&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Average training loss for Epoch 0 : 3.53323210245
Average training loss for Epoch 1 : 3.31435756163
Average training loss for Epoch 2 : 3.21755325109
It took 117.78161263465881 seconds to train for 3 epochs.&lt;/code&gt;&lt;/pre&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;g &lt;span class="op"&gt;=&lt;/span&gt; build_multilayer_lstm_graph_with_dynamic_rnn()
t &lt;span class="op"&gt;=&lt;/span&gt; time.time()
train_network(g, &lt;span class="dv"&gt;3&lt;/span&gt;)
&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;It took&amp;quot;&lt;/span&gt;, time.time() &lt;span class="op"&gt;-&lt;/span&gt; t, &lt;span class="st"&gt;&amp;quot;seconds to train for 3 epochs.&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Average training loss for Epoch 0 : 3.55792756053
Average training loss for Epoch 1 : 3.3225021006
Average training loss for Epoch 2 : 3.28286816745
It took 96.69413661956787 seconds to train for 3 epochs.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It’s not a breeze to work through and understand the dynamic_rnn code (which lives &lt;a href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/ops/rnn_cell.py"&gt;here&lt;/a&gt;), but we can obtain a similar result ourselves by using tf.scan (dynamic_rnn does not use scan). Scan runs just a tad slower than Tensorflow’s optimized code, but is easier to understand and write yourself.&lt;/p&gt;
&lt;p&gt;Scan is a higher-order function that you might be familiar with if you’ve done any programming in OCaml, Haskell or the like. In general, it takes a function (&lt;span class="math inline"&gt;\(f: (x_t, y_{t-1}) \mapsto y_t\)&lt;/span&gt;), a sequence (&lt;span class="math inline"&gt;\([x_0, x_1 \dots x_n]\)&lt;/span&gt;) and an initial value (&lt;span class="math inline"&gt;\(y_{-1}\)&lt;/span&gt;) and returns a sequence (&lt;span class="math inline"&gt;\([y_0, y_1 \dots y_n]\)&lt;/span&gt;) according to the rule: &lt;span class="math inline"&gt;\(y_t = f(x_t, y_{t-1})\)&lt;/span&gt;. In Tensorflow, scan treats the first dimension of a Tensor as the sequence. Thus, if fed a Tensor of shape [n, m, o] as the sequence, scan would unpack it into a sequence of n-tensors, each with shape [m, o]. You can learn more about Tensorflow’s scan &lt;a href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/g3doc/api_docs/python/functional_ops.md#tfscanfn-elems-initializernone-parallel_iterations10-back_proptrue-swap_memoryfalse-namenone-scan"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Below, I use scan with an LSTM so as to compare to the dynamic_rnn using Tensorflow above. Because LSTMs store their state in a 2-tuple, and we’re using a 3-layer network, the scan function produces, as &lt;code&gt;final_states&lt;/code&gt; below, a 3-tuple (one for each layer) of 2-tuples (one for each LSTM state), each of shape [num_steps, batch_size, state_size]. We need only the last state, which is why we unpack, slice and repack &lt;code&gt;final_states&lt;/code&gt; to get &lt;code&gt;final_state&lt;/code&gt; below.&lt;/p&gt;
&lt;p&gt;Another thing to note is that scan produces rnn_outputs with shape [num_steps, batch_size, state_size], whereas the dynamic_rnn produces rnn_outputs with shape [batch_size, num_steps, state_size] (the first two dimensions are switched). Dynamic_rnn has the flexibility to switch this behavior, using the “time_major” argument. Tf.scan does not have this flexibility, which is why we transpose &lt;code&gt;rnn_inputs&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; in the code below.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; build_multilayer_lstm_graph_with_scan(
    state_size &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;100&lt;/span&gt;,
    num_classes &lt;span class="op"&gt;=&lt;/span&gt; vocab_size,
    batch_size &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;32&lt;/span&gt;,
    num_steps &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;200&lt;/span&gt;,
    num_layers &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;3&lt;/span&gt;,
    learning_rate &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="fl"&gt;1e-4&lt;/span&gt;):

    reset_graph()

    x &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(tf.int32, [batch_size, num_steps], name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;input_placeholder&amp;#39;&lt;/span&gt;)
    y &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(tf.int32, [batch_size, num_steps], name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;labels_placeholder&amp;#39;&lt;/span&gt;)

    embeddings &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;embedding_matrix&amp;#39;&lt;/span&gt;, [num_classes, state_size])

    rnn_inputs &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.embedding_lookup(embeddings, x)

    cell &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.rnn_cell.LSTMCell(state_size, state_is_tuple&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)
    cell &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.rnn_cell.MultiRNNCell([cell] &lt;span class="op"&gt;*&lt;/span&gt; num_layers, state_is_tuple&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)
    init_state &lt;span class="op"&gt;=&lt;/span&gt; cell.zero_state(batch_size, tf.float32)
    rnn_outputs, final_states &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="op"&gt;\&lt;/span&gt;
        tf.scan(&lt;span class="kw"&gt;lambda&lt;/span&gt; a, x: cell(x, a[&lt;span class="dv"&gt;1&lt;/span&gt;]),
                tf.transpose(rnn_inputs, [&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;2&lt;/span&gt;]),
                initializer&lt;span class="op"&gt;=&lt;/span&gt;(tf.zeros([batch_size, state_size]), init_state))

    &lt;span class="co"&gt;# there may be a better way to do this:&lt;/span&gt;
    final_state &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;tuple&lt;/span&gt;([tf.nn.rnn_cell.LSTMStateTuple(
                  tf.squeeze(tf.&lt;span class="bu"&gt;slice&lt;/span&gt;(c, [num_steps&lt;span class="dv"&gt;-1&lt;/span&gt;,&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;0&lt;/span&gt;], [&lt;span class="dv"&gt;1&lt;/span&gt;, batch_size, state_size])),
                  tf.squeeze(tf.&lt;span class="bu"&gt;slice&lt;/span&gt;(h, [num_steps&lt;span class="dv"&gt;-1&lt;/span&gt;,&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;0&lt;/span&gt;], [&lt;span class="dv"&gt;1&lt;/span&gt;, batch_size, state_size])))
                       &lt;span class="cf"&gt;for&lt;/span&gt; c, h &lt;span class="kw"&gt;in&lt;/span&gt; final_states])

    &lt;span class="cf"&gt;with&lt;/span&gt; tf.variable_scope(&lt;span class="st"&gt;&amp;#39;softmax&amp;#39;&lt;/span&gt;):
        W &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;W&amp;#39;&lt;/span&gt;, [state_size, num_classes])
        b &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;, [num_classes], initializer&lt;span class="op"&gt;=&lt;/span&gt;tf.constant_initializer(&lt;span class="fl"&gt;0.0&lt;/span&gt;))

    rnn_outputs &lt;span class="op"&gt;=&lt;/span&gt; tf.reshape(rnn_outputs, [&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;, state_size])
    y_reshaped &lt;span class="op"&gt;=&lt;/span&gt; tf.reshape(tf.transpose(y,[&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;0&lt;/span&gt;]), [&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;])

    logits &lt;span class="op"&gt;=&lt;/span&gt; tf.matmul(rnn_outputs, W) &lt;span class="op"&gt;+&lt;/span&gt; b

    total_loss &lt;span class="op"&gt;=&lt;/span&gt; tf.reduce_mean(tf.nn.sparse_softmax_cross_entropy_with_logits(logits, y_reshaped))
    train_step &lt;span class="op"&gt;=&lt;/span&gt; tf.train.AdamOptimizer(learning_rate).minimize(total_loss)

    &lt;span class="cf"&gt;return&lt;/span&gt; &lt;span class="bu"&gt;dict&lt;/span&gt;(
        x &lt;span class="op"&gt;=&lt;/span&gt; x,
        y &lt;span class="op"&gt;=&lt;/span&gt; y,
        init_state &lt;span class="op"&gt;=&lt;/span&gt; init_state,
        final_state &lt;span class="op"&gt;=&lt;/span&gt; final_state,
        total_loss &lt;span class="op"&gt;=&lt;/span&gt; total_loss,
        train_step &lt;span class="op"&gt;=&lt;/span&gt; train_step
    )&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;t &lt;span class="op"&gt;=&lt;/span&gt; time.time()
g &lt;span class="op"&gt;=&lt;/span&gt; build_multilayer_lstm_graph_with_scan()
&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;It took&amp;quot;&lt;/span&gt;, time.time() &lt;span class="op"&gt;-&lt;/span&gt; t, &lt;span class="st"&gt;&amp;quot;seconds to build the graph.&amp;quot;&lt;/span&gt;)
t &lt;span class="op"&gt;=&lt;/span&gt; time.time()
train_network(g, &lt;span class="dv"&gt;3&lt;/span&gt;)
&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;It took&amp;quot;&lt;/span&gt;, time.time() &lt;span class="op"&gt;-&lt;/span&gt; t, &lt;span class="st"&gt;&amp;quot;seconds to train for 3 epochs.&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;It took 0.6475389003753662 seconds to build the graph.
Average training loss for Epoch 0 : 3.55362293501
Average training loss for Epoch 1 : 3.32045680079
Average training loss for Epoch 2 : 3.27433713688
It took 101.60246014595032 seconds to train for 3 epochs.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Using scan was only marginally slower than using dynamic_rnn, and gives us the flexibility and understanding to tweak the code if we ever need to (e.g., if for some reason we wanted to create a skip connection from the state at timestep t-2 to timestep t, it would be easy to do with scan).&lt;/p&gt;
&lt;h3 id="upgrading-the-rnn-cell"&gt;Upgrading the RNN cell&lt;/h3&gt;
&lt;p&gt;Above, we seamlessly swapped out the BasicRNNCell we were using for a Multi-layered LSTM cell. This was possible because the RNN cells conform to a general structure: every RNN cell is a function of the current input, &lt;span class="math inline"&gt;\(X_t\)&lt;/span&gt;, and the prior state, &lt;span class="math inline"&gt;\(S_{t-1}\)&lt;/span&gt;, that outputs a current state, &lt;span class="math inline"&gt;\(S_{t}\)&lt;/span&gt;, and a current output, &lt;span class="math inline"&gt;\(Y_t\)&lt;/span&gt;. Thus, in the same way that we can swap out activation functions in a feedforward net (e.g., change the tanh activation to a sigmoid or a relu activation), we can swap out the entire recurrence function (cell) in an RNN.&lt;/p&gt;
&lt;p&gt;Note that while for basic RNN cells, the current output equals the current state (&lt;span class="math inline"&gt;\(Y_t = S_t\)&lt;/span&gt;), this does not have to be the case. We’ll see how LSTMs and multi-layered RNNs diverge from this below.&lt;/p&gt;
&lt;p&gt;Two popular choices for RNN cells are the GRU cell and the LSTM cell. By using gates, GRU and LSTM cells avoid the vanishing gradient problem and allow the network to learn longer-term dependencies. Their internals are quite complicated, and I would refer you to my post &lt;a href="https://r2rt.com/written-memories-understanding-deriving-and-extending-the-lstm.html"&gt;Written Memories: Understanding, Deriving and Extending the LSTM&lt;/a&gt; for a good starting point to learn about them.&lt;/p&gt;
&lt;p&gt;All we have to do to upgrade our vanilla RNN cell is to replace this line:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cell = tf.nn.rnn_cell.BasicRNNCell(state_size)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;with this for LSTM:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cell = tf.nn.rnn_cell.LSTMCell(state_size)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or this for GRU:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cell = tf.nn.rnn_cell.GRUCell(state_size)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The LSTM keeps two sets of internal state vectors, &lt;span class="math inline"&gt;\(c\)&lt;/span&gt; (for memory &lt;strong&gt;c&lt;/strong&gt;ell or &lt;strong&gt;c&lt;/strong&gt;onstant error carousel) and &lt;span class="math inline"&gt;\(h\)&lt;/span&gt; (for &lt;strong&gt;h&lt;/strong&gt;idden state). By default, they are concatenated into a single vector, but as of this writing, using the default arguments to LSTMCell will produce a warning message:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;WARNING:tensorflow:&amp;lt;tensorflow.python.ops.rnn_cell.LSTMCell object at 0x7faade1708d0&amp;gt;: Using a concatenated state is slower and will soon be deprecated.  Use state_is_tuple=True.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This error tells us that it’s faster to represent the LSTM state as a tuple of &lt;span class="math inline"&gt;\(c\)&lt;/span&gt; and &lt;span class="math inline"&gt;\(h\)&lt;/span&gt;, rather than as a concatenation of &lt;span class="math inline"&gt;\(c\)&lt;/span&gt; and &lt;span class="math inline"&gt;\(h\)&lt;/span&gt;. You can tack on the argument &lt;code&gt;state_is_tuple=True&lt;/code&gt; to have it do that.&lt;/p&gt;
&lt;p&gt;By using a tuple for the state, we can also easily replace the base cell with a “MultiRNNCell” for multiple layers. To see why this works, consider that while a single cell:&lt;/p&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/RNN_BasicRNNCell.png" alt="Diagram of Basic RNN Cell" /&gt;&lt;figcaption&gt;Diagram of Basic RNN Cell&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;looks different from a two cells stacked on top of each other:&lt;/p&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/RNN_MultiRNNCellUngrouped.png" alt="Diagram of Multi RNN Cell 1" /&gt;&lt;figcaption&gt;Diagram of Multi RNN Cell 1&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;we can wrap the two cells into a single two-layer cell to make them look and behave as a single cell:&lt;/p&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/RNN_MultiRNNCellGrouped.png" alt="Diagram of Multi RNN Cell 2" /&gt;&lt;figcaption&gt;Diagram of Multi RNN Cell 2&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;To make this switch, we call &lt;code&gt;tf.nn.rnn_cell.MultiRNNCell&lt;/code&gt;, which takes a &lt;em&gt;list&lt;/em&gt; of RNNCells as its inputs and wraps them into a single cell:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cell = tf.nn.rnn_cell.MultiRNNCell([tf.nn.rnn_cell.BasicRNNCell(state_size)] * num_layers)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that if you are wrapping an LSTMCell that uses &lt;code&gt;state_is_tuple=True&lt;/code&gt;, you should pass this same argument to the MultiRNNCell as well.&lt;/p&gt;
&lt;h3 id="writing-a-custom-rnn-cell"&gt;Writing a custom RNN cell&lt;/h3&gt;
&lt;p&gt;It’s almost too easy to use the standard GRU or LSTM cells, so let’s define our own RNN cell. Here’s a random idea that may or may not work: starting with a GRU cell, instead of taking a single transformation of its input, we enable it to take a weighted average of multiple transformations of its input. That is, using the notation from &lt;a href="http://arxiv.org/pdf/1406.1078v3.pdf"&gt;Cho et al. (2014)&lt;/a&gt;, instead of using &lt;span class="math inline"&gt;\(Wx\)&lt;/span&gt; in our candidate state, &lt;span class="math inline"&gt;\(\tilde h^{(t)} = \text{tanh}(Wx + U(r \odot h^{(t-1)})\)&lt;/span&gt;, we use a weighted average of &lt;span class="math inline"&gt;\(W_1 x, \ W_2 x \dots W_n x\)&lt;/span&gt; for some n. In other words, we will replace &lt;span class="math inline"&gt;\(Wx\)&lt;/span&gt; with &lt;span class="math inline"&gt;\(\Sigma\lambda_iW_ix\)&lt;/span&gt; for some weights &lt;span class="math inline"&gt;\(\lambda_i\)&lt;/span&gt; that sum to 1. The vector of weights, &lt;span class="math inline"&gt;\(\lambda\)&lt;/span&gt;, will be calculated as &lt;span class="math inline"&gt;\(\lambda = \text{softmax}(W_{avg}x^{(t)} + U_{avg}h^{(t-1)} + b)\)&lt;/span&gt;. The idea is that we might benefit from treat the input differently in different scenarios (e.g., we may want to treat verbs differently than nouns).&lt;/p&gt;
&lt;p&gt;To write the custom cell, we need to extend tf.nn.rnn_cell.RNNCell. Specifically, we need to fill in 3 abstract methods and write an &lt;code&gt;__init__&lt;/code&gt; method (take a look at the Tensorflow code &lt;a href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/ops/rnn_cell.py"&gt;here&lt;/a&gt;). First, let’s start with a GRU cell, adapted from Tensorflow’s implementation:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;class&lt;/span&gt; GRUCell(tf.nn.rnn_cell.RNNCell):
    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;Gated Recurrent Unit cell (cf. http://arxiv.org/abs/1406.1078).&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

    &lt;span class="kw"&gt;def&lt;/span&gt; &lt;span class="fu"&gt;__init__&lt;/span&gt;(&lt;span class="va"&gt;self&lt;/span&gt;, num_units):
        &lt;span class="va"&gt;self&lt;/span&gt;._num_units &lt;span class="op"&gt;=&lt;/span&gt; num_units

    &lt;span class="at"&gt;@property&lt;/span&gt;
    &lt;span class="kw"&gt;def&lt;/span&gt; state_size(&lt;span class="va"&gt;self&lt;/span&gt;):
        &lt;span class="cf"&gt;return&lt;/span&gt; &lt;span class="va"&gt;self&lt;/span&gt;._num_units

    &lt;span class="at"&gt;@property&lt;/span&gt;
    &lt;span class="kw"&gt;def&lt;/span&gt; output_size(&lt;span class="va"&gt;self&lt;/span&gt;):
        &lt;span class="cf"&gt;return&lt;/span&gt; &lt;span class="va"&gt;self&lt;/span&gt;._num_units

    &lt;span class="kw"&gt;def&lt;/span&gt; &lt;span class="fu"&gt;__call__&lt;/span&gt;(&lt;span class="va"&gt;self&lt;/span&gt;, inputs, state, scope&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;None&lt;/span&gt;):
        &lt;span class="cf"&gt;with&lt;/span&gt; tf.variable_scope(scope &lt;span class="kw"&gt;or&lt;/span&gt; &lt;span class="bu"&gt;type&lt;/span&gt;(&lt;span class="va"&gt;self&lt;/span&gt;).&lt;span class="va"&gt;__name__&lt;/span&gt;):  &lt;span class="co"&gt;# &amp;quot;GRUCell&amp;quot;&lt;/span&gt;
            &lt;span class="cf"&gt;with&lt;/span&gt; tf.variable_scope(&lt;span class="st"&gt;&amp;quot;Gates&amp;quot;&lt;/span&gt;):  &lt;span class="co"&gt;# Reset gate and update gate.&lt;/span&gt;
                &lt;span class="co"&gt;# We start with bias of 1.0 to not reset and not update.&lt;/span&gt;
                ru &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.rnn_cell._linear([inputs, state],
                                        &lt;span class="dv"&gt;2&lt;/span&gt; &lt;span class="op"&gt;*&lt;/span&gt; &lt;span class="va"&gt;self&lt;/span&gt;._num_units, &lt;span class="va"&gt;True&lt;/span&gt;, &lt;span class="fl"&gt;1.0&lt;/span&gt;)
                ru &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.sigmoid(ru)
                r, u &lt;span class="op"&gt;=&lt;/span&gt; tf.split(&lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="dv"&gt;2&lt;/span&gt;, ru)
            &lt;span class="cf"&gt;with&lt;/span&gt; tf.variable_scope(&lt;span class="st"&gt;&amp;quot;Candidate&amp;quot;&lt;/span&gt;):
                c &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.tanh(tf.nn.rnn_cell._linear([inputs, r &lt;span class="op"&gt;*&lt;/span&gt; state],
                                             &lt;span class="va"&gt;self&lt;/span&gt;._num_units, &lt;span class="va"&gt;True&lt;/span&gt;))
            new_h &lt;span class="op"&gt;=&lt;/span&gt; u &lt;span class="op"&gt;*&lt;/span&gt; state &lt;span class="op"&gt;+&lt;/span&gt; (&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="op"&gt;-&lt;/span&gt; u) &lt;span class="op"&gt;*&lt;/span&gt; c
        &lt;span class="cf"&gt;return&lt;/span&gt; new_h, new_h&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We modify the &lt;code&gt;__init__&lt;/code&gt; method to take a parameter &lt;span class="math inline"&gt;\(n\)&lt;/span&gt; at initialization, which will determine the number of transformation matrices &lt;span class="math inline"&gt;\(W_i\)&lt;/span&gt; it will create:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def __init__(self, num_units, num_weights):
    self._num_units = num_units
    self._num_weights = num_weights&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then, we modify the &lt;code&gt;Candidate&lt;/code&gt; variable scope of the &lt;code&gt;__call__&lt;/code&gt; method to do a weighted average as shown below (note that all of the &lt;span class="math inline"&gt;\(W_i\)&lt;/span&gt; matrices are created as a single variable and then split into multiple tensors):&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;class&lt;/span&gt; CustomCell(tf.nn.rnn_cell.RNNCell):
    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;Gated Recurrent Unit cell (cf. http://arxiv.org/abs/1406.1078).&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

    &lt;span class="kw"&gt;def&lt;/span&gt; &lt;span class="fu"&gt;__init__&lt;/span&gt;(&lt;span class="va"&gt;self&lt;/span&gt;, num_units, num_weights):
        &lt;span class="va"&gt;self&lt;/span&gt;._num_units &lt;span class="op"&gt;=&lt;/span&gt; num_units
        &lt;span class="va"&gt;self&lt;/span&gt;._num_weights &lt;span class="op"&gt;=&lt;/span&gt; num_weights

    &lt;span class="at"&gt;@property&lt;/span&gt;
    &lt;span class="kw"&gt;def&lt;/span&gt; state_size(&lt;span class="va"&gt;self&lt;/span&gt;):
        &lt;span class="cf"&gt;return&lt;/span&gt; &lt;span class="va"&gt;self&lt;/span&gt;._num_units

    &lt;span class="at"&gt;@property&lt;/span&gt;
    &lt;span class="kw"&gt;def&lt;/span&gt; output_size(&lt;span class="va"&gt;self&lt;/span&gt;):
        &lt;span class="cf"&gt;return&lt;/span&gt; &lt;span class="va"&gt;self&lt;/span&gt;._num_units

    &lt;span class="kw"&gt;def&lt;/span&gt; &lt;span class="fu"&gt;__call__&lt;/span&gt;(&lt;span class="va"&gt;self&lt;/span&gt;, inputs, state, scope&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;None&lt;/span&gt;):
        &lt;span class="cf"&gt;with&lt;/span&gt; tf.variable_scope(scope &lt;span class="kw"&gt;or&lt;/span&gt; &lt;span class="bu"&gt;type&lt;/span&gt;(&lt;span class="va"&gt;self&lt;/span&gt;).&lt;span class="va"&gt;__name__&lt;/span&gt;):  &lt;span class="co"&gt;# &amp;quot;GRUCell&amp;quot;&lt;/span&gt;
            &lt;span class="cf"&gt;with&lt;/span&gt; tf.variable_scope(&lt;span class="st"&gt;&amp;quot;Gates&amp;quot;&lt;/span&gt;):  &lt;span class="co"&gt;# Reset gate and update gate.&lt;/span&gt;
                &lt;span class="co"&gt;# We start with bias of 1.0 to not reset and not update.&lt;/span&gt;
                ru &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.rnn_cell._linear([inputs, state],
                                        &lt;span class="dv"&gt;2&lt;/span&gt; &lt;span class="op"&gt;*&lt;/span&gt; &lt;span class="va"&gt;self&lt;/span&gt;._num_units, &lt;span class="va"&gt;True&lt;/span&gt;, &lt;span class="fl"&gt;1.0&lt;/span&gt;)
                ru &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.sigmoid(ru)
                r, u &lt;span class="op"&gt;=&lt;/span&gt; tf.split(&lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="dv"&gt;2&lt;/span&gt;, ru)
            &lt;span class="cf"&gt;with&lt;/span&gt; tf.variable_scope(&lt;span class="st"&gt;&amp;quot;Candidate&amp;quot;&lt;/span&gt;):
                lambdas &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.rnn_cell._linear([inputs, state], &lt;span class="va"&gt;self&lt;/span&gt;._num_weights, &lt;span class="va"&gt;True&lt;/span&gt;)
                lambdas &lt;span class="op"&gt;=&lt;/span&gt; tf.split(&lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="va"&gt;self&lt;/span&gt;._num_weights, tf.nn.softmax(lambdas))

                Ws &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;quot;Ws&amp;quot;&lt;/span&gt;,
                        shape &lt;span class="op"&gt;=&lt;/span&gt; [&lt;span class="va"&gt;self&lt;/span&gt;._num_weights, inputs.get_shape()[&lt;span class="dv"&gt;1&lt;/span&gt;], &lt;span class="va"&gt;self&lt;/span&gt;._num_units])
                Ws &lt;span class="op"&gt;=&lt;/span&gt; [tf.squeeze(i) &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; tf.split(&lt;span class="dv"&gt;0&lt;/span&gt;, &lt;span class="va"&gt;self&lt;/span&gt;._num_weights, Ws)]

                candidate_inputs &lt;span class="op"&gt;=&lt;/span&gt; []

                &lt;span class="cf"&gt;for&lt;/span&gt; idx, W &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;enumerate&lt;/span&gt;(Ws):
                    candidate_inputs.append(tf.matmul(inputs, W) &lt;span class="op"&gt;*&lt;/span&gt; lambdas[idx])

                Wx &lt;span class="op"&gt;=&lt;/span&gt; tf.add_n(candidate_inputs)

                c &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.tanh(Wx &lt;span class="op"&gt;+&lt;/span&gt; tf.nn.rnn_cell._linear([r &lt;span class="op"&gt;*&lt;/span&gt; state],
                                            &lt;span class="va"&gt;self&lt;/span&gt;._num_units, &lt;span class="va"&gt;True&lt;/span&gt;, scope&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;second&amp;quot;&lt;/span&gt;))
            new_h &lt;span class="op"&gt;=&lt;/span&gt; u &lt;span class="op"&gt;*&lt;/span&gt; state &lt;span class="op"&gt;+&lt;/span&gt; (&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="op"&gt;-&lt;/span&gt; u) &lt;span class="op"&gt;*&lt;/span&gt; c
        &lt;span class="cf"&gt;return&lt;/span&gt; new_h, new_h&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let’s see how the custom cell stacks up to a regular GRU cell (using &lt;code&gt;num_steps = 30&lt;/code&gt;, since this performs much better than &lt;code&gt;num_steps = 200&lt;/code&gt; after 5 epochs – can you see why that might happen?):&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; build_multilayer_graph_with_custom_cell(
    cell_type &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="va"&gt;None&lt;/span&gt;,
    num_weights_for_custom_cell &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;5&lt;/span&gt;,
    state_size &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;100&lt;/span&gt;,
    num_classes &lt;span class="op"&gt;=&lt;/span&gt; vocab_size,
    batch_size &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;32&lt;/span&gt;,
    num_steps &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;200&lt;/span&gt;,
    num_layers &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;3&lt;/span&gt;,
    learning_rate &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="fl"&gt;1e-4&lt;/span&gt;):

    reset_graph()

    x &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(tf.int32, [batch_size, num_steps], name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;input_placeholder&amp;#39;&lt;/span&gt;)
    y &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(tf.int32, [batch_size, num_steps], name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;labels_placeholder&amp;#39;&lt;/span&gt;)

    embeddings &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;embedding_matrix&amp;#39;&lt;/span&gt;, [num_classes, state_size])

    rnn_inputs &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.embedding_lookup(embeddings, x)

    &lt;span class="cf"&gt;if&lt;/span&gt; cell_type &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;Custom&amp;#39;&lt;/span&gt;:
        cell &lt;span class="op"&gt;=&lt;/span&gt; CustomCell(state_size, num_weights_for_custom_cell)
    &lt;span class="cf"&gt;elif&lt;/span&gt; cell_type &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;GRU&amp;#39;&lt;/span&gt;:
        cell &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.rnn_cell.GRUCell(state_size)
    &lt;span class="cf"&gt;elif&lt;/span&gt; cell_type &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;LSTM&amp;#39;&lt;/span&gt;:
        cell &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.rnn_cell.LSTMCell(state_size, state_is_tuple&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)
    &lt;span class="cf"&gt;else&lt;/span&gt;:
        cell &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.rnn_cell.BasicRNNCell(state_size)

    &lt;span class="cf"&gt;if&lt;/span&gt; cell_type &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;LSTM&amp;#39;&lt;/span&gt;:
        cell &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.rnn_cell.MultiRNNCell([cell] &lt;span class="op"&gt;*&lt;/span&gt; num_layers, state_is_tuple&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)
    &lt;span class="cf"&gt;else&lt;/span&gt;:
        cell &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.rnn_cell.MultiRNNCell([cell] &lt;span class="op"&gt;*&lt;/span&gt; num_layers)

    init_state &lt;span class="op"&gt;=&lt;/span&gt; cell.zero_state(batch_size, tf.float32)
    rnn_outputs, final_state &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.dynamic_rnn(cell, rnn_inputs, initial_state&lt;span class="op"&gt;=&lt;/span&gt;init_state)

    &lt;span class="cf"&gt;with&lt;/span&gt; tf.variable_scope(&lt;span class="st"&gt;&amp;#39;softmax&amp;#39;&lt;/span&gt;):
        W &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;W&amp;#39;&lt;/span&gt;, [state_size, num_classes])
        b &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;, [num_classes], initializer&lt;span class="op"&gt;=&lt;/span&gt;tf.constant_initializer(&lt;span class="fl"&gt;0.0&lt;/span&gt;))

    &lt;span class="co"&gt;#reshape rnn_outputs and y&lt;/span&gt;
    rnn_outputs &lt;span class="op"&gt;=&lt;/span&gt; tf.reshape(rnn_outputs, [&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;, state_size])
    y_reshaped &lt;span class="op"&gt;=&lt;/span&gt; tf.reshape(y, [&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;])

    logits &lt;span class="op"&gt;=&lt;/span&gt; tf.matmul(rnn_outputs, W) &lt;span class="op"&gt;+&lt;/span&gt; b

    total_loss &lt;span class="op"&gt;=&lt;/span&gt; tf.reduce_mean(tf.nn.sparse_softmax_cross_entropy_with_logits(logits, y_reshaped))
    train_step &lt;span class="op"&gt;=&lt;/span&gt; tf.train.AdamOptimizer(learning_rate).minimize(total_loss)

    &lt;span class="cf"&gt;return&lt;/span&gt; &lt;span class="bu"&gt;dict&lt;/span&gt;(
        x &lt;span class="op"&gt;=&lt;/span&gt; x,
        y &lt;span class="op"&gt;=&lt;/span&gt; y,
        init_state &lt;span class="op"&gt;=&lt;/span&gt; init_state,
        final_state &lt;span class="op"&gt;=&lt;/span&gt; final_state,
        total_loss &lt;span class="op"&gt;=&lt;/span&gt; total_loss,
        train_step &lt;span class="op"&gt;=&lt;/span&gt; train_step
    )&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;g &lt;span class="op"&gt;=&lt;/span&gt; build_multilayer_graph_with_custom_cell(cell_type&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;GRU&amp;#39;&lt;/span&gt;, num_steps&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;30&lt;/span&gt;)
t &lt;span class="op"&gt;=&lt;/span&gt; time.time()
train_network(g, &lt;span class="dv"&gt;5&lt;/span&gt;, num_steps&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;30&lt;/span&gt;)
&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;It took&amp;quot;&lt;/span&gt;, time.time() &lt;span class="op"&gt;-&lt;/span&gt; t, &lt;span class="st"&gt;&amp;quot;seconds to train for 5 epochs.&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Average training loss for Epoch 0 : 2.92919953048
Average training loss for Epoch 1 : 2.35888109404
Average training loss for Epoch 2 : 2.21945820894
Average training loss for Epoch 3 : 2.12258511006
Average training loss for Epoch 4 : 2.05038544733
It took 284.6971204280853 seconds to train for 5 epochs.&lt;/code&gt;&lt;/pre&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;g &lt;span class="op"&gt;=&lt;/span&gt; build_multilayer_graph_with_custom_cell(cell_type&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;Custom&amp;#39;&lt;/span&gt;, num_steps&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;30&lt;/span&gt;)
t &lt;span class="op"&gt;=&lt;/span&gt; time.time()
train_network(g, &lt;span class="dv"&gt;5&lt;/span&gt;, num_steps&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;30&lt;/span&gt;)
&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;It took&amp;quot;&lt;/span&gt;, time.time() &lt;span class="op"&gt;-&lt;/span&gt; t, &lt;span class="st"&gt;&amp;quot;seconds to train for 5 epochs.&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Average training loss for Epoch 0 : 3.04418995892
Average training loss for Epoch 1 : 2.5172702761
Average training loss for Epoch 2 : 2.37068433601
Average training loss for Epoch 3 : 2.27533404217
Average training loss for Epoch 4 : 2.20167231745
It took 537.6112766265869 seconds to train for 5 epochs.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So much for that idea. Our custom cell took almost twice as long to train and seems to perform worse than a standard GRU cell.&lt;/p&gt;
&lt;h3 id="adding-dropout"&gt;Adding Dropout&lt;/h3&gt;
&lt;p&gt;Adding features like dropout to the network is easy: we figure out where they belong and drop them in.&lt;/p&gt;
&lt;p&gt;Dropout belongs &lt;em&gt;in between layers, not on the state or in intra-cell connections&lt;/em&gt;. See &lt;a href="https://arxiv.org/pdf/1409.2329.pdf"&gt;Zaremba et al. (2015), Recurrent Neural Network Regularization&lt;/a&gt; (“The main idea is to apply the dropout operator only to the non-recurrent connections.”)&lt;/p&gt;
&lt;p&gt;Thus, to apply dropout, we need to wrap the input and/or output of &lt;em&gt;each&lt;/em&gt; cell. In our RNN implementation using list, we might do something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rnn_inputs = [tf.nn.dropout(rnn_input, keep_prob) for rnn_input in rnn_inputs]
rnn_outputs = [tf.nn.dropout(rnn_output, keep_prob) for nn_output in rnn_outputs]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In our dynamic_rnn or scan implementations, we might apply dropout directly to the rnn_inputs or rnn_outputs:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rnn_inputs = tf.nn.dropout(rnn_inputd, keep_prob)
rnn_outputs = tf.nn.dropout(rnn_outputd, keep_prob)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But what happens when we use &lt;code&gt;MultiRNNCell&lt;/code&gt;? How can we have dropout in between layers like in Zaremba et al. (2015)? The answer is to wrap our base RNN cell with dropout, thereby including it as part of the base cell, similar to how we wrapped our three RNN cells into a single MultiRNNCell above. Tensorflow allows us to do this without writing a new RNNCell by using &lt;code&gt;tf.nn.rnn_cell.DropoutWrapper&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cell = tf.nn.rnn_cell.LSTMCell(state_size, state_is_tuple=True)
cell = tf.nn.rnn_cell.DropoutWrapper(cell, input_keep_prob=input_dropout, output_keep_prob=output_dropout)
cell = tf.nn.rnn_cell.MultiRNNCell([cell] * num_layers, state_is_tuple=True)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that if we wrap a base cell with dropout and then use it to build a MultiRNNCell, both input dropout and output dropout will be applied between layers (so if both are, say, 0.9, the dropout in between layers will be 0.9 * 0.9 = 0.81). If we want equal dropout on all inputs and outputs of a multi-layered RNN, we can use only output or input dropout on the base cell, and then wrap the entire MultiRNNCell with the input or output dropout like so:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cell = tf.nn.rnn_cell.LSTMCell(state_size, state_is_tuple=True)
cell = tf.nn.rnn_cell.DropoutWrapper(cell, input_keep_prob=global_dropout)
cell = tf.nn.rnn_cell.MultiRNNCell([cell] * num_layers, state_is_tuple=True)
cell = tf.nn.rnn_cell.DropoutWrapper(cell, output_keep_prob=global_dropout)&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="layer-normalization"&gt;Layer normalization&lt;/h3&gt;
&lt;p&gt;Layer normalization is a feature that was published just a few days ago by &lt;a href="https://arxiv.org/abs/1607.06450"&gt;Lei Ba et al. (2016)&lt;/a&gt;, which we can use to improve our RNN. It was inspired by batch normalization, which you can read about and learn how to implement in my post &lt;a href="http://r2rt.com/implementing-batch-normalization-in-tensorflow.html"&gt;here&lt;/a&gt;. Batch normalization (for feed-forward and convolutional neural networks) and layer normalization (for recurrent neural networks) generally improve training time and achieve better overall performance. In this section, we’ll apply what we’ve learned in this post to implement layer normalization in Tensorflow.&lt;/p&gt;
&lt;p&gt;Layer normalization is applied as follows: the initial layer normalization function is applied individually to each training example so as to normalize the output vector of a linear transformation to have a mean of 0 and a variance of 1. In math: &lt;span class="math inline"&gt;\(LN_{initial}: v \mapsto \frac{v - \mu_v}{\sqrt{\sigma_v^2 + \epsilon}}\)&lt;/span&gt; for some vector &lt;span class="math inline"&gt;\(v\)&lt;/span&gt; and some small value of &lt;span class="math inline"&gt;\(\epsilon\)&lt;/span&gt; for numerical stability. For some the same reasons we add scale and shift parameters to the initial batch normalization transform (see my &lt;a href="http://r2rt.com/implementing-batch-normalization-in-tensorflow.html"&gt;batch normalization post&lt;/a&gt; for details), we add scale, &lt;span class="math inline"&gt;\(\alpha\)&lt;/span&gt;, and shift, &lt;span class="math inline"&gt;\(\beta\)&lt;/span&gt;, parameters here as well, so that the final layer normalization function is:&lt;/p&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[LN: v \mapsto \alpha \odot \frac{v - \mu_v}{\sqrt{\sigma_v^2 + \epsilon}} + \beta\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Note that &lt;span class="math inline"&gt;\(\odot\)&lt;/span&gt; is point-wise multiplication.&lt;/p&gt;
&lt;p&gt;To add layer normalization to our network, we first write a function that will layer normalization a 2D tensor along its second dimension:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; ln(tensor, scope &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="va"&gt;None&lt;/span&gt;, epsilon &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="fl"&gt;1e-5&lt;/span&gt;):
    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot; Layer normalizes a 2D tensor along its second axis &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="cf"&gt;assert&lt;/span&gt;(&lt;span class="bu"&gt;len&lt;/span&gt;(tensor.get_shape()) &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt;)
    m, v &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.moments(tensor, [&lt;span class="dv"&gt;1&lt;/span&gt;], keep_dims&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)
    &lt;span class="cf"&gt;if&lt;/span&gt; &lt;span class="kw"&gt;not&lt;/span&gt; &lt;span class="bu"&gt;isinstance&lt;/span&gt;(scope, &lt;span class="bu"&gt;str&lt;/span&gt;):
        scope &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;
    &lt;span class="cf"&gt;with&lt;/span&gt; tf.variable_scope(scope &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;layer_norm&amp;#39;&lt;/span&gt;):
        scale &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;scale&amp;#39;&lt;/span&gt;,
                                shape&lt;span class="op"&gt;=&lt;/span&gt;[tensor.get_shape()[&lt;span class="dv"&gt;1&lt;/span&gt;]],
                                initializer&lt;span class="op"&gt;=&lt;/span&gt;tf.constant_initializer(&lt;span class="dv"&gt;1&lt;/span&gt;))
        shift &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;shift&amp;#39;&lt;/span&gt;,
                                shape&lt;span class="op"&gt;=&lt;/span&gt;[tensor.get_shape()[&lt;span class="dv"&gt;1&lt;/span&gt;]],
                                initializer&lt;span class="op"&gt;=&lt;/span&gt;tf.constant_initializer(&lt;span class="dv"&gt;0&lt;/span&gt;))
    LN_initial &lt;span class="op"&gt;=&lt;/span&gt; (tensor &lt;span class="op"&gt;-&lt;/span&gt; m) &lt;span class="op"&gt;/&lt;/span&gt; tf.sqrt(v &lt;span class="op"&gt;+&lt;/span&gt; epsilon)

    &lt;span class="cf"&gt;return&lt;/span&gt; LN_initial &lt;span class="op"&gt;*&lt;/span&gt; scale &lt;span class="op"&gt;+&lt;/span&gt; shift&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let’s apply it our layer normalization function as it was applied by Lei Ba et al. (2016) to LSTMs (in their experiments “Teaching machines to read and comprehend” and “Handwriting sequence generation”). Lei Ba et al. apply layer normalization to the output of each gate &lt;em&gt;inside&lt;/em&gt; the LSTM cell, which means that we get to take a second shot at writing a new type of RNN cell. We’ll start with Tensorflow’s official code, located &lt;a href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/ops/rnn_cell.py"&gt;here&lt;/a&gt;, and modify it accordingly:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;class&lt;/span&gt; LayerNormalizedLSTMCell(tf.nn.rnn_cell.RNNCell):
    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="co"&gt;    Adapted from TF&amp;#39;s BasicLSTMCell to use Layer Normalization.&lt;/span&gt;
&lt;span class="co"&gt;    Note that state_is_tuple is always True.&lt;/span&gt;
&lt;span class="co"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

    &lt;span class="kw"&gt;def&lt;/span&gt; &lt;span class="fu"&gt;__init__&lt;/span&gt;(&lt;span class="va"&gt;self&lt;/span&gt;, num_units, forget_bias&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;1.0&lt;/span&gt;, activation&lt;span class="op"&gt;=&lt;/span&gt;tf.nn.tanh):
        &lt;span class="va"&gt;self&lt;/span&gt;._num_units &lt;span class="op"&gt;=&lt;/span&gt; num_units
        &lt;span class="va"&gt;self&lt;/span&gt;._forget_bias &lt;span class="op"&gt;=&lt;/span&gt; forget_bias
        &lt;span class="va"&gt;self&lt;/span&gt;._activation &lt;span class="op"&gt;=&lt;/span&gt; activation

    &lt;span class="at"&gt;@property&lt;/span&gt;
    &lt;span class="kw"&gt;def&lt;/span&gt; state_size(&lt;span class="va"&gt;self&lt;/span&gt;):
        &lt;span class="cf"&gt;return&lt;/span&gt; tf.nn.rnn_cell.LSTMStateTuple(&lt;span class="va"&gt;self&lt;/span&gt;._num_units, &lt;span class="va"&gt;self&lt;/span&gt;._num_units)

    &lt;span class="at"&gt;@property&lt;/span&gt;
    &lt;span class="kw"&gt;def&lt;/span&gt; output_size(&lt;span class="va"&gt;self&lt;/span&gt;):
        &lt;span class="cf"&gt;return&lt;/span&gt; &lt;span class="va"&gt;self&lt;/span&gt;._num_units

    &lt;span class="kw"&gt;def&lt;/span&gt; &lt;span class="fu"&gt;__call__&lt;/span&gt;(&lt;span class="va"&gt;self&lt;/span&gt;, inputs, state, scope&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;None&lt;/span&gt;):
        &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;Long short-term memory cell (LSTM).&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="cf"&gt;with&lt;/span&gt; tf.variable_scope(scope &lt;span class="kw"&gt;or&lt;/span&gt; &lt;span class="bu"&gt;type&lt;/span&gt;(&lt;span class="va"&gt;self&lt;/span&gt;).&lt;span class="va"&gt;__name__&lt;/span&gt;):
            c, h &lt;span class="op"&gt;=&lt;/span&gt; state

            &lt;span class="co"&gt;# change bias argument to False since LN will add bias via shift&lt;/span&gt;
            concat &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.rnn_cell._linear([inputs, h], &lt;span class="dv"&gt;4&lt;/span&gt; &lt;span class="op"&gt;*&lt;/span&gt; &lt;span class="va"&gt;self&lt;/span&gt;._num_units, &lt;span class="va"&gt;False&lt;/span&gt;)

            i, j, f, o &lt;span class="op"&gt;=&lt;/span&gt; tf.split(&lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="dv"&gt;4&lt;/span&gt;, concat)

            &lt;span class="co"&gt;# add layer normalization to each gate&lt;/span&gt;
            i &lt;span class="op"&gt;=&lt;/span&gt; ln(i, scope &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;i/&amp;#39;&lt;/span&gt;)
            j &lt;span class="op"&gt;=&lt;/span&gt; ln(j, scope &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;j/&amp;#39;&lt;/span&gt;)
            f &lt;span class="op"&gt;=&lt;/span&gt; ln(f, scope &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;f/&amp;#39;&lt;/span&gt;)
            o &lt;span class="op"&gt;=&lt;/span&gt; ln(o, scope &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;o/&amp;#39;&lt;/span&gt;)

            new_c &lt;span class="op"&gt;=&lt;/span&gt; (c &lt;span class="op"&gt;*&lt;/span&gt; tf.nn.sigmoid(f &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="va"&gt;self&lt;/span&gt;._forget_bias) &lt;span class="op"&gt;+&lt;/span&gt; tf.nn.sigmoid(i) &lt;span class="op"&gt;*&lt;/span&gt;
                   &lt;span class="va"&gt;self&lt;/span&gt;._activation(j))

            &lt;span class="co"&gt;# add layer_normalization in calculation of new hidden state&lt;/span&gt;
            new_h &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="va"&gt;self&lt;/span&gt;._activation(ln(new_c, scope &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;new_h/&amp;#39;&lt;/span&gt;)) &lt;span class="op"&gt;*&lt;/span&gt; tf.nn.sigmoid(o)
            new_state &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.rnn_cell.LSTMStateTuple(new_c, new_h)

            &lt;span class="cf"&gt;return&lt;/span&gt; new_h, new_state&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And that’s it! Let’s try this out.&lt;/p&gt;
&lt;h3 id="final-model"&gt;Final model&lt;/h3&gt;
&lt;p&gt;At this point, we’ve covered all of the graph modifications we planned to cover, so here is our final model, which allows for dropout and layer normalized LSTM cells:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; build_graph(
    cell_type &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="va"&gt;None&lt;/span&gt;,
    num_weights_for_custom_cell &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;5&lt;/span&gt;,
    state_size &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;100&lt;/span&gt;,
    num_classes &lt;span class="op"&gt;=&lt;/span&gt; vocab_size,
    batch_size &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;32&lt;/span&gt;,
    num_steps &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;200&lt;/span&gt;,
    num_layers &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;3&lt;/span&gt;,
    build_with_dropout&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;,
    learning_rate &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="fl"&gt;1e-4&lt;/span&gt;):

    reset_graph()

    x &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(tf.int32, [batch_size, num_steps], name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;input_placeholder&amp;#39;&lt;/span&gt;)
    y &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(tf.int32, [batch_size, num_steps], name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;labels_placeholder&amp;#39;&lt;/span&gt;)

    dropout &lt;span class="op"&gt;=&lt;/span&gt; tf.constant(&lt;span class="fl"&gt;1.0&lt;/span&gt;)

    embeddings &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;embedding_matrix&amp;#39;&lt;/span&gt;, [num_classes, state_size])

    rnn_inputs &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.embedding_lookup(embeddings, x)

    &lt;span class="cf"&gt;if&lt;/span&gt; cell_type &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;Custom&amp;#39;&lt;/span&gt;:
        cell &lt;span class="op"&gt;=&lt;/span&gt; CustomCell(state_size, num_weights_for_custom_cell)
    &lt;span class="cf"&gt;elif&lt;/span&gt; cell_type &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;GRU&amp;#39;&lt;/span&gt;:
        cell &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.rnn_cell.GRUCell(state_size)
    &lt;span class="cf"&gt;elif&lt;/span&gt; cell_type &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;LSTM&amp;#39;&lt;/span&gt;:
        cell &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.rnn_cell.LSTMCell(state_size, state_is_tuple&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)
    &lt;span class="cf"&gt;elif&lt;/span&gt; cell_type &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;LN_LSTM&amp;#39;&lt;/span&gt;:
        cell &lt;span class="op"&gt;=&lt;/span&gt; LayerNormalizedLSTMCell(state_size)
    &lt;span class="cf"&gt;else&lt;/span&gt;:
        cell &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.rnn_cell.BasicRNNCell(state_size)

    &lt;span class="cf"&gt;if&lt;/span&gt; build_with_dropout:
        cell &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.rnn_cell.DropoutWrapper(cell, input_keep_prob&lt;span class="op"&gt;=&lt;/span&gt;dropout)

    &lt;span class="cf"&gt;if&lt;/span&gt; cell_type &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;LSTM&amp;#39;&lt;/span&gt; &lt;span class="kw"&gt;or&lt;/span&gt; cell_type &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;LN_LSTM&amp;#39;&lt;/span&gt;:
        cell &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.rnn_cell.MultiRNNCell([cell] &lt;span class="op"&gt;*&lt;/span&gt; num_layers, state_is_tuple&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)
    &lt;span class="cf"&gt;else&lt;/span&gt;:
        cell &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.rnn_cell.MultiRNNCell([cell] &lt;span class="op"&gt;*&lt;/span&gt; num_layers)

    &lt;span class="cf"&gt;if&lt;/span&gt; build_with_dropout:
        cell &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.rnn_cell.DropoutWrapper(cell, output_keep_prob&lt;span class="op"&gt;=&lt;/span&gt;dropout)

    init_state &lt;span class="op"&gt;=&lt;/span&gt; cell.zero_state(batch_size, tf.float32)
    rnn_outputs, final_state &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.dynamic_rnn(cell, rnn_inputs, initial_state&lt;span class="op"&gt;=&lt;/span&gt;init_state)

    &lt;span class="cf"&gt;with&lt;/span&gt; tf.variable_scope(&lt;span class="st"&gt;&amp;#39;softmax&amp;#39;&lt;/span&gt;):
        W &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;W&amp;#39;&lt;/span&gt;, [state_size, num_classes])
        b &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;, [num_classes], initializer&lt;span class="op"&gt;=&lt;/span&gt;tf.constant_initializer(&lt;span class="fl"&gt;0.0&lt;/span&gt;))

    &lt;span class="co"&gt;#reshape rnn_outputs and y&lt;/span&gt;
    rnn_outputs &lt;span class="op"&gt;=&lt;/span&gt; tf.reshape(rnn_outputs, [&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;, state_size])
    y_reshaped &lt;span class="op"&gt;=&lt;/span&gt; tf.reshape(y, [&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;])

    logits &lt;span class="op"&gt;=&lt;/span&gt; tf.matmul(rnn_outputs, W) &lt;span class="op"&gt;+&lt;/span&gt; b

    predictions &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.softmax(logits)

    total_loss &lt;span class="op"&gt;=&lt;/span&gt; tf.reduce_mean(tf.nn.sparse_softmax_cross_entropy_with_logits(logits, y_reshaped))
    train_step &lt;span class="op"&gt;=&lt;/span&gt; tf.train.AdamOptimizer(learning_rate).minimize(total_loss)

    &lt;span class="cf"&gt;return&lt;/span&gt; &lt;span class="bu"&gt;dict&lt;/span&gt;(
        x &lt;span class="op"&gt;=&lt;/span&gt; x,
        y &lt;span class="op"&gt;=&lt;/span&gt; y,
        init_state &lt;span class="op"&gt;=&lt;/span&gt; init_state,
        final_state &lt;span class="op"&gt;=&lt;/span&gt; final_state,
        total_loss &lt;span class="op"&gt;=&lt;/span&gt; total_loss,
        train_step &lt;span class="op"&gt;=&lt;/span&gt; train_step,
        preds &lt;span class="op"&gt;=&lt;/span&gt; predictions,
        saver &lt;span class="op"&gt;=&lt;/span&gt; tf.train.Saver()
    )&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let’s compare the GRU, LSTM and LN_LSTM after training each for 20 epochs using 80 step sequences.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;g &lt;span class="op"&gt;=&lt;/span&gt; build_graph(cell_type&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;GRU&amp;#39;&lt;/span&gt;, num_steps&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;80&lt;/span&gt;)
t &lt;span class="op"&gt;=&lt;/span&gt; time.time()
losses &lt;span class="op"&gt;=&lt;/span&gt; train_network(g, &lt;span class="dv"&gt;20&lt;/span&gt;, num_steps&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;80&lt;/span&gt;, save&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;saves/GRU_20_epochs&amp;quot;&lt;/span&gt;)
&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;It took&amp;quot;&lt;/span&gt;, time.time() &lt;span class="op"&gt;-&lt;/span&gt; t, &lt;span class="st"&gt;&amp;quot;seconds to train for 20 epochs.&amp;quot;&lt;/span&gt;)
&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;The average loss on the final epoch was:&amp;quot;&lt;/span&gt;, losses[&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;It took 1051.6652357578278 seconds to train for 20 epochs.
The average loss on the final epoch was: 1.75318197903&lt;/code&gt;&lt;/pre&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;g &lt;span class="op"&gt;=&lt;/span&gt; build_graph(cell_type&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;LSTM&amp;#39;&lt;/span&gt;, num_steps&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;80&lt;/span&gt;)
t &lt;span class="op"&gt;=&lt;/span&gt; time.time()
losses &lt;span class="op"&gt;=&lt;/span&gt; train_network(g, &lt;span class="dv"&gt;20&lt;/span&gt;, num_steps&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;80&lt;/span&gt;, save&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;saves/LSTM_20_epochs&amp;quot;&lt;/span&gt;)
&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;It took&amp;quot;&lt;/span&gt;, time.time() &lt;span class="op"&gt;-&lt;/span&gt; t, &lt;span class="st"&gt;&amp;quot;seconds to train for 20 epochs.&amp;quot;&lt;/span&gt;)
&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;The average loss on the final epoch was:&amp;quot;&lt;/span&gt;, losses[&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;It took 614.4890048503876 seconds to train for 20 epochs.
The average loss on the final epoch was: 2.02813237837&lt;/code&gt;&lt;/pre&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;g &lt;span class="op"&gt;=&lt;/span&gt; build_graph(cell_type&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;LN_LSTM&amp;#39;&lt;/span&gt;, num_steps&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;80&lt;/span&gt;)
t &lt;span class="op"&gt;=&lt;/span&gt; time.time()
losses &lt;span class="op"&gt;=&lt;/span&gt; train_network(g, &lt;span class="dv"&gt;20&lt;/span&gt;, num_steps&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;80&lt;/span&gt;, save&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;saves/LN_LSTM_20_epochs&amp;quot;&lt;/span&gt;)
&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;It took&amp;quot;&lt;/span&gt;, time.time() &lt;span class="op"&gt;-&lt;/span&gt; t, &lt;span class="st"&gt;&amp;quot;seconds to train for 20 epochs.&amp;quot;&lt;/span&gt;)
&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;The average loss on the final epoch was:&amp;quot;&lt;/span&gt;, losses[&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;It took 3867.550405740738 seconds to train for 20 epochs.
The average loss on the final epoch was: 1.71850851623&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It looks like the layer normalized LSTM just managed to edge out the GRU in the last few epochs, though the increase in training time hardly seems worth it (perhaps my implementation could be improved?). It would be interesting to see how they would perform on a validation or test set and also to try out a layer normalized GRU. For now, let’s use the GRU to generate some text.&lt;/p&gt;
&lt;h3 id="generating-text"&gt;Generating text&lt;/h3&gt;
&lt;p&gt;To generate text, were going to rebuild the graph so as to accept a single character at a time and restore our saved model. We’ll give the network a single character prompt, grab its predicted probability distribution for the next character, use that distribution to pick the next character, and repeat. When picking the next character, our &lt;code&gt;generate_characters&lt;/code&gt; function can be set to use the whole probability distribution (default), or be forced to pick one of the top n most likely characters in the distribution. The latter option should obtain more English-like results.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; generate_characters(g, checkpoint, num_chars, prompt&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;, pick_top_chars&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;None&lt;/span&gt;):
    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot; Accepts a current character, initial state&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

    &lt;span class="cf"&gt;with&lt;/span&gt; tf.Session() &lt;span class="im"&gt;as&lt;/span&gt; sess:
        sess.run(tf.initialize_all_variables())
        g[&lt;span class="st"&gt;&amp;#39;saver&amp;#39;&lt;/span&gt;].restore(sess, checkpoint)

        state &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="va"&gt;None&lt;/span&gt;
        current_char &lt;span class="op"&gt;=&lt;/span&gt; vocab_to_idx[prompt]
        chars &lt;span class="op"&gt;=&lt;/span&gt; [current_char]

        &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(num_chars):
            &lt;span class="cf"&gt;if&lt;/span&gt; state &lt;span class="kw"&gt;is&lt;/span&gt; &lt;span class="kw"&gt;not&lt;/span&gt; &lt;span class="va"&gt;None&lt;/span&gt;:
                feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{g[&lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;]: [[current_char]], g[&lt;span class="st"&gt;&amp;#39;init_state&amp;#39;&lt;/span&gt;]: state}
            &lt;span class="cf"&gt;else&lt;/span&gt;:
                feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{g[&lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;]: [[current_char]]}

            preds, state &lt;span class="op"&gt;=&lt;/span&gt; sess.run([g[&lt;span class="st"&gt;&amp;#39;preds&amp;#39;&lt;/span&gt;],g[&lt;span class="st"&gt;&amp;#39;final_state&amp;#39;&lt;/span&gt;]], feed_dict)

            &lt;span class="cf"&gt;if&lt;/span&gt; pick_top_chars &lt;span class="kw"&gt;is&lt;/span&gt; &lt;span class="kw"&gt;not&lt;/span&gt; &lt;span class="va"&gt;None&lt;/span&gt;:
                p &lt;span class="op"&gt;=&lt;/span&gt; np.squeeze(preds)
                p[np.argsort(p)[:&lt;span class="op"&gt;-&lt;/span&gt;pick_top_chars]] &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;
                p &lt;span class="op"&gt;=&lt;/span&gt; p &lt;span class="op"&gt;/&lt;/span&gt; np.&lt;span class="bu"&gt;sum&lt;/span&gt;(p)
                current_char &lt;span class="op"&gt;=&lt;/span&gt; np.random.choice(vocab_size, &lt;span class="dv"&gt;1&lt;/span&gt;, p&lt;span class="op"&gt;=&lt;/span&gt;p)[&lt;span class="dv"&gt;0&lt;/span&gt;]
            &lt;span class="cf"&gt;else&lt;/span&gt;:
                current_char &lt;span class="op"&gt;=&lt;/span&gt; np.random.choice(vocab_size, &lt;span class="dv"&gt;1&lt;/span&gt;, p&lt;span class="op"&gt;=&lt;/span&gt;np.squeeze(preds))[&lt;span class="dv"&gt;0&lt;/span&gt;]

            chars.append(current_char)

    chars &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;map&lt;/span&gt;(&lt;span class="kw"&gt;lambda&lt;/span&gt; x: idx_to_vocab[x], chars)
    &lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;&amp;quot;&lt;/span&gt;.join(chars))
    &lt;span class="cf"&gt;return&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;&amp;quot;&lt;/span&gt;.join(chars))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;g &lt;span class="op"&gt;=&lt;/span&gt; build_graph(cell_type&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;LN_LSTM&amp;#39;&lt;/span&gt;, num_steps&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;, batch_size&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;)
generate_characters(g, &lt;span class="st"&gt;&amp;quot;saves/LN_LSTM_20_epochs&amp;quot;&lt;/span&gt;, &lt;span class="dv"&gt;750&lt;/span&gt;, prompt&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;, pick_top_chars&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;5&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;ATOOOS

 UIEAOUYOUZZZZZZUZAAAYAYf n fsflflrurctuateot t ta&amp;#39;s  a  wtutss ESGNANO:
Whith then, a do makes and them and to sees,
I wark on this ance may string take thou honon
To sorriccorn of the bairer, whither, all
I&amp;#39;d see if yiust the would a peid.

LARYNGLe:
To would she troust they fould.

PENMES:
Thou she so the havin to my shald woust of
As tale we they all my forder have
As to say heant thy wansing thag and
Whis it thee shath his breact, I be and might, she
Tirs you desarvishensed and see thee: shall,
What he hath with that is all time,
And sen the have would be sectiens, way thee,
They are there to man shall with me to the mon,
And mere fear would be the balte, as time an at
And the say oun touth, thy way womers thee.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can see that this network has learned something. It’s definitely not random, though there is a bit of a warm up at the beginning (the state starts at 0). I was expecting something a bit better, however, given &lt;a href="http://karpathy.github.io/2015/05/21/rnn-effectiveness/#shakespeare"&gt;Karpathy’s Shakespeare results&lt;/a&gt;. His model used more data, a state_size of 512, and was trained quite a bit longer than this one. Let’s see if we can match that. I couldn’t find a suitable premade dataset, so I had to make one myself: I concatenated the scripts from the Star Wars movies, the Star Trek movies, Tarantino and the Matrix. The final file size is 3.3MB, which is a bit smaller than the full works of William Shakespeare. Let’s load these up and try this again, with a larger state size:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="co"&gt;Load new data&lt;/span&gt;
&lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

file_url &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;https://gist.githubusercontent.com/spitis/59bfafe6966bfe60cc206ffbb760269f/&amp;#39;&lt;/span&gt;&lt;span class="op"&gt;+\&lt;/span&gt;
&lt;span class="co"&gt;&amp;#39;raw/030a08754aada17cef14eed6fac7797cda830fe8/variousscripts.txt&amp;#39;&lt;/span&gt;
file_name &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;variousscripts.txt&amp;#39;&lt;/span&gt;
&lt;span class="cf"&gt;if&lt;/span&gt; &lt;span class="kw"&gt;not&lt;/span&gt; os.path.exists(file_name):
    urllib.request.urlretrieve(file_url, file_name)

&lt;span class="cf"&gt;with&lt;/span&gt; &lt;span class="bu"&gt;open&lt;/span&gt;(file_name,&lt;span class="st"&gt;&amp;#39;r&amp;#39;&lt;/span&gt;) &lt;span class="im"&gt;as&lt;/span&gt; f:
    raw_data &lt;span class="op"&gt;=&lt;/span&gt; f.read()
    &lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;Data length:&amp;quot;&lt;/span&gt;, &lt;span class="bu"&gt;len&lt;/span&gt;(raw_data))

vocab &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;set&lt;/span&gt;(raw_data)
vocab_size &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;len&lt;/span&gt;(vocab)
idx_to_vocab &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;dict&lt;/span&gt;(&lt;span class="bu"&gt;enumerate&lt;/span&gt;(vocab))
vocab_to_idx &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;dict&lt;/span&gt;(&lt;span class="bu"&gt;zip&lt;/span&gt;(idx_to_vocab.values(), idx_to_vocab.keys()))

data &lt;span class="op"&gt;=&lt;/span&gt; [vocab_to_idx[c] &lt;span class="cf"&gt;for&lt;/span&gt; c &lt;span class="kw"&gt;in&lt;/span&gt; raw_data]
&lt;span class="kw"&gt;del&lt;/span&gt; raw_data&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Data length: 3299132&lt;/code&gt;&lt;/pre&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;g &lt;span class="op"&gt;=&lt;/span&gt; build_graph(cell_type&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;GRU&amp;#39;&lt;/span&gt;,
                num_steps&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;80&lt;/span&gt;,
                state_size &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;512&lt;/span&gt;,
                batch_size &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;50&lt;/span&gt;,
                num_classes&lt;span class="op"&gt;=&lt;/span&gt;vocab_size,
                learning_rate&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;5e-4&lt;/span&gt;)
t &lt;span class="op"&gt;=&lt;/span&gt; time.time()
losses &lt;span class="op"&gt;=&lt;/span&gt; train_network(g, &lt;span class="dv"&gt;30&lt;/span&gt;, num_steps&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;80&lt;/span&gt;, batch_size &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;50&lt;/span&gt;, save&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;saves/GRU_30_epochs_variousscripts&amp;quot;&lt;/span&gt;)
&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;It took&amp;quot;&lt;/span&gt;, time.time() &lt;span class="op"&gt;-&lt;/span&gt; t, &lt;span class="st"&gt;&amp;quot;seconds to train for 30 epochs.&amp;quot;&lt;/span&gt;)
&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;The average loss on the final epoch was:&amp;quot;&lt;/span&gt;, losses[&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;It took 4877.8002140522 seconds to train for 30 epochs.
The average loss on the final epoch was: 0.726858645461&lt;/code&gt;&lt;/pre&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;g &lt;span class="op"&gt;=&lt;/span&gt; build_graph(cell_type&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;GRU&amp;#39;&lt;/span&gt;, num_steps&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;, batch_size&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;, num_classes&lt;span class="op"&gt;=&lt;/span&gt;vocab_size, state_size &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;512&lt;/span&gt;)
generate_characters(g, &lt;span class="st"&gt;&amp;quot;saves/GRU_30_epochs_variousscripts&amp;quot;&lt;/span&gt;, &lt;span class="dv"&gt;750&lt;/span&gt;, prompt&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;D&amp;#39;&lt;/span&gt;, pick_top_chars&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;5&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;DENT&amp;#39;SUEENCK

Bartholomew of the TIE FIGHTERS are stunned. There is a crowd and armored
switcheroos.

PICARD
(continuing)
Couns two dim is tired. In order to the sentence...

The sub    bottle appears on the screen into a small shuttle shift of the
ceiling. The DAMBA FETT splash fires and matches them into the top, transmit to stable high above upon their statels,
falling from an alien shaft.

ANAKIN and OBI-WAN stand next to OBI-WAN down the control plate of smoke at the TIE fighter. They stare at the centre of the station loose into a comlink cover -- comes up to the General, the GENERAL HUNTAN AND FINNFURMBARD from the PICADOR to a beautiful Podracisly.

ENGINEER
Naboo from an army seventy medical
security team area re-weilergular.

EXT.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Not sure these are that much better than before, but it’s sort of readable?&lt;/p&gt;
&lt;h3 id="conclusion"&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;In this post, we used a character sequence generation task to learn how to use Tensorflow’s scan and dynamic_rnn functions, how to use advanced RNN cells and stack multiple RNNs, and how to add features to our RNN like dropout and layer normalization. In the next post, we will use a machine translation task to look at handling variable length sequences and building RNN encoders and decoders.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</content></entry><entry><title>Styles of Truncated Backpropagation</title><link href="https://r2rt.com/styles-of-truncated-backpropagation.html" rel="alternate"></link><published>2016-07-19T00:00:00-04:00</published><updated>2016-07-19T00:00:00-04:00</updated><author><name>Silviu Pitis</name></author><id>tag:r2rt.com,2016-07-19:/styles-of-truncated-backpropagation.html</id><summary type="html">In my post on Recurrent Neural Networks in Tensorflow, I observed that Tensorflow's approach to truncated backpropagation (feeding in truncated subsequences of length n) is qualitatively different than "backpropagating errors a maximum of n steps". In this post, I explore the differences, and ask whether one approach is better than the other.</summary><content type="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;meta name="generator" content="pandoc"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes"&gt;
  &lt;title&gt;&lt;/title&gt;
  &lt;style type="text/css"&gt;code{white-space: pre;}&lt;/style&gt;
  &lt;style type="text/css"&gt;
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code &gt; span.kw { color: #007020; font-weight: bold; } /* Keyword */
code &gt; span.dt { color: #902000; } /* DataType */
code &gt; span.dv { color: #40a070; } /* DecVal */
code &gt; span.bn { color: #40a070; } /* BaseN */
code &gt; span.fl { color: #40a070; } /* Float */
code &gt; span.ch { color: #4070a0; } /* Char */
code &gt; span.st { color: #4070a0; } /* String */
code &gt; span.co { color: #60a0b0; font-style: italic; } /* Comment */
code &gt; span.ot { color: #007020; } /* Other */
code &gt; span.al { color: #ff0000; font-weight: bold; } /* Alert */
code &gt; span.fu { color: #06287e; } /* Function */
code &gt; span.er { color: #ff0000; font-weight: bold; } /* Error */
code &gt; span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code &gt; span.cn { color: #880000; } /* Constant */
code &gt; span.sc { color: #4070a0; } /* SpecialChar */
code &gt; span.vs { color: #4070a0; } /* VerbatimString */
code &gt; span.ss { color: #bb6688; } /* SpecialString */
code &gt; span.im { } /* Import */
code &gt; span.va { color: #19177c; } /* Variable */
code &gt; span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code &gt; span.op { color: #666666; } /* Operator */
code &gt; span.bu { } /* BuiltIn */
code &gt; span.ex { } /* Extension */
code &gt; span.pp { color: #bc7a00; } /* Preprocessor */
code &gt; span.at { color: #7d9029; } /* Attribute */
code &gt; span.do { color: #ba2121; font-style: italic; } /* Documentation */
code &gt; span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code &gt; span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code &gt; span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  &lt;/style&gt;
  &lt;!--[if lt IE 9]&gt;
    &lt;script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"&gt;&lt;/script&gt;
  &lt;![endif]--&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;In my post on &lt;a href="https://r2rt.com/recurrent-neural-networks-in-tensorflow-i.html"&gt;Recurrent Neural Networks in Tensorflow&lt;/a&gt;, I observed that Tensorflow’s approach to truncated backpropagation (feeding in truncated subsequences of length n) is qualitatively different than “backpropagating errors a maximum of n steps”. In this post, I explore the differences, implement a truncated backpropagation algorithm in Tensorflow that maintains the distribution between backpropagated errors, and ask whether one approach is better than the other.&lt;/p&gt;
&lt;p&gt;I conclude that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Because a well-implemented evenly-distributed truncated backpropagation algorithm would run about as fast as full backpropagation over the sequence, and full backpropagation performs slightly better, it is most likely not worth implementing such an algorithm.&lt;/li&gt;
&lt;li&gt;The discussion and preliminary experiments in this post show that n-step Tensorflow-style truncated backprop (i.e., with num_steps = n) does not effectively backpropagate errors the full n-steps. Thus, if you are using Tensorflow-style truncated backpropagation and need to capture n-step dependencies, you may benefit from using a num_steps that is appreciably higher than n in order to effectively backpropagate errors the desired n steps.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="differences-in-styles-of-truncated-backpropagation"&gt;Differences in styles of truncated backpropagation&lt;/h3&gt;
&lt;p&gt;Suppose we are training an RNN on sequences of length 10,000. If we apply non-truncated backpropagation through time, the entire sequence is fed into the network at once, the error at time step 10,000 will be back propagated all the way back to time step 1. The two problems with this are that it is (1) expensive to backpropagate the error so many steps, and (2) due to vanishing gradients, backpropagated errors get smaller and smaller layer by layer, which makes further backpropagation insignificant.&lt;/p&gt;
&lt;p&gt;To deal with this, we might implement “truncated” backpropagation. A good description of truncated backpropagation is provided in Section 2.8.6 of &lt;a href="http://www.cs.utoronto.ca/~ilya/pubs/ilya_sutskever_phd_thesis.pdf"&gt;Ilya Sutskever’s Ph.D. thesis&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“[Truncated backpropagation] processes the sequence one timestep at a time, and every k1 timesteps, it runs BPTT for k2 timesteps…”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Tensorflow-style truncated backpropagation uses k1 = k2 (= num_steps). See &lt;a href="https://www.tensorflow.org/versions/r0.9/tutorials/recurrent/index.html#truncated-backpropagation"&gt;Tensorflow api docs&lt;/a&gt;. The question this post addresses is whether setting k1 = 1 achieves better results. I will deem this “true” truncated backpropagation, since every error that can be backpropagated k2 steps is backpropagated the full k2 steps.&lt;/p&gt;
&lt;p&gt;To understand why these two approaches are qualitatively different, consider how they differ on sequences of length 49 with backpropagation of errors truncated to 7 steps. In both, every error is backpropagated to the weights at the current timestep. However, in Tensorflow-style truncated backpropagation, the sequence is broken into 7 subsequences, each of length 7, and only 7 over the errors are backpropagated 7 steps. In “true” truncated backpropagation, 42 of the errors can be backpropagated for 7 steps, and 42 are. This may lead to different results because the ratio of 7-step to 1-step errors used to update the weights is significantly different.&lt;/p&gt;
&lt;p&gt;To visualize the difference, here is how true truncated backpropagation looks on a sequence of length 6 with errors truncated to 3 steps:&lt;/p&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/RNN_true_truncated_backprop.png" alt="Diagram of True Truncated Backpropagation" /&gt;&lt;figcaption&gt;Diagram of True Truncated Backpropagation&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;And here is how Tensorflow-style truncated backpropagation looks on the same sequence:&lt;/p&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/RNN_tf_truncated_backprop.png" alt="Diagram of Tensorflow Truncated Backpropagation" /&gt;&lt;figcaption&gt;Diagram of Tensorflow Truncated Backpropagation&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h3 id="experiment-design"&gt;Experiment design&lt;/h3&gt;
&lt;p&gt;To compare the performance of the two algorithms, I write implement a “true” truncated backpropagation algorithm and compare results. The algorithms are compared on a vanilla-RNN, based on the one used in my prior post, &lt;a href="https://r2rt.com/recurrent-neural-networks-in-tensorflow-i.html"&gt;Recurrent Neural Networks in Tensorflow I&lt;/a&gt;, except that I upgrade the task and model complexity, since the basic model from my prior post learned the simple patterns in the toy dataset very quickly. The task will be language modeling on the ptb dataset, and to match the increased complexity of this task, I add an embedding layer and dropout to the basic RNN model.&lt;/p&gt;
&lt;p&gt;I compare the best performance of each algorithm on the validation set after 20 epochs for the cases below. In each case, I use an AdamOptimizer (it does better than other optimizers in preliminary tests) and learning rates of 0.003, 0.001 and 0.0003.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;5-step truncated backpropagation&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;True, sequences of length 20&lt;/li&gt;
&lt;li&gt;TF-style&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;10-step truncated backpropagation&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;True, sequences of length 30&lt;/li&gt;
&lt;li&gt;TF-style&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;20-step truncated backpropagation&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;True, sequences of length 40&lt;/li&gt;
&lt;li&gt;TF-style&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;40-step truncated backpropagation&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TF-style&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="code"&gt;Code&lt;/h3&gt;
&lt;h4 id="imports-and-data-generators"&gt;Imports and data generators&lt;/h4&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="im"&gt;import&lt;/span&gt; numpy &lt;span class="im"&gt;as&lt;/span&gt; np
&lt;span class="im"&gt;import&lt;/span&gt; tensorflow &lt;span class="im"&gt;as&lt;/span&gt; tf
&lt;span class="op"&gt;%&lt;/span&gt;matplotlib inline
&lt;span class="im"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class="im"&gt;as&lt;/span&gt; plt
&lt;span class="im"&gt;from&lt;/span&gt; tensorflow.models.rnn.ptb &lt;span class="im"&gt;import&lt;/span&gt; reader

&lt;span class="co"&gt;#data from http://www.fit.vutbr.cz/~imikolov/rnnlm/simple-examples.tgz&lt;/span&gt;
raw_data &lt;span class="op"&gt;=&lt;/span&gt; reader.ptb_raw_data(&lt;span class="st"&gt;&amp;#39;ptb_data&amp;#39;&lt;/span&gt;)
train_data, val_data, test_data, num_classes &lt;span class="op"&gt;=&lt;/span&gt; raw_data

&lt;span class="kw"&gt;def&lt;/span&gt; gen_epochs(n, num_steps, batch_size):
    &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(n):
        &lt;span class="cf"&gt;yield&lt;/span&gt; reader.ptb_iterator(train_data, batch_size, num_steps)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="model"&gt;Model&lt;/h4&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; build_graph(num_steps,
            bptt_steps &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;4&lt;/span&gt;, batch_size &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;200&lt;/span&gt;, num_classes &lt;span class="op"&gt;=&lt;/span&gt; num_classes,
            state_size &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;4&lt;/span&gt;, embed_size &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;50&lt;/span&gt;, learning_rate &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="fl"&gt;0.01&lt;/span&gt;):
    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="co"&gt;    Builds graph for a simple RNN&lt;/span&gt;

&lt;span class="co"&gt;    Notable parameters:&lt;/span&gt;
&lt;span class="co"&gt;    num_steps: sequence length / steps for TF-style truncated backprop&lt;/span&gt;
&lt;span class="co"&gt;    bptt_steps: number of steps for true truncated backprop&lt;/span&gt;
&lt;span class="co"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

    g &lt;span class="op"&gt;=&lt;/span&gt; tf.get_default_graph()

    &lt;span class="co"&gt;# placeholders&lt;/span&gt;
    x &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(tf.int32, [batch_size, &lt;span class="va"&gt;None&lt;/span&gt;], name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;input_placeholder&amp;#39;&lt;/span&gt;)
    y &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(tf.int32, [batch_size, &lt;span class="va"&gt;None&lt;/span&gt;], name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;labels_placeholder&amp;#39;&lt;/span&gt;)
    default_init_state &lt;span class="op"&gt;=&lt;/span&gt; tf.zeros([batch_size, state_size])
    init_state &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder_with_default(default_init_state,
                                             [batch_size, state_size], name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;state_placeholder&amp;#39;&lt;/span&gt;)
    dropout &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(tf.float32, [], name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;dropout_placeholder&amp;#39;&lt;/span&gt;)

    x_one_hot &lt;span class="op"&gt;=&lt;/span&gt; tf.one_hot(x, num_classes)
    x_as_list &lt;span class="op"&gt;=&lt;/span&gt; [tf.squeeze(i, squeeze_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;1&lt;/span&gt;]) &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; tf.split(&lt;span class="dv"&gt;1&lt;/span&gt;, num_steps, x_one_hot)]

    &lt;span class="cf"&gt;with&lt;/span&gt; tf.variable_scope(&lt;span class="st"&gt;&amp;#39;embeddings&amp;#39;&lt;/span&gt;):
        embeddings &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;embedding_matrix&amp;#39;&lt;/span&gt;, [num_classes, embed_size])

    &lt;span class="kw"&gt;def&lt;/span&gt; embedding_lookup(one_hot_input):
        &lt;span class="cf"&gt;with&lt;/span&gt; tf.variable_scope(&lt;span class="st"&gt;&amp;#39;embeddings&amp;#39;&lt;/span&gt;, reuse&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;):
            embeddings &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;embedding_matrix&amp;#39;&lt;/span&gt;, [num_classes, embed_size])
            embeddings &lt;span class="op"&gt;=&lt;/span&gt; tf.identity(embeddings)
            g.add_to_collection(&lt;span class="st"&gt;&amp;#39;embeddings&amp;#39;&lt;/span&gt;, embeddings)
            &lt;span class="cf"&gt;return&lt;/span&gt; tf.matmul(one_hot_input, embeddings)

    rnn_inputs &lt;span class="op"&gt;=&lt;/span&gt; [embedding_lookup(i) &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; x_as_list]

    &lt;span class="co"&gt;#apply dropout to inputs&lt;/span&gt;
    rnn_inputs &lt;span class="op"&gt;=&lt;/span&gt; [tf.nn.dropout(x, dropout) &lt;span class="cf"&gt;for&lt;/span&gt; x &lt;span class="kw"&gt;in&lt;/span&gt; rnn_inputs]

    &lt;span class="co"&gt;# rnn_cells&lt;/span&gt;
    &lt;span class="cf"&gt;with&lt;/span&gt; tf.variable_scope(&lt;span class="st"&gt;&amp;#39;rnn_cell&amp;#39;&lt;/span&gt;):
        W &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;W&amp;#39;&lt;/span&gt;, [embed_size &lt;span class="op"&gt;+&lt;/span&gt; state_size, state_size])
        b &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;, [state_size], initializer&lt;span class="op"&gt;=&lt;/span&gt;tf.constant_initializer(&lt;span class="fl"&gt;0.0&lt;/span&gt;))

    &lt;span class="kw"&gt;def&lt;/span&gt; rnn_cell(rnn_input, state):
        &lt;span class="cf"&gt;with&lt;/span&gt; tf.variable_scope(&lt;span class="st"&gt;&amp;#39;rnn_cell&amp;#39;&lt;/span&gt;, reuse&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;):

            W &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;W&amp;#39;&lt;/span&gt;, [embed_size &lt;span class="op"&gt;+&lt;/span&gt; state_size, state_size])
            W &lt;span class="op"&gt;=&lt;/span&gt; tf.identity(W)
            g.add_to_collection(&lt;span class="st"&gt;&amp;#39;Ws&amp;#39;&lt;/span&gt;, W)

            b &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;, [state_size], initializer&lt;span class="op"&gt;=&lt;/span&gt;tf.constant_initializer(&lt;span class="fl"&gt;0.0&lt;/span&gt;))
            b &lt;span class="op"&gt;=&lt;/span&gt; tf.identity(b)
            g.add_to_collection(&lt;span class="st"&gt;&amp;#39;bs&amp;#39;&lt;/span&gt;, b)

            &lt;span class="cf"&gt;return&lt;/span&gt; tf.tanh(tf.matmul(tf.concat(&lt;span class="dv"&gt;1&lt;/span&gt;, [rnn_input, state]), W) &lt;span class="op"&gt;+&lt;/span&gt; b)

    state &lt;span class="op"&gt;=&lt;/span&gt; init_state
    rnn_outputs &lt;span class="op"&gt;=&lt;/span&gt; []
    &lt;span class="cf"&gt;for&lt;/span&gt; rnn_input &lt;span class="kw"&gt;in&lt;/span&gt; rnn_inputs:
        state &lt;span class="op"&gt;=&lt;/span&gt; rnn_cell(rnn_input, state)
        rnn_outputs.append(state)

    &lt;span class="co"&gt;#apply dropout to outputs&lt;/span&gt;
    rnn_outputs &lt;span class="op"&gt;=&lt;/span&gt; [tf.nn.dropout(x, dropout) &lt;span class="cf"&gt;for&lt;/span&gt; x &lt;span class="kw"&gt;in&lt;/span&gt; rnn_outputs]

    final_state &lt;span class="op"&gt;=&lt;/span&gt; rnn_outputs[&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;]

    &lt;span class="co"&gt;#logits and predictions&lt;/span&gt;
    &lt;span class="cf"&gt;with&lt;/span&gt; tf.variable_scope(&lt;span class="st"&gt;&amp;#39;softmax&amp;#39;&lt;/span&gt;):
        W &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;W_softmax&amp;#39;&lt;/span&gt;, [state_size, num_classes])
        b &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;b_softmax&amp;#39;&lt;/span&gt;, [num_classes], initializer&lt;span class="op"&gt;=&lt;/span&gt;tf.constant_initializer(&lt;span class="fl"&gt;0.0&lt;/span&gt;))
    logits &lt;span class="op"&gt;=&lt;/span&gt; [tf.matmul(rnn_output, W) &lt;span class="op"&gt;+&lt;/span&gt; b &lt;span class="cf"&gt;for&lt;/span&gt; rnn_output &lt;span class="kw"&gt;in&lt;/span&gt; rnn_outputs]
    predictions &lt;span class="op"&gt;=&lt;/span&gt; [tf.nn.softmax(logit) &lt;span class="cf"&gt;for&lt;/span&gt; logit &lt;span class="kw"&gt;in&lt;/span&gt; logits]

    &lt;span class="co"&gt;#losses&lt;/span&gt;
    y_as_list &lt;span class="op"&gt;=&lt;/span&gt; [tf.squeeze(i, squeeze_dims&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;1&lt;/span&gt;]) &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; tf.split(&lt;span class="dv"&gt;1&lt;/span&gt;, num_steps, y)]
    losses &lt;span class="op"&gt;=&lt;/span&gt; [tf.nn.sparse_softmax_cross_entropy_with_logits(logit,label) &lt;span class="op"&gt;\&lt;/span&gt;
              &lt;span class="cf"&gt;for&lt;/span&gt; logit, label &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;zip&lt;/span&gt;(logits, y_as_list)]
    total_loss &lt;span class="op"&gt;=&lt;/span&gt; tf.reduce_mean(losses)

    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="co"&gt;    Implementation of true truncated backprop using TF&amp;#39;s high-level gradients function.&lt;/span&gt;

&lt;span class="co"&gt;    Because I add gradient-ops for each error, this are a number of duplicate operations,&lt;/span&gt;
&lt;span class="co"&gt;    making this a slow implementation. It would be considerably more effort to write an&lt;/span&gt;
&lt;span class="co"&gt;    efficient implementation, however, so for testing purposes, it&amp;#39;s OK that this goes slow.&lt;/span&gt;

&lt;span class="co"&gt;    An efficient implementation would still require all of the same operations as the full&lt;/span&gt;
&lt;span class="co"&gt;    backpropagation through time of errors in a sequence, and so any advantage would not come&lt;/span&gt;
&lt;span class="co"&gt;    from speed, but from having a better distribution of backpropagated errors.&lt;/span&gt;
&lt;span class="co"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

    embed_by_step &lt;span class="op"&gt;=&lt;/span&gt; g.get_collection(&lt;span class="st"&gt;&amp;#39;embeddings&amp;#39;&lt;/span&gt;)
    Ws_by_step &lt;span class="op"&gt;=&lt;/span&gt; g.get_collection(&lt;span class="st"&gt;&amp;#39;Ws&amp;#39;&lt;/span&gt;)
    bs_by_step &lt;span class="op"&gt;=&lt;/span&gt; g.get_collection(&lt;span class="st"&gt;&amp;#39;bs&amp;#39;&lt;/span&gt;)

    &lt;span class="co"&gt;# Collect gradients for each step in a list&lt;/span&gt;
    embed_grads &lt;span class="op"&gt;=&lt;/span&gt; []
    W_grads &lt;span class="op"&gt;=&lt;/span&gt; []
    b_grads &lt;span class="op"&gt;=&lt;/span&gt; []

    &lt;span class="co"&gt;# Keeping track of vanishing gradients for my own curiousity&lt;/span&gt;
    vanishing_grad_list &lt;span class="op"&gt;=&lt;/span&gt; []

    &lt;span class="co"&gt;# Loop through the errors, and backpropagate them to the relevant nodes&lt;/span&gt;
    &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(num_steps):
        start &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;max&lt;/span&gt;(&lt;span class="dv"&gt;0&lt;/span&gt;,i&lt;span class="op"&gt;+&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="op"&gt;-&lt;/span&gt;bptt_steps)
        stop &lt;span class="op"&gt;=&lt;/span&gt; i&lt;span class="op"&gt;+&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;
        grad_list &lt;span class="op"&gt;=&lt;/span&gt; tf.gradients(losses[i],
                                 embed_by_step[start:stop] &lt;span class="op"&gt;+\&lt;/span&gt;
                                 Ws_by_step[start:stop] &lt;span class="op"&gt;+\&lt;/span&gt;
                                 bs_by_step[start:stop])
        embed_grads &lt;span class="op"&gt;+=&lt;/span&gt; grad_list[&lt;span class="dv"&gt;0&lt;/span&gt; : stop &lt;span class="op"&gt;-&lt;/span&gt; start]
        W_grads &lt;span class="op"&gt;+=&lt;/span&gt; grad_list[stop &lt;span class="op"&gt;-&lt;/span&gt; start : &lt;span class="dv"&gt;2&lt;/span&gt; &lt;span class="op"&gt;*&lt;/span&gt; (stop &lt;span class="op"&gt;-&lt;/span&gt; start)]
        b_grads &lt;span class="op"&gt;+=&lt;/span&gt; grad_list[&lt;span class="dv"&gt;2&lt;/span&gt; &lt;span class="op"&gt;*&lt;/span&gt; (stop &lt;span class="op"&gt;-&lt;/span&gt; start) : ]

        &lt;span class="cf"&gt;if&lt;/span&gt; i &lt;span class="op"&gt;&amp;gt;=&lt;/span&gt; bptt_steps:
            vanishing_grad_list.append(grad_list[stop &lt;span class="op"&gt;-&lt;/span&gt; start : &lt;span class="dv"&gt;2&lt;/span&gt; &lt;span class="op"&gt;*&lt;/span&gt; (stop &lt;span class="op"&gt;-&lt;/span&gt; start)])

    grad_embed &lt;span class="op"&gt;=&lt;/span&gt; tf.add_n(embed_grads) &lt;span class="op"&gt;/&lt;/span&gt; (batch_size &lt;span class="op"&gt;*&lt;/span&gt; bptt_steps)
    grad_W &lt;span class="op"&gt;=&lt;/span&gt; tf.add_n(W_grads) &lt;span class="op"&gt;/&lt;/span&gt; (batch_size &lt;span class="op"&gt;*&lt;/span&gt; bptt_steps)
    grad_b &lt;span class="op"&gt;=&lt;/span&gt; tf.add_n(b_grads) &lt;span class="op"&gt;/&lt;/span&gt; (batch_size &lt;span class="op"&gt;*&lt;/span&gt; bptt_steps)

    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="co"&gt;    Training steps&lt;/span&gt;
&lt;span class="co"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

    opt &lt;span class="op"&gt;=&lt;/span&gt; tf.train.AdamOptimizer(learning_rate)
    grads_and_vars_tf_style &lt;span class="op"&gt;=&lt;/span&gt; opt.compute_gradients(total_loss, tf.trainable_variables())
    grads_and_vars_true_bptt &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="op"&gt;\&lt;/span&gt;
        [(grad_embed, tf.trainable_variables()[&lt;span class="dv"&gt;0&lt;/span&gt;]),
         (grad_W, tf.trainable_variables()[&lt;span class="dv"&gt;1&lt;/span&gt;]),
         (grad_b, tf.trainable_variables()[&lt;span class="dv"&gt;2&lt;/span&gt;])] &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="op"&gt;\&lt;/span&gt;
        opt.compute_gradients(total_loss, tf.trainable_variables()[&lt;span class="dv"&gt;3&lt;/span&gt;:])
    train_tf_style &lt;span class="op"&gt;=&lt;/span&gt; opt.apply_gradients(grads_and_vars_tf_style)
    train_true_bptt &lt;span class="op"&gt;=&lt;/span&gt; opt.apply_gradients(grads_and_vars_true_bptt)

    &lt;span class="cf"&gt;return&lt;/span&gt; &lt;span class="bu"&gt;dict&lt;/span&gt;(
        train_tf_style &lt;span class="op"&gt;=&lt;/span&gt; train_tf_style,
        train_true_bptt &lt;span class="op"&gt;=&lt;/span&gt; train_true_bptt,
        gvs_tf_style &lt;span class="op"&gt;=&lt;/span&gt; grads_and_vars_tf_style,
        gvs_true_bptt &lt;span class="op"&gt;=&lt;/span&gt; grads_and_vars_true_bptt,
        gvs_gradient_check &lt;span class="op"&gt;=&lt;/span&gt; opt.compute_gradients(losses[&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;], tf.trainable_variables()),
        loss &lt;span class="op"&gt;=&lt;/span&gt; total_loss,
        final_state &lt;span class="op"&gt;=&lt;/span&gt; final_state,
        x&lt;span class="op"&gt;=&lt;/span&gt;x,
        y&lt;span class="op"&gt;=&lt;/span&gt;y,
        init_state&lt;span class="op"&gt;=&lt;/span&gt;init_state,
        dropout&lt;span class="op"&gt;=&lt;/span&gt;dropout,
        vanishing_grads&lt;span class="op"&gt;=&lt;/span&gt;vanishing_grad_list
    )&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; reset_graph():
    &lt;span class="cf"&gt;if&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;sess&amp;#39;&lt;/span&gt; &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;globals&lt;/span&gt;() &lt;span class="kw"&gt;and&lt;/span&gt; sess:
        sess.close()
    tf.reset_default_graph()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="some-quick-tests"&gt;Some quick tests&lt;/h3&gt;
&lt;h4 id="timing-test"&gt;Timing test&lt;/h4&gt;
&lt;p&gt;As expected, my implementation of true BPTT is slow as there are duplicate operations being performed. An efficient implementation would run at roughly the same speed as the full backpropagation.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;reset_graph()
g &lt;span class="op"&gt;=&lt;/span&gt; build_graph(num_steps &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;40&lt;/span&gt;, bptt_steps &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;20&lt;/span&gt;)
sess &lt;span class="op"&gt;=&lt;/span&gt; tf.InteractiveSession()
sess.run(tf.initialize_all_variables())

X, Y &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;next&lt;/span&gt;(reader.ptb_iterator(train_data, batch_size&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;200&lt;/span&gt;, num_steps&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;40&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="op"&gt;%%&lt;/span&gt;timeit
gvs_bptt &lt;span class="op"&gt;=&lt;/span&gt; sess.run(g[&lt;span class="st"&gt;&amp;#39;gvs_true_bptt&amp;#39;&lt;/span&gt;], feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{g[&lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;]:X, g[&lt;span class="st"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;]:Y, g[&lt;span class="st"&gt;&amp;#39;dropout&amp;#39;&lt;/span&gt;]: &lt;span class="dv"&gt;1&lt;/span&gt;})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;10 loops, best of 3: 173 ms per loop&lt;/code&gt;&lt;/pre&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="op"&gt;%%&lt;/span&gt;timeit
gvs_tf &lt;span class="op"&gt;=&lt;/span&gt; sess.run(g[&lt;span class="st"&gt;&amp;#39;gvs_tf_style&amp;#39;&lt;/span&gt;], feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{g[&lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;]:X, g[&lt;span class="st"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;]:Y, g[&lt;span class="st"&gt;&amp;#39;dropout&amp;#39;&lt;/span&gt;]: &lt;span class="dv"&gt;1&lt;/span&gt;})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;10 loops, best of 3: 80.2 ms per loop&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="vanshing-gradients-demonstration"&gt;Vanshing gradients demonstration&lt;/h4&gt;
&lt;p&gt;To demonstrate the vanishing gradient problem, I collected this information. As you can see, the gradients vanish very quickly, decreasing by a factor of of about 3-4 at each step.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;vanishing_grads, gvs &lt;span class="op"&gt;=&lt;/span&gt; sess.run([g[&lt;span class="st"&gt;&amp;#39;vanishing_grads&amp;#39;&lt;/span&gt;], g[&lt;span class="st"&gt;&amp;#39;gvs_true_bptt&amp;#39;&lt;/span&gt;]],
                                feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{g[&lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;]:X, g[&lt;span class="st"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;]:Y, g[&lt;span class="st"&gt;&amp;#39;dropout&amp;#39;&lt;/span&gt;]: &lt;span class="dv"&gt;1&lt;/span&gt;})
vanishing_grads &lt;span class="op"&gt;=&lt;/span&gt; np.array(vanishing_grads)
weights &lt;span class="op"&gt;=&lt;/span&gt; gvs[&lt;span class="dv"&gt;1&lt;/span&gt;][&lt;span class="dv"&gt;1&lt;/span&gt;]

&lt;span class="co"&gt;# sum all the grads from each loss node&lt;/span&gt;
vanishing_grads &lt;span class="op"&gt;=&lt;/span&gt; np.&lt;span class="bu"&gt;sum&lt;/span&gt;(vanishing_grads, axis&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;0&lt;/span&gt;)

&lt;span class="co"&gt;# now calculate the l1 norm at each bptt step&lt;/span&gt;
vanishing_grads &lt;span class="op"&gt;=&lt;/span&gt; np.&lt;span class="bu"&gt;sum&lt;/span&gt;(np.&lt;span class="bu"&gt;sum&lt;/span&gt;(np.&lt;span class="bu"&gt;abs&lt;/span&gt;(vanishing_grads),axis&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;),axis&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;)

vanishing_grads&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;array([  5.28676978e-08,   1.51207473e-07,   4.04591049e-07,
         1.55859300e-06,   5.00411124e-06,   1.32292716e-05,
         3.94736344e-05,   1.17605050e-04,   3.37805774e-04,
         1.01710076e-03,   2.74375151e-03,   8.92040879e-03,
         2.23708227e-02,   7.23497868e-02,   2.45202959e-01,
         7.39126682e-01,   2.19093657e+00,   6.16793633e+00,
         2.27248211e+01,   9.78200531e+01], dtype=float32)&lt;/code&gt;&lt;/pre&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="bu"&gt;len&lt;/span&gt;(vanishing_grads) &lt;span class="op"&gt;-&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;):
    &lt;span class="bu"&gt;print&lt;/span&gt;(vanishing_grads[i&lt;span class="op"&gt;+&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;] &lt;span class="op"&gt;/&lt;/span&gt; vanishing_grads[i])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;2.86011
2.67573
3.85227
3.21066
2.64368
2.98381
2.97933
2.87237
3.0109
2.69762
3.25117
2.50782
3.23411
3.38913
3.01435
2.96422
2.81521
3.68435
4.30455&lt;/code&gt;&lt;/pre&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;plt.plot(vanishing_grads)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/RNN_output_19_1.png" alt="Plot of Vanishing Gradients" /&gt;&lt;figcaption&gt;Plot of Vanishing Gradients&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h4 id="quick-accuracy-test"&gt;Quick accuracy test&lt;/h4&gt;
&lt;p&gt;A sanity check to make sure the true truncated backpropagation algorithm is doing the right thing.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="co"&gt;# first test using bptt_steps &amp;gt;= num_steps&lt;/span&gt;

reset_graph()
g &lt;span class="op"&gt;=&lt;/span&gt; build_graph(num_steps &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;7&lt;/span&gt;, bptt_steps &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;7&lt;/span&gt;)
X, Y &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;next&lt;/span&gt;(reader.ptb_iterator(train_data, batch_size&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;200&lt;/span&gt;, num_steps&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;7&lt;/span&gt;))

&lt;span class="cf"&gt;with&lt;/span&gt; tf.Session() &lt;span class="im"&gt;as&lt;/span&gt; sess:
    sess.run(tf.initialize_all_variables())
    gvs_bptt, gvs_tf &lt;span class="op"&gt;=\&lt;/span&gt;
        sess.run([g[&lt;span class="st"&gt;&amp;#39;gvs_true_bptt&amp;#39;&lt;/span&gt;],g[&lt;span class="st"&gt;&amp;#39;gvs_tf_style&amp;#39;&lt;/span&gt;]],
                                feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{g[&lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;]:X, g[&lt;span class="st"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;]:Y, g[&lt;span class="st"&gt;&amp;#39;dropout&amp;#39;&lt;/span&gt;]: &lt;span class="fl"&gt;0.8&lt;/span&gt;})

&lt;span class="co"&gt;# assert embedding gradients are the same&lt;/span&gt;
&lt;span class="cf"&gt;assert&lt;/span&gt;(np.&lt;span class="bu"&gt;max&lt;/span&gt;(gvs_bptt[&lt;span class="dv"&gt;0&lt;/span&gt;][&lt;span class="dv"&gt;0&lt;/span&gt;] &lt;span class="op"&gt;-&lt;/span&gt; gvs_tf[&lt;span class="dv"&gt;0&lt;/span&gt;][&lt;span class="dv"&gt;0&lt;/span&gt;]) &lt;span class="op"&gt;&amp;lt;&lt;/span&gt; &lt;span class="fl"&gt;1e-4&lt;/span&gt;)
&lt;span class="co"&gt;# assert weight gradients are the same&lt;/span&gt;
&lt;span class="cf"&gt;assert&lt;/span&gt;(np.&lt;span class="bu"&gt;max&lt;/span&gt;(gvs_bptt[&lt;span class="dv"&gt;1&lt;/span&gt;][&lt;span class="dv"&gt;0&lt;/span&gt;] &lt;span class="op"&gt;-&lt;/span&gt; gvs_tf[&lt;span class="dv"&gt;1&lt;/span&gt;][&lt;span class="dv"&gt;0&lt;/span&gt;]) &lt;span class="op"&gt;&amp;lt;&lt;/span&gt; &lt;span class="fl"&gt;1e-4&lt;/span&gt;)
&lt;span class="co"&gt;# assert bias gradients are the same&lt;/span&gt;
&lt;span class="cf"&gt;assert&lt;/span&gt;(np.&lt;span class="bu"&gt;max&lt;/span&gt;(gvs_bptt[&lt;span class="dv"&gt;2&lt;/span&gt;][&lt;span class="dv"&gt;0&lt;/span&gt;] &lt;span class="op"&gt;-&lt;/span&gt; gvs_tf[&lt;span class="dv"&gt;2&lt;/span&gt;][&lt;span class="dv"&gt;0&lt;/span&gt;]) &lt;span class="op"&gt;&amp;lt;&lt;/span&gt; &lt;span class="fl"&gt;1e-4&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="experiment"&gt;Experiment&lt;/h3&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="co"&gt;Train the network&lt;/span&gt;
&lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

&lt;span class="kw"&gt;def&lt;/span&gt; train_network(num_epochs,
                  num_steps,
                  use_true_bptt,
                  batch_size &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;200&lt;/span&gt;,
                  bptt_steps &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;7&lt;/span&gt;,
                  state_size &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;4&lt;/span&gt;,
                  learning_rate &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="fl"&gt;0.01&lt;/span&gt;,
                  dropout &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="fl"&gt;0.8&lt;/span&gt;,
                  verbose &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="va"&gt;True&lt;/span&gt;):

    reset_graph()
    tf.set_random_seed(&lt;span class="dv"&gt;1234&lt;/span&gt;)
    g &lt;span class="op"&gt;=&lt;/span&gt; build_graph(num_steps &lt;span class="op"&gt;=&lt;/span&gt; num_steps,
                    bptt_steps &lt;span class="op"&gt;=&lt;/span&gt; bptt_steps,
                    state_size &lt;span class="op"&gt;=&lt;/span&gt; state_size,
                    batch_size &lt;span class="op"&gt;=&lt;/span&gt; batch_size,
                   learning_rate &lt;span class="op"&gt;=&lt;/span&gt; learning_rate)
    &lt;span class="cf"&gt;if&lt;/span&gt; use_true_bptt:
        train_step &lt;span class="op"&gt;=&lt;/span&gt; g[&lt;span class="st"&gt;&amp;#39;train_true_bptt&amp;#39;&lt;/span&gt;]
    &lt;span class="cf"&gt;else&lt;/span&gt;:
        train_step &lt;span class="op"&gt;=&lt;/span&gt; g[&lt;span class="st"&gt;&amp;#39;train_tf_style&amp;#39;&lt;/span&gt;]
    &lt;span class="cf"&gt;with&lt;/span&gt; tf.Session() &lt;span class="im"&gt;as&lt;/span&gt; sess:
        sess.run(tf.initialize_all_variables())
        training_losses &lt;span class="op"&gt;=&lt;/span&gt; []
        val_losses &lt;span class="op"&gt;=&lt;/span&gt; []
        &lt;span class="cf"&gt;for&lt;/span&gt; idx, epoch &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;enumerate&lt;/span&gt;(gen_epochs(num_epochs, num_steps, batch_size)):
            training_loss &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;
            steps &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;
            training_state &lt;span class="op"&gt;=&lt;/span&gt; np.zeros((batch_size, state_size))
            &lt;span class="cf"&gt;for&lt;/span&gt; X, Y &lt;span class="kw"&gt;in&lt;/span&gt; epoch:
                steps &lt;span class="op"&gt;+=&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;
                training_loss_, training_state, _ &lt;span class="op"&gt;=&lt;/span&gt; sess.run([g[&lt;span class="st"&gt;&amp;#39;loss&amp;#39;&lt;/span&gt;],
                                                      g[&lt;span class="st"&gt;&amp;#39;final_state&amp;#39;&lt;/span&gt;],
                                                      train_step],
                                                  feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{g[&lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;]: X,
                                                             g[&lt;span class="st"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;]: Y,
                                                             g[&lt;span class="st"&gt;&amp;#39;dropout&amp;#39;&lt;/span&gt;]: dropout,
                                                             g[&lt;span class="st"&gt;&amp;#39;init_state&amp;#39;&lt;/span&gt;]: training_state})
                training_loss &lt;span class="op"&gt;+=&lt;/span&gt; training_loss_
            &lt;span class="cf"&gt;if&lt;/span&gt; verbose:
                &lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;Average training loss for Epoch&amp;quot;&lt;/span&gt;, idx, &lt;span class="st"&gt;&amp;quot;:&amp;quot;&lt;/span&gt;, training_loss&lt;span class="op"&gt;/&lt;/span&gt;steps)
            training_losses.append(training_loss&lt;span class="op"&gt;/&lt;/span&gt;steps)

            val_loss &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;
            steps &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;
            training_state &lt;span class="op"&gt;=&lt;/span&gt; np.zeros((batch_size, state_size))

            &lt;span class="cf"&gt;for&lt;/span&gt; X,Y &lt;span class="kw"&gt;in&lt;/span&gt; reader.ptb_iterator(val_data, batch_size, num_steps):
                steps &lt;span class="op"&gt;+=&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;
                val_loss_, training_state &lt;span class="op"&gt;=&lt;/span&gt; sess.run([g[&lt;span class="st"&gt;&amp;#39;loss&amp;#39;&lt;/span&gt;],
                                                      g[&lt;span class="st"&gt;&amp;#39;final_state&amp;#39;&lt;/span&gt;]],
                                                  feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{g[&lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;]: X,
                                                             g[&lt;span class="st"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;]: Y,
                                                             g[&lt;span class="st"&gt;&amp;#39;dropout&amp;#39;&lt;/span&gt;]: &lt;span class="dv"&gt;1&lt;/span&gt;,
                                                             g[&lt;span class="st"&gt;&amp;#39;init_state&amp;#39;&lt;/span&gt;]: training_state})
                val_loss &lt;span class="op"&gt;+=&lt;/span&gt; val_loss_
            &lt;span class="cf"&gt;if&lt;/span&gt; verbose:
                &lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;Average validation loss for Epoch&amp;quot;&lt;/span&gt;, idx, &lt;span class="st"&gt;&amp;quot;:&amp;quot;&lt;/span&gt;, val_loss&lt;span class="op"&gt;/&lt;/span&gt;steps)
                &lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;***&amp;quot;&lt;/span&gt;)
            val_losses.append(val_loss&lt;span class="op"&gt;/&lt;/span&gt;steps)

    &lt;span class="cf"&gt;return&lt;/span&gt; training_losses, val_losses&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="results"&gt;Results&lt;/h3&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="co"&gt;# Procedure to collect results&lt;/span&gt;
&lt;span class="co"&gt;# Note: this takes a few hours to run&lt;/span&gt;

bptt_steps &lt;span class="op"&gt;=&lt;/span&gt; [(&lt;span class="dv"&gt;5&lt;/span&gt;,&lt;span class="dv"&gt;20&lt;/span&gt;), (&lt;span class="dv"&gt;10&lt;/span&gt;,&lt;span class="dv"&gt;30&lt;/span&gt;), (&lt;span class="dv"&gt;20&lt;/span&gt;,&lt;span class="dv"&gt;40&lt;/span&gt;), (&lt;span class="dv"&gt;40&lt;/span&gt;,&lt;span class="dv"&gt;40&lt;/span&gt;)]
lrs &lt;span class="op"&gt;=&lt;/span&gt; [&lt;span class="fl"&gt;0.003&lt;/span&gt;, &lt;span class="fl"&gt;0.001&lt;/span&gt;, &lt;span class="fl"&gt;0.0003&lt;/span&gt;]
&lt;span class="cf"&gt;for&lt;/span&gt; bptt_step, lr &lt;span class="kw"&gt;in&lt;/span&gt; ((x, y) &lt;span class="cf"&gt;for&lt;/span&gt; x &lt;span class="kw"&gt;in&lt;/span&gt; bptt_steps &lt;span class="cf"&gt;for&lt;/span&gt; y &lt;span class="kw"&gt;in&lt;/span&gt; lrs):
    _, val_losses &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="op"&gt;\&lt;/span&gt;
        train_network(&lt;span class="dv"&gt;20&lt;/span&gt;, bptt_step[&lt;span class="dv"&gt;0&lt;/span&gt;], use_true_bptt&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;, state_size&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;100&lt;/span&gt;,
                      batch_size&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;32&lt;/span&gt;, learning_rate&lt;span class="op"&gt;=&lt;/span&gt;lr, verbose&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;)
    &lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;** TF STYLE **&amp;quot;&lt;/span&gt;, bptt_step, lr)
    &lt;span class="bu"&gt;print&lt;/span&gt;(np.&lt;span class="bu"&gt;min&lt;/span&gt;(val_losses))
    &lt;span class="cf"&gt;if&lt;/span&gt; bptt_step[&lt;span class="dv"&gt;0&lt;/span&gt;] &lt;span class="op"&gt;!=&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;:
        _, val_losses &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="op"&gt;\&lt;/span&gt;
            train_network(&lt;span class="dv"&gt;20&lt;/span&gt;, bptt_step[&lt;span class="dv"&gt;1&lt;/span&gt;], use_true_bptt&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;, bptt_steps&lt;span class="op"&gt;=&lt;/span&gt; bptt_step[&lt;span class="dv"&gt;0&lt;/span&gt;],
                          state_size&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;100&lt;/span&gt;, batch_size&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;32&lt;/span&gt;, learning_rate&lt;span class="op"&gt;=&lt;/span&gt;lr, verbose&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;)
        &lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;** TRUE STYLE **&amp;quot;&lt;/span&gt;, bptt_step, lr)
        &lt;span class="bu"&gt;print&lt;/span&gt;(np.&lt;span class="bu"&gt;min&lt;/span&gt;(val_losses))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here are the results in a table:&lt;/p&gt;
&lt;h5 id="minimum-validation-loss-achieved-in-20-epochs"&gt;Minimum validation loss achieved in 20 epochs:&lt;/h5&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;BPTT Steps&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td&gt;Learning Rate&lt;/td&gt;
&lt;td&gt;0.003&lt;/td&gt;
&lt;td&gt;0.001&lt;/td&gt;
&lt;td&gt;0.0003&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;True (20-seq)&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;5.12&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;5.01&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;5.09&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td&gt;TF Style&lt;/td&gt;
&lt;td&gt;5.21&lt;/td&gt;
&lt;td&gt;5.04&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;5.04&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td&gt;BPTT Steps&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;Learning Rate&lt;/td&gt;
&lt;td&gt;0.003&lt;/td&gt;
&lt;td&gt;0.001&lt;/td&gt;
&lt;td&gt;0.0003&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td&gt;True (30-seq)&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;5.07&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;5.00&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;5.12&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;TF Style&lt;/td&gt;
&lt;td&gt;5.15&lt;/td&gt;
&lt;td&gt;5.03&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;5.05&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;BPTT Steps&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td&gt;Learning Rate&lt;/td&gt;
&lt;td&gt;0.003&lt;/td&gt;
&lt;td&gt;0.001&lt;/td&gt;
&lt;td&gt;0.0003&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;True (40-seq)&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;5.05&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;5.00&lt;/td&gt;
&lt;td&gt;5.15&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td&gt;TF Style&lt;/td&gt;
&lt;td&gt;5.11&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;4.99&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;5.08&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td&gt;BPTT Steps&lt;/td&gt;
&lt;td&gt;40&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;Learning Rate&lt;/td&gt;
&lt;td&gt;0.003&lt;/td&gt;
&lt;td&gt;0.001&lt;/td&gt;
&lt;td&gt;0.0003&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td&gt;TF Style&lt;/td&gt;
&lt;td&gt;5.05&lt;/td&gt;
&lt;td&gt;4.99&lt;/td&gt;
&lt;td&gt;5.15&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="discussion"&gt;Discussion&lt;/h3&gt;
&lt;p&gt;As you can see, true truncated backpropagation seems to have an advantage over Tensorflow-style truncated backpropagation when truncating errors at the same number of steps. However, this advantage completely disappears (and actually reverses) when comparing true truncated backpropagation to Tensorflow-style truncated backpropagation that uses the same sequence length.&lt;/p&gt;
&lt;p&gt;This suggests two things:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Because a well-implemented true truncated backpropagation algorithm would run about as fast as full backpropagation over the sequence, and full backpropagation performs slightly better, it is most likely not worth implementing an efficient true truncated backpropagation algorithm.&lt;/li&gt;
&lt;li&gt;Since true truncated backpropagation outperforms Tensorflow-style truncated backpropagation when truncating errors to the same number of steps, we might conclude that Tensorflow-style truncated backpropagation does not effectively backpropagate errors the full n-steps. Thus, if you need to capture n-step dependencies with Tensorflow-style truncated backpropagation, you may benefit from using a num_steps that is appreciably higher than n in order to effectively backpropagate errors the desired n steps.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Edit&lt;/strong&gt;: After writing this post, I discovered that this distinction between styles of truncated backpropagation is discussed in &lt;a href="https://web.stanford.edu/class/psych209a/ReadingsByDate/02_25/Williams%20Zipser95RecNets.pdf"&gt;Williams and Zipser (1992), Gradient-Based Learning Algorithms for Recurrent Networks and Their Computation Complexity&lt;/a&gt;. The authors refer to the “true” truncated backpropagation as “truncated backpropagation” or BPTT(n) [or BPTT(n, 1)], whereas they refer to Tensorflow-style truncated backpropagation as “epochwise truncated backpropagation” or BPTT(n, n). They also allow for semi-epochwise truncated BPTT, which would do a backward pass more often than once per sequence, but less often than all possible times (i.e., in Ilya Sutskever’s language used above, this would be BPTT(k2, k1), where 1 &amp;lt; k1 &amp;lt; k2).&lt;/p&gt;
&lt;p&gt;In &lt;a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.56.7941&amp;amp;rep=rep1&amp;amp;type=pdf"&gt;Williams and Peng (1990), An Efficien Gradient-Based Algorithm for On-Line Training of Recurrent Network Trajectories&lt;/a&gt;, the authors conduct a similar experiment to the one in the post, and reach similar conclusions. In particular, Williams Peng write that: “The results of these experiments have been that the success rate of BPTT(2h; h) is essentially identical to that of BPTT(h)”. In other words, they compared “true” truncated backpropagation, with h steps of truncation, to BPTT(2h, h), which is similar to Tensorflow-style backpropagation and has 2h steps of truncation, and found that they performed similarly.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</content></entry><entry><title>Recurrent Neural Networks in Tensorflow I</title><link href="https://r2rt.com/recurrent-neural-networks-in-tensorflow-i.html" rel="alternate"></link><published>2016-07-11T00:00:00-04:00</published><updated>2016-07-11T00:00:00-04:00</updated><author><name>Silviu Pitis</name></author><id>tag:r2rt.com,2016-07-11:/recurrent-neural-networks-in-tensorflow-i.html</id><summary type="html">This is the first in a series of posts about recurrent neural networks in Tensorflow. In this post, we will build a vanilla recurrent neural network (RNN) from the ground up in Tensorflow, and then translate the model into Tensorflow's RNN API.</summary><content type="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;meta name="generator" content="pandoc"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes"&gt;
  &lt;title&gt;&lt;/title&gt;
  &lt;style type="text/css"&gt;code{white-space: pre;}&lt;/style&gt;
  &lt;style type="text/css"&gt;
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code &gt; span.kw { color: #007020; font-weight: bold; } /* Keyword */
code &gt; span.dt { color: #902000; } /* DataType */
code &gt; span.dv { color: #40a070; } /* DecVal */
code &gt; span.bn { color: #40a070; } /* BaseN */
code &gt; span.fl { color: #40a070; } /* Float */
code &gt; span.ch { color: #4070a0; } /* Char */
code &gt; span.st { color: #4070a0; } /* String */
code &gt; span.co { color: #60a0b0; font-style: italic; } /* Comment */
code &gt; span.ot { color: #007020; } /* Other */
code &gt; span.al { color: #ff0000; font-weight: bold; } /* Alert */
code &gt; span.fu { color: #06287e; } /* Function */
code &gt; span.er { color: #ff0000; font-weight: bold; } /* Error */
code &gt; span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code &gt; span.cn { color: #880000; } /* Constant */
code &gt; span.sc { color: #4070a0; } /* SpecialChar */
code &gt; span.vs { color: #4070a0; } /* VerbatimString */
code &gt; span.ss { color: #bb6688; } /* SpecialString */
code &gt; span.im { } /* Import */
code &gt; span.va { color: #19177c; } /* Variable */
code &gt; span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code &gt; span.op { color: #666666; } /* Operator */
code &gt; span.bu { } /* BuiltIn */
code &gt; span.ex { } /* Extension */
code &gt; span.pp { color: #bc7a00; } /* Preprocessor */
code &gt; span.at { color: #7d9029; } /* Attribute */
code &gt; span.do { color: #ba2121; font-style: italic; } /* Documentation */
code &gt; span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code &gt; span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code &gt; span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  &lt;/style&gt;
  &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"&gt;&lt;/script&gt;
  &lt;!--[if lt IE 9]&gt;
    &lt;script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"&gt;&lt;/script&gt;
  &lt;![endif]--&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;This is the first in a series of posts about recurrent neural networks in Tensorflow. In this post, we will build a vanilla recurrent neural network (RNN) from the ground up in Tensorflow, and then translate the model into Tensorflow’s RNN API.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit 2017/03/07&lt;/strong&gt;: Updated to work with Tensorflow 1.0.&lt;/p&gt;
&lt;h3 id="introduction-to-rnns"&gt;Introduction to RNNs&lt;/h3&gt;
&lt;p&gt;RNNs are neural networks that accept their own outputs as inputs. So as to not reinvent the wheel, here are a few blog posts to introduce you to RNNs:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;a href="https://r2rt.com/written-memories-understanding-deriving-and-extending-the-lstm.html"&gt;Written Memories: Understanding, Deriving and Extending the LSTM&lt;/a&gt;, on this blog&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.wildml.com/2015/09/recurrent-neural-networks-tutorial-part-1-introduction-to-rnns/"&gt;Recurrent Neural Networks Tutorial&lt;/a&gt;, by Denny Britz&lt;/li&gt;
&lt;li&gt;&lt;a href="http://karpathy.github.io/2015/05/21/rnn-effectiveness/"&gt;The Unreasonable Effectiveness of Recurrent Neural Networks&lt;/a&gt;, by Andrej Karpathy&lt;/li&gt;
&lt;li&gt;&lt;a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/"&gt;Understanding LSTM Networks&lt;/a&gt;, by Christopher Olah&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="outline-of-the-data"&gt;Outline of the data&lt;/h3&gt;
&lt;p&gt;In this post, we’ll be building a no frills RNN that accepts a binary sequence X and uses it to predict a binary sequence Y. The sequences are constructed as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Input sequence (X)&lt;/strong&gt;: At time step &lt;em&gt;t&lt;/em&gt;, &lt;span class="math inline"&gt;\(X_t\)&lt;/span&gt; has a 50% chance of being 1 (and a 50% chance of being 0). E.g., X might be [1, 0, 0, 1, 1, 1 … ].&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Output sequence (Y)&lt;/strong&gt;: At time step &lt;em&gt;t&lt;/em&gt;, &lt;span class="math inline"&gt;\(Y_t\)&lt;/span&gt; has a base 50% chance of being 1 (and a 50% base chance to be 0). The chance of &lt;span class="math inline"&gt;\(Y_t\)&lt;/span&gt; being 1 is increased by 50% (i.e., to 100%) if &lt;span class="math inline"&gt;\(X_{t-3}\)&lt;/span&gt; is 1, and decreased by 25% (i.e., to 25%) if &lt;span class="math inline"&gt;\(X_{t-8}\)&lt;/span&gt; is 1. If both &lt;span class="math inline"&gt;\(X_{t-3}\)&lt;/span&gt; and &lt;span class="math inline"&gt;\(X_{t-8}\)&lt;/span&gt; are 1, the chance of &lt;span class="math inline"&gt;\(Y_{t}\)&lt;/span&gt; being 1 is 50% + 50% - 25% = 75%.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Thus, there are two dependencies in the data: one at &lt;em&gt;t&lt;/em&gt;-3 (3 steps back) and one at &lt;em&gt;t&lt;/em&gt;-8 (8 steps back).&lt;/p&gt;
&lt;p&gt;This data is simple enough that we can calculate the expected cross-entropy loss for a trained RNN depending on whether or not it learns the dependencies:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If the network learns no dependencies, it will correctly assign a probability of 62.5% to 1, for an expected cross-entropy loss of about &lt;strong&gt;0.66&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;If the network learns only the first dependency (3 steps back) but not the second dependency, it will correctly assign a probability of 87.5%, 50% of the time, and correctly assign a probability of 62.5% the other 50% of the time, for an expected cross entropy loss of about &lt;strong&gt;0.52&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;If the network learns both dependencies, it will be 100% accurate 25% of the time, correctly assign a probability of 50%, 25% of the time, and correctly assign a probability of 75%, 50% of the time, for an expected cross extropy loss of about &lt;strong&gt;0.45&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Here are the calculations:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="im"&gt;import&lt;/span&gt; numpy &lt;span class="im"&gt;as&lt;/span&gt; np

&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;Expected cross entropy loss if the model:&amp;quot;&lt;/span&gt;)
&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;- learns neither dependency:&amp;quot;&lt;/span&gt;, &lt;span class="op"&gt;-&lt;/span&gt;(&lt;span class="fl"&gt;0.625&lt;/span&gt; &lt;span class="op"&gt;*&lt;/span&gt; np.log(&lt;span class="fl"&gt;0.625&lt;/span&gt;) &lt;span class="op"&gt;+&lt;/span&gt;
                                      &lt;span class="fl"&gt;0.375&lt;/span&gt; &lt;span class="op"&gt;*&lt;/span&gt; np.log(&lt;span class="fl"&gt;0.375&lt;/span&gt;)))
&lt;span class="co"&gt;# Learns first dependency only ==&amp;gt; 0.51916669970720941&lt;/span&gt;
&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;- learns first dependency:  &amp;quot;&lt;/span&gt;,
      &lt;span class="fl"&gt;-0.5&lt;/span&gt; &lt;span class="op"&gt;*&lt;/span&gt; (&lt;span class="fl"&gt;0.875&lt;/span&gt; &lt;span class="op"&gt;*&lt;/span&gt; np.log(&lt;span class="fl"&gt;0.875&lt;/span&gt;) &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="fl"&gt;0.125&lt;/span&gt; &lt;span class="op"&gt;*&lt;/span&gt; np.log(&lt;span class="fl"&gt;0.125&lt;/span&gt;))
      &lt;span class="fl"&gt;-0.5&lt;/span&gt; &lt;span class="op"&gt;*&lt;/span&gt; (&lt;span class="fl"&gt;0.625&lt;/span&gt; &lt;span class="op"&gt;*&lt;/span&gt; np.log(&lt;span class="fl"&gt;0.625&lt;/span&gt;) &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="fl"&gt;0.375&lt;/span&gt; &lt;span class="op"&gt;*&lt;/span&gt; np.log(&lt;span class="fl"&gt;0.375&lt;/span&gt;)))
&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;- learns both dependencies: &amp;quot;&lt;/span&gt;, &lt;span class="fl"&gt;-0.50&lt;/span&gt; &lt;span class="op"&gt;*&lt;/span&gt; (&lt;span class="fl"&gt;0.75&lt;/span&gt; &lt;span class="op"&gt;*&lt;/span&gt; np.log(&lt;span class="fl"&gt;0.75&lt;/span&gt;) &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="fl"&gt;0.25&lt;/span&gt; &lt;span class="op"&gt;*&lt;/span&gt; np.log(&lt;span class="fl"&gt;0.25&lt;/span&gt;))
      &lt;span class="op"&gt;-&lt;/span&gt; &lt;span class="fl"&gt;0.25&lt;/span&gt; &lt;span class="op"&gt;*&lt;/span&gt; (&lt;span class="dv"&gt;2&lt;/span&gt; &lt;span class="op"&gt;*&lt;/span&gt; &lt;span class="fl"&gt;0.50&lt;/span&gt; &lt;span class="op"&gt;*&lt;/span&gt; np.log (&lt;span class="fl"&gt;0.50&lt;/span&gt;)) &lt;span class="op"&gt;-&lt;/span&gt; &lt;span class="fl"&gt;0.25&lt;/span&gt; &lt;span class="op"&gt;*&lt;/span&gt; (&lt;span class="dv"&gt;0&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Expected cross entropy loss if the model:
- learns neither dependency: 0.661563238158
- learns first dependency:   0.519166699707
- learns both dependencies:  0.454454367449&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="model-architecture"&gt;Model architecture&lt;/h3&gt;
&lt;p&gt;The model will be as simple as possible: at time step &lt;em&gt;t&lt;/em&gt;, for &lt;span class="math inline"&gt;\(t \in \{0, 1, \dots n\}\)&lt;/span&gt; the model accepts a (one-hot) binary &lt;span class="math inline"&gt;\(X_t\)&lt;/span&gt; vector and a previous state vector, &lt;span class="math inline"&gt;\(S_{t-1}\)&lt;/span&gt;, as inputs and produces a state vector, &lt;span class="math inline"&gt;\(S_t\)&lt;/span&gt;, and a predicted probability distribution vector, &lt;span class="math inline"&gt;\(P_t\)&lt;/span&gt;, for the (one-hot) binary vector &lt;span class="math inline"&gt;\(Y_t\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Formally, the model is:&lt;/p&gt;
&lt;p&gt;&lt;span class="math inline"&gt;\(S_t = \text{tanh}(W(X_t \ @ \ S_{t-1}) + b_s)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="math inline"&gt;\(P_t = \text{softmax}(US_t + b_p)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;where &lt;span class="math inline"&gt;\(@\)&lt;/span&gt; represents vector concatenation, &lt;span class="math inline"&gt;\(X_t \in R^2\)&lt;/span&gt; is a one-hot binary vector, &lt;span class="math inline"&gt;\(W \in R^{d \times (2 + d)}, \  b_s \in R^d, \ U \in R^{2 \times d}\)&lt;/span&gt;, &lt;span class="math inline"&gt;\(b_p \in R^2\)&lt;/span&gt; and d is the size of the state vector (I use &lt;span class="math inline"&gt;\(d = 4\)&lt;/span&gt; below). At time step 0, &lt;span class="math inline"&gt;\(S_{-1}\)&lt;/span&gt; (the initial state) is initialized as a vector of zeros.&lt;/p&gt;
&lt;p&gt;Here is a diagram of the model:&lt;/p&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/BasicRNN.png" alt="Diagram of Basic RNN" /&gt;&lt;figcaption&gt;Diagram of Basic RNN&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h3 id="how-wide-should-our-tensorflow-graph-be"&gt;How wide should our Tensorflow graph be?&lt;/h3&gt;
&lt;p&gt;To build models in Tensorflow generally, you first represent the model as a graph, and then execute the graph. A critical question we must answer when deciding how to represent our model is: how wide should our graph be? How many time steps of input should our graph accept at once?&lt;/p&gt;
&lt;p&gt;Each time step is a duplicate, so it might make sense to have our graph, G, represent a single time step: &lt;span class="math inline"&gt;\(G(X_t, S_{t-1}) \mapsto (P_t, S_t)\)&lt;/span&gt;. We can then execute our graph for each time step, feeding in the state returned from the previous execution into the current execution. This would work for a model that was already trained, but there’s a problem with using this approach for training: the gradients computed during backpropagation are graph-bound. We would only be able to backpropagate errors to the current timestep; we could not backpropagate the error to time step &lt;em&gt;t-1&lt;/em&gt;. This means our network will not be able to learn how to store long-term dependencies (such as the two in our data) in its state.&lt;/p&gt;
&lt;p&gt;Alternatively, we might make our graph as wide as our data sequence. This often works, except that in this case, we have an arbitrarily long input sequence, so we have to stop somewhere. Let’s say we make our graph accept sequences of length 10,000. This solves the problem of graph-bound gradients, and the errors from time step 9999 are propagated all the way back to time step 0. Unfortunately, such backpropagation is not only (often prohibitively) expensive, but also ineffective, due to the vanishing / exploding gradient problem: it turns out that backpropagating errors over too many time steps often causes them to vanish (become insignificantly small) or explode (become overwhelmingly large). To understand why this is the case, we apply the chain rule repeatedly to &lt;span class="math inline"&gt;\(\frac{\partial E_t}{\partial S_{t-k}}\)&lt;/span&gt; and observe that there is a product of &lt;span class="math inline"&gt;\(k\)&lt;/span&gt; factors (Jacobian matrices) linking the gradient at &lt;span class="math inline"&gt;\(S_t\)&lt;/span&gt; and the gradient as &lt;span class="math inline"&gt;\(S_{t-k}\)&lt;/span&gt;:&lt;/p&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[\frac{\partial E_t}{\partial S_{t-k}} =
\frac{\partial E_t}{\partial S_t}
\frac{\partial S_t}{\partial S_{t-k}} =
\frac{\partial E_t}{\partial S_t}
\left(\frac{\partial S_t}{\partial S_{t-1}}
\frac{\partial S_{t-1}}{\partial S_{t-2}} \dots
\frac{\partial S_{t-k+1}}{\partial S_{t-k}}\right) =
\frac{\partial E_t}{\partial S_t}
\prod_{i=1}^{k}\frac{\partial S_{t-i+1}}{\partial S_{t-i}}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;In the words of Pascanu et al., “&lt;em&gt;in the same way a product of [k] real numbers can shrink to zero or explode to infinity, so does this product of matrices …&lt;/em&gt;” See &lt;a href="http://arxiv.org/pdf/1211.5063v2.pdf"&gt;On the difficulty of training RNNs&lt;/a&gt;, by Pascanu et al. or my post &lt;a href="https://r2rt.com/written-memories-understanding-deriving-and-extending-the-lstm.html"&gt;Written Memories: Understanding, Deriving and Extending the LSTM&lt;/a&gt; for more detailed explanations and references.&lt;/p&gt;
&lt;p&gt;The usual pattern for dealing with very long sequences is therefore to “truncate” our backpropagation by backpropagating errors a maximum of &lt;span class="math inline"&gt;\(n\)&lt;/span&gt; steps. We choose &lt;span class="math inline"&gt;\(n\)&lt;/span&gt; as a hyperparameter to our model, keeping in mind the trade-off: higher &lt;span class="math inline"&gt;\(n\)&lt;/span&gt; lets us capture longer term dependencies, but is more expensive computationally and memory-wise.&lt;/p&gt;
&lt;p&gt;A natural interpretation of backpropagating errors a maximum of &lt;span class="math inline"&gt;\(n\)&lt;/span&gt; steps means that we backpropagate every possible error &lt;span class="math inline"&gt;\(n\)&lt;/span&gt; steps. That is, if we have a sequence of length 49, and choose &lt;span class="math inline"&gt;\(n = 7\)&lt;/span&gt;, we would backpropagate 42 of the errors the full 7 steps. &lt;em&gt;This is not the approach we take in Tensorflow.&lt;/em&gt; Tensorflow’s approach is to limit the graph to being &lt;span class="math inline"&gt;\(n\)&lt;/span&gt; units wide. See &lt;a href="https://www.tensorflow.org/versions/r0.9/tutorials/recurrent/index.html#truncated-backpropagation"&gt;Tensorflow’s writeup on Truncated Backpropagation&lt;/a&gt; (“[Truncated backpropagation] is easy to implement by feeding inputs of length [&lt;span class="math inline"&gt;\(n\)&lt;/span&gt;] at a time and doing backward pass after each iteration.”). This means that we would take our sequence of length 49, break it up into 7 sub-sequences of length 7 that we feed into the graph in 7 separate computations, and that only the errors from the 7th input in each graph are backpropagated the full 7 steps. Therefore, even if you think there are no dependencies longer than 7 steps in your data, it may still be worthwhile to use &lt;span class="math inline"&gt;\(n &amp;gt; 7\)&lt;/span&gt; so as to increase the proportion of errors that are backpropagated by 7 steps. For an empirical investigation of the difference between backpropagating every error &lt;span class="math inline"&gt;\(n\)&lt;/span&gt; steps and Tensorflow-style backpropagation, see my post on &lt;a href="https://r2rt.com/styles-of-truncated-backpropagation.html"&gt;Styles of Truncated Backpropagation&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="using-lists-of-tensors-to-represent-the-width"&gt;Using lists of tensors to represent the width&lt;/h3&gt;
&lt;p&gt;Our graph will be &lt;span class="math inline"&gt;\(n\)&lt;/span&gt; units (time steps) wide where each unit is a perfect duplicate, sharing the same variables. The easiest way to build a graph containing these duplicate units is to build each duplicate part in parallel. This is a key point, so I’m bolding it: &lt;strong&gt;the easiest way to represent each type of duplicate tensor (the rnn inputs, the rnn outputs (hidden state), the predictions, and the loss) is as a &lt;em&gt;list&lt;/em&gt; of tensors.&lt;/strong&gt; Here is a diagram with references to the variables used in the code below:&lt;/p&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/BasicRNNLabeled.png" alt="Diagram of Basic RNN - Labeled" /&gt;&lt;figcaption&gt;Diagram of Basic RNN - Labeled&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;We will run a training step after each execution of the graph, simultaneously grabbing the final state produced by that execution to pass on to the next execution.&lt;/p&gt;
&lt;p&gt;Without further ado, here is the code:&lt;/p&gt;
&lt;h4 id="imports-config-variables-and-data-generators"&gt;Imports, config variables, and data generators&lt;/h4&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="im"&gt;import&lt;/span&gt; numpy &lt;span class="im"&gt;as&lt;/span&gt; np
&lt;span class="im"&gt;import&lt;/span&gt; tensorflow &lt;span class="im"&gt;as&lt;/span&gt; tf
&lt;span class="op"&gt;%&lt;/span&gt;matplotlib inline
&lt;span class="im"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class="im"&gt;as&lt;/span&gt; plt&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="co"&gt;# Global config variables&lt;/span&gt;
num_steps &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;5&lt;/span&gt; &lt;span class="co"&gt;# number of truncated backprop steps (&amp;#39;n&amp;#39; in the discussion above)&lt;/span&gt;
batch_size &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;200&lt;/span&gt;
num_classes &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt;
state_size &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;4&lt;/span&gt;
learning_rate &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="fl"&gt;0.1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; gen_data(size&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;1000000&lt;/span&gt;):
    X &lt;span class="op"&gt;=&lt;/span&gt; np.array(np.random.choice(&lt;span class="dv"&gt;2&lt;/span&gt;, size&lt;span class="op"&gt;=&lt;/span&gt;(size,)))
    Y &lt;span class="op"&gt;=&lt;/span&gt; []
    &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(size):
        threshold &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="fl"&gt;0.5&lt;/span&gt;
        &lt;span class="cf"&gt;if&lt;/span&gt; X[i&lt;span class="dv"&gt;-3&lt;/span&gt;] &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;:
            threshold &lt;span class="op"&gt;+=&lt;/span&gt; &lt;span class="fl"&gt;0.5&lt;/span&gt;
        &lt;span class="cf"&gt;if&lt;/span&gt; X[i&lt;span class="dv"&gt;-8&lt;/span&gt;] &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;:
            threshold &lt;span class="op"&gt;-=&lt;/span&gt; &lt;span class="fl"&gt;0.25&lt;/span&gt;
        &lt;span class="cf"&gt;if&lt;/span&gt; np.random.rand() &lt;span class="op"&gt;&amp;gt;&lt;/span&gt; threshold:
            Y.append(&lt;span class="dv"&gt;0&lt;/span&gt;)
        &lt;span class="cf"&gt;else&lt;/span&gt;:
            Y.append(&lt;span class="dv"&gt;1&lt;/span&gt;)
    &lt;span class="cf"&gt;return&lt;/span&gt; X, np.array(Y)

&lt;span class="co"&gt;# adapted from https://github.com/tensorflow/tensorflow/blob/master/tensorflow/models/rnn/ptb/reader.py&lt;/span&gt;
&lt;span class="kw"&gt;def&lt;/span&gt; gen_batch(raw_data, batch_size, num_steps):
    raw_x, raw_y &lt;span class="op"&gt;=&lt;/span&gt; raw_data
    data_length &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;len&lt;/span&gt;(raw_x)

    &lt;span class="co"&gt;# partition raw data into batches and stack them vertically in a data matrix&lt;/span&gt;
    batch_partition_length &lt;span class="op"&gt;=&lt;/span&gt; data_length &lt;span class="op"&gt;//&lt;/span&gt; batch_size
    data_x &lt;span class="op"&gt;=&lt;/span&gt; np.zeros([batch_size, batch_partition_length], dtype&lt;span class="op"&gt;=&lt;/span&gt;np.int32)
    data_y &lt;span class="op"&gt;=&lt;/span&gt; np.zeros([batch_size, batch_partition_length], dtype&lt;span class="op"&gt;=&lt;/span&gt;np.int32)
    &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(batch_size):
        data_x[i] &lt;span class="op"&gt;=&lt;/span&gt; raw_x[batch_partition_length &lt;span class="op"&gt;*&lt;/span&gt; i:batch_partition_length &lt;span class="op"&gt;*&lt;/span&gt; (i &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;)]
        data_y[i] &lt;span class="op"&gt;=&lt;/span&gt; raw_y[batch_partition_length &lt;span class="op"&gt;*&lt;/span&gt; i:batch_partition_length &lt;span class="op"&gt;*&lt;/span&gt; (i &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;)]
    &lt;span class="co"&gt;# further divide batch partitions into num_steps for truncated backprop&lt;/span&gt;
    epoch_size &lt;span class="op"&gt;=&lt;/span&gt; batch_partition_length &lt;span class="op"&gt;//&lt;/span&gt; num_steps

    &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(epoch_size):
        x &lt;span class="op"&gt;=&lt;/span&gt; data_x[:, i &lt;span class="op"&gt;*&lt;/span&gt; num_steps:(i &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;) &lt;span class="op"&gt;*&lt;/span&gt; num_steps]
        y &lt;span class="op"&gt;=&lt;/span&gt; data_y[:, i &lt;span class="op"&gt;*&lt;/span&gt; num_steps:(i &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;) &lt;span class="op"&gt;*&lt;/span&gt; num_steps]
        &lt;span class="cf"&gt;yield&lt;/span&gt; (x, y)

&lt;span class="kw"&gt;def&lt;/span&gt; gen_epochs(n, num_steps):
    &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(n):
        &lt;span class="cf"&gt;yield&lt;/span&gt; gen_batch(gen_data(), batch_size, num_steps)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="model"&gt;Model&lt;/h4&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="co"&gt;Placeholders&lt;/span&gt;
&lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

x &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(tf.int32, [batch_size, num_steps], name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;input_placeholder&amp;#39;&lt;/span&gt;)
y &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(tf.int32, [batch_size, num_steps], name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;labels_placeholder&amp;#39;&lt;/span&gt;)
init_state &lt;span class="op"&gt;=&lt;/span&gt; tf.zeros([batch_size, state_size])

&lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="co"&gt;RNN Inputs&lt;/span&gt;
&lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

&lt;span class="co"&gt;# Turn our x placeholder into a list of one-hot tensors:&lt;/span&gt;
&lt;span class="co"&gt;# rnn_inputs is a list of num_steps tensors with shape [batch_size, num_classes]&lt;/span&gt;
x_one_hot &lt;span class="op"&gt;=&lt;/span&gt; tf.one_hot(x, num_classes)
rnn_inputs &lt;span class="op"&gt;=&lt;/span&gt; tf.unstack(x_one_hot, axis&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="co"&gt;Definition of rnn_cell&lt;/span&gt;

&lt;span class="co"&gt;This is very similar to the __call__ method on Tensorflow&amp;#39;s BasicRNNCell. See:&lt;/span&gt;
&lt;span class="co"&gt;https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/rnn/python/ops/core_rnn_cell_impl.py#L95&lt;/span&gt;
&lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="cf"&gt;with&lt;/span&gt; tf.variable_scope(&lt;span class="st"&gt;&amp;#39;rnn_cell&amp;#39;&lt;/span&gt;):
    W &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;W&amp;#39;&lt;/span&gt;, [num_classes &lt;span class="op"&gt;+&lt;/span&gt; state_size, state_size])
    b &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;, [state_size], initializer&lt;span class="op"&gt;=&lt;/span&gt;tf.constant_initializer(&lt;span class="fl"&gt;0.0&lt;/span&gt;))

&lt;span class="kw"&gt;def&lt;/span&gt; rnn_cell(rnn_input, state):
    &lt;span class="cf"&gt;with&lt;/span&gt; tf.variable_scope(&lt;span class="st"&gt;&amp;#39;rnn_cell&amp;#39;&lt;/span&gt;, reuse&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;):
        W &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;W&amp;#39;&lt;/span&gt;, [num_classes &lt;span class="op"&gt;+&lt;/span&gt; state_size, state_size])
        b &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;, [state_size], initializer&lt;span class="op"&gt;=&lt;/span&gt;tf.constant_initializer(&lt;span class="fl"&gt;0.0&lt;/span&gt;))
    &lt;span class="cf"&gt;return&lt;/span&gt; tf.tanh(tf.matmul(tf.concat([rnn_input, state], &lt;span class="dv"&gt;1&lt;/span&gt;), W) &lt;span class="op"&gt;+&lt;/span&gt; b)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="co"&gt;Adding rnn_cells to graph&lt;/span&gt;

&lt;span class="co"&gt;This is a simplified version of the &amp;quot;static_rnn&amp;quot; function from Tensorflow&amp;#39;s api. See:&lt;/span&gt;
&lt;span class="co"&gt;https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/rnn/python/ops/core_rnn.py#L41&lt;/span&gt;
&lt;span class="co"&gt;Note: In practice, using &amp;quot;dynamic_rnn&amp;quot; is a better choice that the &amp;quot;static_rnn&amp;quot;:&lt;/span&gt;
&lt;span class="co"&gt;https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/ops/rnn.py#L390&lt;/span&gt;
&lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
state &lt;span class="op"&gt;=&lt;/span&gt; init_state
rnn_outputs &lt;span class="op"&gt;=&lt;/span&gt; []
&lt;span class="cf"&gt;for&lt;/span&gt; rnn_input &lt;span class="kw"&gt;in&lt;/span&gt; rnn_inputs:
    state &lt;span class="op"&gt;=&lt;/span&gt; rnn_cell(rnn_input, state)
    rnn_outputs.append(state)
final_state &lt;span class="op"&gt;=&lt;/span&gt; rnn_outputs[&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="co"&gt;Predictions, loss, training step&lt;/span&gt;

&lt;span class="co"&gt;Losses is similar to the &amp;quot;sequence_loss&amp;quot;&lt;/span&gt;
&lt;span class="co"&gt;function from Tensorflow&amp;#39;s API, except that here we are using a list of 2D tensors, instead of a 3D tensor. See:&lt;/span&gt;
&lt;span class="co"&gt;https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/seq2seq/python/ops/loss.py#L30&lt;/span&gt;
&lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

&lt;span class="co"&gt;#logits and predictions&lt;/span&gt;
&lt;span class="cf"&gt;with&lt;/span&gt; tf.variable_scope(&lt;span class="st"&gt;&amp;#39;softmax&amp;#39;&lt;/span&gt;):
    W &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;W&amp;#39;&lt;/span&gt;, [state_size, num_classes])
    b &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;, [num_classes], initializer&lt;span class="op"&gt;=&lt;/span&gt;tf.constant_initializer(&lt;span class="fl"&gt;0.0&lt;/span&gt;))
logits &lt;span class="op"&gt;=&lt;/span&gt; [tf.matmul(rnn_output, W) &lt;span class="op"&gt;+&lt;/span&gt; b &lt;span class="cf"&gt;for&lt;/span&gt; rnn_output &lt;span class="kw"&gt;in&lt;/span&gt; rnn_outputs]
predictions &lt;span class="op"&gt;=&lt;/span&gt; [tf.nn.softmax(logit) &lt;span class="cf"&gt;for&lt;/span&gt; logit &lt;span class="kw"&gt;in&lt;/span&gt; logits]

&lt;span class="co"&gt;# Turn our y placeholder into a list of labels&lt;/span&gt;
y_as_list &lt;span class="op"&gt;=&lt;/span&gt; tf.unstack(y, num&lt;span class="op"&gt;=&lt;/span&gt;num_steps, axis&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;)

&lt;span class="co"&gt;#losses and train_step&lt;/span&gt;
losses &lt;span class="op"&gt;=&lt;/span&gt; [tf.nn.sparse_softmax_cross_entropy_with_logits(labels&lt;span class="op"&gt;=&lt;/span&gt;label, logits&lt;span class="op"&gt;=&lt;/span&gt;logit) &lt;span class="cf"&gt;for&lt;/span&gt; &lt;span class="op"&gt;\&lt;/span&gt;
          logit, label &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;zip&lt;/span&gt;(logits, y_as_list)]
total_loss &lt;span class="op"&gt;=&lt;/span&gt; tf.reduce_mean(losses)
train_step &lt;span class="op"&gt;=&lt;/span&gt; tf.train.AdagradOptimizer(learning_rate).minimize(total_loss)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="co"&gt;Train the network&lt;/span&gt;
&lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

&lt;span class="kw"&gt;def&lt;/span&gt; train_network(num_epochs, num_steps, state_size&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;4&lt;/span&gt;, verbose&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;):
    &lt;span class="cf"&gt;with&lt;/span&gt; tf.Session() &lt;span class="im"&gt;as&lt;/span&gt; sess:
        sess.run(tf.global_variables_initializer())
        training_losses &lt;span class="op"&gt;=&lt;/span&gt; []
        &lt;span class="cf"&gt;for&lt;/span&gt; idx, epoch &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;enumerate&lt;/span&gt;(gen_epochs(num_epochs, num_steps)):
            training_loss &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;
            training_state &lt;span class="op"&gt;=&lt;/span&gt; np.zeros((batch_size, state_size))
            &lt;span class="cf"&gt;if&lt;/span&gt; verbose:
                &lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;&lt;span class="ch"&gt;\n&lt;/span&gt;&lt;span class="st"&gt;EPOCH&amp;quot;&lt;/span&gt;, idx)
            &lt;span class="cf"&gt;for&lt;/span&gt; step, (X, Y) &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;enumerate&lt;/span&gt;(epoch):
                tr_losses, training_loss_, training_state, _ &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="op"&gt;\&lt;/span&gt;
                    sess.run([losses,
                              total_loss,
                              final_state,
                              train_step],
                                  feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{x:X, y:Y, init_state:training_state})
                training_loss &lt;span class="op"&gt;+=&lt;/span&gt; training_loss_
                &lt;span class="cf"&gt;if&lt;/span&gt; step &lt;span class="op"&gt;%&lt;/span&gt; &lt;span class="dv"&gt;100&lt;/span&gt; &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt; &lt;span class="kw"&gt;and&lt;/span&gt; step &lt;span class="op"&gt;&amp;gt;&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;:
                    &lt;span class="cf"&gt;if&lt;/span&gt; verbose:
                        &lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;Average loss at step&amp;quot;&lt;/span&gt;, step,
                              &lt;span class="st"&gt;&amp;quot;for last 250 steps:&amp;quot;&lt;/span&gt;, training_loss&lt;span class="op"&gt;/&lt;/span&gt;&lt;span class="dv"&gt;100&lt;/span&gt;)
                    training_losses.append(training_loss&lt;span class="op"&gt;/&lt;/span&gt;&lt;span class="dv"&gt;100&lt;/span&gt;)
                    training_loss &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;

    &lt;span class="cf"&gt;return&lt;/span&gt; training_losses&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;training_losses &lt;span class="op"&gt;=&lt;/span&gt; train_network(&lt;span class="dv"&gt;1&lt;/span&gt;,num_steps)
plt.plot(training_losses)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;EPOCH 0
Average loss at step 100 for last 250 steps: 0.6559883219
Average loss at step 200 for last 250 steps: 0.617185292244
Average loss at step 300 for last 250 steps: 0.595771013498
Average loss at step 400 for last 250 steps: 0.568864737153
Average loss at step 500 for last 250 steps: 0.524139249921
Average loss at step 600 for last 250 steps: 0.522666031122
Average loss at step 700 for last 250 steps: 0.522012578249
Average loss at step 800 for last 250 steps: 0.519179680347
Average loss at step 900 for last 250 steps: 0.519965928495&lt;/code&gt;&lt;/pre&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/RNN_output_21_2.png" alt="RNN Output, num_steps = 5" /&gt;&lt;figcaption&gt;RNN Output, num_steps = 5&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;As you can see, the network very quickly learns to capture the first dependency (but not the second), and converges to the expected cross-entropy loss of 0.52.&lt;/p&gt;
&lt;p&gt;Exporting our model to a separate file in order to play with hyperparameters, we can see what happens when we use &lt;code&gt;num_steps = 1&lt;/code&gt; and &lt;code&gt;num_steps = 10&lt;/code&gt; (for this latter case, we also increase the state_size so as to maintain the the information about the second dependency for the required 8 steps):&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="im"&gt;import&lt;/span&gt; basic_rnn
&lt;span class="kw"&gt;def&lt;/span&gt; plot_learning_curve(num_steps, state_size&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;4&lt;/span&gt;, epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;):
    &lt;span class="kw"&gt;global&lt;/span&gt; losses, total_loss, final_state, train_step, x, y, init_state
    tf.reset_default_graph()
    g &lt;span class="op"&gt;=&lt;/span&gt; tf.get_default_graph()
    losses, total_loss, final_state, train_step, x, y, init_state &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="op"&gt;\&lt;/span&gt;
        basic_rnn.setup_graph(g,
            basic_rnn.RNN_config(num_steps&lt;span class="op"&gt;=&lt;/span&gt;num_steps, state_size&lt;span class="op"&gt;=&lt;/span&gt;state_size))
    res &lt;span class="op"&gt;=&lt;/span&gt; train_network(epochs, num_steps, state_size&lt;span class="op"&gt;=&lt;/span&gt;state_size, verbose&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;)
    plt.plot(res)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="co"&gt;NUM_STEPS = 1&lt;/span&gt;
&lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
plot_learning_curve(num_steps&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;, state_size&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;4&lt;/span&gt;, epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;2&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/RNN_output_25_0.png" alt="RNN Output, num_steps = 1" /&gt;&lt;figcaption&gt;RNN Output, num_steps = 1&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="co"&gt;NUM_STEPS = 10&lt;/span&gt;
&lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
plot_learning_curve(num_steps&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;10&lt;/span&gt;, state_size&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;16&lt;/span&gt;, epochs&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;10&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/RNN_output_26_0.png" alt="RNN Output, num_steps = 10" /&gt;&lt;figcaption&gt;RNN Output, num_steps = 10&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;As expected, using &lt;code&gt;num_steps = 10&lt;/code&gt; comes close to our expected cross-entropy for knowing both dependencies (0.454). However, using &lt;code&gt;num_steps = 1&lt;/code&gt; hovers around something slightly better than the expected cross-entropy for knowing neither dependency (0.66), and doesn’t seem to converge. What’s going on?&lt;/p&gt;
&lt;p&gt;The answer is that some information about the first dependency is making its way into the incoming state by pure chance. Although the model can’t learn weights that will maintain information about the first dependency (due to the backpropagation being graph-bound), it can learn to take advantage of whatever information about &lt;span class="math inline"&gt;\(X_{t-3}\)&lt;/span&gt; is left over in &lt;span class="math inline"&gt;\(S_{t-1}\)&lt;/span&gt;. In doing so, the model changes the way information about &lt;span class="math inline"&gt;\(X_{t-3}\)&lt;/span&gt; is stored in &lt;span class="math inline"&gt;\(S_{t-1}\)&lt;/span&gt;, which explains why the loss goes up and down, rather than settling at a local minima.&lt;/p&gt;
&lt;h3 id="translating-our-model-to-tensorflow"&gt;Translating our model to Tensorflow&lt;/h3&gt;
&lt;p&gt;Translating our model to Tensorflow’s API is easy. We simply replace these two sections:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="co"&gt;Definition of rnn_cell&lt;/span&gt;

&lt;span class="co"&gt;This is very similar to the __call__ method on Tensorflow&amp;#39;s BasicRNNCell. See:&lt;/span&gt;
&lt;span class="co"&gt;https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/rnn/python/ops/core_rnn_cell_impl.py#L95&lt;/span&gt;
&lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="cf"&gt;with&lt;/span&gt; tf.variable_scope(&lt;span class="st"&gt;&amp;#39;rnn_cell&amp;#39;&lt;/span&gt;):
    W &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;W&amp;#39;&lt;/span&gt;, [num_classes &lt;span class="op"&gt;+&lt;/span&gt; state_size, state_size])
    b &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;, [state_size], initializer&lt;span class="op"&gt;=&lt;/span&gt;tf.constant_initializer(&lt;span class="fl"&gt;0.0&lt;/span&gt;))

&lt;span class="kw"&gt;def&lt;/span&gt; rnn_cell(rnn_input, state):
    &lt;span class="cf"&gt;with&lt;/span&gt; tf.variable_scope(&lt;span class="st"&gt;&amp;#39;rnn_cell&amp;#39;&lt;/span&gt;, reuse&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;):
        W &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;W&amp;#39;&lt;/span&gt;, [num_classes &lt;span class="op"&gt;+&lt;/span&gt; state_size, state_size])
        b &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;, [state_size], initializer&lt;span class="op"&gt;=&lt;/span&gt;tf.constant_initializer(&lt;span class="fl"&gt;0.0&lt;/span&gt;))
    &lt;span class="cf"&gt;return&lt;/span&gt; tf.tanh(tf.matmul(tf.concat([rnn_input, state], &lt;span class="dv"&gt;1&lt;/span&gt;), W) &lt;span class="op"&gt;+&lt;/span&gt; b)

&lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="co"&gt;Adding rnn_cells to graph&lt;/span&gt;

&lt;span class="co"&gt;This is a simplified version of the &amp;quot;static_rnn&amp;quot; function from Tensorflow&amp;#39;s api. See:&lt;/span&gt;
&lt;span class="co"&gt;https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/rnn/python/ops/core_rnn.py#L41&lt;/span&gt;
&lt;span class="co"&gt;Note: In practice, using &amp;quot;dynamic_rnn&amp;quot; is a better choice that the &amp;quot;static_rnn&amp;quot;:&lt;/span&gt;
&lt;span class="co"&gt;https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/ops/rnn.py#L390&lt;/span&gt;
&lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
state &lt;span class="op"&gt;=&lt;/span&gt; init_state
rnn_outputs &lt;span class="op"&gt;=&lt;/span&gt; []
&lt;span class="cf"&gt;for&lt;/span&gt; rnn_input &lt;span class="kw"&gt;in&lt;/span&gt; rnn_inputs:
    state &lt;span class="op"&gt;=&lt;/span&gt; rnn_cell(rnn_input, state)
    rnn_outputs.append(state)
final_state &lt;span class="op"&gt;=&lt;/span&gt; rnn_outputs[&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With these two lines:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;cell &lt;span class="op"&gt;=&lt;/span&gt; tf.contrib.rnn.BasicRNNCell(state_size)
rnn_outputs, final_state &lt;span class="op"&gt;=&lt;/span&gt; tf.contrib.rnn.static_rnn(cell, rnn_inputs, initial_state&lt;span class="op"&gt;=&lt;/span&gt;init_state)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="using-a-dynamic-rnn"&gt;Using a dynamic RNN&lt;/h3&gt;
&lt;p&gt;Above, we added every node for every timestep to the graph before execution. This is called “static” construction. We could also let Tensorflow dynamically create the graph at execution time, which can be more efficient. To do this, instead of using a list of tensors (of length &lt;code&gt;num_steps&lt;/code&gt; and shape &lt;code&gt;[batch_size, features]&lt;/code&gt;), we keep everything in a single 3-dimnesional tensor of shape &lt;code&gt;[batch_size, num_steps, features]&lt;/code&gt;, and use Tensorflow’s &lt;code&gt;dynamic_rnn&lt;/code&gt; function. This is shown below.&lt;/p&gt;
&lt;h3 id="final-model-static"&gt;Final model — static&lt;/h3&gt;
&lt;p&gt;To recap, here’s the entire static model, as modified to use Tensorflow’s API:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="co"&gt;Placeholders&lt;/span&gt;
&lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

x &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(tf.int32, [batch_size, num_steps], name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;input_placeholder&amp;#39;&lt;/span&gt;)
y &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(tf.int32, [batch_size, num_steps], name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;labels_placeholder&amp;#39;&lt;/span&gt;)
init_state &lt;span class="op"&gt;=&lt;/span&gt; tf.zeros([batch_size, state_size])

&lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="co"&gt;Inputs&lt;/span&gt;
&lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

x_one_hot &lt;span class="op"&gt;=&lt;/span&gt; tf.one_hot(x, num_classes)
rnn_inputs &lt;span class="op"&gt;=&lt;/span&gt; tf.unstack(x_one_hot, axis&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;)

&lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="co"&gt;RNN&lt;/span&gt;
&lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

cell &lt;span class="op"&gt;=&lt;/span&gt; tf.contrib.rnn.BasicRNNCell(state_size)
rnn_outputs, final_state &lt;span class="op"&gt;=&lt;/span&gt; tf.contrib.rnn.static_rnn(cell, rnn_inputs, initial_state&lt;span class="op"&gt;=&lt;/span&gt;init_state)

&lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="co"&gt;Predictions, loss, training step&lt;/span&gt;
&lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

&lt;span class="cf"&gt;with&lt;/span&gt; tf.variable_scope(&lt;span class="st"&gt;&amp;#39;softmax&amp;#39;&lt;/span&gt;):
    W &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;W&amp;#39;&lt;/span&gt;, [state_size, num_classes])
    b &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;, [num_classes], initializer&lt;span class="op"&gt;=&lt;/span&gt;tf.constant_initializer(&lt;span class="fl"&gt;0.0&lt;/span&gt;))
logits &lt;span class="op"&gt;=&lt;/span&gt; [tf.matmul(rnn_output, W) &lt;span class="op"&gt;+&lt;/span&gt; b &lt;span class="cf"&gt;for&lt;/span&gt; rnn_output &lt;span class="kw"&gt;in&lt;/span&gt; rnn_outputs]
predictions &lt;span class="op"&gt;=&lt;/span&gt; [tf.nn.softmax(logit) &lt;span class="cf"&gt;for&lt;/span&gt; logit &lt;span class="kw"&gt;in&lt;/span&gt; logits]

y_as_list &lt;span class="op"&gt;=&lt;/span&gt; tf.unstack(y, num&lt;span class="op"&gt;=&lt;/span&gt;num_steps, axis&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;)

losses &lt;span class="op"&gt;=&lt;/span&gt; [tf.nn.sparse_softmax_cross_entropy_with_logits(labels&lt;span class="op"&gt;=&lt;/span&gt;label, logits&lt;span class="op"&gt;=&lt;/span&gt;logit) &lt;span class="cf"&gt;for&lt;/span&gt; &lt;span class="op"&gt;\&lt;/span&gt;
          logit, label &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;zip&lt;/span&gt;(logits, y_as_list)]
total_loss &lt;span class="op"&gt;=&lt;/span&gt; tf.reduce_mean(losses)
train_step &lt;span class="op"&gt;=&lt;/span&gt; tf.train.AdagradOptimizer(learning_rate).minimize(total_loss)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="final-model-dynamic"&gt;Final model — dynamic&lt;/h3&gt;
&lt;p&gt;And here it is with the &lt;code&gt;dynamic_rnn&lt;/code&gt; API, which should be preferred over the static API:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="co"&gt;Placeholders&lt;/span&gt;
&lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

x &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(tf.int32, [batch_size, num_steps], name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;input_placeholder&amp;#39;&lt;/span&gt;)
y &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(tf.int32, [batch_size, num_steps], name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;labels_placeholder&amp;#39;&lt;/span&gt;)
init_state &lt;span class="op"&gt;=&lt;/span&gt; tf.zeros([batch_size, state_size])

&lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="co"&gt;Inputs&lt;/span&gt;
&lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

rnn_inputs &lt;span class="op"&gt;=&lt;/span&gt; tf.one_hot(x, num_classes)

&lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="co"&gt;RNN&lt;/span&gt;
&lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

cell &lt;span class="op"&gt;=&lt;/span&gt; tf.contrib.rnn.BasicRNNCell(state_size)
rnn_outputs, final_state &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.dynamic_rnn(cell, rnn_inputs, initial_state&lt;span class="op"&gt;=&lt;/span&gt;init_state)

&lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="co"&gt;Predictions, loss, training step&lt;/span&gt;
&lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

&lt;span class="cf"&gt;with&lt;/span&gt; tf.variable_scope(&lt;span class="st"&gt;&amp;#39;softmax&amp;#39;&lt;/span&gt;):
    W &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;W&amp;#39;&lt;/span&gt;, [state_size, num_classes])
    b &lt;span class="op"&gt;=&lt;/span&gt; tf.get_variable(&lt;span class="st"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;, [num_classes], initializer&lt;span class="op"&gt;=&lt;/span&gt;tf.constant_initializer(&lt;span class="fl"&gt;0.0&lt;/span&gt;))
logits &lt;span class="op"&gt;=&lt;/span&gt; tf.reshape(
            tf.matmul(tf.reshape(rnn_outputs, [&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;, state_size]), W) &lt;span class="op"&gt;+&lt;/span&gt; b,
            [batch_size, num_steps, num_classes])
predictions &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.softmax(logits)

losses &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.sparse_softmax_cross_entropy_with_logits(labels&lt;span class="op"&gt;=&lt;/span&gt;y, logits&lt;span class="op"&gt;=&lt;/span&gt;logits)
total_loss &lt;span class="op"&gt;=&lt;/span&gt; tf.reduce_mean(losses)
train_step &lt;span class="op"&gt;=&lt;/span&gt; tf.train.AdagradOptimizer(learning_rate).minimize(total_loss)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="conclusion"&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;And there you have it, a basic RNN In Tensorflow. In the &lt;a href="https://r2rt.com/recurrent-neural-networks-in-tensorflow-ii.html"&gt;next post&lt;/a&gt; of this series, we’ll look at how to improve our base implementation, how to upgrade to a GRU/LSTM or other custom RNN cell and use multiple layers, how to add features like dropout and layer normalization, and how to use our RNN to generate sequences.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</content></entry><entry><title>First Convergence Bias</title><link href="https://r2rt.com/first-convergence-bias.html" rel="alternate"></link><published>2016-04-11T00:00:00-04:00</published><updated>2016-04-11T00:00:00-04:00</updated><author><name>Silviu Pitis</name></author><id>tag:r2rt.com,2016-04-11:/first-convergence-bias.html</id><summary type="html">In this post, I offer the results of an experiment providing support for "first convergence bias", which includes the proposition that training a randomly initialized network via backpropagation may never converge to a global minimum, regardless of the intialization and number of trials.</summary><content type="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;meta name="generator" content="pandoc"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes"&gt;
  &lt;title&gt;&lt;/title&gt;
  &lt;style type="text/css"&gt;code{white-space: pre;}&lt;/style&gt;
  &lt;style type="text/css"&gt;
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code &gt; span.kw { color: #007020; font-weight: bold; } /* Keyword */
code &gt; span.dt { color: #902000; } /* DataType */
code &gt; span.dv { color: #40a070; } /* DecVal */
code &gt; span.bn { color: #40a070; } /* BaseN */
code &gt; span.fl { color: #40a070; } /* Float */
code &gt; span.ch { color: #4070a0; } /* Char */
code &gt; span.st { color: #4070a0; } /* String */
code &gt; span.co { color: #60a0b0; font-style: italic; } /* Comment */
code &gt; span.ot { color: #007020; } /* Other */
code &gt; span.al { color: #ff0000; font-weight: bold; } /* Alert */
code &gt; span.fu { color: #06287e; } /* Function */
code &gt; span.er { color: #ff0000; font-weight: bold; } /* Error */
code &gt; span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code &gt; span.cn { color: #880000; } /* Constant */
code &gt; span.sc { color: #4070a0; } /* SpecialChar */
code &gt; span.vs { color: #4070a0; } /* VerbatimString */
code &gt; span.ss { color: #bb6688; } /* SpecialString */
code &gt; span.im { } /* Import */
code &gt; span.va { color: #19177c; } /* Variable */
code &gt; span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code &gt; span.op { color: #666666; } /* Operator */
code &gt; span.bu { } /* BuiltIn */
code &gt; span.ex { } /* Extension */
code &gt; span.pp { color: #bc7a00; } /* Preprocessor */
code &gt; span.at { color: #7d9029; } /* Attribute */
code &gt; span.do { color: #ba2121; font-style: italic; } /* Documentation */
code &gt; span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code &gt; span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code &gt; span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  &lt;/style&gt;
  &lt;!--[if lt IE 9]&gt;
    &lt;script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"&gt;&lt;/script&gt;
  &lt;![endif]--&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;In my post &lt;a href="https://r2rt.com/skill-vs-strategy.html"&gt;Skill vs Strategy&lt;/a&gt; I made the following proposition:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Let’s say we retrain the network one million times, and each of the local minima reached leads to approximately the same performance. Is this enough for us to conclude that the resulting strategies are close to the best? I would answer in the negative; we cannot be certain that a random initialization will ever lead to an optimal strategy via backpropagation. It may be a situation like the chest shot, where in order to reach an optimal strategy, the network must be trained again after it has learned some useful hidden features.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In this post, I offer the results of an experiment providing support for this proposition. The specific experiment was not designed to test this proposition, and in fact, the results I obtained are opposite of the results I expected.&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id="motivation"&gt;Motivation&lt;/h3&gt;
&lt;p&gt;In my post &lt;a href="https://r2rt.com/representational-power-of-deeper-layers.html"&gt;Representational Power of Deeper Layers&lt;/a&gt;, I showed that progressively deeper layers serve as better representations of the original data. This motivated the thought that the better the first layer representation of the data, the better the last layer representation could be. Intuitively, this makes sense, if our first layer can get us 95% of the way to the best solution, then the second layer only has 5% of ground to cover, whereas if the first layer only gets 70% of the way there, the second layer has six times as much work to do.&lt;/p&gt;
&lt;h3 id="experiment"&gt;Experiment&lt;/h3&gt;
&lt;p&gt;I tested this hypothesis by setting up a neural network with 3-hidden layers to classify MNIST digits. The network is trained only on 1000 MNIST training examples, as opposed to the entire training set of 50000, and achieves a test accuracy of between 86% and 89%.&lt;/p&gt;
&lt;p&gt;Using a simple mini-batch gradient descent with a batch-size of 50, I compared the following two scenarios:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;Training the entire network for 1000 steps.&lt;/li&gt;
&lt;li&gt;Training the first layer for 200 steps, training the first and second layers together for 200 steps, and only then training the entire network for 1000 steps.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;My hypothesis was that the second option would lead to better results, because by the time the third layer starts training, the first and second layers are finely tuned to produce “good” representations of the data. This hypothesis was proven incorrect.&lt;/p&gt;
&lt;h3 id="results"&gt;Results&lt;/h3&gt;
&lt;p&gt;For each of the two training strategies above, I trained 500 randomly-initialized networks and recorded their final accuracies. Training the entire network at once yielded an average test accuracy of 87.87%, whereas training the two earlier layers before training the entire network yielded an average test accuracy of only 87.64%. While this is not that significant of a difference, the plot below clearly shows that the “local minima” that each strategy reaches is pulled from a different distribution.&lt;/p&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/FCB_output_12_2.png" /&gt;
&lt;/figure&gt;
&lt;h3 id="discussion"&gt;Discussion&lt;/h3&gt;
&lt;p&gt;Although my hypothesis was invalidated, the result is nice because it supports my prior proposition that the local minima of first convergence may be biased. I.e., we have no guarantee of getting to the best local minima after training via backpropagation. Thus, the discussion in &lt;a href="https://r2rt.com/skill-vs-strategy.html"&gt;Skill vs Strategy&lt;/a&gt; is very relevant. Convergence speed aside, which is the usual reason for preferring alternate training strategies, other training strategies (e.g., other optimization strategies like Adagrad) are worth exploring as they might be biased toward a superior quality of local minima.&lt;/p&gt;
&lt;p&gt;How this relates to “greedy layer-wise training of deep networks” (see &lt;a href="https://papers.nips.cc/paper/3048-greedy-layer-wise-training-of-deep-networks.pdf"&gt;this paper&lt;/a&gt;) may also be interesting. I haven’t learned enough yet to dive into that paper or that method of training, but the gist, as I currently understand it, is that we can obtain better initializations of the weights in a deep network by first training each layer in an unsupervised fashion. In this experiment I did greedy layer-wise &lt;em&gt;supervised&lt;/em&gt; training, which led to worse results. As an aside, the discussion in that paper also strongly supports the proposition that local minima of first convergence may be biased.&lt;/p&gt;
&lt;h3 id="code"&gt;Code&lt;/h3&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="im"&gt;import&lt;/span&gt; tensorflow &lt;span class="im"&gt;as&lt;/span&gt; tf
&lt;span class="im"&gt;import&lt;/span&gt; numpy &lt;span class="im"&gt;as&lt;/span&gt; np
&lt;span class="im"&gt;import&lt;/span&gt; load_mnist
&lt;span class="im"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class="im"&gt;as&lt;/span&gt; plt
&lt;span class="im"&gt;import&lt;/span&gt; seaborn &lt;span class="im"&gt;as&lt;/span&gt; sns
sns.&lt;span class="bu"&gt;set&lt;/span&gt;(color_codes&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)
&lt;span class="op"&gt;%&lt;/span&gt;matplotlib inline
mnist &lt;span class="op"&gt;=&lt;/span&gt; load_mnist.read_data_sets(&lt;span class="st"&gt;&amp;#39;MNIST_data&amp;#39;&lt;/span&gt;, one_hot&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; weight_variable(shape):
  initial &lt;span class="op"&gt;=&lt;/span&gt; tf.truncated_normal(shape, stddev&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.1&lt;/span&gt;)
  &lt;span class="cf"&gt;return&lt;/span&gt; tf.Variable(initial)

&lt;span class="kw"&gt;def&lt;/span&gt; bias_variable(shape):
  initial &lt;span class="op"&gt;=&lt;/span&gt; tf.constant(&lt;span class="fl"&gt;0.1&lt;/span&gt;, shape&lt;span class="op"&gt;=&lt;/span&gt;shape)
  &lt;span class="cf"&gt;return&lt;/span&gt; tf.Variable(initial)

&lt;span class="kw"&gt;def&lt;/span&gt; simple_fc_layer(input_layer, shape):
    w &lt;span class="op"&gt;=&lt;/span&gt; weight_variable(shape)
    b &lt;span class="op"&gt;=&lt;/span&gt; bias_variable([shape[&lt;span class="dv"&gt;1&lt;/span&gt;]])
    &lt;span class="cf"&gt;return&lt;/span&gt; tf.nn.tanh(tf.matmul(input_layer,w) &lt;span class="op"&gt;+&lt;/span&gt; b)

&lt;span class="kw"&gt;def&lt;/span&gt; cross_entropy_layer(input_layer,shape):
    w &lt;span class="op"&gt;=&lt;/span&gt; weight_variable(shape)
    b &lt;span class="op"&gt;=&lt;/span&gt; bias_variable([shape[&lt;span class="dv"&gt;1&lt;/span&gt;]])
    &lt;span class="cf"&gt;return&lt;/span&gt; tf.nn.softmax(tf.matmul(input_layer,w) &lt;span class="op"&gt;+&lt;/span&gt; b)

&lt;span class="kw"&gt;def&lt;/span&gt; accuracy(y, y_):
    correct &lt;span class="op"&gt;=&lt;/span&gt; tf.equal(tf.argmax(y,&lt;span class="dv"&gt;1&lt;/span&gt;), tf.argmax(y_,&lt;span class="dv"&gt;1&lt;/span&gt;))
    &lt;span class="cf"&gt;return&lt;/span&gt; tf.reduce_mean(tf.cast(correct, &lt;span class="st"&gt;&amp;quot;float&amp;quot;&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;x &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(&lt;span class="st"&gt;&amp;quot;float&amp;quot;&lt;/span&gt;, shape&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="va"&gt;None&lt;/span&gt;, &lt;span class="dv"&gt;784&lt;/span&gt;])
y_ &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(&lt;span class="st"&gt;&amp;quot;float&amp;quot;&lt;/span&gt;, shape&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="va"&gt;None&lt;/span&gt;, &lt;span class="dv"&gt;10&lt;/span&gt;])
lr &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(&lt;span class="st"&gt;&amp;quot;float&amp;quot;&lt;/span&gt;)

l1 &lt;span class="op"&gt;=&lt;/span&gt; simple_fc_layer(x, [&lt;span class="dv"&gt;784&lt;/span&gt;,&lt;span class="dv"&gt;100&lt;/span&gt;])
y1 &lt;span class="op"&gt;=&lt;/span&gt; cross_entropy_layer(l1,[&lt;span class="dv"&gt;100&lt;/span&gt;,&lt;span class="dv"&gt;10&lt;/span&gt;])

l2 &lt;span class="op"&gt;=&lt;/span&gt; simple_fc_layer(l1, [&lt;span class="dv"&gt;100&lt;/span&gt;,&lt;span class="dv"&gt;100&lt;/span&gt;])
y2 &lt;span class="op"&gt;=&lt;/span&gt; cross_entropy_layer(l2,[&lt;span class="dv"&gt;100&lt;/span&gt;,&lt;span class="dv"&gt;10&lt;/span&gt;])

l3 &lt;span class="op"&gt;=&lt;/span&gt; simple_fc_layer(l2, [&lt;span class="dv"&gt;100&lt;/span&gt;,&lt;span class="dv"&gt;100&lt;/span&gt;])
y3 &lt;span class="op"&gt;=&lt;/span&gt; cross_entropy_layer(l3,[&lt;span class="dv"&gt;100&lt;/span&gt;,&lt;span class="dv"&gt;10&lt;/span&gt;])


ce1 &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="op"&gt;-&lt;/span&gt;tf.reduce_sum(y_&lt;span class="op"&gt;*&lt;/span&gt;tf.log(y1))
ce2 &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="op"&gt;-&lt;/span&gt;tf.reduce_sum(y_&lt;span class="op"&gt;*&lt;/span&gt;tf.log(y2))
ce3 &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="op"&gt;-&lt;/span&gt;tf.reduce_sum(y_&lt;span class="op"&gt;*&lt;/span&gt;tf.log(y3))

ts1 &lt;span class="op"&gt;=&lt;/span&gt; tf.train.GradientDescentOptimizer(lr).minimize(ce1)
ts2 &lt;span class="op"&gt;=&lt;/span&gt; tf.train.GradientDescentOptimizer(lr).minimize(ce2)
ts3 &lt;span class="op"&gt;=&lt;/span&gt; tf.train.GradientDescentOptimizer(lr).minimize(ce3)

a1 &lt;span class="op"&gt;=&lt;/span&gt; accuracy(y1,y_)
a2 &lt;span class="op"&gt;=&lt;/span&gt; accuracy(y2,y_)
a3 &lt;span class="op"&gt;=&lt;/span&gt; accuracy(y3,y_)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;train3 &lt;span class="op"&gt;=&lt;/span&gt; []
train123 &lt;span class="op"&gt;=&lt;/span&gt; []

&lt;span class="cf"&gt;for&lt;/span&gt; run &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;400&lt;/span&gt;):
    &lt;span class="cf"&gt;with&lt;/span&gt; tf.Session() &lt;span class="im"&gt;as&lt;/span&gt; sess:
        sess.run(tf.initialize_all_variables())
        &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;1000&lt;/span&gt;):
            start &lt;span class="op"&gt;=&lt;/span&gt; (&lt;span class="dv"&gt;50&lt;/span&gt;&lt;span class="op"&gt;*&lt;/span&gt;i) &lt;span class="op"&gt;%&lt;/span&gt; &lt;span class="dv"&gt;1000&lt;/span&gt;
            end &lt;span class="op"&gt;=&lt;/span&gt; start &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;50&lt;/span&gt;
            learning_rate &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="fl"&gt;0.01&lt;/span&gt; &lt;span class="cf"&gt;if&lt;/span&gt; i &lt;span class="op"&gt;&amp;lt;&lt;/span&gt; &lt;span class="dv"&gt;750&lt;/span&gt; &lt;span class="cf"&gt;else&lt;/span&gt; &lt;span class="fl"&gt;0.003&lt;/span&gt;
            ts3.run(feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{x: mnist.train.images[start:end], y_: mnist.train.labels[start:end], lr:learning_rate})
        res &lt;span class="op"&gt;=&lt;/span&gt; a3.&lt;span class="bu"&gt;eval&lt;/span&gt;(feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{x: mnist.test.images, y_: mnist.test.labels})
        &lt;span class="bu"&gt;print&lt;/span&gt;(res, end&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;&lt;span class="ch"&gt;\r&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;)
        train3.append(res)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="cf"&gt;for&lt;/span&gt; run &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;400&lt;/span&gt;):
    &lt;span class="cf"&gt;with&lt;/span&gt; tf.Session() &lt;span class="im"&gt;as&lt;/span&gt; sess:
        sess.run(tf.initialize_all_variables())
        &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;200&lt;/span&gt;):
            start &lt;span class="op"&gt;=&lt;/span&gt; (&lt;span class="dv"&gt;50&lt;/span&gt;&lt;span class="op"&gt;*&lt;/span&gt;i) &lt;span class="op"&gt;%&lt;/span&gt; &lt;span class="dv"&gt;1000&lt;/span&gt;
            end &lt;span class="op"&gt;=&lt;/span&gt; start &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;50&lt;/span&gt;
            ts1.run(feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{x: mnist.train.images[start:end], y_: mnist.train.labels[start:end], lr: &lt;span class="fl"&gt;0.01&lt;/span&gt;})
        &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;200&lt;/span&gt;):
            start &lt;span class="op"&gt;=&lt;/span&gt; (&lt;span class="dv"&gt;50&lt;/span&gt;&lt;span class="op"&gt;*&lt;/span&gt;i) &lt;span class="op"&gt;%&lt;/span&gt; &lt;span class="dv"&gt;1000&lt;/span&gt;
            end &lt;span class="op"&gt;=&lt;/span&gt; start &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;50&lt;/span&gt;
            ts2.run(feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{x: mnist.train.images[start:end], y_: mnist.train.labels[start:end], lr: &lt;span class="fl"&gt;0.01&lt;/span&gt;})
        &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;1000&lt;/span&gt;):
            start &lt;span class="op"&gt;=&lt;/span&gt; (&lt;span class="dv"&gt;50&lt;/span&gt;&lt;span class="op"&gt;*&lt;/span&gt;i) &lt;span class="op"&gt;%&lt;/span&gt; &lt;span class="dv"&gt;1000&lt;/span&gt;
            end &lt;span class="op"&gt;=&lt;/span&gt; start &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;50&lt;/span&gt;
            learning_rate &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="fl"&gt;0.01&lt;/span&gt; &lt;span class="cf"&gt;if&lt;/span&gt; i &lt;span class="op"&gt;&amp;lt;&lt;/span&gt; &lt;span class="dv"&gt;750&lt;/span&gt; &lt;span class="cf"&gt;else&lt;/span&gt; &lt;span class="fl"&gt;0.003&lt;/span&gt;
            ts3.run(feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{x: mnist.train.images[start:end], y_: mnist.train.labels[start:end], lr:learning_rate})
        res &lt;span class="op"&gt;=&lt;/span&gt; a3.&lt;span class="bu"&gt;eval&lt;/span&gt;(feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{x: mnist.test.images, y_: mnist.test.labels})
        &lt;span class="bu"&gt;print&lt;/span&gt;(res, end&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;&lt;span class="ch"&gt;\r&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;)
        train123.append(res)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;sns.distplot(train3,label&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;Train all layers&amp;quot;&lt;/span&gt;)
sns.distplot(train123,label&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;Train layer-by-layer&amp;quot;&lt;/span&gt;)
plt.legend()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/FCB_output_12_2.png" /&gt;
&lt;/figure&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;Mean and standard deviation of training all layers: &amp;quot;&lt;/span&gt; &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="bu"&gt;str&lt;/span&gt;(np.mean(train3)) &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;, &amp;quot;&lt;/span&gt; &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="bu"&gt;str&lt;/span&gt;(np.std(train3)))
&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;Mean and standard deviation of layer-wise training: &amp;quot;&lt;/span&gt; &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="bu"&gt;str&lt;/span&gt;(np.mean(train123)) &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;, &amp;quot;&lt;/span&gt; &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="bu"&gt;str&lt;/span&gt;(np.std(train123)))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Mean and standard deviation of training all layers: 0.87867, 0.00274425
Mean and standard deviation of layer-wise training: 0.876439, 0.00234411&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</content></entry><entry><title>Inverting a Neural Net</title><link href="https://r2rt.com/inverting-a-neural-net.html" rel="alternate"></link><published>2016-04-05T00:00:00-04:00</published><updated>2016-04-05T00:00:00-04:00</updated><author><name>Silviu Pitis</name></author><id>tag:r2rt.com,2016-04-05:/inverting-a-neural-net.html</id><summary type="html">In this experiment, I "invert" a simple two-layer MNIST model to visualize what the final hidden layer representations look like when projected back into the original sample space.</summary><content type="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;meta name="generator" content="pandoc"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes"&gt;
  &lt;title&gt;&lt;/title&gt;
  &lt;style type="text/css"&gt;code{white-space: pre;}&lt;/style&gt;
  &lt;style type="text/css"&gt;
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code &gt; span.kw { color: #007020; font-weight: bold; } /* Keyword */
code &gt; span.dt { color: #902000; } /* DataType */
code &gt; span.dv { color: #40a070; } /* DecVal */
code &gt; span.bn { color: #40a070; } /* BaseN */
code &gt; span.fl { color: #40a070; } /* Float */
code &gt; span.ch { color: #4070a0; } /* Char */
code &gt; span.st { color: #4070a0; } /* String */
code &gt; span.co { color: #60a0b0; font-style: italic; } /* Comment */
code &gt; span.ot { color: #007020; } /* Other */
code &gt; span.al { color: #ff0000; font-weight: bold; } /* Alert */
code &gt; span.fu { color: #06287e; } /* Function */
code &gt; span.er { color: #ff0000; font-weight: bold; } /* Error */
code &gt; span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code &gt; span.cn { color: #880000; } /* Constant */
code &gt; span.sc { color: #4070a0; } /* SpecialChar */
code &gt; span.vs { color: #4070a0; } /* VerbatimString */
code &gt; span.ss { color: #bb6688; } /* SpecialString */
code &gt; span.im { } /* Import */
code &gt; span.va { color: #19177c; } /* Variable */
code &gt; span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code &gt; span.op { color: #666666; } /* Operator */
code &gt; span.bu { } /* BuiltIn */
code &gt; span.ex { } /* Extension */
code &gt; span.pp { color: #bc7a00; } /* Preprocessor */
code &gt; span.at { color: #7d9029; } /* Attribute */
code &gt; span.do { color: #ba2121; font-style: italic; } /* Documentation */
code &gt; span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code &gt; span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code &gt; span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  &lt;/style&gt;
  &lt;!--[if lt IE 9]&gt;
    &lt;script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"&gt;&lt;/script&gt;
  &lt;![endif]--&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;In this experiment, I “invert” a simple two-layer MNIST model to visualize what the final hidden layer representations look like when projected back into the original sample space.&lt;/p&gt;
&lt;p&gt;[&lt;strong&gt;Note 2017/03/05&lt;/strong&gt;: At the time of writing this post, I did not know what an autoencoder was.]&lt;/p&gt;
&lt;h3 id="model-setup"&gt;Model Setup&lt;/h3&gt;
&lt;p&gt;This is a fully-connected model with two-hidden layers of 100 hidden neurons. The model also contains inverse weight matrices (&lt;code&gt;w2_inv&lt;/code&gt; and &lt;code&gt;w1_inv&lt;/code&gt;) that are trained after the fact by minimizing the l1 difference (&lt;code&gt;x_inv_similarity&lt;/code&gt;) between the inverse projection of a sample and the original sample.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="im"&gt;import&lt;/span&gt; tensorflow &lt;span class="im"&gt;as&lt;/span&gt; tf
&lt;span class="im"&gt;import&lt;/span&gt; numpy &lt;span class="im"&gt;as&lt;/span&gt; np
&lt;span class="im"&gt;import&lt;/span&gt; load_mnist
&lt;span class="im"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class="im"&gt;as&lt;/span&gt; plt
&lt;span class="im"&gt;import&lt;/span&gt; matplotlib.image &lt;span class="im"&gt;as&lt;/span&gt; mpimg
&lt;span class="im"&gt;import&lt;/span&gt; matplotlib.cm &lt;span class="im"&gt;as&lt;/span&gt; cm
&lt;span class="im"&gt;from&lt;/span&gt; mpl_toolkits.axes_grid1 &lt;span class="im"&gt;import&lt;/span&gt; ImageGrid
&lt;span class="op"&gt;%&lt;/span&gt;matplotlib inline
mnist &lt;span class="op"&gt;=&lt;/span&gt; load_mnist.read_data_sets(&lt;span class="st"&gt;&amp;#39;MNIST_data&amp;#39;&lt;/span&gt;, one_hot&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)
sess &lt;span class="op"&gt;=&lt;/span&gt; tf.InteractiveSession()

&lt;span class="kw"&gt;def&lt;/span&gt; weight_variable(shape,name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;None&lt;/span&gt;):
    initial &lt;span class="op"&gt;=&lt;/span&gt; tf.truncated_normal(shape, stddev&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.1&lt;/span&gt;)
    &lt;span class="cf"&gt;return&lt;/span&gt; tf.Variable(initial,name&lt;span class="op"&gt;=&lt;/span&gt;name)

&lt;span class="kw"&gt;def&lt;/span&gt; bias_variable(shape):
  initial &lt;span class="op"&gt;=&lt;/span&gt; tf.constant(&lt;span class="fl"&gt;0.1&lt;/span&gt;, shape&lt;span class="op"&gt;=&lt;/span&gt;shape)
  &lt;span class="cf"&gt;return&lt;/span&gt; tf.Variable(initial)


&lt;span class="kw"&gt;def&lt;/span&gt; logit(p):
    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;element-wise logit of tensor p&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="cf"&gt;return&lt;/span&gt; tf.log(tf.div(p,&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="op"&gt;-&lt;/span&gt;p))

&lt;span class="kw"&gt;def&lt;/span&gt; squash(p, dim):
    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;element-wise squash of dim of tensor MxN p to be between 0 and 1&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    p_ &lt;span class="op"&gt;=&lt;/span&gt; p &lt;span class="op"&gt;-&lt;/span&gt; tf.reduce_min(p,dim,keep_dims&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;) &lt;span class="co"&gt;# add the minimum so all above 0&lt;/span&gt;
    p_norm &lt;span class="op"&gt;=&lt;/span&gt; (p_ &lt;span class="op"&gt;/&lt;/span&gt; tf.reduce_max(p_,dim,keep_dims&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;))
    p_norm_ &lt;span class="op"&gt;=&lt;/span&gt; (p_norm &lt;span class="op"&gt;-&lt;/span&gt; &lt;span class="fl"&gt;0.5&lt;/span&gt;) &lt;span class="op"&gt;*&lt;/span&gt; &lt;span class="fl"&gt;0.99&lt;/span&gt; &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="fl"&gt;0.5&lt;/span&gt; &lt;span class="co"&gt;#squashs to be strictly 0 &amp;lt; p_norm_ &amp;lt; 1&lt;/span&gt;
    &lt;span class="cf"&gt;return&lt;/span&gt; p_norm_

x &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(&lt;span class="st"&gt;&amp;quot;float&amp;quot;&lt;/span&gt;, shape&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="va"&gt;None&lt;/span&gt;, &lt;span class="dv"&gt;784&lt;/span&gt;])
y_ &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(&lt;span class="st"&gt;&amp;quot;float&amp;quot;&lt;/span&gt;, shape&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="va"&gt;None&lt;/span&gt;, &lt;span class="dv"&gt;10&lt;/span&gt;])

w1 &lt;span class="op"&gt;=&lt;/span&gt; weight_variable([&lt;span class="dv"&gt;784&lt;/span&gt;,&lt;span class="dv"&gt;100&lt;/span&gt;])
b1 &lt;span class="op"&gt;=&lt;/span&gt; bias_variable([&lt;span class="dv"&gt;100&lt;/span&gt;])
l1 &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.sigmoid(tf.matmul(x,w1) &lt;span class="op"&gt;+&lt;/span&gt; b1) &lt;span class="co"&gt;#100&lt;/span&gt;

w2 &lt;span class="op"&gt;=&lt;/span&gt; weight_variable([&lt;span class="dv"&gt;100&lt;/span&gt;,&lt;span class="dv"&gt;100&lt;/span&gt;])
b2 &lt;span class="op"&gt;=&lt;/span&gt; bias_variable([&lt;span class="dv"&gt;100&lt;/span&gt;])
l2 &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.sigmoid(tf.matmul(l1,w2) &lt;span class="op"&gt;+&lt;/span&gt; b2) &lt;span class="co"&gt;#100&lt;/span&gt;

w2_inv &lt;span class="op"&gt;=&lt;/span&gt; weight_variable([&lt;span class="dv"&gt;100&lt;/span&gt;,&lt;span class="dv"&gt;100&lt;/span&gt;])
l1_inv &lt;span class="op"&gt;=&lt;/span&gt; tf.matmul(logit(l2) &lt;span class="op"&gt;-&lt;/span&gt; b2, w2_inv)
l1_inv_norm &lt;span class="op"&gt;=&lt;/span&gt; squash(l1_inv, &lt;span class="dv"&gt;1&lt;/span&gt;)

&lt;span class="co"&gt;# this &amp;quot;excess l1 inv&amp;quot; is minimized so as to try to get the l1_inv to be compatible&lt;/span&gt;
&lt;span class="co"&gt;# with the logit (inverse sigmoid) function without requiring the squash operation&lt;/span&gt;
excess_l1_inv &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.l2_loss(tf.reduce_min(l1_inv)) &lt;span class="op"&gt;+&lt;/span&gt; tf.nn.l2_loss(tf.reduce_max(l1_inv &lt;span class="op"&gt;-&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;))

w1_inv &lt;span class="op"&gt;=&lt;/span&gt; weight_variable([&lt;span class="dv"&gt;100&lt;/span&gt;,&lt;span class="dv"&gt;784&lt;/span&gt;])
x_inv &lt;span class="op"&gt;=&lt;/span&gt; tf.matmul(logit(l1_inv_norm) &lt;span class="op"&gt;-&lt;/span&gt; b1,w1_inv)

w &lt;span class="op"&gt;=&lt;/span&gt; weight_variable([&lt;span class="dv"&gt;100&lt;/span&gt;,&lt;span class="dv"&gt;10&lt;/span&gt;])
b &lt;span class="op"&gt;=&lt;/span&gt; bias_variable([&lt;span class="dv"&gt;10&lt;/span&gt;])
y &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.softmax(tf.matmul(l2,w) &lt;span class="op"&gt;+&lt;/span&gt; b)

cross_entropy &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="op"&gt;-&lt;/span&gt;tf.reduce_sum(y_&lt;span class="op"&gt;*&lt;/span&gt;tf.log(y))
x_inv_similarity &lt;span class="op"&gt;=&lt;/span&gt; tf.reduce_sum(tf.&lt;span class="bu"&gt;abs&lt;/span&gt;(x &lt;span class="op"&gt;-&lt;/span&gt; x_inv))

opt &lt;span class="op"&gt;=&lt;/span&gt; tf.train.AdagradOptimizer(&lt;span class="fl"&gt;0.01&lt;/span&gt;)
grads &lt;span class="op"&gt;=&lt;/span&gt; opt.compute_gradients(x_inv_similarity&lt;span class="op"&gt;+&lt;/span&gt;excess_l1_inv, [w1_inv, w2_inv])
inv_train_step &lt;span class="op"&gt;=&lt;/span&gt; opt.apply_gradients(grads)

train_step &lt;span class="op"&gt;=&lt;/span&gt; tf.train.AdagradOptimizer(&lt;span class="fl"&gt;0.01&lt;/span&gt;).minimize(cross_entropy)

sess.run(tf.initialize_all_variables())

correct_prediction &lt;span class="op"&gt;=&lt;/span&gt; tf.equal(tf.argmax(y,&lt;span class="dv"&gt;1&lt;/span&gt;), tf.argmax(y_,&lt;span class="dv"&gt;1&lt;/span&gt;))
accuracy &lt;span class="op"&gt;=&lt;/span&gt; tf.reduce_mean(tf.cast(correct_prediction, &lt;span class="st"&gt;&amp;quot;float&amp;quot;&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="training-the-model"&gt;Training the Model&lt;/h3&gt;
&lt;p&gt;First, we train the model, and then we train the inverse operations. The model achieves an accuracy of about 95%. Because we don’t want to confuse the inverse training with bad samples, we only train the model using samples that the model itself is confident it has classified correctly. This reduces noise in the inverse projections.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;2000&lt;/span&gt;):
    batch &lt;span class="op"&gt;=&lt;/span&gt; mnist.train.next_batch(&lt;span class="dv"&gt;1000&lt;/span&gt;)
    train_step.run(feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{x: batch[&lt;span class="dv"&gt;0&lt;/span&gt;], y_: batch[&lt;span class="dv"&gt;1&lt;/span&gt;]})
    &lt;span class="cf"&gt;if&lt;/span&gt; i &lt;span class="op"&gt;%&lt;/span&gt; &lt;span class="dv"&gt;100&lt;/span&gt; &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;:
        &lt;span class="bu"&gt;print&lt;/span&gt;(i,end&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot; &amp;quot;&lt;/span&gt;)
        &lt;span class="bu"&gt;print&lt;/span&gt;(accuracy.&lt;span class="bu"&gt;eval&lt;/span&gt;(feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{x: mnist.test.images,
                                       y_: mnist.test.labels}), end&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;&lt;span class="ch"&gt;\r&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;)

&lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;1000&lt;/span&gt;):
    batch &lt;span class="op"&gt;=&lt;/span&gt; mnist.train.next_batch(&lt;span class="dv"&gt;1000&lt;/span&gt;)
    confidence &lt;span class="op"&gt;=&lt;/span&gt; np.&lt;span class="bu"&gt;max&lt;/span&gt;(y.&lt;span class="bu"&gt;eval&lt;/span&gt;(feed_dict&lt;span class="op"&gt;=&lt;/span&gt; {x: batch[&lt;span class="dv"&gt;0&lt;/span&gt;]}),axis&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;)
    inv_train_step.run(feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{x: batch[&lt;span class="dv"&gt;0&lt;/span&gt;][confidence&lt;span class="op"&gt;&amp;gt;&lt;/span&gt;.&lt;span class="dv"&gt;8&lt;/span&gt;], y_: batch[&lt;span class="dv"&gt;1&lt;/span&gt;][confidence&lt;span class="op"&gt;&amp;gt;&lt;/span&gt;.&lt;span class="dv"&gt;8&lt;/span&gt;]})
    &lt;span class="cf"&gt;if&lt;/span&gt; i &lt;span class="op"&gt;%&lt;/span&gt; &lt;span class="dv"&gt;100&lt;/span&gt; &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;:
        &lt;span class="bu"&gt;print&lt;/span&gt;(i,end&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;&lt;span class="ch"&gt;\r&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;)

&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;Final Accuracy: &amp;quot;&lt;/span&gt; &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="bu"&gt;str&lt;/span&gt;(accuracy.&lt;span class="bu"&gt;eval&lt;/span&gt;(feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{x: mnist.test.images,
                                       y_: mnist.test.labels})))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Final Accuracy: 0.9521&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="visualizing-inverse-projections"&gt;Visualizing inverse projections&lt;/h3&gt;
&lt;p&gt;We now show a visual comparison of the first 36 test samples and their projections.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; plot_nxn(n, images):
    images &lt;span class="op"&gt;=&lt;/span&gt; images.reshape((n&lt;span class="op"&gt;*&lt;/span&gt;n,&lt;span class="dv"&gt;28&lt;/span&gt;,&lt;span class="dv"&gt;28&lt;/span&gt;))
    fig &lt;span class="op"&gt;=&lt;/span&gt; plt.figure(&lt;span class="dv"&gt;1&lt;/span&gt;, (n, n))
    grid &lt;span class="op"&gt;=&lt;/span&gt; ImageGrid(fig, &lt;span class="dv"&gt;111&lt;/span&gt;,  &lt;span class="co"&gt;# similar to subplot(111)&lt;/span&gt;
                     nrows_ncols&lt;span class="op"&gt;=&lt;/span&gt;(n, n),  &lt;span class="co"&gt;# creates grid of axes&lt;/span&gt;
                     axes_pad&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.1&lt;/span&gt;,  &lt;span class="co"&gt;# pad between axes in inch.&lt;/span&gt;
                     )

    &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(n&lt;span class="op"&gt;*&lt;/span&gt;n):
        grid[i].imshow(images[i], cmap &lt;span class="op"&gt;=&lt;/span&gt; cm.Greys_r)  &lt;span class="co"&gt;# The AxesGrid object work as a list of axes.&lt;/span&gt;

    plt.show()

plot_nxn(&lt;span class="dv"&gt;6&lt;/span&gt;,mnist.test.images[:&lt;span class="dv"&gt;36&lt;/span&gt;])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/INN_output_11_0.png" /&gt;
&lt;/figure&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;x1 &lt;span class="op"&gt;=&lt;/span&gt; x_inv.&lt;span class="bu"&gt;eval&lt;/span&gt;(feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{x: mnist.test.images})[:&lt;span class="dv"&gt;36&lt;/span&gt;]
plot_nxn(&lt;span class="dv"&gt;6&lt;/span&gt;,x1)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/INN_output_13_0.png" /&gt;
&lt;/figure&gt;
&lt;p&gt;I think the most interesting this about this is how the model completely transforms the misclassified digits. For example, the 9th sample and the 3rd to last sample each get transformed to a 6.&lt;/p&gt;
&lt;p&gt;It’s also interesting that the inverse projections are somewhat “idealized” versions of each digit. For example, the orientations of the inversely projected 3s and 9s and the stroke width of the inversely projected 0s are now all the same.&lt;/p&gt;
&lt;h3 id="generating-samples"&gt;Generating samples&lt;/h3&gt;
&lt;p&gt;Here we generate samples of digits 1-9 by first optimizing the hidden representation so that the neural network is confident that the representaton is of a specific class, and then outputting the inverse projection.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; generate(n_samples,fake_labels):
    &lt;span class="kw"&gt;global&lt;/span&gt; w
    &lt;span class="kw"&gt;global&lt;/span&gt; b
    fake_l2 &lt;span class="op"&gt;=&lt;/span&gt; tf.Variable(tf.zeros([n_samples, &lt;span class="dv"&gt;100&lt;/span&gt;]))
    fake_y &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.softmax(tf.matmul(tf.nn.sigmoid(fake_l2),w) &lt;span class="op"&gt;+&lt;/span&gt; b)
    fake_labels &lt;span class="op"&gt;=&lt;/span&gt; tf.constant(fake_labels)
    diff &lt;span class="op"&gt;=&lt;/span&gt; tf.reduce_sum(tf.&lt;span class="bu"&gt;abs&lt;/span&gt;(fake_labels &lt;span class="op"&gt;-&lt;/span&gt; fake_y))
    &lt;span class="co"&gt;#train the fake_l2 to minimize diff&lt;/span&gt;
    opt &lt;span class="op"&gt;=&lt;/span&gt; tf.train.GradientDescentOptimizer(&lt;span class="fl"&gt;1.&lt;/span&gt;)
    grads &lt;span class="op"&gt;=&lt;/span&gt; opt.compute_gradients(diff, [fake_l2])
    tstep &lt;span class="op"&gt;=&lt;/span&gt; opt.apply_gradients(grads)
    sess.run(tf.initialize_variables([fake_l2]))

    &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;1000&lt;/span&gt;):
        tstep.run()

    fake_l1_inv &lt;span class="op"&gt;=&lt;/span&gt; tf.matmul(fake_l2 &lt;span class="op"&gt;-&lt;/span&gt; b2, w2_inv)
    fake_l1_inv_norm &lt;span class="op"&gt;=&lt;/span&gt; squash(fake_l1_inv,&lt;span class="dv"&gt;1&lt;/span&gt;)
    fake_x_inv &lt;span class="op"&gt;=&lt;/span&gt; tf.matmul(logit(fake_l1_inv_norm) &lt;span class="op"&gt;-&lt;/span&gt; b1,w1_inv)

    &lt;span class="cf"&gt;return&lt;/span&gt; fake_x_inv.&lt;span class="bu"&gt;eval&lt;/span&gt;(), fake_y.&lt;span class="bu"&gt;eval&lt;/span&gt;()


genned, fakes &lt;span class="op"&gt;=&lt;/span&gt; generate(&lt;span class="dv"&gt;9&lt;/span&gt;, np.eye(&lt;span class="dv"&gt;10&lt;/span&gt;)[[&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;2&lt;/span&gt;,&lt;span class="dv"&gt;3&lt;/span&gt;,&lt;span class="dv"&gt;4&lt;/span&gt;,&lt;span class="dv"&gt;5&lt;/span&gt;,&lt;span class="dv"&gt;6&lt;/span&gt;,&lt;span class="dv"&gt;7&lt;/span&gt;,&lt;span class="dv"&gt;8&lt;/span&gt;,&lt;span class="dv"&gt;9&lt;/span&gt;]].astype(&lt;span class="st"&gt;&amp;quot;float32&amp;quot;&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here we see that the network is over 99.5% confident that each of its hidden layer representations are good representations. Below that we see their inverse projections.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;np.&lt;span class="bu"&gt;max&lt;/span&gt;(fakes,axis&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;array([ 0.99675035,  0.99740452,  0.99649602,  0.99652439,  0.99734575,
        0.99607605,  0.99735802,  0.99755549,  0.99680138], dtype=float32)&lt;/code&gt;&lt;/pre&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;plot_nxn(&lt;span class="dv"&gt;3&lt;/span&gt;,genned)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/INN_output_20_0.png" /&gt;
&lt;/figure&gt;
&lt;p&gt;A bit noisy, but it works!&lt;/p&gt;
&lt;h3 id="visualizing-features"&gt;Visualizing Features&lt;/h3&gt;
&lt;p&gt;We will now show the inverse projection of each of the 100 features of the hidden representation, to get an idea of what the neural network has learned. Unfortunately, the noise is overwhelming, but we can sort of make out shadows of the learned features.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; generate_features():
    fake_l2 &lt;span class="op"&gt;=&lt;/span&gt; tf.constant(np.eye(&lt;span class="dv"&gt;100&lt;/span&gt;).astype(&lt;span class="st"&gt;&amp;quot;float32&amp;quot;&lt;/span&gt;)&lt;span class="op"&gt;*&lt;/span&gt;(&lt;span class="fl"&gt;1e8&lt;/span&gt;))
    fake_l1_inv &lt;span class="op"&gt;=&lt;/span&gt; tf.matmul(fake_l2 &lt;span class="op"&gt;-&lt;/span&gt; b2, w2_inv)
    fake_l1_inv_norm &lt;span class="op"&gt;=&lt;/span&gt; squash(fake_l1_inv,&lt;span class="dv"&gt;1&lt;/span&gt;)
    fake_x_inv &lt;span class="op"&gt;=&lt;/span&gt; tf.matmul(logit(fake_l1_inv_norm) &lt;span class="op"&gt;-&lt;/span&gt; b1,w1_inv)
    &lt;span class="cf"&gt;return&lt;/span&gt; fake_x_inv.&lt;span class="bu"&gt;eval&lt;/span&gt;()


genned &lt;span class="op"&gt;=&lt;/span&gt; generate_features()
plot_nxn(&lt;span class="dv"&gt;10&lt;/span&gt;,np.&lt;span class="bu"&gt;round&lt;/span&gt;(genned,&lt;span class="dv"&gt;1&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/INN_output_24_0.png" /&gt;
&lt;/figure&gt;
&lt;/body&gt;
&lt;/html&gt;
</content></entry><entry><title>Representational Power of Deeper Layers</title><link href="https://r2rt.com/representational-power-of-deeper-layers.html" rel="alternate"></link><published>2016-03-30T00:00:00-04:00</published><updated>2016-03-30T00:00:00-04:00</updated><author><name>Silviu Pitis</name></author><id>tag:r2rt.com,2016-03-30:/representational-power-of-deeper-layers.html</id><summary type="html">The hidden layers in a neural network can be seen as different representations of the input. Do deeper layers learn "better" representations? In a network trained to solve a classification problem, this would mean that deeper layers provide better features than earlier layers. The natural hypothesis is that this is indeed the case. In this post, I test this hypothesis on an network with three hidden layers trained to classify the MNIST dataset. It is shown that deeper layers do in fact produce better representations of the input.</summary><content type="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;meta name="generator" content="pandoc"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes"&gt;
  &lt;title&gt;&lt;/title&gt;
  &lt;style type="text/css"&gt;code{white-space: pre;}&lt;/style&gt;
  &lt;style type="text/css"&gt;
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code &gt; span.kw { color: #007020; font-weight: bold; } /* Keyword */
code &gt; span.dt { color: #902000; } /* DataType */
code &gt; span.dv { color: #40a070; } /* DecVal */
code &gt; span.bn { color: #40a070; } /* BaseN */
code &gt; span.fl { color: #40a070; } /* Float */
code &gt; span.ch { color: #4070a0; } /* Char */
code &gt; span.st { color: #4070a0; } /* String */
code &gt; span.co { color: #60a0b0; font-style: italic; } /* Comment */
code &gt; span.ot { color: #007020; } /* Other */
code &gt; span.al { color: #ff0000; font-weight: bold; } /* Alert */
code &gt; span.fu { color: #06287e; } /* Function */
code &gt; span.er { color: #ff0000; font-weight: bold; } /* Error */
code &gt; span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code &gt; span.cn { color: #880000; } /* Constant */
code &gt; span.sc { color: #4070a0; } /* SpecialChar */
code &gt; span.vs { color: #4070a0; } /* VerbatimString */
code &gt; span.ss { color: #bb6688; } /* SpecialString */
code &gt; span.im { } /* Import */
code &gt; span.va { color: #19177c; } /* Variable */
code &gt; span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code &gt; span.op { color: #666666; } /* Operator */
code &gt; span.bu { } /* BuiltIn */
code &gt; span.ex { } /* Extension */
code &gt; span.pp { color: #bc7a00; } /* Preprocessor */
code &gt; span.at { color: #7d9029; } /* Attribute */
code &gt; span.do { color: #ba2121; font-style: italic; } /* Documentation */
code &gt; span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code &gt; span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code &gt; span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  &lt;/style&gt;
  &lt;!--[if lt IE 9]&gt;
    &lt;script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"&gt;&lt;/script&gt;
  &lt;![endif]--&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;The hidden layers in a neural network can be seen as different representations of the input. Do deeper layers learn “better” representations? In a network trained to solve a classification problem, this would mean that deeper layers provide better features than earlier layers. The natural hypothesis is that this is indeed the case. In this post, I test this hypothesis on an network with three hidden layers trained to classify the MNIST dataset. It is shown that deeper layers do in fact produce better representations of the input.&lt;/p&gt;
&lt;h3 id="model-setup"&gt;Model setup&lt;/h3&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="im"&gt;import&lt;/span&gt; tensorflow &lt;span class="im"&gt;as&lt;/span&gt; tf
&lt;span class="im"&gt;import&lt;/span&gt; numpy &lt;span class="im"&gt;as&lt;/span&gt; np
&lt;span class="im"&gt;import&lt;/span&gt; load_mnist
&lt;span class="im"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class="im"&gt;as&lt;/span&gt; plt
&lt;span class="op"&gt;%&lt;/span&gt;matplotlib inline
mnist &lt;span class="op"&gt;=&lt;/span&gt; load_mnist.read_data_sets(&lt;span class="st"&gt;&amp;#39;MNIST_data&amp;#39;&lt;/span&gt;, one_hot&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)

sess &lt;span class="op"&gt;=&lt;/span&gt; tf.InteractiveSession()

&lt;span class="kw"&gt;def&lt;/span&gt; weight_variable(shape):
  initial &lt;span class="op"&gt;=&lt;/span&gt; tf.truncated_normal(shape, stddev&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.1&lt;/span&gt;)
  &lt;span class="cf"&gt;return&lt;/span&gt; tf.Variable(initial)

&lt;span class="kw"&gt;def&lt;/span&gt; bias_variable(shape):
  initial &lt;span class="op"&gt;=&lt;/span&gt; tf.constant(&lt;span class="fl"&gt;0.1&lt;/span&gt;, shape&lt;span class="op"&gt;=&lt;/span&gt;shape)
  &lt;span class="cf"&gt;return&lt;/span&gt; tf.Variable(initial)

&lt;span class="kw"&gt;def&lt;/span&gt; simple_fc_layer(input_layer, shape):
    w &lt;span class="op"&gt;=&lt;/span&gt; weight_variable(shape)
    b &lt;span class="op"&gt;=&lt;/span&gt; bias_variable([shape[&lt;span class="dv"&gt;1&lt;/span&gt;]])
    &lt;span class="cf"&gt;return&lt;/span&gt; tf.nn.tanh(tf.matmul(input_layer,w) &lt;span class="op"&gt;+&lt;/span&gt; b)

x &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(&lt;span class="st"&gt;&amp;quot;float&amp;quot;&lt;/span&gt;, shape&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="va"&gt;None&lt;/span&gt;, &lt;span class="dv"&gt;784&lt;/span&gt;])
y_ &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(&lt;span class="st"&gt;&amp;quot;float&amp;quot;&lt;/span&gt;, shape&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="va"&gt;None&lt;/span&gt;, &lt;span class="dv"&gt;10&lt;/span&gt;])

l1 &lt;span class="op"&gt;=&lt;/span&gt; simple_fc_layer(x, [&lt;span class="dv"&gt;784&lt;/span&gt;,&lt;span class="dv"&gt;100&lt;/span&gt;])
l2 &lt;span class="op"&gt;=&lt;/span&gt; simple_fc_layer(l1, [&lt;span class="dv"&gt;100&lt;/span&gt;,&lt;span class="dv"&gt;100&lt;/span&gt;])
l3 &lt;span class="op"&gt;=&lt;/span&gt; simple_fc_layer(l2, [&lt;span class="dv"&gt;100&lt;/span&gt;,&lt;span class="dv"&gt;100&lt;/span&gt;])

w &lt;span class="op"&gt;=&lt;/span&gt; weight_variable([&lt;span class="dv"&gt;100&lt;/span&gt;,&lt;span class="dv"&gt;10&lt;/span&gt;])
b &lt;span class="op"&gt;=&lt;/span&gt; bias_variable([&lt;span class="dv"&gt;10&lt;/span&gt;])
y &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.softmax(tf.matmul(l3,w) &lt;span class="op"&gt;+&lt;/span&gt; b)

cross_entropy &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="op"&gt;-&lt;/span&gt;tf.reduce_sum(y_&lt;span class="op"&gt;*&lt;/span&gt;tf.log(y))
train_step &lt;span class="op"&gt;=&lt;/span&gt; tf.train.GradientDescentOptimizer(&lt;span class="fl"&gt;0.01&lt;/span&gt;).minimize(cross_entropy)

sess.run(tf.initialize_all_variables())

saver &lt;span class="op"&gt;=&lt;/span&gt; tf.train.Saver()
saver.save(sess, &lt;span class="st"&gt;&amp;#39;/tmp/initial_variables.ckpt&amp;#39;&lt;/span&gt;)

correct_prediction &lt;span class="op"&gt;=&lt;/span&gt; tf.equal(tf.argmax(y,&lt;span class="dv"&gt;1&lt;/span&gt;), tf.argmax(y_,&lt;span class="dv"&gt;1&lt;/span&gt;))
accuracy &lt;span class="op"&gt;=&lt;/span&gt; tf.reduce_mean(tf.cast(correct_prediction, &lt;span class="st"&gt;&amp;quot;float&amp;quot;&lt;/span&gt;))

base_accuracy &lt;span class="op"&gt;=&lt;/span&gt; []
&lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;10000&lt;/span&gt;):
    start &lt;span class="op"&gt;=&lt;/span&gt; (&lt;span class="dv"&gt;50&lt;/span&gt;&lt;span class="op"&gt;*&lt;/span&gt;i) &lt;span class="op"&gt;%&lt;/span&gt; &lt;span class="dv"&gt;54950&lt;/span&gt;
    end &lt;span class="op"&gt;=&lt;/span&gt; start &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;50&lt;/span&gt;
    train_step.run(feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{x: mnist.train.images[start:end], y_: mnist.train.labels[start:end]})
    &lt;span class="cf"&gt;if&lt;/span&gt; i &lt;span class="op"&gt;%&lt;/span&gt; &lt;span class="dv"&gt;100&lt;/span&gt; &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;:
        base_accuracy.append(accuracy.&lt;span class="bu"&gt;eval&lt;/span&gt;(feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{x: mnist.test.images, y_: mnist.test.labels}))

&lt;span class="bu"&gt;print&lt;/span&gt;(base_accuracy[&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;0.971&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The network achieves an accuracy of about 97% after 10000 training steps in batches of 50 (about 1 epoch of the dataset).&lt;/p&gt;
&lt;h3 id="increasing-representational-power"&gt;Increasing representational power&lt;/h3&gt;
&lt;p&gt;To show increasing representational power, I run logistic regression (supervised) and PCA (unsupervised) models on each layer of the data and show that they perform progressively better with deeper layers.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;x_test, y_test &lt;span class="op"&gt;=&lt;/span&gt; mnist.test.images[:&lt;span class="dv"&gt;1000&lt;/span&gt;], mnist.test.labels[:&lt;span class="dv"&gt;1000&lt;/span&gt;]

y_train_single &lt;span class="op"&gt;=&lt;/span&gt; np.&lt;span class="bu"&gt;sum&lt;/span&gt;((mnist.train.labels[:&lt;span class="dv"&gt;1000&lt;/span&gt;] &lt;span class="op"&gt;*&lt;/span&gt; np.array([&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;2&lt;/span&gt;,&lt;span class="dv"&gt;3&lt;/span&gt;,&lt;span class="dv"&gt;4&lt;/span&gt;,&lt;span class="dv"&gt;5&lt;/span&gt;,&lt;span class="dv"&gt;6&lt;/span&gt;,&lt;span class="dv"&gt;7&lt;/span&gt;,&lt;span class="dv"&gt;8&lt;/span&gt;,&lt;span class="dv"&gt;9&lt;/span&gt;])),axis&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;)
y_test_single &lt;span class="op"&gt;=&lt;/span&gt; np.&lt;span class="bu"&gt;sum&lt;/span&gt;((y_test &lt;span class="op"&gt;*&lt;/span&gt; np.array([&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;2&lt;/span&gt;,&lt;span class="dv"&gt;3&lt;/span&gt;,&lt;span class="dv"&gt;4&lt;/span&gt;,&lt;span class="dv"&gt;5&lt;/span&gt;,&lt;span class="dv"&gt;6&lt;/span&gt;,&lt;span class="dv"&gt;7&lt;/span&gt;,&lt;span class="dv"&gt;8&lt;/span&gt;,&lt;span class="dv"&gt;9&lt;/span&gt;])),axis&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;)

x_arr_test &lt;span class="op"&gt;=&lt;/span&gt; [x_test] &lt;span class="op"&gt;+&lt;/span&gt; sess.run([l1,l2,l3],feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{x:x_test,y_:y_test})
x_arr_train &lt;span class="op"&gt;=&lt;/span&gt; [mnist.train.images[:&lt;span class="dv"&gt;1000&lt;/span&gt;]] &lt;span class="op"&gt;+&lt;/span&gt; sess.run([l1,l2,l3],feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{x:mnist.train.images[:&lt;span class="dv"&gt;1000&lt;/span&gt;],y:mnist.train.labels[:&lt;span class="dv"&gt;1000&lt;/span&gt;]})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="logistic-regression"&gt;Logistic Regression&lt;/h3&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="im"&gt;from&lt;/span&gt; sklearn.linear_model &lt;span class="im"&gt;import&lt;/span&gt; LogisticRegression
log_reg &lt;span class="op"&gt;=&lt;/span&gt; LogisticRegression()

&lt;span class="cf"&gt;for&lt;/span&gt; idx, i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;enumerate&lt;/span&gt;(x_arr_train):
    log_reg.fit(i,y_train_single)
    &lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;Layer &amp;quot;&lt;/span&gt; &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="bu"&gt;str&lt;/span&gt;(idx) &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="st"&gt;&amp;quot; accuracy is: &amp;quot;&lt;/span&gt; &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="bu"&gt;str&lt;/span&gt;(log_reg.score(x_arr_test[idx],y_test_single)))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Layer 0 accuracy is: 0.828
Layer 1 accuracy is: 0.931
Layer 2 accuracy is: 0.953
Layer 3 accuracy is: 0.966&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In support of the hypothesis, logistic regression performs progressively better the deeper the representation. There appear to be decreasing marginal returns to each additional hidden layer, and it would be interesting to see if this pattern holds up for deeper / more complex models.&lt;/p&gt;
&lt;h3 id="pca"&gt;PCA&lt;/h3&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="im"&gt;from&lt;/span&gt; sklearn.decomposition &lt;span class="im"&gt;import&lt;/span&gt; PCA
&lt;span class="im"&gt;from&lt;/span&gt; matplotlib &lt;span class="im"&gt;import&lt;/span&gt; cm
&lt;span class="kw"&gt;def&lt;/span&gt; plot_mnist_pca(axis, x, ix1, ix2, colors, num&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;1000&lt;/span&gt;):
    pca &lt;span class="op"&gt;=&lt;/span&gt; PCA()
    pca.fit(x)
    x_red &lt;span class="op"&gt;=&lt;/span&gt; pca.transform(x)
    axis.scatter(x_red[:num,ix1],x_red[:num,ix2],c&lt;span class="op"&gt;=&lt;/span&gt;colors[:&lt;span class="dv"&gt;1000&lt;/span&gt;],cmap&lt;span class="op"&gt;=&lt;/span&gt;cm.rainbow_r)

&lt;span class="kw"&gt;def&lt;/span&gt; plot(list_to_plot):
    fig,ax &lt;span class="op"&gt;=&lt;/span&gt; plt.subplots(&lt;span class="dv"&gt;3&lt;/span&gt;,&lt;span class="dv"&gt;4&lt;/span&gt;,figsize&lt;span class="op"&gt;=&lt;/span&gt;(&lt;span class="dv"&gt;12&lt;/span&gt;,&lt;span class="dv"&gt;9&lt;/span&gt;))
    fig.tight_layout()
    perms &lt;span class="op"&gt;=&lt;/span&gt; [(&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;1&lt;/span&gt;),(&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;2&lt;/span&gt;),(&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;span class="dv"&gt;2&lt;/span&gt;)]
    colors &lt;span class="op"&gt;=&lt;/span&gt; y_test_single

    index &lt;span class="op"&gt;=&lt;/span&gt; np.zeros(colors.shape)
    &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; list_to_plot:
        index &lt;span class="op"&gt;+=&lt;/span&gt; (colors&lt;span class="op"&gt;==&lt;/span&gt;i)

    &lt;span class="cf"&gt;for&lt;/span&gt; row, axis_row &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;enumerate&lt;/span&gt;(ax):
        &lt;span class="cf"&gt;for&lt;/span&gt; col, axis &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;enumerate&lt;/span&gt;(axis_row):
             plot_mnist_pca(axis, x_arr_test[col][index&lt;span class="op"&gt;==&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;], perms[row][&lt;span class="dv"&gt;0&lt;/span&gt;], perms[row][&lt;span class="dv"&gt;1&lt;/span&gt;], colors[index&lt;span class="op"&gt;==&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;], num&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;1000&lt;/span&gt;)

plot(&lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;4&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/RPDL_output_9_0.png" /&gt;
&lt;/figure&gt;
&lt;p&gt;Each row of the above grid plots combinations (pairs) of the first three principal components with respect to the numbers 0, 1, 2 and 3 (using only 4 numbers at a time makes the separation more visible). The columns, from left to right, correspond to the input layer, the first hidden layer, the second hidden layer and the final hidden layer.&lt;/p&gt;
&lt;p&gt;In support of the hypothesis, the principal components of deeper layers provide visibly better separation of the data than earlier layers.&lt;/p&gt;
&lt;h3 id="a-failed-experiment-teaching-the-neural-network-features"&gt;A failed experiment: teaching the neural network features&lt;/h3&gt;
&lt;p&gt;I had hypothesized that we could use the most prominent features (the top three principal components) of the final hidden layer to train a new neural network and have it perform better. For each training example, in addition to predicting the classification, the new network also performs a regression on the top three principal components of that training example’s third hidden layer representation according to the first model. The training step backpropagates both the classification error and the regression error.&lt;/p&gt;
&lt;p&gt;Unfortunately, this approach did not provide any noticeable improvement over the original model.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;pca &lt;span class="op"&gt;=&lt;/span&gt; PCA()
l3_train &lt;span class="op"&gt;=&lt;/span&gt; l3.&lt;span class="bu"&gt;eval&lt;/span&gt;(feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{x:mnist.train.images})
l3_test  &lt;span class="op"&gt;=&lt;/span&gt; l3.&lt;span class="bu"&gt;eval&lt;/span&gt;(feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{x:mnist.test.images})

pca.fit(l3_train)
y_new_train &lt;span class="op"&gt;=&lt;/span&gt; pca.transform(l3_train)[:,:&lt;span class="dv"&gt;3&lt;/span&gt;]
y_new_test &lt;span class="op"&gt;=&lt;/span&gt; pca.transform(l3_test)[:,:&lt;span class="dv"&gt;3&lt;/span&gt;]

saver.restore(sess, &lt;span class="st"&gt;&amp;#39;/tmp/initial_variables.ckpt&amp;#39;&lt;/span&gt;)

&lt;span class="co"&gt;# create new placeholder for 3 new variables&lt;/span&gt;
y_3newfeatures_ &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(&lt;span class="st"&gt;&amp;quot;float&amp;quot;&lt;/span&gt;, shape&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="va"&gt;None&lt;/span&gt;, &lt;span class="dv"&gt;3&lt;/span&gt;])

&lt;span class="co"&gt;# add linear regression for new features&lt;/span&gt;
w &lt;span class="op"&gt;=&lt;/span&gt; weight_variable([&lt;span class="dv"&gt;100&lt;/span&gt;,&lt;span class="dv"&gt;3&lt;/span&gt;])
b &lt;span class="op"&gt;=&lt;/span&gt; bias_variable([&lt;span class="dv"&gt;3&lt;/span&gt;])
y_3newfeatures &lt;span class="op"&gt;=&lt;/span&gt; tf.matmul(l1,w) &lt;span class="op"&gt;+&lt;/span&gt; b

sess.run(tf.initialize_all_variables())

new_feature_loss &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="fl"&gt;1e-1&lt;/span&gt;&lt;span class="op"&gt;*&lt;/span&gt;tf.reduce_sum(tf.&lt;span class="bu"&gt;abs&lt;/span&gt;(y_3newfeatures_&lt;span class="op"&gt;-&lt;/span&gt;y_3newfeatures))

train_step_new_features &lt;span class="op"&gt;=&lt;/span&gt; tf.train.GradientDescentOptimizer(&lt;span class="fl"&gt;0.01&lt;/span&gt;).minimize(cross_entropy &lt;span class="op"&gt;+&lt;/span&gt; new_feature_loss)

new_accuracy &lt;span class="op"&gt;=&lt;/span&gt; []
&lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;10000&lt;/span&gt;):
    start &lt;span class="op"&gt;=&lt;/span&gt; (&lt;span class="dv"&gt;50&lt;/span&gt;&lt;span class="op"&gt;*&lt;/span&gt;i) &lt;span class="op"&gt;%&lt;/span&gt; &lt;span class="dv"&gt;54950&lt;/span&gt;
    end &lt;span class="op"&gt;=&lt;/span&gt; start &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;50&lt;/span&gt;
    train_step_new_features.run(feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{x: mnist.train.images[start:end], y_: mnist.train.labels[start:end],y_3newfeatures_:y_new_train[start:end]})
    &lt;span class="cf"&gt;if&lt;/span&gt; i &lt;span class="op"&gt;%&lt;/span&gt; &lt;span class="dv"&gt;100&lt;/span&gt; &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;:
        acc, ce, lr &lt;span class="op"&gt;=&lt;/span&gt; sess.run([accuracy, cross_entropy, new_feature_loss],feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{x:mnist.test.images,y_:mnist.test.labels,y_3newfeatures_:y_new_test})
        new_accuracy.append(acc)
        &lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;Accuracy: &amp;quot;&lt;/span&gt; &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="bu"&gt;str&lt;/span&gt;(acc) &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="st"&gt;&amp;quot; -- Cross entropy: &amp;quot;&lt;/span&gt; &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="bu"&gt;str&lt;/span&gt;(ce) &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="st"&gt;&amp;quot; -- New feature loss: &amp;quot;&lt;/span&gt; &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="bu"&gt;str&lt;/span&gt;(lr),end&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;&lt;span class="ch"&gt;\r&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;)

&lt;span class="bu"&gt;print&lt;/span&gt;(new_accuracy[&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;0.9707&lt;/code&gt;&lt;/pre&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;fig, ax &lt;span class="op"&gt;=&lt;/span&gt; plt.subplots()

ax.plot(base_accuracy, label&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;Base&amp;#39;&lt;/span&gt;)
ax.plot(new_accuracy, label&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;New&amp;#39;&lt;/span&gt;)
ax.set_xlabel(&lt;span class="st"&gt;&amp;#39;Training steps&amp;#39;&lt;/span&gt;)
ax.set_ylabel(&lt;span class="st"&gt;&amp;#39;Accuracy&amp;#39;&lt;/span&gt;)
ax.set_title(&lt;span class="st"&gt;&amp;#39;Base vs New Accuracy&amp;#39;&lt;/span&gt;)
ax.legend(loc&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;4&lt;/span&gt;)
plt.show()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/RPDL_output_13_0.png" /&gt;
&lt;/figure&gt;
&lt;/body&gt;
&lt;/html&gt;
</content></entry><entry><title>Implementing Batch Normalization in Tensorflow</title><link href="https://r2rt.com/implementing-batch-normalization-in-tensorflow.html" rel="alternate"></link><published>2016-03-29T00:00:00-04:00</published><updated>2016-03-29T00:00:00-04:00</updated><author><name>Silviu Pitis</name></author><id>tag:r2rt.com,2016-03-29:/implementing-batch-normalization-in-tensorflow.html</id><summary type="html">Batch normalization is deep learning technique introduced in 2015 that enables the use of higher learning rates, acts as a regularizer and can speed up training by 14 times. In this post, I show how to implement batch normalization in Tensorflow.</summary><content type="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;meta name="generator" content="pandoc"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes"&gt;
  &lt;title&gt;&lt;/title&gt;
  &lt;style type="text/css"&gt;code{white-space: pre;}&lt;/style&gt;
  &lt;style type="text/css"&gt;
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code &gt; span.kw { color: #007020; font-weight: bold; } /* Keyword */
code &gt; span.dt { color: #902000; } /* DataType */
code &gt; span.dv { color: #40a070; } /* DecVal */
code &gt; span.bn { color: #40a070; } /* BaseN */
code &gt; span.fl { color: #40a070; } /* Float */
code &gt; span.ch { color: #4070a0; } /* Char */
code &gt; span.st { color: #4070a0; } /* String */
code &gt; span.co { color: #60a0b0; font-style: italic; } /* Comment */
code &gt; span.ot { color: #007020; } /* Other */
code &gt; span.al { color: #ff0000; font-weight: bold; } /* Alert */
code &gt; span.fu { color: #06287e; } /* Function */
code &gt; span.er { color: #ff0000; font-weight: bold; } /* Error */
code &gt; span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code &gt; span.cn { color: #880000; } /* Constant */
code &gt; span.sc { color: #4070a0; } /* SpecialChar */
code &gt; span.vs { color: #4070a0; } /* VerbatimString */
code &gt; span.ss { color: #bb6688; } /* SpecialString */
code &gt; span.im { } /* Import */
code &gt; span.va { color: #19177c; } /* Variable */
code &gt; span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code &gt; span.op { color: #666666; } /* Operator */
code &gt; span.bu { } /* BuiltIn */
code &gt; span.ex { } /* Extension */
code &gt; span.pp { color: #bc7a00; } /* Preprocessor */
code &gt; span.at { color: #7d9029; } /* Attribute */
code &gt; span.do { color: #ba2121; font-style: italic; } /* Documentation */
code &gt; span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code &gt; span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code &gt; span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  &lt;/style&gt;
  &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"&gt;&lt;/script&gt;
  &lt;!--[if lt IE 9]&gt;
    &lt;script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"&gt;&lt;/script&gt;
  &lt;![endif]--&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;Batch normalization, as described in the March 2015 &lt;a href="http://arxiv.org/pdf/1502.03167v3.pdf"&gt;paper&lt;/a&gt; (the BN2015 paper) by Sergey Ioffe and Christian Szegedy, is a simple and effective way to improve the performance of a neural network. In the BN2015 paper, Ioffe and Szegedy show that batch normalization enables the use of higher learning rates, acts as a regularizer and can speed up training by 14 times. In this post, I show how to implement batch normalization in Tensorflow.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit 2018 (that should have been made back in 2016)&lt;/strong&gt;: If you’re just looking for a working implementation, Tensorflow has an easy to use batch_normalization layer in the tf.layers module. Just be sure to wrap your training step in a &lt;code&gt;with tf.control_dependencies(tf.get_collection(tf.GraphKeys.UPDATE_OPS)):&lt;/code&gt; and it will work.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit 07/12/16&lt;/strong&gt;: I’ve updated this post to cover the calculation of population mean and variance at test time in more detail.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit 02/08/16&lt;/strong&gt;: In case you are looking for &lt;strong&gt;&lt;em&gt;recurrent batch normalization&lt;/em&gt;&lt;/strong&gt; (i.e., from &lt;a href="https://arxiv.org/abs/1603.09025"&gt;Cooijmans et al. (2016)&lt;/a&gt;), I have uploaded a working Tensorflow implementation &lt;a href="https://gist.github.com/spitis/27ab7d2a30bbaf5ef431b4a02194ac60"&gt;here&lt;/a&gt;. The only tricky part of the implementation, as compared to the feedforward batch normalization presented this post, is storing separate population variables for different timesteps.&lt;/p&gt;
&lt;h3 id="the-problem"&gt;The problem&lt;/h3&gt;
&lt;p&gt;Batch normalization is intended to solve the following problem: Changes in model parameters during learning change the distributions of the outputs of each hidden layer. This means that later layers need to adapt to these (often noisy) changes during training.&lt;/p&gt;
&lt;h3 id="batch-normalization-in-brief"&gt;Batch normalization in brief&lt;/h3&gt;
&lt;p&gt;To solve this problem, the BN2015 paper propposes the &lt;em&gt;batch normalization&lt;/em&gt; of the input to the activation function of each nuron (e.g., each sigmoid or ReLU function) during training, so that the input to the activation function across each training batch has a mean of 0 and a variance of 1. For example, applying batch normalization to the activation &lt;span class="math inline"&gt;\(\sigma(Wx + b)\)&lt;/span&gt; would result in &lt;span class="math inline"&gt;\(\sigma(BN(Wx + b))\)&lt;/span&gt; where &lt;span class="math inline"&gt;\(BN\)&lt;/span&gt; is the &lt;em&gt;batch normalizing transform&lt;/em&gt;.&lt;/p&gt;
&lt;h3 id="the-batch-normalizing-transform"&gt;The batch normalizing transform&lt;/h3&gt;
&lt;p&gt;To normalize a value across a batch (i.e., to batch normalize the value), we subtract the batch mean, &lt;span class="math inline"&gt;\(\mu_B\)&lt;/span&gt;, and divide the result by the batch standard deviation, &lt;span class="math inline"&gt;\(\sqrt{\sigma^2_B + \epsilon}\)&lt;/span&gt;. Note that a small constant &lt;span class="math inline"&gt;\(\epsilon\)&lt;/span&gt; is added to the variance in order to avoid dividing by zero.&lt;/p&gt;
&lt;p&gt;Thus, the initial batch normalizing transform of a given value, &lt;span class="math inline"&gt;\(x_i\)&lt;/span&gt;, is: &lt;span class="math display"&gt;\[BN_{initial}(x_i) = \frac{x_i - \mu_B}{\sqrt{\sigma^2_B + \epsilon}}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Because the batch normalizing transform given above restricts the inputs to the activation function to a prescribed normal distribution, this can limit the representational power of the layer. Therefore, we allow the network to undo the batch normalizing transform by multiplying by a new scale parameter &lt;span class="math inline"&gt;\(\gamma\)&lt;/span&gt; and adding a new shift parameter &lt;span class="math inline"&gt;\(\beta\)&lt;/span&gt;. &lt;span class="math inline"&gt;\(\gamma\)&lt;/span&gt; and &lt;span class="math inline"&gt;\(\beta\)&lt;/span&gt; are learnable parameters.&lt;/p&gt;
&lt;p&gt;Adding in &lt;span class="math inline"&gt;\(\gamma\)&lt;/span&gt; and &lt;span class="math inline"&gt;\(\beta\)&lt;/span&gt; producing the following final batch normalizing transform: &lt;span class="math display"&gt;\[BN(x_i) = \gamma(\frac{x_i - \mu_B}{\sqrt{\sigma^2_B + \epsilon}}) + \beta\]&lt;/span&gt;&lt;/p&gt;
&lt;h3 id="implementing-batch-normalization-in-tensorflow"&gt;Implementing batch normalization in Tensorflow&lt;/h3&gt;
&lt;p&gt;We will add batch normalization to a basic fully-connected neural network that has two hidden layers of 100 neurons each and show a similar result to Figure 1 (b) and (c) of the BN2015 paper.&lt;/p&gt;
&lt;p&gt;Note that this network is not yet generally suitable for use at test time. See the section &lt;a href="#making-predictions-with-the-model"&gt;Making predictions with the model&lt;/a&gt; below for the reason why, as well as a fixed version.&lt;/p&gt;
&lt;h4 id="imports-config"&gt;Imports, config&lt;/h4&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="im"&gt;import&lt;/span&gt; numpy &lt;span class="im"&gt;as&lt;/span&gt; np, tensorflow &lt;span class="im"&gt;as&lt;/span&gt; tf, tqdm
&lt;span class="im"&gt;from&lt;/span&gt; tensorflow.examples.tutorials.mnist &lt;span class="im"&gt;import&lt;/span&gt; input_data
&lt;span class="im"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class="im"&gt;as&lt;/span&gt; plt
&lt;span class="op"&gt;%&lt;/span&gt;matplotlib inline
mnist &lt;span class="op"&gt;=&lt;/span&gt; input_data.read_data_sets(&lt;span class="st"&gt;&amp;#39;MNIST_data&amp;#39;&lt;/span&gt;, one_hot&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="co"&gt;# Generate predetermined random weights so the networks are similarly initialized&lt;/span&gt;
w1_initial &lt;span class="op"&gt;=&lt;/span&gt; np.random.normal(size&lt;span class="op"&gt;=&lt;/span&gt;(&lt;span class="dv"&gt;784&lt;/span&gt;,&lt;span class="dv"&gt;100&lt;/span&gt;)).astype(np.float32)
w2_initial &lt;span class="op"&gt;=&lt;/span&gt; np.random.normal(size&lt;span class="op"&gt;=&lt;/span&gt;(&lt;span class="dv"&gt;100&lt;/span&gt;,&lt;span class="dv"&gt;100&lt;/span&gt;)).astype(np.float32)
w3_initial &lt;span class="op"&gt;=&lt;/span&gt; np.random.normal(size&lt;span class="op"&gt;=&lt;/span&gt;(&lt;span class="dv"&gt;100&lt;/span&gt;,&lt;span class="dv"&gt;10&lt;/span&gt;)).astype(np.float32)

&lt;span class="co"&gt;# Small epsilon value for the BN transform&lt;/span&gt;
epsilon &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="fl"&gt;1e-3&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="building-the-graph"&gt;Building the graph&lt;/h4&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="co"&gt;# Placeholders&lt;/span&gt;
x &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(tf.float32, shape&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="va"&gt;None&lt;/span&gt;, &lt;span class="dv"&gt;784&lt;/span&gt;])
y_ &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(tf.float32, shape&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="va"&gt;None&lt;/span&gt;, &lt;span class="dv"&gt;10&lt;/span&gt;])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="co"&gt;# Layer 1 without BN&lt;/span&gt;
w1 &lt;span class="op"&gt;=&lt;/span&gt; tf.Variable(w1_initial)
b1 &lt;span class="op"&gt;=&lt;/span&gt; tf.Variable(tf.zeros([&lt;span class="dv"&gt;100&lt;/span&gt;]))
z1 &lt;span class="op"&gt;=&lt;/span&gt; tf.matmul(x,w1)&lt;span class="op"&gt;+&lt;/span&gt;b1
l1 &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.sigmoid(z1)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here is the same layer 1 with batch normalization:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="co"&gt;# Layer 1 with BN&lt;/span&gt;
w1_BN &lt;span class="op"&gt;=&lt;/span&gt; tf.Variable(w1_initial)

&lt;span class="co"&gt;# Note that pre-batch normalization bias is ommitted. The effect of this bias would be&lt;/span&gt;
&lt;span class="co"&gt;# eliminated when subtracting the batch mean. Instead, the role of the bias is performed&lt;/span&gt;
&lt;span class="co"&gt;# by the new beta variable. See Section 3.2 of the BN2015 paper.&lt;/span&gt;
z1_BN &lt;span class="op"&gt;=&lt;/span&gt; tf.matmul(x,w1_BN)

&lt;span class="co"&gt;# Calculate batch mean and variance&lt;/span&gt;
batch_mean1, batch_var1 &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.moments(z1_BN,[&lt;span class="dv"&gt;0&lt;/span&gt;])

&lt;span class="co"&gt;# Apply the initial batch normalizing transform&lt;/span&gt;
z1_hat &lt;span class="op"&gt;=&lt;/span&gt; (z1_BN &lt;span class="op"&gt;-&lt;/span&gt; batch_mean1) &lt;span class="op"&gt;/&lt;/span&gt; tf.sqrt(batch_var1 &lt;span class="op"&gt;+&lt;/span&gt; epsilon)

&lt;span class="co"&gt;# Create two new parameters, scale and beta (shift)&lt;/span&gt;
scale1 &lt;span class="op"&gt;=&lt;/span&gt; tf.Variable(tf.ones([&lt;span class="dv"&gt;100&lt;/span&gt;]))
beta1 &lt;span class="op"&gt;=&lt;/span&gt; tf.Variable(tf.zeros([&lt;span class="dv"&gt;100&lt;/span&gt;]))

&lt;span class="co"&gt;# Scale and shift to obtain the final output of the batch normalization&lt;/span&gt;
&lt;span class="co"&gt;# this value is fed into the activation function (here a sigmoid)&lt;/span&gt;
BN1 &lt;span class="op"&gt;=&lt;/span&gt; scale1 &lt;span class="op"&gt;*&lt;/span&gt; z1_hat &lt;span class="op"&gt;+&lt;/span&gt; beta1
l1_BN &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.sigmoid(BN1)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="co"&gt;# Layer 2 without BN&lt;/span&gt;
w2 &lt;span class="op"&gt;=&lt;/span&gt; tf.Variable(w2_initial)
b2 &lt;span class="op"&gt;=&lt;/span&gt; tf.Variable(tf.zeros([&lt;span class="dv"&gt;100&lt;/span&gt;]))
z2 &lt;span class="op"&gt;=&lt;/span&gt; tf.matmul(l1,w2)&lt;span class="op"&gt;+&lt;/span&gt;b2
l2 &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.sigmoid(z2)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that tensorflow provides a &lt;code&gt;tf.nn.batch_normalization&lt;/code&gt;, which I apply to layer 2 below. This code does the same thing as the code for layer 1 above. See the documentation &lt;a href="https://www.tensorflow.org/versions/master/api_docs/python/nn/normalization#batch_normalization"&gt;here&lt;/a&gt; and the code &lt;a href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/ops/nn_impl.py#L702"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="co"&gt;# Layer 2 with BN, using Tensorflows built-in BN function&lt;/span&gt;
w2_BN &lt;span class="op"&gt;=&lt;/span&gt; tf.Variable(w2_initial)
z2_BN &lt;span class="op"&gt;=&lt;/span&gt; tf.matmul(l1_BN,w2_BN)
batch_mean2, batch_var2 &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.moments(z2_BN,[&lt;span class="dv"&gt;0&lt;/span&gt;])
scale2 &lt;span class="op"&gt;=&lt;/span&gt; tf.Variable(tf.ones([&lt;span class="dv"&gt;100&lt;/span&gt;]))
beta2 &lt;span class="op"&gt;=&lt;/span&gt; tf.Variable(tf.zeros([&lt;span class="dv"&gt;100&lt;/span&gt;]))
BN2 &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.batch_normalization(z2_BN,batch_mean2,batch_var2,beta2,scale2,epsilon)
l2_BN &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.sigmoid(BN2)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="co"&gt;# Softmax&lt;/span&gt;
w3 &lt;span class="op"&gt;=&lt;/span&gt; tf.Variable(w3_initial)
b3 &lt;span class="op"&gt;=&lt;/span&gt; tf.Variable(tf.zeros([&lt;span class="dv"&gt;10&lt;/span&gt;]))
y  &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.softmax(tf.matmul(l2,w3)&lt;span class="op"&gt;+&lt;/span&gt;b3)

w3_BN &lt;span class="op"&gt;=&lt;/span&gt; tf.Variable(w3_initial)
b3_BN &lt;span class="op"&gt;=&lt;/span&gt; tf.Variable(tf.zeros([&lt;span class="dv"&gt;10&lt;/span&gt;]))
y_BN  &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.softmax(tf.matmul(l2_BN,w3_BN)&lt;span class="op"&gt;+&lt;/span&gt;b3_BN)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="co"&gt;# Loss, optimizer and predictions&lt;/span&gt;
cross_entropy &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="op"&gt;-&lt;/span&gt;tf.reduce_sum(y_&lt;span class="op"&gt;*&lt;/span&gt;tf.log(y))
cross_entropy_BN &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="op"&gt;-&lt;/span&gt;tf.reduce_sum(y_&lt;span class="op"&gt;*&lt;/span&gt;tf.log(y_BN))

train_step &lt;span class="op"&gt;=&lt;/span&gt; tf.train.GradientDescentOptimizer(&lt;span class="fl"&gt;0.01&lt;/span&gt;).minimize(cross_entropy)
train_step_BN &lt;span class="op"&gt;=&lt;/span&gt; tf.train.GradientDescentOptimizer(&lt;span class="fl"&gt;0.01&lt;/span&gt;).minimize(cross_entropy_BN)

correct_prediction &lt;span class="op"&gt;=&lt;/span&gt; tf.equal(tf.arg_max(y,&lt;span class="dv"&gt;1&lt;/span&gt;),tf.arg_max(y_,&lt;span class="dv"&gt;1&lt;/span&gt;))
accuracy &lt;span class="op"&gt;=&lt;/span&gt; tf.reduce_mean(tf.cast(correct_prediction,tf.float32))
correct_prediction_BN &lt;span class="op"&gt;=&lt;/span&gt; tf.equal(tf.arg_max(y_BN,&lt;span class="dv"&gt;1&lt;/span&gt;),tf.arg_max(y_,&lt;span class="dv"&gt;1&lt;/span&gt;))
accuracy_BN &lt;span class="op"&gt;=&lt;/span&gt; tf.reduce_mean(tf.cast(correct_prediction_BN,tf.float32))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="training-the-network"&gt;Training the network&lt;/h4&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;zs, BNs, acc, acc_BN &lt;span class="op"&gt;=&lt;/span&gt; [], [], [], []

sess &lt;span class="op"&gt;=&lt;/span&gt; tf.InteractiveSession()
sess.run(tf.global_variables_initializer())
&lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; tqdm.tqdm(&lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;40000&lt;/span&gt;)):
    batch &lt;span class="op"&gt;=&lt;/span&gt; mnist.train.next_batch(&lt;span class="dv"&gt;60&lt;/span&gt;)
    train_step.run(feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{x: batch[&lt;span class="dv"&gt;0&lt;/span&gt;], y_: batch[&lt;span class="dv"&gt;1&lt;/span&gt;]})
    train_step_BN.run(feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{x: batch[&lt;span class="dv"&gt;0&lt;/span&gt;], y_: batch[&lt;span class="dv"&gt;1&lt;/span&gt;]})
    &lt;span class="cf"&gt;if&lt;/span&gt; i &lt;span class="op"&gt;%&lt;/span&gt; &lt;span class="dv"&gt;50&lt;/span&gt; &lt;span class="kw"&gt;is&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;:
        res &lt;span class="op"&gt;=&lt;/span&gt; sess.run([accuracy,accuracy_BN,z2,BN2],feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{x: mnist.test.images, y_: mnist.test.labels})
        acc.append(res[&lt;span class="dv"&gt;0&lt;/span&gt;])
        acc_BN.append(res[&lt;span class="dv"&gt;1&lt;/span&gt;])
        zs.append(np.mean(res[&lt;span class="dv"&gt;2&lt;/span&gt;],axis&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;0&lt;/span&gt;)) &lt;span class="co"&gt;# record the mean value of z2 over the entire test set&lt;/span&gt;
        BNs.append(np.mean(res[&lt;span class="dv"&gt;3&lt;/span&gt;],axis&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;0&lt;/span&gt;)) &lt;span class="co"&gt;# record the mean value of BN2 over the entire test set&lt;/span&gt;

zs, BNs, acc, acc_BN &lt;span class="op"&gt;=&lt;/span&gt; np.array(zs), np.array(BNs), np.array(acc), np.array(acc_BN)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="improvements-in-speed-and-accuracy"&gt;Improvements in speed and accuracy&lt;/h3&gt;
&lt;p&gt;As seen below, there is a noticeable improvement in the accuracy and speed of training. As shown in figure 2 of the BN2015 paper, this difference can be very significant for other network architectures.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;fig, ax &lt;span class="op"&gt;=&lt;/span&gt; plt.subplots()

ax.plot(&lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="bu"&gt;len&lt;/span&gt;(acc)&lt;span class="op"&gt;*&lt;/span&gt;&lt;span class="dv"&gt;50&lt;/span&gt;,&lt;span class="dv"&gt;50&lt;/span&gt;),acc, label&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;Without BN&amp;#39;&lt;/span&gt;)
ax.plot(&lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="bu"&gt;len&lt;/span&gt;(acc)&lt;span class="op"&gt;*&lt;/span&gt;&lt;span class="dv"&gt;50&lt;/span&gt;,&lt;span class="dv"&gt;50&lt;/span&gt;),acc_BN, label&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;With BN&amp;#39;&lt;/span&gt;)
ax.set_xlabel(&lt;span class="st"&gt;&amp;#39;Training steps&amp;#39;&lt;/span&gt;)
ax.set_ylabel(&lt;span class="st"&gt;&amp;#39;Accuracy&amp;#39;&lt;/span&gt;)
ax.set_ylim([&lt;span class="fl"&gt;0.8&lt;/span&gt;,&lt;span class="dv"&gt;1&lt;/span&gt;])
ax.set_title(&lt;span class="st"&gt;&amp;#39;Batch Normalization Accuracy&amp;#39;&lt;/span&gt;)
ax.legend(loc&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;4&lt;/span&gt;)
plt.show()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/BN_output_23_0.png" alt="Effect of batch normalization on training" /&gt;&lt;figcaption&gt;Effect of batch normalization on training&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h5 id="illustration-of-input-to-activation-functions-over-time"&gt;Illustration of input to activation functions over time&lt;/h5&gt;
&lt;p&gt;Below is the distribution over time of the inputs to the sigmoid activation function of the first five neurons in the network’s second layer. Batch normalization has a visible and significant effect of removing variance/noise in these inputs. As described by Ioffe and Szegedy, this allows the third layer to learn faster and is responsible for the increase in accuracy and learning speed. See Figure 1 and Section 4.1 of the BN2015 paper.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;fig, axes &lt;span class="op"&gt;=&lt;/span&gt; plt.subplots(&lt;span class="dv"&gt;5&lt;/span&gt;, &lt;span class="dv"&gt;2&lt;/span&gt;, figsize&lt;span class="op"&gt;=&lt;/span&gt;(&lt;span class="dv"&gt;6&lt;/span&gt;,&lt;span class="dv"&gt;12&lt;/span&gt;))
fig.tight_layout()

&lt;span class="cf"&gt;for&lt;/span&gt; i, ax &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;enumerate&lt;/span&gt;(axes):
    ax[&lt;span class="dv"&gt;0&lt;/span&gt;].set_title(&lt;span class="st"&gt;&amp;quot;Without BN&amp;quot;&lt;/span&gt;)
    ax[&lt;span class="dv"&gt;1&lt;/span&gt;].set_title(&lt;span class="st"&gt;&amp;quot;With BN&amp;quot;&lt;/span&gt;)
    ax[&lt;span class="dv"&gt;0&lt;/span&gt;].plot(zs[:,i])
    ax[&lt;span class="dv"&gt;1&lt;/span&gt;].plot(BNs[:,i])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figure&gt;
&lt;img src="https://r2rt.com/static/images/BN_output_25_0.png" alt="Effect of batch normalization on inputs to activation functions" /&gt;&lt;figcaption&gt;Effect of batch normalization on inputs to activation functions&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h3 id="making-predictions-with-the-model"&gt;Making predictions with the model&lt;/h3&gt;
&lt;p&gt;When using a batch normalized model at test time to make predictions, using the batch mean and batch variance can be counter-productive. To see this, consider what happens if we feed a single example into the trained model above: the inputs to our activation functions will always be 0 (since we are normalizing them to have a mean of 0), and we will always get the same prediction, regardless of the input!&lt;/p&gt;
&lt;p&gt;To demonstrate:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;predictions &lt;span class="op"&gt;=&lt;/span&gt; []
correct &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;
&lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;100&lt;/span&gt;):
    pred, corr &lt;span class="op"&gt;=&lt;/span&gt; sess.run([tf.arg_max(y_BN,&lt;span class="dv"&gt;1&lt;/span&gt;), accuracy_BN],
                         feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{x: [mnist.test.images[i]], y_: [mnist.test.labels[i]]})
    correct &lt;span class="op"&gt;+=&lt;/span&gt; corr
    predictions.append(pred[&lt;span class="dv"&gt;0&lt;/span&gt;])
&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;PREDICTIONS:&amp;quot;&lt;/span&gt;, predictions)
&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;ACCURACY:&amp;quot;&lt;/span&gt;, correct&lt;span class="op"&gt;/&lt;/span&gt;&lt;span class="dv"&gt;100&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;PREDICTIONS: [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8]
ACCURACY: 0.02&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our model always predicts 8, and there appear to be only two 8s in the first 100 MNIST test samples, for an accuracy of 2%.&lt;/p&gt;
&lt;h3 id="fixing-the-model-for-test-time"&gt;Fixing the model for test time&lt;/h3&gt;
&lt;p&gt;To fix this, we need to replace the batch mean and batch variance in each batch normalization step with estimates of the population mean and population variance, respectively. See Section 3.1 of the BN2015 paper. Testing the model above only worked because the entire test set was predicted at once, so the “batch mean” and “batch variance” of the test set provided good estimates for the population mean and population variance.&lt;/p&gt;
&lt;p&gt;To make a batch normalized model generally suitable for testing, we want to obtain estimates for the population mean and population variance at each batch normalization step before test time (i.e., during training), and use these values when making predictions. Note that for the same reason that we need batch normalization (i.e. the mean and variance of the activation inputs changes during training), it would be best to estimate the population mean and variance &lt;em&gt;after&lt;/em&gt; the weights they depend on are trained, although doing these simultaneously is not the worst offense, since the weights are expected to converge near the end of training.&lt;/p&gt;
&lt;p&gt;And now, to actually implement this in Tensorflow, we will write a &lt;code&gt;batch_norm_wrapper&lt;/code&gt; function, which we will use to wrap the inputs to our activation functions. The function will store the population mean and variance as tf.Variables, and decide whether to use the batch statistics or the population statistics for normalization. To do this, it makes use of an &lt;code&gt;is_training&lt;/code&gt; flag. Because we need to learn the population mean and variance during training, we do this when &lt;code&gt;is_training == True&lt;/code&gt;. Here is an outline of the code:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; batch_norm_wrapper(inputs, is_training):
    ...
    pop_mean &lt;span class="op"&gt;=&lt;/span&gt; tf.Variable(tf.zeros([inputs.get_shape()[&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;]]), trainable&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;)
    pop_var &lt;span class="op"&gt;=&lt;/span&gt; tf.Variable(tf.ones([inputs.get_shape()[&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;]]), trainable&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;)

    &lt;span class="cf"&gt;if&lt;/span&gt; is_training:
        mean, var &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.moments(inputs,[&lt;span class="dv"&gt;0&lt;/span&gt;])
        ...
        &lt;span class="co"&gt;# learn pop_mean and pop_var here&lt;/span&gt;
        ...
        &lt;span class="cf"&gt;return&lt;/span&gt; tf.nn.batch_normalization(inputs, batch_mean, batch_var, beta, scale, epsilon)
    &lt;span class="cf"&gt;else&lt;/span&gt;:
        &lt;span class="cf"&gt;return&lt;/span&gt; tf.nn.batch_normalization(inputs, pop_mean, pop_var, beta, scale, epsilon)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that the variables have been declared with a &lt;code&gt;trainable = False&lt;/code&gt; argument, since we will be updating these ourselves rather than having the optimizer do it.&lt;/p&gt;
&lt;p&gt;One approach to estimating the population mean and variance during training is to use an exponential moving average, though strictly speaking, a simple average over the sample would be (marginally) better. The exponential moving average is simple and lets us avoid extra work, so we use that:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;decay &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="fl"&gt;0.999&lt;/span&gt; &lt;span class="co"&gt;# use numbers closer to 1 if you have more data&lt;/span&gt;
train_mean &lt;span class="op"&gt;=&lt;/span&gt; tf.assign(pop_mean, pop_mean &lt;span class="op"&gt;*&lt;/span&gt; decay &lt;span class="op"&gt;+&lt;/span&gt; batch_mean &lt;span class="op"&gt;*&lt;/span&gt; (&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="op"&gt;-&lt;/span&gt; decay))
train_var &lt;span class="op"&gt;=&lt;/span&gt; tf.assign(pop_var, pop_var &lt;span class="op"&gt;*&lt;/span&gt; decay &lt;span class="op"&gt;+&lt;/span&gt; batch_var &lt;span class="op"&gt;*&lt;/span&gt; (&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="op"&gt;-&lt;/span&gt; decay))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Finally, we will need a way to call these training ops. For full control, you can add them to a graph collection (see the link to Tensorflow’s code below), but for simplicity, we will call them every time we calculate the batch_mean and batch_var. To do this, we add them as dependencies to the return value of batch_norm_wrapper when is_training is true. Here is the final batch_norm_wrapper function:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="co"&gt;# this is a simpler version of Tensorflow&amp;#39;s &amp;#39;official&amp;#39; version. See:&lt;/span&gt;
&lt;span class="co"&gt;# https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/layers/python/layers/layers.py#L102&lt;/span&gt;
&lt;span class="kw"&gt;def&lt;/span&gt; batch_norm_wrapper(inputs, is_training, decay &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="fl"&gt;0.999&lt;/span&gt;):

    scale &lt;span class="op"&gt;=&lt;/span&gt; tf.Variable(tf.ones([inputs.get_shape()[&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;]]))
    beta &lt;span class="op"&gt;=&lt;/span&gt; tf.Variable(tf.zeros([inputs.get_shape()[&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;]]))
    pop_mean &lt;span class="op"&gt;=&lt;/span&gt; tf.Variable(tf.zeros([inputs.get_shape()[&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;]]), trainable&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;)
    pop_var &lt;span class="op"&gt;=&lt;/span&gt; tf.Variable(tf.ones([inputs.get_shape()[&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;]]), trainable&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;)

    &lt;span class="cf"&gt;if&lt;/span&gt; is_training:
        batch_mean, batch_var &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.moments(inputs,[&lt;span class="dv"&gt;0&lt;/span&gt;])
        train_mean &lt;span class="op"&gt;=&lt;/span&gt; tf.assign(pop_mean,
                               pop_mean &lt;span class="op"&gt;*&lt;/span&gt; decay &lt;span class="op"&gt;+&lt;/span&gt; batch_mean &lt;span class="op"&gt;*&lt;/span&gt; (&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="op"&gt;-&lt;/span&gt; decay))
        train_var &lt;span class="op"&gt;=&lt;/span&gt; tf.assign(pop_var,
                              pop_var &lt;span class="op"&gt;*&lt;/span&gt; decay &lt;span class="op"&gt;+&lt;/span&gt; batch_var &lt;span class="op"&gt;*&lt;/span&gt; (&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="op"&gt;-&lt;/span&gt; decay))
        &lt;span class="cf"&gt;with&lt;/span&gt; tf.control_dependencies([train_mean, train_var]):
            &lt;span class="cf"&gt;return&lt;/span&gt; tf.nn.batch_normalization(inputs,
                batch_mean, batch_var, beta, scale, epsilon)
    &lt;span class="cf"&gt;else&lt;/span&gt;:
        &lt;span class="cf"&gt;return&lt;/span&gt; tf.nn.batch_normalization(inputs,
            pop_mean, pop_var, beta, scale, epsilon)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="an-implementation-that-works-at-test-time"&gt;An implementation that works at test time&lt;/h3&gt;
&lt;p&gt;And now to demonstrate that this works, we rebuild/retrain the model with our batch_norm_wrapper function. Note that we need to build the graph once for training, and then again at test time, so we write a build_graph function (in practice, this would usually be encapsulated in a model object):&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; build_graph(is_training):
    &lt;span class="co"&gt;# Placeholders&lt;/span&gt;
    x &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(tf.float32, shape&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="va"&gt;None&lt;/span&gt;, &lt;span class="dv"&gt;784&lt;/span&gt;])
    y_ &lt;span class="op"&gt;=&lt;/span&gt; tf.placeholder(tf.float32, shape&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="va"&gt;None&lt;/span&gt;, &lt;span class="dv"&gt;10&lt;/span&gt;])

    &lt;span class="co"&gt;# Layer 1&lt;/span&gt;
    w1 &lt;span class="op"&gt;=&lt;/span&gt; tf.Variable(w1_initial)
    z1 &lt;span class="op"&gt;=&lt;/span&gt; tf.matmul(x,w1)
    bn1 &lt;span class="op"&gt;=&lt;/span&gt; batch_norm_wrapper(z1, is_training)
    l1 &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.sigmoid(bn1)

    &lt;span class="co"&gt;#Layer 2&lt;/span&gt;
    w2 &lt;span class="op"&gt;=&lt;/span&gt; tf.Variable(w2_initial)
    z2 &lt;span class="op"&gt;=&lt;/span&gt; tf.matmul(l1,w2)
    bn2 &lt;span class="op"&gt;=&lt;/span&gt; batch_norm_wrapper(z2, is_training)
    l2 &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.sigmoid(bn2)

    &lt;span class="co"&gt;# Softmax&lt;/span&gt;
    w3 &lt;span class="op"&gt;=&lt;/span&gt; tf.Variable(w3_initial)
    b3 &lt;span class="op"&gt;=&lt;/span&gt; tf.Variable(tf.zeros([&lt;span class="dv"&gt;10&lt;/span&gt;]))
    y  &lt;span class="op"&gt;=&lt;/span&gt; tf.nn.softmax(tf.matmul(l2, w3))

    &lt;span class="co"&gt;# Loss, Optimizer and Predictions&lt;/span&gt;
    cross_entropy &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="op"&gt;-&lt;/span&gt;tf.reduce_sum(y_&lt;span class="op"&gt;*&lt;/span&gt;tf.log(y))

    train_step &lt;span class="op"&gt;=&lt;/span&gt; tf.train.GradientDescentOptimizer(&lt;span class="fl"&gt;0.01&lt;/span&gt;).minimize(cross_entropy)

    correct_prediction &lt;span class="op"&gt;=&lt;/span&gt; tf.equal(tf.arg_max(y,&lt;span class="dv"&gt;1&lt;/span&gt;),tf.arg_max(y_,&lt;span class="dv"&gt;1&lt;/span&gt;))
    accuracy &lt;span class="op"&gt;=&lt;/span&gt; tf.reduce_mean(tf.cast(correct_prediction,tf.float32))

    &lt;span class="cf"&gt;return&lt;/span&gt; (x, y_), train_step, accuracy, y, tf.train.Saver()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="co"&gt;#Build training graph, train and save the trained model&lt;/span&gt;

sess.close()
tf.reset_default_graph()
(x, y_), train_step, accuracy, _, saver &lt;span class="op"&gt;=&lt;/span&gt; build_graph(is_training&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)

acc &lt;span class="op"&gt;=&lt;/span&gt; []
&lt;span class="cf"&gt;with&lt;/span&gt; tf.Session() &lt;span class="im"&gt;as&lt;/span&gt; sess:
    sess.run(tf.global_variables_initializer())
    &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; tqdm.tqdm(&lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;10000&lt;/span&gt;)):
        batch &lt;span class="op"&gt;=&lt;/span&gt; mnist.train.next_batch(&lt;span class="dv"&gt;60&lt;/span&gt;)
        train_step.run(feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{x: batch[&lt;span class="dv"&gt;0&lt;/span&gt;], y_: batch[&lt;span class="dv"&gt;1&lt;/span&gt;]})
        &lt;span class="cf"&gt;if&lt;/span&gt; i &lt;span class="op"&gt;%&lt;/span&gt; &lt;span class="dv"&gt;50&lt;/span&gt; &lt;span class="kw"&gt;is&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;:
            res &lt;span class="op"&gt;=&lt;/span&gt; sess.run([accuracy],feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{x: mnist.test.images, y_: mnist.test.labels})
            acc.append(res[&lt;span class="dv"&gt;0&lt;/span&gt;])
    saved_model &lt;span class="op"&gt;=&lt;/span&gt; saver.save(sess, &lt;span class="st"&gt;&amp;#39;./temp-bn-save&amp;#39;&lt;/span&gt;)

&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;Final accuracy:&amp;quot;&lt;/span&gt;, acc[&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Final accuracy: 0.9721&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And now to show that this worked, we repeat our experiment of predicting examples one by one:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;tf.reset_default_graph()
(x, y_), _, accuracy, y, saver &lt;span class="op"&gt;=&lt;/span&gt; build_graph(is_training&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;)

predictions &lt;span class="op"&gt;=&lt;/span&gt; []
correct &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;
&lt;span class="cf"&gt;with&lt;/span&gt; tf.Session() &lt;span class="im"&gt;as&lt;/span&gt; sess:
    sess.run(tf.global_variables_initializer())
    saver.restore(sess, &lt;span class="st"&gt;&amp;#39;./temp-bn-save&amp;#39;&lt;/span&gt;)
    &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;100&lt;/span&gt;):
        pred, corr &lt;span class="op"&gt;=&lt;/span&gt; sess.run([tf.arg_max(y,&lt;span class="dv"&gt;1&lt;/span&gt;), accuracy],
                             feed_dict&lt;span class="op"&gt;=&lt;/span&gt;{x: [mnist.test.images[i]], y_: [mnist.test.labels[i]]})
        correct &lt;span class="op"&gt;+=&lt;/span&gt; corr
        predictions.append(pred[&lt;span class="dv"&gt;0&lt;/span&gt;])
&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;PREDICTIONS:&amp;quot;&lt;/span&gt;, predictions)
&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;ACCURACY:&amp;quot;&lt;/span&gt;, correct&lt;span class="op"&gt;/&lt;/span&gt;&lt;span class="dv"&gt;100&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;PREDICTIONS: [7, 2, 1, 0, 4, 1, 4, 9, 6, 9, 0, 6, 9, 0, 1, 5, 9, 7, 3, 4, 9, 6, 6, 5, 4, 0, 7, 4, 0, 1, 3, 1, 3, 4, 7, 2, 7, 1, 2, 1, 1, 7, 4, 2, 3, 5, 1, 2, 4, 4, 6, 3, 5, 5, 6, 0, 4, 1, 9, 5, 7, 8, 9, 3, 7, 4, 6, 4, 3, 0, 7, 0, 2, 9, 1, 7, 3, 2, 9, 7, 7, 6, 2, 7, 8, 4, 7, 3, 6, 1, 3, 6, 9, 3, 1, 4, 1, 7, 6, 9]
ACCURACY: 0.99&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</content></entry><entry><title>Skill vs Strategy</title><link href="https://r2rt.com/skill-vs-strategy.html" rel="alternate"></link><published>2016-01-23T00:00:00-05:00</published><updated>2016-01-23T00:00:00-05:00</updated><author><name>Silviu Pitis</name></author><id>tag:r2rt.com,2016-01-23:/skill-vs-strategy.html</id><summary type="html">In this post I consider the distinction between skill and strategy and what it means for machine learning. Backpropagation is limited in that it develops a skill at a specific strategy, but cannot, by itself, change strategies. I look at how strategy switches are achieved in real examples and ask what algorithm might allow machines to effectively switch strategies.</summary><content type="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;meta name="generator" content="pandoc"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes"&gt;
  &lt;title&gt;&lt;/title&gt;
  &lt;style type="text/css"&gt;code{white-space: pre;}&lt;/style&gt;
  &lt;!--[if lt IE 9]&gt;
    &lt;script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"&gt;&lt;/script&gt;
  &lt;![endif]--&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;In this post I discuss several real life examples of strategies that cannot be achieved through mere practice of an inferior strategy. Backpropagation is an algorithm akin to such “mere practice” in that backpropagation develops skill at a specific strategy (i.e., it learns a specific local minimum). Like practice, backpropagation alone cannot result in a switch to a superior strategy. I look at how strategy switches are achieved in real examples and ask what algorithm might allow machines to effectively switch strategies.&lt;/p&gt;
&lt;h2 id="shooting-hoops"&gt;Shooting hoops&lt;/h2&gt;
&lt;p&gt;As a basketball player, I found the difference between the shots of 12 year olds and NBA players fascinating. Compare the shot of 12 year old Julian Newman to that of Dirk Nowitzki:&lt;/p&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
&lt;a class="spoiler-trigger"&gt;Show&lt;/a&gt;
&lt;/div&gt;
&lt;div class="panel-collapse collapse out"&gt;
&lt;div class="panel-body"&gt;
&lt;p&gt;&lt;img src="https://r2rt.com/static/images/bball_dirk.gif" alt="Dirk Nowitzki basketball shot" style="max-width: 45%; float: right"&gt; &lt;img src="https://r2rt.com/static/images/bball_julian.gif" alt="Julian Newman basketball shot" style="max-width: 45%;"&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;!-- Source Videos:
https://youtu.be/FjPNPTcxz1I
http://youtu.be/eDgRMdT1QVI
--&gt;
&lt;p&gt;Julian’s shot is as skilled as it gets given his age and physical characteristics. But notice how Julian shoots from his chest. He leans forward and pushes the ball away from his body (a chest shot). This is different from Dirk, who stands tall, raises the ball above his head, and shoots by extending his arm and flicking his wrist (a wrist shot).&lt;/p&gt;
&lt;p&gt;As he grows, Julian will soon find opponents’ hands inconveniently placed in the path of his shot. He’ll also soon be tall enough and strong enough to shoot like Dirk.&lt;/p&gt;
&lt;p&gt;What’s interesting is that Julian’s chest shot skill will not transfer perfectly. The only way he can switch to a wrist shot is by training the new style.&lt;/p&gt;
&lt;p&gt;To us observers, this switch may seem obvious. Yet in my experience and that of my basketball-playing friends, it is anything but. When we were Julian’s age, our chest shots came naturally and with higher accuracy (even with an opponent’s hand in front). We did switch eventually, perhaps due to a combination of logic and faith in the results of continued practice, or maybe as a simple matter of monkey see monkey do, or perhaps it was Coach Carter’s shooting drills that did it. Whatever the reason, the ball now leaves my hands from above my head with a flick of the wrist. I shoot like Dirk, except the part where the ball goes in.&lt;/p&gt;
&lt;h2 id="the-fosbury-flop"&gt;The Fosbury Flop&lt;/h2&gt;
&lt;p&gt;The &lt;a href="https://en.wikipedia.org/wiki/Fosbury_Flop"&gt;Fosbury Flop&lt;/a&gt; is to Olympic high jumping as the wrist shot is to shooting a basketball. Though the mid-1960s, Olympic high jumpers would jump using the straddle technique, Western Roll, Eastern cut-off or scissors jump. But in 1968, a young Dick Fosbury set a new world record with his unorthodox new method of flopping backward over the bar. The Fosbury Flop was born.&lt;/p&gt;
&lt;p&gt;Compare the dominant pre-Fosbury style, the straddle technique, to the Fosbury Flop:&lt;/p&gt;
&lt;div class="panel panel-default"&gt;
&lt;div class="panel-heading"&gt;
&lt;p&gt;&lt;a class="spoiler-trigger"&gt;Show&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="panel-collapse collapse out"&gt;
&lt;div class="panel-body"&gt;
&lt;p&gt;&lt;img src="https://r2rt.com/static/images/fosbury.gif" alt="Fosbury Flop" style="max-width: 45%; min-width: 90px; float: right"&gt; &lt;img src="https://r2rt.com/static/images/straddle.gif" alt="Straddle technique" style="max-width: 45%; min-width: 90px;"&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;!-- Source Videos:
https://www.youtube.com/watch?v=d6lpk_9T5hM
https://www.youtube.com/watch?v=Id4W6VA0uLc
--&gt;
&lt;p&gt;Unlike the chest shot, which is clearly more prone to being caught under an opponent’s hand than the wrist shot, it’s not clear that the Fosbury Flop is any better than the straddle technique. Indeed, when Fosbury first used the Flop, he was met with warnings from his coaches. And even today, you will find high jumpers debating the relative merits of each jumping style. But the Fosbury Flop caught on, and has held every world record since the straddle technique’s last record in 1978.&lt;/p&gt;
&lt;h2 id="as-easy-as-17-plus-24"&gt;As easy as 17 plus 24&lt;/h2&gt;
&lt;p&gt;Another example, one of my favorites, concerns a fundamental human skill. Unlike the wrist shot for basketball players and the Fosbury Flop for high jumpers, this technique is relatively unknown among those who stand to benefit.&lt;/p&gt;
&lt;p&gt;Sometime in middle school, my music teacher recounted the story of a student who did arithmetic in his head faster than with a calculator. His secret? While school had taught us to add right-to-left, this student added left-to-right. A proud skeptic, I tested his technique out for myself. After a little practice, I too was summing numbers faster than with a calculator. It turns out that adjusting your answers for carried 1s isn’t as hard as it seems. In math class I had just started algebra, but in music, I had finally learned to add correctly.&lt;/p&gt;
&lt;h2 id="mayan-astronomy"&gt;Mayan astronomy&lt;/h2&gt;
&lt;p&gt;As a final fun example, take a minute to watch Richard Feynman’s &lt;a href="https://youtu.be/NM-zWTU7X-k?t=3m52s"&gt;imaginary discussion between a Mayan astronomer and his student&lt;/a&gt;:&lt;/p&gt;
&lt;iframe width="420" height="315" src="https://www.youtube.com/embed/NM-zWTU7X-k?start=232" frameborder="0"&gt;
&lt;/iframe&gt;
&lt;h2 id="well-executed-strategies-are-local-minima"&gt;Well-executed strategies are local minima&lt;/h2&gt;
&lt;p&gt;Similar situations are common. For most any task there exist multiple strategies of varying effectiveness: there are different ways to perform in competitive sports, different ways to study, and even different ways to think about life and pursue happiness. In the language of machine learning, this is simply to say that real world situations involve non-convex objective functions with multiple local minima. The dip around each local minimum corresponds to a distinct strategy, and the minimum itself corresponds to the perfect execution of that strategy. Under this lens, &lt;em&gt;backpropagation is an algorithm for improving skill&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Perhaps unsurprisingly, a skillfully-executed next-best strategy works in each of the above examples. It may not be as effective as the best strategy, but it gets the job done (else it wouldn’t really be a strategy). This is similar to the empirical result that despite the non-convex nature of a neural network’s error surface, backpropagation generally converges to a local minimum that performs well. A good way to think about this might be that until something “sort of works” (i.e., it has some semblance of a strategy), it won’t even start to converge; you can’t be skilled at a non-strategy.&lt;/p&gt;
&lt;p&gt;In spite of the efficacy of the next-best strategy, the examples above demonstrate that a superior strategy can perform significantly better. A superior strategy can also open doors that were previously closed in related domains (e.g., our ancestors needed to develop opposable thumbs before they could develop writing). This is critical to creating strong artificial intelligence, and so begs the question: what prompts the switch to a superior strategy and how can we use this to build stronger AI?&lt;/p&gt;
&lt;p&gt;[&lt;strong&gt;Note 2017/03/05&lt;/strong&gt;: I have since learned that my thoughts here are related to the exploration vs exploitation problem in reinforcement learning. To write more on this later.]&lt;/p&gt;
&lt;h2 id="whats-in-a-strategy-why-random-guesses-wont-work"&gt;What’s in a strategy; why random guesses won’t work&lt;/h2&gt;
&lt;p&gt;Implicit in a strategy is an &lt;em&gt;objective&lt;/em&gt;, which can be shooting a basketball through a hoop or minimizing an arbitrary loss function.&lt;/p&gt;
&lt;p&gt;A strategy is executed within a &lt;em&gt;context&lt;/em&gt;, which can make reaching the objective easier. It’s easier to shoot a basketball if you are a foot taller, and its easier to train a model when you have more data.&lt;/p&gt;
&lt;p&gt;Because some characteristics of the context are within our control, our strategy will often first involve developing these characteristics. In basketball, you can shoot from close up by passing the ball or crossing your opponent. In training a neural network, you can gather more data or select better features.&lt;/p&gt;
&lt;p&gt;As developing these characteristics can take time, and different strategies often rely on different characteristics, switching strategies can be costly. While changing the structure of a small neural network may be relatively inexpensive, retraining a lawyer to be a software engineer can be difficult due to the large investment required to develop domain expertise. Therefore, we’ll often need a compelling reason to prompt a strategy switch; something more than a random guess.&lt;/p&gt;
&lt;p&gt;Another reason to rule out random guesses is the very reason we need the backpropagation algorithm to begin with. There are infinitely many random guesses we could make. We simply do not have infinite time to make them, and so whereas backpropagation and its variants are required meta-strategies that tell us how to converge to a working strategy, we might wonder whether there are other meta-strategies that tell us how to effectively switch strategies.&lt;/p&gt;
&lt;h2 id="switching-strategies-through-social-learning"&gt;Switching strategies through social learning&lt;/h2&gt;
&lt;p&gt;One such meta-strategy is social learning, or learning by external influence. Whether it’s the Coach’s shooting drills, seeing other players hit threes using their wrist, watching Dick Fosbury set a world record with his Flop, or hearing a story of how a math whiz does mental addition faster than a calculator. In my limited experience, there is not yet a true parallel for this in the world of artificial intelligence. [&lt;strong&gt;Note 2017/03/05&lt;/strong&gt;: My experience at the time was indeed very limited: genetic algorithms, and related algorithms that keep populations of candidates, like &lt;a href="http://www.cc.gatech.edu/~isbell/papers/isbell-mimic-nips-1997.pdf"&gt;Bonet et al.’s MIMIC&lt;/a&gt;, do precisely this kind of social learning.]&lt;/p&gt;
&lt;p&gt;Our machine learning models do switch strategies due to the external influence of their creators; for example, vision researches were presented with the so called “AlexNet” architecture in 2012 (described in this &lt;a href="http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf"&gt;paper&lt;/a&gt;), and the model has since been copied and further improved. Unfortunately, such improvement is not machine autonomous, but requires the direct interference of a human. There are cases where a model is improved by mimicking a database of past samples, but it is difficult to call such programmed mimicry autonomous or intelligent.&lt;/p&gt;
&lt;p&gt;One big question then is, how can we get a machine to learn socially? Is there a way to do this on a more sophisticated level than averaging models or copying weight variables? There must be, because humans can do it.&lt;/p&gt;
&lt;p&gt;Being able to accept external influence requires the ability to understand the process that is producing the result. We can see and communicate the precise difference between a chest shot and a wrist shot and so we can accept the external influences and learn via imitation. But even human communication is limited to concepts that the receiver understands. A chess amateur may gain little by watching a grandmaster play whereas a master might learn a great deal. I think the day our programs are able to understand higher order concepts so as to learn by external influence we will be &lt;em&gt;very&lt;/em&gt; close to artificial general intelligence. [&lt;strong&gt;Note 2017/03/05&lt;/strong&gt;: These thoughts are very similar to the ones I put forth on Stage III models in my post on &lt;a href="http://r2rt.com/deconstruction-with-explicit-embeddings.html"&gt;discrete embeddings&lt;/a&gt;.]&lt;/p&gt;
&lt;h2 id="strategies-of-first-convergence-or-why-social-learning-is-not-enough"&gt;Strategies of first convergence, or why social learning is not enough&lt;/h2&gt;
&lt;p&gt;With social learning, our machines will be able to stand on the shoulders of giants. But what if there are no giants?&lt;/p&gt;
&lt;p&gt;While it is certainly possible to first converge to the best strategy, the chest shot in basketball shows us that our first strategy may be biased. As kids grow up, they are not strong or tall enough to pull of a wrist shot and inevitably converge to a chest shot. By the time they grow up, their chest shot may be a local minima that they can never escape without some creativity or outside help.&lt;/p&gt;
&lt;p&gt;Suppose we are trying to classify images of people as male or female, and train an image classification neural network with backpropagation to do so. By starting with a random initialization, the network reaches a local minimum. The question is: can we be sure that this local minimum is close to the global minimum? We might try testing this by reinitializing the weights and retraining the network. Let’s say we retrain the network one million times, and each of the local minima reached leads to approximately the same performance. Is this enough for us to conclude that the resulting strategies are close to the best? I would answer in the negative; we cannot be certain that a random initialization will ever lead to an optimal strategy via backpropagation. It may be a situation like the chest shot, where in order to reach an optimal strategy, the network must be trained again after it has learned some useful hidden features.&lt;/p&gt;
&lt;p&gt;It’s possible, for example, that height is such a good first proxy that neural networks trained with backpropagation immediately learn to use, and even heavily rely, on height as a feature. Humans know that while height is correlated with gender, more subtle characteristics like facial structure are superior predictors. It’s possible that neural networks trained with just backpropagation, even if they eventually learn to use facial structure, will never be able to change their strategy completely and “unlearn” the use of height.&lt;/p&gt;
&lt;p&gt;Therefore, even if machines are able to learn strategies from each other, it may not be enough to produce the Fosbury Flop or the theory of General Relativity. &lt;em&gt;Monkey see, monkey do&lt;/em&gt; is not enough for true intelligence: intelligent machines must be able to produce new strategies independently.&lt;/p&gt;
&lt;h2 id="switching-strategies-through-creativity"&gt;Switching strategies through creativity&lt;/h2&gt;
&lt;p&gt;The ability to switch strategies without external influence is the ultimate mark of intelligence. It takes something more than training to stop what one is currently doing and try something else entirely. You need to have a hypothesis that another method will be superior before you try it. In the basketball example, the opponent might stick a hand in your face while you’re trying to shoot, and it might prompt the thought: “if only I could shoot from higher up.” In isolation, backpropagating neural networks cannot have these sorts of thoughts about their weights and structures.&lt;/p&gt;
&lt;p&gt;The key to independent strategy switches is the hypothesis–a guess. Per Feynman, this is the core of the scientific method:&lt;/p&gt;
&lt;iframe width="420" height="315" src="https://www.youtube.com/embed/EYPapE-3FRw" frameborder="0"&gt;
&lt;/iframe&gt;
&lt;p&gt;As Feynman notes, however, the guesses are not random–some guesses are better than others. Our task then, is to figure out an algorithm for making effective guesses: an algorithm for creativity. [&lt;strong&gt;Note 2017/03/05&lt;/strong&gt;: The ability to generate hypotheticals is one key aspect of this. Note that epsilon-greedy or other random exploration approaches don’t quite cut it—they are just another form of social learning (learning socially from ourselves), unrelated to the scientific method.]&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</content></entry></feed>