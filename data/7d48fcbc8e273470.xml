<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns:yt="http://www.youtube.com/xml/schemas/2015" xmlns:media="http://search.yahoo.com/mrss/" xmlns="http://www.w3.org/2005/Atom">
 <link rel="self" href="http://www.youtube.com/feeds/videos.xml?channel_id=UCjO0vb8UqSMP8EvYI1Bq7xA"/>
 <id>yt:channel:UCjO0vb8UqSMP8EvYI1Bq7xA</id>
 <yt:channelId>UCjO0vb8UqSMP8EvYI1Bq7xA</yt:channelId>
 <title>Dane Perry Svendsen</title>
 <link rel="alternate" href="https://www.youtube.com/channel/UCjO0vb8UqSMP8EvYI1Bq7xA"/>
 <author>
  <name>Dane Perry Svendsen</name>
  <uri>https://www.youtube.com/channel/UCjO0vb8UqSMP8EvYI1Bq7xA</uri>
 </author>
 <published>2014-01-23T02:55:07+00:00</published>
 <entry>
  <id>yt:video:qj4a_3_HDes</id>
  <yt:videoId>qj4a_3_HDes</yt:videoId>
  <yt:channelId>UCjO0vb8UqSMP8EvYI1Bq7xA</yt:channelId>
  <title>Gravity</title>
  <link rel="alternate" href="https://www.youtube.com/watch?v=qj4a_3_HDes"/>
  <author>
   <name>Dane Perry Svendsen</name>
   <uri>https://www.youtube.com/channel/UCjO0vb8UqSMP8EvYI1Bq7xA</uri>
  </author>
  <published>2014-12-05T09:37:52+00:00</published>
  <updated>2022-07-12T01:57:21+00:00</updated>
  <media:group>
   <media:title>Gravity</media:title>
   <media:content url="https://www.youtube.com/v/qj4a_3_HDes?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
   <media:thumbnail url="https://i2.ytimg.com/vi/qj4a_3_HDes/hqdefault.jpg" width="480" height="360"/>
   <media:description>http://dperrysvendsen.wordpress.com/2014/12/05/gravity/

This program is a simple top-down physics game written in C, using the SwinGame API. To complete each level, the player must guide a ball into a target area. The ball can only be moved indirectly, by utilising the gravitational attraction of nearby ‘nodes’. 

Each node will begin to attract the ball as the player holds down the corresponding number key. Nodes are represented as a circle surrounded by a number of rings: nodes with more rings have a larger mass, and will exert a stronger force, the magnitude of which is calculated according to the Newtonian laws of motion and universal gravitation (much the same as in my N-body simulation).

When I first wrote this game I had only just began learning C. I recall I ran into a lot of challenges, mostly to do with the verbose way in which strings have to be handled in C, as they aren’t a built in data type. I tended to constantly forget that assignment, concatenation and comparison all had to be performed with a function, which was unlike any language I’d previously worked with. Nonetheless, I managed to get some basic level loading functions working, which allowed the parameters for each level to be read from a text file.</media:description>
   <media:community>
    <media:starRating count="101" average="5.00" min="1" max="5"/>
    <media:statistics views="5337"/>
   </media:community>
  </media:group>
 </entry>
 <entry>
  <id>yt:video:16hgaQ9c2Rc</id>
  <yt:videoId>16hgaQ9c2Rc</yt:videoId>
  <yt:channelId>UCjO0vb8UqSMP8EvYI1Bq7xA</yt:channelId>
  <title>Smoke and Mirrors</title>
  <link rel="alternate" href="https://www.youtube.com/watch?v=16hgaQ9c2Rc"/>
  <author>
   <name>Dane Perry Svendsen</name>
   <uri>https://www.youtube.com/channel/UCjO0vb8UqSMP8EvYI1Bq7xA</uri>
  </author>
  <published>2014-12-05T09:37:52+00:00</published>
  <updated>2022-06-18T08:56:17+00:00</updated>
  <media:group>
   <media:title>Smoke and Mirrors</media:title>
   <media:content url="https://www.youtube.com/v/16hgaQ9c2Rc?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
   <media:thumbnail url="https://i2.ytimg.com/vi/16hgaQ9c2Rc/hqdefault.jpg" width="480" height="360"/>
   <media:description>http://dperrysvendsen.wordpress.com/2014/12/05/smoke-and-mirrors/

This program is a physics-based puzzle game in written in C#, in which the player must direct coloured laser beams onto their corresponding targets. This can involve reflecting the beams off rotating mirrors and splitting beams into their constituent colours by passing them through glass, while avoiding areas of smoke through which the beams cannot pass.

This involves the program calculating the trajectory of each beam on the fly. When a beam is updated, it has an initial position and angle. These values are used to generate a new point a short distance from the previous. If the beam collides with a mirror, the new angle is calculated according to the law of reflection, which states that the angle of reflection is equal to the angle of incidence, relative to the normal (which in this case is perpendicular to the mirror).

This process repeats until the beam collides with certain objects or leaves the screen. To avoid extremely long beams causing a performance hit, the iteration count is capped at 10,000. If the beam hits glass, several new beams of different colours will be created in its place. Whilst this bears little resemblance to how refraction actually works, it does make for an interesting game mechanic.

For this system to work as intended, I had to figure out how to check for collisions between a beam and mirror. For objects with a rectangular hitbox, this is extremely simple, but accounting for an angled line effectively only one pixel thick presents some issues. I’d originally tried using an implementation of the Bresenham line algorithm to generate an array of points along the line, then checking each individually, but it was clear this was far too inefficient and wouldn’t scale well.

I eventually settled on checking the distance between the specified point on the beam and one of the edges of the mirror. If result was less than the length of the mirror, then it was possible that the two points are overlapping. The corresponding point on the mirror (based on this distance value) can then be checked. This method was much more suitable, and was able to generate the same results in only two steps.</media:description>
   <media:community>
    <media:starRating count="33" average="5.00" min="1" max="5"/>
    <media:statistics views="1750"/>
   </media:community>
  </media:group>
 </entry>
 <entry>
  <id>yt:video:X3x7BlLgS-4</id>
  <yt:videoId>X3x7BlLgS-4</yt:videoId>
  <yt:channelId>UCjO0vb8UqSMP8EvYI1Bq7xA</yt:channelId>
  <title>Pathfinding Algorithms</title>
  <link rel="alternate" href="https://www.youtube.com/watch?v=X3x7BlLgS-4"/>
  <author>
   <name>Dane Perry Svendsen</name>
   <uri>https://www.youtube.com/channel/UCjO0vb8UqSMP8EvYI1Bq7xA</uri>
  </author>
  <published>2014-12-05T09:29:08+00:00</published>
  <updated>2022-04-16T01:32:09+00:00</updated>
  <media:group>
   <media:title>Pathfinding Algorithms</media:title>
   <media:content url="https://www.youtube.com/v/X3x7BlLgS-4?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
   <media:thumbnail url="https://i1.ytimg.com/vi/X3x7BlLgS-4/hqdefault.jpg" width="480" height="360"/>
   <media:description>This program was originally built to demonstrate the relative efficiency of different pathfinding algorithms in finding the shortest path between two points on a map.

Three algorithms are built in:
• Breadth-first search, an algorithm traditionally used to navigate small, enclosed areas.
• Best-first search, an algorithm generally better suited to more open environments with fewer obstacles.
• A* search, a somewhat more complex algorithm designed to intelligently dodge obstacles.

To represent the map, the program uses a grid of nodes, in which each node has up to four traversable edges: up, down, left and right. One node is designated the root node, and another the target node. In addition, a node can be marked as impassable, effectively creating an obstacle around which an algorithm must navigate.

In order to generate a path, each algorithm utilises an open set, a collection of nodes representing the boundary of an increasing search area. The algorithm gradually expands the search area by evaluating one node at a time from its open set.
 
Evaluating a node involves first checking if it is the target node – if this is the case, a path has been found and the algorithm terminates. Failing this, the node is removed from the open set and marked as visited so that is will not be re-added (this prevents the algorithm from generating loops). Finally, each of the nodes immediate unvisited neighbours are added to the open set. Crucially, for each of these neighbouring nodes, the current node is marked as their predecessor.

This search area continues to expand until either it reaches the target node (meaning a path was been found), or there are no new nodes to evaluate (meaning no path was found). If a path is found, it is then reconstructed based on the predecessor of each node, starting from the target node, and continuing until the root node is reached.

The difference between each algorithm lies in how they decide the order in which the Nodes in the open set are evaluated.
• Breadth-first search uses a Queue, which functions much like a real-world queue in ensuring that Nodes are evaluated in the same order they were added.
• Best-first search uses a List, assigning each Node a heuristic value based on its estimated distance from the target node, not taking into account any obstacles. This value is simply the rectilinear distance, or the sum of the horizontal and vertical offsets, between the two points. The Node with the lowest heuristic value is then chosen to be evaluated.
• A* search also uses a List, and also assigns each Node a heuristic value. However, it adds this heuristic value to the cumulative cost (the path length) to generate the Node’s f-score. The Node with the lowest f-score is then chosen to be evaluated.</media:description>
   <media:community>
    <media:starRating count="27183" average="5.00" min="1" max="5"/>
    <media:statistics views="2008681"/>
   </media:community>
  </media:group>
 </entry>
 <entry>
  <id>yt:video:3GoCdQ4V9Ko</id>
  <yt:videoId>3GoCdQ4V9Ko</yt:videoId>
  <yt:channelId>UCjO0vb8UqSMP8EvYI1Bq7xA</yt:channelId>
  <title>N-body Simulation</title>
  <link rel="alternate" href="https://www.youtube.com/watch?v=3GoCdQ4V9Ko"/>
  <author>
   <name>Dane Perry Svendsen</name>
   <uri>https://www.youtube.com/channel/UCjO0vb8UqSMP8EvYI1Bq7xA</uri>
  </author>
  <published>2014-05-12T02:59:07+00:00</published>
  <updated>2022-01-18T13:57:33+00:00</updated>
  <media:group>
   <media:title>N-body Simulation</media:title>
   <media:content url="https://www.youtube.com/v/3GoCdQ4V9Ko?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
   <media:thumbnail url="https://i4.ytimg.com/vi/3GoCdQ4V9Ko/hqdefault.jpg" width="480" height="360"/>
   <media:description>http://dperrysvendsen.wordpress.com/2014/05/12/n-body-simulation/

An N-Body simulation is used to model the movement of a collection of bodies as they are acted on by the force of gravity. This type of simulation is commonly used in cosmology to model the evolution of solar systems, galaxies and superclusters. The largest ever created, the 'Millennium Run', simulated 20 million galaxies, composed of over 10 billion 'particles', each with the mass of roughly a billion suns. Other simulations even take into account the warping of spacetime described by general relativity.

This program is a simpler direct N-body simulation, in which each pair of particles are attracted with a Newtonian gravitational force proportional to the product of their masses and inversely proportional to the square of the distance between their respective centres of mass. In this program, the default gravitational constant is 6.67x10^-3. A lower value, closer to the actual value of 6.67x10^-11, renders gravity so weak that the particles will not appear to move at all.

Particles can be spawned either randomly or at the cursor, while gravity and collisions can be toggled. In addition, the gravitational constant, density and mass range of the simulation can be adjusted. Where two particles collide, momentum is conserved, with the larger particle inheriting the mass, as well as part of the velocity, of the smaller.</media:description>
   <media:community>
    <media:starRating count="58" average="5.00" min="1" max="5"/>
    <media:statistics views="3701"/>
   </media:community>
  </media:group>
 </entry>
 <entry>
  <id>yt:video:b5QFkXGyQxQ</id>
  <yt:videoId>b5QFkXGyQxQ</yt:videoId>
  <yt:channelId>UCjO0vb8UqSMP8EvYI1Bq7xA</yt:channelId>
  <title>Mandelbrot Renderer</title>
  <link rel="alternate" href="https://www.youtube.com/watch?v=b5QFkXGyQxQ"/>
  <author>
   <name>Dane Perry Svendsen</name>
   <uri>https://www.youtube.com/channel/UCjO0vb8UqSMP8EvYI1Bq7xA</uri>
  </author>
  <published>2014-05-02T14:19:40+00:00</published>
  <updated>2022-02-12T23:05:06+00:00</updated>
  <media:group>
   <media:title>Mandelbrot Renderer</media:title>
   <media:content url="https://www.youtube.com/v/b5QFkXGyQxQ?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
   <media:thumbnail url="https://i3.ytimg.com/vi/b5QFkXGyQxQ/hqdefault.jpg" width="480" height="360"/>
   <media:description>http://dperrysvendsen.wordpress.com/2014/05/03/mandelbrot-renderer/

It should be noted that this video is not real-time: different parts have been sped up to various degrees, at most ~5x. Also, this particular implementation does not allow for infinite zooming; at a certain point the output will become pixilated.

---

French-American Mathematician Benoit Mandelbrot is best known for making what Sir Arthur C. Clarke described as &quot;one of the most astonishing discoveries in the entire history of mathematics&quot;.

In 1975, Mandelbrot discovered what is now known as the Mandelbrot set, a collection of complex numbers which can be used to generate a repeating geometric pattern of infinite complexity. Mandelbrot labelled these patterns fractals, a name derived from the Latin frāctus, meaning shattered or fractured. The core characteristic of a fractal is self-similarity: in other words, the pattern will appear similar no matter how far one zooms in or out.

There are multiple techniques for rendering the Mandelbrot set, each of which produces slightly different results. This particular program uses the crude &quot;escape time&quot; algorithm, which produces noticeable aliased borders between different bands of colour, rather than the familiar smooth colouring characteristic of the &quot;normalised iteration count&quot; algorithm.


In order to render the set, the program iterates through all pixels on the screen, assigning each a co-ordinate in Mandelbrot space, according the position and scale of the current area being rendered. The colour of the pixel is determined by the number of iterations performed before the sum of the squares of the coordinates is greater than 4. If this value is not reached within a specified number of iterations, set by the user at the beginning of the program, the pixel is considered to be inside the set, and is coloured black.</media:description>
   <media:community>
    <media:starRating count="37" average="5.00" min="1" max="5"/>
    <media:statistics views="2275"/>
   </media:community>
  </media:group>
 </entry>
 <entry>
  <id>yt:video:q8cvBsrbK40</id>
  <yt:videoId>q8cvBsrbK40</yt:videoId>
  <yt:channelId>UCjO0vb8UqSMP8EvYI1Bq7xA</yt:channelId>
  <title>Spirograph</title>
  <link rel="alternate" href="https://www.youtube.com/watch?v=q8cvBsrbK40"/>
  <author>
   <name>Dane Perry Svendsen</name>
   <uri>https://www.youtube.com/channel/UCjO0vb8UqSMP8EvYI1Bq7xA</uri>
  </author>
  <published>2014-01-28T00:52:53+00:00</published>
  <updated>2022-07-19T12:52:55+00:00</updated>
  <media:group>
   <media:title>Spirograph</media:title>
   <media:content url="https://www.youtube.com/v/q8cvBsrbK40?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
   <media:thumbnail url="https://i2.ytimg.com/vi/q8cvBsrbK40/hqdefault.jpg" width="480" height="360"/>
   <media:description>http://dperrysvendsen.wordpress.com/2014/01/28/spirograph/

Originally marketed as a children's toy, the Spirograph consisted of a set of gears designed to travel around the inside of a larger ring. The setup accommodated a pen, which allowed the user to draw intricate spiralling patterns by rotating the gears. The resultant geometric patterns, known as epitrochoids and hypotrochoids, belong to a family of vector-valued functions called roulette curves.

In this simulation, the underlying concept remains the same; however the gears are instead represented as three connected arms. By adjusting the length and speed of each arm, a multitude of patterns can be produced, each consisting of a single, unbroken line.</media:description>
   <media:community>
    <media:starRating count="96" average="5.00" min="1" max="5"/>
    <media:statistics views="4369"/>
   </media:community>
  </media:group>
 </entry>
 <entry>
  <id>yt:video:FXxrZ8YXJyE</id>
  <yt:videoId>FXxrZ8YXJyE</yt:videoId>
  <yt:channelId>UCjO0vb8UqSMP8EvYI1Bq7xA</yt:channelId>
  <title>Cellular Automaton</title>
  <link rel="alternate" href="https://www.youtube.com/watch?v=FXxrZ8YXJyE"/>
  <author>
   <name>Dane Perry Svendsen</name>
   <uri>https://www.youtube.com/channel/UCjO0vb8UqSMP8EvYI1Bq7xA</uri>
  </author>
  <published>2014-01-24T01:00:30+00:00</published>
  <updated>2022-05-23T06:40:53+00:00</updated>
  <media:group>
   <media:title>Cellular Automaton</media:title>
   <media:content url="https://www.youtube.com/v/FXxrZ8YXJyE?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
   <media:thumbnail url="https://i3.ytimg.com/vi/FXxrZ8YXJyE/hqdefault.jpg" width="480" height="360"/>
   <media:description>http://dperrysvendsen.wordpress.com/2014/01/24/cellular-automaton/

In its simplest form, a cellular automaton is a simulated environment, represented as a grid of cells, each of which can be either 'alive' or 'dead'. After each successive generation, the state of each cell is determined by the state of its immediate neighbours.

The 'Game of Life', designed by mathematician John Conway, is perhaps the most well-known example. This program employs the same set of rules first put forward by Conway in 1970:

o Any live cell with fewer than two live neighbours dies, as if by under-population.
o Any live cell with two or three live neighbours lives on to the next generation.
o Any live cell with more than three live neighbours dies, as if by overcrowding.
o Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.

Whilst the original Game of Life was a 'zero-player game', capable of independent evolution, this version puts control in the hands of the user by allowing them to add/remove live cells as the simulation runs. In addition, cells will leave coloured trails as they blink in and out of existence.

The result is a dynamic landscape of spontaneously forming and deforming structures.</media:description>
   <media:community>
    <media:starRating count="47" average="5.00" min="1" max="5"/>
    <media:statistics views="2966"/>
   </media:community>
  </media:group>
 </entry>
</feed>
