<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[inFERENCe]]></title><description><![CDATA[posts on machine learning, statistics, opinions on things I'm reading in the space]]></description><link>https://www.inference.vc/</link><image><url>https://www.inference.vc/favicon.png</url><title>inFERENCe</title><link>https://www.inference.vc/</link></image><generator>Ghost 4.48</generator><lastBuildDate>Mon, 31 Oct 2022 23:34:36 GMT</lastBuildDate><atom:link href="https://www.inference.vc/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Implicit Bayesian Inference in Large Language Models]]></title><description><![CDATA[<p>This intriguing paper kept me thinking long enough for me to I decide it&apos;s time to resurrect my blogging (I started writing this during ICLR review period, and realised it might be a good idea to wait until that&apos;s concluded)</p><ul><li>Sang Michael Xie, Aditi Raghunathan, Percy</li></ul>]]></description><link>https://www.inference.vc/implicit-bayesian-inference-in-sequence-models/</link><guid isPermaLink="false">619e783462fbf1003bd8b017</guid><dc:creator><![CDATA[Ferenc Huszar]]></dc:creator><pubDate>Thu, 03 Mar 2022 13:57:26 GMT</pubDate><content:encoded><![CDATA[<p>This intriguing paper kept me thinking long enough for me to I decide it&apos;s time to resurrect my blogging (I started writing this during ICLR review period, and realised it might be a good idea to wait until that&apos;s concluded)</p><ul><li>Sang Michael Xie, Aditi Raghunathan, Percy Liang and Tengyu Ma (2021) <a href="https://arxiv.org/abs/2111.02080">An Explanation of In-context Learning as Implicit Bayesian Inference</a></li></ul><p>I liked this paper because it relates to one of my favourite concepts and ideas: exchangeability. And it took me back to thoughts I had back in 2015 (pre-historic by deep learning standards) about leveraging <a href="https://www.inference.vc/exchangeable-processes-via-neural-networks/">exchangeable sequence models</a> to implement giant general-purpose learning machines. In <a href="https://www.inference.vc/exchangeable-processes-via-neural-networks/">that old post</a> I made this observation about exchangeable models:</p><blockquote>If we had an exchangeable RNN, we could train it on multiple unsupervised learning problems over the same input space. Such system actually <strong><strong>learns to learn</strong></strong>. If you want to use it on a new dataset, you just feed it into the RNN, and it will give you Bayesian predictive probabilities without any additional computation. So it would be an ultimate general inference machine&#x2122;.</blockquote><p>Fast forwarding a bit, <em>ultimate general inference machine</em> (fortunate I trademarked it) is not actually all that far from how OpenAI&apos;s GPT-3 is sometimes branded and used. It&apos;s been demonstrated that you can repurpose them as few-shot (or in some cases zero-shot) learners in a surprising variety of tasks (<a href="https://arxiv.org/abs/2005.14165">Brown et al, 2020</a>). This ability of language models to solve different tasks by feeding them cleverly designed prompts is sometimes referred to as prompt-hacking or <em>in-context learning</em>.</p><p>Quite honestly, I never connected these dots until I read this paper: the motivations for leveraging one single big exchangeable sequence model as a general-purpose learner, and the more recent trend of in-context learning using GPT-3. In fact, I was deeply skeptical about the latter, thinking of it as another hack that must be somehow fundamentally flawed. But this paper by <a href="https://arxiv.org/abs/2111.02080">Xie et al (2021</a>) connected those dots for me, which is why I found it so fascinating, and I will never think of &apos;prompt hacking&apos; or in-context learning quite the same way.</p><h3 id="exchangeable-sequences-as-implicit-learning-machines">Exchangeable sequences as Implicit Learning Machines</h3><p>Before talking about the paper, let me first refresh those old ideas about exchangeable sequences and implicit learning. An exchangeable sequence model is a probability distribution $p(x_1, x_2, \ldots)$ over sequences that is invariant to permutations of the tokens within the sequence, i.e. $p(x_1, x_2, \ldots, x_N) = p(x_{\pi_1}, x_{\pi_2}, \ldots, x_{\pi_N})$ for any permutation $\pi$.</p><p>The de Finetti theorem connects such sequence models to Bayesian inference, saying that any such distribution can be decomposed as a mixture over i.i.d. sequence models:</p><p>$$<br>p(x_1, x_2, \ldots, x_N) = \int \prod_{n=1}^N p(x_n\vert \theta) d\pi(\theta)<br>$$</p><p>As a consequence, the one-step-ahead predictive distribution (which predicts the next token in the sequence) also always has a decomposition as Bayesian integration:</p><p>$$<br>p(x_N \vert x_1, x_2, \ldots, x_{N-1}) = \int &#xA0;p(x_N\vert \theta) d\pi(\theta\vert x_1, \ldots, x_N),<br>$$</p><p>where $\pi(\theta\vert x_1, \ldots, x_N)$ is the Bayesian posterior obtained from the prior $\pi(\theta)$ via the Bayes rule:</p><p>$$<br>\pi(\theta \vert x_1, x_2, \ldots, x_{N-1}) \propto \pi(\theta) \prod_{n=1}^{N-1}p(x_n\vert \theta)<br>$$</p><p>So in this sense, if we have an exchangeable sequence model, we can think of these one-step-ahead predictive distributions as <em>implicitly performing Bayesian inference</em>. Crucially, this happens even if we don&apos;t know what $\theta$ is, or what our prior $\pi$ is, or what the likelihood $p(x_i\vert \theta)$ is. We don&apos;t have to explicitly specify what those components are, de Finetti theorem guarantees that they exist, so long as the predictions $p(x_N \vert x_1, x_2, \ldots, x_{N-1})$ are consistent with an exchangeable sequence model.</p><p>This thought motivated me to try and design RNNs (remember this was in pre-transformer times) that always produce exchangeable distributions by construction. This turned out to be very difficult, but the idea eventually evolved into <a href="https://arxiv.org/abs/1802.07535">BRUNO</a> (named after Bruno de Finetti), a flexible meta-trained model for exchangeable data which exhibited few-shot concept learning abilities. This idea then got extended in a number of ways in <a href="https://irakorshunova.github.io/phd_iryna_korshunova.pdf">Ira Korshunova&apos;s PhD thesis</a>.</p><h3 id="from-exchangeable-sequences-to-mixtures-of-hmms">From Exchangeable sequences to Mixtures of HMMs</h3><p>But GPT-3 is a language models, and clearly language tokens are not exchangeble. So whats the connection?</p><p>There are interesting extensions to the concept of exchangeability, which come with interesting generalisations of the de Finetti-type theorems. <em>Partial exchangeability,</em> as defined by <a href="https://projecteuclid.org/journals/annals-of-probability/volume-8/issue-1/De-Finettis-Theorem-for-Markov-Chains/10.1214/aop/1176994828.full">Diaconis and Freedman (1980)</a>, is an invariance property of a distribution over sequences which guarantees that the sequence can be decomposed as a mixture of Markov-chains. Thus, one can say that a partially exchangeable process implicitly performs Bayesian inference over Markov chains, much the same way exchangeable processes can be said to be preforming inference over i.i.d. data generating processes.</p><p>In this new paper, <a href="https://arxiv.org/abs/2111.02080">Xie et al (2021</a>), assume that the sequence model we work with is a mixture of hidden Markov models (HMMs). This is more general still than the partially exchangeable mixture of Markov chains of Diaconis and Freedman. I don&apos;t know if Mixtures of HMMs (MoHMMs) can be characterised by an exchangeability-like invariance property, but that&apos;s somewhat irrelevant now. In fact, <a href="https://arxiv.org/abs/2111.02080">Xie et al (2021</a>) never mention exchangeability in the paper. The core argument about implicit Bayeisan inferencec holds every time we work with a sequence model which is a mixture of simpler distributions: you can interpret the one-step-ahead predictions as implicitly performing Bayesian inference over some parameter. While it is unlikely that the distribution of human language from the internet follows a MoHMM distribution, it is reasonable to assume that the distribution over sequences that comes out of a GPT-3 is perhaps a mixture of some sort. And if that is the case, predicting the next token implicitly performs Bayesian inference over some parameter $\theta$, which the authors refer to as a &apos;concept&apos;.</p><h3 id="in-context-learning">In context learning</h3><p>The core idea of this paper is that perhaps in-context learning exploits this implicit Bayesian inference, inherent to statistical models of language, to solve tasks. Language models learn to implicitly make probabilistic inferences about concepts - whatever those are - because learning to carry out such inferences is needed to do well on next-token-prediction tasks. One that implicit learning capability is there, one can hijack it to perform other tasks that also require such inferences, including few-shot classification.</p><p>I think this is a very intriguing general idea. But then the key question the authors focus is somewhat disappointingly specific and artificial: Although a MoHMMs can be used to `complete sequences` drawn from a specific HMM (one of the mixture components) what happens if we ask the MoHMMs to complete sequences that they would never natively generate, for example an artificially constructed sequence that has a few-shot classification task embedded inside. This then becomes a question about distribution mismatch. The key findings is that, despite this distribution mismatch, the implicit inference machinery inside MoHMMs is able to identify the right concept and use it to make correct predictions in the few-shot task.</p><p>However - and please read the paper for specific details - , the analysis makes very strong assumptions about how the in-context-learning task embedded in the sequence is related to the MoHMM distribution. In a way, the in-context task the authors study is in fact more like a few-shot sequence completion task than, say, a classification task.</p><p>All in all, this was a fun paper to think about, and one that definitely changed my way of thinking about the whole in-context-learning and language-models-as-few-shot-learners direction.</p>]]></content:encoded></item><item><title><![CDATA[Eastern European Guide to Writing Reference Letters]]></title><description><![CDATA[<p><em>Excruciating.</em> One phrase I often use to describe what it&apos;s like to read reference letters for Eastern European applicants to PhD and Master&apos;s programs in Cambridge. </p><p>Even objectively outstanding students often receive dull, short, factual, almost negative-sounding reference letters. This is a result of (A) <a href="https://erinmeyer.com/books/the-culture-map/">cultural</a></p>]]></description><link>https://www.inference.vc/the-east-european-guide-to-writing-reference-letters/</link><guid isPermaLink="false">6212686b35ff93003b346ee6</guid><dc:creator><![CDATA[Ferenc Huszar]]></dc:creator><pubDate>Mon, 28 Feb 2022 14:29:15 GMT</pubDate><content:encoded><![CDATA[<p><em>Excruciating.</em> One phrase I often use to describe what it&apos;s like to read reference letters for Eastern European applicants to PhD and Master&apos;s programs in Cambridge. </p><p>Even objectively outstanding students often receive dull, short, factual, almost negative-sounding reference letters. This is a result of (A) <a href="https://erinmeyer.com/books/the-culture-map/">cultural differences</a> - we are very good at sarcasm, painfully good at giving direct negative feedback, not so good at praising others and (B) the fact that reference letters play no role in Eastern Europe and most professors have never written or seen a good one before.</p><p>Poor reference letters hurt students. They give us no insight into the applicant&apos;s true strengths, and no ammunition to support the best candidates in scholarship competitions or the admission process in general. I decided to write this guide for students so they can share it with their professors when asking for reference letters. Although reading letters from the region is what triggered me to write this, mist of this advice should be generally useful for many other people who don&apos;t know how to write good academic reference letters.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://www.inference.vc/content/images/2022/02/quality-continuum-1.jpg" class="kg-image" alt loading="lazy" width="636" height="759" srcset="https://www.inference.vc/content/images/size/w600/2022/02/quality-continuum-1.jpg 600w, https://www.inference.vc/content/images/2022/02/quality-continuum-1.jpg 636w"><figcaption>Illustration of Eastern European subjective scale. Source: the almighty Internet.</figcaption></figure><h2 id="high-level-goals">High-Level Goals</h2><ul><li><strong>Help the supervisor to make a case for admitting a student: </strong>The reference letter is very important in the whole admissions process. In competitive places in Europe, there is often competition not just between applicants, but also between different research groups and supervisors about whose student gets funding. Reference letters are often used as ammunition to justify decisions internally, and to determine who gets prioritised for various scholarship and funding competitions.</li><li><strong>Help put candidate&apos;s profile into context:</strong> If you write a reference letter from a region like Eastern Europe, keep in mind how difficult it is to compare candidates from wildly different education systems and backgrounds. Is someone with a 4.9/5.0 GPA from Hungary more impressive than someone with a 9.5/10.0 GPA from Serbia? Your job, partly, is to explain to the admissions committee what the student&apos;s achievements mean in a global context. Do not use abbreviations that are not internationally obvious. Do not assume the reader has ever heard of your institution. <em>Explain everything.</em></li></ul><h2 id="basic-hygiene-and-format">Basic Hygiene and Format</h2><ul><li><strong>Confidentiality: </strong>Please do not ask the student to write their own recommendation letter. Sadly, many professors do it, but this is <em>not acceptable</em>, especially for the best students who apply to a top institution. You can also assume your reference letter is confidential. Don&apos;t share it with the student directly (Why? You probably want to write nicer things than you are comfortable sharing with them directly.)</li><li><strong>Length:</strong> Reference letters for the best candidates are often <em>2 full pages</em> long. Something that&apos;s half a page or just two paragraphs is interpreted as &apos;weak support&apos; or worse.</li><li><strong>Format:</strong> Although plain text is often accepted on submissions forms, when possible, please submit a PDF on letter-headed format (where the institution&apos;s logo, name, etc appear on the header). The format should follow the layout of a formal letter. You may address it &apos;To Whom It May Concern,&apos; or &apos;To the Admissions Committee,&apos; or to &apos;Dear Colleagues,&apos; or if you know the potential supervisor, by all means make it personal, address it to them. Obviously sign the letter with your name and title.</li><li><strong>Basic contents:</strong> Make sure that the letter mentions your full job title, affiliation, the candidate&apos;s full name, and the name of the programme/job/scholarship they are applying for.</li></ul><h2 id="contents">Contents</h2><p>Below is an example structure that is often used. (I&apos;ll use Marta as an example because I don&apos;t have a student called Marta so it won&apos;t get personal)</p><ul><li><strong>Introduction: </strong>A few sentences mentioning who you&apos;re recommending &#xA0;and for what program, for example &quot;I&apos;m writing to recommend Marta Somethingova for the Cambridge MPhil in Advanced Computer Science.&quot; The second sentence should clearly indicate how strongly you are recommending this candidate. Factual statements signal this is a lukewarm recommendation (they asked me and I had to write something). To convey your enthusiasm, you can write something like &apos;&apos;Marta is the strongest student I&apos;ve worked with in the last couple years&quot;.</li><li><strong>Context, How do I know Marta: </strong>Since when, in what capacity and how closely you have known Marta. This is important - a reference from a thesis supervisor who has worked with the student for a year is more informative than a reference from someone who only met them in one exam. If you&apos;ve done a project together, include details on how many times you&apos;ve met, etc. What was the project about, how challenging was it, what was the student&apos;s contribution.</li><li><strong>Marta&apos;s academic results/performance, in context:</strong> How good is Marta, compared to other students/persons in a similar context? Be aware that whoever is reading your letter may not know your country&apos;s marking scheme, so something like a GPA of 4.8 out of 5 isn&apos;t all that informative. Try to put that in context as much as you can: how many other students would achieve similar results in your institution? Best if you can give a rank index (#8 out of a cohort of 300) relative to the whole cohort<em>. Context on your institution:</em> Similarly, assume the reader has no idea how selective your institution is, so include a few details like &apos;top/most selective computer science program in the country&apos; or something.<em> Try to put this in context by making a prediction</em> about how well the student will do in the course you&apos;re recommending them to, or how well they would have done in a more challenging program. Do your research here, if you can.</li><li><strong>Details of research/project, if applicable:</strong> If you&apos;re recommending someone who has worked on a research project with you, include enough technical information (ideally with references or pointers) so that the reader can judge how serious that project was, and what Marta&apos;s contribution was. Don&apos;t worry, nobody is going to steal your research idea if you write it down in a recommendation letter - we are way too busy reading reference letters to do any research :D</li><li><strong>Marta&apos;s specific strengths:</strong> What quality of Marta do you think will be first noticed in an interview? Is Marta particularly good at understanding complex ideas fast? Is Marta very good at getting things done? Or writing clean code, mentoring others? Where appropriate, try to focus on talent and potential, before commenting on diligence or effort: If the first thing you write is &quot;Marta is very hard working&quot; it may be misinterpreted as a covert way of saying she tries very hard because she is not as good as the students who just get it without much effort. Be conscious of possible gender stereotypes that often come up here. E.g. she is quiet. <em>Make a prediction</em> about Marta&apos;s career prospects: She&apos;s on a good track to an academic career/well positioned for a career in industry. Please consider what the people reading your letter will want to see. If you recommend someone for an academic pure Maths program, you don&apos;t want to say the student is well positioned to end up in a boring finance job. If you feel like you MUST, you can include relative weaknesses here, but please phrase these as opportunities of growth, and what Marta needs to improve.</li><li><strong>Other/extracurricular activities:</strong> If you&apos;re aware of other things the student is doing - like organising meetups, volunteering, competitions, whatever - you can include them here if you feel they are relevant. Your job, again, is to put these in context.</li><li><strong>Further background on Marta&apos;s education history: </strong>This may be useful to support candidates who achieved impressive things in their country, but whose achievements may not make a lot of sense in an international context. For example, did they go to a very selective secondary school known for some specialization? Or, to the contrary, did they do exceptionally well despite not having access to the best education? Did they participate in country-specific olympiads or competitions? If so, what do those results mean? How many students do those things? Did they get a scholarship for their academic performance? If so, how many students get those? Did they participate in some kind of university activity? If so, what&apos;s the relevance of that? The most important assumption to remember is: Whoever reads the applicant&apos;s CV or your recommendation letter will know absolutely nothing about your country. You have to fill in the blanks, and explain everything from the ground up.<em> NO ACRONYMS!</em></li><li><strong>Your mini-CV: </strong>It&apos;s worth including one paragraph about yourself, the referee. What is your job title, how long you&apos;ve been doing what you&apos;re doing, what&apos;s your specialty, etc. The purpose of this is to prove you are qualified and able to spot talent. Make this as internationally attractive and meaningful as you can.</li><li><strong>Conclusion: </strong>Here is your chance to reiterate the strength of your recommendation. If you think you&apos;re describing a not-to-miss candidate, say so explicitly. One sentence we often include here is along the lines of &apos;If Marta were to apply for a PhD/Masters under my supervision I would not hesitate to take her as a student&apos;.</li></ul><h2 id="relative-ranking-of-students">Relative ranking of students</h2><ul><li>Often, reference submission websites ask you to place the student in the top X% of students you&apos;ve worked with. More depends on this than you might think. Be honest, but be aware that these judgments often go into a formula for scoring or pre-filtering applications. In a competitive program, if you say someone is top 20%, that is likely a death sentence for the student&apos;s chances of getting a scholarship. Again, don&apos;t lie, just make sure you don&apos;t put the student in a lower bucket than they really deserve to be in.</li></ul><h2 id="writing-style">Writing style</h2><ul><li>Be aware of cultural differences in how we praise others and give direct feedback to/on colleagues. I often recommend the <a href="https://erinmeyer.com/books/the-culture-map/">Culture Map</a> book by Erin Meyer on this topic. Though individuals are individuals, by and large, those who socialise in the U.S. Academic system tend to write recommendation letters with a higher baseline level of enthusiasm. If you feel your letter is too positive, that may be appropriate compensation for these differences, so long as your letter is honest, of course.</li><li>Writing style and tone are the most difficult to get right if you haven&apos;t seen examples before. I suggest you write a draft a couple weeks before submitting a letter, and then return to it before submitting. Re-reading after a week often allows you to better notice where the letter isn&apos;t conveying what you wanted.</li><li>Ask for help! If you have a candidate you enthusiastically support, don&apos;t be afraid to ask for help writing the reference letter. Ideally, ask someone who is experienced, doesn&apos;t know the candidate, and who is not part of the decision making at the institution the student is applying.</li></ul><p>In summary, please take time to write strong recommendation letters for your best students. There may not be many students at your institution who apply to top programs, but those who do are likely the ones who really need and deserve your attention.</p>]]></content:encoded></item><item><title><![CDATA[Causal inference 4: Causal Diagrams, Markov Factorization, Structural Equation Models]]></title><description><![CDATA[<p>This post is written with my PhD student and now <strong>guest author <a href="https://twitter.com/rpatrik96">Patrik Reizinger</a></strong> and is part 4 of a series of posts on causal inference:</p><ul><li><a href="https://www.inference.vc/untitled">Part 1: Intro to causal inference and do-calculus</a></li><li><a href="https://www.inference.vc/causal-inference-2-illustrating-interventions-in-a-toy-example/">Part 2: Illustrating Interventions with a Toy Example</a></li><li><a href="https://www.inference.vc/causal-inference-3-counterfactuals/">Part 3: Counterfactuals</a></li><li>&#x27A1;&#xFE0F;&#xFE0F; <a href="https://www.inference.vc/causal-inference-4/www.inference.vc/causal-inference-4/">Part 4:</a></li></ul>]]></description><link>https://www.inference.vc/causal-inference-4/</link><guid isPermaLink="false">607571006b8e12003bfa0782</guid><category><![CDATA[causal inference]]></category><dc:creator><![CDATA[Patrik Reizinger]]></dc:creator><pubDate>Thu, 10 Jun 2021 13:56:20 GMT</pubDate><media:content url="https://www.inference.vc/content/images/2021/06/many_to_one-1.png" medium="image"/><content:encoded><![CDATA[<img src="https://www.inference.vc/content/images/2021/06/many_to_one-1.png" alt="Causal inference 4: Causal Diagrams, Markov Factorization, Structural Equation Models"><p>This post is written with my PhD student and now <strong>guest author <a href="https://twitter.com/rpatrik96">Patrik Reizinger</a></strong> and is part 4 of a series of posts on causal inference:</p><ul><li><a href="https://www.inference.vc/untitled">Part 1: Intro to causal inference and do-calculus</a></li><li><a href="https://www.inference.vc/causal-inference-2-illustrating-interventions-in-a-toy-example/">Part 2: Illustrating Interventions with a Toy Example</a></li><li><a href="https://www.inference.vc/causal-inference-3-counterfactuals/">Part 3: Counterfactuals</a></li><li>&#x27A1;&#xFE0F;&#xFE0F; <a href="https://www.inference.vc/causal-inference-4/www.inference.vc/causal-inference-4/">Part 4: Causal Diagrams, Markov Factorization, Structural Equation Models</a></li></ul><p>One way to think about causal inference is that causal models require a more fine-grained models of the world compared to statistical models. Many causal models are equivalent to the same statistical model, yet support different causal inferences. This post elaborates on this point, and makes the relationship between causal and statistical models more precise.</p><!--kg-card-begin: markdown--><h1 id="markovfactorization">Markov factorization</h1>
<!--kg-card-end: markdown--><p>Do you remember those combinatorics problems from school where the question was how many ways exist to get from a start position to a target field on a chessboard? And you can only move one step right or one step down. If you remember, then I need to admit that we will not consider problems like that. But its (one possible) takeaway actually can help us to understand Markov factorizations.</p><!--kg-card-begin: markdown--><p>You know, it is totally indifferent how you traversed the chessboard, the result is the same. So we can say that - from the perspective of target position and the process of getting there - this is a many-to-one mapping. The same holds for random variables and causal generative models.</p>
<p>If you have a bunch of random variables - let&apos;s call them $X_1, X_2, \dots, X_n$ -, their joint distribution is $p \left(X_1, X_2, \dots, X_n \right) $. If you invoke the <em>chain rule of probability,</em> you will have several options to express this joint as a product of factors:</p>
<p>$$<br>
p \left(X_1, X_2, \dots, X_n \right) = \prod p(X_{\pi_i}\vert X_{\pi_1}, \ldots, X_{\pi_{i-1}}),<br>
$$</p>
<p>where $\pi_i$ is a permutation of indices. Since you can do this for any permutation $\pi$, the mapping between such factorizations and the joint distribution they express is many-to-one. As you can see this in the image below. The different factorizations induce a different graph, but have the same joint distribution.</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card"><img src="https://www.inference.vc/content/images/2021/04/many_to_one-1.png" class="kg-image" alt="Causal inference 4: Causal Diagrams, Markov Factorization, Structural Equation Models" loading="lazy" width="775" height="388" srcset="https://www.inference.vc/content/images/size/w600/2021/04/many_to_one-1.png 600w, https://www.inference.vc/content/images/2021/04/many_to_one-1.png 775w" sizes="(min-width: 720px) 720px"></figure><p>Since you are reading this post, you may already be aware that in causal inference we often talk about a causal factorization, which looks like</p><p>$$<br>p \left(X_1, X_2, \dots, X_n \right) = \prod_{i=1}^{n} p\left(X_i | X_{\mathrm{pa}(i)}\right),<br>$$</p><p>where $\mathrm{pa}(X_i)$ denotes the causal parents of node $X_i$. This is one of many possible ways you can factorize the joint distribution, but we consider this one special. In the recent work, <a href="https://arxiv.org/abs/2102.11107">Sch&#xF6;lkopf et al.</a> call it a <em>disentangled</em> model. What are disentangled models? Disentangled factors describe independent aspects of the mechanism that generated the data. And they are not independent because you factored them in this way, but you were looking for this factorization because its factors are independent.</p><p>In other words, for every joint distribution there are many possible factorizations, but we assume that only one, the causal or disentangled factorization, describes the true underlying process that generated the data.</p><p>Let&apos;s consider an example for <em>disentangled</em> models. We want to model the joint distribution of altitude $A$ and temperature $T$. In this case, the causal direction is $A \rightarrow T$ - if the altitude changes, the distribution of the temperature will change too. But you cannot change the altitude by artificially heating a city - otherwise we all would enjoy views as in Miami; global warming is real but fortunately has no altitude-changing effect.<br>In the end, we get the factorization of $p(A)p(T|A)$. The important insights here are the answers to the question: What do we expect from these factors? The previously-mentioned Sch&#xF6;lkopf et al. paper calls the main takeaway the <strong>Independent Causal Mechanisms (ICM) Principle</strong>, i.e.</p><blockquote>By conditioning on the parents of any factor in the disentangled model, the factor will neither be able to give you further information about other factors nor is able to influence them.</blockquote><p>In the above example, this means that if you consider different countries with their altitude distributions, you can still use the same $p(T|A),$ i.e., the factors <strong>generalize</strong> well. For <em>no influence</em>, the example holds straight above the ICM Principle. Furthermore, knowing any of the factors - e.g. $p(A)$ - won&apos;t tell anything about the other <em>(no information)</em>. If you know which country you are in, so will have no clue about the climate (if you consulted the website of the corresponding weather agency, that&apos;s what I call cheating). In the other direction, despite being the top-of-class student in climate matters, you won&apos;t be able to tell the country if somebody says to you that here the altitude is 350 meters and the temperature is 7&#xB0;C!</p><!--kg-card-begin: markdown--><h2 id="statisticalvscausalinference">Statistical vs causal inference</h2>
<p>We discussed Markov factorizations, as they help us understand the philosophical difference between statistical and causal inference. The beauty, and a source of confusion, is that one can use Markov factorizations in both paradigms.</p>
<blockquote>
<p>However, while using Markov factorizations is optional for statistical inference, it is a must for causal inference.</p>
</blockquote>
<p>So why would a statistical inference person use Markov factorizations? Because they make life easier in the sense that you do not need to worry about too high electricty costs. Namely, factorized models of data can be computationally much more efficient. Instead of modeling a joint distribution directly, which has a lot of parameters - in the case of $n$ binary variables, that is $2^n-1$ different values -, a factorized version can be pretty lightweight and parameter-efficient. If you are able to factorize the joint in a way that you have 8 factors with $n/8$ variables each, then you can describe your model with $8\times2^{n/8}-1$ parameters. If $n=16$, that is $65,535$ vs $31$. Similarly, representing your distibution in a factorized form gives rise to efficient, general-purpose message-passing algorithms, such as belief propagation or expectation propagation.</p>
<p>On the other hand, causal inference people really need this, otherwise, they are lost. Because without Markov factorizations, they cannot really formulate causal claims.</p>
<blockquote>
<p>A causal practicioner uses Markov factorizations, because this way she is able to reason about interventions.</p>
</blockquote>
<p>If you do not have the disentangled factorization, you cannot model the effect of interventions <em>on the real mechanisms</em> that make the system tick.</p>
<h3 id="connectiontodomainadaptation">Connection to domain adaptation</h3>
<p>In plain machine learning lingo, what you want to do is <em>domain adaptation,</em> that is, you want to draw conclusions about a distribution you did not observe (these are the interventional ones). The Markov factorization prescribes ways in which you expect the distribution to change - one factor at a time - and thus the set of distributions you want to be able to robustly generalise to or draw inferences about.</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><h2 id="docalculus">Do calculus</h2>
<p>Do-caclculus, the topic of the <a href="http://inference.vc/untitled">first post</a> in the series, can be relatively simply described using Markov factorizations. As you remember, $\mathrm{do}(X=x)$ means that we set the variable $X$ to the value $x$, meaning that the distribution of that variable $p(X)$ collapses to a point mass. We can model this intervention mathematically by replacing the factor $p( x \vert \mathrm{pa}(X))$ by a Dirac-delta $\delta_x$, resulting in the deletion of all incoming edges of the intervened factors in the graphical model. We then marginalise over $x$ to calculate the joint distribution of the remaining variables. For example, if we have two variables $x$ and $y$ we can write:</p>
<p>$$<br>
p(y\vert do(X=x_0)) = \int p(x,y) \frac{\delta(x - x_0)}{p(x\vert y)} dx<br>
$$</p>
<h2 id="semsmarkovfactorizationandthereparamtrizationtrick">SEMs, Markov factorization, and the reparamtrization trick</h2>
<p>If you&apos;ve read the previous parts in this series, you&apos;ll know that Markov factorizations aren&apos;t the only tool we use in causal inference. For counterfactuals, we used structural equation models (SEMs). In this part we will illustrate the connection between these with a cheesy reference to the reparametrization trick used in VAEs among others.</p>
<p>But before that, let&apos;s recap SEMs. In this case, you define the relationship between the child node and its parents via a functional assignment. For node $X$ with parents $\mathrm{pa}(X)$ it has the form of</p>
<p>$$<br>
X = f(\mathrm{pa}(X), \epsilon),<br>
$$</p>
<p>with some noise $\epsilon.$ Here, you should read &quot;=&quot; in the sense of an assigment (like in Python), in mathematics, this should be &quot;:=&quot;.<br>
The above equation expresses the conditional probability $ p\left(X| \mathrm{pa}(X)\right)$ as a <em>deterministic</em> function of $X$ and some noise variable $\epsilon$. Wait a second..., isn&apos;t it the same thing what the reparametrization trick does? Yes it is.</p>
<blockquote>
<p>So the SEM formulation (called the <em>implicit distribution</em>) is related via the reparametrization trick to the conditional probability of $X$ given its parents.</p>
</blockquote>
<h3 id="classesofcausalmodels">Classes of causal models</h3>
<p>Thus, we can say that a SEM is a conditional distribution, and vica versa. Okay, but how do the sets of these constructs relate to each other?<br>
If you have a SEM, then you can read off the conditional, which is <strong>unique</strong>. On the other hand, you can find more SEMs for the same conditional.  Just as you can express a conditional distribution in multiple different ways using different reparametrizations, it is possible to express the same Markov factorization by multiple SEMs. Consider for example that if your distribution is $\mathcal{N}(\mu,\sigma),$ then multiplying it by -1 gives you the same distribution. In this sense, SEMs are a richer class of models than Markov factorizations, thus they allow us to make inferences (counterfactual) which we weren&apos;t able to express in the more coarse grained language of Markov Factorizations.</p>
<p>As we discussed above, a single joint distribution has multiple valid Markov factorizations, and the same Markov factorization can be expressed as different SEMs. We can think of joint distributions, Markov factorizations, and SEMs as increasingly fine-grained model classes: joint distributions $\subset$ Markov facorizations $\subset$ SEMs. The more aspects of the data generating process you model, the more elaborate the set of inferences you can make become. Thus, Joint distributions allow you to make predictions under no mechanism shift, Markov factorizations allow you to model interventions, SEMs allow you to make counterfactual statements.</p>
<p>The price you pay for more expressive models is that they also get generally much harder to estimate from data. In fact, some aspects of causal models are impossible to infer from i.i.d. observational data. Moreover, some counterfactual inferences are experimentally not verifiable.</p>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[On Information Theoretic Bounds for SGD]]></title><description><![CDATA[<p>Few days ago we had a talk by Gergely Neu, who presented his recent work:</p><ul><li>Gergely Neu <a href="https://arxiv.org/abs/2102.00931">Information-Theoretic Generalization Bounds for Stochastic Gradient Descent</a></li></ul><p>I&apos;m writing this post mostly to annoy him, by presenting this work using super hand-wavy intuitions and cartoon figures. If this isn&apos;t</p>]]></description><link>https://www.inference.vc/on-information-theoretic-bounds-for-sgd/</link><guid isPermaLink="false">60817747e5f995003a1b5643</guid><category><![CDATA[generalization]]></category><category><![CDATA[information theory]]></category><dc:creator><![CDATA[Ferenc Huszar]]></dc:creator><pubDate>Fri, 23 Apr 2021 14:17:49 GMT</pubDate><media:content url="https://www.inference.vc/content/images/2021/04/PNG-image-16ED63A8BA1E-1-6.png" medium="image"/><content:encoded><![CDATA[<img src="https://www.inference.vc/content/images/2021/04/PNG-image-16ED63A8BA1E-1-6.png" alt="On Information Theoretic Bounds for SGD"><p>Few days ago we had a talk by Gergely Neu, who presented his recent work:</p><ul><li>Gergely Neu <a href="https://arxiv.org/abs/2102.00931">Information-Theoretic Generalization Bounds for Stochastic Gradient Descent</a></li></ul><p>I&apos;m writing this post mostly to annoy him, by presenting this work using super hand-wavy intuitions and cartoon figures. If this isn&apos;t enough, I will even find a way to mention GANs in this context.</p><p>But truthfully, I&apos;m just excited because for once, there is a little bit of learning theory that I half-understand, at least at an intuitive level, thanks to its reliance on KL divergences and the mutual information.</p><h2 id="a-simple-guessing-game">A simple &#xA0;guessing game</h2><p>Let&apos;s start this with a simple thought experiment to illustrate why and how mutual information may be useful in describing an algorithm&apos;s ability to generalize. Say we&apos;re given two datasets, $\mathcal{D}_{train}$ and &#xA0;$\mathcal{D}_{test}$, of the same size for simplicity. We play the following game: we both have access to $\mathcal{D}_{train}$ and &#xA0;$\mathcal{D}_{test}$, and we both know what learning algorithm, $\operatorname{Alg}$ we&apos;re going to use.</p><p>Now I toss a coin &#xA0;and I keep the result (recorded as random variable $Y$) a secret. If it&apos;s heads, I run $\operatorname{Alg}$ on the training set $\mathcal{D}_{train}$. If it&apos;s tails, I run $\operatorname{Alg}$ on the test data $\mathcal{D}_{test}$ instead. I don&apos;t tell you which of these I did, I only reveal to you the final parameter value $W$. Can you guess, just by looking at $W$, whether I trained on training or test data?</p><p>If you cannot guess $Y$, that means that the algorithm returns the same random $W$ irrespective of whether you train it on training or test data. So the training and test losses become interchangeable. This implies that the algorithm will generalize very well (on average) and not overfit to the data it&apos;s trained on.</p><p>The mutual information, in this case between $W$ and $Y$ quantifies your theoretical ability to guess $Y$ from $W$. The higher this value is, the easier it is to tell which dataset the algorithm was trained on. If it&apos;s easy to reverse engineer my coin toss from parameters, it means that the algorithm&apos;s output is very sensitive to the input dataset it&apos;s trained on. And that likely implies poor generalization.</p><p>Note by: an algorithm generalizing well on average doesn&apos;t mean it works well on average. It just means that there won&apos;t be a large gap between the expected training and expected test error. Take for example an algorithm returns a randomly initialized neural network, without even touching the data. That algorithm generalizes extremely well on average: it does just as poorly on test data as it does on training data.</p><h2 id="illustrating-this-in-more-detail">Illustrating this in more detail</h2><p>Below is an illustration of my thought experiment for SGD.</p><figure class="kg-card kg-image-card"><img src="https://www.inference.vc/content/images/2021/04/two_SGD.png" class="kg-image" alt="On Information Theoretic Bounds for SGD" loading="lazy" width="2000" height="1276" srcset="https://www.inference.vc/content/images/size/w600/2021/04/two_SGD.png 600w, https://www.inference.vc/content/images/size/w1000/2021/04/two_SGD.png 1000w, https://www.inference.vc/content/images/size/w1600/2021/04/two_SGD.png 1600w, https://www.inference.vc/content/images/size/w2400/2021/04/two_SGD.png 2400w" sizes="(min-width: 720px) 720px"></figure><p>In the top row, I doodled the distribution of the parameter $W_t$ at various timesteps $t=0,1,2,\ldots,T$ of SGD. We start the algorithm by initializing $W$ randomly from a Gaussian (left panel). Then, each stochastic gradient update changes the distribution of $W_t$ a bit compared to the distribution of $W_{t-1}$. How the shape of the distribution changes depends on the data we use in the SGD steps. In the top row, let&apos;s say I ran SGD on $\mathcal{D}_{train}$ and in the bottom, I run it on $\mathcal{D}_{test}$. The distibutions $p(W_t\vert \mathcal{D})$ I drew here describe where the SGD iterate is likely to be after $t$ steps of SGD started from random initialization. They are not to be confused with Bayesian posteriors, for example.</p><p>We know that running the algorithm on the test set would produce low test error. Therefore, sampling a weight vector $W$ from $p(W_T\vert \mathcal{D}_{test})$ would be great if we could do that. But in practice, we can&apos;t train on the test data, all we have the ability to sample from is $p(W_T\vert \mathcal{D}_{train})$. So what we&apos;d like for good generalization, is if $p(W_T\vert \mathcal{D}_{test})$ and $p(W_T\vert \mathcal{D}_{train})$ were as close as possible. The mutual information between $W_T$ and my coinflip $Y$ measures this closeness in terms of the Jensen-Shannon divergence:</p><p>$$<br>\mathbb{I}[Y, W_T] = \operatorname{JSD}[p(W_T\vert \mathcal{D}_{test})\|p(W_T\vert \mathcal{D}_{train})]<br>$$</p><p>So, in summary, if we can guarantee that the final parameter an algorithm comes up with doesn&apos;t reveal too much information about what dataset it was trained on, we can hope that the algorithm has good generalization properties.</p><h2 id="mutual-inforrmation-based-generalization-bounds">Mutual Inforrmation-based Generalization Bounds</h2><p>These vague intuitions can be formalized into real information-theoretic generalization bounds. These were first presented in a general context in (<a href="http://proceedings.mlr.press/v51/russo16.html">Russo and Zou, 2016</a>) and in a more clearly machine learning context in (<a href="https://proceedings.neurips.cc/paper/2017/hash/ad71c82b22f4f65b9398f76d8be4c615-Abstract.html">Xu and Raginsky, 2017</a>). I&apos;ll give a quick - and possibly somewhat handwavy - overview of the main results.</p><p>Let $\mathcal{D}$ and $\mathcal{D}&apos;$ be random datasets of size $n$, drawn i.i.d. from some underlying data distribution $P$. Let $W$ be a parameter vector, which we obtain by running a learning algorithm $\operatorname{Alg}$ on the training data $\mathcal{D}$: $W = \operatorname{Alg}(\mathcal{D})$. The algorithm may be non-deterministic, i.e. it may output a random $W$ given a dataset. Let $\mathcal{L}(W, \mathcal{D})$ denote the loss of model $W$ on dataset $\mathcal{D}$. The expected generalization error of $\operatorname{Alg}$ is defined as follows:</p><p>$$<br>\text{gen}( \operatorname{Alg}, P) = \mathbb{E}_{\mathcal{D}\sim P^n,\mathcal{D}&apos;\sim P^n, W\vert \mathcal{D}\sim \operatorname{Alg}(\mathcal{D})}[\mathcal{L}(W, \mathcal{D}&apos;) - \mathcal{L}(W, \mathcal{D})]<br>$$</p><p>If we unpack this, we have two datasets $\mathcal{D}$ and $\mathcal{D}&apos;$, the former taking the role of the training dataset, the latter of the test data. We look at the expected difference between the training and test losses ($\mathcal{L}(W, \mathcal{D})$ and $\mathcal{L}(W, \mathcal{D}&apos;)$), where $W$ is obtained by running $\operatorname{Alg}$ on the training data $\mathcal{D}$. The expectation is taken over all possible random training sets, test sets, and over all possible random outcomes of the learning algorithm.</p><p>The information theoretic bound states that for any learning algorithm, and any loss function that&apos;s bounded by $1$, the following inequality holds:</p><p>$$<br>gen(\operatorname{Alg}, P) \leq \sqrt{\frac{\mathbb{I}[W, \mathcal{D}]}{n}}<br>$$</p><p>The main term in the RHS of this bound is the mutual infomation between the training data \mathcal{D} and the pararmeter vector $W$ the algorithm finds. It essentially quantifies the number of bits of information the algorithm leaks about the training data into the parameters it learns. The lower this number, the better the algorithm generalizes.</p><h2 id="why-we-can-t-apply-this-to-sgd">Why we can&apos;t apply this to SGD?</h2><p>The problem with applying these nice, intuitive bounds to SGD is that SGD, in fact, leaks too much information about the specific minibatches it is trained on. Let&apos;s go back to my illustrative example of having to guess if we ran the algorithm on training or test data. Consider the scenario where we start form some parameter value $w_t$ and we update either with a random minibatch of training data (blue) or a random minibatch of test data (orange).</p><figure class="kg-card kg-image-card"><img src="https://www.inference.vc/content/images/2021/04/parameter_updates.png" class="kg-image" alt="On Information Theoretic Bounds for SGD" loading="lazy" width="1047" height="881" srcset="https://www.inference.vc/content/images/size/w600/2021/04/parameter_updates.png 600w, https://www.inference.vc/content/images/size/w1000/2021/04/parameter_updates.png 1000w, https://www.inference.vc/content/images/2021/04/parameter_updates.png 1047w" sizes="(min-width: 720px) 720px"></figure><p>Since the training and test datasets are assumed to be of finite size, there are only a finite number of possible minibatches. Each of these minibatches can take the parameter to a unique new location. The problem is, the set of locations you can reach with one dataset (blue dots) does not overlap with the set of locations you can reach if you update with the other dataset (orange dots). Suddenly, if I give you $w_{t+1}$, you can immediately tell if it&apos;s an orange or blue dot, so you can immediately reconstruct my coinflip $Y$.</p><p>In the more general case, the problem with SGD in the context of information-theoretic bounds is that the amount of information SGD leaks about the dataset it was trained on is high, and in some cases may even be infinite. This is actually related to the problem that several of us noticed in the context of GANs, where the true and fake distributions may have non-overlapping support, making the KL divergence infinite, and saturating out the Jensen-Shannon divergence. The first trick we came up with to solve this problem was to smooth things out by <a href="https://www.inference.vc/instance-noise-a-trick-for-stabilising-gan-training/">adding Gaussian noise</a>. Indeed, adding noise is key what researches have been doing to apply these information-theoretic bounds to SGD.</p><h3 id="adding-noise-to-sgd">Adding noise to SGD</h3><p>The first thing people did (<a href="https://arxiv.org/abs/1801.04295">Pensia et al, 2018</a>) is to study a noisy cousin of SGD: stochastic gradient Langevin dynamics (SGLD). SGDL is like SGD but in each iteration we add a bit of Gaussian noise to the parameters in addition to the gradient update. To understand why SGLD leaks less information, consider the previous example with the orange and blue point clouds. SGLD makes those point clouds overlap by convolving them with Gaussian noise.</p><p>However, SGLD is not exactly SGD, and it&apos;s not really used as much in practice. In order to say something about SGD specifically, <a href="https://arxiv.org/abs/2102.00931">Neu (2021)</a> did something else, while still relying on the idea of adding noise. Instead of baking the noise in as part of the algorithm, Neu only adds noise as part of the analysis. The algorithm being analysed is still SGD, but when we measure the mutual information we will measure the mutual information between $\mathbb{I}[W + \xi; \mathcal{D}]$, where $\xi$ is Gaussian noise. </p><p>I leave it to you to check out the details of the paper. While the findings fall short of explaining whether SGD have any tendency to find solutions that generalise well, some of the results are nice and interpretable: they connect the generalization of SGD to the noisiness of gradients as well as the smoothness of the loss along the specific optimization path that was taken.</p>]]></content:encoded></item><item><title><![CDATA[Notes on the Origin of Implicit Regularization in SGD]]></title><description><![CDATA[<p>I wanted to highlight an intriguing paper I presented at a journal club recently:</p><ul><li>Samuel L Smith, Benoit Dherin, David Barrett, Soham De (2021) <a href="https://openreview.net/forum?id=rq_Qr0c1Hyo">On the Origin of Implicit Regularization in Stochastic Gradient Descent</a></li></ul><p>There&apos;s actually a related paper that came out simultaneously, studying full-batch gradient descent instead</p>]]></description><link>https://www.inference.vc/notes-on-the-origin-of-implicit-regularization-in-stochastic-gradient-descent/</link><guid isPermaLink="false">6065ae116b8e12003bfa063b</guid><category><![CDATA[deep learning]]></category><category><![CDATA[generalization]]></category><category><![CDATA[SGD]]></category><category><![CDATA[differerntial equations]]></category><dc:creator><![CDATA[Ferenc Huszar]]></dc:creator><pubDate>Thu, 01 Apr 2021 14:23:24 GMT</pubDate><media:content url="https://www.inference.vc/content/images/2021/04/xRYHk0m-1.png" medium="image"/><content:encoded><![CDATA[<img src="https://www.inference.vc/content/images/2021/04/xRYHk0m-1.png" alt="Notes on the Origin of Implicit Regularization in SGD"><p>I wanted to highlight an intriguing paper I presented at a journal club recently:</p><ul><li>Samuel L Smith, Benoit Dherin, David Barrett, Soham De (2021) <a href="https://openreview.net/forum?id=rq_Qr0c1Hyo">On the Origin of Implicit Regularization in Stochastic Gradient Descent</a></li></ul><p>There&apos;s actually a related paper that came out simultaneously, studying full-batch gradient descent instead of SGD:</p><ul><li>David G.T. Barrett, Benoit Dherin (2021) <a href="https://arxiv.org/abs/2009.11162">Implicit Gradient Regularization</a></li></ul><p>One of the most important insights in machine learning over the past few years relates to the importance of optimization algorithms in generalization performance.</p><h2 id="why-deep-learning-works-at-all">Why deep learning works at all</h2><p>In order to understand why deep learning works as well as it does, it is insufficient to reason about the loss function or the model class, which is what classical generalisation theory focussed on. Instead, the algorithms we use to find minima (namely, stochastic gradient descent) seem to play an important role. In many tasks, powerful neural networks are able to interpolate training data, i.e. achieve near-0 training loss. There are in fact several minima of the training loss which are virtually indistinguishably good on the training data. Some of these minima generalise well (i.e. result in low test error), others can be arbitrarily badly overfit.</p><p>What seems to be important then is not whether the optimization algorithm converges quickly to a local minimum, but which of the available &quot;virtually global&quot; minima it prefers to reach. It seems to be the case that the optimization algorithms we use to train deep neural networks <em>prefer</em> some minima over others, and that this preference results in better generalisation performance. The preference of optimization algorithms to converge to certain minima while avoiding others is described as <em>implicit regularization</em>.</p><p>I wrote <a href="https://hackmd.io/75gt3X6WQbu1_A3pF8svWg">this note</a> as an overview on how we/I currently think about why deep networks generalize.</p><h2 id="analysing-the-effect-of-finite-stepsize">Analysing the effect of finite stepsize</h2><p>One of the interesting new theories that helped me imagine what happens in deep learning training is that of <a href="https://www.inference.vc/neural-tangent-kernels-some-intuition-for-kernel-gradient-descent/">neural tangent kernels</a>. In this framework we study neural network training in the limit of infinitely wide layers, full-batch training and infinitesimally small learning rate, i.e. when gradient becomes continuous gradient flow, described by an ordinary differential equation. Although the theory is useful and appealing, full-batch training with infinitesimally small learning rates is very much a cartoon version of what we actually do in practice. In practice, the smallest learning date doesn&apos;t always work best. Secondly, the stochasticity of gradient updates in minibatch-SGD seems to be of importance as well.</p><p>What <a href="https://openreview.net/forum?id=rq_Qr0c1Hyo">Smith et al (2021)</a> do differently in this paper is they try to study minibatch-SGD, for small, but not infinitesimally small, learning rates. This is much closer to practice. The toolkit that allows them to study this scenario is borrowed from the study of differential equations and is called backward error analysis. The cartoon illustration below shows what backward error analysis tries to achieve:</p><figure class="kg-card kg-image-card"><img src="https://www.inference.vc/content/images/2021/04/Backward-error-analysis.png" class="kg-image" alt="Notes on the Origin of Implicit Regularization in SGD" loading="lazy" width="531" height="482"></figure><p>Let&apos;s say we have a differential equation $\dot{\omega} = f(\omega)$. The solution to this ODE with initial condition $\omega_0$ is a continuous trajectory $\omega_t$, shown in the image in black. We usually can&apos;t compute this solution in closed form, and instead simulate the ODE using the Euler&apos;s method, $\omega_{k+1} = \omega_k + \epsilon f(\omega_k)$. This results in a discrete trajectory shown in teal. Due to discretization error, for finite stepsize $\epsilon$, this discrete path may not lie exactly where the continuous black path lies. Errors accumulate over time, as shown in this illustration. The goal of backward error analysis is to find a different ODE, $\dot{\omega} = \tilde{f}(\omega)$ such that the approximate discrete path we got from Euler&apos;s method lieas near the the continuous path which solves this new ODE. Our goal is to reverse engineer a modified $\tilde{f}$ such that the discrete iteration can be well-modelled by an ODE.</p><p>Why is this useful? Because the form $\tilde{f}$ takes can reveal interesting aspects of the behaviour of the discrete algorithm, particularly if it has any implicit bias towards moving into different areas of the space. When the authors apply this technique to (full-batch) gradient descent, it already suggests the kind of implicit regularization bias gradient descent has.</p><p>In Gradient descent with a cost function $C$, the original ODE is $f(\omega) = -\nabla C (\omega)$. The modified ODE which corresponds to a finite stepsize $\epsilon$ takes the form $\dot{\omega} = -\nabla\tilde{C}_{GD}(\omega)$ where</p><p>$$<br>\tilde{C}_{GD}(\omega) = C(\omega) + \frac{\epsilon}{4} \|\nabla C(\omega)\|^2<br>$$</p><p>So, gradient descent with finite stepsize $\epsilon$ is like running gradient flow, but with an added penalty that penalises the gradients of the loss function. The second term is what <a href="https://arxiv.org/pdf/2009.11162.pdf">Barret and Dherin (2021)</a> call &#xA0;implicit gradient regularization.</p><h2 id="stochastic-gradients">Stochastic Gradients</h2><p>Analysing SGD in this framework is a bit more difficult because the trajectory in stochastic gradient descent is, well, stochastic. Therefore, you don&apos;t have have a single discrete trajectory to optimize, but instead you have a distribution of different trajectories which you&apos;d traverse if you randomly reshuffle your data. Here&apos;s a picture illustrating this situation:</p><figure class="kg-card kg-image-card"><img src="https://www.inference.vc/content/images/2021/04/Backward-error-analysis--1-.png" class="kg-image" alt="Notes on the Origin of Implicit Regularization in SGD" loading="lazy" width="531" height="482"></figure><p>Starting from the initial point $\omega_0$ we now have multiple trajectories. These correspond to different ways we can shuffle data (in the paper we assume we have a fixed allocation of datapoints to minibatches, and the randomness comes from the order in which the minibatches are considered). The two teal trajectories illustrate two potential paths. The paths end up at a random location, the teal dots show additional random endpoints where trajectories may end up at. The teal star shows the mean of the distribution of random trajectory endpoints.</p><p>The goal in (Smith et al, 2021) is to reverse-engineer an ODE so that the continuous (orange) path lies close to this mean location. The corresponding ODE is of the form $\dot{omega} = -\nabla C_{SGD}(\omega)$, where</p><p>$$<br>\tilde{C}_{SGD}(\omega) = C(\omega) + \frac{\epsilon}{4m} \sum_{k=1}^{m} \|\nabla \hat{C}_k(\omega)\|^2,<br>$$</p><p>where $\hat{C}_k$ is the loss function on the $k^{th}$ minibatch. There are $m$ minibatches in total. Note that this is similar to what we had for gradient descent, but instead of the norm of the full-batch gradient we now have the average norm of minibatch gradients as the implicit regularizer. Another interesting view on this is to look at the difference between the GD and SGD regularizers:</p><p>$$<br>\tilde{C}_{SGD} = \tilde{C}_{GD} + \frac{\epsilon}{4m} \sum_{k=1}^{m} \|\nabla \hat{C}_k(\omega) - C(\omega)\|^2<br>$$</p><p>This additional regularization term, $\frac{1}{m}\sum_{k=1}^{m} \|\nabla \hat{C}_k(\omega) - C(\omega)\|^2$, is something like the total variance of minibatch gradients (the trace of the empirical Fisher information matrix). Intuitively, this regularizer term will avoid parts of the parameter-space where the variance of gradients calculated over different minibatches is high.</p><p>Importantly, while $C_{GD}$ has the same minima as $C$, this is no longer true for $C_{SGD}$. Some minima of $C$ where the variance of gradients is high, is no longer a minimum of $C_{SGD}$. As an implication, not only does SGD follow different trajectories than full-batch GD, it may also converge to completely different solutions.</p><p>As a sidenote, there are many versions of SGD, based on how data is sampled for the gradient updates. Here, it is assumed that the datapoints are assigned to minibatches, but then the minibatches are randomly sampled. This is different from randomly sampling datapoints with replacement from the training data (<a href="https://arxiv.org/abs/1511.06251">Li et al (2015)</a> consider that case), and indeed an analysis of that variant may well lead to different results.</p><h2 id="connection-to-generalization">Connection to generalization</h2><p>Why would an implicit regularization effect avoiding high minibatch gradient variance be useful for generalisation? Well, let&apos;s consider a cartoon illustration of two local minima below:</p><figure class="kg-card kg-image-card"><img src="https://www.inference.vc/content/images/2021/04/xRYHk0m.png" class="kg-image" alt="Notes on the Origin of Implicit Regularization in SGD" loading="lazy" width="926" height="370" srcset="https://www.inference.vc/content/images/size/w600/2021/04/xRYHk0m.png 600w, https://www.inference.vc/content/images/2021/04/xRYHk0m.png 926w" sizes="(min-width: 720px) 720px"></figure><p>Both minima are the same as much as the average loss $C$ is concerned: the value of the minimum is the same, and the width of the two minima are the same. Yet, in the left-hand situation, the wide minimum arises as the average of several minibatch losses, which all look the same, and which all are relatively wide themselves. In the right-hand minimum, the wide average loss minimum arises as the average of a lot of sharp minibatch losses, which all disagree on where exactly the location of the minimum is.</p><p>If we have these two options, it is reasonable to expect the left-hand minimum to generalise better, because the loss function seems to be less sensitive to whichever specific minibatch we are evaluating it on. As a consequence, the loss function also may be less sensitive to whether a datapoint is in the training set or in the test set.</p><h2 id="summary">Summary</h2><p>In summary, this paper is a very interesting analysis of stochastic gradient descent. While it has its limitations (which the authors don&apos;t try to hide and discuss transparently in the paper), it nevertheless contributes a very interesting new technique for analysing optimization algorithms with finite stepsize. I found the paper to be well-written, with the explanation of somewhat tedious details of the analysis clearly laid out. But perhaps I liked this paper most because it confirmed my intuitions about why SGD works, and what type of minima it tends to prefer.</p>]]></content:encoded></item><item><title><![CDATA[An information maximization view on the $\beta$-VAE objective]]></title><description><![CDATA[<h6 id="guest-post-with-d-ra-j-mbor">guest post with <a href="http://dorajambor.com/">D&#xF3;ra J&#xE1;mbor</a></h6><p><br>This is a half-guest-post written jointly with D&#xF3;ra, a fellow participant in a reading group where we recently discussed the original paper on $\beta$-VAEs:</p><ul><li>Irina Higgins et al (ICLR 2017): <a href="http://www.matthey.me/publication/beta-vae/">$\beta$-VAE: Learning Basic Visual Concepts with a</a></li></ul>]]></description><link>https://www.inference.vc/beta-vae/</link><guid isPermaLink="false">60493ffd17b186003957870d</guid><category><![CDATA[VAE]]></category><category><![CDATA[generative models]]></category><category><![CDATA[deep learning]]></category><category><![CDATA[KL divergence]]></category><dc:creator><![CDATA[Dora Jambor]]></dc:creator><pubDate>Thu, 18 Mar 2021 15:18:12 GMT</pubDate><media:content url="https://www.inference.vc/content/images/2021/03/Screenshot-2021-03-18-at-15.17.10.png" medium="image"/><content:encoded><![CDATA[<h6 id="guest-post-with-d-ra-j-mbor">guest post with <a href="http://dorajambor.com/">D&#xF3;ra J&#xE1;mbor</a></h6><img src="https://www.inference.vc/content/images/2021/03/Screenshot-2021-03-18-at-15.17.10.png" alt="An information maximization view on the $\beta$-VAE objective"><p><br>This is a half-guest-post written jointly with D&#xF3;ra, a fellow participant in a reading group where we recently discussed the original paper on $\beta$-VAEs:</p><ul><li>Irina Higgins et al (ICLR 2017): <a href="http://www.matthey.me/publication/beta-vae/">$\beta$-VAE: Learning Basic Visual Concepts with a Constrained Variational Framework</a></li></ul><p>On the surface of it, $\beta$-VAEs are a straightforward extension of VAEs where we are allowed to directly control the tradeoff between the reconstruction and KL loss terms. In an attempt to better understand where the $\beta$-VAE objective comes from, and to further motivate why it makes sense, here we derive &#xA0;$\beta$-VAEs from different first principles than it is presented in the paper. Over to mostly D&#xF3;ra for the rest of this post:</p><h3 id="first-some-notation-">First, some notation:</h3><ul><li>$p_\mathcal{D}(\mathbf{x})$: data distribution</li><li>$q_\psi(\mathbf{z}\vert \mathbf{x})$: representation distribution</li><li>$q_\psi(\mathbf{z}) = \int p_\mathcal{D}(\mathbf{x})q_\psi(\mathbf{z}\vert \mathbf{x})$: aggregate posterior - marginal distribution of representation $Z$</li><li>$q_\psi(\mathbf{x}\vert \mathbf{z}) = \frac{q_\psi(\mathbf{z}\vert \mathbf{x})p_\mathcal{D}(\mathbf{x})}{q_\psi(\mathbf{z})}$: &quot;inverted posterior&quot;</li></ul><h3 id="motivation-and-assumptions-of-beta-vaes">Motivation and assumptions of $\beta$-VAEs</h3><p>Learning disentangled representations that recover the independent data generative factors has been a long-term goal for unsupervised representation learning.</p><p>$\beta$-VAEs were introduced in 2017 with a proposed modification to the original VAE formulation that can achieve better disentanglement in the posterior $q_\psi(\mathbf{z}\vert \mathbf{x})$. An assumption of $\beta$-VAEs is that there are two sets of latent factors, $\mathbf{v}$ and $\mathbf{w}$, that contribute to generating observations $x$ in the real world. One set, $\mathbf{v}$, is coordinate-wise conditionally independent given the observed variable, i.e., $\log p(\mathbf{v}\vert x) = \sum_k \log p(v_k\vert \mathbf{x})$. At the same time, we don&apos;t assume anything about the remaining factors $\mathbf{w}$.</p><p>The factors $v$ are going to be the main object of interest for us. The conditional independence assumption allows us to formulate what it means to disentangle these factors of variation. Consider a representation $\mathbb{z}$ which <em>entangles<strong> </strong></em> coordinates of $v$, in that each coordinate of $\mathbb{z}$ depends on multiple coordinates of $\mathbb{v}$, e.g. $z_1 = f_1(v_1, v_2)$ and $z_2 = f_2(v_1, v_2)$. Such a $\mathbb{z}$ won&apos;t necessarily satisfy co-ordinatewise conditional independence $\log p(\mathbf{z}\vert x) = \sum_k \log p(z_k\vert \mathbf{x})$. However, if each component of $\mathbb{z}$ depended only on one corresponding coordinate of $\mathbf{v}$, for example $z_1 = g_1(v_1)$ and $z_2 = g_2(v_2)$, the component-wise conditional independence would hold for $\mathbb{z}$ too.</p><p>Thus, under these assumptions we can encourage disentanglement to happen by encouraging the posterior $q_\psi(\mathbf{z}\vert \mathbf{x})$ to be coordinate-wise conditionally independent. This can be done by adding a new hyperparameter $\beta$ to the original VAE formulation</p><p>$$<br>\mathcal{L}(\theta, \phi; x, z, \beta) = -\mathbb{E}_{q_{\phi}(x\vert z)p_\mathcal{D}(x)}[\log p_{\theta}(x \vert z)] + \beta \operatorname{KL} (q_{\phi(z\vert x)}\| p(z)),<br>$$</p><p><br>where $\beta$ controls the trade-off between the capacity of the latent information channel and learning conditionally independent latent factors. When $\beta$ is higher than 1, we encourage the posterior $q_\psi(z\vert x)$ to be close to the isotropic unit Gaussian $p(z) = \mathcal{N}(0, I)$, which itself is coordnate-wise independent.</p><h3 id="marginal-versus-conditional-independence">Marginal versus Conditional Independence</h3><p>In this post, we revisit the conditional independence assumption of latent factors, and argue that a more appropriate objective would be to have marginal independence in the latent factors. To show you our intuition, let&apos;s revisit the &quot;Explaining Away&quot; phenomenon from Probabilistic Graphical Models.</p><h4 id="explaining-away">Explaining away</h4><p>Consider three random variables:<br>$A$: Ferenc is grading exams<br>$B$: Ferenc is in a good mood<br>$C$: Ferenc is tweeting a meme</p><p>with the following graphical model $A \rightarrow C \leftarrow B$.</p><p>Here we could assume that Ferenc grading exams is independent of him being in a good mood, i.e., $A \perp B$. However, the pressure of marking exams results in increased likelihood of procrastination, which increases the chances of tweeting memes, too.</p><p>However, as soon as we see a meme being tweeted by him, we know that he either in a good mood or he is grading exams. If &#xA0;we know he is grading exams, that explains why he is tweeting memes, so it&apos;s less likely he&apos;s tweeting memes because he&apos;s a good mood. Consequently, $A \not!\perp B\vert C$.</p><p>In all seriousness, if we have a graphical model $A \rightarrow C \leftarrow B$, in evidence of $C$, independence between $A$ and $B$ no longer holds.</p><h3 id="why-does-this-matter">Why does this matter?</h3><p>We argue that the explaining away phenomenon makes the conditional independence of latent factors undesirable. A much more reasonable assumption about the generative process of the data is that the factors of variation $\mathbf{v}$ are drawn independently, and then the observations are generated conditoned on them. However, if we consider two coordinates of $\mathbb{v}$ and the observation $\mathbf{x}$, we now have a $V_1 \rightarrow \mathbf{X} \leftarrow V_2$ graphical model, thus, conditional independence cannot hold.</p><p></p><p>Instead, we argue that to recover the generative factors of the data, we should encourage latent factors to be marginally independent. In the next section, we set out to derive an algorithm that encourages marginal independence in the representation Z. We will also show how the resulting loss function from this new derivation is actually equivalent to the original $\beta$-VAEs formulation.</p><h3 id="marginally-independent-latent-factors">Marginally Independent Latent Factors</h3><p>We&apos;ll start from desired properties of the representation distribution $q_\psi(z\vert x)$. We&apos;d like this representation to satisfy two properties:</p><ol><li>Marginal independence: We would like the aggregate posterior $q_\psi(z)$ to be close to some fixed and factorized unit Gaussian prior $p(z) = \prod_i p(z_i)$. This encourages $q_\psi(z)$ to exhibit coordinate-wise independence.</li><li>Maximum Information: We&apos;d like the representation $Z$ to retain as much information as possible about the input data $X$.</li></ol><p>Note that without (1), (2) is insufficient, because then any deterministic and invertible function of $X$ would contain maximum information about $X$ but that wouldn&apos;t make it a useful or disentangled representation. Similarly, without (2), (1) is insufficient because if we set $q_\psi(z\vert x) = p(z)$ it would give us a latent representation Z that is coordinate-wise independent, but it is also independent of the data which is not very useful.</p><h3 id="deriving-a-practical-objective">Deriving a practical objective</h3><p>We can achieve a combination of these desiderata by optimizing an objective with the weighted combination of two terms corresponding to the two goals we set out above:</p><p>$$<br>\mathcal{L}(\psi) = \operatorname{KL}[q_\psi(z)| p(z)] - \lambda \mathbb{I}_{q_\psi(z\vert x) p_\mathcal{D}(x)}[X, Z]<br>$$</p><p>Remember, we use $q_\psi(z)$ to denote the aggregate posterior. We will refer to this as the InfoMax objective. Now we&apos;re going to show how this objective can be related to the $\beta$-VAE objective. Let&apos;s first consider the KL term in the above objective:</p><!--kg-card-begin: markdown--><p>\begin{align}<br>
\operatorname{KL}[q_\psi(z)| p(z)] &amp;= \mathbb{E}_{q_\psi(z)} \log \frac{q_\psi(z)}{p(z)}\\<br>
&amp;= \mathbb{E}_{q_\psi(z\vert x)p_\mathcal{D}(x)} \log \frac{q_\psi(z)}{p(z)}\\<br>
&amp;= \mathbb{E}_{q_\psi(z\vert x)p_\mathcal{D}(x)} \log \frac{q_\psi(z)}{q_\psi(z\vert x)} + \mathbb{E}_{q_\psi(z\vert x)p_\mathcal{D}(x)} \log \frac{q_\psi(z\vert x)}{p(z)}\\<br>
&amp;= \mathbb{E}_{q_\psi(z\vert x)p_\mathcal{D}(x)} \log \frac{q_\psi(z)p_\mathcal{D}(x)}{q_\psi(z\vert x)p_\mathcal{D}(x)} + \mathbb{E}_{q_\psi(z\vert x)p_\mathcal{D}(x)} \log \frac{q_\psi(z\vert x)}{p(z)}\\<br>
&amp;= -\mathbb{I}_{q_\psi(z\vert x)p_\mathcal{D}(x)}[X,Z] + \mathbb{E}_{p_\mathcal{D}}\operatorname{KL}[q_\psi(z\vert x)| p(z)]<br>
\end{align}</p>
<!--kg-card-end: markdown--><p>This is interesting. If the mutual information between $X$ and $Z$ is non-zero (which is ideally the case), the above equation shows that latent factors cannot be both marginally and conditionally independent at the same time. It also gives us a way to relate &#xA0;the KL terms representing marginal and conditional independence.</p><p>Putting this back into the InfoMax objective, we have that</p><!--kg-card-begin: markdown--><p>\begin{align}<br>
\mathcal{L}(\psi) &amp;= \operatorname{KL}[q_\psi(z)| p(z)] - \lambda \mathbb{I}_{q_\psi(z\vert x)p_\mathcal{D}(x)}[X, Z]\\<br>
&amp;= \mathbb{E}_{p_\mathcal{D}}\operatorname{KL}[q_\psi(z\vert x)| p(z)] - (\lambda + 1) \mathbb{I}_{q_\psi(z\vert x)p_\mathcal{D}(x)}[X, Z]\<br>
\end{align}</p>
<!--kg-card-end: markdown--><p>Using the KL term in the InfoMax objective, we were able to recover the KL-divergence term that also appears in the $\beta$-VAE (and consequently, VAE) objective.</p><p>At this point, we still haven&apos;t defined the generative model $p_\theta(x\vert z)$, the above objective expresses everything in terms of the data distribution $p_\mathcal{D}$ and the posterior/representation distribution $q_\psi$.</p><p>We will now focus on the 2nd term in our desired objective, the weighted mutual information, which we still can&apos;t easily evaluate. We will now show that we can recover the reconstruction term in $\beta$-VAEs by doing a variational approximation to the mutual information.</p><h3 id="variational-bound-on-mutual-information">Variational bound on mutual information</h3><p>Note the following equality:</p><p>\begin{equation}<br>\mathbb{I}[X,Z] = \mathbb{H}[X] - \mathbb{H}[X\vert Z]<br>\end{equation}</p><p>Since we sample X from the data distribution $p_\mathcal{D}$, we see that the first term $\mathbb{H}[X]$, the entropy of $X$, is constant with respect to the variational parameter $\psi$. We are left to focus on finding a good approximation to the second term $\mathbb{H}[X\vert Z]$. We can do so by minimizing the KL divergence between $q_\psi(x\vert z)$ and an auxilliary distribution $p_\theta(x\vert z)$ to make a variational appoximation to the mutual information:</p><!--kg-card-begin: markdown--><p>$$\mathbb{H}[X\vert Z] = - \mathbb{E}_{q\psi(z\vert x)p_\mathcal{D}(x)} \log q_\psi(x\vert z) \leq \inf_\theta - \mathbb{E}_{q\psi(z\vert x)p_\mathcal{D}(x)} \log p_\theta(x\vert z)$$</p>
<!--kg-card-end: markdown--><h3 id="putting-this-bound-back-together-">Putting this bound back together:</h3><p>Finding this lower bound to MI, we have now recovered the reconstruction term from the $\beta$-VAE objective:</p><!--kg-card-begin: markdown--><p>$$<br>
\mathcal{L}(\psi) + \text{const} \leq - (1 + \lambda) \mathbb{E}_{q_\psi(z\vert x)p_\mathcal{D}(x)} \log p_\theta(x\vert z) + \mathbb{E}_{p_\mathcal{D}}\operatorname{KL}[q_\psi(z\vert x)| p(z)]<br>
$$</p>
<!--kg-card-end: markdown--><p>This is essentially the same as the $\beta$-VAE objective function, where $\beta$ is related to our previous $\lambda$. In particular, $\beta = \frac{1}{1 + \lambda}$. Thus, since we assumed $\lambda&gt;0$ for the InfoMax objective to make sense, we can say that the $\beta$-VAE objective encourages disentanglement in the InfoMax sense for values of $0&lt;\beta&lt;1$.</p><h3 id="takeaways">Takeaways</h3><p>Conceptually, this derivation is interesting because the main object of interest is now the recognition model, $q_\psi(z\vert x)$. That is, the posterior becomes a the focus of the objective function - something that is not the case when we are maximizing model likelihood alone (as explained <a href="https://www.inference.vc/maximum-likelihood-for-representation-learning-2/">here</a>). In this respect, this derivation of the $\beta$-VAE makes more sense from a representation learning viewpoint than the derivation of VAE from maximum likelihood.</p><p>There is a nice symmetry to these two views. There are two joint distributions over latents and observable variables in a VAE. On one hand we have $q_\psi(z\vert x)p_\mathcal{D}(x)$ and on the other we have $p(x)p_\theta(x\vert z)$. The &quot;latent variable model&quot; $q_\psi(z\vert x)p_\mathcal{D}(x)$ is a family of LVMs which has a marginal distribution on observable $\mathbf{x}$ that is exactly the same as the data distribution $p_\mathcal{D}$. So one can say $q_\psi(z\vert x)p_\mathcal{D}(x)$ is a parametric family of latent variable models with whose likelihood is maximal - and we want to choose from this family a model where the representation $q_\psi(z\vert x)$ has nice properties.</p><p>On the flipside, $p(z)p_\theta(x\vert z)$ is a parametic set of models where the marginal distribution of latents is coordinatewise independent, but we would like to choose from this family a model that has good data likelihood.</p><p>The VAE objective tries to move these two latent variable models closer to one another. From the perspective of $q_\psi(z\vert x)p_\mathcal{D}(x)$ this amounts to reproducing the prior $p(z)$ with the aggregate posterior. from the perspective of $p(z)p_\theta(x\vert z)$, it amounts to maximising the data likelihood. When the $\beta$-VAE objective is used, we additionally wish to maximise the mutual information between the observed data and the representation.</p><p>This dual role of information maximization and maximum likelihood has been pointed out before, for example in this paper about the <a href="http://aivalley.com/Papers/MI_NIPS_final.pdf">IM algorithm</a>. The symmetry of variational learning has been exploited a few times, for example in <a href="https://link.springer.com/chapter/10.1007/978-3-662-07952-2_22">yin-yang machines</a>, and more recently also in methods like <a href="https://arxiv.org/abs/1606.00704">adversarially learned inference</a>. </p>]]></content:encoded></item><item><title><![CDATA[Some Intuition on the Neural Tangent Kernel]]></title><description><![CDATA[<p>Neural tangent kernels are a useful tool for understanding neural network training and implicit regularization in gradient descent. But it&apos;s not the easiest concept to wrap your head around. The paper that I found to have been most useful for me to develop an understanding is this one:</p>]]></description><link>https://www.inference.vc/neural-tangent-kernels-some-intuition-for-kernel-gradient-descent/</link><guid isPermaLink="false">5fb6a4e717ce640039c507c5</guid><dc:creator><![CDATA[Ferenc Huszar]]></dc:creator><pubDate>Fri, 20 Nov 2020 13:57:12 GMT</pubDate><media:content url="https://www.inference.vc/content/images/2020/11/download-45-1.png" medium="image"/><content:encoded><![CDATA[<img src="https://www.inference.vc/content/images/2020/11/download-45-1.png" alt="Some Intuition on the Neural Tangent Kernel"><p>Neural tangent kernels are a useful tool for understanding neural network training and implicit regularization in gradient descent. But it&apos;s not the easiest concept to wrap your head around. The paper that I found to have been most useful for me to develop an understanding is this one:</p><ul><li>Lee et al (2019) <a href="https://arxiv.org/abs/1902.06720">Wide Neural Networks of Any Depth Evolve as Linear Models Under Gradient Descent</a></li></ul><p>In this post I will illustrate the concept of neural tangent kernels through a simple 1D regression example. Please feel free to peruse the <a href="https://colab.research.google.com/drive/1zAMTtSuxR5V8xBJL02FMNtCLJuKY9TWg?usp=sharing">google colab notebook</a> I used to make these plots.</p><h2 id="example-1-warming-up">Example 1: Warming up</h2><p>Let&apos;s start from a very boring case begin with. Let&apos;s say we have a function defined over integers between -10 and 20. We parametrize our function as a look-up table, that is the value of the function $f(i)$ at each integer $i$ is described by a separate parameter $\theta_i = f(i)$. I&apos;m initializing the parameters of this function as $\theta_i = 3i+2$. The function is shown by the black dots below:</p><figure class="kg-card kg-image-card"><img src="https://www.inference.vc/content/images/2020/11/download-40.png" class="kg-image" alt="Some Intuition on the Neural Tangent Kernel" loading="lazy" width="522" height="321"></figure><p>Now, let&apos;s consider what happens if we observe a new datapoint, $(x, y) =(10, 50)$, shown by the blue cross. We&apos;re going to take a gradient descent step updating $\theta$. Let&apos;s say we use the squared error loss function $(f(10; \theta) - 50)^2$ and a learning rate $\eta=0.1$. Because the function&apos;s value at $x=10$ only depends on one of the parameter $\theta_10$, only this parameter will be updated. The rest of the parameters, and therefore the rest of the function values remain unchanged. The red arrows illustrate the way function values move in a single gradient descent step: Most values don&apos;t move at all, only one of them moves closer to the observed data. Hence only one visible red arrow.</p><p>However, in machine learning we rarely parametrize functions as lookup tables of individual function values. This parametrization is pretty useless as it doesn&apos;t allow you to interpolate let alone extrapolate to unseen data. Let&apos;s see what happens in a more familiar model: linear regression.</p><h2 id="example-2-linear-function">Example 2: Linear function</h2><p>Let&apos;s now consider the linear function $f(x, \theta) = \theta_1 x + \theta_2$. I initialize the parameters to $\theta_1=3$ and $\theta_2=1$, so at initialisation, I have exactly the same function over integers as I had in the first example. Let&apos;s look at what happens to this function as I update $\theta$ by performing single gradient descent step incorporating the observation $(x, y) =(10, 50)$ as before. Again, red arrows are show how function values move:</p><figure class="kg-card kg-image-card"><img src="https://www.inference.vc/content/images/2020/11/download-37.png" class="kg-image" alt="Some Intuition on the Neural Tangent Kernel" loading="lazy" width="522" height="348"></figure><p>Whoa! What&apos;s going on now? Since individual function values are no longer independently parametrized, we can&apos;t move them independently. The model binds them together through its global parameters &#xA0;$\theta_1$ and $\theta_2$. If we want to move the function closer to the desired output $y=50$ at location $x=10$ the function values elsewhere have to change, too.</p><p>In this case, updating the function with an observation at $x=10$ changes the function value far away from the observation. &#xA0;It even changes the function value in the opposite direction than what one would expect.. This might seem a bit weird, but that&apos;s really how linear models work.</p><p>Now we have a little bit of background to start talking about this neural tangent kernel thing.</p><h2 id="meet-the-neural-tangent-kernel">Meet the neural tangent kernel</h2><p>Given a function $f_\theta(x)$ which is parametrized by $\theta$, its <em>neural tangent kernel</em> $k_\theta(x, x&apos;)$ quantifies how much the function&apos;s value at $x$ changes as we take an infinitesimally small gradient step in $\theta$ incorporating a new observation at $x&apos;$. Another way of phrasing this is: $k(x, x&apos;)$ measures how sensitive the function value at $x$ is to prediction errors at $x&apos;$.</p><p>In the plots before, the size of the red arrows at each location $x$ were given by the following equation:</p><p>$$<br>\eta \tilde{k}_\theta(x, x&apos;) = f\left(x, \theta + \eta \frac{f_\theta(x&apos;)}{d\theta}\right) - f(x, \theta)<br>$$</p><p>In neural network parlance, this is what&apos;s going on: The loss function tells me to increase the function value $f_\theta(x&apos;)$. I back-propagate this through the network to see what change in $\theta$ do I have to make to achieve this. However, moving $f_\theta(x&apos;)$ this way also simultaneously moves $f_\theta(x)$ at other locations $x \neq x&apos;$. $\tilde{k}_\theta(x, x&apos;)$ expresses by how much.</p><p>The neural kernel is basically something like the limit of $\tilde{k}$ in as the stepsize becomes infinitesimally small. In particular:</p><p>$$<br>k(x, x&apos;) = \lim_{\eta \rightarrow 0} \frac{f\left(x, \theta + \eta \frac{df_\theta(x&apos;)}{d\theta}\right) - f(x, \theta)}{\eta}<br>$$</p><p>Using a 1st order Taylor expansion of $f_\theta(x)$, it is possible to show that</p><p>$$<br>k_\theta(x, x&apos;) = \left\langle \frac{df_\theta(x)}{d\theta} , \frac{f_\theta(x&apos;)}{d\theta} \right\rangle<br>$$</p><p>As homework for you: find $k(x, x&apos;)$ &#xA0;and/or $\tilde{k}(x, x&apos;)$ for a fixed $\eta$ in the linear model in the pervious example. Is it linear? Is it something else?</p><p>Note that this is a different derivation from what&apos;s in the paper (which starts from continuous differential equation version of gradient descent).</p><p>Now, I&apos;ll go back to the examples to illustrate two more important property of this kernel: sensitivity to parametrization, and changes during training.</p><h2 id="example-3-reparametrized-linear-model">Example 3: Reparametrized linear model</h2><p>It&apos;s well known that neural networks can be repararmetized in ways that don&apos;t change the actual output of the function, but which may lead to differences in how optimization works. <a href="https://arxiv.org/pdf/1502.03167.pdf">Batchnorm</a> is a well-known example of this. Can we see the effect of reparametrization in the neural tangent kernel? Yes we can. Let&apos;s look at what happens if I reparametrize the linear function I used in the second example as:</p><p>$$<br>f_\theta(x) = \theta_1 x + \color{blue}{10\cdot}\theta_2<br>$$</p><p>but now with parameters $\theta_1=3, \theta_2=\color{blue}{0.1}$. I highlighted in blue what changed. The function itself, at initialization is the same since $10 * 0.1 = 1$. The function class is the same, too, as I can still implement arbitrary linear functions. However, when we look at the effect of a single gradient step, we see that the function changes differently when gradient descent is performed in this parametrisation.</p><figure class="kg-card kg-image-card"><img src="https://www.inference.vc/content/images/2020/11/download-39.png" class="kg-image" alt="Some Intuition on the Neural Tangent Kernel" loading="lazy" width="522" height="348"></figure><p>In this parametization, it became easier for gradient descent to push the whole function up by a constant, while in the previous parametrisation it decided to change the slope. What this demonstrates is that the neural tangent kernel $k_\theta(x, x&apos;)$ is sensitive to reparametrization.</p><h2 id="example-4-tiny-radial-basis-function-network">Example 4: tiny radial basis function network</h2><p>While the linear models may be good illustration, let&apos;s look at what $k_\theta(x, x&apos;)$ looks like in a nonlinear model. Here, I&apos;ll consider a model with two squared exponential basis functions:</p><p>$$<br>f_\theta(x) = \theta_1 \exp\left(-\frac{(x - \theta_2)^2}{30}\right) + \theta_3 \exp\left(-\frac{(x - \theta_4)^2}{30}\right) &#xA0;+ \theta_5,<br>$$</p><p>with initial parameter values $(\theta_1, \theta_2, \theta_3, \theta_4, \theta_5) = (4.0, -10.0, 25.0, 10.0, 50.0)$. These are chosen somewhat arbitrarily and to make the result visually appealing:</p><figure class="kg-card kg-image-card"><img src="https://www.inference.vc/content/images/2020/11/download-41.png" class="kg-image" alt="Some Intuition on the Neural Tangent Kernel" loading="lazy" width="504" height="328"></figure><p>We can visualise the function $\tilde{k}_\theta(x, 10)$ directly, rather than plotting it on top the function. Here I also normalize it by dividing by $\tilde{k}_\theta(10, 10)$.</p><figure class="kg-card kg-image-card"><img src="https://www.inference.vc/content/images/2020/11/download-43.png" class="kg-image" alt="Some Intuition on the Neural Tangent Kernel" loading="lazy" width="504" height="246"></figure><p>What we can see is that this starts to look a bit like a <em>kernel</em> function in that it has higher values near $10$ and decreases as you go farther away. However, a few things are worth noting: the maximum of this kernel function is not at $x=1o$, but at $x=7$. It means, that the function value $f(7)$ changes more in reaction to an observation at $x&apos;=10$ than the value $f(10)$. Secondly, there are some negative values. In this case the previous figure provides a visual explanation why: we can increase the function value at $x=10$ by pushing the valley centred at $\theta_1=4$ away from it, to the left. This parameter change in turn decreases function values on the left-hand wall of the valley. Third, the kernel function converges to a positive constant at its tails - this is because of the offset $\theta_5$.</p><h2 id="example-5-changes-as-we-train">Example 5: Changes as we train</h2><p>Now I&apos;m going to illustrate another important property of the neural tangent kernel: in general, the kernel depends on the parameter value $\theta$, and therefore it changes as the model is trained. Here I show what happens to the kernel as I take 15 gradient ascent steps trying to increase $f(10)$. The purple curve is the one I had at initialization (above), and the orange ones show the kernel at the last gradient step.</p><figure class="kg-card kg-image-card"><img src="https://www.inference.vc/content/images/2020/11/download-45.png" class="kg-image" alt="Some Intuition on the Neural Tangent Kernel" loading="lazy" width="490" height="246"></figure><p>The corresponding changes to the function $f_\theta_t$ changes are shown below:</p><figure class="kg-card kg-image-card"><img src="https://www.inference.vc/content/images/2020/11/download-46.png" class="kg-image" alt="Some Intuition on the Neural Tangent Kernel" loading="lazy" width="504" height="239"></figure><p>So we can see that as the parameter changes, the kernel also changes. The kernel becomes flatter. An explanation of this is that eventually we reach a region of parameter space, where $\theta_4$ changes the fastest. </p><h2 id="why-is-this-interesting">Why is this interesting?</h2><p>It turns out the neural tangent kernel becomes particularly useful when studying learning dynamics in infinitely wide feed-forward neural networks. Why? Because in this limit, two things happen:</p><ol><li>First: if we initialize $\theta_0$ randomly from appropiately chosen distributions, the initial NTK of the network $k_{\theta_0}$ approaches a deterministic kernel as the width increases. This means, that at initialization, $k_{\theta_0}$ doesn&apos;t really depend on $\theta_0$ but is a fixed kernel independent of the specific initialization.</li><li>Second: in the infinite limit the kernel $k_{\theta_t}$ stays constant over time as we optimise $\theta_t$. This removes the parameter dependence during training.</li></ol><p>These two facts put together imply that gradient descent in the infinitely wide and infinitesimally small learning rate limit can be understood as a pretty simple algorithm called <em>kernel gradient descent</em> with a fixed kernel function that depends only on the architecture (number of layers, activations, etc).</p><p>These results, taken together with an older known result by <a href="https://arxiv.org/pdf/1912.02803.pdf">Neal, (1994)</a>, allows us to characterise the probability distribution of minima that gradient descent converges to in this infinite limit as a Gaussian &#xA0;process. For details, see the paper mentioned above.</p><h2 id="don-t-mix-your-kernels">Don&apos;t mix your kernels</h2><p>There are two somewhat related sets of results both involving infinitely wide neural netwoks and kernel functions, so I just wanted to clarify the difference between them:</p><ol><li>the older, well-known result by <a href="https://arxiv.org/pdf/1912.02803.pdf">Neal, (1994)</a>, later extended by others, is that the distribution of $f_\theta$ under random initialization of $\theta$ converges to a Gaussian process. This Gaussian process has a kernel or covariance function which is not, in general, the same as the neural tangent kernel. This old result doesn&apos;t say anything about gradient descent, and is typically used to motivate the use of Gaussian process-based Bayesian methods.</li><li>the new, NTK, result is that the evolution of $f_{\theta_t}$ during gradient descent training can be described in terms of a kernel, the neural tangent kernel, and that in the infinite limit this kernel stays constant during training and is deterministic at initialization. Using this result, it is possible to show that in some cases the distribution of $f_{\theta_t}$ is a Gaussian process at every timestep $t$, not just at initialization. This result also allows us to identify the Gaussian process which describes the limit as $t \rightarrow \infty$. This limiting Gaussian process however is not the same as the posterior Gaussian process which Neal and others would calculate on the basis of the first result.</li></ol><p>So I hope this post helps a bit by building some intuition about what the neural tangent kernel is. If you&apos;re interested, check out the simple <a href="https://colab.research.google.com/drive/1zAMTtSuxR5V8xBJL02FMNtCLJuKY9TWg?usp=sharing">colab notebook</a> I used for these illustrations.</p>]]></content:encoded></item><item><title><![CDATA[Notes on Causally Correct Partial Models]]></title><description><![CDATA[<p>I recently encountered this cool paper in a reading group presentation:</p><ul><li>Rezende et al (2020) Rezende <a href="https://arxiv.org/abs/2002.02836v1">Causally Correct Partial Models for Reinforcement Learning</a></li></ul><p>It&apos;s frankly taken me a long time to understand what was going on, and it took me weeks to write this half-decent explanation of it.</p>]]></description><link>https://www.inference.vc/notes-on-causally-correct-partial-models-2/</link><guid isPermaLink="false">5fad12006af0b10039bc5c8f</guid><dc:creator><![CDATA[Ferenc Huszar]]></dc:creator><pubDate>Thu, 12 Nov 2020 14:58:37 GMT</pubDate><media:content url="https://www.inference.vc/content/images/2020/11/Screenshot-2020-10-28-at-13.41.29-1.png" medium="image"/><content:encoded><![CDATA[<img src="https://www.inference.vc/content/images/2020/11/Screenshot-2020-10-28-at-13.41.29-1.png" alt="Notes on Causally Correct Partial Models"><p>I recently encountered this cool paper in a reading group presentation:</p><ul><li>Rezende et al (2020) Rezende <a href="https://arxiv.org/abs/2002.02836v1">Causally Correct Partial Models for Reinforcement Learning</a></li></ul><p>It&apos;s frankly taken me a long time to understand what was going on, and it took me weeks to write this half-decent explanation of it. The <a href="https://hackmd.io/ag2vVxJzSf-Ve8R88rZWlQ">first notes</a> I wrote followed the logic of the paper more, this in this post I thought I&apos;d just focus on the high level idea, after which hopefully the paper is more straightforward. I wanted to capture the key idea, without the distractions of RNN hidden states, etc, which I found confusing to think about.</p><h2 id="pomdp-setup">POMDP setup</h2><p>To start with the basics, this paper deals with the &#xA0;partially observed Markov decision process (POMDP) setup. The diagram below illustrates what&apos;s going on:</p><figure class="kg-card kg-image-card"><img src="https://www.inference.vc/content/images/2020/10/Screenshot-2020-10-28-at-13.41.29.png" class="kg-image" alt="Notes on Causally Correct Partial Models" loading="lazy" width="564" height="266"></figure><p>The grey nodes $e_t$ show the unobserved state of the environment at each timestep $t=0,1,2\ldots$. At each timestep the agent observes $y_0$ which depends on the current state of the environment (red-ish nodes). The agent then updates their state $s_t$ based on its past state $s_{t-1}$, the new observation $y_t$, and the previous action taken $a_{t-1}$. This is shown by the blue squares (they&apos;re squares, signifying that this node depends deterministically on its parents). Then, based on the agent&apos;s state, it chooses an action $a_t$ from by sampling from policy $\pi(a_t\vert s_t)$. The action influences how the environment&apos;s state, $e_{t+1}$ changes.</p><p>We assume that the agent&apos;s ultimate goal is to maximise reward at the last state at time $T$, which we assume is a deterministic function of the observation $r(y_T)$. Think of this reward as the score in an atari game, which is written on the screen whose contents are made available in $y_t$.</p><h3 id="the-ultimate-goal">The ultimate goal</h3><p>Let&apos;s start by stating what we ultimately would like estimate from the data we have. The assumption is that we sampled the data using some policy $\pi$, but we would like to be able to say how well a different policy $\tilde{\pi}$ would do, in other words, what would be the expected score at time $T$ if instead of $\pi$ we used a different policy $\tilde{\pi}$.</p><p>What we are interested in, is a causal/counterfactual query:</p><p>$$<br>\mathbb{E}_{\tau\sim\tilde{p}}[r(y_T)],<br>$$</p><p>where $\tau = [(s_t, y_t, e_t, a_t) : t=0\ldots T]$ denotes a trajectory or rollout up to time $T$, and $\tilde{p}$ denotes the generative process when using policy $\tilde{\pi}$, that is:</p><p>$$<br>\tilde{p}(\tau) = p(e_0)p(y_0\vert e_0) \tilde{\pi}(a_0\vert s_0) p(s_0)\prod_{t=1}^T p(e_t\vert a_{t-1}, e_{t-1}) p(y_t\vert e_t) \tilde{\pi}(a_t\vert s_t) \delta (s_t - g(s_{t-1}, y_t))<br>$$</p><p>I called this a causal or counterfactual query, because we are interested in making predictions under a different distribution $\tilde{p}$ than $p$ which we have observations from. The difference between $\tilde{p}$ and $p$ can be called an intervention, where we replace specific factors in the data generating process with different ones.</p><p>There are - at least - two ways one could go about estimating such counterfactual distribution:</p><ol><li>model-free, via <em>importance sampling</em>. This method tries to directly estimate the causal query by calculating a weighted average over the observed data. The weights are given by the ratio between $\tilde{\pi}(a_t\vert s_t)$, the probability by which $\tilde{\pi}$ would choose an action and $\pi(a_t\vert s_t)$, the probability it was chosen by the policy that we used to collect the data. A great paper explaining how this works is <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2013/11/bottou13a.pdf">(Bottou et al, 2013)</a>. Importance sampling as the advantage that we don&apos;t have to build any model of the environment, we can directly evaluate the average reward from the samples we have, using only $\pi$ and $\tilde{\pi}$ &#xA0;to calculate the weights. The downside, however, is that importance sampling &#xA0;often incredibly high variance estimate, and is only reliable if $\tilde{\pi}$ and $\pi$ are very close.</li><li>model-based, via <em>causal calculus</em>. If possible, we can <a href="https://www.inference.vc/untitled/">use do-calculus</a> to express the causal query in an alternative way, using various conditional distributions estimated from the observed data. This approach has the disadvantage that it requires us build a model from the data first. We then use the conditional distributions learned from the data to approximate the quantity of interest by plugging them into the formula we got from do-calculus. If our models are imperfect, these imperfections/approximation errors can compound when the causal estimand is calculated, potentially leading to large biases and inaccuracies. On the other hand, our models may be accurate enough to extrapolate to situations where importance weighting would be unreliable.</li></ol><p>In this paper, we focus on solving the problem with causal calculus. This requires us to build a model of observed data, which we can then use to make causal predictions. The key question this paper asks is</p><blockquote>How much of the data do we have to model to be able to make the kinds of causal inferences we would like to make?</blockquote><h3 id="option-1-model-almost-everything">Option 1: model (almost) everything</h3><p>One way we can answer the query above is to model the joint distribution of everything, or mostly everything, that we can observe. For example, we could build a full autoregressive model of observations $y_t$ conditioned on actions $a_t$. In essence this would amount to fitting a model to $p(y_{0:T}\vert a_{0:T})$.</p><p>If we had such model, we would theoretically be able to make causal predictions, for reasons I will explain later. However, this option is ruled out in the paper because we assume the observations $y_t$ are very high dimensional, such as images rendered in a computer game. Thus, modelling the joint distribution of the whole observation sequence $y_{1:T}$ accurately is hopeless and would require a lot of data. Therefore, we would like to get away without modelling the whole observation sequence $y_{1:T}$, which brings us to partial models.</p><h3 id="option-2-partial-models">Option 2: partial models</h3><p>Partial models try to avoid modelling the joint distribution of high-dimensional observations $y_{1:T}$ or agent-state sequences $s_{0:T}$, and focus on modelling directly the distribution of $r(y_T)$ - i.e. only the reward component of the last observation, given the action-sequence $a_{0:T}$. This is clearly a lot easier to do, because $r(y_T)$ is assumed to be a low-dimensional aspect of the full observation $y_T$, so all we have to learn is a model of a scalar conditioned on a sequence of actions $q_\theta(r(y_T)\vert a_{0:T})$. We know very well how to fit such models to realistic amounts of data.</p><p>However, if we don&apos;t include either $y_t$ or $s_t$ in our model, we won&apos;t be able to make the counterfactual inferences we wanted to make in the first place. Why? Let&apos;s look at he data generating process once more:</p><figure class="kg-card kg-image-card"><img src="https://www.inference.vc/content/images/2020/10/Screenshot-2020-10-28-at-13.41.29.png" class="kg-image" alt="Notes on Causally Correct Partial Models" loading="lazy" width="564" height="266"></figure><p>We are trying to model the causal impact of actions $a_0$ and $a_1$ on the outcome $y_2$. Let&apos;s focus on $a_1$. $y_2$ is clearly statistically dependent on $a_1$. However, this statistical dependence emerges due to completely different effects:</p><ul><li><strong>causal association:</strong> $a_1$ influences the state of the environment $e_2$, resulting in an observation $y_2$. Therefore, $a_1$ has an direct causal effect on $y_2$, mediated by $e_2$</li><li><strong>spurious association due to confounding:</strong> The unobserved hidden state $e_1$ is a confounder between the action $a_1$ and the observation $y_2$. The state $e_1$ has an indirect causal effect on $a_1$ mediated by the observation $y_1$ and the agent&apos;s state $s_1$. Similarly $e_1$ has an indirect effect on $y_2$ mediated by $e_2$.</li></ul><p>I illustrated these two sources of statistical association by colour-coding the different paths in the causal graph. The blue path is the confounding path: correlation is induced because both $a_1$ and $y_2$ have $e_1$ as causal ancestor. The red path is the causal path: $a_1$ indirectly influences $y_2$ via the hidden state $e_2$.</p><figure class="kg-card kg-image-card"><img src="https://www.inference.vc/content/images/2020/11/Screenshot-2020-10-28-at-13.41.29.png" class="kg-image" alt="Notes on Causally Correct Partial Models" loading="lazy" width="564" height="266"></figure><p>If we would like to correctly evaluate the consequence of changing policies, we have to be able to disambiguate between these two sources of statistical association, get rid of the blue path, and only take the red path into account. Unfortunately, this is not possible in a partial model, where we only model the distribution of $y_2$ conditional on $a_0$ and $a_1$.</p><p>If we want to draw causal inferences, we <strong>must model the distribution of at least one variable along blue path.</strong> Clearly, $y_1$ and $s_1$ are theoretically observable, and are on the confounding path. Adding either of these to our model would allow us to use the backdoor adjustment formula (explained in the paper). However, this would take us back to Option 1, where we have to model the joint distribution of either sequences of observations $y_{0:T}$ or sequences of states $s_{0:T}$, both assumed to be high-dimensional and difficult to model.</p><h3 id="option-3-causally-correct-partial-models">Option 3: causally correct partial models</h3><p>So we finally got to the core of what is proposed in the paper: a kind of halfway-house between modeling everything and modeling too little. We are going to model <em>enough </em>variables to be able to evaluate causal queries, while keeping the dimensionality of the model we have to fit low. To do this, we change the data generating process slightly - by splitting the policy into two stages:</p><figure class="kg-card kg-image-card"><img src="https://www.inference.vc/content/images/2020/11/JrUSsb4.png" class="kg-image" alt="Notes on Causally Correct Partial Models" loading="lazy" width="634" height="270" srcset="https://www.inference.vc/content/images/size/w600/2020/11/JrUSsb4.png 600w, https://www.inference.vc/content/images/2020/11/JrUSsb4.png 634w"></figure><p>The agent first generates $z_t$ from the state $s_t$, and then uses the sampled $z_t$ value to make a decision $a_t$. One can understand $z_t$ as being a stochastic bottleneck between the agent&apos;s high-dimensional state $s_t$, and the low-dimensional action $a_t$. The assumption is that the sequence $z_{0:T}$ should be a lot easier to model than either $y_{0:T}$ or $s_{0:T}$. However, if we now build a model $p(r(y_T), z_{0:T} \vert a_{0:T})$ are now able to use this model evaluate the causal queries of interest, thanks for the backdoor adjustment formula. For how to precisely do this, please refer to the paper.</p><p>Intuitively, this approach helps by adding a low-dimensional stochastic node along the confounding path. This allows us to compensate for confounding, without having to build a full generative model of sequences of high-dimensional variables. It allows us to solve the problem we need to solve without having to solve a ridiculously difficult subproblem.</p>]]></content:encoded></item><item><title><![CDATA[Meta-Learning Millions of Hyper-parameters using the Implicit Function Theorem]]></title><description><![CDATA[<p>Last night on the train I read this nice paper by David Duvenaud and colleagues. Around midnight I got a calendar notification &quot;it&apos;s David Duvenaud&apos;s birthday&quot;. So I thought it&apos;s time for a David Duvenaud birthday special (don&apos;t get too</p>]]></description><link>https://www.inference.vc/meta-learning-with-the-implicit-function-theorem/</link><guid isPermaLink="false">5dcd5c2289b7c10044af6516</guid><dc:creator><![CDATA[Ferenc Huszar]]></dc:creator><pubDate>Thu, 14 Nov 2019 15:33:49 GMT</pubDate><media:content url="https://www.inference.vc/content/images/2019/11/Screen-Shot-2019-11-14-at-3.03.24-PM.png" medium="image"/><content:encoded><![CDATA[<img src="https://www.inference.vc/content/images/2019/11/Screen-Shot-2019-11-14-at-3.03.24-PM.png" alt="Meta-Learning Millions of Hyper-parameters using the Implicit Function Theorem"><p>Last night on the train I read this nice paper by David Duvenaud and colleagues. Around midnight I got a calendar notification &quot;it&apos;s David Duvenaud&apos;s birthday&quot;. So I thought it&apos;s time for a David Duvenaud birthday special (don&apos;t get too excited David, I won&apos;t make it an annual tradition...)</p><ul><li>Jonathan Lorraine, Paul Vicol, David Duvenaud (2019) <a href="https://arxiv.org/abs/1911.02590">Optimizing Millions of Hyperparameters by Implicit Differentiation</a></li></ul><h2 id="background">Background</h2><p>I recently covered<a href="https://www.inference.vc/notes-on-imaml-meta-learning-without-differentiating-through/"> iMAML: the meta-learning algorithm</a> that makes use of implicit gradients to sidestep backpropagating through the inner loop optimization in meta-learning/hyperparameter tuning. The method presented in (<a href="https://arxiv.org/abs/1911.02590">Lorraine et al, 2019</a>) uses the same high-level idea, but introduces a different - on the surface less fiddly - approximation to the crucial inverse Hessian. I won&apos;t spend a lot of time introducing the whole meta-learning setup from scratch, you can use the previous post as a starting point.</p><h2 id="implicit-function-theorem">Implicit Function Theorem</h2><p>Many - though not all - meta-learning or hyperparameter optimization problems can be stated as nested optimization problems. If we have some hyperparameters $\lambda$ and some parameters $\theta$ we are interested in</p><p>$$<br>\operatorname{argmin}_\lambda \mathcal{L}_V (\operatorname{argmin}_\theta \mathcal{L}_T(\theta, \lambda)),<br>$$</p><p>Where $\mathcal{L}_T$ is some training loss and $\mathcal{L}_V$ a validation loss. The optimal parameter to the training problem, $\theta^\ast$ implicitly depends on the hyperparameters $\lambda$:</p><p>$$<br>\theta^\ast(\lambda) = \operatorname{argmin} f(\theta, \lambda)<br>$$</p><p>If this implicit function mapping $\lambda$ to $\theta^\ast$ is differentiable, and subject to some other conditions, the implicit function theorem states that its derivative is</p><p>$$<br>\left.\frac{\partial\theta^{\ast}}{\partial\lambda}\right\vert_{\lambda_0} = \left.-\left[\frac{\partial^2 \mathcal{L}_T}{\partial \theta \partial \theta}\right]^{-1}\frac{\partial^2\mathcal{L}_T}{\partial \theta \partial \lambda}\right\vert_{\lambda_0, \theta^\ast(\lambda_0)}<br>$$</p><p>The formula we obtained for iMAML is a special case of this where the $\frac{\partial^2\mathcal{L}_T}{\partial \theta \partial \lambda}$ is the identity This is because there, the hyperparameter controls a quadratic regularizer $\frac{1}{2}\|\theta - \lambda\|^2$, and indeed if you differentiate this with respect to both $\lambda$ and $\theta$ you are left with a constant times identity.</p><p>The primary difficulty of course is approximating the inverse Hessian, or indeed matrix-vector products involving this inverse Hessian. This is where iMAML and the method proposed by <a href="https://arxiv.org/abs/1911.02590">Lorraine et al, (2019</a>) differ. iMAML uses a conjugate gradient method to iteratively approximate the gradient. In this work, they use a Neumann series approximation, which, for a matrix $U$ looks as follows:</p><p>$$<br>U^{-1} = \sum_{i=0}^{\infty}(I - U)^i<br>$$</p><p>This is basically a generalization of the better known sum of a geometric series: if you have a scalar $\vert u \vert&lt;1$ then</p><p>$$<br>\sum_{i=0}^\infty q^i = \frac{1}{1-q}.<br>$$</p><p>Using a finite truncation of the Neumann series one can approximate the inverse Hessian in the following way:</p><p>$$<br>\left[\frac{\partial^2 \mathcal{L}_T}{\partial \theta \partial \theta}\right]^{-1} \approx \sum_{i=1}^j \left(I - \frac{\partial^2 \mathcal{L}_T}{\partial \theta \partial \theta}\right)^i.<br>$$</p><p>This Neumann series approximation, at least on the surface, seems significantly less hassle to implement than running a conjugate gradient optimization step.</p><h2 id="experiments">Experiments</h2><p>One of the fun bits of this paper is the interesting set of experiments the authors used to demonstrate the versatility of this approach. For example, in this framework, one can treat the training dataset as a hyperparameter. Optimizing pixel values in a small training dataset, one image per class, allowed the authors to &quot;distill&quot; a dataset into a set of prototypical examples. If you train your neural net on this distilled dataset, you get relatively good validation performance. The results are not quite as image-like as one would imagine, but for some classes, like bikes, you even get recognisable shapes:</p><p>In another experiment the authors trained a network to perform data augmentation, treating parameters of this network as a hyperparameter of a learning task. In both of these cases, the number of hyperparameters optimized were in the hundreds of thousands, way beyond the number we usually consider as hyperparameters.</p><h2 id="limitations">Limitations</h2><p>This method inherits some of the limitations I already discussed with <a href="https://www.inference.vc/notes-on-imaml-meta-learning-without-differentiating-through/">iMAML.</a> Please also see the comments where various people gave pointers to work that overcomes some of these limitations.</p><p>Most crucially, methods based on implicit gradients assume that your learning algorithm (inner loop) finds a unique, optimal parameter that minimises some loss function. This is simply not a valid assumption for SGD where different random seeds might produce very different and differently behaving optima.</p><p>Secondly, this assumption only allows for hyperparameters that control the loss function, but not for ones that control other aspects of the optimization algorithm, such as learning rates, batch sizes or initialization. For those kind of situations, explicit differentiation may still be the most competitive solution. On that note, I also recommend reading this recent paper on <a href="https://arxiv.org/abs/1910.01727">generalized inner-loop meta-learnin</a>g and the associated pytorch package <a href="https://github.com/facebookresearch/higher">higher</a>.</p><h2 id="conclusion">Conclusion</h2><p>Happy birthday David. Nice work!</p>]]></content:encoded></item><item><title><![CDATA[The secular Bayesian: Using belief distributions without really believing]]></title><description><![CDATA[<h2 id="the-religious-bayesian">The religious Bayesian</h2><p>My parents didn&apos;t raise me in a religious tradition. It all started to change when a great scientist took me under his wing and taught me the teachings of Bayes. I travelled the world and spent 4 years in a Bayesian monastery in Cambridge, UK.</p>]]></description><link>https://www.inference.vc/the-secular-bayesian-using-belief-distributions-without-really-believing/</link><guid isPermaLink="false">5dbac64b6c822a003820974f</guid><dc:creator><![CDATA[Ferenc Huszar]]></dc:creator><pubDate>Thu, 31 Oct 2019 15:13:21 GMT</pubDate><media:content url="https://www.inference.vc/content/images/2019/10/image-url-1.jpg" medium="image"/><content:encoded><![CDATA[<h2 id="the-religious-bayesian">The religious Bayesian</h2><img src="https://www.inference.vc/content/images/2019/10/image-url-1.jpg" alt="The secular Bayesian: Using belief distributions without really believing"><p>My parents didn&apos;t raise me in a religious tradition. It all started to change when a great scientist took me under his wing and taught me the teachings of Bayes. I travelled the world and spent 4 years in a Bayesian monastery in Cambridge, UK. This particular place practiced the nonparametric Bayesian doctrine.</p><p>We were religious Bayesians. We looked at the world and all we saw the face of Bayes: if something worked, it did because it had a Bayesian interpretation. If an algorithm did not work, we shunned its creator for being unfaithful to Bayes. &#xA0;We scorned at point estimates, despised p-values. Bayes had the answer to everything. But above all, we believed in our models.</p><figure class="kg-card kg-image-card"><img src="https://www.inference.vc/content/images/2019/10/Bayes_toast.jpg" class="kg-image" alt="The secular Bayesian: Using belief distributions without really believing" loading="lazy"></figure><h2 id="possessed-by-deamons">Possessed by deamons</h2><p>At a convention dominated by Bayesian thinkers I was approached by a frequentist, let&apos;s call him Lucifer (in fact his real name is <a href="https://www.szit.bme.hu/~gyorfi/indexen.html">Laci</a> so not that far off). &quot;Do you believe your data exists?&quot; - he asked. &quot;Yes&quot; I answered. &quot;Do you believe your model and its parameters exist?&quot; &quot;Well, not really, it&apos;s just a model I use to describe reality&quot; I said. Then he told me the following, poisoning my pure Bayesian heart forever: &quot;If you use Bayes&apos; rule, you assume that a joint distribution between model parameters and data exist. This, however, only exists if your data and your parameters both exist, in the same $\sigma$-algebra. You can&apos;t have it both ways. You have to think your model really exists somewhere.&quot; </p><p>I never forgot this encounter, but equally I didn&apos;t think much about it since then. Over the years, I started to doubt more and more aspects of my Bayesian faith. I realised the likelihood was important, but not the only thing that exists. There were scoring rules, loss functions which couldn&apos;t be written as a log-likelihood. I noticed nonparametric Bayesian models weren&apos;t automatically more useful than large parametric ones. &#xA0;I worked on weird stuff like <a href="http://proceedings.mlr.press/v15/lacoste_julien11a.html">loss-calibrated Bayes</a>. I started having thoughts about model misspecification, kind of a taboo topic in the Bayesian church.</p><h2 id="the-secular-bayesian">The secular Bayesian</h2><p>Over the years I came to terms with my Bayesian heritage, and I now live my life as a secular Bayesian. Certain elements of the Bayesian way are no doubt useful: Engineering inductuve biases explicitly into a prior distribution, using probabilities, divergences, information, variational bounds as tools for developing new algorithms. Posterior distributions can capture model uncertainty which can be exploited for active learning or exploration in interactive learning. Bayesian methods often - though not always - lead to increased robustness, better calibration, and so much more. At the same time, I can carry on living my life, use gradient descent to find local minima, use bootstrap to capture uncertainty. And first and foremost, I do not have to believe that my models really exist or perfectly describe reality anymore. I am free to think about model misspecification.</p><p>Lately, I have started to familiarize myself with a new body of work, which I call secular Bayesianism, that combines Bayesian inference with more frequentists ideas about learning from observation. In this body of work, people study model misspecification (see e.g. M-open Bayesian inference). And, I found a resolution to the &quot;you have to believe in your model, you can&apos;t have it both ways&quot; problem that bothered me all these years.</p><h2 id="a-generalized-framework-for-updating-belief-distributions">A generalized framework for updating belief distributions</h2><p>After this rather long intro, let me present the paper this post is really about and which, as a secular Bayesian, I found very interesting:</p><ul><li>P.G. Bissiri, C.C. Holmes and S.G. Walker (2016) <a href="https://rss.onlinelibrary.wiley.com/doi/pdf/10.1111/rssb.12158">A General Framework for Updating Belief Distributions</a></li></ul><p>This paper basically asks: can we take the belief out of belief distributions? Let&apos;s say we want to estimate some parameter of interest $\theta$ from data. Does it still make sense to specify a prior distribution over this parameter, and then update them in light of data using some kind of Bayes rule-like update mechanism to form posterior distributions, all without assuming that the parameter of interest $\theta$ and the observations $x_i$ are linked to one another via a probabilistic model? And if it is meaningful, what form would that update rule take.</p><h3 id="the-setup">The setup</h3><p>First of all, for simplicity, let&apos;s assume that data $x_i$ is sampled i.i.d from some distribution $P$. That&apos;s right, not exchangeable, actually i.i.d. like in frequentist settings. Let&apos;s also assume that we have some parameter of interest $\theta$. Unlike in Bayesian analysis where $\theta$ usually parametrises some kind of generative model for data $x_i$, we don&apos;t assume anything like that. All we assume is that there is a loss function $\ell$ which connects the parameter to the observations: $\ell(\theta, x)$ measures how well the estimate $\theta$ agrees with observation $x$.</p><p>Let&apos;s say that a priori, without seeing any datapoints we have a prior distribution $\pi$ over $\theta$. Now we observe a datapoint $x_1$. How should we make use of our observation $x_1$, the loss function $\ell$ and the prior $\pi$ to come up with some kind of posterior over this parameter? Let&apos;s denote this update rule $\psi(\ell(\cdot, x_1), \pi)$. There are many ways we could do this, but is there one which is better than the rest?</p><h3 id="desiderata">Desiderata</h3><p>The paper lists a number of desiderata - desired properties the update rule $\psi$ should satisfy. These are all meaningful assumptions to have. The main one is coherence, which is a property somewhat analogous to exchangeability: if we observe a sequence of observations, we would like the resulting posterior to be the same, irrespective of which order the observations are presented. The coherence property can be written as follows</p><p>$$<br>\psi\left(\ell(\cdot, x_2), \psi\left(\ell(\cdot, x_1), \pi\right)\right) = \psi\left(\ell(\cdot, x_1), \psi\left(\ell(\cdot, x_2), \pi \right)\right)<br>$$</p><p>As a desired property, this makes a lot of sense, and Bayes rule obviously satisfies it. However, this is not really how the authors actually define coherence. In Equation (3) they use a more restrictive definition of coherence, further restricting the set of acceptable update rules as follows:</p><p>$$<br>\psi\left(\ell(\cdot, x_2), \psi\left(\ell(\cdot, x_1), \pi\right)\right) = \psi\left(\ell(\cdot, x_1) + \ell(\cdot, x_2), \pi \right)<br>$$</p><p>By combining losses from the two observations in an additive way, one can indeed ensure permuation invariance. However, the sum is not the only way to do this. Any pooling operation over observations would also have satisfied this. For example, one could replace the $\ell(\cdot, x_1) + \ell(\cdot, x_2)$ bit by $\max(\ell(\cdot, x_1), \ell(\cdot, x_2))$ and still satisfy the general principle of coherence. The most general class of permutation invariant functions which would satisfy the general coherence desideratum are discussed in <a href="https://www.inference.vc/deepsets-modeling-permutation-invariance/">DeepSets</a>. Overall, my hunch is that going with the sum is a design choice, rather than a general desideratum. This choice is the real reason why the resulting update rule will end up very Bayes-rule like, as we will see later.</p><p>The other desiderata the paper proposes are actually discussed separately in Section 1.2 of <a href="https://rss.onlinelibrary.wiley.com/doi/pdf/10.1111/rssb.12158">(Brissini et al, 2016)</a>, and called assumptions instead. These are much more basic requirements for the update function. Assumption 2 for example talks about how restricting the prior to a subset should result in a posterior which is also the restricted version of the original posterior. Assumption 3 requires that lower evidence (larger loss) for a parameter should yield smaller posterior probabilities - a monotonicity property.</p><h3 id="uniqueness-of-coherent-update-rule">Uniqueness of coherent update rule</h3><p>One contribution of the paper is showing that all the desiderata mentioned above pinpoint a specific update rule $\psi$ which satisfies all the desired properties. This update takes the following form:</p><p>$$<br>\pi(\theta\vert x_{1:N}) = \psi(\ell(\cdot, x), \pi) \alpha \exp\{-\sum_{n=1}^N\ell(\theta, x_N)\}\pi(\theta)<br>$$</p><p>Just like Bayes rule we have a normalized product of the prior with something that takes the role of the likelihood term. If the loss is the logarithmic loss of a probabilistic model, we recover the Bayes rule, but this update rule makes sense for arbitrary loss functions.</p><p>Again, this solution is unique under the very strong and specific desideratum that we&apos;d like the losses from i.i.d. observations combine in an additive way, and I presume that, had we chosen a different permutation invariant function, we would end up with a similar generalization of Bayes rule with that permutation invariant function appearing in the exponent.</p><h3 id="rationality">Rationality</h3><p>Now that we have an update rule which satisfies our desiderata, can we say if it&apos;s actually a good or useful update rule? It seems it is, in the following sense.</p><p>Let&apos;s think about a way to measure the usefulness of a posterior $\nu$. Suppose we have data sampling distribution $P$, losses are still measured by $\ell$, and our prior is $\pi$. A good posterior does two things well: it allows us to make good decisions in some kind of downstream test scenario, and it is informed by our prior. It therefore makes sense to define a loss function over the posterior $\nu$ as a sum of two terms:</p><p>$$<br>L(\nu; \ell, \pi, P) = h_1(\nu; \ell, P) + h_2(\nu; \pi)<br>$$</p><p>The first term, $h_1$ measures the posterior&apos;s usefulness at test time, and $h_2$ measures how well it&apos;s influenced by the prior. The authors define $h_1$ to be as follows:</p><p>$h_1(\nu; \ell, P) = \mathbb{E}_{x\sim P} \mathbb{E}_\theta\sim\nu \ell(x, \theta)$</p><p>So basically, we will sample from the posterior, and then evaluate the random sample parameter $\theta$ on a randomly chosen test datapoint $x$ using our loss $\ell$. I would say this is a rather narrow view on what it means for a posterior to do well on a downstream task, more about it later in the criticism section. In any case it&apos;s one possible goal for a posterior to try to achieve.</p><p>Now we turn to choosing $h_2$, and the authors note something very interesting. If we want the resulting optimal posterior to possess the coherence property (as defined in their Eqn. (3)), it turns out the only choice for $h_2$ is the KL divergence between the prior and posterior. Any other choice would lead to incoherent updates. This, I believe is only true for the additive definition of coherence, not the more general definition I gave above.</p><p>Putting $h_1$ and $h_2$ together it turns out that the posterior that minimizes this loss function is precisely of the form $\pi(\theta\vert x_{1:N}) \alpha \exp\{-\sum_{n=1}^N \ell(\theta, x_n)\}$. So, not only is this update rule the only update rule that satisfies the desired properties, it is also optimal under this particular definition of optimality/rationality.</p><h2 id="why-is-this-significant">Why is this significant?</h2><p>This work is interesting because it gives a new justification for Bayes rule-like updates to belief distributions, and as a result it also provides a different/new perspective on Bayesian inference. Crucially, never in this derivation did we have to reason about a joint distribution between $\theta$ and the observations $x$ (or conditionals of one given the other). Even though I wrote $\pi(\theta \vert x_{1:N})$ to denote a posterior, this is really just a shorthand notation, syntactic sugar. This is important. One of the main technical criticisms of the Bayesian terminology is that in order to reason about the joint distribution between two random variables ($x$ and $\theta$), these variables have to live in the same probability space, so if you believe that your data exists, you have to believe in your model, and model parameters exist as well. This framework sidesteps that.</p><blockquote>It allows rational updates of belief distributions, without forcing you to believe in anything.</blockquote><p>From a practical viewpoint, this work also extends Bayesian inference in a meaningful way. While Bayesian inference only made sense if you inferred the whole set of parameters jointly, here you are allowed to specify any loss function, and really focus on the parameter of importance. For example, if you&apos;re only interested in estimating the median of a distribution in a Bayesian way, without assuming it follows a certain distribution, you can now do this by specifying your loss to be $\vert x-\theta\vert$. This is explained a lot more clearly in the paper, so I encourage you to read it.</p><h2 id="criticism">Criticism</h2><p>My main criticism of this work is that it made a number of assumptions that ultimately limited the range of acceptable solutions, and to my cynical eye it appears that these choices were specifically made so that Bayes rule-like update rules came out winning. So rather than really deriving Bayesian updates from first principles, we engineered principles under which Bayesian updates are optimal. In other words, the top-down analysis was rigged in favour of familiar Bayes-like updates. There are two specific assumptions which I would personally like to see relaxed:</p><p>The first one is the restrictive notion of coherence, which requires losses to combine additively from multiple observations. I think this very clearly gives rise to the convenient exponential, log-additive form in the end. It would be interesting to see whether other types of permutation invariant update rules also make sense in practice.</p><p>Secondly, the way the authors defined optimality, in terms of the loss $h_1$ above is very limiting. We rarely use posterior distributions in this way (take a random sample). Instead, we might be intersested integrating over the posterior, and evaluating the loss of that classifier. This is a loss that cannot be written in the bilinear form that is the formula for $h_1$ above. I wonder if. using more elaborate losses for the posterior, perhaps along the lines of general decision problems as in (<a href="http://proceedings.mlr.press/v15/lacoste_julien11a.html">Lacoste-Julien et al, 2011)</a>, could lead to more interesting update rules which don&apos;t look at all like Bayes rule but are still rational.</p>]]></content:encoded></item><item><title><![CDATA[Exponentially Growing Learning Rate? Implications of Scale Invariance induced by Batch Normalization]]></title><description><![CDATA[<p>Yesterday I read this intriguing paper about the midboggling fact that it is possible to use exponentially growing learning rate schedule when training neural networks with batch normalization:</p><ul><li>Zhiyuan Li and Sanjeev Arora (2019) <a href="https://arxiv.org/abs/1910.07454">An Exponential Learning Rate Schedule for Deep Learning</a></li></ul><p>The paper provides both theoretical insights as well</p>]]></description><link>https://www.inference.vc/exponentially-growing-learning-rate-implications-of-scale-invariance-induced-by-batchnorm/</link><guid isPermaLink="false">5db19dbaa31d42003824fb47</guid><dc:creator><![CDATA[Ferenc Huszar]]></dc:creator><pubDate>Fri, 25 Oct 2019 13:02:15 GMT</pubDate><media:content url="https://www.inference.vc/content/images/2019/10/download-75.png" medium="image"/><content:encoded><![CDATA[<img src="https://www.inference.vc/content/images/2019/10/download-75.png" alt="Exponentially Growing Learning Rate? Implications of Scale Invariance induced by Batch Normalization"><p>Yesterday I read this intriguing paper about the midboggling fact that it is possible to use exponentially growing learning rate schedule when training neural networks with batch normalization:</p><ul><li>Zhiyuan Li and Sanjeev Arora (2019) <a href="https://arxiv.org/abs/1910.07454">An Exponential Learning Rate Schedule for Deep Learning</a></li></ul><p>The paper provides both theoretical insights as well as empirical demonstration of this remarcable property.</p><h2 id="scale-invariance">Scale invariance</h2><p>The reason why this works boils down to the observation that batch-normalization renders the loss function of neural networks scale invariant - scaling the weights by a constant does not change the output, or the loss, of the batch normalized network. It turns out that this property alone might result in somewhat unexpected and potentially helpful properties for optimization. I will use this post to illustrate some of the properties of scale invariant loss functions - and gradient descent trajectories on them - using a 2D toy example:</p><figure class="kg-card kg-image-card"><img src="https://www.inference.vc/content/images/2019/10/download-72.png" class="kg-image" alt="Exponentially Growing Learning Rate? Implications of Scale Invariance induced by Batch Normalization" loading="lazy"></figure><p>Here, I drew a loss function whih has the scale invariance property. The value of the loss only depends on the angle, but not the magnitude of the weight vector. The value of the loss along any radial line from the origin outwards is constant. Simple consequences of scale invariance are that (Lemma 1 of the paper)</p><ol><li>that the gradient of this function is always orthogonal to the current value of the parameter vector, and that</li><li>the farther you are from the origin, the smaller the magnitude of the gradient. This is perhaps less intuitive but think about how the function behaves on a circle around the origin. The function is the same, but as you increase the radius you stretch the same function round a larger circle - it gets fatter, therefore its gradients decrease.</li></ol><p>Here is a - somewhat messy - quiver plot showing the gradients of the function above:</p><figure class="kg-card kg-image-card"><img src="https://www.inference.vc/content/images/2019/10/download-74.png" class="kg-image" alt="Exponentially Growing Learning Rate? Implications of Scale Invariance induced by Batch Normalization" loading="lazy"></figure><p>The quiver plot is messy because the gradients around the origin explode. But you can perhaps see how the gradients get larger and larger - and remain perpendicular to the value itself.</p><p>So Imagine doing vanilla gradient descent (no momentum, weight decay, fixed learning rate) on such a loss surface. Because the gradient is always perpendicular to the current value of the parameter, by the Pythagorean theorem, the norm of the parameter vector increases with each iteration. So gradient descent takes you away from the origin. However, the weight vector won&apos;t completely blow up to infinity, because the gradients also get smaller and smaller as the weight vector grows, so it settles at some point. Here is a gradient descent path looks like starting from the coordinate $(-0.7, 0.7)$:</p><figure class="kg-card kg-image-card"><img src="https://www.inference.vc/content/images/2019/10/first_animation--7-.gif" class="kg-image" alt="Exponentially Growing Learning Rate? Implications of Scale Invariance induced by Batch Normalization" loading="lazy"></figure><p>In fact, you can&apos;t really see it but the optimization kind of gets stuck in there, and doesn&apos;t move any longer. It&apos;s interesting to see what happens if we add weight decay, which is the same as adding L2 regularizer over the weights:</p><figure class="kg-card kg-image-card"><img src="https://www.inference.vc/content/images/2019/10/first_animation--11-.gif" class="kg-image" alt="Exponentially Growing Learning Rate? Implications of Scale Invariance induced by Batch Normalization" loading="lazy"></figure><p>We can see that once the trajectory is about to get stuck in a local minimum, weight decay pulls it back towards the origin, which is where gradients become larger. This, in turn, perturbs the trajectory often pushing it out of the current local minimum. So in a way, we can start to build the intuition that weight decay on a scale-invariant loss function acts as a kind of learning rate adjustment.</p><p>In fact, what the paper works out is an equivalence between two things:</p><ul><li>weight decay with constant learning rate and</li><li>no weight decay and an exponentially growing learning rate</li></ul><p>On the plot below I show the trajectory with the exponentially growing learning rate which is equivalent to the one I showed before with weight decay. This one has no weight decay, and its learning rate keeps growing:</p><figure class="kg-card kg-image-card"><img src="https://www.inference.vc/content/images/2019/10/second_animation.gif" class="kg-image" alt="Exponentially Growing Learning Rate? Implications of Scale Invariance induced by Batch Normalization" loading="lazy"></figure><p>We can see that the trajectory blows up, and quickly gets out of bound on this animation. How can this be equivalent to the weight decay trajectory? Well, from the perspective of the loss function, the magnitude of the weight vector is irrelevant, and we only care about the angle when viewed from the origin. Turns out, if you look at those angles, the two trajectories are the same. To illustrate this, I use the normalization formula from Theorem 2.1 to project this trajectory back to the same magnitude the weight decay one would have. I obtain something that indeed looks very much like the trajectory above:</p><figure class="kg-card kg-image-card"><img src="https://www.inference.vc/content/images/2019/10/third_animation.gif" class="kg-image" alt="Exponentially Growing Learning Rate? Implications of Scale Invariance induced by Batch Normalization" loading="lazy"></figure><p>After a while, the trajectories start working differently, which I think is probably due to the accumulation of numerical errors in my implementation of the toy example. I could probably fix this, but I&apos;m not sure it&apos;s worth the effort. The authors show much more convincing empirical evidence that this works in real, complicated neural network losses that people actually want to optimize.</p><p>You can think of this renormalization I did above as &quot;constantly zooming out&quot; on the loss landscape to keep up with the exponentially exploding parameter. I tried to illustrate this below:</p><figure class="kg-card kg-image-card"><img src="https://www.inference.vc/content/images/2019/10/fourth_animation--18-.gif" class="kg-image" alt="Exponentially Growing Learning Rate? Implications of Scale Invariance induced by Batch Normalization" loading="lazy"></figure><p>On the left-hand plot, I show the original, weight-decayed gradient descent with a constant learning rate. On the right-hand plot I show the equivalent trajectory with exponentially growing learning rate and no weight decay, and I also added a constant zoom to counteract the explosion of the parameter&apos;s norm, in line with Theorem 2.1. We can see that, especially initially, the two paths behave the same way when viewed from the origin. They then work differently which I believe is down to the numerical precision issue that could probably be worked out.</p><p>The paper shows a similar equivalence in the presence of momentum as well, if interested, read the details in the paper.</p><h2 id="summary">Summary</h2><p>I thought this observation was very cool, and may well lead to a better understanding of the mechanisms by which batchnorm and other weight normalization schemes work. It also explains why the combination of weight decay with weight normalization schemes results in a relatively robust gradient descent regime where constant learning rate works well.</p>]]></content:encoded></item><item><title><![CDATA[On Marginal Likelihood and Cross-Validation]]></title><description><![CDATA[<p>Here&apos;s a paper someone has pointed me to, along the lines of &quot;<a href="https://www.inference.vc/everything-that-works-works-because-its-bayesian-2/">everything that works, works because it&apos;s Bayesian</a>&quot;:</p><ul><li>Edwin Fong, Chris Holmes (2019) <a href="https://arxiv.org/abs/1905.08737">On the marginal likelihood and cross-validation</a></li></ul><p>I found this paper to be lacking on the accessibility front, mostly owing to</p>]]></description><link>https://www.inference.vc/marginal-likelihood-and-cross-validation/</link><guid isPermaLink="false">5da85c371c937800387e7984</guid><dc:creator><![CDATA[Ferenc Huszar]]></dc:creator><pubDate>Thu, 17 Oct 2019 13:59:08 GMT</pubDate><media:content url="https://www.inference.vc/content/images/2019/10/latex-image-675-1.png" medium="image"/><content:encoded><![CDATA[<img src="https://www.inference.vc/content/images/2019/10/latex-image-675-1.png" alt="On Marginal Likelihood and Cross-Validation"><p>Here&apos;s a paper someone has pointed me to, along the lines of &quot;<a href="https://www.inference.vc/everything-that-works-works-because-its-bayesian-2/">everything that works, works because it&apos;s Bayesian</a>&quot;:</p><ul><li>Edwin Fong, Chris Holmes (2019) <a href="https://arxiv.org/abs/1905.08737">On the marginal likelihood and cross-validation</a></li></ul><p>I found this paper to be lacking on the accessibility front, mostly owing to the fact that it is a mixture of two somewhat related but separate things:</p><ul><li>(A) a simple-in-hindsight and cool observation about the relationship between marginal likelihoods and cross validation which I will present in this post, and</li><li>(B) a somewhat tangential sidetrack about a generalized form of Bayesian inference and prequential analysis which I think is mostly there to advertise an otherwise interesting line of research Chris Holmes and colleagues have been working on for some time. The advertising worked for sure, as I found the underlying paper (<a href="https://rss.onlinelibrary.wiley.com/doi/full/10.1111/rssb.12158">Bissiri et al, 2016</a>) quite interesting as well. I will leave discussing that to a different post, maybe next week.</li></ul><h2 id="the-marginal-likelihood-and-cross-validation">The marginal likelihood and cross-validation</h2><p>To discuss the connection between marginal likelihoods to (Bayesian) cross validation, let&apos;s first define what is what.</p><h3 id="the-marginal-likelihood">The marginal likelihood</h3><p><br>First of all, we are in the world of exchangeable data, assuming we model a sequence of observations $x_1,\ldots,x_N$ by a probabilistic model which renders them conditionally independent given some global parameter $\theta$. Our model is thus specified by the observation model p(x\vert \theta) and prior $p(\theta)$. The marginal likelhiood is the probability mass this model assigns to a given sequence of observations:</p><p>$$<br>p(x_1,\ldots,x_N) = \int \prod p(x_i \vert \theta) p(\theta) d\theta<br>$$</p><p>Important for the discussion of its connection with cross-validation, the marginal likelhihood, like any multivariate distribution, can be decomposed by the chain rule:</p><p>$$<br>p(x_1,\ldots,x_N) = p(x_1)\prod_{n=1}^{N-1}p(x_{n+1}\vert x_1,\ldots, x_{n})<br>$$</p><p>And, of course, a similar decomposition exists for any arbitrary ordering of the observations $x_n$.</p><h3 id="cross-validation">Cross-validation</h3><p>Another related quantity is a single-fold leave-$P$-out cross-validation. Here, we set the last $P \leq N$ observations aside, fit our model to the first $N-P$ observations, and then we calculate the average predictive log loss on the held-out pounts. This can be written as:</p><p>$$<br>- \sum_{p=1}^{P} \log p(x_{N-p+1}\vert x_1, \ldots, x_{N-P})<br>$$</p><p>Importantly, here, we assume that we perform Bayesian cross-validation of the model. I.e. in this formula, the parameter $\theta$ is integrated out. In fact what we&apos;re looking at is:</p><p>$$<br>- \sum_{p=1}^{P} \log \int p(x_{N-P+1}\vert \theta) p(\theta \vert x_1, \ldots, x_{N-P}) d\theta<br>$$</p><p>Now of course, we could leave any other subset of size $P$ of the observations out. If we repeat this process $K$ times with a uniform random subset of datapoints left out each time, and average the results over the $K$ trials, we have $K$-fold leave-$P$-out cross validation. If $K$ is large enough, we might be trying all possible subsets of $P$ with the same probability. I will cheesily call this $\infty$-fold cross-validation. Mathematically, &#xA0;$\infty$-fold leave-$P$-out Bayesian cross-validation is the following quantity:<br>$$<br>- \frac{1}{N \choose P} \sum_{\substack{S&#x2282;\{1\ldots N\}\\|S|=P}} \sum_{i \in S} \log p(x_i\vert x_j : j \notin S),<br>$$</p><p>which is Eqn (10) in the paper with slightly different notation.</p><h3 id="the-connection">The connection</h3><p>The connection I think is best illustrated in the following way. Let&apos;s consider three observations, and all the possible ways we can permute them. There are $3(3+1)/2 = 6$ different permutations. For each of these permutations we can decompose the marginal likelihood as a product of conditionals, or equivalently we can write the log marginal likelihood as a sum of logs of the same conditionals. Let&apos;s arrange these log conditionals into a table as follows:</p><figure class="kg-card kg-image-card"><img src="https://www.inference.vc/content/images/2019/10/latex-image-675.png" class="kg-image" alt="On Marginal Likelihood and Cross-Validation" loading="lazy"></figure><p></p><p>Each column corresponds to a different ordering of variables, and summing up the terms in each column gives the log marginal likelihood. So, the sum of all the terms in this matrix gives the marginal likelihood times 6 (as there are 6 columns). In general it gives $N(N+1)/2$ times the marginal likelihood for $N$ observations. Now look at the sums of the terms in each row. The first row is full of terms you&apos;d see in leave-$3$-out cross validation (which doesn&apos;t make too much sense with $3$ observations). In the second row, you see terms for leave-2-out CV. Third row corresponds to leave-1-out CV. So, if you do some careful combinatorics (homework) and count how many duplicate terms you&apos;ll find in each row, one can conclude that the sum of leave-K-out $\infty$-fold Bayesian cross-validation errors for all values of $K$ gives you the log marginal likelihood times a constant. Which is the main point of the paper.</p><p>This observation gives a really good motivation for using the marginal likelihood, and also gives a new perspective on how it works. For $N$ datapoints, there are 2^N-1 different ways of selecting a non-empty test set and corresponding training set. Calculating the marginal likelihood amounts to evaluating the average predictive &#xA0;score on all of these exponentially many &apos;folds&apos;.</p><h2 id="hooray">Hooray?</h2><p>Before we jump to the conclusion that cross-validation, too, works only because it is essentially an approximation to Bayesian model selection, we must remind ourselves that this connection only holds for Bayesian cross-validation. What this means is that in each fold of cross-validation, we integrate $\theta$ in a Bayesian fashion.</p><p>In practice, when cross-validating neural networks, we usually optimize over the parameters rather than integrate in a Bayesian way. Or, at best, we use a variational approximation to the posterior and integrate over that approximately. As the relationship only holds in theory, when exact parameter marginalization is performed, it remains to be seen how useful and robust this connection will prove in potential applications.</p>]]></content:encoded></item><item><title><![CDATA[Notes on iMAML: Meta-Learning with Implicit Gradients]]></title><description><![CDATA[<p>This week I read this cool new paper on meta-learning: it a slightly different approach compared to its predecessors based on some observations about differentiating the optima of regularized optimization.</p><ul><li>Aravind Rajeswaran, Chelsea Finn, Sham Kakade, Sergey Levine (2019) <a href="https://arxiv.org/abs/1909.04630">Meta-Learning with Implicit Gradients</a></li></ul><p>Another paper that came out at the</p>]]></description><link>https://www.inference.vc/notes-on-imaml-meta-learning-without-differentiating-through/</link><guid isPermaLink="false">5d80a05552573a0038bd2a55</guid><dc:creator><![CDATA[Ferenc Huszar]]></dc:creator><pubDate>Thu, 19 Sep 2019 14:08:40 GMT</pubDate><media:content url="https://www.inference.vc/content/images/2019/09/download-69.png" medium="image"/><content:encoded><![CDATA[<img src="https://www.inference.vc/content/images/2019/09/download-69.png" alt="Notes on iMAML: Meta-Learning with Implicit Gradients"><p>This week I read this cool new paper on meta-learning: it a slightly different approach compared to its predecessors based on some observations about differentiating the optima of regularized optimization.</p><ul><li>Aravind Rajeswaran, Chelsea Finn, Sham Kakade, Sergey Levine (2019) <a href="https://arxiv.org/abs/1909.04630">Meta-Learning with Implicit Gradients</a></li></ul><p>Another paper that came out at the same time has discovered similar techniques, so I thought I&apos;d update the post and mention it, although I won&apos;t cover it in detail and the post was written primarily about Rajeswaran et al (2019)</p><ul><li>Yutian Chen, Abram L. Friesen, Feryal Behbahani, David Budden, Matthew W. Hoffman, Arnaud Doucet, Nando de Freitas (2019) <a href="https://arxiv.org/abs/1909.05557">Modular Meta-Learning with Shrinkage</a></li></ul><h3 id="outline-of-this-post">Outline of this post</h3><ul><li>I will give a high-level overview of the meta-learning setup, where our goal is to learn a good initialization or regularization strategy for SGD so it converges to better minima across a range of tasks.</li><li>I illustrate how iMAML works on a 1D toy-example, and discuss the behaviour and properties of the meta-objective.</li><li>I will then discuss a limitation of iMAML: that it only considers the location of minima, and not the probability with which a stochastic algorithm ends up in a specific minimum.</li><li>I will finally relate iMAML to a variational approach to meta-learning.</li></ul><h2 id="meta-learning-and-maml">Meta-Learning and MAML</h2><p>Meta-learning has several possible formulations, I will try to explain the setup of this paper following my own interpretation and notation that differs from the paper but will make my explanations clearer (hopefully).</p><p>In meta-learning we have a series of independent tasks, with associated training and validation loss functions $f_i$ and $g_i$, respectively. We have a set of model parameters $\theta$ which are shared across the tasks, and the loss functions $f_i(\theta)$ and $g_i(\theta)$ evaluate how well the model with parameters $\theta$ does on the training and test cases of task $i$. We have an algorithm that has access to the training loss $f_i$ and some meta-parameters $\theta_0$, and output some optimal or learned parameters $\theta_i^\ast = Alg(f_i, \theta_0)$. The goal of the meta-learning algorithm is to optimize the meta-objective</p><p>$$<br>\mathcal{M}(\theta_0) = \sum_i g_i(Alg(f_i, \theta_0))<br>$$</p><p>with respect to the meta-parameters $\theta_0$.</p><p>In early versions of this work, MAML, the algorithm was chosen to be stochastic gradient descent, $f_i$ and $g_i$ being the training and test loss of a neural network, for example. The meta-parameter $\theta_0$ was the point of initialization for the SGD algorithm, shared between all the tasks. Since SGD updates are differentiable, one can compute the gradient of the meta-objective with respect to the initial value $\theta_0$ by simply backpropagating through the SGD steps. This was essentially what MAML did.</p><p>However, the effect of initialization on the final value of $\theta$ is pretty weak, and difficult - if at all possible - to characterise analytically. If we allow the SGD to go on for many steps, we might converge to a better parameter, but the trajectory will be very long, and the gradients with respect to the initial value vanish. If we make the trajectories short enough, the gradients w.r.t. $\theta_0$ are informative but we may not reach a very good final value.</p><h2 id="imaml">iMAML</h2><p>This is why Rajeswaran et al opted to make the dependence of the final point of the trajectory on meta-paramteter $\theta\_0$ way stronger: Instead of simply initializing SGD from $\theta\_0$ they also anchor the parameter to stay in the vicinity of $\theta\_0$ by adding a quadratic regularizer $\|\theta - \theta_0\|$ to their loss. Because of this, two things happen:</p><ul><li>now all steps of the SGD depend on $\theta$, not just the initial point</li><li>now the location of &#xA0;the minimum SGD eventually converges to also depend on #\theta\_0#</li></ul><p>It is this second property that iMAML exploits. Let me illustrate what that dependence looks like:</p><figure class="kg-card kg-image-card"><img src="https://www.inference.vc/content/images/2019/09/download-60.png" class="kg-image" alt="Notes on iMAML: Meta-Learning with Implicit Gradients" loading="lazy"></figure><p>In the figure above, let&apos;s say that we would like to minimise an objective function $f(\theta)$. This would be the training loss of one of the tasks the meta-learning algorithm has to solve. Our current meta-parameter $\theta_0$ is marked on the x axis, and the orange curve shows the associated quadratic penalty. The teal curve shows the sum of the objective with the penalty. The red star shows the location of the minimum, which is what the learning algorithm finds.</p><figure class="kg-card kg-image-card"><img src="https://www.inference.vc/content/images/2019/09/first_animation--3-.gif" class="kg-image" alt="Notes on iMAML: Meta-Learning with Implicit Gradients" loading="lazy"></figure><p>Now let&apos;s animate this plot. I&apos;m going to move the anchor point $\theta_0$ around, and reproduce the same plots. You can see that, as we move $\theta_0$ and the associate penalty, the local (and therefore global) minima of the regularized objective move change:</p><p>So it&apos;s clear that there is a non-trivial, non-linear relationship between the anchor-point $\theta_0$ and the location of a local minimum $\theta^\ast$. Let&apos;s plot this relationship as a function of the anchor point:</p><figure class="kg-card kg-image-card"><img src="https://www.inference.vc/content/images/2019/09/download-63.png" class="kg-image" alt="Notes on iMAML: Meta-Learning with Implicit Gradients" loading="lazy"></figure><p>We can see that this function is not at all nice to work with, it has sharp jumps when the closest local minimum to $\theta_0$ changes, and it is relatively flat between these jumps. In fact, you can observe that the sharpest the local minimum nearest to $\theta_0$ is, the flatter the relationship between $\theta_0$ and $\theta$. This is because if $f$ has a sharp local minimum near $\theta_0$, then the location of the regularized minimum will be mostly determined by $f$, and the location of the anchor point $\theta_0$ doesn&apos;t matter much. If the local minimum around f is wide, there&apos;s a lot of wiggle room for the optimum and the effect of the regularization will be larger.</p><h2 id="implicit-gradients">Implicit Gradients</h2><p><br>And now we come to the whole point of the iMAML procedure. The gradient of this function $\theta^\ast(\theta_0)$ in fact can be calculated in closed form. It is, indeed, related to the curvature, or second derivative, of $f$ around the minimum we find:</p><p>$$<br>\frac{d\theta^\ast}{d\theta_0} = \frac{1}{1 + f&apos;&apos;(\theta^\ast)}<br>$$</p><p>In order to check that this formula works, I calculated the derivative numerically and compared it with what the theory predicts, they match perfectly:</p><figure class="kg-card kg-image-card"><img src="https://www.inference.vc/content/images/2019/09/download-66.png" class="kg-image" alt="Notes on iMAML: Meta-Learning with Implicit Gradients" loading="lazy"></figure><p>When the parameter space is high-dimensional, we have a similar formula involving the inverse of the Hessian plus the identity. In high dimensions, inverting or even calculating and storing the Hessian is not very practical. One of the main contributions of the iMAML paper is a practical way to approximate gradients, using a conjugate gradient inner optimization loop. For details, please read the paper.</p><h3 id="optimizing-the-meta-objective">Optimizing the meta-objective</h3><p>When optimizing the anchor point in a meta-learning setting, it is not the location $\theta^\ast$ we are interested in, only the value that the function $f$ takes at this location. (in reality, we would now use the validation loss, in place of the training loss used for gradient descent, but for simplicity, I assume the two losses overlap). The value of $f$ at its local optimum is plotted below:</p><figure class="kg-card kg-image-card"><img src="https://www.inference.vc/content/images/2019/09/download-65.png" class="kg-image" alt="Notes on iMAML: Meta-Learning with Implicit Gradients" loading="lazy"></figure><p>Oh dear. This function is not very pretty. The meta-objective $f(\theta^\ast(\theta_0))$ becomes a piecewise continuous function, a connection of neighbouring basins, with non-smooth boundaries. The local gradients of this function contain very little information about the global structure of the loss function, it only tells you where to go to reach the nearest local minimum. So I wouldn&apos;t say this is the nicest function to optimize.</p><p>Thankfully, though, this function is not what we have to optimize. In meta-learning, we have a distribution over functions $f$ we optimize, so the actual meta-objective is something like $\sum_i f_i(\theta_i^\ast(\theta_0))$. And the sum of a bunch of ugly functions might well turn into something smooth and nice. In addition, the 1-D function I use for this blog post is not representative of the high-dimensional loss functions of neural networks which we want to apply iMAML to. Take for example the concept of mode connectivity (see e.g. <a href="https://arxiv.org/pdf/1802.10026.pdf">Garipov et al, 2018</a>): it seems that the modes found by SGD using different random seeds are not just isolated basins, but they are connected by smooth valleys along which the training and test error are low. This may in turn make the meta-objective behave more smoothly between minima.</p><h2 id="what-is-missing-stochasticity">What is missing? Stochasticity</h2><p>An important aspect that MAML or iMAML do not not consider is the fact that we usually use stochastic optimization algorithms. Rather than deterministically finding a particular local minimum, SGD samples different minima: when run with different random seeds it will find different minima.</p><p>A more generous formulation of the meta-objective would allow for stochastic algorithms. If we denote by $\mathcal{Alg}(f_i, \theta_0)$ the distribution over solutions the algorithm finds, the meta-objective would be</p><p>$$<br>\mathcal{M}_{stochastic}(\theta) = \sum_i \mathbb{E}_{\theta \sim \mathcal{Alg}(f_i, \theta_0)} g_i(\theta)<br>$$</p><p>Allowing for stochastic behaviour might actually be a great feature for meta-learning. While the position of the global minimum of the regularized objective can change abruptly s a function $\theta_0$ (as illustrated in the third figure above), allowing for stochastic behaviour might smooth our the meta-learning objective.</p><p>Now suppose that SGD anchored to $\theta_0$ converges to one of a finite set of local minima. The meta-learning objective now depends on $\theta_0$ in two different ways:</p><ul><li>as we change the anchor $\theta_0$, the location of the minima change, as illustrated above. This change is differentiable, and we know its derivative.</li><li>as we change the anchor $\theta_0$, the probability with which we find the different solutions changes. Some solutions will be found more often, some less often.</li></ul><p>iMAML accounts for the first influence, but it ignores the influence through the second mechanism. This is not to say that iMAML is broken, but that it misses a possibly crucial contribution of stochastic behaviour that MAML or explicitly differentiating through the algorithm does not.</p><h2 id="compare-with-a-variational-approach">Compare with a Variational Approach</h2><p>Of course this work reminded me of a Bayesian approach. Whenever someone describes quadratic penalties, all I see are Gaussian distributions.</p><p>In a Bayesian interpretation of iMAML, one can think of the anchor point $\theta_0$ as the mean of a prior distribution over the neural network&apos;s weights. The inner loop of the algorithm, or $Alg(f_i, \theta_0)$ then finds the maximum-a-posteriori (MAP) approximation to the posterior over $\theta$ given the dataset in question. This is assuming that the loss is a log likelihood of some kind. The question is, how should one update the meta-parameter $\theta_0$?</p><p>In the Bayesian world, we would seek to optimize $\theta_0$ by maximising the marginal likelihood. As this is usually intractable, so it is common to turn to a variational approximation, which in this case would look something like this:</p><p>$$<br>\mathcal{M}_{\text{variational}}(\theta_0, Q_i) = \sum_i \left( KL[Q_i\vert \mathcal{N}_{\theta_0}] + \mathbb{E}_{\theta \sim Q_i} f_i(\theta) \right),<br>$$</p><p>where $Q_i$ approximates the posterior over model parameters for task $i$. A specific choice of $Q_i$ is a dirac delta distribution centred at a specific point $Q_i(</p><p>theta) = \delta(\theta - \theta^{\ast}_i)$. If we generously ignore some constants that blow up to infinitely large, the KL divergence between the Gaussian prior and the degenerate point-posterior is a simple Euclidean distance, and our variational objective reduces to:</p><p>$$<br>\mathcal{M}_{\text{variational}}(\theta_0, \theta_i) = \sum_i \left( \|\theta_i - \theta_0\|^2 + f_i(\theta_i) \right)<br>$$</p><p>Now this objective function looks very much like the optimization problem that the inner loop of iMAML attempts to solve. If we were working in the pure variational framework, this may be where we leave things, and we could jointly optimize all the $\theta_i$s as well as $\theta_0$. Someone in the know, please comment below pointing me to the best references where this is being done for meta-learning.</p><p>This objective is significantly easier to optimize with and involves no inner-loop optimization or black magic. It simply ends up pulling $\theta_0$ closer to the centre of gravity of the various optima found for each task $i$. Not sure if this is such a good idea though for meta-learning, as the final values of $\theta_i$ which we reach by jointly optimizing over everything may not be reachable by doing SGD from $\theta_0$ from scratch. But who knows. A good idea may be, given the observations above, to jointly minimize the variational objective with respect to $\theta_0$ and $\theta_i$, but every once in a while reinitialize $\theta_i$ to be $\theta_0$. But at this point, I&apos;m really just making stuff up...</p><p>Anyway, back to iMAML, which does something interesting with this variational objective, and I think it can be understood as a kind of amortized computation: Instead of treating $\theta_i$ as separate auxiliary parameters, it specifies that $\theta_i$ are in fact a deterministic function of $\theta_0$. As the variational objective is a valid upper bound for any value of $\theta_i$, it is also a valid upper bound if we make $\theta_i$ explicitly dependent on $\theta_0$. The variational objective thus becomes a function of $\theta_0$ only (and also of hyperparameters of the algorithm $Alg$ if it has any):</p><p>$$<br>\mathcal{M}_{\text{variational}}(\theta_0) = \sum_i \left( \|Alg(f_i, \theta_0) - \theta_0\|^2 + f_i(Alg(f_i, \theta_0)) \right)<br>$$</p><p>And there we have it. A variational objective for meta-learning $\theta_0$ which is very similar to the MAML/iMAML meta-objective, except it also has the $\|Alg(f_i, \theta_0) - \theta_0\|^2$ term which factors into updating $\theta_0$ which we didn&apos;t have before. Also notice that I did not use separate training and validation loss $f_i$ and $g_i$ but that would be a very justified choice as well.</p><p>What is cool about this is that this provides extra justification and interpretation for what iMAML is trying to do, and suggests directions in which iMAML could perhaps be improved. On the flipside, the implicit differentiation trick in iMAML might be useful in other situations where we want to amortize the variational posterior similarly.</p><p>I&apos;m pretty sure I missed many references, please comment below if you think I should add anything, especially on the variational bit.</p>]]></content:encoded></item><item><title><![CDATA[Invariant Risk Minimization: An Information Theoretic View]]></title><description><![CDATA[<p>I finally got around to reading this new paper by Arjovsky et al. It debuted on Twitter with a big splash, being decribed as &apos;beautiful&apos; and &apos;long awaited&apos; &apos;gem of a paper&apos;. It almost felt like a new superhero movie or Disney remake just</p>]]></description><link>https://www.inference.vc/invariant-risk-minimization/</link><guid isPermaLink="false">5d317d7966235e0038be6426</guid><dc:creator><![CDATA[Ferenc Huszar]]></dc:creator><pubDate>Fri, 19 Jul 2019 14:12:58 GMT</pubDate><media:content url="https://www.inference.vc/content/images/2019/07/IRM_graphical_model-1.png" medium="image"/><content:encoded><![CDATA[<img src="https://www.inference.vc/content/images/2019/07/IRM_graphical_model-1.png" alt="Invariant Risk Minimization: An Information Theoretic View"><p>I finally got around to reading this new paper by Arjovsky et al. It debuted on Twitter with a big splash, being decribed as &apos;beautiful&apos; and &apos;long awaited&apos; &apos;gem of a paper&apos;. It almost felt like a new superhero movie or Disney remake just came out.</p><ul><li>Martin Arjovsky, L&#xE9;on Bottou, Ishaan Gulrajani, David Lopez-Paz (2019) <a href="https://arxiv.org/abs/1907.02893">Invariant Risk Minimization</a></li></ul><p>The paper is, indeed, very well written, and describes a very elegant idea, a practical algorithm, some theory and lots of discussion around how this is related to various bits. Here, I will describe the main idea and then provide an information theoretic view on the same topic.</p><h2 id="summary-of-the-approach">Summary of the approach</h2><p>We would like to learn robust predictors that are based on invariant causal associations between variables, rather than spurious surface correlations that might be present in our data. If we only observe i.i.d. data from a generative process, this is generally not possible. </p><p>In this paper, the authors assume that we have access to data sampled from different environments $e$. The data distribution in these different enviroments is different, but there is an underlying causal dependence of the variable of interest $Y$ on some of the observed features $X$ that remains constant, or invariant across all environments. The question is, can we exploit the variability across different environments to learn this underlying invariant association?</p><p>Usual empirical risk minimisation (ERM) approaches cannot distinguish between statistical associations that correspond to causal connections, and those that are just spurious correlations. Invariant Risk Minimization can, in certain situations. It does this by finding a representation $\phi$ of features, such that the optimal predictor is simultaneously Bayes optimal in all environments.</p><p>The authors then propose a practical loss function that tries to capture his property:</p><p>$$<br>\min_\phi \sum_e \mathcal{R}^e(\Phi) + \lambda \|\nabla_{w\vert w=1}\mathcal{R}^e(w \cdot \Phi)\|^2_2<br>$$</p><p>The first term is the usual ERM: we&apos;re trying to minimize average risk across all environments, using a single predictor $\phi$. The second term is where the interesting bit happens. I said before that what we want this term to encorage is that $\phi$ is simultaneously Bayes-optimal in all environments. What the term actually looks at is whether $\phi$ is locally optimal, wether it can be improved locally by scaling by a constant $w$. For details, I recommend reading the paper where a lot of intuitive explanation is provided. In this post, I&apos;ll focus on an information theoretic interpretation of what&apos;s going on.</p><h2 id="information-theoretic-explanation">Information theoretic explanation</h2><p>Unlike the authors, who treat the environment index $e$ as something outside of the structural equation model, I prefer to think of $E$ as also being part of the generative process: an observable random variable. This may not be the most useful formulation in all circumstances, but it will help when trying to derive IRM through the lens of conditional dependence relationships.</p><p>The most general generative model of data in the IRM setup looks something like this:</p><figure class="kg-card kg-image-card"><img src="https://www.inference.vc/content/images/2019/07/IRM_graphical_model.png" class="kg-image" alt="Invariant Risk Minimization: An Information Theoretic View" loading="lazy"></figure><p>There are three (sets of) observable variables: $E$, the environment index, $X$, the features describing the datapoint and $Y$, the label we wish to predict. I also assume the existence of a hidden confounder $W$. In the above graph, I separated $X$ into upstream dimensions $X_1$ and downstream dimensions $X_2$ based on where they are in the causal chain relative to $Y$. In reality, we don&apos;t know what this breakdown is, and breaking $X$ up to $X_1$ and $X_2$ may not be trivial due to entanglement, but it is still reasonable to assume that some components of the input $X$ encode causal parents of $Y$, and others encode causal descendants of $Y$.</p><p>The environment $E$ influences every factor in this generative model, except the factor $p(Y\vert X_1, W)$: notice there is no arrow from $E$ to $Y$. In other words, it is assumed that the relationship of variable $Y$ to its observable causal parents $X_1$ and hidden variables $W$ is stable across all environments. This is the primary underlying assumption of IRM. Now, let&apos;s read out some conditional independence relationships from this graph:</p><ul><li>$Y \cancel{\perp\mkern-13mu\perp} E$: this is simply saying that the marginal distribution of $Y$ can, generally, change across environments.</li><li>$Y \perp\mkern-13mu\perp E\vert X_1, W$: The observable $X_1$ and latent $W$ shield the label $Y$ from the influence of the environment. I already said that this is the key assumption on which IRM is based: that there is an underlying causal mechanism determining the value of Y from its causal parents, which does not change across environments.</li><li>$Y \cancel{\perp\mkern-13mu\perp} E\vert X_1$: If we leave $W$ out of the conditioning, the above environment-independence no longer holds. This is because the confounder $W$ inroduces spurious association between $X_1$ and $Y$. This spurious correlation is assumed to be environment-dependent.</li><li>$Y \cancel{\perp\mkern-13mu\perp} E\vert X_1, X_2$: this is, perhaps, the most important point. This dependence statement says that the way $Y$ depends on the observable variables $X = (X_1, X_2)$ is environment-dependent. This can be verified by noticing that $X_2$ is a collider between $E$ and $Y$. Conditioning on a collider introduces spurious correlations (for example, explaining away).</li></ul><p>In summary, the association between $X$ and $Y$ will be a result of three sources of correlation:</p><ol><li>real causal relationship between some components of $X$ and $Y$.</li><li>spurious association introduced by the unobserved confounder $W$.</li><li>spurious association introduced by conditioning on parts of $X$ which is are causally influenced by $Y$, rather than the other way around.</li></ol><p>In a general, if our generative model describes the world accurately, the conditional independence statements we observed tell us that while the real causal association is stable across environments ($Y \perp\mkern-13mu\perp E\vert X_1, W$), the other two are environment-dependent ($Y \cancel{\perp\mkern-13mu\perp} E\vert X_1$ and $Y \cancel{\perp\mkern-13mu\perp} E\vert X_1, X_2$). Thus, we can eliminate the spurious associations by seeking associations that are stable across environments, i.e. independent of $E$.</p><p>One can interpret the objective of Invariant Risk Minimisation as seeking a representation of observable variables $\Phi(x)$, such that:</p><ul><li>$Y \perp\mkern-13mu\perp E\vert \phi(X)$, and</li><li>$\phi$ is informative about $y$, i.e. we can predict $y$ accurately from $\phi(x)$</li></ul><p>This is a bit similar to the information bottleneck criterion which would seek a stochasstic representation $Z = \phi(X, \nu)$, $\nu$ being some random noise, by solving the following optimization problem:</p><p>$$<br>\max_{\phi} \left\{ I[Y, Z] - \beta I[X, Z] \right\}<br>$$</p><p>We could similarly attempt to find an invariant &#xA0;repesentation $Z = \phi(X)$ by minimizing an objective like:</p><p>$$<br>\max_{\phi} \left\{ I[Y, Z] - \beta I[Y, E \vert Z] \right\}<br>$$</p><p>Notice, that one can write mutual information $\mathbb{I}[Y, E \vert \phi(X)] $ in the following variational interpretation:</p><p>$$<br>I[Y, E \vert \phi(x)] = \max_q \min_r \mathbb{E}_{x,y,e} [\log q(y\vert \phi(x), e) - \log r(y\vert \phi(x))]<br>$$</p><p>With a little bit of math juggling, we can write the above stability objective in the following form:</p><p>\begin{align}<br>\max_{\phi} \left\{ I[Y, \phi(X)] - \beta I[Y, E \vert \phi(X)] \right\} = &#xA0;\max_\phi \max_r \min_q \mathbb{E}_{x,y,e} \left[\log r(y\vert \phi(x)) - \frac{\beta}{1 + \beta}\log q(y\vert \phi(x), e) \right]<br>\end{align}</p><p>This optimization problem is intuitively already very similar to IRM: we would like a representation $\phi$ so we can predict $y$ from it accurately, but we shouldn&apos;t be able to build a much better predictor by overfitting to one of the environments. In other words: here, too, we seek a representation so that the Bayes optimal predictor of $y$ is close to Bayes optimal simultanously in all environments.</p><p>Sadly, this is a minimax type of problem, so $\phi$ can only be found with a GAN-like iterative algorithm - something we don&apos;t really like, but we&apos;re kind of getting used to. It would be interesting to see how such algorithm would work, and if you&apos;re aware of this being done already, please feel to point me to the relevant references in the comments section.</p><h2 id="from-information-to-gradient-penalties">From information to gradient penalties</h2><p></p><p>I wanted to add sidenote here that I think we can recover something very similar in spirit to (IRMv1). I leave developing the full connection as a homework to you. Let me just illustrate the basic idea here.</p><p>Say we have a parametric family of functions $f(y\vert \phi(x); \theta)$ for predicting $y$ from $\phi(x)$. The conditional information can be approximated as follows:</p><p>\begin{align}<br>I[Y, E \vert \phi(x)] &#xA0;&amp;\approx &#xA0;\min_\theta {E}_{x,y} \ell (f(y\vert \phi(x); \theta) - \mathbb{E}_e \min_{\theta_e} \mathbb{E}_{x,y\vert e} &#xA0;\ell (f(y\vert \phi(x); \theta_e)\\<br>&amp;= \min_\theta \mathbb{E}_e \mathcal{R}^e(f_\theta\circ\phi) - \mathbb{E}_e \min_{\theta_e} \mathcal{R}^e(f_{\theta_e}\circ\phi)<br>\end{align}</p><p>where $\ell$ is the log-loss, if we want to recover Shannon&apos;s information. If we assume that $f$ is a universal function approximator, an equality holds. If, instead of globally optimizating $\theta_e$, we only search locally within a trust region around $\theta$, we can create the following (approximate) lower-bound to the information.</p><p>\begin{align}<br>I[Y, E \vert \phi(x)] &#xA0;&amp;\geq \min_\theta {E}_{x,y}\ell f(y\vert \phi(x); \theta) - \mathbb{E}_e \min_{\|d\|^2\leq \epsilon} \mathbb{E}_{x,y\vert e} \ell f(y\vert \phi(x); \theta + d) &#xA0;\\<br>&amp;= \min_\theta \mathbb{E}_e \left\{ \mathcal{R}^e(f_\theta\circ\phi) &#xA0;- \min_{\|d_e\|\leq \epsilon}\mathcal{R}^e(f_{\theta + d_e}\circ\phi) \right\}<br>\end{align}</p><p>Now, we can approximate the risk $\mathcal{R}^e(f_{\theta + d_e}\circ\phi) $ locally by a first order Taylor approximation around $\theta$, and show that, as $\epsilon \rightarrow 0$, we obtain that:</p><p>$$<br>I[Y, E \vert \phi(x)] &#xA0;\geq \min_\theta \mathbb{E}_e \| \nabla_\theta \mathbb{E}_{x,y\vert e} [\ell f(y\vert \phi(x), \theta)] \|_2= \min_\theta \mathbb{E}_e \| \nabla_\theta \mathcal{R}^e(f_\theta\circ\phi) \|_2<br>$$</p><p>Compare this with the second term in Eqn IRMv1 of the paper. If we now add back in the requirement that we would like to be able to predict $y$ from $\phi(x)$, we get an optimization problem of the following form:</p><p>$$<br>\min_\phi \left\{ \min_\theta \mathbb{E}_e \mathcal{R}^e(f_\theta\circ\phi) + \lambda \min_\theta \mathbb{E}_e \| \nabla_\theta \mathcal{R}^e(f_\theta\circ\phi) \|_2 \right\},<br>$$</p><p>which is almost like the IRM objective. Technically, there are two minimizations over $\theta$ and there&apos;s no reason why the two shouldn&apos;t be done separately. Note however, that a global minimum of the second term $\mathbb{E}_e \| \nabla_\theta \mathcal{R}^e(f_\theta\circ\phi) \|_2$ is always a local minimum of the first term. This justifies connecting the two minimization problems together:</p><p>$$<br>\min_\phi \min_\theta \left\{ &#xA0;\mathbb{E}_e \mathcal{R}^e(f_\theta\circ\phi) + \lambda \mathbb{E}_e \| \nabla_\theta \mathcal{R}^e(f_\theta\circ\phi) \|_2 \right\},<br>$$</p><p>This is no longer an ugly minimax problem, however, it is still not amazing. It is a lower bound to the original objective which we originally wished to minimize. The lower bound was created when we replaced global minimization over local minimization. Thus, the bound is actually tight if all local minima with respect to $\theta$ of $\mathcal{R}^e(f_\theta\circ\phi)$ are also global minima, e.g. if the loss is convex. In non-convex problems, all bets are off. It may still work, but who knows.</p><h2 id="summary">Summary</h2><p>This is indeed a nice paper, with lots of great insights. Unfortunately, I am not sure how realistic the assumptions are that we can sample from a multitude of different environments, which differ from each other sufficiently so that the invariant causal quantities can be identified.</p><h3 id="other-work-on-invariance">Other work on invariance</h3><p>I would like to mention that this is not the first time that invariance and causality have been connected and exploited for domain adaptation. I personally first encountered this idea in a talk by Jonas Peters at the Causality Workshop in 2018. Here is a related paper by him that I wanted to highlight here:</p><ul><li>Peters, B&#xFC;hlmann, Meinshausen (2016) <a href="https://rss.onlinelibrary.wiley.com/doi/full/10.1111/rssb.12167">Causal inference by using invariant prediction: identification and confidence intervals</a></li></ul><p>And here are two more papers which propose a causal treatment of the domain adaptation problem:</p><ul><li>Adarsh Subbaswamy, Peter Schulam, Suchi Saria (2018) <a href="https://arxiv.org/abs/1812.04597">Preventing Failures Due to Dataset Shift: Learning Predictive Models That Transport</a></li><li>Christina Heinze-Deml, Nicolai Meinshausen (2019) <a href="https://arxiv.org/abs/1710.11469">Conditional Variance Penalties and Domain Shift Robustness</a></li></ul><p>The second paper, which commenters also pointed out to me, is perhaps the most closely related, but it is based on slightly different assumptions about what is invariant across the domains.</p><p>Finally, commenters asked me about domain-adversarial learning, so I wanted to include a pointer here for completeness:</p><ul><li>Yaroslav Ganin, Victor Lempitsky (2014) <a href="https://arxiv.org/abs/1409.7495">Unsupervised Domain Adaptation by Backpropagation</a></li></ul><p>On this paper, I agree with <a href="https://arxiv.org/abs/1907.02893">Arjovsky et al (2019)</a>&apos;s discussion in the IRM paper: it promotes the wrong invariance property by trying to learn a data representation that is marginally independent of the domain index. See the discussion on this in the comments section below.</p><p>Finally, I wanted to point out another slightly looser connection: non-stationarity, or the availability of data from multiple environments has been exploited by &#xA0;<a href="https://arxiv.org/abs/1605.06336">(Hyvarinen and Morioka, 2016)</a> exploits this idea for unsupervised feature learning. It turns out, this non-stationarity and the availability of different environments makes otherwise non-identifiable nonlinear ICA models identifable.</p>]]></content:encoded></item><item><title><![CDATA[ICML Highlight: Contrastive Divergence for Combining Variational Inference and MCMC]]></title><description><![CDATA[<p>Welcome to my ICML 2019 jetlag special - because what else do you do when you wake up earlier than anyone than write a blog post. Here&apos;s a paper that was presented yesterday which I really liked.</p><ul><li>Ruiz and Titsias (2019) <a href="https://arxiv.org/abs/1905.04062">A Contrastive Divergence for Combining Variational Inference</a></li></ul>]]></description><link>https://www.inference.vc/icml-highlight-contrastive-divergence-for-variational-inference-and-mcmc/</link><guid isPermaLink="false">5d01064e055c38003864c850</guid><dc:creator><![CDATA[Ferenc Huszar]]></dc:creator><pubDate>Wed, 12 Jun 2019 15:07:20 GMT</pubDate><media:content url="https://www.inference.vc/content/images/2019/06/Screen-Shot-2019-06-12-at-8.06.57-AM.png" medium="image"/><content:encoded><![CDATA[<img src="https://www.inference.vc/content/images/2019/06/Screen-Shot-2019-06-12-at-8.06.57-AM.png" alt="ICML Highlight: Contrastive Divergence for Combining Variational Inference and MCMC"><p>Welcome to my ICML 2019 jetlag special - because what else do you do when you wake up earlier than anyone than write a blog post. Here&apos;s a paper that was presented yesterday which I really liked.</p><ul><li>Ruiz and Titsias (2019) <a href="https://arxiv.org/abs/1905.04062">A Contrastive Divergence for Combining Variational Inference and MCMC</a></li></ul><h2 id="background-principle-of-minimal-improvement">Background: principle of minimal improvement</h2><p>First, some background on why I found this paper particulartly interesting. When <a href="https://www.inference.vc/alphago-zero-policy-improvement-and-vector-fields/">AlphaGo Zero</a> came out, I wrote a post about the <em>principle of minimal improvement</em>: Suppose you have an operator which may be computationally expensive to run, but which that can take a policy and improve it. Using such improvement operator you can define an objective function for policies by measuring the extent to which the operator changes a policy. If your policy is already optimal, the operator can&apos;t improve it any further, so the change will be zero. In the case of AlphaGo Zero, the improvement operator is Monte Carlo Tree Search (MCTS). I noted in that post how the same principle may be applicable to approximate inference: expectation propagation and contrastive divergence both can be casted in a similar light.</p><p>The paper I&apos;m talking about uses a very similar argument to come up with a contrastive divergence for variational inference, where the improvement operator is MCMC step.</p><h2 id="combining-vi-with-mcmc">Combining VI with MCMC</h2><p>The two dominant ways of performing inference in latent variable models are variational inference (including amortized inference, such as in VAE), and Markov Chain Monte Carlo (MCMC). VI approximates the posterior with a paramteric distribution. This can be computationally efficient and practically convenient as VI results in end-to-end differentiable, unbiased estimates of the evidence lower bound (ELBO). As a drawback, the paramteric posterior approximation often can&apos;t approximate the posterior perfectly, and an approximation error almost always remains. By contrast, an MCMC approximate posterior can always be improved by running the chains longer, and obtaining more independent samples, but it is more difficult to work with and computationally more demanding than VI. </p><p>A lot of great work has been done recently on combining VI with MCMC (see references in <a href="https://arxiv.org/abs/1905.04062">Ruiz and Titsias, 2019</a>). Usually, one starts from a crude, parametric variational approximation to the posterior, and then improves it by running a couple steps of MCMC. Crucially, one can view the transition kernel, $\Pi$, of the MCMC as an improvement operator: given any distribution $q$, taking an MCMC steps should take you closer to the posterior. In other words, $\Pi q$ is an improvement over $q$. Taking multiple steps, i.e. $\Pi^t q$, should provide an even greater improvement. Improvement is $0$ only when $\Pi q = q$ which only holds for the true posterior. It is a reasonable criterion therefore to seek a posterior approximation $q_\theta$ such that the improvement in $\Pi^t q_\theta$ over over $q_\theta$ is minimized.</p><h2 id="two-ways-to-measure-improvement">Two ways to measure improvement</h2><p>There are two ways of quantifying the amount of improvement, or change, that MCMC provides over a parametric posterior $q_\theta$. The first measures how much closer we got to the posterior $p$ by comparing the KL divergences:</p><p>$$<br>\mathcal{L}_1(\theta) = \operatorname{KL}\left[q_\theta\middle\|p\right] - \operatorname{KL}\left[\Pi^tq_\theta\middle\|p\right] <br>$$</p><p>The second one measures the amount of change between $\Pi^tq_\theta$ and $q_\theta$, measured as the KL divergence. This objective function merely tries to identify fixed points of the improvement operator:</p><p>$$<br>\mathcal{L}_2(\theta) = \operatorname{KL}\left[\Pi^tq_\theta\middle\|q_\theta\right]<br>$$</p><p>Either of these objectives would make sense and is justified on its own right, but sadly neither of them can be evaluated or optimized easily in this case. Both require taking expectations over $\Pi^tq_\theta$, as well as evaluating $\log \Pi^tq_\theta$. However, the brilliant insight in this paper is that when you sum them together, the most problematic terms cancel out, leaving you with a tractable objective to minimise.</p><p>$$<br>\mathcal{L}_1(\theta) + \mathcal{L}_2(\theta) = \mathbb{E}_{z\sim \Pi^t q_\theta} f_\theta(z) - &#xA0;\mathbb{E}_{z\sim q_\theta} f_\theta(z),<br>$$</p><p>where $f_theta(z) = \log p(z,x) - \log q_\theta(z)$, $x$ is the observed, $z$ the hidden variable.</p><p>There is one more technical hurdle to overcome, which is to calculate or estimate the derivative of this objective with respect to $\theta$. The authors propose a REINFORCE-like score function gradient estimator in Eqn. (12), which is somewhat worrying as it is known to have very high variance. The authors propose overcoming this using a control variate. For more details, please refer to the paper.</p><p>There is further discussion on the behaviour of this objective function in the limit of infinitely long MCMC paths, i.e. $t\rightarrow\infty$. It turns out, the criterion works like the symmetrized KL divergence $KL[q\|p] + KL[p\|q]$. The difference of this objective from the usual conservative mode and seeking VI objective is neatly illustrated in Figure 1 of the paper:</p><p></p><figure class="kg-card kg-image-card"><img src="https://www.inference.vc/content/images/2019/06/Screen-Shot-2019-06-12-at-8.13.15-AM.png" class="kg-image" alt="ICML Highlight: Contrastive Divergence for Combining Variational Inference and MCMC" loading="lazy"></figure><p>Variational Contrastive Divergence (VCD) favours posterior approximations which have a much higher coverage of the true posterior compared to VI, which tries to cover the modes and tries to avoid allocating mass to areas where the true posterior does not.</p>]]></content:encoded></item></channel></rss>