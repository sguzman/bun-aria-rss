<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Diving into data</title>
	<atom:link href="http://blog.datadive.net/feed/" rel="self" type="application/rss+xml" />
	<link>http://blog.datadive.net</link>
	<description>A blog on machine learning, data mining and visualization</description>
	<lastBuildDate>Thu, 09 Dec 2021 21:37:38 +0000</lastBuildDate>
	<language>en</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=6.0.3</generator>
	<item>
		<title>Monotonicity constraints in machine learning</title>
		<link>http://blog.datadive.net/monotonicity-constraints-in-machine-learning/</link>
					<comments>http://blog.datadive.net/monotonicity-constraints-in-machine-learning/#comments</comments>
		
		<dc:creator><![CDATA[ando]]></dc:creator>
		<pubDate>Sun, 16 Sep 2018 10:01:42 +0000</pubDate>
				<category><![CDATA[Data science]]></category>
		<category><![CDATA[Machine learning]]></category>
		<guid isPermaLink="false">http://blog.datadive.net/?p=4721</guid>

					<description><![CDATA[In practical machine learning and data science tasks, an ML model is often used to quantify a global, semantically meaningful relationship between two or more values. For example, a hotel chain might want to use ML to optimize their pricing &#8230; <a href="http://blog.datadive.net/monotonicity-constraints-in-machine-learning/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p>In practical machine learning and data science tasks, an ML model is often used to quantify a global, semantically meaningful relationship between two or more values. For example, a hotel chain might want to use ML to optimize their pricing strategy and use a model to estimate the likelihood of a room being booked at a given price and day of the week. For a relationship like this the assumption is that, all other things being equal, a cheaper price is preferred by a user, so demand is higher at a lower price. However what might easily happen is that upon building the model, the data scientist discovers that the model is behaving unexpectedly: for example the model predicts that on Tuesdays, the clients would rather pay $110 than $100 for a room! The reason is that while there is an expected monotonic relationship between price and the likelihood of booking, the model is unable to (fully) capture it, due to noisiness of the data and confounds in it.</p><p>Too often, such constraints  are ignored by practitioners, especially when non-linear models such as random forests, gradient boosted trees or neural networks are used. And while monotonicity constraints have been a topic of academic research for a long time (see a <a href="http://www.kdd.org/exploration_files/potharst.pdf">survey paper</a> on monotonocity constraints for tree based methods), there has been lack of support from libraries, making the problem hard to tackle for practitioners.</p><p>Luckily, in recent years there has been a lot of progress in various ML libraries to allow setting monotonicity constraints for the models, including in <a href="https://github.com/Microsoft/LightGBM">LightGBM</a> and <a href="https://github.com/dmlc/xgboost">XGBoost</a>, two of the most popular libraries for gradient boosted trees. Monotonicity constraints have also been built into <a href="https://github.com/tensorflow/lattice">Tensorflow Lattice</a>, a library that implements a novel method for creating interpolated lookup tables.</p>
<h2>Monotonicity constraints in LighGBM and XGBoost</h2><p>For tree based methods (decision trees, random forests, gradient boosted trees), monotonicity can be forced during the model learning phase by not creating splits on monotonic features that would break the monotonicity constraint. </p><p>In the following example, let&#8217;s train too models using LightGBM on a toy dataset where we know the relationship between X and Y to be monotonic (but noisy) and compare the default and monotonic model.</p>
<pre class="brush: python; collapse: false; title: ; wrap-lines: false; notranslate">
import numpy as np
size = 100
x = np.linspace(0, 10, size) 
y = x**2 + 10 - (20 * np.random.random(size))
</pre><p><a href="http://blog.datadive.net/wp-content/uploads/2018/09/data_plot.png"><img loading="lazy" class="alignnone size-full wp-image-4729" src="http://blog.datadive.net/wp-content/uploads/2018/09/data_plot.png" alt="" width="393" height="261" srcset="http://blog.datadive.net/wp-content/uploads/2018/09/data_plot.png 393w, http://blog.datadive.net/wp-content/uploads/2018/09/data_plot-300x199.png 300w" sizes="(max-width: 393px) 100vw, 393px" /></a><br />
Let&#8217;s fit a fit a gradient boosted model on this data, setting <code>min_child_samples</code> to 5. </p>
<pre class="brush: python; collapse: false; title: ; wrap-lines: false; notranslate">
import lightgbm as lgb
overfit_model = lgb.LGBMRegressor(silent=False, min_child_samples=5)
overfit_model.fit(x.reshape(-1,1), y)

#predicted output from the model from the same input
prediction = overfit_model.predict(x.reshape(-1,1))
</pre><p>The model will slightly overfit (due to small <code>min_child_samples</code>), which we can see from plotting the values of X against the predicted values of Y: the red line is not monotonic as we&#8217;d like it to be.</p><p><a href="http://blog.datadive.net/wp-content/uploads/2018/09/model_fit.png"><img loading="lazy" class="alignnone size-full wp-image-4730" src="http://blog.datadive.net/wp-content/uploads/2018/09/model_fit.png" alt="" width="380" height="274" srcset="http://blog.datadive.net/wp-content/uploads/2018/09/model_fit.png 380w, http://blog.datadive.net/wp-content/uploads/2018/09/model_fit-300x216.png 300w" sizes="(max-width: 380px) 100vw, 380px" /></a></p><p>Since we know that that the relationship between X and Y should be monotonic, we can set this constraint when specifying the model.</p>
<pre class="brush: python; collapse: false; title: ; wrap-lines: false; notranslate">
monotone_model = lgb.LGBMRegressor(min_child_samples=5, 
                                   monotone_constraints=&quot;1&quot;)
monotone_model.fit(x.reshape(-1,1), y)
</pre><p>The parameter monotone_constraints=&#8221;1&#8243; states that the output should be monotonically increasing wrt. the first features (which in our case happens to be the only feature). After training the monotone model, we can see that the relationship is now strictly monotone.<br />
<a href="http://blog.datadive.net/wp-content/uploads/2018/09/monotone_model_fit.png"><img loading="lazy" class="alignnone size-full wp-image-4731" src="http://blog.datadive.net/wp-content/uploads/2018/09/monotone_model_fit.png" alt="" width="401" height="256" srcset="http://blog.datadive.net/wp-content/uploads/2018/09/monotone_model_fit.png 401w, http://blog.datadive.net/wp-content/uploads/2018/09/monotone_model_fit-300x192.png 300w" sizes="(max-width: 401px) 100vw, 401px" /></a></p><p>And if we check the model performance, we can see that not only does the monotonicity constraint provide a more natural fit, but the model generalizes better as well (as expected). Measuring the mean squared error on new test data, we see that error is smaller for the monotone model.</p>
<pre class="brush: python; collapse: false; title: ; wrap-lines: false; notranslate">
from sklearn.metrics import mean_squared_error as mse

size = 1000000
x = np.linspace(0, 10, size) 
y = x**2  -10 + (20 * np.random.random(size))

print (&quot;Default model mse&quot;, mse(y, overfit_model.predict(x.reshape(-1,1))))
print (&quot;Monotone model mse&quot;, mse(y, monotone_model.predict(x.reshape(-1,1))))
</pre><p><code><br />
Default model mse 37.61501106522855<br />
Monotone model mse 32.283051723268265<br />
</code></p>
<h2>Other methods for enforcing monotonicity</h2><p>Tree based methods are not the only option for setting monotonicity constraint in the data. One recent development in the field is <a href= "https://github.com/tensorflow/lattice"> Tensorflow Lattice</a>, which implements lattice based models that are essentially interpolated look-up tables that can approximate arbitrary input-output relationships in the data and which can optionally be monotonic. There is a thorough <a href="https://github.com/tensorflow/lattice/blob/master/g3doc/tutorial/index.md">tutorial</a> on it in Tensorflow Github.</p><p>If a curve is already given, monotonic spline can be fit on the data, for example using the <a href="https://stat.ethz.ch/R-manual/R-devel/library/stats/html/splinefun.html">splinefun</a> package.</p>
<div style="padding-top:0px;	
padding-right:0px;
padding-bottom:0px;
padding-left:0px;
margin-top:0px;
margin-right:0px;
margin-bottom:0px;
margin-left:0px;"><a href="https://twitter.com/crossentropy" class="twitter-follow-button" 
						data-show-count="false"
						data-lang="autoLANGauto"
						data-width="250px"
						data-align="left"
						data-show-screen-name="true"
						data-size="medium"
						data-dnt="false">
						Follow @crossentropy </a> </div>
						<script>
						!function(d,s,id) {
						  var js,fjs=d.getElementsByTagName(s)[0];
						  if(!d.getElementById(id)) {
						   js=d.createElement(s);
						   js.id=id;js.src="//platform.twitter.com/widgets.js";
						   fjs.parentNode.insertBefore(js,fjs);
						  }
						}
						(document,"script","twitter-wjs");
						</script><div style="padding-top:0px;	
padding-right:0px;
padding-bottom:0px;
padding-left:0px;
margin-top:0px;
margin-right:0px;
margin-bottom:0px;
margin-left:0px;"><a href="https://twitter.com/share" class="twitter-share-button" 
				        data-url="http://blog.datadive.net/monotonicity-constraints-in-machine-learning/" 
				        data-via="crossentropy"
					    data-text="Monotonicity constraints in machine learning"
					    data-related=""
					    data-count="horizontal"
					    data-hashtags=""
					    data-lang="autoLANGauto"
					    data-counturl=""
					    data-size="medium"
					    data-dnt="false"	> Tweet </a> </div>
		                <script>
					    !function(d,s,id) {
					      var js,fjs=d.getElementsByTagName(s)[0];
					      if(!d.getElementById(id)) {
					       js=d.createElement(s);js.id=id;js.src="https://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);
					      }
					    }
					   (document,"script","twitter-wjs");
					    </script>]]></content:encoded>
					
					<wfw:commentRss>http://blog.datadive.net/monotonicity-constraints-in-machine-learning/feed/</wfw:commentRss>
			<slash:comments>19</slash:comments>
		
		
			</item>
		<item>
		<title>Random forest interpretation &#8211; conditional feature contributions</title>
		<link>http://blog.datadive.net/random-forest-interpretation-conditional-feature-contributions/</link>
					<comments>http://blog.datadive.net/random-forest-interpretation-conditional-feature-contributions/#comments</comments>
		
		<dc:creator><![CDATA[ando]]></dc:creator>
		<pubDate>Mon, 24 Oct 2016 21:13:15 +0000</pubDate>
				<category><![CDATA[Random forest]]></category>
		<guid isPermaLink="false">http://blog.datadive.net/?p=4511</guid>

					<description><![CDATA[In two of my previous blog posts, I explained how the black box of a random forest can be opened up by tracking decision paths along the trees and computing feature contributions. This way, any prediction can be decomposed into &#8230; <a href="http://blog.datadive.net/random-forest-interpretation-conditional-feature-contributions/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p>In two of my <a href="http://blog.datadive.net/interpreting-random-forests/">previous</a> <a href="http://blog.datadive.net/random-forest-interpretation-with-scikit-learn/">blog posts</a>, I explained how the black box of a random forest can be opened up by tracking decision paths along the trees and computing feature contributions. This way, any prediction can be decomposed into contributions from features, such that \(prediction = bias + feature_1contribution+..+feature_ncontribution\).</p><p>However, this linear breakdown is inherently imperfect, since a linear combination of features cannot capture interactions between them. A classic example of a relation where a linear combination of inputs cannot capture the output is <a href="https://en.wikipedia.org/wiki/Exclusive_or">exclusive or</a> (XOR), defined as</p>
<div class="table-responsive">
<table  style="width:200px; "  class="easy-table easy-table-default tablesorter  " >
<thead>
<tr>
<th class=' ' >X1</th>
<th class=' ' >X2</th>
<th class=' ' >OUT</th>
</tr>
</thead>
<tbody>
<tr>
<td >0</td>
<td >0</td>
<td >0</td>
</tr>
<tr>
<td >0</td>
<td >1</td>
<td >1</td>
</tr>
<tr>
<td >1</td>
<td >0</td>
<td >1</td>
</tr>
<tr>
<td >1</td>
<td >1</td>
<td >0</td>
</tr>
</tbody>
</table>
</div><p>In this case, neither X1 nor X2 provide anything towards predicting the outcome in isolation. Their value only becomes predictive in conjunction with the the other input feature.</p><p>A decision tree can easily learn a function to classify the XOR data correctly via a two level tree (depicted below). However, if we consider feature contributions at each node, then at first step through the tree (when we have looked only at X1), we haven&#8217;t yet moved away from the bias, so the best we can predict at that stage is still &#8220;don&#8217;t know&#8221;, i.e. 0.5. And if we would have to write out the contribution from the feature at the root of the tree, we would (incorrectly) say that it is 0. After the next step down the tree, we would be able to make the correct prediction, at which stage we might say that the second feature provided all the predictive power, since we can move from a coin-flip (predicting 0.5), to a concrete and correct prediction, either 0 or 1. But of course attributing this to only the second level variable in the tree is clearly wrong, since the contribution comes from both features and should be equally attributed to both.</p><p>This information is of course available along the tree paths. We simply should gather together all conditions (and thus features) along the path that lead to a given node.</p>
<div class="wpd3-1-0"><script type="text/javascript">function wpd3_1_0 () {}; wpd3_1_0();</script></div>

    <style type="text/css">


.node circle {
  cursor: pointer;
  fill: #fff;
  stroke: steelblue;
  stroke-width: 1.5px;
}

.node text {
  font-size: 15px;
  
}
/*
table, th, td {
   border: 1px solid black;
} 
table {
    border-collapse: collapse;
}

th {
    padding:5px
}*/
path.link {
  fill: none;
  stroke: #ccc;
  stroke-width: 4px;
}

#equation {
margin-top:20px;
margin-bottom:20px;
border:1px solid;
padding:3px;
background-color:#eeffee;
}

.code {
 font-family: Consolas,Courier New,monospace;
 font-weight: bold;
}

    </style>
    
    <div id="d3"></div>
<div id ="equation">
    
    </div>


    
    <script type="text/javascript">
    
    d3.selectAll("a.link").on("click", function(d,i){
        var nodes = tree.nodes(root);
        nodes.forEach(function(d) { d.highlight = 0;});
        var key;
        if (i == 0) {
            key = 4;
        } else if (i == 1) {
            key = 6;
        } else {
            key = 10
        }
        
        items = highlight_parents(nodes[key])

        show_line(items)
        upd(root)
    });
var m = [0, 120, 0, 120],
    w = 1280 - m[1] - m[3],
    h = 500 - m[0] - m[2],
    i = 0,
    root;

var tree = d3.layout.tree()
    .size([h, w]);

var diagonal = d3.svg.diagonal()
    .projection(function(d) { return [d.y, d.x]; });

var vis = d3.select("#d3").append("svg:svg")
    .attr("width", w + m[1] + m[3])
    .attr("height", h + m[0] + m[2])
  .append("svg:g")
    .attr("transform", "translate(" + m[3] + "," + m[0] + ")");

var root = {"error": 2, "samples": 3, "value": [0.5], "label": "X1 == 0", "type": "split", 
    "children": 
        [{"error": 2, "samples": 3, "value": [0.5], "label": "X2 == 0", "type": "split",
            "children": [{"error": 2, "samples": 3, "value": [0], "label": "Leaf - 3", "type": "leaf"}
                       , {"error": 2, "samples": 3, "value": [1], "label": "Leaf - 4", "type": "leaf"}
                    ]}
     , {"error": 2, "samples": 3, "value": [0.5], "label": "X2 == 0", "type": "split", 
            "children": [{"error": 2, "samples": 3, "value": [1], "label": "Leaf - 6", "type": "leaf"}
                       , {"error": 2, "samples": 3, "value": [0], "label": "Leaf - 7", "type": "leaf"}
]}
]}



var leaf_id = 0;  

var nodes = tree.nodes(root).reverse();
nodes.forEach(function(d) { d.highlight = 0; d.y = d.depth * 100; });
  update(root);

        
items = highlight_parents(nodes[3])
show_line(items)
upd(root)
        
  
  
function highlight_parents(node) {
    node.highlight = 1;
    var accum2;
    if (typeof node.parent !== "undefined") {
        accum2 =  highlight_parents(node.parent)
    } else {
        accum2 = []
    }

    accum2.push(node)
    return accum2;
    
}

function show_line(items) {
    var v = "<span class='code'>" + items[0].value[0].toFixed(2) + "</span> (trainset mean)"
    var pred = items[items.length  - 1].value[0].toFixed(2) 
    var contr_list = ""
    for (var i = 1; i < items.length; i++) {
        add = (items[i].value[0] - items[i-1].value[0]).toFixed(2)
        contr_list += items[i-1].label.split(" ")[0] + "  "
        if (add < 0) {
            add = " - " + Math.abs(add)
            word = "decrease"
        } else {
            add = " + " + add
            word = "increase"
        }
        v += "<span class='code'>"+ add + "</span> ("+word+" from "+ contr_list+")"
    }
    d3.select('#equation').html("Prediction: <span class='code'><u>" +pred +"</u>  &#8776; </span>"+ v)
    
}

function upd(source) {

  var link = vis.selectAll("path.link")
      .style("stroke", function(d) {
            if (d.target.highlight) {return '#ff0000'} else {return "#00AA00"}})
      .style("stroke-width", function(d) {if (d.target.highlight) {return '6px'} else {return "4px"}})
   d3.selectAll('text').attr('font-weight', function(d){ if (d.highlight) {return 'bold'} else {return ""}})
   
}
  
function update(source) {
  var duration = d3.event && d3.event.altKey ? 5000 : 500;

  // Compute the new tree layout.
  var nodes = tree.nodes(root).reverse();

  nodes.forEach(function(d) { d.y = d.depth * 100; });
  
  // Normalize for fixed-depth.
  //nodes.forEach(function(d) { d.y = d.depth * 100; });
  

  // Update the nodes…
  var node = vis.selectAll("g.node")
      .data(nodes, function(d) { return d.id || (d.id = ++i); });
  
  // Enter any new nodes at the parent's previous position.
  var nodeEnter = node.enter().append("svg:g")
      .attr("class", "node")
      .attr("transform", function(d) { return "translate(" + source.y0 + "," + source.x0 + ")"; })
      .on("mouseover", function(d){
                    if (d.type == "leaf") {
                        var nodes = tree.nodes(root);
                        nodes.forEach(function(d) { d.highlight = 0;});
                        items = highlight_parents(d)
                        show_line(items)
                        upd(root)
                    }
                    
                    });

  nodeEnter.append("svg:circle")
      .attr("r", 1e-6)
      .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });

      
  nodeEnter.append("svg:text")
      .attr("x", function(d) { return d.children || d._children ? -10 : 10; })
      //.attr("dy", ".35em")
      .attr("text-anchor", function(d) { return d.children || d._children ? "end" : "start"; })
            .text(function(d) { 
                if (d.type != "leaf") {
                    return d.label;
                } else {
                    return "Value:"+(d.value[0]).toFixed(2); 
                }})
      .style("fill-opacity", 1e-6)
      .style("font-family", "Consolas,Courier New,monospace")
      .style("background-color", "yellow")
      
      
      
  nodeEnter.append("svg:text")
      .attr("x", function(d) { return d.children || d._children ? -10 : 10; })
      .attr("y", "20")
      .attr("text-anchor", function(d) { return d.children || d._children ? "end" : "start"; })
      .text(function(d) { if (d.type != "leaf") {return "Value:"+(d.value[0]).toFixed(2);  } else {return ""}})
      .style("font-family", "Consolas,Courier New,monospace")
      
      
  // Transition nodes to their new position.
  var nodeUpdate = node.transition()
      .duration(duration)
      .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });

  nodeUpdate.select("circle")
      .attr("r", 8)
      .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });

  nodeUpdate.select("text")
      .style("fill-opacity", 1);

  
  // Update the links…
  var link = vis.selectAll("path.link")
      .data(tree.links(nodes), function(d) { return d.target.id; });

  // Enter any new links at the parent's previous position.
  link.enter().insert("svg:path", "g")
      .attr("class", "link")
      .attr("d", function(d) {
        var o = {x: source.x0, y: source.y0};
        return diagonal({source: o, target: o});
      });
  link.style("stroke", function(d) {
            if (d.target.highlight) {return '#ff0000'} else {return "#00AA00"}})
      .style("stroke-width", function(d) {if (d.target.highlight) {return '6px'} else {return "4px"}})
      
  
  link.transition()
      .duration(0)
      .attr("d", diagonal);


}

    </script>

<p>As you can see, the contribution of the first feature at the root of the tree is 0 (<em>value</em> staying at 0.5), while observing the second feature gives the full information needed for the prediction. We can now combine the features along the decision path, and correctly state that X1 and X2 together create the contribution towards the prediction.</p><p>The joint contribution calculation is supported by v0.2 of the <a href="https://github.com/andosa/treeinterpreter/">treeinterpreter</a> package (clone or install via pip). Joint contributions can be obtained by passing the <em>joint_contributions</em> argument to the <em>predict </em>method, returning the triple [prediction, contributions, bias], where contribution is a mapping from tuples of feature indices to absolute contributions.<br />
Here&#8217;s an example, comparing two datasets of the Boston housing data, and calculating which feature combinations contribute to the difference in estimated prices</p>
<pre class="brush: python; collapse: false; title: ; wrap-lines: false; notranslate"> 
from sklearn.ensemble import RandomForestRegressor
import numpy as np
from sklearn.datasets import load_boston
from treeinterpreter import treeinterpreter as ti, utils

boston = load_boston()
rf = RandomForestRegressor()
# We train a random forest model, ...
rf.fit(boston.data[:300], boston.target[:300])
# take two subsets from the data ...
ds1 = boston.data[300:400]
ds2 = boston.data[400:]
# and check what the predicted average price is
print (np.mean(rf.predict(ds1)))
print (np.mean(rf.predict(ds2)))
</pre>
<blockquote><p><code><br />
21.9329<br />
17.8863207547<br />
</code></p></blockquote><p>The average predicted price is different for the two datasets. We can break down why and check the joint feature contribution for both datasets.</p>
<pre class="brush: python; collapse: false; title: ; wrap-lines: false; notranslate"> 
prediction1, bias1, contributions1 = ti.predict(rf, ds1, joint_contribution=True)
prediction2, bias2, contributions2 = ti.predict(rf, ds2, joint_contribution=True)
</pre><p>Since biases are equal for both datasets (because the the model is the same), the difference between the average predicted values has to come only from (joint) feature contributions. In other words, the sum of the feature contribution differences should be equal to the difference in average prediction.<br />
We can make use of the <em>aggregated_contributions</em> convenience method which takes the contributions for individual predictions and aggregates them together for the whole dataset</p>
<pre class="brush: python; collapse: false; title: ; wrap-lines: false; notranslate"> 
aggregated_contributions1 = utils.aggregated_contribution(contributions1)
aggregated_contributions2 = utils.aggregated_contribution(contributions2)

print (np.sum(list(aggregated_contributions1.values())) -  
       np.sum(list(aggregated_contributions2.values())))
print (np.mean(prediction1) - np.mean(prediction2))
</pre>
<blockquote><p><code><br />
4.04657924528<br />
4.04657924528<br />
</code></p></blockquote><p>Indeed we see that the contributions exactly match the difference, as they should.</p><p>Finally, we can check which feature combination contributed by how much to the difference of the predictions in the too datasets:</p>
<pre class="brush: python; collapse: false; title: ; wrap-lines: false; notranslate"> 
res = []
for k in set(aggregated_contributions1.keys()).union(
              set(aggregated_contributions2.keys())):
    res.append(([boston[&quot;feature_names&quot;][index] for index in k] , 
               aggregated_contributions1.get(k, 0) - aggregated_contributions2.get(k, 0)))   
        
for lst, v in (sorted(res, key=lambda x:-abs(x[1])))[:10]:
    print (lst, v)    
</pre>
<blockquote><p><code><br />
(['RM', 'LSTAT'], 2.0317570671740883)<br />
(['RM'], 0.69252072064203141)<br />
(['CRIM', 'RM', 'LSTAT'], 0.37069750747155134)<br />
(['RM', 'AGE'], 0.11572468903150034)<br />
(['INDUS', 'RM', 'AGE', 'LSTAT'], 0.054158313631716165)<br />
(['CRIM', 'RM', 'AGE', 'LSTAT'], -0.030778806073267474)<br />
(['CRIM', 'RM', 'PTRATIO', 'LSTAT'], 0.022935961564662693)<br />
(['CRIM', 'INDUS', 'RM', 'AGE', 'TAX', 'LSTAT'], 0.022200426774483421)<br />
(['CRIM', 'RM', 'DIS', 'LSTAT'], 0.016906509656987388)<br />
(['CRIM', 'INDUS', 'RM', 'AGE', 'LSTAT'], -0.016840238405056267)<br />
</code></p></blockquote><p>The majority of the delta came from the feature for number of rooms (RM), in conjunction with demographics data (LSTAT).</p>
<h2>Summary</h2><p>Making random forest predictions interpretable is pretty straightforward, leading to a similar level of interpretability as linear models. However, in some cases, tracking the feature interactions can be important, in which case representing the results as a linear combination of features can be misleading. By using the <em>joint_contributions</em> keyword for prediction in the <a href="https://github.com/andosa/treeinterpreter/">treeinterpreter</a> package, one can trivially take into account feature interactions when breaking down the contributions.</p>
<div style="padding-top:0px;	
padding-right:0px;
padding-bottom:0px;
padding-left:0px;
margin-top:0px;
margin-right:0px;
margin-bottom:0px;
margin-left:0px;"><a href="https://twitter.com/crossentropy" class="twitter-follow-button" 
						data-show-count="false"
						data-lang="autoLANGauto"
						data-width="250px"
						data-align="left"
						data-show-screen-name="true"
						data-size="medium"
						data-dnt="false">
						Follow @crossentropy </a> </div>
						<script>
						!function(d,s,id) {
						  var js,fjs=d.getElementsByTagName(s)[0];
						  if(!d.getElementById(id)) {
						   js=d.createElement(s);
						   js.id=id;js.src="//platform.twitter.com/widgets.js";
						   fjs.parentNode.insertBefore(js,fjs);
						  }
						}
						(document,"script","twitter-wjs");
						</script><div style="padding-top:0px;	
padding-right:0px;
padding-bottom:0px;
padding-left:0px;
margin-top:0px;
margin-right:0px;
margin-bottom:0px;
margin-left:0px;"><a href="https://twitter.com/share" class="twitter-share-button" 
				        data-url="http://blog.datadive.net/random-forest-interpretation-conditional-feature-contributions/" 
				        data-via="crossentropy"
					    data-text="Random forest interpretation - conditional feature contributions"
					    data-related=""
					    data-count="horizontal"
					    data-hashtags=""
					    data-lang="autoLANGauto"
					    data-counturl=""
					    data-size="medium"
					    data-dnt="false"	> Tweet </a> </div>
		                <script>
					    !function(d,s,id) {
					      var js,fjs=d.getElementsByTagName(s)[0];
					      if(!d.getElementById(id)) {
					       js=d.createElement(s);js.id=id;js.src="https://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);
					      }
					    }
					   (document,"script","twitter-wjs");
					    </script>]]></content:encoded>
					
					<wfw:commentRss>http://blog.datadive.net/random-forest-interpretation-conditional-feature-contributions/feed/</wfw:commentRss>
			<slash:comments>25</slash:comments>
		
		
			</item>
		<item>
		<title>Histogram intersection for change detection</title>
		<link>http://blog.datadive.net/histogram-intersection-for-change-detection/</link>
					<comments>http://blog.datadive.net/histogram-intersection-for-change-detection/#comments</comments>
		
		<dc:creator><![CDATA[ando]]></dc:creator>
		<pubDate>Sun, 28 Feb 2016 15:12:51 +0000</pubDate>
				<category><![CDATA[Change detection]]></category>
		<category><![CDATA[Data science]]></category>
		<guid isPermaLink="false">http://blog.datadive.net/?p=4051</guid>

					<description><![CDATA[The need for anomaly and change detection will pop up in almost any data driven system or quality monitoring application. Typically, there are set of metrics that need to be monitored and an alert raised if the values deviate from &#8230; <a href="http://blog.datadive.net/histogram-intersection-for-change-detection/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[
<p>The need for anomaly and change detection will pop up in almost any data driven system or quality monitoring application. Typically, there are set of metrics that need to be monitored and an alert raised if the values deviate from the expected. Depending on the task at hand, this can happen at individual datapoint level (anomaly detection) or population level where we want to know if the underlying distribution changes or not (change detection).</p>



<p>The latter is most commonly tackled by the most straightforward: calculating some point estimates, typically the mean or median and track these. This could be time based such as calculating the daily mean, or be based on some unit of &#8220;work done&#8221; such as for batches in a production line or versions in software product. The calculated point estimates can be displayed on dashboards to be checked visually or a delta computed between consequtive numbers, which can be compared against some pre-defined threshold to see if an alarm should be raised.</p>



<p>The problem with such point estimates is that they don&#8217;t necessarily capture the change in the underlying distribution of the tracked measure well. A change in the distribution can be signficicant while the mean or the median remains unchanged.</p>



<p>In cases when change needs to be detected, measuring it directly on the distribution is typically a much better option.</p>



<h2>Histogram intersection</h2>



<p>Histogram intersection calculates the similarity of two discretized probability distributions (histograms), with possible value of the intersection lying between 0 (no overlap) and 1 (identical distributions). Given bin edges and two normalized histogram, it can be calculated by</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: python; title: ; notranslate">
def histogram_intersection(h1, h2, bins):
    bins = numpy.diff(bins)
    sm = 0
    for i in range(len(bins)):
        sm += min(bins&#091;i]*h1&#091;i], bins&#091;i]*h2&#091;i])
    return sm
</pre></div>


<p>For example for the two distributions \(\mathcal{N}(2,1)\) and \(\mathcal{N}(3,1.5)\), the intersection is ~0.66, easy to represent graphically<br><a href="http://blog.datadive.net/wp-content/uploads/2016/02/intersect.png"><img loading="lazy" class="alignnone size-full wp-image-4071" src="http://blog.datadive.net/wp-content/uploads/2016/02/intersect.png" alt="intersect" width="551" height="313" srcset="http://blog.datadive.net/wp-content/uploads/2016/02/intersect.png 551w, http://blog.datadive.net/wp-content/uploads/2016/02/intersect-300x170.png 300w" sizes="(max-width: 551px) 100vw, 551px" /></a></p>



<p>Histogram intersection has a few extra benefits:</p>



<ul><li>It works equally well on categorical data, where we can use category frequencies to compute the intersection</li><li>Dealing with null values comes for free, simply by making nulls part of the distribution: if there is an increase in nulls, it changes the intersection, even if non-null values will continue to be distributed the same way. In contrast, when tracking point estimates such as the mean, null value checks need to be explicitly added as an additional item to track.</li></ul>



<p>As always, there are some caveats. One issue is that the intersection depends on how the bins have been selected. This becomes an issue especially for long tailed distributions. For example for the lognormal distribution, with same \(\mu\) and \(\sigma\) as above, the histogram might look something like the following, with practically all density concentrated in the first bin. Calculating the intersection on that would clearly give very misleading results.<br><a href="http://blog.datadive.net/wp-content/uploads/2016/02/intersect2.png"><img loading="lazy" class="alignnone size-full wp-image-4081" src="http://blog.datadive.net/wp-content/uploads/2016/02/intersect2.png" alt="intersect2" width="561" height="312" srcset="http://blog.datadive.net/wp-content/uploads/2016/02/intersect2.png 561w, http://blog.datadive.net/wp-content/uploads/2016/02/intersect2-300x167.png 300w" sizes="(max-width: 561px) 100vw, 561px" /></a></p>



<p>This can be tackled by either moving the histogram to log-scale, or simply by clipping the long tail to use it as an approximtion. For this particular examples clipping gives the same result as the &#8220;true&#8221; intersection calculted in log scale.</p>



<figure class="wp-block-image"><a href="http://blog.datadive.net/wp-content/uploads/2016/02/intersect3.png"><img loading="lazy" width="565" height="318" src="http://blog.datadive.net/wp-content/uploads/2016/02/intersect3.png" alt="intersect3" class="wp-image-4091" srcset="http://blog.datadive.net/wp-content/uploads/2016/02/intersect3.png 565w, http://blog.datadive.net/wp-content/uploads/2016/02/intersect3-300x169.png 300w" sizes="(max-width: 565px) 100vw, 565px" /></a></figure>



<h3>Kullback-Leibler divergence and statistical tests</h3>



<p>Two methods often recommended for detecting change in distribution are <a href="https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence">Kullback-Leibler divergence</a> and statistical tests, for example a chi-squared test which could be used both on categorical data and a histogram of continous data. Both of the methods have significant drawbacks however.</p>



<p>Kullback-Leibler divergence is measured in bits and unlike histogram intersection, does not lie in a given range. This makes comparison on two different dataset difficult. Secondly, it is only defined when zeroes in the distributions lie in the same bins. Ths can be overcome by transferrning some of the probability mass to locations with zero probability, however, this is another extra complexity that needs to be handled. Finally, KL divergence is not a true metric, i.e. it does not obey triangle inequality, and is non-symmetric, i.e. in general, when comparing two different distributions \(P\) and \(Q\), \(KL(P,Q) \neq KL(Q,P)\).</p>



<p>Using a statistical test, for example a chi-squared test might seem like a good option, since it gives you a p-value you can use to estimate how likely it is that the distribution has changed. The problem is that the p-value of a test is a function of the size of the data, so we can obtain tiny p-values with very small differences in the distributions. In the following, we are comparing \(\mathcal{N}(0,1)\) and \(\mathcal{N}(0.005,1)\) in the first plot, and \(\mathcal{N}(0,1)\) and \(\mathcal{N}(1,1)\) in the second plot.<br><a href="http://blog.datadive.net/wp-content/uploads/2016/02/intersect4.png"><img loading="lazy" class="alignnone size-full wp-image-4171" src="http://blog.datadive.net/wp-content/uploads/2016/02/intersect4.png" alt="intersect4" width="753" height="322" srcset="http://blog.datadive.net/wp-content/uploads/2016/02/intersect4.png 753w, http://blog.datadive.net/wp-content/uploads/2016/02/intersect4-300x128.png 300w" sizes="(max-width: 753px) 100vw, 753px" /></a></p>



<p>In both cases, we have tiny p-values, in fact it is even smaller for the first plot. From practical point of view, the change in the first case is likely irrelevant, since the absolute change is so small.</p>



<p>A chi-squared test can of course still be very useful and complement the histogram intersection, by letting us know if the amount of data is small enough that measuring the intersection likely won&#8217;t give meaningful results.</p>



<h3>Beyond histogram intersection</h3>



<p>One drawback of histogram intersection is that it does not consider distances between bins, which can be important in case of ordinal data.</p>



<p>For example, consider the following plot with three different histograms. Histogram intersection between histograms 1 and 2, and 1 and 3 are the same. However, assuming it is ordinal data, we might want to say that histgorams 1 and 2 are actually more similar to each other, since the changed bins are closer to each other than the change between 1 and 3.<br><a href="http://blog.datadive.net/wp-content/uploads/2016/02/intersect51.png"><img loading="lazy" class="alignnone size-full wp-image-4421" src="http://blog.datadive.net/wp-content/uploads/2016/02/intersect51.png" alt="intersect5" width="719" height="317" srcset="http://blog.datadive.net/wp-content/uploads/2016/02/intersect51.png 719w, http://blog.datadive.net/wp-content/uploads/2016/02/intersect51-300x132.png 300w" sizes="(max-width: 719px) 100vw, 719px" /></a></p>



<p>There are various methods to take this into account, the most well known being <a href="https://en.wikipedia.org/wiki/Earth_mover's_distance">earth mover&#8217;s distance</a>. There is a nice overview of these methods <a href="http://www.ariel.ac.il/sites/ofirpele/publications/ECCV2010.pdf">here</a>.</p>
<div style="padding-top:0px;	
padding-right:0px;
padding-bottom:0px;
padding-left:0px;
margin-top:0px;
margin-right:0px;
margin-bottom:0px;
margin-left:0px;"><a href="https://twitter.com/crossentropy" class="twitter-follow-button" 
						data-show-count="false"
						data-lang="autoLANGauto"
						data-width="250px"
						data-align="left"
						data-show-screen-name="true"
						data-size="medium"
						data-dnt="false">
						Follow @crossentropy </a> </div>
						<script>
						!function(d,s,id) {
						  var js,fjs=d.getElementsByTagName(s)[0];
						  if(!d.getElementById(id)) {
						   js=d.createElement(s);
						   js.id=id;js.src="//platform.twitter.com/widgets.js";
						   fjs.parentNode.insertBefore(js,fjs);
						  }
						}
						(document,"script","twitter-wjs");
						</script><div style="padding-top:0px;	
padding-right:0px;
padding-bottom:0px;
padding-left:0px;
margin-top:0px;
margin-right:0px;
margin-bottom:0px;
margin-left:0px;"><a href="https://twitter.com/share" class="twitter-share-button" 
				        data-url="http://blog.datadive.net/histogram-intersection-for-change-detection/" 
				        data-via="crossentropy"
					    data-text="Histogram intersection for change detection"
					    data-related=""
					    data-count="horizontal"
					    data-hashtags=""
					    data-lang="autoLANGauto"
					    data-counturl=""
					    data-size="medium"
					    data-dnt="false"	> Tweet </a> </div>
		                <script>
					    !function(d,s,id) {
					      var js,fjs=d.getElementsByTagName(s)[0];
					      if(!d.getElementById(id)) {
					       js=d.createElement(s);js.id=id;js.src="https://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);
					      }
					    }
					   (document,"script","twitter-wjs");
					    </script>]]></content:encoded>
					
					<wfw:commentRss>http://blog.datadive.net/histogram-intersection-for-change-detection/feed/</wfw:commentRss>
			<slash:comments>13</slash:comments>
		
		
			</item>
		<item>
		<title>Who are the best MMA fighters of all time. A Bayesian study</title>
		<link>http://blog.datadive.net/who-are-the-best-mma-fighters-of-all-time-a-bayesian-study/</link>
					<comments>http://blog.datadive.net/who-are-the-best-mma-fighters-of-all-time-a-bayesian-study/#comments</comments>
		
		<dc:creator><![CDATA[ando]]></dc:creator>
		<pubDate>Tue, 22 Dec 2015 13:22:31 +0000</pubDate>
				<category><![CDATA[Bayesian analysis]]></category>
		<category><![CDATA[Data science]]></category>
		<category><![CDATA[Machine learning]]></category>
		<guid isPermaLink="false">http://blog.datadive.net/?p=3821</guid>

					<description><![CDATA[Like with any sport, the question of who are the best competitors of all time in Mixed Martial Arts (MMA) is something that is hotly debated among MMA fans. And unlike for tournament based sports such as tennis, or sports &#8230; <a href="http://blog.datadive.net/who-are-the-best-mma-fighters-of-all-time-a-bayesian-study/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p>Like with any sport, the question of who are the best competitors of all time in Mixed Martial Arts (MMA) is something that is hotly debated among MMA fans. And unlike for tournament based sports such as tennis, or sports where results can be objectively measured such as track and field, it is a question that is much more difficult to answer in MMA. Firstly, fighters compete in different weight classes and organizations, often making direct comparison impossible. Secondly, even when competitors are in the same weight class in the same organization, comparison can be difficult simply because of the relatively low number of matches that an average competitor has &#8211; not everyone is competing against everyone else. All of this leavies a lot of room for speculation and what-if scenarios. Indeed, any ranking of fighter&#8217;s skills is highly subjective, dependant on the criterias set forth and as a consequence highly debatable.</p><p>What we can do though is to take a purely statistical approach, by estimating which fighters are the likeliest to have the highest skill level, considering their wins and the quality of their opponents. This blog post intends to do just that, by using state of the art statistical methods that have been successfully used in similar settings, for example to analyze and rank chess players (see <a href="http://research.microsoft.com/apps/pubs/default.aspx?id=74417"><br />
TrueSkill Through Time: Revisiting the History of Chess</a>) and for <a href="http://research.microsoft.com/en-us/projects/trueskill/">ranking players in competitive online games</a>.</p>
<h2>Dataset</h2><p>The data we will utilise is obtained from <a href="http://www.sherdog.com/stats/fightfinder">Sherdog fight finder</a>, a comprehenseive database of MMA matches, dating back from 1980 (with the first match between Casemiro Martins and Rickson Gracie). The dataset includes results of over 200,000 matches and over 94000 fighters in total. The following chart displays the number of matches per year in the dataset.<br />
<a href="http://blog.datadive.net/wp-content/uploads/2015/12/matchesperyear.png"><img loading="lazy" class="alignnone size-full wp-image-3841" src="http://blog.datadive.net/wp-content/uploads/2015/12/matchesperyear.png" alt="matchesperyear" width="720" height="432" srcset="http://blog.datadive.net/wp-content/uploads/2015/12/matchesperyear.png 720w, http://blog.datadive.net/wp-content/uploads/2015/12/matchesperyear-300x180.png 300w" sizes="(max-width: 720px) 100vw, 720px" /></a></p><p>In this data, we have full details of match outcomes, including win type (if the fight ended with a win for one of the contestants), but also information about matches ending in no contest or disqualification. Since the study tries to esimate skill, we ignore data about both NC and disqualified matches (even though the latter means a win for one of the fighters, it is not possible to infer the skill level based on that fact alone, Jon Jones vs Matt Hamill being a good example ). All computatios are done on the snapshot of the data as of Dec. 20, 2015.</p>
<h2>Skill inference</h2><p>Our goal is to assign a skill level for each fighter, based on observed match outcomes. As mentioned earlier, the methodology we will employe is based on the same Bayesian statistical approach that is used by Microsoft for Xbox called <a href="http://research.microsoft.com/en-us/projects/trueskill/">Trueskill</a> to determine the skill level players so that they can be matched up optimally competitive multiplayer games such as Halo. Also, the same approach has been employed to rank chess players using historic chess match outcome data from 1850 to 2006 (see <a href="http://research.microsoft.com/apps/pubs/default.aspx?id=74417">TrueSkill Through Time: Revisiting the History of Chess</a>).</p><p>We rely on Bayesian inference to infer the skill of competitors based on the observed match outcomes. As skills of fighters are unknown, they are assigned a probability distribution, in the current case a Gaussian with mean \(\mu\) and variance of \(\sigma^2\). The mean \(\mu\) of a fighter skill specifies the average performance of the fighter. Our uncertainty in the skill level is specified by variance \(\sigma^2\). The match outcome is determined by the performance of both contestants. Since performance of a fighter can vary from match to match (good days and bad days), it can be thought of as a noisy version of skill. The winner of the match is the one with hgher performance in that particular match.</p><p>The following is the high level summary of the model we base the stastical inference on</p>
<ul>
<li>Each fighter&#8217;s skill is a normally distributed (Gaussian) random variable (the mean and variance of which we will lern from the data). Since a fighter&#8217;s skill changes over the years, we have a skill ranking for a fighter for each year he is active. These are the values we want to infer.</li>
<li>In every match, fighters performance comes from skill, i.e. is drawn from Gaussian \( \mathcal{N}(skill, performanceVariance)\), where \(perfromanceVariance\) is another hidden variable, learned from data.</li>
<li>A fight ends in a decision victory for fighter \(f_1\), if his performance \(p_1\) is greater than the performannce of fighter \(f_2\) + some threshold \(decisionThreshold\), i.e. \(p_1 > p_2+ decisionThreshold\).</li>
<li>If the skill difference is less than the decision threshold, the fight ends in a draw.</li>
<li>A fight ends in a finish victory (sbmission, KO or TKO) for fighter \(f_1\) if \( p1 > p2 + finishThreshold\)</li>
<li>Both finish and decision threshold themseves are hidden variables that are learned from data</li>
<li>Finish threshold is constrained to be strictly larger than decision threshold, i.e. \(finishThreshold > decisionThreshold\)</li>
<li>Two contestants in a match are assumed to be on a somewhat similar level, i.e. their skill level is very unlikely to be vastly different. In other words, UFC level fighters are in general matched up with other UFC level fighters, not low level amateurs. This assumption helps us in inferring the skill level of fighters who have a very small number of fights. Thus for each match, we assume \(\mid skill_1 &#8211; skill_2 \mid \lt matchupThreshold \). The value of matchup threshold is again a hidden variable learned from data.</li>
</ul><p>To implement the model we use <a href="http://research.microsoft.com/en-us/um/cambridge/projects/infernet/">Infer.net</a>, a Bayesian inference framework. The model is in large parts based on the <a href="http://research.microsoft.com/en-us/um/cambridge/projects/infernet/docs/Chess%20Analysis.aspx">Chess analysis</a> model built by Microsoft Research on the same toolset. The code for the model can be found in <a href="https://github.com/andosa/MMAinfer">Github</a>. The final inference is done model is inferred based on the full Sherdog fight database.</p>
<h3>Dealing with weight classes</h3><p>While most matches are within a weight class, there are also matches where contestants in different weight classes are matched up. In this case, a heavier fighter has an advantage on average. This translates into a bias, where the average skill levels of fighters in higher weight classes will be observed to be higher than those of lower ones. To create a true pound for pound ranking, we can normalize the skill by weight class, by dividing each fighter&#8217;s skill level by the average skill level of the given weightclass.</p><p>The mean skill level over all fighters is 1000 (since this is chosen as the prior/baseline). The following are the weight class averages (NA denotes no information about a fighter&#8217;s weightclass).</p>
<div class="table-responsive">
<table  style="width:100%; "  class="easy-table easy-table-default tablesorter  " >
<thead>
<tr>
<th class=' ' >Weight class</th>
<th class=' ' >Average inferred skill</th>
</tr>
</thead>
<tbody>
<tr>
<td >Heavyweight</td>
<td >1159</td>
</tr>
<tr>
<td >Light Heavyweight</td>
<td >    1141</td>
</tr>
<tr>
<td >Middleweight</td>
<td >         1140</td>
</tr>
<tr>
<td >Welterweight</td>
<td >         1132</td>
</tr>
<tr>
<td >Lightweight</td>
<td >          1119</td>
</tr>
<tr>
<td >Featherweight</td>
<td >        1115</td>
</tr>
<tr>
<td >Bantamweight</td>
<td >         1085</td>
</tr>
<tr>
<td >Flyweight</td>
<td >           1085</td>
</tr>
<tr>
<td >NA</td>
<td >                    893</td>
</tr>
</tbody>
</table>
</div><p>A note about this table: this shouldnt be interepreted in absolute terms (&#8220;flyweights are only 6% weaker that heavyweights&#8221;). Rather, this is a bias correction table for the pound for pound ranking. In p4p terms, every weight class should have the same average skill level. Since across-weight class matches bias the numbers, this is the table we can use to correct it.</p>
<h4>Jon Jones is the best MMA fighters ever</h4><p>Long story short, statistically, Jon Jones has the highest skill ranking of any fighter in the database. The following graph shows the computed skill level of the top 10 male fighters out of 94000 fighters in the database.</p><p><a href="http://blog.datadive.net/wp-content/uploads/2015/12/rankings.png"><img loading="lazy" class="alignnone size-full wp-image-3861" src="http://blog.datadive.net/wp-content/uploads/2015/12/rankings.png" alt="rankings" width="864" height="576" srcset="http://blog.datadive.net/wp-content/uploads/2015/12/rankings.png 864w, http://blog.datadive.net/wp-content/uploads/2015/12/rankings-300x200.png 300w" sizes="(max-width: 864px) 100vw, 864px" /></a></p><p>Jones stands quite a bit higher above other fighters in terms of his skill rating. Where other top fighters&#8217; ratings are very close to each other, Jon Jones&#8217; rating is clearly above. Statistically, this isn&#8217;t a surprise. He is without loss (the model disregards DQ losses as irrelevant to skill), and with wins over extremely high level competition.</p><p>Looking at the rest of the list, there are some interesting results there. While Daniel Cormier isn&#8217;t typically ranked among the very top, statistically speaking, he should be. His only loss is to number one in Jones, and almost all of his wins are over very high quality opponents. The combined record of his opponents is the best in all of top 10.</p><p>Anderson&#8217;s Silva&#8217;s position as an all-time great is statistically somewhat hurt by the start and end of his career, his two losses to Chris Weidman and the losses to relatively weak fighters early in the career mean that from purely statistical point of view, he does not quite reach Jon Jones&#8217;s level. But even so, he is among the very top.</p><p>Ben Askren is definitely a surprise in the list. His undefeated record is the main reason he is this high. Since we have not observed a loss for him, it makes his probable skill very high from a statistical perspective. This is in some sense a drawback of the model, but fundementally, it <i>is</i> difficult to draw a conclusion about undefeated fighters. Khabib Nurmagomedov is another example for this. Normally, he isn&#8217;t considered p4p top 10. Statistically however, it makes a lot of sense, being 22-0 and having a very solid win list, including the current champion.</p><p>Two fighter have made meteoric rises in the rankings. Rafael dos Anjos and Conor Mcgregor, starting from a relatively low baseline(due to their lower level competionion and losses earlier in the career) have risen to top 10 very quickly, thanks to their very strong wins in the recent year(s).</p><p>One thing that should be emphasized is that the statistical skill levels for the top fighters are actually extremely close. For example, Conor Mcgregor came into the top 10 ranking only after beating Aldo, who was top 5 prior to that. This means a single fight can change the rankings very significantly.</p><p>Additionally, as mentioned earlier there is also variance associated with each inferred skill which reflects our statistical uncertainty in the estimation. An this uncertainty is (naturally) very high, due to the low number of fights each fighter has (unlike say chess, where the number of games can be in the thousands for a competitor). This is illustrated by the following chart, where we plot 95% confidence intervals around the mean for fighters often considered to be the top 3 of all time.<br />
<a href="http://blog.datadive.net/wp-content/uploads/2015/12/rankings_95th.png"><img loading="lazy" class="alignnone size-full wp-image-3851" src="http://blog.datadive.net/wp-content/uploads/2015/12/rankings_95th.png" alt="rankings_95th" width="864" height="576" srcset="http://blog.datadive.net/wp-content/uploads/2015/12/rankings_95th.png 864w, http://blog.datadive.net/wp-content/uploads/2015/12/rankings_95th-300x200.png 300w" sizes="(max-width: 864px) 100vw, 864px" /></a><br />
As can be seen, the intervals are fairly wide and overlapping. What this means is that while Jones has the highest average skill <i>given the match outcomes</i>, we cannot conclude with absolute certainty that his skill level is above the other top ranked fighters, simply that it is likely to be the case. And indeed, a slight underperfomance in one of his fights (such a loss to Gustafsson) would have changed the rankings drastically, showing how fragile the ranking estimation actually is. This all boils down to the fact that since the number of fights of a typical competitor is fairly small and there is a lot of &#8220;luck&#8221; involved, small mistakes making large changes in the overall picture.  And our model is well able to capture and quantify this uncertainty.</p>
<h5>Where is Demetrious Johsnon?</h5><p>Many consider the long-reigning flyweight champion Demetrious Johnson to be among the all time best, so him not being in top 10 statstically is somewhat surprising. Looking at the data further, the main reason for this seems to be overall competition, which surprisingly seems slightly weaker in the division. For example, his oppponents&#8217; and their opponents&#8217; combined win percentage is 62.9%. For comparison Chris Weidman&#8217;s opponents and their opponents win ratio is 64.6%, for McGregor it is 64.1% . This translates to Demetrious&#8217;s opponents ranking be on average lower than the opponents of the fighters in the top 10, in turn translating to his score being lower. </p>
<h2>Summary</h2><p>Bayesian inference provides an excellent toolset for inferring hidden parameters in the data, especially when the amount of data to draw conclusions on is small. As a result it is especially useful in a setting such as reasoning about the skill levels of top MMA competitors. Based on the available data, Jon Jones is the best ever from a statistical perspective. But it has to be kept in mind that the variance (uncertainty) in the estimates is very high and small changes in the data, such as one win or loss, can significantly alter the rankings. And this reflects the real world intuition well: a loss or two can easily change the perception of the fighter in the list of all time greats.</p><p>The code for the model to replicate the results or develop it further can be found at <a href="https://github.com/andosa/MMAinfer">Github</a>.</p>
<div style="padding-top:0px;	
padding-right:0px;
padding-bottom:0px;
padding-left:0px;
margin-top:0px;
margin-right:0px;
margin-bottom:0px;
margin-left:0px;"><a href="https://twitter.com/crossentropy" class="twitter-follow-button" 
						data-show-count="false"
						data-lang="autoLANGauto"
						data-width="250px"
						data-align="left"
						data-show-screen-name="true"
						data-size="medium"
						data-dnt="false">
						Follow @crossentropy </a> </div>
						<script>
						!function(d,s,id) {
						  var js,fjs=d.getElementsByTagName(s)[0];
						  if(!d.getElementById(id)) {
						   js=d.createElement(s);
						   js.id=id;js.src="//platform.twitter.com/widgets.js";
						   fjs.parentNode.insertBefore(js,fjs);
						  }
						}
						(document,"script","twitter-wjs");
						</script><div style="padding-top:0px;	
padding-right:0px;
padding-bottom:0px;
padding-left:0px;
margin-top:0px;
margin-right:0px;
margin-bottom:0px;
margin-left:0px;"><a href="https://twitter.com/share" class="twitter-share-button" 
				        data-url="http://blog.datadive.net/who-are-the-best-mma-fighters-of-all-time-a-bayesian-study/" 
				        data-via="crossentropy"
					    data-text="Who are the best MMA fighters of all time. A Bayesian study"
					    data-related=""
					    data-count="horizontal"
					    data-hashtags=""
					    data-lang="autoLANGauto"
					    data-counturl=""
					    data-size="medium"
					    data-dnt="false"	> Tweet </a> </div>
		                <script>
					    !function(d,s,id) {
					      var js,fjs=d.getElementsByTagName(s)[0];
					      if(!d.getElementById(id)) {
					       js=d.createElement(s);js.id=id;js.src="https://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);
					      }
					    }
					   (document,"script","twitter-wjs");
					    </script>]]></content:encoded>
					
					<wfw:commentRss>http://blog.datadive.net/who-are-the-best-mma-fighters-of-all-time-a-bayesian-study/feed/</wfw:commentRss>
			<slash:comments>20</slash:comments>
		
		
			</item>
		<item>
		<title>First Estonian Machine Learning Meetup</title>
		<link>http://blog.datadive.net/estonian-machine-learning-meetup/</link>
					<comments>http://blog.datadive.net/estonian-machine-learning-meetup/#comments</comments>
		
		<dc:creator><![CDATA[ando]]></dc:creator>
		<pubDate>Tue, 24 Nov 2015 22:11:27 +0000</pubDate>
				<category><![CDATA[Machine learning]]></category>
		<category><![CDATA[Random forest]]></category>
		<guid isPermaLink="false">http://blog.datadive.net/?p=3671</guid>

					<description><![CDATA[Today, we had the first event of the Estonian Machine Learning Meetup series. I was quite baffled by the pretty massive turnout, with more than a hundred people attending, indicating that such an event series is long overdue. So props &#8230; <a href="http://blog.datadive.net/estonian-machine-learning-meetup/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p>Today, we had the first event of the Estonian <a href="http://www.meetup.com/Machine-Learning-Estonia/">Machine Learning Meetup</a> series. I was quite baffled by the pretty massive turnout, with more than a hundred people attending, indicating that such an event series is long overdue. So props  to <a href="https://twitter.com/ideavoid">Andre Karpištšenko</a> for organizing. I had the honour of being a presenter in the inaugural event, talking about interpreting machine learning models in general, and random forest models in particular. Slides below.</p><p><iframe src="https://www.slideshare.net/slideshow/embed_code/55481963" width="650" height="526" frameborder="0" marginwidth="0" marginheight="0" scrolling="no"></iframe></p>
<div style="padding-top:0px;	
padding-right:0px;
padding-bottom:0px;
padding-left:0px;
margin-top:0px;
margin-right:0px;
margin-bottom:0px;
margin-left:0px;"><a href="https://twitter.com/crossentropy" class="twitter-follow-button" 
						data-show-count="false"
						data-lang="autoLANGauto"
						data-width="250px"
						data-align="left"
						data-show-screen-name="true"
						data-size="medium"
						data-dnt="false">
						Follow @crossentropy </a> </div>
						<script>
						!function(d,s,id) {
						  var js,fjs=d.getElementsByTagName(s)[0];
						  if(!d.getElementById(id)) {
						   js=d.createElement(s);
						   js.id=id;js.src="//platform.twitter.com/widgets.js";
						   fjs.parentNode.insertBefore(js,fjs);
						  }
						}
						(document,"script","twitter-wjs");
						</script><div style="padding-top:0px;	
padding-right:0px;
padding-bottom:0px;
padding-left:0px;
margin-top:0px;
margin-right:0px;
margin-bottom:0px;
margin-left:0px;"><a href="https://twitter.com/share" class="twitter-share-button" 
				        data-url="http://blog.datadive.net/estonian-machine-learning-meetup/" 
				        data-via="crossentropy"
					    data-text="First Estonian Machine Learning Meetup"
					    data-related=""
					    data-count="horizontal"
					    data-hashtags=""
					    data-lang="autoLANGauto"
					    data-counturl=""
					    data-size="medium"
					    data-dnt="false"	> Tweet </a> </div>
		                <script>
					    !function(d,s,id) {
					      var js,fjs=d.getElementsByTagName(s)[0];
					      if(!d.getElementById(id)) {
					       js=d.createElement(s);js.id=id;js.src="https://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);
					      }
					    }
					   (document,"script","twitter-wjs");
					    </script>]]></content:encoded>
					
					<wfw:commentRss>http://blog.datadive.net/estonian-machine-learning-meetup/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
		<item>
		<title>7 tools in every data scientist&#8217;s toolbox</title>
		<link>http://blog.datadive.net/7-tools-in-every-data-scientists-toolbox/</link>
					<comments>http://blog.datadive.net/7-tools-in-every-data-scientists-toolbox/#comments</comments>
		
		<dc:creator><![CDATA[ando]]></dc:creator>
		<pubDate>Thu, 15 Oct 2015 20:14:10 +0000</pubDate>
				<category><![CDATA[Data science]]></category>
		<category><![CDATA[Machine learning]]></category>
		<guid isPermaLink="false">http://blog.datadive.net/?p=3401</guid>

					<description><![CDATA[There is huge number of machine learning methods, statistical tools and data mining techniques available for a given data related task, from self organizing maps to Q-learning, from streaming graph algorithms to gradient boosted trees. Many of these methods, while &#8230; <a href="http://blog.datadive.net/7-tools-in-every-data-scientists-toolbox/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p>There is huge number of machine learning methods, statistical tools and data mining techniques available for a given data related task, from self organizing maps to Q-learning, from streaming graph algorithms to gradient boosted trees. Many of these methods, while powerful in specific domains and problem setups, are arcane and utilized or even understood by few.</p><p>On the other hand, there are some methods and concepts that are widely used and consistently useful (or downright irreplaceable) in a large variety of domains, problem settings and scales. Knowing and understanding them well will give practitioners a solid base to tackle a large subset of common data related problems when complemented by programming, data manipulation and visualization skills.</p><p>Here&#8217;s a list of statistical and machine learning concepts that are in every data scientist&#8217;s toolbox.</p>
<h2>Tree based methods</h2><p>Some of the most universally useful methods in data science are decision tree based: decision trees, random forests and gradient boosted trees. Decision trees as base learners have a lot of very useful characteristics most of which are inherited by derived methods such as random forests. They&#8217;re</p>
<ul>
<li>Robust to outliers</li>
<li>Can deal with both continuous and categorical data</li>
<li>Can learn non-linear relationships in the data well</li>
<li>Require very little input preparation (see previous three points)</li>
<li>Easy to interpret, via plotting the tree or extracting the tree rules. This can be very useful to give you the &#8220;feel&#8221; of the data</li>
</ul><p>The main negative of decision trees is that they are a high variance method and tend to overfit, i.e. do not generalize well. This is where using decision trees as base learners for ensemble methods comes in.</p><p><a href="https://en.wikipedia.org/wiki/Random_forest">Random forests</a> are simply sets of decision trees, trained using bootstrapped data and random feature selection. This fixes the high variance problem of decision trees, making random forests one of the most versatile and widely used machine learning methods. They have high accuracy and low variance all the while inheriting most benefits from decision trees. When compared to many other more sophisticated models, they require very little tuning. In general, it is pretty hard to train a really bad performing random forest models. Even with out of the box hyperparameters, random forest models perform quite well in general. Finally, they are trivially parallelizable in both training and testing phase.</p><p>One drawback that is often highlighted about random forests is that they are a black box, i.e. that there is no way to interpret the model or the resulting predictions. Fortunately, this is no really true due to recent developments in making random forests more interpretable. There are methods for <a href="http://blog.datadive.net/interpreting-random-forests/">decomposing random forest</a> predictions into <a href="http://blog.datadive.net/random-forest-interpretation-with-scikit-learn/">feature contributions</a>, selecting compact rule sets and summarizing the extracted tree rules (<a href="https://cran.r-project.org/web/packages/inTrees/index.html">inTrees</a> package in R).</p><p>There are excellent implementations for tree based methods in most mainstream languages, with python (<a>scikit learn</a>) and R(<a href="https://cran.r-project.org/web/packages/randomForest/index.html">randomForest</a>, <a href="https://cran.r-project.org/web/packages/party/index.html">party</a>) probably being the most accessible.</p>
<h2>Linear (regularized) models</h2><p>Linear models (such as linear and logistic regression) are typically one of the first models to be taught in ML courses and covered in textbooks, and for good reason. They are very powerful for their relative simplicity. They are fast to train and used especially often when good interpretability is of essence. The general form: \(y = a +b_1X_1+ \ldots +b_nX_n\) means that it&#8217;s easy to see the relative importance and contribution of each feature and sanity check the model.</p><p>A drawback of linear models is that unlike tree based methods, they are much more sensitive to outliers (requiring input sanitation), require explicit handling of categorical features (via one-hot encoding) and expect a linear relation between input and the response variable.<br />
It is possible to overcome the latter via basis expansion: i.e. by including transformations of the input features by logarithmic, polynomial or some other transformation, depending on the data at hand. This is usually most efficiently done when combining with with regularization (Lasso and Ridge regression). These are very powerful techniques for feature selection and for preventing over fitting, allowing to filter out irrelevant features (and irrelevant transforms in case of basis expansion).</p><p>Another great aspect of linear models is that very effective online (streaming) algorithms exist, making training models even on massive datasets easily accessible, by requiring constant memory.</p><p>There are an excellent set of linear model and regularization libraries in Python (<a href="http://scikit-learn.org/stable/modules/linear_model.html">scikit learn</a>, <a href="http://statsmodels.sourceforge.net/">statsmodel</a>) and R(<a href="https://stat.ethz.ch/R-manual/R-patched/library/stats/html/lm.html">lm</a>). For large datasets, there are online learning tools available such as <a href="https://github.com/JohnLangford/vowpal_wabbit">vowpal wabbit.</a></p>
<h2>Quantifying confidence: hypothesis testing, confidence- and prediction intervals</h2><p>Being able to quantify the certainty in the estimates and predictions that are produced based on data is often one of the most crucial aspects in a data scientist&#8217;s work. If you don&#8217;t take variance into account in your estimates, it becomes easy to come to arbitrary conclusions. Thus, understanding and using hypothesis testing is something every data scientist utilizes.</p><p>There are multiple ways to do hypothesis testing. Statistics courses spend a lot of time on statistical tests (such as <a href="https://en.wikipedia.org/wiki/Student's_t-test">t</a>-, <a href="&quot;https://en.wikipedia.org/wiki/Z-test">z</a>&#8211; and <a href="https://en.wikipedia.org/wiki/F-test">F-test</a> ) and their closed form solution. In practice, confidence intervals are often better alternatives for hypothesis testing, by providing more information about the estimates, quantifying both their location and precision. In Bayesian world, credible intervals offer a similar benefit.</p><p>While there has been a <a href="http://digitalcommons.unl.edu/cgi/viewcontent.cgi?article=1225&context=usgsnpwrc">lot of</a> <a href="http://www.nature.com/news/psychology-journal-bans-p-values-1.17001">controversy</a> around using p-values (due to them having been misused and abused a lot in some scientific circles), they remain a valuable tool when applied correctly. For example for categorical data, <a href="https://en.wikipedia.org/wiki/Chi-squared_test">chi-squared test</a> can be an excellent tool for understanding if the effect you see in your bar charts is real.</p><p>Finally, it is important to understand what hypothesis testing is really about. It&#8217;s often viewed as some arcane formula, which tells you the right answer by magically producing a p-value that can then be compared to 0.05. In the end, every test is the same: trying to answer the question whether the observed effect is real or not. And while having a &#8220;test&#8221; as a closed closed form solution for calculating the test score and p-values is great, you can achieve the same thing &#8212; an answer to the question: is this effect real? &#8212; via simulation. In fact it can be better to use simulation if you&#8217;re uncertain whether all the assumptions that need to hold for the analytical test actually do. There is a great writeup on this topic: <a href="http://allendowney.blogspot.com.ee/2011/05/there-is-only-one-test.html">There is only on test</a>.</p><p>Speaking of simulation and bootstrapping&#8230;</p>
<h2>Resampling methods: bootstrapping, cross validation, Monte Carlo</h2><p>Resampling methods are a powerful set of tools that employ resampling to produce new hypothetical sample sets as if they were sampled from the underlying population. They are excellent when parametric approaches are difficult to use or just don&#8217;t apply. As such they are often crucial for many data analysis and machine learning tasks.</p><p><a href="https://en.wikipedia.org/wiki/Bootstrapping_%28statistics%29">Bootstrapping</a>, or sampling with replacement allows obtaining measures of confidence such as variance or confidence intervals to sample estimates (such as mean or median). The estimates can be obtained by sampling with replacement from the observed dataset, measuring the estimate we&#8217;re interested in (for example the mean) and then repeating the process until we have enough readings to compute confidence intervals, variance or any other property of the estimate we want (for example via percentile bootstrap).</p><p>Depending on the underlying distribution (for example skewed vs symmetric), the estimations can be biased. There are ways to mitigate that, for example via bias corrected and accelerated bootstrap (good overview <a href="http://www.tau.ac.il/~saharon/Boot/10.1.1.133.8405.pdf">here</a>). R&#8217;s <a href="https://cran.r-project.org/web/packages/boot/index.html">boot</a> package has multiple different bootstrap methods available. But often, going beyond percentile bootstrap could be overkill: we are often interested in the order of magnitude of the measure of confidence anyway, not necessarily an exact value.</p><p>Bootstrapping also has its uses in machine learning, for example for creating ensembles of models (such as random forests).</p><p><a href="https://en.wikipedia.org/wiki/Cross-validation_%28statistics%29">Cross-validation</a> is another resampling method, used to make sure that the results we see on our sample set would actually apply to an independent dataset. In other words, to make sure we are not overfitting our models. This is a must in machine learning tasks where prediction is involved. Just as with bootstrapping, the idea is simple: randomly partition the dataset into two &#8212; training set and test set &#8212; measure the performance of the model trained on the train set on the test set, and then repeat the experiment after spitting the data randomly again. After enough experiments, averaging over the result gives a good estimate of how the model would perform on a new dataset sampled from the underlying population. There are a lot of methods for that in R and an excellent set of libraries in <a href="http://scikit-learn.org/stable/modules/cross_validation.html">scikit-learn</a></p><p>Both approaches mentioned in the section are similar in spirit to the wide spectrum of Monte Carlo methods, employed in physics since the 40s.</p>
<h2>Finding hidden groups: (centroid-based) clustering</h2><p>Clustering is one of the most commonly used approaches in unsupervised learning, used to find hidden groups or partitionings in the the data. There are a large number of different approaches to this: <a href="https://en.wikipedia.org/wiki/Hierarchical_clustering">hierarchical</a>, <a href="https://en.wikipedia.org/wiki/DBSCAN">density</a>-, <a href="https://en.wikipedia.org/wiki/Cluster_analysis#Distribution-based_clustering">distribution</a> and <a href="https://en.wikipedia.org/wiki/K-means_clustering">centroids-based clustering</a>; there is a nice visual summary of many of the methods in scikit-learn&#8217;s <a href="http://scikit-learn.org/stable/modules/clustering.html">clustering page</a>.</p><p>Clustering methods, being easy to apply and shown early on in most introductory textbooks, enjoy a wide popularity. What seems to happen often though is that beginning practitioners turn to them to obtain a set of clusters&#8230; and stop there. More often than not there isn&#8217;t a lot of value in only doing the clustering and leaving it at that. Usually, clustering is more useful as a tool when chained together with other data analysis methods. For example, it can be very effective as a tool for dimensionality reduction, for further analyzing how different groups of objects behave. A good example for this is combining clustering with time dimension. It can be difficult to track the evolution of the dataset under study when you have thousands of features. Reducing it to a smaller set of clusters and observing how the cluster distributions change can on the other hand reveal interesting patterns in the data not visible otherwise.</p><p>Scikit-learn includes an excellent set of <a href="http://scikit-learn.org/stable/modules/clustering.html">clustering methods</a>, likewise for for R&#8217;s <a href="http://cran.cnr.berkeley.edu/web/views/Cluster.html">cluster</a> package.</p>
<h2>Feature selection</h2><p>Feature selection is usually not treated as a separate topic in ML or data science literature, rather it is viewed as a a loose set of techniques that are mostly natural side effects of other, more fundamental methods such as lasso, random forest, etc. While this is technically true, I&#8217;ve found that having a unified understanding of feature selection to be greatly beneficial in many data science and machine learning tasks. Understanding feature selection methods well leads to better performing models, better understanding of the data and better intuition about the algorithms underlying many machine learning models.</p><p>There are in general two reasons why feature selection is used:</p>
<ol>
<li> Reducing the number of features, to reduce overfitting and improve the generalization of models.</li>
<li> To gain a better understanding of the features and their relationship to the response variables.</li>
</ol><p>An important factor to take into account is that these two goals are often at odds with each other and thus require different approaches: depending on the data at hand a feature selection method that is good for goal (1) isn’t necessarily good for goal (2) and vice versa. For the previous, model based methods (for example <a href="http://blog.datadive.net/selecting-good-features-part-ii-linear-models-and-regularization/">linear model based</a> and <a href="http://blog.datadive.net/selecting-good-features-part-iii-random-forests/">random forest based</a>) are usually better, while for the latter, <a href="http://blog.datadive.net/selecting-good-features-part-i-univariate-selection/">univariate feature selection</a> methods can be the most useful, since they do not underestimate feature&#8217;s importance due to correlation with other features, like model based feature selection methods tend to do.</p>
<h2>Measuring performance: metrics, loss functions, measures of relevance</h2><p>The questions of how good is an estimator is the first one to come up once a model is built. It is easy to apply a measure, but it can also be easy to interpret it incorrectly. For example, accuracy of 95% in a classification task can sound wonderful, until you realize that in 95% of the cases, your data has a particular response, so your classifier is simply predicting this constant value. This doesn&#8217;t mean that accuracy is a bad metric per se, simply that one needs to be careful how and where it is applied. Thus, it is crucial to understand the metric you are applying in the context to the data at hand.<br />
For classification <a href="&quot;https://en.wikipedia.org/wiki/Receiver_operating_characteristic">ROC curve</a> and <a href="https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_curve">AUC</a> are excellent measures for classifier performance. They are not necessarily intuitive at first sight, so it&#8217;s worth taking the time to understand how the numbers are calculated. Similarly, <a href="https://en.wikipedia.org/wiki/Precision_and_recall">precision and recall</a>, <a href="https://en.wikipedia.org/wiki/Confusion_matrix">confusion matrix</a> and <a href="https://en.wikipedia.org/wiki/F1_score">F1</a> are widely used for evaluating classification. Typical minimization targets in ML classification tasks are logistic loss and hinge loss.</p><p>For regression tasks, <a href="https://en.wikipedia.org/wiki/Coefficient_of_determination">R^2</a> is an excellent measure that shows how good your estimators are in terms of a trivial estimator that predicts the mean. Additionally, it has a strong relation to correlation coefficient, namely R^2 is the square of the correlation coefficient between outcomes and predicted values. Typical minimization target in ML tasks are squared error and absolute error.</p><p>From data science point of view, interpretability of the measures can be important, in which case they can roughly be divided into 3 groups. Firstly, measures that lie in a given range (e. g. AUC lying between 0.5 and 1, R^2 between 0 and 1) are excellent in the sense that their numbers are comparable when the underlying data or responses change. Secondly, measures such as accuracy or mean absolute error are good at returning values that are easy to interpret in the context of concrete data, as they lie in the same scale as the underlying data and are therefor easy for humans to evaluate: are we off by 1%, 10% or 50% on average. Finally, measures such as squared error or log loss can be useful as optimization targets, but in general not as great for a quick interpretation by humans.</p><p>Scikit-learn provides a nice set of metrics and scoring functions in its <a href="http://scikit-learn.org/stable/modules/classes.html">metrics</a> module.</p>
<h2>Summary</h2><p>The list above only scratches the surface of modern ML and statistical tools. There are many, many powerful and widely used methods left untouched in this post: deep learning, Bayesian methods, SVMs, recommender systems, graph algorithms etc, etc. Yet, i would say that mastering the above will give a practioner a very solid baseline to tackle a very wide area of data related tasks, and furthermore will make stepping into other, more sophisticated methods much easier.</p>
<div style="padding-top:0px;	
padding-right:0px;
padding-bottom:0px;
padding-left:0px;
margin-top:0px;
margin-right:0px;
margin-bottom:0px;
margin-left:0px;"><a href="https://twitter.com/crossentropy" class="twitter-follow-button" 
						data-show-count="false"
						data-lang="autoLANGauto"
						data-width="250px"
						data-align="left"
						data-show-screen-name="true"
						data-size="medium"
						data-dnt="false">
						Follow @crossentropy </a> </div>
						<script>
						!function(d,s,id) {
						  var js,fjs=d.getElementsByTagName(s)[0];
						  if(!d.getElementById(id)) {
						   js=d.createElement(s);
						   js.id=id;js.src="//platform.twitter.com/widgets.js";
						   fjs.parentNode.insertBefore(js,fjs);
						  }
						}
						(document,"script","twitter-wjs");
						</script><div style="padding-top:0px;	
padding-right:0px;
padding-bottom:0px;
padding-left:0px;
margin-top:0px;
margin-right:0px;
margin-bottom:0px;
margin-left:0px;"><a href="https://twitter.com/share" class="twitter-share-button" 
				        data-url="http://blog.datadive.net/7-tools-in-every-data-scientists-toolbox/" 
				        data-via="crossentropy"
					    data-text="7 tools in every data scientist's toolbox"
					    data-related=""
					    data-count="horizontal"
					    data-hashtags=""
					    data-lang="autoLANGauto"
					    data-counturl=""
					    data-size="medium"
					    data-dnt="false"	> Tweet </a> </div>
		                <script>
					    !function(d,s,id) {
					      var js,fjs=d.getElementsByTagName(s)[0];
					      if(!d.getElementById(id)) {
					       js=d.createElement(s);js.id=id;js.src="https://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);
					      }
					    }
					   (document,"script","twitter-wjs");
					    </script>]]></content:encoded>
					
					<wfw:commentRss>http://blog.datadive.net/7-tools-in-every-data-scientists-toolbox/feed/</wfw:commentRss>
			<slash:comments>11</slash:comments>
		
		
			</item>
		<item>
		<title>Random forest interpretation with scikit-learn</title>
		<link>http://blog.datadive.net/random-forest-interpretation-with-scikit-learn/</link>
					<comments>http://blog.datadive.net/random-forest-interpretation-with-scikit-learn/#comments</comments>
		
		<dc:creator><![CDATA[ando]]></dc:creator>
		<pubDate>Wed, 12 Aug 2015 20:48:38 +0000</pubDate>
				<category><![CDATA[Machine learning]]></category>
		<category><![CDATA[Random forest]]></category>
		<guid isPermaLink="false">http://blog.datadive.net/?p=3082</guid>

					<description><![CDATA[In one of my previous posts I discussed how random forests can be turned into a &#8220;white box&#8221;, such that each prediction is decomposed into a sum of contributions from each feature i.e. .I&#8217;ve a had quite a few requests &#8230; <a href="http://blog.datadive.net/random-forest-interpretation-with-scikit-learn/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p>In one of my <a href="/interpreting-random-forests/">previous posts</a> I discussed how random forests can be turned into a &#8220;white box&#8221;, such that each prediction is decomposed into a sum of contributions from each feature i.e.  \(prediction = bias + feature_1 contribution + &#8230; + feature_n contribution\).</p><p>I&#8217;ve a had quite a few requests for code to do this. Unfortunately, most random forest libraries (including <a href="http://scikit-learn.org/">scikit-learn</a>) don&#8217;t expose tree paths of predictions. The implementation for sklearn required a hacky patch for exposing the paths. Fortunately, since 0.17.dev, scikit-learn has two additions in the API that make this relatively straightforward: obtaining leaf node_ids for predictions, and storing all intermediate values in all nodes in decision trees, not only leaf nodes. Combining these, it is possible to extract the prediction paths for each individual prediction and decompose the predictions via inspecting the paths.</p><p>Without further ado, the code is available at <a href="https://github.com/andosa/treeinterpreter">github</a>, and also via <code>pip install treeinterpreter</code></p><p><em>Note: this requires scikit-learn 0.17, which is still in development. You can check how to install it at http://scikit-learn.org/stable/install.html#install-bleeding-edge</em></p>
<h2>Decomposing random forest predictions with treeinterpreter</h2><p>Let&#8217;s take a sample dataset, train a random forest model, predict some values on the test set and then decompose the predictions.</p>
<pre class="brush: python; collapse: false; title: ; wrap-lines: false; notranslate">
from treeinterpreter import treeinterpreter as ti
from sklearn.tree import DecisionTreeRegressor
from sklearn.ensemble import RandomForestRegressor
import numpy as np

from sklearn.datasets import load_boston
boston = load_boston()
rf = RandomForestRegressor()
rf.fit(boston.data[:300], boston.target[:300])
</pre><p>Lets pick two arbitrary data points that yield different price estimates from the model.</p>
<pre class="brush: python; collapse: false; title: ; wrap-lines: false; notranslate">
instances = boston.data[[300, 309]]
print &quot;Instance 0 prediction:&quot;, rf.predict(instances[0])
print &quot;Instance 1 prediction:&quot;, rf.predict(instances[1])
</pre>
<blockquote><p>
<code><br />
Instance 0 prediction: [ 30.76]<br />
Instance 1 prediction: [ 22.41]<br />
</code>
</p></blockquote><p>Predictions that the random forest model made for the two data points are quite different. But why? We can now decompose the predictions into the bias term (which is just the trainset mean) and individual feature contributions, so we see which features contributed to the difference and by how much.</p><p>We can simply call the treeinterpreter <code>predict </code> method with the model and the data.</p>
<pre class="brush: python; collapse: false; title: ; wrap-lines: false; notranslate">
prediction, bias, contributions = ti.predict(rf, instances)
</pre><p>Printint out the results:</p>
<pre class="brush: python; collapse: false; title: ; wrap-lines: false; notranslate">
for i in range(len(instances)):
    print &quot;Instance&quot;, i
    print &quot;Bias (trainset mean)&quot;, biases[i]
    print &quot;Feature contributions:&quot;
    for c, feature in sorted(zip(contributions[i], 
                                 boston.feature_names), 
                             key=lambda x: -abs(x[0])):
        print feature, round(c, 2)
    print &quot;-&quot;*20  
</pre>
<blockquote><p><code><br />
Instance 0<br />
Bias (trainset mean) 25.2849333333<br />
Feature contributions:<br />
RM 2.73<br />
LSTAT 1.71<br />
PTRATIO 1.27<br />
ZN 1.04<br />
DIS -0.7<br />
B -0.39<br />
TAX -0.19<br />
CRIM -0.13<br />
RAD 0.11<br />
INDUS 0.06<br />
AGE -0.02<br />
NOX -0.01<br />
CHAS 0.0<br />
--------------------<br />
Instance 1<br />
Bias (trainset mean) 25.2849333333<br />
Feature contributions:<br />
RM -4.88<br />
LSTAT 2.38<br />
DIS 0.32<br />
AGE -0.28<br />
TAX -0.23<br />
CRIM 0.16<br />
PTRATIO 0.15<br />
B -0.15<br />
INDUS -0.14<br />
CHAS -0.1<br />
ZN -0.05<br />
NOX -0.05<br />
RAD -0.02<br />
</code></p></blockquote><p>The feature contributions are sorted by their absolute impact. We can see that in the first instance where the prediction was high, most of the positive contributions came from RM, LSTAT and PTRATIO feaures. On the second instance the predicted value is much lower, since RM feature actually has a very large negative impact that is not offset by the positive impact of other features, thus taking the prediction below the dataset mean.</p><p>But is the decomposition actually correct? This is easy to check: bias and contributions need to sum up to the predicted value:</p>
<pre class="brush: python; collapse: false; title: ; wrap-lines: false; notranslate">
print prediction
print biases + np.sum(contributions, axis=1)
</pre>
<blockquote><p><code><br />
[ 30.76  22.41]<br />
[ 30.76  22.41]<br />
</code></p></blockquote><p>Note that when summing up the contributions, we are dealing with floating point numbers so the values can slightly different due to rounding errors</p>
<h2> Comparing too datasets</h2><p>One use case where this approach can be very useful is when comparing two datasets. For example</p>
<ul>
<li>Understanding the exact reasons why estimated values are different on two datasets, for example what contributes to estimated house prices being different in two neighborhoods.</li>
<li>Debugging models and/or data, for example understanding why average predicted values on newer data do not match the results seen on older data.</li>
</ul><p>For this example, let&#8217;s split the remaining housing price data into two test datasets and compute the average estimated prices for them.</p>
<pre class="brush: python; collapse: false; title: ; wrap-lines: false; notranslate">
ds1 = boston.data[300:400]
ds2 = boston.data[400:]

print np.mean(rf.predict(ds1))
print np.mean(rf.predict(ds2))
</pre>
<blockquote><p><code><br />
22.1912<br />
18.4773584906<br />
</code></p></blockquote><p>We can see that the average predicted prices for the houses in the two datasets are quite different. We can now trivially break down the contributors to this difference: which features contribute to this different and by how much.</p>
<pre class="brush: python; collapse: false; title: ; wrap-lines: false; notranslate">
prediction1, bias1, contributions1 = ti.predict(rf, ds1)
prediction2, bias2, contributions2 = ti.predict(rf, ds2)
</pre><p>We can now calculate the mean contribution of each feature to the difference.</p>
<pre class="brush: python; collapse: false; title: ; wrap-lines: false; notranslate">
totalc1 = np.mean(contributions1, axis=0) 
totalc2 = np.mean(contributions2, axis=0) 
</pre><p>Since biases are equal for both datasets (because the training data for the model was the same), the difference between the average predicted values has to come only from feature contributions. In other words, the sum of the feature contribution differences should be equal to the difference in average prediction, which we can trivially check to be the case</p>
<pre class="brush: python; collapse: false; title: ; wrap-lines: false; notranslate">
print np.sum(totalc1 - totalc2)
print np.mean(prediction1) - np.mean(prediction2)
</pre>
<blockquote><p><code><br />
3.71384150943<br />
3.71384150943<br />
</code></p></blockquote><p>Finally, we can just print out the differences of the contributions in the two datasets. The sum of these is exactly the difference between the average predictions.</p>
<pre class="brush: python; collapse: false; title: ; wrap-lines: false; notranslate">
for c, feature in sorted(zip(totalc1 - totalc2, 
                             boston.feature_names), reverse=True):
    print feature, round(c, 2)
</pre>
<blockquote><p><code><br />
LSTAT 2.8<br />
CRIM 0.5<br />
RM 0.5<br />
PTRATIO 0.09<br />
AGE 0.08<br />
NOX 0.03<br />
B 0.01<br />
CHAS -0.01<br />
ZN -0.02<br />
RAD -0.03<br />
INDUS -0.03<br />
TAX -0.08<br />
DIS -0.14<br />
</code></p></blockquote>
<h2>Classification trees and forests</h2><p>Exactly the same method can be used for classification trees, where features contribute to the estimated probability of a given class.<br />
We can see this on the sample iris dataset.</p>
<pre class="brush: python; collapse: false; title: ; wrap-lines: false; notranslate">
from sklearn.ensemble import RandomForestClassifier
from sklearn.datasets import load_iris
iris = load_iris()

rf = RandomForestClassifier(max_depth = 4)
idx = range(len(iris.target))
np.random.shuffle(idx)

rf.fit(iris.data[idx][:100], iris.target[idx][:100])
</pre><p>Let&#8217;s predict now for a single instance.</p>
<pre class="brush: python; collapse: false; title: ; wrap-lines: false; notranslate">
instance = iris.data[idx][100:101]
print rf.predict_proba(instance)
</pre><p>Breakdown of feature contributions:</p>
<pre class="brush: python; collapse: false; title: ; wrap-lines: false; notranslate">
prediction, bias, contributions = ti.predict(rf, instance)
print &quot;Prediction&quot;, prediction
print &quot;Bias (trainset prior)&quot;, bias
print &quot;Feature contributions:&quot;
for c, feature in zip(contributions[0], 
                             iris.feature_names):
    print feature, c
</pre>
<blockquote><p><code><br />
Prediction [[ 0.   0.9  0.1]]<br />
Bias (trainset prior) [[ 0.36   0.262  0.378]]<br />
Feature contributions:<br />
sepal length (cm) [-0.1228614   0.07971035  0.04315104]<br />
sepal width (cm) [ 0.         -0.01352012  0.01352012]<br />
petal length (cm) [-0.11716058  0.24709886 -0.12993828]<br />
petal width (cm) [-0.11997802  0.32471091 -0.20473289]<br />
</code></p></blockquote><p>We can see that the strongest contributors to predicting the second class were petal length and width, which had the larges impact on updating the prior.</p>
<h2>Summary</h2><p>Making random forest predictions interpretable is actually pretty straightforward, and leading to similar level of interpretability as linear models. With <a href="https://github.com/andosa/treeinterpreter">treeinterpreter</a> (<code>pip install treeinterpreter</code>), this can be done with just a couple of lines of code.</p>
<div style="padding-top:0px;	
padding-right:0px;
padding-bottom:0px;
padding-left:0px;
margin-top:0px;
margin-right:0px;
margin-bottom:0px;
margin-left:0px;"><a href="https://twitter.com/crossentropy" class="twitter-follow-button" 
						data-show-count="false"
						data-lang="autoLANGauto"
						data-width="250px"
						data-align="left"
						data-show-screen-name="true"
						data-size="medium"
						data-dnt="false">
						Follow @crossentropy </a> </div>
						<script>
						!function(d,s,id) {
						  var js,fjs=d.getElementsByTagName(s)[0];
						  if(!d.getElementById(id)) {
						   js=d.createElement(s);
						   js.id=id;js.src="//platform.twitter.com/widgets.js";
						   fjs.parentNode.insertBefore(js,fjs);
						  }
						}
						(document,"script","twitter-wjs");
						</script><div style="padding-top:0px;	
padding-right:0px;
padding-bottom:0px;
padding-left:0px;
margin-top:0px;
margin-right:0px;
margin-bottom:0px;
margin-left:0px;"><a href="https://twitter.com/share" class="twitter-share-button" 
				        data-url="http://blog.datadive.net/random-forest-interpretation-with-scikit-learn/" 
				        data-via="crossentropy"
					    data-text="Random forest interpretation with scikit-learn"
					    data-related=""
					    data-count="horizontal"
					    data-hashtags=""
					    data-lang="autoLANGauto"
					    data-counturl=""
					    data-size="medium"
					    data-dnt="false"	> Tweet </a> </div>
		                <script>
					    !function(d,s,id) {
					      var js,fjs=d.getElementsByTagName(s)[0];
					      if(!d.getElementById(id)) {
					       js=d.createElement(s);js.id=id;js.src="https://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);
					      }
					    }
					   (document,"script","twitter-wjs");
					    </script>]]></content:encoded>
					
					<wfw:commentRss>http://blog.datadive.net/random-forest-interpretation-with-scikit-learn/feed/</wfw:commentRss>
			<slash:comments>50</slash:comments>
		
		
			</item>
		<item>
		<title>Prediction intervals for Random Forests</title>
		<link>http://blog.datadive.net/prediction-intervals-for-random-forests/</link>
					<comments>http://blog.datadive.net/prediction-intervals-for-random-forests/#comments</comments>
		
		<dc:creator><![CDATA[ando]]></dc:creator>
		<pubDate>Tue, 02 Jun 2015 13:25:41 +0000</pubDate>
				<category><![CDATA[Confidence intervals]]></category>
		<category><![CDATA[Random forest]]></category>
		<guid isPermaLink="false">http://blog.datadive.net/?p=2871</guid>

					<description><![CDATA[An aspect that is important but often overlooked in applied machine learning is intervals for predictions, be it confidence or prediction intervals. For classification tasks, beginning practitioners quite often conflate probability with confidence: probability of 0.5 is taken to mean &#8230; <a href="http://blog.datadive.net/prediction-intervals-for-random-forests/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p>An aspect that is important but often overlooked in applied machine learning is intervals for predictions, be it confidence or prediction intervals. For classification tasks, beginning practitioners quite often conflate probability with confidence: probability of 0.5 is taken to mean that we are uncertain about the prediction, while a prediction of 1.0 means we are absolutely certain in the outcome. But there are two concepts being mixed up here. A prediction of 0.5 could mean that we have learned very little about a given instance, due to observing no or only a few data points about it. Or it could be that we have a lot of data, and the response is fundamentally uncertain, like flipping a coin.</p><p>For regression, a prediction returning a single value (typically meant to minimize the squared error) likewise does not relay any information about the underlying distribution of the data or the range of response values we might later see in the test data.  </p><p>Looking at the following plots, both the left and right plot represent similar, learned models for predicting Y from X. But while the model predictions would be similar, confidence in them would be quite different for obvious reasons: we have much less and more spread out data in the second case.</p><p><a href="http://blog.datadive.net/wp-content/uploads/2015/05/scatters.png"><img loading="lazy" src="http://blog.datadive.net/wp-content/uploads/2015/05/scatters.png" alt="scatters" width="720" height="360" class="alignnone size-full wp-image-3061" srcset="http://blog.datadive.net/wp-content/uploads/2015/05/scatters.png 720w, http://blog.datadive.net/wp-content/uploads/2015/05/scatters-300x150.png 300w" sizes="(max-width: 720px) 100vw, 720px" /></a></p><p>A useful concept for quantifying the latter issue is  <strong>prediction intervals</strong>.  A prediction interval is an estimate of an interval into which the future observations will fall with a given probability. In other words, it can quantify our confidence or certainty in the prediction. Unlike confidence intervals from classical statistics, which are about a parameter of population (such as the mean), prediction intervals are about individual predictions. </p><p>For linear regression, calculating the predictions intervals is straightforward (under certain assumptions like the normal distribution of the residuals) and included in most libraries, such as R&#8217;s <a href =" https://stat.ethz.ch/R-manual/R-patched/library/stats/html/predict.lm.html"> predict method</a> for linear models.</p><p>But how to calculate the intervals for tree based methods such as random forests? </p>
<h3>Quantile regression forests</h3><p>A general method for finding confidence intervals for decision tree based methods is <a href="http://www.jmlr.org/papers/volume7/meinshausen06a/meinshausen06a.pdf">Quantile Regression Forests</a>.<br />
The idea behind quantile regression forests is simple: instead of recording the mean value of response variables in each tree leaf in the forest, record all observed responses in the leaf. The prediction can then return not just the mean of the response variables, but the full conditional distribution \(P(Y \leq y \mid X = x)\) of response values for every \(x\). Using the distribution, it is trivial to create prediction intervals for new instances simply by using the appropriate percentiles of the distribution. For example, the 95% prediction intervals would be the range between 2.5 and 97.5 percentiles of the distribution of the response variables in the leaves. And of course one could calculate other estimates on the distribution, such as median, standard deviation etc. Unfortunately, quantile regression forests do not enjoy too wild of a popularity. While it is available in R&#8217;s <a href="http://cran.r-project.org/web/packages/quantreg/index.html">quantreg </a>packages, most machine learning packages do not seem to include the method.</p>
<h3>Random forests as  quantile regression forests</h3><p>But here&#8217;s a nice thing: one can use a random forest as quantile regression forest simply by expanding the tree fully so that each leaf has exactly one value. (And expanding the trees fully is in fact what Breiman suggested in his original random forest paper.) Then a prediction trivially returns individual response variables from which the distribution can be built if the forest is large enough. One caveat is that expanding the tree fully can overfit: if that does happen, the intervals will be useless, just as the predictions. The nice thing is that just like accuracy and precision, the intervals can be cross-validated.</p>
<h3>Example</h3><p>Let&#8217;s look at the well-known Boston housing dataset and try to create prediction intervals using vanilla random forest from <a href="http://scikit-learn.org/">scikit-learn</a>:</p>
<pre class="brush: python; collapse: false; title: ; wrap-lines: false; notranslate">
from sklearn.ensemble import RandomForestRegressor
import numpy as np
from sklearn.datasets import load_boston

boston = load_boston()
X = boston[&quot;data&quot;]
Y = boston[&quot;target&quot;]
size = len(boston[&quot;data&quot;])
</pre><p>We&#8217;ll use 400 samples for training, leaving 106 samples for test. The size of the forest should be relatively large, so let&#8217;s use 1000 trees.</p>
<pre class="brush: python; collapse: false; title: ; wrap-lines: false; notranslate">
trainsize = 400
idx = range(size)
#shuffle the data
np.random.shuffle(idx)
rf = RandomForestRegressor(n_estimators=1000, min_samples_leaf=1)
rf.fit(X[idx[:trainsize]], Y[idx[:trainsize]])
</pre><p>We can now define a function to calculate prediction intervals for every prediction:</p>
<pre class="brush: python; collapse: false; title: ; wrap-lines: false; notranslate">
def pred_ints(model, X, percentile=95):
    err_down = []
    err_up = []
    for x in range(len(X)):
        preds = []
        for pred in model.estimators_:
            preds.append(pred.predict(X[x])[0])
        err_down.append(np.percentile(preds, (100 - percentile) / 2. ))
        err_up.append(np.percentile(preds, 100 - (100 - percentile) / 2.))
    return err_down, err_up
</pre><p>Let&#8217;s compute 90% prediction intervals and test how many observations in the test set fall into the interval.</p>
<pre class="brush: python; collapse: false; title: ; wrap-lines: false; notranslate">
err_down, err_up = pred_ints(rf, X[idx[trainsize:]], percentile=90)

truth = Y[idx[trainsize:]]
correct = 0.
for i, val in enumerate(truth):
    if err_down[i] &lt;= val &lt;= err_up[i]:
        correct += 1
print correct/len(truth)
</pre>
<blockquote><p><code><br />
0.905660377358<br />
</code></p></blockquote><p>This is pretty close to what we expected: 90.6% of observations fell into the prediction intervals. Plotting the true values and predictions together with error bars visualizes this nicely.</p><p><a href="http://blog.datadive.net/wp-content/uploads/2015/05/90interval.png"><img loading="lazy" class="alignnone size-full wp-image-2911" src="http://blog.datadive.net/wp-content/uploads/2015/05/90interval.png" alt="90interval" width="753" height="397" /></a></p><p>If we set prediction interval to be 50% for the same model and test data, we see 51% of predictions fall into the interval, again very close to the expected value . Plotting the error bars again, we see that they are significantly smaller:</p><p><a href="http://blog.datadive.net/wp-content/uploads/2015/05/50interval.png"><img loading="lazy" class="alignnone size-full wp-image-2901" src="http://blog.datadive.net/wp-content/uploads/2015/05/50interval.png" alt="50interval" width="736" height="395" /></a></p><p>What can also be observed on the plot that on average, predictions that are more accurate have smaller prediction intervals since these are usually &#8220;easier&#8221; predictions to make. The correlation between absolute prediction error and prediction interval size is ~0.6 for this dataset.</p><p>And again, just as one can and should use cross-validation for estimating the accuracy of the model, one should also cross-validate the intervals to make sure that they give unbiased results on the particular dataset at hand. And just like one can do <a href="http://scikit-learn.org/stable/auto_examples/calibration/plot_calibration.html">probability calibration</a>, interval calbiration can also be done.</p>
<h2>Caveats</h2><p>There are situations when the tree is not expanded fully, such that there is more than one data point per leaf. This can happen because either<br />
a) a node is already pure, so splitting further makes no sense, or<br />
b) the node is not pure, but the feature vector is exactly the same for all responses, so there isn’t anything to do a further split on.</p><p>In case of a), we know the response and node size, so we still know the distribution perfectly and can use it for calculating the intervals. If case b) happens, we are in trouble, since we don&#8217;t know the distribution of responses in the non-expanded leaf. Luckily, the latter very rarely happens with real world datasets and is easy to check for. </p>
<h1>Conclusions</h1><p>Utilizing prediction intervals can be very beneficial in many machine learning and data science tasks, since they can tell a lot about the underlying data that we are learning about and provide a simple way to sanity check our results. While they seem to enjoy relatively widespread use for linear models due to the ease of access with these methods, they tend to be underutilized for tree-based methods such as random forests. But actually they are relatively straightforward to use (keeping the caveats in mind) by utilizing the fact that a random forest can return a conditional distribution instead of just the conditional mean. In fact, estimating the intervals this way can be more robust than prediction intervals for linear methods, since it does not rely on the assumption of normally distributed residuals.</p>
<div style="padding-top:0px;	
padding-right:0px;
padding-bottom:0px;
padding-left:0px;
margin-top:0px;
margin-right:0px;
margin-bottom:0px;
margin-left:0px;"><a href="https://twitter.com/crossentropy" class="twitter-follow-button" 
						data-show-count="false"
						data-lang="autoLANGauto"
						data-width="250px"
						data-align="left"
						data-show-screen-name="true"
						data-size="medium"
						data-dnt="false">
						Follow @crossentropy </a> </div>
						<script>
						!function(d,s,id) {
						  var js,fjs=d.getElementsByTagName(s)[0];
						  if(!d.getElementById(id)) {
						   js=d.createElement(s);
						   js.id=id;js.src="//platform.twitter.com/widgets.js";
						   fjs.parentNode.insertBefore(js,fjs);
						  }
						}
						(document,"script","twitter-wjs");
						</script><div style="padding-top:0px;	
padding-right:0px;
padding-bottom:0px;
padding-left:0px;
margin-top:0px;
margin-right:0px;
margin-bottom:0px;
margin-left:0px;"><a href="https://twitter.com/share" class="twitter-share-button" 
				        data-url="http://blog.datadive.net/prediction-intervals-for-random-forests/" 
				        data-via="crossentropy"
					    data-text="Prediction intervals for Random Forests"
					    data-related=""
					    data-count="horizontal"
					    data-hashtags=""
					    data-lang="autoLANGauto"
					    data-counturl=""
					    data-size="medium"
					    data-dnt="false"	> Tweet </a> </div>
		                <script>
					    !function(d,s,id) {
					      var js,fjs=d.getElementsByTagName(s)[0];
					      if(!d.getElementById(id)) {
					       js=d.createElement(s);js.id=id;js.src="https://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);
					      }
					    }
					   (document,"script","twitter-wjs");
					    </script>]]></content:encoded>
					
					<wfw:commentRss>http://blog.datadive.net/prediction-intervals-for-random-forests/feed/</wfw:commentRss>
			<slash:comments>35</slash:comments>
		
		
			</item>
		<item>
		<title>Which topics get the upvote on Hacker News?</title>
		<link>http://blog.datadive.net/which-topics-get-the-upvote-on-hacker-news/</link>
					<comments>http://blog.datadive.net/which-topics-get-the-upvote-on-hacker-news/#comments</comments>
		
		<dc:creator><![CDATA[ando]]></dc:creator>
		<pubDate>Fri, 13 Feb 2015 15:00:32 +0000</pubDate>
				<category><![CDATA[NLP]]></category>
		<category><![CDATA[Topic modelling]]></category>
		<guid isPermaLink="false">http://blog.datadive.net/?p=1831</guid>

					<description><![CDATA[Hacker News is a popular social news website, mostly covering technology and startup topics. It relies on user submissions and moderation, where each submitted story can be upvoted and commented by users, which in term determines whether the story reaches &#8230; <a href="http://blog.datadive.net/which-topics-get-the-upvote-on-hacker-news/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p><a href="https://news.ycombinator.com/">Hacker News</a> is a popular social news website, mostly covering technology and startup topics. It relies on user submissions and moderation, where each submitted story can be upvoted and commented by users, which in term determines whether the story reaches the front page and how long it stays there.</p><p>One question that has intrigued me is whether among the topics that are regularly on the front page, are there any that are consistently preferred over others in terms of upvotes or comments? For example, do science news get more or less upvotes than stories on gaming on average? Do bitcoin stories get more or less comments than posts on web design?</p><p>Obviously, the variance in such user feedback is huge, so any topic will have both very big and largely ignored stories. But given that tens of thousands of stories make the front page every year, we should be able to see the aggregate differences in topic popularity, if these differences exists.</p><p>Luckily, there are tools and libraries available that make answering such questions not only possible, but fairly straightforward.</p>
<h3>Libraries used</h3>
<ul>
<li><a href="http://docs.python-requests.org/">Requests </a>&#8211; an excellent Python HTTP library for downloading post contents</li>
<li><a href="https://code.google.com/p/boilerpipe/">Boilerpipe </a>&#8211; a library for extracting an article from a webpage and removing all the boilerplate</li>
<li><a href="http://www.crummy.com/software/BeautifulSoup/">BeautifulSoup </a>&#8211; HTML parsing, for when boilerpipe fails</li>
<li><a href="https://radimrehurek.com/gensim/">Gensim </a>&#8211; robust topic modelling</li>
<li><a href="http://stanford.edu/~mwaskom/software/seaborn/">Seaborn </a>&#8211; Matplotlib extension for beautiful plots</li>
</ul>
<h2>Data</h2><p><a href="http://hckrnews.com/data">Hckr news </a>provides a convenient archive for accessing all posts that have made it to the front page of Hacker News, together with the number of comments and upvotes for each submission. The total number of posts for 2014 was 35981. Around 34500 of them were still accessible as of January 2015, the rest were returning 4xx or 5xx.</p><p>Note that this is different from the set of <em>all</em> Hacker News submissions, since the majority of submissions never make it to the front page.</p><p>The following plots show the distribution of upvotes and comments in Hacker News front page stories in 2014 on log scale (for comments, what is shown is log(comments + 1) to accommodate zero comment posts)</p><p><a href="http://blog.datadive.net/wp-content/uploads/2015/01/upvotes.png"><img loading="lazy" class="size-full wp-image-1881 aligncenter" src="http://blog.datadive.net/wp-content/uploads/2015/01/upvotes.png" alt="upvotes" width="478" height="351" srcset="http://blog.datadive.net/wp-content/uploads/2015/01/upvotes.png 478w, http://blog.datadive.net/wp-content/uploads/2015/01/upvotes-300x220.png 300w" sizes="(max-width: 478px) 100vw, 478px" /></a></p><p><a href="http://blog.datadive.net/wp-content/uploads/2015/01/comments.png"><img loading="lazy" class="size-full wp-image-1871 aligncenter" src="http://blog.datadive.net/wp-content/uploads/2015/01/comments.png" alt="comments" width="486" height="352" srcset="http://blog.datadive.net/wp-content/uploads/2015/01/comments.png 486w, http://blog.datadive.net/wp-content/uploads/2015/01/comments-300x217.png 300w" sizes="(max-width: 486px) 100vw, 486px" /></a></p><p>The following scatter-plot shows that while there is a strong correlation between upvotes and comments, there are also quite a few outliers: posts with no comments but a very significant number of upvotes and posts with high comment count but very few upvotes.</p><p><a href="http://blog.datadive.net/wp-content/uploads/2015/01/upvotes_vs_comments2.png"><img loading="lazy" class="size-full wp-image-2481 aligncenter" src="http://blog.datadive.net/wp-content/uploads/2015/01/upvotes_vs_comments2.png" alt="upvotes_vs_comments2" width="486" height="478" srcset="http://blog.datadive.net/wp-content/uploads/2015/01/upvotes_vs_comments2.png 486w, http://blog.datadive.net/wp-content/uploads/2015/01/upvotes_vs_comments2-300x295.png 300w" sizes="(max-width: 486px) 100vw, 486px" /></a></p>
<h2>Extracting the content</h2><p>Most webpages include (a lot) of boilerplate text that is usually irrelevant to the actual story that is being linked: &#8220;popular posts&#8221;, &#8220;latest headlines&#8221;, terms of service, &#8220;follow us&#8221; links, etc. All of these pollute the content by introducing a lot of keywords that are not actually related to the article. Fortunately, there are libraries available for removing such boilerplate and extracting the actual article from the page. <a href="https://code.google.com/p/boilerpipe/">Boilerpipe </a>is an excellent Java library for doing just that (and it also has python bindings).</p><p>Removing the boilerplate and extracting the the textual content is as easy as running</p>
<pre class="brush: python; collapse: false; title: ; wrap-lines: false; notranslate">
from boilerpipe.extract import Extractor
extractor = Extractor(extractor='ArticleExtractor', html=html)
extracted_text = extractor.getText()
</pre><p>As usual with such heuristics, it doesn&#8217;t work on all pages. In case boilerpipe returns an empty string, I simply extract the textual content of the page (minus content from style and script tags) using BeautifulSoup.</p>
<pre class="brush: python; collapse: false; title: ; wrap-lines: false; notranslate">
soup = BeautifulSoup.BeautifulSoup(html)
#Strip out style and script content
strip_tags = [&quot;script&quot;, &quot;style&quot;]
for tag in soup(strip_tags):
    tag.extract()
text = soup.getText(separator = &quot; &quot;)
</pre>
<h2>Learning the topics</h2><p>There are a number of different methods for extracting topics from a text corpus, from simple <a href="http://en.wikipedia.org/wiki/Tf%E2%80%93idf">tf-idf</a> based heuristics to<a href="http://en.wikipedia.org/wiki/Latent_semantic_analysis"> Latent semantic analysis</a> to sophisticated generative model based approaches. The most popular among the latter is <a href="http://en.wikipedia.org/wiki/Latent_Dirichlet_allocation">latent Dirichlet allocation</a>.</p>
<h4>Latent Dirichlet allocation</h4><p>LDA is a generative model whereby every document is assumed to come from a mixture of a topics, and every topic  is viewed as a multinomial distribution of words. Learning these topics is then a an exercise in Bayesian inference. (Here&#8217;s a detailed <a href="http://www.arbylon.net/publications/text-est.pdf">technical overview paper</a> on LDA and the necessary background on model-based machine learning.)</p><p>There are a number of libraries that implement LDA, including <a href="https://github.com/JohnLangford/vowpal_wabbit/wiki">Vowpal Wabbit</a>, <a href="https://code.google.com/p/plda/">plda</a>, <a href="http://mallet.cs.umass.edu/">Mallet </a>etc. The one I&#8217;ve found to strike the best balance between ease-of-use and efficiency is <a href="https://radimrehurek.com/gensim/">Gensim</a>.  It  implements an online version of LDA, which converges to a good solution relatively fast. It also comes with methods for text cleaning and parsing (including stemming).</p>
<h3>Choosing the number of topics.</h3><p>LDA assumes that the number of topics is given a priori (similar to many clustering algorithms). There are approaches available which learn the number of topics from the data, such as <a href="http://en.wikipedia.org/wiki/Hierarchical_Dirichlet_process">hierarchical Dirichlet process</a>. In practice however, the inferred topic counts and resulting topics are often not what&#8217;s expected. The optimal number of topics from the structural/syntactic point of view isn&#8217;t necessarily optimal from  the semantic point of view.  Thus in practice,  running LDA with a number of different topic counts, evaluating the learned topics, and deciding whether the number topics should be increased or decreased usually gives better results.</p><p>For this dataset, 30 topics (and  running 3 passes over the dataset) seemed to strike a good balance of covering a wide enough array of domains, while keeping &#8220;junk&#8221; and overlapping topics at minimum.</p>
<pre class="brush: python; collapse: false; title: ; wrap-lines: false; notranslate">
lda = LdaModel(corpus, num_topics = 30, id2word=corpus.dictionary, passes = 3)
</pre>
<h3>Naming the topics</h3><p>The LDA topics are distributions over words, which naturally lends itself  as a naming scheme: just take a number (for example 5-10) of most probable words in the distribution as the topic descriptor. This typically works quite well. There are interesting approaches on how to improve topic naming, for example taking into account word centrality in the word network in the corpus etc.  For this particular dataset, the naive top words approach turned out to be descriptive enough.</p><p>When looking at the Hacker news dataset, the topics LDA is able to extract from the submitted stories closely tracks the expected, intuitive topics distribution. There are multiple topics on programming, computer systems, startups, but also science, health, government, gaming etc., i.e. topics that are often featured.</p><p>Here&#8217;s the full list, each named by the top 8 words in the distribution, roughly grouped by their domain . (The latter is done manually and admittedly somewhat arbitrarily.)<br />

<style type="text/css">	 
table#itemtable td, th {padding:1px;padding-left:5px;border-left: 1px solid #DDD} 	 	
</style>
<table id="itemtable">
<tbody>
<tr>
<th>Topic</th>
<th width="30%">Domain</th>
</tr>
<tr>
<td>function-value-code-string-return-list-int-byte</td>
<td rowspan="6">Programming, code</td>
</tr>
<tr>
<td>memory-thread-performance-code-write-process-data-run</td>
</tr>
<tr>
<td>number-point-algorithm-value-example-result-set-problem</td>
</tr>
<tr>
<td>return-value-class-self-def-object-method-string</td>
</tr>
<tr>
<td>code-javascript-api-html-function-web-application-user</td>
</tr>
<tr>
<td>language-type-program-code-programmer-java-write-class</td>
</tr>
<tr>
<td>network-device-power-design-technology-system-internet-machine</td>
<td rowspan="5">Computer systems, servers, data and databases</td>
</tr>
<tr>
<td>data-database-map-table-analysis-information-graph-model</td>
</tr>
<tr>
<td>server-client-http-request-service-ruby-connection-user</td>
</tr>
<tr>
<td>nameserver-file-net-kernel-dn-com-type-process</td>
</tr>
<tr>
<td>file-run-command-install-build-package-docker-version</td>
</tr>
<tr>
<td>science-research-human-paper-scientist-university-theory-researcher</td>
<td rowspan="2">Science, space</td>
</tr>
<tr>
<td>space-nasa-tesla-rocket-launch-star-china-nuclear</td>
</tr>
<tr>
<td>project-bug-source-fix-code-open-support-software</td>
<td>Software development, open source</td>
</tr>
<tr>
<td>company-business-product-market-year-startup-team-million</td>
<td>Startups, business</td>
</tr>
<tr>
<td>text-color-gallery-line-image-display-file-font</td>
<td>(Web) design</td>
</tr>
<tr>
<td>currency-btc-usd-fiat-bitcoin-money-price-bank</td>
<td>Money, bitcoin, investing</td>
</tr>
<tr>
<td>women-health-drug-study-brain-children-patient-cell</td>
<td>Health</td>
</tr>
<tr>
<td>water-air-land-light-plant-film-earth-sea</td>
<td>Environment</td>
</tr>
<tr>
<td>security-key-attack-password-hacker-encryption-network-secure</td>
<td>Security, cryptography</td>
</tr>
<tr>
<td>game-play-design-player-video-work-create-look</td>
<td>Gaming</td>
</tr>
<tr>
<td>app-apple-phone-device-mobile-android-user-ios</td>
<td>Mobile,apps</td>
</tr>
<tr>
<td>government-law-state-court-case-public-report-information</td>
<td>Government, law</td>
</tr>
<tr>
<td>user-link-email-site-service-customer-post-account</td>
<td rowspan="3">Online, computer usage</td>
</tr>
<tr>
<td>search-page-facebook-web-google-site-music-yahoo</td>
</tr>
<tr>
<td>google-microsoft-windows-video-browser-user-support-chrome</td>
</tr>
<tr>
<td>year-world-city-american-york-live-state-told</td>
<td>Location, travel, geography</td>
</tr>
<tr>
<td>work-think-know-way-good-year-look-lot</td>
<td>General</td>
</tr>
<tr>
<td>com-http-www-emacs-lisp-org-book-pdf</td>
<td rowspan="2">No clear theme ("junk" topics)</td>
</tr>
<tr>
<td>php-frac-julia-theta-xwl-fff-drosophila-aubyn</td>
</tr>
</tbody>
</table>
</p><p>Here are a few examples of top pages within some of the topics, i.e. pages where the proportion of the particular topic is the highest.</p><p><strong>Company-business-product-market-year-startup-team-million:</strong></p>
<ul>
<li><a href="http://www.cnbc.com/id/102117120">Airbnb valued at $13B ahead of staff stock sale</a></li>
<li><a href="http://www.xconomy.com/boulder-denver/2014/09/30/franklin-out-vmlogix-and-citrix-exec-in-as-sendgrid-replaces-ceo/ ">SendGrid Replaces CEO</a></li>
<li><a href="http://m.wsj.com/articles/BL-DGB-38612">Slack raises $120M on $1.12B valuation</a>
</li>
</ul><p><strong>Function-value-code-string-return-list-int-byte:</strong></p>
<ul>
<li><a href="http://pfultz2.com/blog/2014/09/05/pipable-functions/">Pipable functions in C++14</a></li>
<li><a href="http://troydm.github.io/blog/2014/03/29/writing-micro-compiler-in-ocaml/">A micro compiler in Ocaml</a></li>
<li><a href="http://wry.me/~darius/writings/dynatail.html">Tail Recursion with Dynamic Scope</a></li>
</ul><p><strong>Security-key-attack-password-hacker-encryption-network-secure:</strong></p>
<ul>
<li><a href="http://marcomanzoni.me/blog/how-pgp-works-under-the-hood/">How PGP Works Under the Hood </a></li>
<li><a href="http://minilock.io/">MiniLock – File encryption software that does more with less</a></li>
<li><a href="https://anonyfish.com/">Anonyfish – Chat Anonymously With Another Secret User</a></li>
</ul><p><strong>Science-research-human-paper-scientist-university-theory-researcher:</strong></p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Biefeld%E2%80%93Brown_effect">Biefeld–Brown effect</a></li>
<li><a href="http://newsoffice.mit.edu/2014/solving-mystery-thermoelectrics-0429%20">Solving a mystery of thermoelectrics</a></li>
<li><a href="http://phys.org/news/2014-09-solid-previously-unsolvable-problems.html">&#8216;Solid&#8217; light could compute previously unsolvable problems</a></li>
</ul><p><strong>Game-play-design-player-video-work-create-look:</strong></p>
<ul>
<li><a href="https://github.com/Matsemann/oculus-fpv">FPV with Oculus Rift and a Quadcopter</a></li>
<li><a href="https://github.com/chesterbr/2048-2600">2048 game to the Atari 2600 VCS</a></li>
<li><a href="http://www.retrocollect.com/News/unofficial-demake-port-of-super-smash-bros-arrives-on-ti-8384-calculators.html">Unofficial Demake Port Of Super Smash Bros Arrives On TI-83/84 Calculators</a></li>
</ul><p><strong>Google-microsoft-windows-video-browser-user-support-chrome:</strong></p>
<ul>
<li><a href="http://googlesystem.blogspot.com/2014/06/64-bit-chrome-for-windows.html">64-Bit Chrome for Windows</a></li>
<li><a href="http://googlesystem.blogspot.com/2014/08/mobile-internet-explorers-new-user-agent.html">Mobile Internet Explorer&#8217;s New User Agent</a></li>
<li><a href="http://www.theverge.com/2014/5/20/5734102/surface-pro-3-features-pricing-announcement">Microsoft announces the Surface Pro 3</a></li>
</ul><p><strong>Year-world-city-american-york-live-state-told</strong></p>
<ul>
<li><a href="http://online.wsj.com/articles/the-return-of-africas-strongmen-1417798993">The Return of Africa’s Strongmen</a></li>
<li><a href="http://www.homelessgopro.com/">Homeless with GoPro Cameras in SF</a></li>
<li><a href="http://time.com/85766/watch-a-street-collapse-swallow-an-entire-block-of-cars-in-baltimore/">Watch a Street Collapse Swallow an Entire Block of Cars in Baltimore</a></li>
</ul><p><strong>Women-health-drug-study-brain-children-patient-cell</strong></p>
<ul>
<li><a href="http://online.wsj.com/articles/sleep-experts-close-in-on-the-optimal-nights-sleep-1405984970">Why Seven Hours of Sleep Might Be Better Than Eight</a></li>
<li><a href="http://www.cell.com/cell/abstract/S0092-8674%2814%2901566-9">Long-Term Culture of Stem Cells from Adult Human Liver</a></li>
<li><a href="http://www.theguardian.com/science/2014/aug/06/aspirin-could-dramtically-cut-cancer-risk-say-scientists-biggest-study-yet">Aspirin could dramatically cut cancer risk, according to biggest study yet</a></li>
</ul><p>The top posts for each topic seem to match the topic descriptors quite well, which is a nice high level sanity check that they indeed capture the expected content of the stories.</p><p>When looking at the distributions of the topics, i.e. the average proportion of a topic in a page, we see that the general topics are at the top, while the junk, hard-to-interpret topics are at the bottom, showing that they are indeed outliers. The proportion of programming or computer system related topics are not at the top individually, but this is due to the fact that they are divided into several subtopics. On aggregate, programming and computer related topics clearly dominate.</p><p><a href="http://blog.datadive.net/wp-content/uploads/2015/01/proportions.png"><img loading="lazy" class="alignnone size-full wp-image-2441" src="http://blog.datadive.net/wp-content/uploads/2015/01/proportions.png" alt="proportions" width="611" height="608" srcset="http://blog.datadive.net/wp-content/uploads/2015/01/proportions.png 611w, http://blog.datadive.net/wp-content/uploads/2015/01/proportions-150x150.png 150w, http://blog.datadive.net/wp-content/uploads/2015/01/proportions-300x298.png 300w" sizes="(max-width: 611px) 100vw, 611px" /></a></p><p>We are finally ready to look at the upvote and comment distribution per topic. For this, we divide the upvotes and comments of each page proportionally between the topics assigned to that page. We then normalize the scores for each topic by the proportion of that topic in the whole corpus, so that each topic&#8217;s scores lies on the same scale.  The following plot shows the average upvotes per topic, together with 95% confidence interval bars to make sure that the differences are statistically significant (the green line denotes the mean number of upvotes over all front page posts):</p><p><a href="http://blog.datadive.net/wp-content/uploads/2015/02/upvotes_per_topic2.png"><img loading="lazy" class="alignnone size-full wp-image-2591" src="http://blog.datadive.net/wp-content/uploads/2015/02/upvotes_per_topic2.png" alt="upvotes_per_topic2" width="612" height="633" srcset="http://blog.datadive.net/wp-content/uploads/2015/02/upvotes_per_topic2.png 612w, http://blog.datadive.net/wp-content/uploads/2015/02/upvotes_per_topic2-290x300.png 290w" sizes="(max-width: 612px) 100vw, 612px" /></a></p><p>The most upvoted topics are software and open source project related, topics on government and law (prominent examples of the latter being posts on Snowden, EFF etc) and mainstream tech news (such as major announcements from Google and Microsoft) and game related stories.</p><p>At the bottom of the scale are science, health, environment, geography related news. These are topics that aren&#8217;t the &#8220;core&#8221; topics for Hacker news (which is technology and startups) and they are in general also non-controversial, when compared to topics related to government/law, money/bitcoin etc. This is well illustrated by the plot of the average number of comments per topic:</p><p><a href="http://blog.datadive.net/wp-content/uploads/2015/02/comments_per_topic2.png"><img loading="lazy" class="alignnone size-full wp-image-2601" src="http://blog.datadive.net/wp-content/uploads/2015/02/comments_per_topic2.png" alt="comments_per_topic2" width="609" height="633" srcset="http://blog.datadive.net/wp-content/uploads/2015/02/comments_per_topic2.png 609w, http://blog.datadive.net/wp-content/uploads/2015/02/comments_per_topic2-288x300.png 288w" sizes="(max-width: 609px) 100vw, 609px" /></a></p><p>In the top we again see mainstream tech related posts, but also money and bitcoin related news, law/government, mobile/apps stories. The topics with the least amount of comments seem to be the most technical ones: science, algorithms, data/databases, code, optimizations etc.</p><p>When looking at the scatter plot of upvotes vs comments, we see that while there is a correlation between the two, the ratio can vary quite significantly. There are a few things that stand out. Bitcoin/money related news, while not that highly upvoted get a lot of discussion; the (open source) software topic gets the most upvotes despite being only mediocre in the amount of discussion it generates; the programming topics cluster, which are mostly similar in being low volume in terms of discussion, but still getting solid upvoting from the community. And finally, science is clearly the least favorite front page topic on Hacker News.</p><p><a href="http://blog.datadive.net/wp-content/uploads/2015/02/topic_comments_vs_upvotes.png"><img loading="lazy" class="alignnone size-full wp-image-2701" src="http://blog.datadive.net/wp-content/uploads/2015/02/topic_comments_vs_upvotes.png" alt="topic_comments_vs_upvotes" width="644" height="462" srcset="http://blog.datadive.net/wp-content/uploads/2015/02/topic_comments_vs_upvotes.png 644w, http://blog.datadive.net/wp-content/uploads/2015/02/topic_comments_vs_upvotes-300x215.png 300w" sizes="(max-width: 644px) 100vw, 644px" /></a></p>
<h2>Conclusions</h2><p>We can see that there are clear differences between topics in terms of upvoting and commenting. In general, the results seem to match the intuitive expectations of Hacker News content quite well. First of all, the extracted topics and their descriptions are clearly in line with the intent of the page. Secondly, we see that topics that are more controversial or polarizing indeed create the most amount of discussion and to an extent it also translates to upvotes.   At he same time, the more technical topics receive a lot fewer comments on average.</p><p>There are a number of interesting things still to look at:</p>
<ul>
<li>The evolution of topics over time &#8211; which topics have increased and which ones decreased in popularity over time?</li>
<li>Analyzing all submissions. In this analysis, we only looked at posts that actually made it to the front page. Another interesting study would be to look at all posts that are submitted. This is however non-trivial, since important stories usually have multiple posts from different sites covering the same story. Generally only one of them gets picked up to to be on the front page. For the analysis, these close duplicates would have to be filtered out.</li>
<li>The structure of posts &#8211; is there anything in the post structure, word usage or similar that makes it hit big on the front page?</li>
</ul><p>&nbsp;</p>
<div style="padding-top:0px;	
padding-right:0px;
padding-bottom:0px;
padding-left:0px;
margin-top:0px;
margin-right:0px;
margin-bottom:0px;
margin-left:0px;"><a href="https://twitter.com/crossentropy" class="twitter-follow-button" 
						data-show-count="false"
						data-lang="autoLANGauto"
						data-width="250px"
						data-align="left"
						data-show-screen-name="true"
						data-size="medium"
						data-dnt="false">
						Follow @crossentropy </a> </div>
						<script>
						!function(d,s,id) {
						  var js,fjs=d.getElementsByTagName(s)[0];
						  if(!d.getElementById(id)) {
						   js=d.createElement(s);
						   js.id=id;js.src="//platform.twitter.com/widgets.js";
						   fjs.parentNode.insertBefore(js,fjs);
						  }
						}
						(document,"script","twitter-wjs");
						</script><div style="padding-top:0px;	
padding-right:0px;
padding-bottom:0px;
padding-left:0px;
margin-top:0px;
margin-right:0px;
margin-bottom:0px;
margin-left:0px;"><a href="https://twitter.com/share" class="twitter-share-button" 
				        data-url="http://blog.datadive.net/which-topics-get-the-upvote-on-hacker-news/" 
				        data-via="crossentropy"
					    data-text="Which topics get the upvote on Hacker News?"
					    data-related=""
					    data-count="horizontal"
					    data-hashtags=""
					    data-lang="autoLANGauto"
					    data-counturl=""
					    data-size="medium"
					    data-dnt="false"	> Tweet </a> </div>
		                <script>
					    !function(d,s,id) {
					      var js,fjs=d.getElementsByTagName(s)[0];
					      if(!d.getElementById(id)) {
					       js=d.createElement(s);js.id=id;js.src="https://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);
					      }
					    }
					   (document,"script","twitter-wjs");
					    </script>]]></content:encoded>
					
					<wfw:commentRss>http://blog.datadive.net/which-topics-get-the-upvote-on-hacker-news/feed/</wfw:commentRss>
			<slash:comments>3</slash:comments>
		
		
			</item>
		<item>
		<title>Selecting good features – Part IV: stability selection, RFE and everything side by side</title>
		<link>http://blog.datadive.net/selecting-good-features-part-iv-stability-selection-rfe-and-everything-side-by-side/</link>
					<comments>http://blog.datadive.net/selecting-good-features-part-iv-stability-selection-rfe-and-everything-side-by-side/#comments</comments>
		
		<dc:creator><![CDATA[ando]]></dc:creator>
		<pubDate>Sat, 20 Dec 2014 13:49:53 +0000</pubDate>
				<category><![CDATA[Feature selection]]></category>
		<category><![CDATA[Machine learning]]></category>
		<guid isPermaLink="false">http://blog.datadive.net/?p=1392</guid>

					<description><![CDATA[In my previous posts, I looked at univariate methods,linear models and regularization and random forests for feature selection.In this post, I&#8217;ll look at two other methods: stability selection and recursive feature elimination (RFE), which can both considered wrapper methods. They &#8230; <a href="http://blog.datadive.net/selecting-good-features-part-iv-stability-selection-rfe-and-everything-side-by-side/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p>In my previous posts, I looked at <a href="/selecting-good-features-part-i-univariate-selection/">univariate methods</a>,<a href="/selecting-good-features-part-ii-linear-models-and-regularization/">linear models and regularization</a> and <a href="/selecting-good-features-part-iii-random-forests/">random forests</a> for feature selection.</p><p>In this post, I&#8217;ll look at two other methods: stability selection and recursive feature elimination (RFE), which can both considered wrapper methods. They both build on top of other (model based) selection methods such as regression or SVM, building models on different subsets of data and extracting the ranking from the aggregates.</p><p>As a wrap-up I&#8217;ll run all previously discussed methods, to highlight their pros, cons and gotchas with respect to each other.</p>
<h1>Stability selection </h1><p><a href="http://stat.ethz.ch/~nicolai/stability.pdf">Stability selection</a> is a relatively novel method for feature selection, based on subsampling in combination with selection algorithms (which could be regression, SVMs or other similar method). The high level idea is to apply a feature selection algorithm on different subsets of data and with different subsets of features. After repeating the process a number of times, the selection results can be aggregated, for example by checking how many times a feature ended up being selected as important when it was in an inspected feature subset. We can expect strong features to have scores close to 100%, since they are always selected when possible. Weaker, but still relevant features will also have non-zero scores, since they would be selected when stronger features are not present in the currently selected subset, while irrelevant features would have scores (close to) zero, since they would never be among selected features.</p><p>Sklearn implements stability selection in the <a href="http://scikit-learn.org/stable/modules/generated/sklearn.linear_model.RandomizedLasso.html">randomized lasso</a> and <a href="http://scikit-learn.org/stable/modules/generated/sklearn.linear_model.RandomizedLogisticRegression.html">randomized logistics regression</a> classes.</p>
<pre class="brush: python; collapse: false; title: ; wrap-lines: false; notranslate">
from sklearn.linear_model import RandomizedLasso
from sklearn.datasets import load_boston
boston = load_boston()

#using the Boston housing data. 
#Data gets scaled automatically by sklearn's implementation
X = boston[&quot;data&quot;]
Y = boston[&quot;target&quot;]
names = boston[&quot;feature_names&quot;]

rlasso = RandomizedLasso(alpha=0.025)
rlasso.fit(X, Y)

print &quot;Features sorted by their score:&quot;
print sorted(zip(map(lambda x: round(x, 4), rlasso.scores_), 
                 names), reverse=True)
</pre>
<blockquote><p><code><br />
Features sorted by their score:<br />
[(1.0, 'RM'), (1.0, 'PTRATIO'), (1.0, 'LSTAT'), (0.62, 'CHAS'), (0.595, 'B'), (0.39, 'TAX'), (0.385, 'CRIM'), (0.25, 'DIS'), (0.22, 'NOX'), (0.125, 'INDUS'), (0.045, 'ZN'), (0.02, 'RAD'), (0.015, 'AGE')]<br />
</code></p></blockquote><p>As you can see from the example, the top 3 features have equal scores of 1.0, meaning they were always selected as useful features (of course this could and would change when changing the regularization parameter, but sklearn&#8217;s <a href="http://scikit-learn.org/stable/modules/generated/sklearn.linear_model.RandomizedLasso.html">randomized lasso</a> implementation can choose a good \(\alpha\) parameter automatically). The scores drop smoothly from there, but in general, the drop off is not sharp as is often the case with pure lasso, or random forest. This means stability selection is useful for both pure feature selection to reduce overfitting, but also for data interpretation: in general, good features won&#8217;t get 0 as coefficients just because there are similar, correlated features in the dataset (as is the case with lasso). For feature selection, I&#8217;ve found it to be among the top performing methods for many different datasets and settings.</p>
<h1>Recursive feature elimination</h1><p>Recursive feature elimination is based on the idea to repeatedly construct a model (for example an SVM or a regression model) and choose either the best or worst performing feature (for example based on coefficients), setting the feature aside and then repeating the process with the rest of the features. This process is applied until all features in the dataset are exhausted. Features are then ranked according to when they were eliminated. As such, it is a greedy optimization for finding the best performing subset of features.</p><p>The stability of RFE depends heavily on the type of model that is used for feature ranking at each iteration. Just as non-regularized regression can be unstable, so can RFE when utilizing it, while using ridge regression can provide more stable results.</p><p>Sklearn provides <a href="http://scikit-learn.org/stable/modules/generated/sklearn.feature_selection.RFE.html">RFE</a> for recursive feature elimination and <a href="http://scikit-learn.org/stable/modules/generated/sklearn.feature_selection.RFECV.html">RFECV</a> for finding the ranks together with optimal number of features via a cross validation loop.</p>
<pre class="brush: python; collapse: false; title: ; wrap-lines: false; notranslate">
from sklearn.feature_selection import RFE
from sklearn.linear_model import LinearRegression

boston = load_boston()
X = boston[&quot;data&quot;]
Y = boston[&quot;target&quot;]
names = boston[&quot;feature_names&quot;]

#use linear regression as the model
lr = LinearRegression()
#rank all features, i.e continue the elimination until the last one
rfe = RFE(lr, n_features_to_select=1)
rfe.fit(X,Y)

print &quot;Features sorted by their rank:&quot;
print sorted(zip(map(lambda x: round(x, 4), rfe.ranking_), names))
</pre>
<blockquote><p><code><br />
Features sorted by their rank:<br />
[(1.0, 'NOX'), (2.0, 'RM'), (3.0, 'CHAS'), (4.0, 'PTRATIO'), (5.0, 'DIS'), (6.0, 'LSTAT'), (7.0, 'RAD'), (8.0, 'CRIM'), (9.0, 'INDUS'), (10.0, 'ZN'), (11.0, 'TAX'), (12.0, 'B'), (13.0, 'AGE')]<br />
</code></p></blockquote>
<h1>Example: running the methods side by side </h1><p>I&#8217;ll now take all the examples from this post, and the <a href="/selecting-good-features-part-i-univariate-selection/">three</a> <a href="/selecting-good-features-part-ii-linear-models-and-regularization/">previous</a> <a href="/selecting-good-features-part-iii-random-forests/">ones</a> and run the methods on a sample dataset to compare them side by side. The dataset will be the so called Friedman #1 regression dataset (from Friedman&#8217;s <a href="ftp://ftp.uic.edu/pub/depts/econ/hhstokes/e538/Friedman_mars_1991.pdf">Multivariate Adaptive Regression Splines</a> paper). The data is generated according to formula \(y = 10sin(\pi x_1 x_2) + 20(x_3 &#8211; 0.5)^2 + 10X_4 + 5X_5 +\epsilon\), where the \(x_1\) to \(x_5\) are drawn from uniform distribution and \(\epsilon\) is the standard normal deviate \(N(0,1)\). Additionally, the original dataset had five noise variables \(x_6,&#8230;,x_{10}\), independent of the response variable. We will increase the number of variables further and add four variables \(x_{11},&#8230;,x_{14}\) each of which are very strongly correlated with \(x_1,&#8230;,x_4\), respectively, generated by \(f(x) = x + N(0, 0.01)\). This yields a correlation coefficient of more than 0.999 between the variables. This will illustrate how different feature ranking methods deal with correlations in the data.</p><p>We&#8217;ll apply run each of the above listed methods on the dataset and normalize the scores so that that are between 0 (for lowest ranked feature) and 1 (for the highest feature). For recursive feature elimination, the top five feature will all get score 1, with the rest of the ranks spaced equally between 0 and 1 according to their rank.</p>
<pre class="brush: python; collapse: false; title: ; wrap-lines: false; notranslate">
from sklearn.datasets import load_boston
from sklearn.linear_model import (LinearRegression, Ridge, 
                                  Lasso, RandomizedLasso)
from sklearn.feature_selection import RFE, f_regression
from sklearn.preprocessing import MinMaxScaler
from sklearn.ensemble import RandomForestRegressor
import numpy as np
from minepy import MINE

np.random.seed(0)

size = 750
X = np.random.uniform(0, 1, (size, 14))

#&quot;Friedamn #1” regression problem
Y = (10 * np.sin(np.pi*X[:,0]*X[:,1]) + 20*(X[:,2] - .5)**2 + 
     10*X[:,3] + 5*X[:,4] + np.random.normal(0,1))
#Add 3 additional correlated variables (correlated with X1-X3)
X[:,10:] = X[:,:4] + np.random.normal(0, .025, (size,4))

names = [&quot;x%s&quot; % i for i in range(1,15)]

ranks = {}

def rank_to_dict(ranks, names, order=1):
    minmax = MinMaxScaler()
    ranks = minmax.fit_transform(order*np.array([ranks]).T).T[0]
    ranks = map(lambda x: round(x, 2), ranks)
    return dict(zip(names, ranks ))

lr = LinearRegression(normalize=True)
lr.fit(X, Y)
ranks[&quot;Linear reg&quot;] = rank_to_dict(np.abs(lr.coef_), names)

ridge = Ridge(alpha=7)
ridge.fit(X, Y)
ranks[&quot;Ridge&quot;] = rank_to_dict(np.abs(ridge.coef_), names)


lasso = Lasso(alpha=.05)
lasso.fit(X, Y)
ranks[&quot;Lasso&quot;] = rank_to_dict(np.abs(lasso.coef_), names)


rlasso = RandomizedLasso(alpha=0.04)
rlasso.fit(X, Y)
ranks[&quot;Stability&quot;] = rank_to_dict(np.abs(rlasso.scores_), names)

#stop the search when 5 features are left (they will get equal scores)
rfe = RFE(lr, n_features_to_select=5)
rfe.fit(X,Y)
ranks[&quot;RFE&quot;] = rank_to_dict(map(float, rfe.ranking_), names, order=-1)

rf = RandomForestRegressor()
rf.fit(X,Y)
ranks[&quot;RF&quot;] = rank_to_dict(rf.feature_importances_, names)


f, pval  = f_regression(X, Y, center=True)
ranks[&quot;Corr.&quot;] = rank_to_dict(f, names)

mine = MINE()
mic_scores = []
for i in range(X.shape[1]):
    mine.compute_score(X[:,i], Y)
    m = mine.mic()
    mic_scores.append(m)

ranks[&quot;MIC&quot;] = rank_to_dict(mic_scores, names) 


r = {}
for name in names:
    r[name] = round(np.mean([ranks[method][name] 
                             for method in ranks.keys()]), 2)

methods = sorted(ranks.keys())
ranks[&quot;Mean&quot;] = r
methods.append(&quot;Mean&quot;)

print &quot;\t%s&quot; % &quot;\t&quot;.join(methods)
for name in names:
    print &quot;%s\t%s&quot; % (name, &quot;\t&quot;.join(map(str, 
                         [ranks[method][name] for method in methods])))

</pre><p>Here&#8217;s the resulting table (sortable by clicking on the column header), with the results from each method + the mean </p>
<div class="table-responsive">
<table  style="width:100%; "  class="easy-table easy-table-default tablesorter  " >
<thead>
<tr>
<th class=' ' >Feature</th>
<th class=' ' >Lin. corr.</th>
<th class=' ' >Linear reg.</th>
<th class=' ' >Lasso</th>
<th class=' ' >MIC</th>
<th class=' ' >RF</th>
<th class=' ' >RFE</th>
<th class=' ' >Ridge</th>
<th class=' ' >Stability</th>
<th class=' ' >Mean</th>
</tr>
</thead>
<tbody>
<tr>
<td >x1</td>
<td >0.3</td>
<td >1.0</td>
<td >0.79</td>
<td >0.39</td>
<td >0.18</td>
<td >1.0</td>
<td >0.77</td>
<td >0.61</td>
<td >0.63</td>
</tr>
<tr>
<td >x2</td>
<td >0.44</td>
<td >0.56</td>
<td >0.83</td>
<td >0.61</td>
<td >0.24</td>
<td >1.0</td>
<td >0.75</td>
<td >0.7</td>
<td >0.64</td>
</tr>
<tr>
<td >x3</td>
<td >0.0</td>
<td >0.5</td>
<td >0.0</td>
<td >0.34</td>
<td >0.01</td>
<td >1.0</td>
<td >0.05</td>
<td >0.0</td>
<td >0.24</td>
</tr>
<tr>
<td >x4</td>
<td >1.0</td>
<td >0.57</td>
<td >1.0</td>
<td >1.0</td>
<td >0.45</td>
<td >1.0</td>
<td >1.0</td>
<td >1.0</td>
<td >0.88</td>
</tr>
<tr>
<td >x5</td>
<td >0.1</td>
<td >0.27</td>
<td >0.51</td>
<td >0.2</td>
<td >0.04</td>
<td >0.78</td>
<td >0.88</td>
<td >0.6</td>
<td >0.42</td>
</tr>
<tr>
<td >x6</td>
<td >0.0</td>
<td >0.02</td>
<td >0.0</td>
<td >0.0</td>
<td >0.0</td>
<td >0.44</td>
<td >0.05</td>
<td >0.0</td>
<td >0.06</td>
</tr>
<tr>
<td >x7</td>
<td >0.01</td>
<td >0.0</td>
<td >0.0</td>
<td >0.07</td>
<td >0.0</td>
<td >0.0</td>
<td >0.01</td>
<td >0.0</td>
<td >0.01</td>
</tr>
<tr>
<td >x8</td>
<td >0.02</td>
<td >0.03</td>
<td >0.0</td>
<td >0.05</td>
<td >0.0</td>
<td >0.56</td>
<td >0.09</td>
<td >0.0</td>
<td >0.09</td>
</tr>
<tr>
<td >x9</td>
<td >0.01</td>
<td >0.0</td>
<td >0.0</td>
<td >0.09</td>
<td >0.0</td>
<td >0.11</td>
<td >0.0</td>
<td >0.0</td>
<td >0.03</td>
</tr>
<tr>
<td >x10</td>
<td >0.0</td>
<td >0.01</td>
<td >0.0</td>
<td >0.04</td>
<td >0.0</td>
<td >0.33</td>
<td >0.01</td>
<td >0.0</td>
<td >0.05</td>
</tr>
<tr>
<td >x11</td>
<td >0.29</td>
<td >0.6</td>
<td >0.0</td>
<td >0.43</td>
<td >0.14</td>
<td >1.0</td>
<td >0.59</td>
<td >0.39</td>
<td >0.43</td>
</tr>
<tr>
<td >x12</td>
<td >0.44</td>
<td >0.14</td>
<td >0.0</td>
<td >0.71</td>
<td >0.12</td>
<td >0.67</td>
<td >0.68</td>
<td >0.42</td>
<td >0.4</td>
</tr>
<tr>
<td >x13</td>
<td >0.0</td>
<td >0.48</td>
<td >0.0</td>
<td >0.23</td>
<td >0.01</td>
<td >0.89</td>
<td >0.02</td>
<td >0.0</td>
<td >0.2</td>
</tr>
<tr>
<td >x14</td>
<td >0.99</td>
<td >0.0</td>
<td >0.16</td>
<td >1.0</td>
<td >1.0</td>
<td >0.22</td>
<td >0.95</td>
<td >0.53</td>
<td >0.61</td>
</tr>
</tbody>
</table>
</div><p>The example should highlight some the interesting characteristics of the different methods.</p><p>With <strong>linear correlation</strong> (Lin. corr.), each feature is evaluated independently, so the scores for features \(x_1&#8230;x_4\) are very similar to \(x_{11}&#8230;x_{14}\), while the noise features \(x_5&#8230;x_{10}\) are correctly identified to have almost no relation with the response variable. It&#8217;s not able to identify any relationship between \(x_3\) and the response variable, since the relationship is quadratic (in fact, this applies almost all other methods except for MIC). It&#8217;s also clear that while the method is able to measure the linear relationship between each feature and the response variable, it is not optimal for selecting the top performing features for improving the generalization of a model, since all top performing features would essentially be picked twice.</p><p><strong>Lasso</strong> picks out the top performing features, while forcing other features to be close to zero. It is clearly useful when reducing the number of features is required, but not necessarily for data interpretation (since it might lead one to believe that features \(x_{11}&#8230;x_{13}\) do not have a strong relationship with the output variable).</p><p><strong>MIC</strong> is similar to correlation coefficient in treating all features &#8220;equally&#8221;, additionally it is able to find the non-linear a relationship between \(x_3\) and the response.</p><p><strong>Random forest&#8217;s</strong> impurity based ranking is typically aggressive in the sense that there is a sharp drop-off of scores after the first few top ones. This can be seen from the example where the third ranked feature has already 4x smaller score than the top feature (whereas for the other ranking methods, the drop-off is clearly not that aggressive). </p><p><strong>Ridge regression</strong> forces regressions coefficients to spread out similarly between correlated variables. This is clearly visible in the example where \(x_{11}&#8230;x_{14}\) are close to \(x_1&#8230;x_4\) in terms of scores.</p><p><strong>Stability selection</strong> is often able to make a useful compromise between data interpretation and top feature selection for model improvement. This is illustrated well in the example. Just like Lasso it is able to identify the top features (\(x_1\), \(x_2\), \(x_4\), \(x_5\)). At the same time their correlated shadow variables also get a high score, illustrating their relation with the response.</p>
<h1>Conclusions</h1><p>Feature ranking can be incredibly useful in a number of machine learning and data mining scenarios. The key though is to have the end goal clearly in mind and understand which method works best for achieving it. When selecting top features for model performance improvement, it is easy to verify if a particular method works well against alternatives simply by doing cross-validation. It&#8217;s not as straightforward when using feature ranking for data interpretation, where stability of the ranking method is crucial and a method that doesn&#8217;t have this property (such as lasso) could easily lead to incorrect conclusions. What can help there is subsampling the data and running the selection algorithms on the subsets. If the results are consistent across the subsets, it is relatively safe to trust the stability of the method on this particular data and therefor straightforward to interpret the data in terms of the ranking.</p>
<div style="padding-top:0px;	
padding-right:0px;
padding-bottom:0px;
padding-left:0px;
margin-top:0px;
margin-right:0px;
margin-bottom:0px;
margin-left:0px;"><a href="https://twitter.com/crossentropy" class="twitter-follow-button" 
						data-show-count="false"
						data-lang="autoLANGauto"
						data-width="250px"
						data-align="left"
						data-show-screen-name="true"
						data-size="medium"
						data-dnt="false">
						Follow @crossentropy </a> </div>
						<script>
						!function(d,s,id) {
						  var js,fjs=d.getElementsByTagName(s)[0];
						  if(!d.getElementById(id)) {
						   js=d.createElement(s);
						   js.id=id;js.src="//platform.twitter.com/widgets.js";
						   fjs.parentNode.insertBefore(js,fjs);
						  }
						}
						(document,"script","twitter-wjs");
						</script><div style="padding-top:0px;	
padding-right:0px;
padding-bottom:0px;
padding-left:0px;
margin-top:0px;
margin-right:0px;
margin-bottom:0px;
margin-left:0px;"><a href="https://twitter.com/share" class="twitter-share-button" 
				        data-url="http://blog.datadive.net/selecting-good-features-part-iv-stability-selection-rfe-and-everything-side-by-side/" 
				        data-via="crossentropy"
					    data-text="Selecting good features – Part IV: stability selection, RFE and everything side by side"
					    data-related=""
					    data-count="horizontal"
					    data-hashtags=""
					    data-lang="autoLANGauto"
					    data-counturl=""
					    data-size="medium"
					    data-dnt="false"	> Tweet </a> </div>
		                <script>
					    !function(d,s,id) {
					      var js,fjs=d.getElementsByTagName(s)[0];
					      if(!d.getElementById(id)) {
					       js=d.createElement(s);js.id=id;js.src="https://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);
					      }
					    }
					   (document,"script","twitter-wjs");
					    </script>]]></content:encoded>
					
					<wfw:commentRss>http://blog.datadive.net/selecting-good-features-part-iv-stability-selection-rfe-and-everything-side-by-side/feed/</wfw:commentRss>
			<slash:comments>45</slash:comments>
		
		
			</item>
	</channel>
</rss>
