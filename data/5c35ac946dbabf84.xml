<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Publishable Stuff]]></title>
  <link href="http://www.sumsar.net/atom.xml" rel="self"/>
  <link href="http://www.sumsar.net/"/>
  <updated>2021-03-11T12:18:27+00:00</updated>
  <id>http://www.sumsar.net/</id>
  <author>
    <name><![CDATA[Rasmus Bååth]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[The Tidyverse in a Table]]></title>
    <link href="http://www.sumsar.net/blog/2020/12/tidyverse-in-a-table/"/>
    <updated>2020-12-29T17:00:00+00:00</updated>
    <id>http://www.sumsar.net/blog/2020/12/tidyverse-in-a-table</id>
    
      <category scheme="http://www.sumsar.net/blog/categories/" term="r" />
    
    <content type="html"><![CDATA[<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><body>
<p><em>This was my submission to the <a href="https://blog.rstudio.com/2020/09/15/announcing-the-2020-rstudio-table-contest/">2020 RStudio Table Contest</a>. For many good reasons it didn’t qualify, you can check out all those good reasons here: <a href="https://blog.rstudio.com/2020/12/23/winners-of-the-2020-rstudio-table-contest/">Winners of the 2020 RStudio Table Contest.
</a></em></p>

<p>Some tables are beautiful. And yes, I’m talking about the stats-and-numbers kind of tables and not the ones you get at IKEA. Some tables show carefully selected statistics, with headers in bold and spacious yet austere design; the numbers rounded to just the right number of decimal places. </p>

<p>But here we’re not going to make a beautiful table, instead we’re making a <em>useful table</em>. In this tutorial, I’m going show you how to take all the documentation, for all the functions in <a href="https://www.tidyverse.org/packages/#core-tidyverse">the <code>tidyverse</code> core packages</a>, and condense it into one single table. Why is this useful? As we’re going to use the excellent <a href="https://rstudio.github.io/DT/">DT package</a> the result is going to be an interactive table that makes it easy to search, sort, and explore the functions of the tidyverse.</p>

<p>Actually, let’s start with the finished table and then I’ll show you how it’s made. Or a screenshot of it, at least. To read on and to try out the interactive table <a href="http://www.sumsar.net/files/posts/2020-12-29-tidyverse-in-a-table/tidyverse_in_a_table.html">check out my full submission here</a>.</p>

<p><a href="http://www.sumsar.net/files/posts/2020-12-29-tidyverse-in-a-table/tidyverse_in_a_table.html"><img src="http://www.sumsar.net/images/posts/2020-12-29-tidyverse-in-a-table/tidyverse-in-a-table.gif" alt=""></a></p>

<!-- more -->

</body></html>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Image Dithering in R]]></title>
    <link href="http://www.sumsar.net/blog/2019/01/image-dithering-in-r/"/>
    <updated>2019-01-22T22:40:00+00:00</updated>
    <id>http://www.sumsar.net/blog/2019/01/image-dithering-in-r</id>
    
      <category scheme="http://www.sumsar.net/blog/categories/" term="r" />
    
    <content type="html"><![CDATA[<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><body>
<p>This January I played the most intriguing computer game I’ve played in ages: <a href="https://obradinn.com/">The Return of the Obra Dinn</a>. Except for being a masterpiece of murder-mystery storytelling it also has the most unique art-style as it only uses black and white pixels. To pull this off Obra Dinn makes use of <em>image dithering</em>: the arrangement of pixels of low color resolution to emulate the color shades in between. Since the game was over all too quickly I thought I instead would explore how basic image dithering can be implemented in R. If old school graphics piques your interest, read on! There will be some grainy looking ggplot charts at the end.</p>

<p><a href="https://obradinn.com/"><img src="http://www.sumsar.net/images/posts/2019-01-22-image-dithering-in-r/obra_dinn_title_cropped.gif" alt=""></a></p>

<p>(<em>The image above is copyright Lucas Pope and is the title screen of <a href="https://obradinn.com/">The Return of the Obra Dinn</a></em>)</p>

<!-- more -->

<h2 id="horatio-nelson-in-black-and-white">Horatio Nelson in black and white</h2>

<p>Image dithering tries to solve the problem that you want to show an image with many shades of color, but your device can only display a much smaller number of colors. This might sound like a silly problem now, but was a very real problem in the early days of computers. For example, <a href="https://en.wikipedia.org/wiki/Macintosh_128K">the original Mac</a> could only display black and white pixels, not even any shades of grey!</p>

<p>So let’s do some image dithering in R! The Return of Obra Dinn takes place on an early 19th century East Indiaman ship, so let’s use something related as an example image. Why not use <a href="https://upload.wikimedia.org/wikipedia/commons/thumb/7/72/HoratioNelson1.jpg/199px-HoratioNelson1.jpg">a low-resolution painting of Vice Admiral Horatio Nelson</a> (1758 - 1805) the British officer who defeated the French and Spanish navies during the battle of Trafalgar. To read in the image I will use the <a href="http://dahtah.github.io/imager/"><code>imager</code></a> package.</p>

<pre><code><div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">library(imager)
nelson <span style="color: #666666">&lt;-</span> load.image(<span style="color: #BA2121">"horatio_nelson.jpg"</span>)
nelson
</pre></div></code></pre>

<pre><code><div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic">## Image. Width: 199 pix Height: 240 pix Depth: 1 Colour channels: 3</span>
</pre></div></code></pre>

<p>The <a href="http://dahtah.github.io/imager/"><code>imager</code></a> package is a really useful package when you want to manipulate (and mess with) images directly in R. The <code>nelson</code> object is now a <code>cimg</code> object, which is basically an <code>array</code> with dimensions Width, Height, Depth (a time dimension, if you have a series of images), and Color channels. More importantly, <code>cimg</code> objects can be <code>plot</code>ted:</p>

<pre><code><div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">plot(nelson)
</pre></div></code></pre>

<p><img src="http://www.sumsar.net/figures/2019-01-22-image-dithering-in-r/unnamed-chunk-3-1.png" alt=""><!-- --></p>

<p>As an example, I’m going to do black-and-white dithering so let’s remove the color and any transparency (called “alpha” here) from the image.</p>

<pre><code><div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">nelson_gray <span style="color: #666666">&lt;-</span> grayscale( rm.alpha(nelson) )
plot(nelson_gray)
</pre></div></code></pre>

<p><img src="http://www.sumsar.net/figures/2019-01-22-image-dithering-in-r/unnamed-chunk-4-1.png" alt=""><!-- --></p>

<p>Now let’s imagine that we would want to display this image using only black and white pixels. Before getting to the dithering, what would the simplest method be to achieve this? Well, we could just <em>threshold</em> the image. A pixel with value <code>0.0</code> (fully black) to <code>0.5</code> are made black, and pixels with values above <code>0.5</code> are set to white (<code>1.0</code>). This is easy to do as <code>nelson_gray</code> can be treated as a matrix:</p>

<pre><code><div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">nelson_threshold <span style="color: #666666">&lt;-</span> nelson_gray <span style="color: #666666">&gt;</span> <span style="color: #666666">0.5</span>
plot(nelson_threshold)
</pre></div></code></pre>

<p><img src="http://www.sumsar.net/figures/2019-01-22-image-dithering-in-r/unnamed-chunk-5-1.png" alt=""><!-- --></p>

<p>So, while the image looks kind of cool, it has lost a lot of nuance as large parts of it are now completely black. So how to fake shades of gray using only black and white pixels? Well, you can <em>dither</em> the image, that is, add some noise to the image as you reduce the number of colors. Let’s start by trying out the most basic kind of noise: White noise, here created using the <code>runif</code> function: </p>

<pre><code><div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">rand_matrix <span style="color: #666666">&lt;-</span> matrix(
  data <span style="color: #666666">=</span> runif(length(nelson_gray)),
  ncol <span style="color: #666666">=</span> ncol(nelson_gray), nrow<span style="color: #666666">=</span>nrow(nelson_gray))
rand_cimg <span style="color: #666666">&lt;-</span> as.cimg(rand_matrix)
plot(rand_cimg)
</pre></div></code></pre>

<p><img src="http://www.sumsar.net/figures/2019-01-22-image-dithering-in-r/unnamed-chunk-6-1.png" alt=""><!-- --></p>

<p>Each pixel in <code>rand_cimg</code> is a value from <code>0.0</code> to <code>1.0</code> and we can now use <code>rand_cimg</code> when thresholding instead of the static <code>0.5</code>. If you try out many different noise images then every black and white pixel will <em>on average</em> have the same value as the original grayscale pixel. This sounds like a good property, but let’s see how it looks with the current <code>rand_cimg</code>:</p>

<pre><code><div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">nelson_rand <span style="color: #666666">&lt;-</span> nelson_gray <span style="color: #666666">&gt;</span> rand_cimg
plot(nelson_rand)
</pre></div></code></pre>

<p><img src="http://www.sumsar.net/figures/2019-01-22-image-dithering-in-r/unnamed-chunk-7-1.png" alt=""><!-- --></p>

<p>To be correct <em>on average</em> doesn’t help much, <em>in practice</em>, we get a very noisy Nelson. But if you squint you can now see shades of gray in the picture, at least. Random noise is just too random, but maybe we can get better dithering by adding less random noise. What about a checker pattern?</p>

<pre><code><div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">checker_pattern <span style="color: #666666">&lt;-</span> rbind(c(<span style="color: #666666">1/3</span>, <span style="color: #666666">2/3</span>),
                         c(<span style="color: #666666">2/3</span>, <span style="color: #666666">1/3</span>))
plot(as.cimg(checker_pattern))
</pre></div></code></pre>

<p><img src="http://www.sumsar.net/figures/2019-01-22-image-dithering-in-r/unnamed-chunk-8-1.png" alt=""><!-- --></p>

<p>The pattern above uses cutoffs of 1/3 and 2/3, so Nelson-pixels that gets compared to a darker 1/3-pixel will be more likely to go white and Nelson-pixels that are compared to a lighter 2/3-pixel will tend to go black. Let’s scale this patter to Nelson-size.</p>

<pre><code><div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># rep_mat takes a matrix (mat) and tiles it so that the resulting</span>
<span style="color: #408080; font-style: italic"># matrix has size nrow_out x ncol_out.</span>
<span style="color: #408080; font-style: italic"># It's basically a 2d version of rep()</span>
rep_mat <span style="color: #666666">&lt;-</span> <span style="color: #008000; font-weight: bold">function</span>(mat, nrow_out, ncol_out) {
  mat[rep(seq_len(nrow(mat)), length.out <span style="color: #666666">=</span> nrow_out),
      rep(seq_len(ncol(mat)), length.out <span style="color: #666666">=</span> ncol_out)]
}

checker_cimg <span style="color: #666666">&lt;-</span> as.cimg(rep_mat(checker_pattern, nrow(nelson_gray), ncol(nelson_gray)))
plot(checker_cimg)
</pre></div></code></pre>

<p><img src="http://www.sumsar.net/figures/2019-01-22-image-dithering-in-r/unnamed-chunk-9-1.png" alt=""><!-- --></p>

<p>And let’s do the thresholding with this new checker pattern:</p>

<pre><code><div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">nelson_checker <span style="color: #666666">&lt;-</span> nelson_gray <span style="color: #666666">&gt;</span> checker_cimg
plot(nelson_checker)
</pre></div></code></pre>

<p><img src="http://www.sumsar.net/figures/2019-01-22-image-dithering-in-r/unnamed-chunk-10-1.png" alt=""><!-- --></p>

<p>Well, it’s not good, but it kind of looks like we got at least one shade of gray now compared to using the static <code>0.5</code>. Actually, that’s exactly what we got! We can see that by taking a smooth gradient…</p>

<pre><code><div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">gradient <span style="color: #666666">&lt;-</span> as.cimg( rep(seq(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, <span style="color: #666666">0.01</span>), <span style="color: #666666">101</span>), x<span style="color: #666666">=101</span>, y<span style="color: #666666">=101</span>)
plot(gradient)
</pre></div></code></pre>

<p><img src="http://www.sumsar.net/figures/2019-01-22-image-dithering-in-r/unnamed-chunk-11-1.png" alt=""><!-- --></p>

<p>… and thresholding with the checker pattern:</p>

<pre><code><div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">checker_cimg <span style="color: #666666">&lt;-</span> as.cimg(rep_mat(checker_pattern,
                                nrow(gradient), ncol(gradient)))
gradient_checker <span style="color: #666666">&lt;-</span> gradient <span style="color: #666666">&gt;</span> checker_cimg
plot(gradient_checker)
</pre></div></code></pre>

<p><img src="http://www.sumsar.net/figures/2019-01-22-image-dithering-in-r/unnamed-chunk-12-1.png" alt=""><!-- --></p>

<p>This gives us three columns: black, “checker-gray”, and white. So, using the checker pattern we can achieve some more nuance than with simple thresholding. Is there perhaps an even better pattern that allows for even more nuance?</p>

<h2 id="better-patterns-bayer-patterns">Better patterns, Bayer patterns</h2>

<p>Yes, there is! The classical pattern used in many image dithering implementations is the <em>Bayer pattern</em> (or <em>Bayer matrix</em>) named after it’s inventor Bryce Bayer. It’s an evolution of the checker pattern defined for matrices of size 2×2, 4×4, 8×8, etc. The exact construction and properties of the Bayer matrix are well described in <a href="https://en.wikipedia.org/wiki/Ordered_dithering">the Wikipedia article</a> but here is how to create it in R and how it looks:</p>

<pre><code><div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># Calculates a non-normalized Bayer pattern matrix of size 2^n</span>
recursive_bayer_pattern <span style="color: #666666">&lt;-</span> <span style="color: #008000; font-weight: bold">function</span>(n) {
  <span style="color: #008000; font-weight: bold">if</span>(n <span style="color: #666666">&lt;=</span> <span style="color: #666666">0</span>) {
    <span style="color: #008000; font-weight: bold">return</span>(matrix(<span style="color: #666666">0</span>))
  }
  m <span style="color: #666666">&lt;-</span> recursive_bayer_pattern(n <span style="color: #666666">-</span> <span style="color: #666666">1</span>)
  rbind(
    cbind(<span style="color: #666666">4</span> <span style="color: #666666">*</span> m <span style="color: #666666">+</span> <span style="color: #666666">0</span>, <span style="color: #666666">4</span> <span style="color: #666666">*</span> m <span style="color: #666666">+</span> <span style="color: #666666">2</span>),
    cbind(<span style="color: #666666">4</span> <span style="color: #666666">*</span> m <span style="color: #666666">+</span> <span style="color: #666666">3</span>, <span style="color: #666666">4</span> <span style="color: #666666">*</span> m <span style="color: #666666">+</span> <span style="color: #666666">1</span>))
}

<span style="color: #408080; font-style: italic"># Returns a Bayer pattern of size 2^n normalized so all values</span>
<span style="color: #408080; font-style: italic"># are between 0.0 and 1.0.</span>
normalized_bayer_pattern <span style="color: #666666">&lt;-</span> <span style="color: #008000; font-weight: bold">function</span>(n) {
  pattern <span style="color: #666666">&lt;-</span> recursive_bayer_pattern(n)
  (<span style="color: #666666">1</span> <span style="color: #666666">+</span> pattern) <span style="color: #666666">/</span> ( <span style="color: #666666">1</span> <span style="color: #666666">+</span> length(pattern) )
}

par(mfcol <span style="color: #666666">=</span> c(<span style="color: #666666">1</span>, <span style="color: #666666">3</span>), mar <span style="color: #666666">=</span> c(<span style="color: #666666">0</span>, <span style="color: #666666">0</span>, <span style="color: #666666">2</span>, <span style="color: #666666">1</span>), ps <span style="color: #666666">=</span> <span style="color: #666666">18</span>)
plot(as.cimg(normalized_bayer_pattern(<span style="color: #666666">1</span>)), main <span style="color: #666666">=</span> <span style="color: #BA2121">"Bayer 2×2"</span>)
plot(as.cimg(normalized_bayer_pattern(<span style="color: #666666">2</span>)), main <span style="color: #666666">=</span> <span style="color: #BA2121">"Bayer 4×4"</span>)
plot(as.cimg(normalized_bayer_pattern(<span style="color: #666666">3</span>)), main <span style="color: #666666">=</span> <span style="color: #BA2121">"Bayer 8×8"</span>)
</pre></div></code></pre>

<p><img src="http://www.sumsar.net/figures/2019-01-22-image-dithering-in-r/unnamed-chunk-14-1.png" alt=""><!-- --></p>

<p>Basically, a Bayer matrix contains as many shades of gray it’s possible to fit in there, and the shades are as spread out as possible. Let’s see how a 4x4 Bayer matrix transforms the smooth gradient: </p>

<pre><code><div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">bayer_cimg <span style="color: #666666">&lt;-</span> as.cimg(rep_mat(normalized_bayer_pattern(<span style="color: #666666">2</span>),
                              nrow(gradient), ncol(gradient)))
gradient_bayer <span style="color: #666666">&lt;-</span> gradient <span style="color: #666666">&gt;</span> bayer_cimg
plot(gradient_bayer)
</pre></div></code></pre>

<p><img src="http://www.sumsar.net/figures/2019-01-22-image-dithering-in-r/unnamed-chunk-16-1.png" alt=""><!-- --></p>

<p>Pretty smooth! We get the classical “crosshatch” patterns reminiscent of last-century computer graphics. Let’s give Admiral Nelson the same treatment:</p>

<pre><code><div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">bayer_matrix <span style="color: #666666">&lt;-</span> rep_mat(normalized_bayer_pattern(<span style="color: #666666">2</span>),
                        nrow(nelson_gray), ncol(nelson_gray))
bayer_cimg <span style="color: #666666">&lt;-</span> as.cimg(bayer_matrix)
nelson_bayer <span style="color: #666666">&lt;-</span> nelson_gray <span style="color: #666666">&gt;</span> bayer_cimg
plot(nelson_bayer)
</pre></div></code></pre>

<p><img src="http://www.sumsar.net/figures/2019-01-22-image-dithering-in-r/unnamed-chunk-17-1.png" alt=""><!-- --></p>

<p>Now he looks doubly old-school. So far I’ve only worked with grayscale images and black-and-white dithering, but we can quickly hack together some color dithering by just performing the dither thresholding on one color channel at a time.</p>

<pre><code><div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">nelson_bayer_color <span style="color: #666666">&lt;-</span> nelson
<span style="color: #008000; font-weight: bold">for</span>(rgb_i <span style="color: #008000; font-weight: bold">in</span> <span style="color: #666666">1:3</span>) {
  color_channel <span style="color: #666666">&lt;-</span> nelson_bayer_color[ , , <span style="color: #666666">1</span>, rgb_i, drop <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">FALSE</span>]
  nelson_bayer_color[ , , <span style="color: #666666">1</span>, rgb_i] <span style="color: #666666">&lt;-</span> color_channel <span style="color: #666666">&gt;</span> bayer_cimg
}
plot(nelson_bayer_color)
</pre></div></code></pre>

<p><img src="http://www.sumsar.net/figures/2019-01-22-image-dithering-in-r/unnamed-chunk-18-1.png" alt=""><!-- --></p>

<p>This method does not generalize to arbitrary color scales, but I still think it looks pretty cool!</p>

<h2 id="image-dithering-ggplots-in-r">Image dithering ggplots in R</h2>

<p>Finally, I’ll show you how to dither some ggplots. Below is most of the code above wrapped up into functions:</p>

<pre><code><div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># rep_mat takes a matrix (mat) and tiles it so that the resulting</span>
<span style="color: #408080; font-style: italic"># matrix has size nrow_out × ncol_out.</span>
<span style="color: #408080; font-style: italic"># It's basically a 2d version of rep()</span>
rep_mat <span style="color: #666666">&lt;-</span> <span style="color: #008000; font-weight: bold">function</span>(mat, nrow_out, ncol_out) {
  mat[rep(seq_len(nrow(mat)), length.out <span style="color: #666666">=</span> nrow_out),
      rep(seq_len(ncol(mat)), length.out <span style="color: #666666">=</span> ncol_out)]
}

<span style="color: #408080; font-style: italic"># Calculates a Bayer pattern matrix of size 2^n</span>
<span style="color: #408080; font-style: italic"># Source: https://gist.github.com/MehdiNS/bd41bbc6db780c9409157d35d331ac80</span>
recursive_bayer_pattern <span style="color: #666666">&lt;-</span> <span style="color: #008000; font-weight: bold">function</span>(n) {
  <span style="color: #008000; font-weight: bold">if</span>(n <span style="color: #666666">&lt;=</span> <span style="color: #666666">0</span>) {
    <span style="color: #008000; font-weight: bold">return</span>(matrix(<span style="color: #666666">0</span>))
  }
  m <span style="color: #666666">&lt;-</span> recursive_bayer_pattern(n <span style="color: #666666">-</span> <span style="color: #666666">1</span>)
  rbind(
    cbind(<span style="color: #666666">4</span> <span style="color: #666666">*</span> m <span style="color: #666666">+</span> <span style="color: #666666">0</span>, <span style="color: #666666">4</span> <span style="color: #666666">*</span> m <span style="color: #666666">+</span> <span style="color: #666666">2</span>),
    cbind(<span style="color: #666666">4</span> <span style="color: #666666">*</span> m <span style="color: #666666">+</span> <span style="color: #666666">3</span>, <span style="color: #666666">4</span> <span style="color: #666666">*</span> m <span style="color: #666666">+</span> <span style="color: #666666">1</span>))
}

<span style="color: #408080; font-style: italic"># Returns a Bayer pattern of size 2^n normalized so all values</span>
<span style="color: #408080; font-style: italic"># are between 1 / (m + 1) and m / (m + 1) where m is the number </span>
<span style="color: #408080; font-style: italic"># of elements in the 2^n × 2^n matrix.</span>
normalized_bayer_pattern <span style="color: #666666">&lt;-</span> <span style="color: #008000; font-weight: bold">function</span>(n) {
  pattern <span style="color: #666666">&lt;-</span> recursive_bayer_pattern(n)
  (<span style="color: #666666">1</span> <span style="color: #666666">+</span> pattern) <span style="color: #666666">/</span> ( <span style="color: #666666">1</span> <span style="color: #666666">+</span> length(pattern) )
}

<span style="color: #408080; font-style: italic"># Returns a  nrow_out × ncol_out cimg image repeatig a 2×2 Bayer pattern</span>
rep_bayer_cimg <span style="color: #666666">&lt;-</span> <span style="color: #008000; font-weight: bold">function</span>(nrow_out, ncol_out) {
  bayer_matrix <span style="color: #666666">&lt;-</span> rep_mat(normalized_bayer_pattern(<span style="color: #666666">2</span>), nrow_out, ncol_out)
  as.cimg(bayer_matrix)
}

<span style="color: #408080; font-style: italic"># Transforms a cimg image into a dithered black and white image</span>
img_to_bayer_bw <span style="color: #666666">&lt;-</span> <span style="color: #008000; font-weight: bold">function</span>(img) {
  img <span style="color: #666666">&lt;-</span> grayscale(rm.alpha(img))
  bayer_cimg <span style="color: #666666">&lt;-</span> rep_bayer_cimg(nrow(img), ncol(img))
  img <span style="color: #666666">&gt;=</span> bayer_cimg
}

<span style="color: #408080; font-style: italic"># Transforms a cimg image into a dithered color image with 8 colors.</span>
img_to_bayer_color <span style="color: #666666">&lt;-</span> <span style="color: #008000; font-weight: bold">function</span>(img) {
  img <span style="color: #666666">&lt;-</span> rm.alpha(img)
  bayer_cimg <span style="color: #666666">&lt;-</span> rep_bayer_cimg(nrow(img), ncol(img))
  <span style="color: #008000; font-weight: bold">for</span>(rgb_i <span style="color: #008000; font-weight: bold">in</span> <span style="color: #666666">1:3</span>) {
    color_channel <span style="color: #666666">&lt;-</span> img[ , , <span style="color: #666666">1</span>, rgb_i, drop <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">FALSE</span>]
    img[ , , <span style="color: #666666">1</span>, rgb_i] <span style="color: #666666">&lt;-</span> color_channel <span style="color: #666666">&gt;=</span> bayer_cimg
  }
  img
}
</pre></div></code></pre>

<p>Let’s then create the ggplot we will transform.</p>

<pre><code><div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">library(ggplot2)
ggplot(mtcars, aes(factor(cyl), mpg, fill <span style="color: #666666">=</span> factor(cyl))) <span style="color: #666666">+</span>
  geom_violin(color <span style="color: #666666">=</span> <span style="color: #BA2121">"black"</span>) <span style="color: #666666">+</span>
  theme_classic() <span style="color: #666666">+</span>
  theme(axis.text<span style="color: #666666">=</span> element_text(colour<span style="color: #666666">=</span><span style="color: #BA2121">"black"</span>))
</pre></div></code></pre>

<p><img src="http://www.sumsar.net/figures/2019-01-22-image-dithering-in-r/unnamed-chunk-20-1.png" alt=""><!-- --></p>

<p>Then we’ll turn it into a low res <code>cimg</code> image.</p>

<pre><code><div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># This function is a hack to read in a ggplot2 plot as a cimg image </span>
<span style="color: #408080; font-style: italic"># by saving it as a png to disk and reading it back in.</span>
ggplot_to_cimg <span style="color: #666666">&lt;-</span> <span style="color: #008000; font-weight: bold">function</span>(width, height, dpi) {
  tmp_fname <span style="color: #666666">&lt;-</span> tempfile(fileext <span style="color: #666666">=</span> <span style="color: #BA2121">".png"</span>)
  ggsave(tmp_fname, width <span style="color: #666666">=</span> width, height <span style="color: #666666">=</span> height, dpi <span style="color: #666666">=</span> dpi, antialias <span style="color: #666666">=</span> <span style="color: #BA2121">"none"</span>)
  load.image(tmp_fname)
}

plot_img <span style="color: #666666">&lt;-</span> ggplot_to_cimg( width <span style="color: #666666">=</span> <span style="color: #666666">3</span>, height <span style="color: #666666">=</span> <span style="color: #666666">2</span>, dpi <span style="color: #666666">=</span> <span style="color: #666666">140</span>)
plot(plot_img)
</pre></div></code></pre>

<p><img src="http://www.sumsar.net/figures/2019-01-22-image-dithering-in-r/unnamed-chunk-21-1.png" alt=""><!-- --></p>

<p>Finally, we can turn it into a retro-dithered black and white plot…</p>

<pre><code><div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">plot( img_to_bayer_bw(plot_img) )
</pre></div></code></pre>

<p><img src="http://www.sumsar.net/figures/2019-01-22-image-dithering-in-r/unnamed-chunk-22-1.png" alt=""><!-- --></p>

<p>…or a dithered eight-color plot. </p>

<pre><code><div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">plot( img_to_bayer_color(plot_img) )
</pre></div></code></pre>

<p><img src="http://www.sumsar.net/figures/2019-01-22-image-dithering-in-r/unnamed-chunk-23-1.png" alt=""><!-- --></p>

<p>Something for your next retro inspired presentation, maybe? If you want to have full control over your image dithering it would probably be more convenient to post-process your plots using an image editor, such as the free and open source <a href="https://www.gimp.org/">GIMP</a> rather than to do it directly in R.</p>

<p>This post has covered basic image dithering in R and, to be more specific, it has covered <a href="https://en.wikipedia.org/wiki/Ordered_dithering">ordered dithering</a>. There is also <a href="https://en.wikipedia.org/wiki/Floyd%E2%80%93Steinberg_dithering">error-diffusion dithering</a> which works in a rather different way. But that’s for another time. Now I’m going to go back to mourning that I’ve already finished <a href="https://obradinn.com/">The Return of the Obra Dinn</a>.</p>

</body></html>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Yet another visualization of the Bayesian Beta-Binomial model]]></title>
    <link href="http://www.sumsar.net/blog/2018/12/visualizing-the-beta-binomial/"/>
    <updated>2018-12-13T23:30:00+00:00</updated>
    <id>http://www.sumsar.net/blog/2018/12/visualizing-the-beta-binomial</id>
    
      <category scheme="http://www.sumsar.net/blog/categories/" term="bayesian" />
    
      <category scheme="http://www.sumsar.net/blog/categories/" term="r" />
    
      <category scheme="http://www.sumsar.net/blog/categories/" term="statistics" />
    
    <content type="html"><![CDATA[<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><body>
<p>The Beta-Binomial model is the “hello world” of Bayesian statistics. That is, it’s the first model you get to run, often before you even know what you are doing. There are many reasons for this: </p>

<ul>
  <li>It only has one parameter, the underlying proportion of success, so it’s easy to visualize and reason about.</li>
  <li>It’s easy to come up with a scenario where it can be used, for example: “What is the proportion of patients that will be cured by this drug?”</li>
  <li>The model can be computed analytically (no need for any messy MCMC).</li>
  <li>It’s relatively easy to come up with an informative prior for the underlying proportion.</li>
  <li>Most importantly: It’s fun to see some results before diving into the theory! 😁</li>
</ul>

<p>That’s why I also introduced the Beta-Binomial model as the first model in my DataCamp course <a href="http://www.sumsar.net/blog/2018/12/my-introductory-course-on-bayesian-statistics/">Fundamentals of Bayesian Data Analysis in R</a> and quite a lot of people have asked me for the code I used to visualize the Beta-Binomial. Scroll to the bottom of this post if that’s what you want, otherwise, here is how I visualized the Beta-Binomial in my course given two successes and four failures:</p>

<center>
  <p>
    <img src="http://www.sumsar.net/images/posts/2018-12-13-visualizing-the-beta-binomial/prop_model_animation.gif" width="650">  
  </p>
</center>

<!-- more -->

<p>The function that produces these plots is called <code>prop_model</code> (<code>prop</code> as in proportion) and takes a vector of <code>TRUE</code>s and <code>FALSE</code>s representing successes and failures. The visualization is created using the excellent <a href="https://CRAN.R-project.org/package=ggridges"><code>ggridges</code> package</a>  (<a href="https://serialmentor.com/blog/2017/9/15/goodbye-joyplots">previously called joyplot</a>). Here’s how you would use <code>prop_model</code> to produce the last plot in the animation above:</p>

<pre><code><div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">data <span style="color: #666666">&lt;-</span> c(<span style="color: #008000; font-weight: bold">FALSE</span>, <span style="color: #008000; font-weight: bold">TRUE</span>, <span style="color: #008000; font-weight: bold">FALSE</span>, <span style="color: #008000; font-weight: bold">FALSE</span>, <span style="color: #008000; font-weight: bold">FALSE</span>, <span style="color: #008000; font-weight: bold">TRUE</span>)
prop_model(data)
</pre></div></code></pre>

<p><img src="http://www.sumsar.net/figures/2018-12-13-visualizing-the-beta-binomial/unnamed-chunk-2-1.png" alt=""></p>

<p>The result is, I think, a quite nice visualization of how the model’s knowledge about the parameter changes as data arrives. At <code>n=0</code> the model doesn’t know anything and — as the default prior states that it’s equally likely the proportion of success is anything from 0.0 to 1.0 — the result is a big, blue, and uniform square. As more data arrives the probability distribution becomes more concentrated, with the final posterior distribution at <code>n=6</code>. </p>

<p>Some added features of <code>prop_model</code> is that it also plots larger data somewhat gracefully and that it returns a random sample from the posterior that can be further explored. For example: </p>

<pre><code><div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">big_data <span style="color: #666666">&lt;-</span> sample(c(<span style="color: #008000; font-weight: bold">TRUE</span>, <span style="color: #008000; font-weight: bold">FALSE</span>), prob <span style="color: #666666">=</span> c(<span style="color: #666666">0.75</span>, <span style="color: #666666">0.25</span>),
                   size <span style="color: #666666">=</span> <span style="color: #666666">100</span>, replace <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">TRUE</span>)
posterior <span style="color: #666666">&lt;-</span> prop_model(big_data)
</pre></div></code></pre>

<p><img src="http://www.sumsar.net/figures/2018-12-13-visualizing-the-beta-binomial/unnamed-chunk-3-1.png" alt=""></p>

<pre><code><div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">quantile(posterior, c(<span style="color: #666666">0.025</span>, <span style="color: #666666">0.5</span>, <span style="color: #666666">0.975</span>))
</pre></div></code></pre>

<pre><code><div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic">## 2.5%  50%  98% </span>
<span style="color: #408080; font-style: italic">## 0.68 0.77 0.84</span>
</pre></div></code></pre>

<p>So here we calculated that the underlying proportion of success is most likely 0.77 with a 95% CI of [0.68, 0.84] (which nicely includes the correct value of 0.75 which we used to simulate <code>big_data</code>).</p>

<p>To be clear, <code>prop_model</code> is not intended as anything serious, it’s just meant as a nice way of exploring the Beta-Binomial model when learning Bayesian statistics, maybe as part of a workshop exercise.</p>

<h2 id="the-propmodel-function">The <code>prop_model</code> function</h2>

<pre><code><div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># This function takes a number of successes and failuers coded as a TRUE/FALSE</span>
<span style="color: #408080; font-style: italic"># or 0/1 vector. This should be given as the data argument.</span>
<span style="color: #408080; font-style: italic"># The result is a visualization of the how a Beta-Binomial</span>
<span style="color: #408080; font-style: italic"># model gradualy learns the underlying proportion of successes </span>
<span style="color: #408080; font-style: italic"># using this data. The function also returns a sample from the</span>
<span style="color: #408080; font-style: italic"># posterior distribution that can be further manipulated and inspected.</span>
<span style="color: #408080; font-style: italic"># The default prior is a Beta(1,1) distribution, but this can be set using the</span>
<span style="color: #408080; font-style: italic"># prior_prop argument.</span>

<span style="color: #408080; font-style: italic"># Make sure the packages tidyverse and ggridges are installed, otherwise run:</span>
<span style="color: #408080; font-style: italic"># install.packages(c("tidyverse", "ggridges"))</span>

<span style="color: #408080; font-style: italic"># Example usage:</span>
<span style="color: #408080; font-style: italic"># data &lt;- c(TRUE, FALSE, TRUE, TRUE, FALSE, TRUE, TRUE)</span>
<span style="color: #408080; font-style: italic"># prop_model(data)</span>
prop_model <span style="color: #666666">&lt;-</span> <span style="color: #008000; font-weight: bold">function</span>(data <span style="color: #666666">=</span> c(), prior_prop <span style="color: #666666">=</span> c(<span style="color: #666666">1</span>, <span style="color: #666666">1</span>), n_draws <span style="color: #666666">=</span> <span style="color: #666666">10000</span>) {
  library(tidyverse)
  data <span style="color: #666666">&lt;-</span> as.logical(data)
  <span style="color: #408080; font-style: italic"># data_indices decides what densities to plot between the prior and the posterior</span>
  <span style="color: #408080; font-style: italic"># For 20 datapoints and less we're plotting all of them.</span>
  data_indices <span style="color: #666666">&lt;-</span> round(seq(<span style="color: #666666">0</span>, length(data), length.out <span style="color: #666666">=</span> min(length(data) <span style="color: #666666">+</span> <span style="color: #666666">1</span>, <span style="color: #666666">20</span>)))

  <span style="color: #408080; font-style: italic"># dens_curves will be a data frame with the x &amp; y coordinates for the </span>
  <span style="color: #408080; font-style: italic"># denities to plot where x = proportion_success and y = probability</span>
  proportion_success <span style="color: #666666">&lt;-</span> c(<span style="color: #666666">0</span>, seq(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, length.out <span style="color: #666666">=</span> <span style="color: #666666">100</span>), <span style="color: #666666">1</span>)
  dens_curves <span style="color: #666666">&lt;-</span> map_dfr(data_indices, <span style="color: #008000; font-weight: bold">function</span>(i) {
    value <span style="color: #666666">&lt;-</span> ifelse(i <span style="color: #666666">==</span> <span style="color: #666666">0</span>, <span style="color: #BA2121">"Prior"</span>, ifelse(data[i], <span style="color: #BA2121">"Success"</span>, <span style="color: #BA2121">"Failure"</span>))
    label <span style="color: #666666">&lt;-</span> paste0(<span style="color: #BA2121">"n="</span>, i)
    probability <span style="color: #666666">&lt;-</span> dbeta(proportion_success,
                         prior_prop[<span style="color: #666666">1</span>] <span style="color: #666666">+</span> sum(data[seq_len(i)]),
                         prior_prop[<span style="color: #666666">2</span>] <span style="color: #666666">+</span> sum(<span style="color: #666666">!</span>data[seq_len(i)]))
    probability <span style="color: #666666">&lt;-</span> probability <span style="color: #666666">/</span> max(probability)
    data_frame(value, label, proportion_success, probability)
  })
  <span style="color: #408080; font-style: italic"># Turning label and value into factors with the right ordering for the plot</span>
  dens_curves<span style="color: #666666">$</span>label <span style="color: #666666">&lt;-</span> fct_rev(factor(dens_curves<span style="color: #666666">$</span>label, levels <span style="color: #666666">=</span>  paste0(<span style="color: #BA2121">"n="</span>, data_indices )))
  dens_curves<span style="color: #666666">$</span>value <span style="color: #666666">&lt;-</span> factor(dens_curves<span style="color: #666666">$</span>value, levels <span style="color: #666666">=</span> c(<span style="color: #BA2121">"Prior"</span>, <span style="color: #BA2121">"Success"</span>, <span style="color: #BA2121">"Failure"</span>))

  p <span style="color: #666666">&lt;-</span> ggplot(dens_curves, aes(x <span style="color: #666666">=</span> proportion_success, y <span style="color: #666666">=</span> label,
                               height <span style="color: #666666">=</span> probability, fill <span style="color: #666666">=</span> value)) <span style="color: #666666">+</span>
    ggridges<span style="color: #666666">::</span>geom_density_ridges(stat<span style="color: #666666">=</span><span style="color: #BA2121">"identity"</span>, color <span style="color: #666666">=</span> <span style="color: #BA2121">"white"</span>, alpha <span style="color: #666666">=</span> <span style="color: #666666">0.8</span>,
                                  panel_scaling <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">TRUE</span>, size <span style="color: #666666">=</span> <span style="color: #666666">1</span>) <span style="color: #666666">+</span>
    scale_y_discrete(<span style="color: #BA2121">""</span>, expand <span style="color: #666666">=</span> c(<span style="color: #666666">0.01</span>, <span style="color: #666666">0</span>)) <span style="color: #666666">+</span>
    scale_x_continuous(<span style="color: #BA2121">"Underlying proportion of success"</span>) <span style="color: #666666">+</span>
    scale_fill_manual(values <span style="color: #666666">=</span> hcl(<span style="color: #666666">120</span> <span style="color: #666666">*</span> <span style="color: #666666">2:0</span> <span style="color: #666666">+</span> <span style="color: #666666">15</span>, <span style="color: #666666">100</span>, <span style="color: #666666">65</span>), name <span style="color: #666666">=</span> <span style="color: #BA2121">""</span>, drop <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">FALSE</span>,
                      labels <span style="color: #666666">=</span>  c(<span style="color: #BA2121">"Prior   "</span>, <span style="color: #BA2121">"Success   "</span>, <span style="color: #BA2121">"Failure   "</span>)) <span style="color: #666666">+</span>
    ggtitle(paste0(
      <span style="color: #BA2121">"Binomial model - Data: "</span>, sum(data),  <span style="color: #BA2121">" successes, "</span> , sum(<span style="color: #666666">!</span>data), <span style="color: #BA2121">" failures"</span>)) <span style="color: #666666">+</span>
    theme_light() <span style="color: #666666">+</span>
    theme(legend.position <span style="color: #666666">=</span> <span style="color: #BA2121">"top"</span>)
  print(p)

  <span style="color: #408080; font-style: italic"># Returning a sample from the posterior distribution that can be further </span>
  <span style="color: #408080; font-style: italic"># manipulated and inspected</span>
  posterior_sample <span style="color: #666666">&lt;-</span> rbeta(n_draws, prior_prop[<span style="color: #666666">1</span>] <span style="color: #666666">+</span> sum(data), prior_prop[<span style="color: #666666">2</span>] <span style="color: #666666">+</span> sum(<span style="color: #666666">!</span>data))
  invisible(posterior_sample)
}
</pre></div></code></pre>

</body></html>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[My introductory course on Bayesian statistics]]></title>
    <link href="http://www.sumsar.net/blog/2018/12/my-introductory-course-on-bayesian-statistics/"/>
    <updated>2018-12-12T22:30:00+00:00</updated>
    <id>http://www.sumsar.net/blog/2018/12/my-introductory-course-on-bayesian-statistics</id>
    
      <category scheme="http://www.sumsar.net/blog/categories/" term="bayesian" />
    
      <category scheme="http://www.sumsar.net/blog/categories/" term="r" />
    
      <category scheme="http://www.sumsar.net/blog/categories/" term="statistics" />
    
    <content type="html"><![CDATA[<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><body>
<p>So, after having held workshops introducing Bayes for a couple of years now, I finally pulled myself together and completed my DataCamp course: <a href="https://www.datacamp.com/courses/fundamentals-of-bayesian-data-analysis-in-r">Fundamentals of Bayesian Data Analysis in R</a>! 😁</p>

<p><a href="https://www.datacamp.com/courses/fundamentals-of-bayesian-data-analysis-in-r"><img src="http://www.sumsar.net/images/posts/2018-12-12-my-introductory-course-on-bayesian-statistics/bayes-course-shield-small.png" alt=""></a></p>

<!-- more -->

<p>While it’s called a course, it’s more like a 4 hour workshop and — without requiring anything but basic R skills and a vague notion of probability — it introduces Bayesian data analysis from scratch. The whole course is done <em>online</em>, coding and all, using DataCamp’s interactive course interface (like Rstudio, but in the browser) and, while you need a DataCamp subscription to do the full course, you can <em>do the first part for free</em> by just signing into DataCamp! If you feel that’s too much of a commitment you have the first two videos in the course right here: </p>

<center><iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/Olz1dJM3uLE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen=""></iframe></center>

<p>Please try it out and let me know what you think! </p>

<h3 id="where-to-go-after-the-course">Where to go after the course?</h3>

<p>As always I recomend either of the following two excelent introductions to Bayesia data analysis:</p>

<ul>
  <li>
    <p><a href="https://www.amazon.com/gp/product/1482253445/ref=as_li_qf_asin_il_tl?ie=UTF8&amp;tag=sumsarnet-20&amp;creative=9325&amp;linkCode=as2&amp;creativeASIN=1482253445&amp;linkId=72b763f899422ed939d39d8c5d08a57d"><em>Statistical Rethinking: A Bayesian Course with Examples in R and Stan</em> by Richard McElreath </a></p>
  </li>
  <li>
    <p><a href="https://www.amazon.com/gp/product/0124058884/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0124058884&amp;linkCode=as2&amp;tag=sumsarnet-20&amp;linkId=a0241b5529f6736dd6ac5d4e5b5708be"><em>Doing Bayesian Data Analysis</em> by John Kruschke</a></p>
  </li>
</ul>

<p>My DataCamp course roughly covers chapters 1-3 in <em>Statistical Rethinking</em> so you’ll already have a headstart on that one.</p>

</body></html>
]]></content>
  </entry>
  
</feed>

