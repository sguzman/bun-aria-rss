<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	>

<channel>
	<title>The Shape of Data</title>
	<atom:link href="https://shapeofdata.wordpress.com/feed/" rel="self" type="application/rss+xml" />
	<link>https://shapeofdata.wordpress.com</link>
	<description>Exploring the geometry behind machine learning, data mining, etc.</description>
	<lastBuildDate>Tue, 06 Dec 2016 03:22:21 +0000</lastBuildDate>
	<language>en</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
<cloud domain='shapeofdata.wordpress.com' port='80' path='/?rsscloud=notify' registerProcedure='' protocol='http-post' />
<image>
		<url>https://s0.wp.com/i/buttonw-com.png</url>
		<title>The Shape of Data</title>
		<link>https://shapeofdata.wordpress.com</link>
	</image>
	<atom:link rel="search" type="application/opensearchdescription+xml" href="https://shapeofdata.wordpress.com/osd.xml" title="The Shape of Data" />
	<atom:link rel='hub' href='https://shapeofdata.wordpress.com/?pushpress=hub'/>
	<item>
		<title>Properties of Interpretability</title>
		<link>https://shapeofdata.wordpress.com/2016/12/05/properties-of-interpretability/</link>
					<comments>https://shapeofdata.wordpress.com/2016/12/05/properties-of-interpretability/#comments</comments>
		
		<dc:creator><![CDATA[Jesse Johnson]]></dc:creator>
		<pubDate>Tue, 06 Dec 2016 03:22:21 +0000</pubDate>
				<category><![CDATA[Interpretability]]></category>
		<guid isPermaLink="false">http://shapeofdata.wordpress.com/?p=2226</guid>

					<description><![CDATA[In my last two posts, I wrote about model interpretability, with the goal of trying to understanding what it means and how to measure it. In the first post, I described the disconnect between our mental models and algorithmic models, &#8230; <a href="https://shapeofdata.wordpress.com/2016/12/05/properties-of-interpretability/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p>In my last two posts, I wrote about model interpretability, with the goal of trying to understanding what it means and how to measure it. In the <a href="https://shapeofdata.wordpress.com/2016/10/26/interacting-with-ml-models/">first post</a>, I described the disconnect between our mental models and algorithmic models, and how interpretability could potentially reduce it. In the <a href="https://shapeofdata.wordpress.com/2016/11/17/goals-of-interpretability/">second post</a>, I laid out four things that a model interpretation should allow us to do &#8211; mitigate bias, account for context, extract knowledge and generalize. In this post, I want to discuss a number of desirable properties that have been suggested for model interpretations, and that might be used to judge whether and how much a model or explanation is interpretable.</p>
<p><span id="more-2226"></span>As I noted previously, while there are many papers in the research literature that describe interpretable models, or ways of adding a layer of interpretability on top of existing models, most of these papers are not explicit about what they mean by interpretability. Two exceptions that I&#8217;ve found (though there are probably others) are Ribeiro, Singh and Guestrin&#8217;s paper on <a href="https://arxiv.org/abs/1602.04938">Locally Interpretable Model-agnostic Explanations (LIME)</a> and Kulesza, Wong, Burnett and Stumpf&#8217;s paper on <a href="https://www.researchgate.net/profile/Todd_Kulesza/publication/274383208_Principles_of_Explanatory_Debugging_to_Personalize_Interactive_Machine_Learning/links/551d8cef0cf213ef063e6c2f.pdf">Principles of Explanatory Debugging (PED)</a>. The properties I&#8217;ll propose below are taken from these two papers, with different names and a few modifications.</p>
<p>It&#8217;s also worth mentioning a distinction that Zack Lipton makes in his <a href="https://arxiv.org/abs/1606.03490">Mythos of Model Interpretability</a>, between transparency &#8211; explaining the way the whole model works &#8211; and post-hoc interpretability &#8211; explaining how individual predictions were made, without necessarily describing the process for calculating them. Even though most of what I&#8217;ve written previously on this blog has focused on transparency, this post and the rest of this series of posts will focus on post-hoc interpretability.</p>
<p>So, here are the seven properties. A post-hoc model interpretation should be:</p>
<p><strong>Concise.</strong> Both the LIME paper and the PED paper point out that an explanation should not overwhelm the user with details about how a prediction was made. A central goal of machine learning is to deal with the complexity that we can&#8217;t or don&#8217;t want to incorporate into our mental models. If an interpretation forces the user to consider all the features and coefficients that went into the model, that defeats the purpose. An explanation should minimize the cognitive load required of the user.</p>
<p>For example, if a prediction can be explained by indicating 100 or 1000 factors that contributed to the value, it would be more concise to have the explanation algorithm pick out the top 5 according to some notion of importance, and only present those. Of course, if you make an explanation too concise, it may cease to be useful. So you&#8217;ll always want to balance making an explanation concise against the the other desirable properties, particularly:</p>
<p><strong>Faithful.</strong> The explanation should accurately describe the way the model made the prediction. For example, you might try explaining the predictions from a neural network by separately training a linear model, then presenting the features that contributed to the linear model&#8217;s prediction (which are relatively easy to determine) as the features that <em>probably</em> had the most impact on the neural net&#8217;s prediction. This explanation would not be faithful, since it does not describe the actual model. The authors of PED use the term <em>sound</em> for this property, and the LIME paper calls it <em>local fidelity</em>.</p>
<p><strong>Complete.</strong> An explanation is <em>complete</em> if it explains all the factors and elements that went into a prediction. In order to be concise, an explanation should never be absolutely complete, but you can measure how complete (how close to complete?) it is. The authors of the PED paper have an earlier paper, <a href="https://pdfs.semanticscholar.org/b56b/1e0acd3301c925bb2b074fe3fb8e0dbf5379.pdf">Too Much, Too Little or Just Right?</a> that examines the tradeoff between a model being concise, faithful (sound) and complete.</p>
<p><strong>Comparable.</strong> An explanation should help you compare different models to each other by examining how they handle individual examples. The LIME authors call this <em>model agnostic</em>. This is relatively straightforward for explanation algorithms that can be applied to multiple types of models, and defines the same form of explanation for all of them. It&#8217;s trickier for interpretable models that provide an explanation in a form that&#8217;s specific to that type of model. But if the explanation gives enough insight into how the prediction was made, it could still be comparable.</p>
<p><strong>Global.</strong> The explanation should indicate how each individual prediction fits into the overall structure of the model. The LIME authors call this a <em>global perspective. It&#8217;s </em>related to the notion <em>transparency</em> I mentioned above &#8211; understanding how the whole model works. However, a global explanation only has to indicate enough of the model&#8217;s structure to provide reasonable context for each individual prediction. Is the predicted value especially high or low? Were there a lot of nearby points in the training set? Is the variance between these data points high? Is the prediction based on extrapolating from lots of unrelated data points (and thus less reliable)?</p>
<p><strong>Consistent.</strong> Users will typically interact with a model over and over again. Ideally, they should learn more about the model over time and make better decisions as a result. This is a major theme in the PED paper, since it focuses on debugging models through repeated explanations. An explanation algorithm is <em>consistent</em> if each successive explanation helps the user to better understand later predictions. Perhaps more importantly, the user should never perceive a contradiction between different explanations. For example, if a feature increases a risk prediction for one data point but decreases it for another data point, the explanations should include enough information for the user to understand why.</p>
<p><strong>Engaging.</strong> The PED paper notes that an explanation should encourage a user to pay attention to the important details, and they point to research showing (not surprisingly) that users who pay more attention to explanations become familiar with the model faster and ultimately make better decisions. Some of this is covered by the earlier properties: If the explanations aren&#8217;t concise, the users&#8217; eyes will glaze over. If they aren&#8217;t faithful and consistent, the users will be distracted by the inconsistencies. But there&#8217;s more to being engaging than just those properties, and it should be considered separately.</p>
<p>This last property has a lot to do with how the explanation is presented rather than the explanation itself, so you could argue that it&#8217;s more of a <a href="https://en.wikipedia.org/wiki/User_experience">User Experience</a> (UX) issue. But in case you didn&#8217;t notice, this whole post has been secretly about UX &#8211; how users interact with an interface that happens to have an ML model behind it. Interpretability is as much a UX problem as it is a machine learning problem, which is part of what makes it both so interesting and so difficult.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://shapeofdata.wordpress.com/2016/12/05/properties-of-interpretability/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
		
		<media:content url="https://1.gravatar.com/avatar/436b5ec3552d5e81ed4f45de75d36397?s=96&#38;d=https%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D96&#38;r=G" medium="image">
			<media:title type="html">jessejohnson</media:title>
		</media:content>
	</item>
		<item>
		<title>Goals of Interpretability</title>
		<link>https://shapeofdata.wordpress.com/2016/11/17/goals-of-interpretability/</link>
					<comments>https://shapeofdata.wordpress.com/2016/11/17/goals-of-interpretability/#comments</comments>
		
		<dc:creator><![CDATA[Jesse Johnson]]></dc:creator>
		<pubDate>Thu, 17 Nov 2016 14:25:10 +0000</pubDate>
				<category><![CDATA[Interpretability]]></category>
		<category><![CDATA[Uncategorized]]></category>
		<guid isPermaLink="false">http://shapeofdata.wordpress.com/?p=2001</guid>

					<description><![CDATA[In my last post, I looked at the gap that arises when we delegate parts of our thought processes to algorithmic models, rather than incorporating the rules they identify directly into our mental models, like we do with traditional statistics. I &#8230; <a href="https://shapeofdata.wordpress.com/2016/11/17/goals-of-interpretability/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p>In my <a href="https://shapeofdata.wordpress.com/2016/10/26/interacting-with-ml-models/">last post</a>, I looked at the gap that arises when we delegate parts of our thought processes to algorithmic models, rather than incorporating the rules they identify directly into our mental models, like we do with traditional statistics. I described how the the idea of <em>model interpretability</em> can make the delegation process smoother by helping to break down the barriers between algorithmic and mental models. An increasing number of research papers these days claim to describe models that are interpretable, or ways of adding a layer of interpretability to existing models, but most of them rely on an implicit, intuitive definition of interpretability, usually one that suits their particular results. It would be nice if there was a canonical notion of what interpretability means. In the next few posts, I plan to explore what such a definition might look like and how you might tell whether a given algorithm is interpretable. In this post, I&#8217;ll explore this question from the angle of goals: What should an interpretable model allow you to do that a non-interpretable model can&#8217;t.</p>
<p><span id="more-2001"></span>The research literature identifies many different reasons to want model interpretability, many of which are described in Zack Lipton&#8217;s <a href="https://arxiv.org/abs/1606.03490">Mythos of Model Interpretability</a>. Zack organizes these into four categories &#8211; Trust, Causality, Transferability and Informativeness. (Read the paper for what these mean.) I&#8217;m going to suggest a slightly different set of categories based on the question &#8220;If I have an interpretable model, what should it allow me to do?&#8221; I&#8217;m not suggesting that an interpretable model should do all the things below, but it should do at least some of them. Though if you think this scheme leaves something out, please let me know in the comments!</p>
<p>So, here it is: An interpretable model should allow you to&#8230;</p>
<p><strong>Identify and Mitigate Bias.</strong> All models are biased &#8211; both algorithmic models and mental models. In fact, algorithmic models can magnify the bias of our mental models, as <a href="https://mathbabe.org/">Cathy O&#8217;Neil</a> has written <a href="https://weaponsofmathdestructionbook.com/">extensively</a> about. You can never completely eliminate bias, but you can often fix the more egregious forms, or at least choose not to use the models that are biased in unacceptable ways. This is roughly what Zack and others refer to as <em>trust</em>. It seems to be the most common motivation for interpretability described in the literature, probably because it&#8217;s of primary interest to the people who are developing the algorithm model, convincing others to use it, and then writing papers about it.</p>
<p>In fact, the ability to understand the biases in a model can be more important than accuracy for model adoption. For example, the introduction of <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.704.9327&amp;rep=rep1&amp;type=pdf">this paper</a> describes a case where a large healthcare project chose a rule-based model over a more accurate neural network for predicting mortality risk for patients with pneumonia. The decision was made after they discovered a rule in the rule-based system suggesting that having asthma lowered one&#8217;s risk of dying from pneumonia. It turned out this was true, only because pneumonia patients with pre-existing asthma were consistently given more aggressive treatments that led to better outcomes. However, the model would have suggested they required less treatment since they were at lower risk. The group running the project realized that the neural network probably had similar biases, but they had no way of telling what or how bad they were. So they decided to go with the model whose biases they could recognize, and thus mitigate.</p>
<p>Recognizing the biases in our mental models is notoriously difficult, but recognizing bias in a black-box algorithmic model is even harder. With our mental models, we can use self-reflection and the ability to recognize new factors to reduce bias. Algorithmic models can train on larger data sets and treat all data points equally, but they can&#8217;t self-reflect. The right type of interpretability could allow us to apply &#8220;self-reflection&#8221; to algorithmic models and get the best of both worlds.</p>
<p><strong>Account for context.</strong> This is essentially what I wrote about in my <a href="https://shapeofdata.wordpress.com/2016/10/26/interacting-with-ml-models/">last post</a>, so I won&#8217;t go into additional detail here. As I described previously, an algorithmic model can never account for all the factors that will affect the decision that the user finally makes. An interpretable model that helps you understand how the factors that are included in the model led to a prediction should allow you to adjust how you use the prediction based on these additional factors.</p>
<p><strong>Extract Knowledge.</strong> Algorithmic models often have a form that&#8217;s incompatible with mental models. Mental models are made up of relatively simple causal relationships, augmented by flexible, subconscious intuition. Algorithmic models are essentially <a href="https://shapeofdata.wordpress.com/2014/01/28/configuration-spaces-and-the-meaning-of-probability/">probability distributions</a> that measure correlations between rigidly defined values. However, if you look at a series of predictions from a model, the pattern recognition parts of your brain won&#8217;t be able to help themselves from trying to extract rules to add to your mental models. The problem is that these patterns may not be real, particularly if the set of examples you look at is biased.</p>
<p>An interpretable model should help you to determine if the patterns that appear to be present in the model are really there, or just artifacts of a biased set of examples. This is similar to identifying bias, as described above, except that here you&#8217;re learning from the model rather than evaluating it. With an interpretable model, you should be able to combine the strong pattern recognition and simplification skills of the human mind with the algorithmic model&#8217;s ability to learn from massive amounts of data. For example, there&#8217;s now a fair amount of research on causal inference in algorithmic models. A causal algorithmic model should be more compatible with mental models that rely heavily on causal reasoning, making it even easier to extract rules that can be incorporated into your mental models. Zack&#8217;s <em>Mythos</em> paper includes causality as a motive for interpretability, though this isn&#8217;t the only type of rule you might want to extract.</p>
<p><strong>Generalize.</strong> Algorithmic models are trained on carefully collected datasets to solve narrowly defined problems. Mental models are trained on a fire hose of input and applied to vaguely defined problems that they usually weren&#8217;t trained for. If you find an algorithmic model that works well for the problem it was trained on, you may be tempted to apply it to other problems, given how well that seems to work for mental models. In some cases, it might work for algorithmic models too, but in many cases it won&#8217;t. An interpretable model should help you determine if and how it can be generalized.</p>
<p>For example, lets say that the pneumonia risk model described above works out really well and you want to use it to predict risks for other types of lung infections. A good approach to interpretability might tell you that the model relies on properties of pneumonia that are different for other infections. So you&#8217;d better create a new model for them. In fact, you could argue that this is what happened in the case described above: They tried to use a model that was trained to predict mortality risk for the problem of predicting which patients required the most care. In this case, they didn&#8217;t even realize they were generalizing until they tried to interpret one of the models.</p>
<p>So, there&#8217;s my proposal for the main motivations of interpretability: An interpretable model should allow you to identify and mitigate bias, account for context, extract knowledge and generalize. There&#8217;s a fair amount of overlap between these, but they capture the different types of motivations I&#8217;ve seen in the literature. In my next few posts, I&#8217;ll use these motivations as a lens through which we can look for ways to tell when models are interpretable.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://shapeofdata.wordpress.com/2016/11/17/goals-of-interpretability/feed/</wfw:commentRss>
			<slash:comments>3</slash:comments>
		
		
		
		<media:content url="https://1.gravatar.com/avatar/436b5ec3552d5e81ed4f45de75d36397?s=96&#38;d=https%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D96&#38;r=G" medium="image">
			<media:title type="html">jessejohnson</media:title>
		</media:content>
	</item>
		<item>
		<title>Interacting with ML Models</title>
		<link>https://shapeofdata.wordpress.com/2016/10/26/interacting-with-ml-models/</link>
					<comments>https://shapeofdata.wordpress.com/2016/10/26/interacting-with-ml-models/#comments</comments>
		
		<dc:creator><![CDATA[Jesse Johnson]]></dc:creator>
		<pubDate>Wed, 26 Oct 2016 20:46:19 +0000</pubDate>
				<category><![CDATA[Interpretability]]></category>
		<guid isPermaLink="false">http://shapeofdata.wordpress.com/?p=1754</guid>

					<description><![CDATA[The main difference between data analysis today, compared with a decade or two ago, is the way that we interact with it. Previously, the role of statistics was primarily to extend our mental models by discovering new correlations and causal &#8230; <a href="https://shapeofdata.wordpress.com/2016/10/26/interacting-with-ml-models/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p>The main difference between data analysis today, compared with a decade or two ago, is the way that we interact with it. Previously, the role of statistics was primarily to extend our mental models by discovering new correlations and causal rules. Today, we increasingly delegate parts of our reasoning processes to algorithmic models that live outside our mental models. In my next few posts, I plan to explore some of the issues that arise from this delegation and how ideas such as model interpretability can potentially address them. Throughout this series of posts, I will argue that while current research has barely scratched the surface of understanding the interaction between algorithmic and mental models, these issues will be much more important to the future of data analysis than the technical performance of the models themselves.  In this first post, I&#8217;ll use a relatively mundane case study &#8211; personalized movie recommendations &#8211; to demonstrate some of these issues, keeping in mind that the same issues impact models in more serious contexts like healthcare and finance.</p>
<p><span id="more-1754"></span>The most common way that you delegate a part of your thought process to an algorithmic model these days is probably with personalized recommendation systems. For example, the ratings you see on a movie streaming site are often calculated based on what you&#8217;ve watched or liked in the past. Such a system might look at things like the genre of each movie, its actors and director, or how much &#8220;viewers similar to you&#8221; liked it.</p>
<p>But when you actually select a movie, you consider a number of factors that aren&#8217;t part of the model, such as the kind of mood you&#8217;re in, how much time you have or who you&#8217;re watching it with. The video streaming site could try to account for some of these by adding additional factors into the model, but they can never get all of them. No matter how complex they make the model, there will always be factors that could not have been anticipated when it was trained. If you completely delegate the decision to the model, picking the highest rated movie without accounting for these external factors, you&#8217;ll probably be in for a rude surprise.</p>
<p>Your mental models, on the other hand, can adapt to account for new and unexpected factors when you make the decision. So when you select a video, you have to combine the algorithmic recommendation with your own mental model of what type of movie you would like in the current context. Your mental model will include complex relationships between some of the factors used in the algorithmic model and the contextual factors that aren&#8217;t included. The better you can understand how the algorithmic model used the different factors to arrive at its prediction, the better equipped you will be to adjust the algorithmic recommendation based on contextual factors.</p>
<p>Imagine you see a musical comedy that is rated 4.2 out of five stars. From the number alone, you don&#8217;t know if that score is for its music or for its humor. If you&#8217;re in the mood for a comedy, you don&#8217;t want to pick a movie that isn&#8217;t very funny, but has great music. So with just the number, you&#8217;ll probably have to come up with your own estimation of how much you&#8217;ll like the movie, ignoring the algorithmic rating entirely. You effectively have to choose between using the algorithmic model without context or using your mental model without the help of the algorithm.</p>
<p>For the rating to be useful, it needs to come with additional hints about how it was calculated. For example, the result might point to a similar movie that you previously watched or rated highly. Or it might point to the factor that most contributed to the rating, such as the genre or the lead actor. While neither of these completely explain how the rating was calculated, they give you some amount of insight, which you can use to mentally adjust the rating based on additional context. You still don&#8217;t want to delegate the entire decision to the model, but you can delegate a part of the thought process. A model that can produce such insights is often called <em>interpretable</em>, though this term is used with a wide range of meanings in the literature.</p>
<p>In this example, even without hints for interpreting the predictions, you can probably still gain some information from the algorithmic model because you have a very good mental model of the types of movies that you like. But if you&#8217;re trying to understand a more complex and less intuitive system or situation &#8211; financial markets, human health, politics &#8211; you will have a less reliable mental model and will need to rely much more heavily on whatever information you can get from the algorithmic model. If we want algorithmic models to be successful in these types of contexts, we need to be able to present their predictions in ways that allow users to seamlessly and accurately interpret them, so they can delegate more of the decision making process while minimizing the risk of a nasty surprise.</p>
<p>In some sense, an interpretable model pokes holes in the barrier between the algorithmic model and your mental model. The ideal, of course, would be to break down the barrier entirely, so that you can fully incorporate the information from the algorithmic model into your mental model&#8217;s assessment. That&#8217;s probably impossible, but I&#8217;m convinced that we can poke significantly larger holes than have been made so far.</p>
<p>In my next few posts, I will discuss a number of different ways that researchers have tried to understand what interpretability means and to develop interpretable models. This is a subtle problem at the boundary between psychology and technology, with many directions that are waiting to be explored. I&#8217;m very excited to see how this field develops over the next few years.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://shapeofdata.wordpress.com/2016/10/26/interacting-with-ml-models/feed/</wfw:commentRss>
			<slash:comments>7</slash:comments>
		
		
		
		<media:content url="https://1.gravatar.com/avatar/436b5ec3552d5e81ed4f45de75d36397?s=96&#38;d=https%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D96&#38;r=G" medium="image">
			<media:title type="html">jessejohnson</media:title>
		</media:content>
	</item>
		<item>
		<title>LSTMs</title>
		<link>https://shapeofdata.wordpress.com/2016/06/04/lstms/</link>
					<comments>https://shapeofdata.wordpress.com/2016/06/04/lstms/#comments</comments>
		
		<dc:creator><![CDATA[Jesse Johnson]]></dc:creator>
		<pubDate>Sat, 04 Jun 2016 13:01:21 +0000</pubDate>
				<category><![CDATA[Neural Networks]]></category>
		<guid isPermaLink="false">http://shapeofdata.wordpress.com/?p=1485</guid>

					<description><![CDATA[In past posts, I&#8217;ve described how Recurrent Neural Networks (RNNs) can be used to learn patterns in sequences of inputs, and how the idea of unrolling can be used to train them. It turns out that there are some significant &#8230; <a href="https://shapeofdata.wordpress.com/2016/06/04/lstms/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p>In past posts, I&#8217;ve described how <a href="https://shapeofdata.wordpress.com/2015/10/20/recurrent-neural-networks/">Recurrent Neural Networks</a> (RNNs) can be used to learn patterns in sequences of inputs, and how the idea of <a href="https://shapeofdata.wordpress.com/2016/04/27/rolling-and-unrolling-rnns/">unrolling</a> can be used to train them. It turns out that there are some significant limitations to the types of patterns that a typical RNN can learn, due to the way their weight matrices are used. As a result, there has been a lot of interest in a variant of RNNs called Long Short-Term Memory networks (LSTMs). As I&#8217;ll describe below, LSTMs have more control than typical RNNs over what they remember, which allows them to learn much more complex patterns.</p>
<p><span id="more-1485"></span>Lets start with what I mean  by a &#8220;typical&#8221; RNN. In my post on RNNs, I mentioned three basic types of operations in the computation graph: 1) Outputs from nodes (which may be earlier or later in the network) can be concatenated into higher-dimensional vectors, for example to mix the current input vector with a vector that was calculated in a previous step. 2) Vectors can be multiplied by weight matrices, to combine and transform the concatenated vectors. 3) A fixed non-linear transformation can be applied to the output from each node in the computation graph.</p>
<p>The limitation with the RNNs defined by these three operations stems from the fact that while the weight matrices are updated during the training phase, they&#8217;re fixed while each sequence of inputs is processed. So each step in the input sequence is combined with the information stored from earlier steps in the same way each time. In some sense, the network is forced to remember the same things about each step in every sequence, even though some steps may be more important, or contain different types of information, than others.</p>
<p>An LSTM, on the other hand, is designed to be able to control what it remembers about each input, and to learn how to decide what to remember in the training phase. The key additional operation that goes into an LSTM is 4) Output vectors from nodes in the computation graph can by multiplied component-wise. In other words, the values in the first dimension of each vector are multiplied together to get the first dimension of a new vector. Then the second dimensions of the two vectors are multiplied, and so on.</p>
<p>This is not a linear transformation, in the sense that you can&#8217;t get the same result by concatenating the two vectors, then multiplying by a weight matrix. Instead, this is more like treating one of the input vectors as a  weight matrix that you&#8217;ll multiply the other output vector by. But unlike the weight matrices in a typical RNN, this &#8220;weight matrix&#8221; vector is determined by a computation somewhere else in the network, so it&#8217;s determined when the new data is processed, rather than fixed throughout the evaluation phase.</p>
<p>This &#8220;weight matrix&#8221; vector is in many ways not as impressive as one of the built-in weight matrices in a typical RNN. It&#8217;s equivalent to a matrix with the values of the vector along the diagonals, and the rest of the entries equal to zero. So it can&#8217;t do anything fancy to the other vector. Instead, you should think of it as a sort of filter that decides what parts of the other vector are important. In particular, if the &#8220;weight matrix&#8221; vector is zero in a given dimension then the result of multiplication will be zero in that dimension, no matter what the value was for that dimension in the other vector. If it&#8217;s close to 1, the output value is exactly equal to the value of the other vector in that dimension. (And a non-linear transformation is often applied to make sure the &#8220;weight matrix&#8221; values are very close to either 0 or 1.) So the &#8220;weight matrix&#8221; vector chooses what parts of a second vector get passed on to the next step. Because of this, the nodes in the computation graph where a &#8220;weight matrix&#8221; vector gets multiplied by a data vector is often called a <em>gate</em>.</p>
<p>An LSTM uses this fancy new fourth operation to create three gates, illustrated in the Figure below. This shows the inside of a single cell in an LSTM, and we&#8217;ll see farther down how this cell gets hooked up on the outside.</p>
<p>The LSTM cell has two inputs and two outputs. The output at the top (labeled <em>out</em>) is the actual RNN output, i.e. the output vector that you will use to evaluate and train the network. The output on the right (labeled <em>mem</em>) is the &#8220;memory&#8221; output, a vector that the LSTM wants to record for the next step. Similarly, the input on the bottom (labeled <em>in</em>) is the same as the input to a standard RNN, i.e. the next input vector in the sequence. The input on the right (also labeled <em>mem</em>) is the &#8220;memory&#8221; vector that was output from the LSTM cell during the previous step in the sequence. You should think of the LSTM as using the new input to update the value of the memory vector before passing it on to the next step, then using the new memory value to generate the actual output for the step.</p>
<p><img data-attachment-id="1631" data-permalink="https://shapeofdata.wordpress.com/2016/06/04/lstms/lstm/" data-orig-file="https://shapeofdata.files.wordpress.com/2016/06/lstm.png" data-orig-size="414,378" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="LSTM" data-image-description="" data-image-caption="" data-medium-file="https://shapeofdata.files.wordpress.com/2016/06/lstm.png?w=300" data-large-file="https://shapeofdata.files.wordpress.com/2016/06/lstm.png?w=414" class=" size-full wp-image-1631 alignleft" src="https://shapeofdata.files.wordpress.com/2016/06/lstm.png?w=640" alt="LSTM" srcset="https://shapeofdata.files.wordpress.com/2016/06/lstm.png 414w, https://shapeofdata.files.wordpress.com/2016/06/lstm.png?w=150 150w, https://shapeofdata.files.wordpress.com/2016/06/lstm.png?w=300 300w" sizes="(max-width: 414px) 100vw, 414px"   />When a new input vector comes in through the bottom of the LSTM, it is multiplied by the weight matrix <img src="https://s0.wp.com/latex.php?latex=M_%7Bin%7D&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" srcset="https://s0.wp.com/latex.php?latex=M_%7Bin%7D&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=M_%7Bin%7D&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x" alt="M_{in}" class="latex" />, which puts it into the same form as the memory vector. We want to combine this with the memory vector using gates like we described above. So the input vector is also concatenated with the previous cycle&#8217;s memory vector, and this is multiplied by three different weight matrices: <img src="https://s0.wp.com/latex.php?latex=M_R&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" srcset="https://s0.wp.com/latex.php?latex=M_R&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=M_R&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x" alt="M_R" class="latex" /> controls what the cell &#8220;remembers&#8221; about the input, <img src="https://s0.wp.com/latex.php?latex=M_F&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" srcset="https://s0.wp.com/latex.php?latex=M_F&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=M_F&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x" alt="M_F" class="latex" /> controls what the cell &#8220;forgets&#8221; from memory and <img src="https://s0.wp.com/latex.php?latex=M_%7Bout%7D&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" srcset="https://s0.wp.com/latex.php?latex=M_%7Bout%7D&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=M_%7Bout%7D&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x" alt="M_{out}" class="latex" /> controls what part of the current memory is output at the top. The results of each multiplication are fed through a non-linear transformation that I didn&#8217;t include in the Figure.</p>
<p>Then these vectors are fed into gates, defined by our new network operation (indicated by a circle with a dot in it) as shown in the Figure. The middle gate filters the memory vector from the previous step and the bottom gate filters the transformed input vector. These two gated vectors are then added together to produce the memory vector for this step. In addition to becoming the memory vector that is sent to the next step in the LSTM, the memory vector is also filtered by the top gate to produce the actual output from the LSTM.</p>
<p>The key step in this process is how the memory vector and the transformed input vector are independently gated before being added together. In the simplest setup, each of the &#8220;weight matrix&#8221; vectors would have all their values 0 or 1, and these would be complementary between the two gates, so that each dimension gets the value from one or the other. The values, which are calculated from both the current input and the current memory vector, would thus determine which of the dimensions in the memory vector should be passed on to the next step, and which should be replaced with the corresponding value from the transformed input vector. But in practice, the network gets to &#8220;learn&#8221; whatever behavior is most effective for producing the desired output patterns, so it may be much more complex.</p>
<p>Speaking of which, lets quickly look at how an LSTM is trained, using the idea of <a href="https://shapeofdata.wordpress.com/2016/04/27/rolling-and-unrolling-rnns/">unrolling</a> that I described in my previous post. As you probably picked up from the discussion above, we hook up an LSTM externally by adding an edge from the right memory out, back around to the left memory in. This is shown on the left in the Figure below. This edge is a bit unwieldy to draw, wrapping around behind the cell. But once you unroll the network, as on the right of the Figure, it forms a nice, neat, horizontal edge from each step in the LSTM to the next.</p>
<p><img data-attachment-id="1656" data-permalink="https://shapeofdata.wordpress.com/2016/06/04/lstms/lstm_outside/" data-orig-file="https://shapeofdata.files.wordpress.com/2016/06/lstm_outside.png" data-orig-size="524,168" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="LSTM_outside" data-image-description="" data-image-caption="" data-medium-file="https://shapeofdata.files.wordpress.com/2016/06/lstm_outside.png?w=300" data-large-file="https://shapeofdata.files.wordpress.com/2016/06/lstm_outside.png?w=524" class=" size-full wp-image-1656 aligncenter" src="https://shapeofdata.files.wordpress.com/2016/06/lstm_outside.png?w=640" alt="LSTM_outside" srcset="https://shapeofdata.files.wordpress.com/2016/06/lstm_outside.png 524w, https://shapeofdata.files.wordpress.com/2016/06/lstm_outside.png?w=150 150w, https://shapeofdata.files.wordpress.com/2016/06/lstm_outside.png?w=300 300w" sizes="(max-width: 524px) 100vw, 524px"   /></p>
<p>As with a standard RNN, you can use unrolling to understand the training process, by feeding the whole sequence of inputs to the network at once, and using back propagation to update the weight matrices based on the desired sequence of outputs.</p>
<p>Note that LSTMs are fairly &#8220;shallow&#8221; as neural networks go, i.e. there aren&#8217;t that many layers of neurons. In fact, if you ignore the gates, there is a single lonely weight matrix between the input vector and the output vector. Of course, there are a number of ways one could modify an LSTM to make it more flexible, and a number of people have experimented with &#8220;deep LSTMs&#8221;. But for now, I&#8217;ll leave that for the readers&#8217; imaginations, or maybe a future post.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://shapeofdata.wordpress.com/2016/06/04/lstms/feed/</wfw:commentRss>
			<slash:comments>5</slash:comments>
		
		
		
		<media:content url="https://1.gravatar.com/avatar/436b5ec3552d5e81ed4f45de75d36397?s=96&#38;d=https%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D96&#38;r=G" medium="image">
			<media:title type="html">jessejohnson</media:title>
		</media:content>

		<media:content url="https://shapeofdata.files.wordpress.com/2016/06/lstm.png" medium="image">
			<media:title type="html">LSTM</media:title>
		</media:content>

		<media:content url="https://shapeofdata.files.wordpress.com/2016/06/lstm_outside.png" medium="image">
			<media:title type="html">LSTM_outside</media:title>
		</media:content>
	</item>
		<item>
		<title>Rolling and Unrolling RNNs</title>
		<link>https://shapeofdata.wordpress.com/2016/04/27/rolling-and-unrolling-rnns/</link>
					<comments>https://shapeofdata.wordpress.com/2016/04/27/rolling-and-unrolling-rnns/#comments</comments>
		
		<dc:creator><![CDATA[Jesse Johnson]]></dc:creator>
		<pubDate>Thu, 28 Apr 2016 02:34:09 +0000</pubDate>
				<category><![CDATA[Uncategorized]]></category>
		<guid isPermaLink="false">http://shapeofdata.wordpress.com/?p=1286</guid>

					<description><![CDATA[A while back, I discussed Recurrent Neural Networks (RNNs), a type of artificial neural network in which some of the connections between neurons point &#8220;backwards&#8221;. When a sequence of inputs is fed into such a network, the backward arrows feed &#8230; <a href="https://shapeofdata.wordpress.com/2016/04/27/rolling-and-unrolling-rnns/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p>A while back, I discussed <a href="https://shapeofdata.wordpress.com/2015/10/20/recurrent-neural-networks/">Recurrent Neural Networks</a> (RNNs), a type of <a href="https://shapeofdata.wordpress.com/2013/06/11/neural-networks-1-the-neuron/">artificial neural network</a> in which some of the connections between neurons point &#8220;backwards&#8221;. When a sequence of inputs is fed into such a network, the backward arrows feed information about earlier input values back into the system at later steps. One thing that I didn&#8217;t describe in that post was how to train such a network. So in this post, I want to present one way of thinking about training an RNN, called <em>unrolling</em>.</p>
<p><span id="more-1286"></span>Recall that a neural network is defined by a directed graph, i.e. a graph in which each edge has an arrow pointing from one endpoint to the other. In my earlier post on RNNs, I described this graph in terms of the classical neural network picture in which each vertex is a neuron that emits a single value. But for this post, it&#8217;ll be easier to describe things in the tensor setting, where each vertex represents a vector defined by a row/layer of neurons. That way, we can think of our network as starting with a single vertex representing the input vector and ending at a single output vertex representing the output vector. We can get to every vertex in the graph by starting from this input vertex and following edges in the direction that their arrows point. Similarly, we can get from any vertex to the output vertex by following some path of edges.</p>
<p>A standard (non-recurrent) feed-forward network is a directed acyclic graph (DAG) which means that in addition to being directed, it has the property that if you start at any vertex and follow edges in the directions that the arrows point, you&#8217;ll never get back to where you started (acyclic). As a result there&#8217;s a natural flow through the network that allows us to calculate the vectors represented by each vertex one at a time so that by the time we calculate each vector, we&#8217;ve already calculated its inputs, i.e. vectors on the other ends of the edges that point to it.</p>
<p>In an RNN, the graph has cycles, so no matter how we arrange the vertices, there will always be edges pointing backwards, from vertices whose vectors we haven&#8217;t yet calculated. But we can deal with this by using the output from the previous step.</p>
<p><img data-attachment-id="1456" data-permalink="https://shapeofdata.wordpress.com/2016/04/27/rolling-and-unrolling-rnns/rnn_example/" data-orig-file="https://shapeofdata.files.wordpress.com/2016/04/rnn_example2.png" data-orig-size="115,375" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="RNN_example" data-image-description="" data-image-caption="" data-medium-file="https://shapeofdata.files.wordpress.com/2016/04/rnn_example2.png?w=92" data-large-file="https://shapeofdata.files.wordpress.com/2016/04/rnn_example2.png?w=115" class=" size-full wp-image-1456 alignright" src="https://shapeofdata.files.wordpress.com/2016/04/rnn_example2.png?w=640" alt="RNN_example"   />For example, the vector <img src="https://s0.wp.com/latex.php?latex=A&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" srcset="https://s0.wp.com/latex.php?latex=A&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=A&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x" alt="A" class="latex" /> in the Figure to the right is calculated from the input vector and the intermediate vector <img src="https://s0.wp.com/latex.php?latex=C&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" srcset="https://s0.wp.com/latex.php?latex=C&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=C&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x" alt="C" class="latex" /> (multiplied by a weight matrix <img src="https://s0.wp.com/latex.php?latex=M_A&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" srcset="https://s0.wp.com/latex.php?latex=M_A&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=M_A&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x" alt="M_A" class="latex" />). The circle with the &#8216;c&#8217; in it represents concatenating the vectors <img src="https://s0.wp.com/latex.php?latex=in&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" srcset="https://s0.wp.com/latex.php?latex=in&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=in&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x" alt="in" class="latex" /> and <img src="https://s0.wp.com/latex.php?latex=C&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" srcset="https://s0.wp.com/latex.php?latex=C&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=C&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x" alt="C" class="latex" />, which means creating a new (higher dimensional) vector where the first half of the entries come from the input vector and the second half come from <img src="https://s0.wp.com/latex.php?latex=C&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" srcset="https://s0.wp.com/latex.php?latex=C&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=C&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x" alt="C" class="latex" />.</p>
<p>When the first input value <img src="https://s0.wp.com/latex.php?latex=in_0&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" srcset="https://s0.wp.com/latex.php?latex=in_0&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=in_0&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x" alt="in_0" class="latex" /> gets to vertex <img src="https://s0.wp.com/latex.php?latex=A&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" srcset="https://s0.wp.com/latex.php?latex=A&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=A&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x" alt="A" class="latex" />, we don&#8217;t yet have a value to use for <img src="https://s0.wp.com/latex.php?latex=C&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" srcset="https://s0.wp.com/latex.php?latex=C&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=C&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x" alt="C" class="latex" />, so we&#8217;ll just use the zero vector of the appropriate dimension, and we&#8217;ll let <img src="https://s0.wp.com/latex.php?latex=A_0&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" srcset="https://s0.wp.com/latex.php?latex=A_0&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=A_0&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x" alt="A_0" class="latex" /> be the value that we calculate. Similarly, we can calculate <img src="https://s0.wp.com/latex.php?latex=B_0&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" srcset="https://s0.wp.com/latex.php?latex=B_0&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=B_0&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x" alt="B_0" class="latex" /> by multiplying <img src="https://s0.wp.com/latex.php?latex=A_0&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" srcset="https://s0.wp.com/latex.php?latex=A_0&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=A_0&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x" alt="A_0" class="latex" /> by the matrix <img src="https://s0.wp.com/latex.php?latex=M_B&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" srcset="https://s0.wp.com/latex.php?latex=M_B&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=M_B&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x" alt="M_B" class="latex" /> and the first output value <img src="https://s0.wp.com/latex.php?latex=C_0&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" srcset="https://s0.wp.com/latex.php?latex=C_0&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=C_0&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x" alt="C_0" class="latex" /> from <img src="https://s0.wp.com/latex.php?latex=B_0&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" srcset="https://s0.wp.com/latex.php?latex=B_0&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=B_0&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x" alt="B_0" class="latex" /> and <img src="https://s0.wp.com/latex.php?latex=M_C&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" srcset="https://s0.wp.com/latex.php?latex=M_C&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=M_C&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x" alt="M_C" class="latex" />.</p>
<p>Then comes the second value in the input sequence, which we&#8217;ll call <img src="https://s0.wp.com/latex.php?latex=in_1&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" srcset="https://s0.wp.com/latex.php?latex=in_1&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=in_1&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x" alt="in_1" class="latex" />. When we go to calculate <img src="https://s0.wp.com/latex.php?latex=S_1&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" srcset="https://s0.wp.com/latex.php?latex=S_1&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=S_1&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x" alt="S_1" class="latex" />, we haven&#8217;t yet calculated <img src="https://s0.wp.com/latex.php?latex=C_1&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" srcset="https://s0.wp.com/latex.php?latex=C_1&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=C_1&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x" alt="C_1" class="latex" />, but we do have <img src="https://s0.wp.com/latex.php?latex=C_0&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" srcset="https://s0.wp.com/latex.php?latex=C_0&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=C_0&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x" alt="C_0" class="latex" /> lying around from the last step. So we&#8217;ll calculate <img src="https://s0.wp.com/latex.php?latex=A_1&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" srcset="https://s0.wp.com/latex.php?latex=A_1&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=A_1&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x" alt="A_1" class="latex" /> using <img src="https://s0.wp.com/latex.php?latex=in_1&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" srcset="https://s0.wp.com/latex.php?latex=in_1&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=in_1&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x" alt="in_1" class="latex" /> and <img src="https://s0.wp.com/latex.php?latex=C_0&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" srcset="https://s0.wp.com/latex.php?latex=C_0&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=C_0&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x" alt="C_0" class="latex" />. Then we can calculate <img src="https://s0.wp.com/latex.php?latex=B_1&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" srcset="https://s0.wp.com/latex.php?latex=B_1&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=B_1&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x" alt="B_1" class="latex" /> and <img src="https://s0.wp.com/latex.php?latex=C_1&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" srcset="https://s0.wp.com/latex.php?latex=C_1&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=C_1&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x" alt="C_1" class="latex" />. This <img src="https://s0.wp.com/latex.php?latex=C_1&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" srcset="https://s0.wp.com/latex.php?latex=C_1&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=C_1&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x" alt="C_1" class="latex" /> will be used to calculate <img src="https://s0.wp.com/latex.php?latex=A_2&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" srcset="https://s0.wp.com/latex.php?latex=A_2&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=A_2&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x" alt="A_2" class="latex" /> in the next step, and so on.</p>
<p>In order to better understand what&#8217;s going on here, lets draw a new graph that represents all the values that we&#8217;ll calculate for the vertices in the original graph. So, in particular <img src="https://s0.wp.com/latex.php?latex=C_0&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" srcset="https://s0.wp.com/latex.php?latex=C_0&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=C_0&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x" alt="C_0" class="latex" /> and <img src="https://s0.wp.com/latex.php?latex=C_1&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" srcset="https://s0.wp.com/latex.php?latex=C_1&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=C_1&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x" alt="C_1" class="latex" /> will be two separate vertices in this new graph, and an edge goes from <img src="https://s0.wp.com/latex.php?latex=C_0&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" srcset="https://s0.wp.com/latex.php?latex=C_0&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=C_0&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x" alt="C_0" class="latex" /> to the concatenation operator that leads into vertex <img src="https://s0.wp.com/latex.php?latex=A_1&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" srcset="https://s0.wp.com/latex.php?latex=A_1&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=A_1&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x" alt="A_1" class="latex" />. This is shown in the Figure below for the first four steps in an input sequence.</p>
<p>&nbsp;</p>
<p><img data-attachment-id="1460" data-permalink="https://shapeofdata.wordpress.com/2016/04/27/rolling-and-unrolling-rnns/rnn_unrolled/" data-orig-file="https://shapeofdata.files.wordpress.com/2016/04/rnn_unrolled1.png" data-orig-size="480,381" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="RNN_unrolled" data-image-description="" data-image-caption="" data-medium-file="https://shapeofdata.files.wordpress.com/2016/04/rnn_unrolled1.png?w=300" data-large-file="https://shapeofdata.files.wordpress.com/2016/04/rnn_unrolled1.png?w=480" class=" size-full wp-image-1460 aligncenter" src="https://shapeofdata.files.wordpress.com/2016/04/rnn_unrolled1.png?w=640" alt="RNN_unrolled" srcset="https://shapeofdata.files.wordpress.com/2016/04/rnn_unrolled1.png 480w, https://shapeofdata.files.wordpress.com/2016/04/rnn_unrolled1.png?w=150 150w, https://shapeofdata.files.wordpress.com/2016/04/rnn_unrolled1.png?w=300 300w" sizes="(max-width: 480px) 100vw, 480px"   /></p>
<p>The first thing you should notice about this graph is that it has multiple inputs &#8211; one for each vector in the input sequence &#8211; and multiple outputs. The second thing you might have noticed is that this graph is acyclic. In particular, the cycle that characterized the original graph has been &#8220;unrolled&#8221; into a longer path that you can follow to the right in the new graph.</p>
<p>(For any readers who have studied topology, this is nicely reminiscent of the construction of a universal cover. In fact, if you unroll infinitely in both the positive and negative directions, the unrolled graph will be a covering space of original graph. And as noted above, it will be acyclic (in terms of directed cycles, though not necessarily undirected cycles), which is analogous to being simply connected. So maybe there&#8217;s some category theoretic sense in which it really is a universal cover&#8230; but I digress.)</p>
<p>It turns out you can always form a DAG from a cyclic directed graph by this procedure, which is called <em>unrolling</em>. Note that in the unrolled graph, we have lots of copies of the weight matrices <img src="https://s0.wp.com/latex.php?latex=M_A%2C+M_B%2C+M_C%2C+M_o&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" srcset="https://s0.wp.com/latex.php?latex=M_A%2C+M_B%2C+M_C%2C+M_o&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=M_A%2C+M_B%2C+M_C%2C+M_o&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x" alt="M_A, M_B, M_C, M_o" class="latex" />. These are the same at every step in the sequence so they don&#8217;t get unrolled.</p>
<p>However, we do need to update the weight matrices in order to train the neural network, and this is where the idea of unrolling really comes in handy. Because the unrolled network is a DAG, we can train it using back-propagation just like a standard neural network. But the input to this unrolled network isn&#8217;t a single vector from the sequence &#8211; it&#8217;s the entire sequence, all at once! And the target output we use to calculate the gradients is the entire sequence of output values we would like the network to produce for each step in the input sequence. In practice, it&#8217;s common to truncate the network and only use a portion of the sequence for each training step.</p>
<p>In the back-propagation step, we calculate gradients and use them to update the weight matrices <img src="https://s0.wp.com/latex.php?latex=M_A%2C+M_B%2C+M_C%2C+M_o&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" srcset="https://s0.wp.com/latex.php?latex=M_A%2C+M_B%2C+M_C%2C+M_o&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=M_A%2C+M_B%2C+M_C%2C+M_o&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x" alt="M_A, M_B, M_C, M_o" class="latex" />. Since we have multiple copies of each weight matrix, we&#8217;re probably going to get different gradients for each copy. But we want all the copies of each matrix to stay the same, so we&#8217;ll combine all the gradients, usually by taking an average, and use this to update the base matrix that all the copies are taken from.</p>
<p>In practice, you don&#8217;t necessarily need to explicitly construct the unrolled network in order to train an RNN with back-propagation. As long as you&#8217;re willing to deal with some complex book keeping, you can calculate the gradients for the weight matrices directly from the original graph. But nonetheless, unrolling is a nice way to think about the training process, independent of how it&#8217;s actually done.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://shapeofdata.wordpress.com/2016/04/27/rolling-and-unrolling-rnns/feed/</wfw:commentRss>
			<slash:comments>4</slash:comments>
		
		
		
		<media:content url="https://1.gravatar.com/avatar/436b5ec3552d5e81ed4f45de75d36397?s=96&#38;d=https%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D96&#38;r=G" medium="image">
			<media:title type="html">jessejohnson</media:title>
		</media:content>

		<media:content url="https://shapeofdata.files.wordpress.com/2016/04/rnn_example2.png" medium="image">
			<media:title type="html">RNN_example</media:title>
		</media:content>

		<media:content url="https://shapeofdata.files.wordpress.com/2016/04/rnn_unrolled1.png" medium="image">
			<media:title type="html">RNN_unrolled</media:title>
		</media:content>
	</item>
		<item>
		<title>Continuous Bayes&#8217; Theorem</title>
		<link>https://shapeofdata.wordpress.com/2016/01/20/continuous-bayes-theorem/</link>
					<comments>https://shapeofdata.wordpress.com/2016/01/20/continuous-bayes-theorem/#comments</comments>
		
		<dc:creator><![CDATA[Jesse Johnson]]></dc:creator>
		<pubDate>Wed, 20 Jan 2016 14:45:40 +0000</pubDate>
				<category><![CDATA[Modeling]]></category>
		<guid isPermaLink="false">http://shapeofdata.wordpress.com/?p=1249</guid>

					<description><![CDATA[Bayes&#8217; Rule is one of the fundamental Theorems of statistics, but up until recently, I have to admit, I was never very impressed with it. Bayes&#8217; gives you a way of determining the probability that a given event will occur, or &#8230; <a href="https://shapeofdata.wordpress.com/2016/01/20/continuous-bayes-theorem/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p>Bayes&#8217; Rule is one of the fundamental Theorems of statistics, but up until recently, I have to admit, I was never very impressed with it. Bayes&#8217; gives you a way of determining the probability that a given event will occur, or that a given condition is true, given your knowledge of another related event or condition. All the examples that I&#8217;ve read or heard about seemed somewhat contrived and unrelated to the sorts of data analysis I was interested in. But it turns out there&#8217;s also an interpretation of Bayes&#8217; Theorem that&#8217;s not only much more geometric than the standard formulation, but also fits quite naturally into the types of things that I&#8217;ve been discussing on this blog. So in today&#8217;s post, I want to explain how I came to truly appreciate Bayes&#8217; Theorem.</p>
<p><span id="more-1249"></span>But rather than start with the statement of Bayes&#8217; Theorem, I want to use an old math teacher trick (which I realize many students hate) of trying to derive it from scratch, without stating what we&#8217;re trying to derive. Rather, we&#8217;ll start by modifying a problem that I described in an earlier post on <a href="https://shapeofdata.wordpress.com/2014/01/28/configuration-spaces-and-the-meaning-of-probability/">probability distributions</a>.</p>
<p>Lets pretend we have a robot arm with two joints: The first is fixed to the center of a table and spins horizontally. There&#8217;s a bar from this first joint to the second joint, which also spins horizontally and is attached to a second bar. The two bars are the same length, as shown on the left in the Figure below. The game is to randomly pick a pair of angles for the two joints, then try to guess the <em>x</em> and <em>y</em> coordinates of the hand at the end of the arm. As I described in the earlier post, we can think of the (density function of the) probability distribution of all the possible <em>(x, y)</em> coordinates, and it would look something like what&#8217;s shown on the right of the Figure. Here, darker colors indicate larger values of the function.</p>
<p><a href="https://shapeofdata.files.wordpress.com/2014/01/robotarm2.png" rel="attachment wp-att-1012"><img data-attachment-id="1012" data-permalink="https://shapeofdata.wordpress.com/2014/01/28/configuration-spaces-and-the-meaning-of-probability/robotarm/" data-orig-file="https://shapeofdata.files.wordpress.com/2014/01/robotarm2.png" data-orig-size="623,304" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;}" data-image-title="robotarm" data-image-description="" data-image-caption="" data-medium-file="https://shapeofdata.files.wordpress.com/2014/01/robotarm2.png?w=300" data-large-file="https://shapeofdata.files.wordpress.com/2014/01/robotarm2.png?w=623" class="size-full wp-image-1012 aligncenter" src="https://shapeofdata.files.wordpress.com/2014/01/robotarm2.png?w=640" alt="robotarm" srcset="https://shapeofdata.files.wordpress.com/2014/01/robotarm2.png 623w, https://shapeofdata.files.wordpress.com/2014/01/robotarm2.png?w=150 150w, https://shapeofdata.files.wordpress.com/2014/01/robotarm2.png?w=300 300w" sizes="(max-width: 623px) 100vw, 623px"   /></a></p>
<p>In the earlier post, we determined that the best place to predict that the hand would be is near the center, since that&#8217;s where the probability density is highest. But now we&#8217;re going to modify the game a bit: What if each time after spinning the wheel, we are told something about the <em>x</em>-coordinate; either its exact value or a small range. Then how would that change our prediction? Note that if we&#8217;re given the exact <em>x-</em>value and asked to predict <em>y</em>, then this is essentially the regression problem except that the probability distribution doesn&#8217;t look anything like the one we used in the <a href="https://shapeofdata.wordpress.com/2013/03/18/the-geometry-of-linear-regression/">post on regression</a>.</p>
<p><a href="https://shapeofdata.files.wordpress.com/2015/12/robotarm_restricted.png" rel="attachment wp-att-1251"><img loading="lazy" data-attachment-id="1251" data-permalink="https://shapeofdata.wordpress.com/2016/01/20/continuous-bayes-theorem/robotarm_restricted/" data-orig-file="https://shapeofdata.files.wordpress.com/2015/12/robotarm_restricted.png" data-orig-size="355,356" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="robotarm_restricted" data-image-description="" data-image-caption="" data-medium-file="https://shapeofdata.files.wordpress.com/2015/12/robotarm_restricted.png?w=300" data-large-file="https://shapeofdata.files.wordpress.com/2015/12/robotarm_restricted.png?w=355" class="alignright wp-image-1251" src="https://shapeofdata.files.wordpress.com/2015/12/robotarm_restricted.png?w=300&#038;h=301" alt="robotarm_restricted" width="300" height="301" srcset="https://shapeofdata.files.wordpress.com/2015/12/robotarm_restricted.png?w=300&amp;h=301 300w, https://shapeofdata.files.wordpress.com/2015/12/robotarm_restricted.png?w=150&amp;h=150 150w, https://shapeofdata.files.wordpress.com/2015/12/robotarm_restricted.png 355w" sizes="(max-width: 300px) 100vw, 300px" /></a>But lets start with the case where we&#8217;re given a range, for example if we knew that the <em>x-</em>value was between 1/4 and 1/3. Then the probability of getting any point with an <em>x</em>-value outside this range would be zero, so the probability density that we would use to guess the <em>y</em>-value would be equal to zero for all points with <em>x</em>-values outside this range. So it would look something like the Figure on the right.</p>
<p>But dropping those values to zero isn&#8217;t enough to get the new distribution; the problem is that when we add this restriction on <em>x</em>, the probability of any point with an <em>x</em>-value in the correct range will increase. The question is: By how much will they increase?</p>
<p>In order to answer this question, we need to look more closely at what the probability density function really means. The first thing to note is that the value of the probability density function at a point is not the probability of choosing that point. In fact, the probability of picking any one point is zero, since there are infinitely many possible <em>x</em> and <em>y</em> values.</p>
<p>In order to understand the meaning of the probability density function, we need to use integrals, but (as usual) we can avoid much of the technical details by describing things in terms of the geometry that underlies those integrals. In particular, we&#8217;re going to think of our probability density function as describing the elevations of a mountain whose base is the square in which our robot arm rotates. But it won&#8217;t be a normal looking mountain &#8211; because of the way the density function looks, it&#8217;ll have a high peak in the middle, surrounded by a deep moat, then a high circular ridge (shorter than the central peak) around the outside.</p>
<p><a href="https://shapeofdata.files.wordpress.com/2016/01/density-volume.png" rel="attachment wp-att-1254"><img data-attachment-id="1254" data-permalink="https://shapeofdata.wordpress.com/2016/01/20/continuous-bayes-theorem/density-volume/" data-orig-file="https://shapeofdata.files.wordpress.com/2016/01/density-volume.png" data-orig-size="410,213" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="density-volume" data-image-description="" data-image-caption="" data-medium-file="https://shapeofdata.files.wordpress.com/2016/01/density-volume.png?w=300" data-large-file="https://shapeofdata.files.wordpress.com/2016/01/density-volume.png?w=410" class="alignleft size-full wp-image-1254" src="https://shapeofdata.files.wordpress.com/2016/01/density-volume.png?w=640" alt="density-volume" srcset="https://shapeofdata.files.wordpress.com/2016/01/density-volume.png 410w, https://shapeofdata.files.wordpress.com/2016/01/density-volume.png?w=150 150w, https://shapeofdata.files.wordpress.com/2016/01/density-volume.png?w=300 300w" sizes="(max-width: 410px) 100vw, 410px"   /></a>I&#8217;ve attempted to draw this on the left, but you&#8217;re probably better off using your imagination to picture it. Once we&#8217;ve transformed our density function into this mountain, we can replace the word &#8220;integral&#8221; with &#8220;volume&#8221; and we&#8217;ll be able to calculate some probabilities.</p>
<p>Now, as noted above, if we pick one specific point, the probability that the hand will end up there is zero. However, if we pick a particular region <em>A </em>of the square, such as a rectangle defined by a range of <em>x-</em>values and a range of <em>y-</em>values, then there may be a non-zero probability that the hand will stop within <em>A</em>. (Though everything I will say below also holds true for more complex shapes <em>A</em>, as well as for shapes in higher-dimensional probability spaces.) In particular, the density function is defined specifically so that the probability will be equal to the volume of the part of the mountain above the shape <em>A</em>.</p>
<p>In other words, if we were to take a band saw to the mountain, following the outline of <em>A</em>, then the volume of the piece that we cut out would be equal to the probability of the robot&#8217;s hand stopping within that region. We&#8217;ll call this volume/probability <em>P(A)</em>.</p>
<p>So, not only is the value of the probability density function at a point <em>not</em> the probability of getting that point (since it&#8217;s always zero), the value of the density function at a point doesn&#8217;t even need to be less than one. In particular, if there is a region <em>A</em> with a small area but a very high (though still less than 1) probability, the values of the density function would need to be very high in order to get the appropriate volume.</p>
<p>If we choose region <em>A</em> to be the entire square then <em>P(A) =</em> 1 because the arm is constrained to stay within that region. So the volume of the entire mountain is 1. If we choose a smaller region <em>A</em>, and an even smaller region <em>B</em> contained in <em>A</em>, then we&#8217;ll get a piece with smaller volume <em>P(B) &lt; P(A)</em>, and thus lower probability as we would expect.</p>
<p>But now lets return to the original question of how to modify our density function after we&#8217;ve narrowed down the set of possible outcomes to a smaller range <em>A </em>of <em>x-</em>values. This function will define a different mountain that is low and flat everywhere outside of <em>A</em>, but has the same elevations as the original within<em> A</em>, as on the left in the Figure below. We want to modify this function to give us a new probability density defining a volume function which we&#8217;ll write <em>P(*|A)</em> where * can be any region of the square. Since we know the robot hand landed in <em>A</em>, the overall probability, i.e. the volume <em>P(A|A) </em>of the new mountain, should be 1. However, since all we did was flatten the parts of the mountain outside the region, its volume is initially quite a bit less than 1.</p>
<p><img data-attachment-id="1259" data-permalink="https://shapeofdata.wordpress.com/2016/01/20/continuous-bayes-theorem/density-volume-restricted/" data-orig-file="https://shapeofdata.files.wordpress.com/2016/01/density-volume-restricted.png" data-orig-size="836,249" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="density-volume-restricted" data-image-description="" data-image-caption="" data-medium-file="https://shapeofdata.files.wordpress.com/2016/01/density-volume-restricted.png?w=300" data-large-file="https://shapeofdata.files.wordpress.com/2016/01/density-volume-restricted.png?w=640" class="alignnone size-full wp-image-1259" src="https://shapeofdata.files.wordpress.com/2016/01/density-volume-restricted.png?w=640" alt="density-volume-restricted" srcset="https://shapeofdata.files.wordpress.com/2016/01/density-volume-restricted.png?w=640 640w, https://shapeofdata.files.wordpress.com/2016/01/density-volume-restricted.png?w=150 150w, https://shapeofdata.files.wordpress.com/2016/01/density-volume-restricted.png?w=300 300w, https://shapeofdata.files.wordpress.com/2016/01/density-volume-restricted.png?w=768 768w, https://shapeofdata.files.wordpress.com/2016/01/density-volume-restricted.png 836w" sizes="(max-width: 640px) 100vw, 640px"   /></p>
<p>In order to get the correct volume, we&#8217;ll need to scale the function up, i.e. multiply each value of the function by a constant <em>k</em>. The resulting function will define a mountain more like the one shown on the right above.<em> </em>For any region <em>B</em> contained in <em>A</em>, we&#8217;ll have <em>P(B|A) = kP(B).</em> Since we want <em>P(A|A) = 1 = P(A)/P(A)</em>, the only possible value for <em>k</em> is <em>1/P(A) </em>and we get <em>P(B|A) = P(B)/P(A).</em></p>
<p>This is the case when the region <em>B</em> is contained in <em>A</em>. But what if it isn&#8217;t? For example, if we want to predict a range of <em>y</em>-values once we know the robot hand is in a certain range of <em>x</em>-values, then <em>A</em> will be a vertical strip of the square, and <em>B</em> will be a horizontal strip of the square, with the two intersecting in a smaller rectangle. (But as I noted above, we could just as easily let <em>A</em> and <em>B</em> be arbitrary blobs in the square or even blobs in a higher-dimensional space, but lets not get too complicated&#8230;)</p>
<p>So, if we want to calculate <em>P(B|A)</em> in this case, we need to consider two parts of <em>B</em> separately: The density function above the part of <em>B</em> that is outside of <em>A</em> will all get flattened to zero, so <em>P(B|A)</em> is completely determined by the part of <em>B</em> inside of <em>A</em>, i.e. the intersection <em>A ∩ B.</em> In other words, we have <em>P(B|A) = P(A ∩ B)/P(A). </em>Note that there&#8217;s no difference between <em>A</em> and <em>B</em> in this formulation, so we also have <em>P(A|B) = P(A ∩ B)/P(B).</em> We can solve both equations for <em>P(A ∩ B) </em>to get <em>P(B|A)P(B) = P(A ∩ B) = P(A|B)P(A). </em>Finally, if we divide both sides by <em>P(B)</em>, we get Bayes&#8217; Theorem:</p>
<p style="text-align:center;"><em>P(B|A) = P(A|B)P(A)/P(B)</em></p>
<p>Of course, for the problem we started out with, the original equation <em>P(B|A) = P(A ∩ B)/P(B)</em> may sometimes be more useful. But in the standard setting of Bayes&#8217; Theorem, <em>P(A ∩ B)</em> is the probability that both events happen (or both statements are true) so it might be harder to calculate.</p>
<p>For extra credit, take a minute to think about how you might calculate the probabilities of different <em>y</em>-values if we knew the exact value of <em>x</em> rather than a range. I&#8217;ll give you two hints: First, note that the probability density function over the vertical line defined by a single <em>x-</em>value defines a single-variable function like you might find in Calculus I and II, and there is some area (rather than a volume) below this function. Second, note that you can take <em>A</em> to be a small rectangular strip around the line defined by the <em>x</em>-value, calculate its volume, then make the strip smaller and smaller and take a limit.</p>
<p>But this post is already long enough, and I expect that most of my readers either don&#8217;t want to read about limits, or would rather work it out themselves. (For me, it&#8217;s both.) So I&#8217;ll leave it there.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://shapeofdata.wordpress.com/2016/01/20/continuous-bayes-theorem/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
		
		<media:content url="https://1.gravatar.com/avatar/436b5ec3552d5e81ed4f45de75d36397?s=96&#38;d=https%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D96&#38;r=G" medium="image">
			<media:title type="html">jessejohnson</media:title>
		</media:content>

		<media:content url="https://shapeofdata.files.wordpress.com/2014/01/robotarm2.png" medium="image">
			<media:title type="html">robotarm</media:title>
		</media:content>

		<media:content url="https://shapeofdata.files.wordpress.com/2015/12/robotarm_restricted.png" medium="image">
			<media:title type="html">robotarm_restricted</media:title>
		</media:content>

		<media:content url="https://shapeofdata.files.wordpress.com/2016/01/density-volume.png" medium="image">
			<media:title type="html">density-volume</media:title>
		</media:content>

		<media:content url="https://shapeofdata.files.wordpress.com/2016/01/density-volume-restricted.png" medium="image">
			<media:title type="html">density-volume-restricted</media:title>
		</media:content>
	</item>
		<item>
		<title>The TensorFlow perspective on neural networks</title>
		<link>https://shapeofdata.wordpress.com/2015/11/30/the-tensorflow-perspective-on-neural-networks/</link>
					<comments>https://shapeofdata.wordpress.com/2015/11/30/the-tensorflow-perspective-on-neural-networks/#comments</comments>
		
		<dc:creator><![CDATA[Jesse Johnson]]></dc:creator>
		<pubDate>Mon, 30 Nov 2015 14:02:47 +0000</pubDate>
				<category><![CDATA[Neural Networks]]></category>
		<guid isPermaLink="false">http://shapeofdata.wordpress.com/?p=1235</guid>

					<description><![CDATA[A few weeks ago, Google announced that it was open sourcing an internal system called TensorFlow that allows one to build neural networks, as well as other types of machine learning models. (Disclaimer: I work for Google.) Because TensorFlow is designed &#8230; <a href="https://shapeofdata.wordpress.com/2015/11/30/the-tensorflow-perspective-on-neural-networks/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p><span style="font-weight:400;">A few weeks ago, Google announced that it was open sourcing an internal system called <a href="http://www.tensorflow.org/">TensorFlow</a> that allows one to build neural networks, as well as other types of machine learning models. (Disclaimer: I work for Google.) Because TensorFlow is designed to be more general than just a neural network framework, it takes a fairly abstract perspective compared to the way we usually talk about neural networks. But (not coincidentally) this perspective is very close to what I described in my <a href="https://shapeofdata.wordpress.com/2015/11/09/neural-networks-linear-transformations-and-word-embeddings/">last post</a>, with rows of neurons defining output vectors and the connections between these rows defining matrices of weights. In today’s post, I want to describe the TensorFlow perspective, explain how it matches up with the traditional way of thinking about neural networks, and explain how TensorFlow generalizes the vector and matrix approach to include more general structures called </span><i><span style="font-weight:400;">tensors</span></i><span style="font-weight:400;">.</span></p>
<p><span id="more-1235"></span>Recall that the standard view of an artificial neural network is a directed graph of neurons, where each neuron calculates a weighted sum of inputs from other neurons, then applies a non-linear function to determine its own output. Many neural networks have neurons arranged into rows or layers, with the neurons from one layer connected to the neurons in the next layer according to some pattern.</p>
<p>In my last post, I pointed out that you can think of each neuron as actually being two neurons &#8211; a linear neuron that calculates the weighted sum, which it sends to a non-linear neuron that applies the non-linear function to the output from the linear neuron. From this perspective, the linear neurons in each layer collect the output from the  previous layer, and the non-linear neurons send their outputs to the next layer. As I described last time, you can then think of the output from each layer as a vector with one dimension/feature for each neuron. The connections between successive layers define a matrix such that the outputs of the linear neurons in one layer define a vector that&#8217;s equal to the outputs from the non-linear neurons of the previous layer multiplied by this matrix.</p>
<p>For a basic feed-forward network, we just have a sequence of layers, one after the other, as in the Figure below. I&#8217;ve indicated which parts of the Figure correspond to these vectors and matrices, and it&#8217;s possible to translate the diagram into the equations that describe how these all relate to each other. But the translation can be a bit tricky, and for more complex networks such as convolutional networks and RNNs, it becomes even harder to understand how the network functions from this perspective.</p>
<p><a href="https://shapeofdata.files.wordpress.com/2015/11/annlabeled.png"><img data-attachment-id="1239" data-permalink="https://shapeofdata.wordpress.com/2015/11/30/the-tensorflow-perspective-on-neural-networks/annlabeled/" data-orig-file="https://shapeofdata.files.wordpress.com/2015/11/annlabeled.png" data-orig-size="513,268" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="ANNlabeled" data-image-description="" data-image-caption="" data-medium-file="https://shapeofdata.files.wordpress.com/2015/11/annlabeled.png?w=300" data-large-file="https://shapeofdata.files.wordpress.com/2015/11/annlabeled.png?w=513" class="size-full wp-image-1239 aligncenter" src="https://shapeofdata.files.wordpress.com/2015/11/annlabeled.png?w=640" alt="ANNlabeled" srcset="https://shapeofdata.files.wordpress.com/2015/11/annlabeled.png 513w, https://shapeofdata.files.wordpress.com/2015/11/annlabeled.png?w=150 150w, https://shapeofdata.files.wordpress.com/2015/11/annlabeled.png?w=300 300w" sizes="(max-width: 513px) 100vw, 513px"   /></a></p>
<p>TensorFlow improves on this by dropping the biological analogy in favor of a graph that directly encodes the mathematical relationships between the elements. A TensorFlow graph for the neural network in the above Figure is shown in the Figure below. Instead of individual neurons, the elements of this graph are vectors, matrices and operations, with edges indicating how the operations are applied. (The v&#8217;s are vectors, W&#8217;s are matrices, and circles/ellipses are operators.) To figure out how each element is calculated, you simply follow the arrows backwards.</p>
<p><a href="https://shapeofdata.files.wordpress.com/2015/11/anntf1.png"><img data-attachment-id="1242" data-permalink="https://shapeofdata.wordpress.com/2015/11/30/the-tensorflow-perspective-on-neural-networks/anntf/" data-orig-file="https://shapeofdata.files.wordpress.com/2015/11/anntf1.png" data-orig-size="544,87" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="ANNtf" data-image-description="" data-image-caption="" data-medium-file="https://shapeofdata.files.wordpress.com/2015/11/anntf1.png?w=300" data-large-file="https://shapeofdata.files.wordpress.com/2015/11/anntf1.png?w=544" class="size-full wp-image-1242 aligncenter" src="https://shapeofdata.files.wordpress.com/2015/11/anntf1.png?w=640" alt="ANNtf" srcset="https://shapeofdata.files.wordpress.com/2015/11/anntf1.png 544w, https://shapeofdata.files.wordpress.com/2015/11/anntf1.png?w=150 150w, https://shapeofdata.files.wordpress.com/2015/11/anntf1.png?w=300 300w" sizes="(max-width: 544px) 100vw, 544px"   /></a></p>
<p>You can create a graph like this in TensorFlow by writing a script in Python. This graph includes operators for matrix multiplication and a non-linear operator (such as the sigmoid or the ReLu), but TensorFlow has a number of other operators as well, such as convolutional multiplication and pooling. Plus, since TensorFlow is open source, anyone can write their own operators. There are a number of <a href="http://tensorflow.org/tutorials">tutorials</a> on the official site where you can find details and examples.</p>
<p>Once you have this graph, you can ask TensorFlow to evaluate it for a given collection of inputs, but the more interesting part is, of course, the training. In other words, we want to select the values in the weight matrices by incrementally adjusting them via back propagation. This involves evaluating data points (following the graph forward), then determining the error and pushing it back to the weight matrices by calculating gradients. TensorFlow is able do this automatically because each of the operators is required to provide a pre-calculated gradient function. TensorFlow combines these using the chain rule, so if you tell it which of the vectors and matrices you want it to update, it can run back propagation automatically.</p>
<p>So that should give you an idea of how TensorFlow allows you to define neural networks, and other types of models, in terms of graphs of vectors, matrices and operators. But often it&#8217;s useful to create a neural network where each layer of neurons isn&#8217;t a just single row. For example, if you&#8217;re working with images, then the input layer would be more naturally described as a rectangular grid of values. Of course, this rectangle could be encoded as a vector, but it&#8217;s more natural to think of it as a matrix, particularly for something like a convolutional net, where the sliding windows are defined in terms of a rectangle. In fact, if it&#8217;s a RGB image then you really want to think of the input as three parallel rectangles, forming a rectangular box of values.</p>
<p>Now, I&#8217;m about to start using the term &#8220;dimension&#8221; in a way that&#8217;s a bit different than usual, so I want to be especially careful. Recall that a vector is defined by a list of numbers of some specified length. The set of all possible vectors of a given length define a vector space whose dimension is the length that we chose. But we&#8217;re going to say that every vector, no matter its length, is a <em>one-dimensional tensor</em>. So a one-dimensional tensor can define a vector space of any dimension you want. The one-dimensional part refers to the fact that we write the values of the vector along a one-dimensional line.</p>
<p>A matrix, on the other hand, is a grid of numbers with a certain number of rows and a certain number of columns. The set of all matrices of a given size also defines a vector space, whose dimension is the number of rows times the number of columns. But we&#8217;ll still say that a matrix is a two-dimensional tensor. (One dimension is rows. The other is columns.) So, as promised, we have two different meanings of the word &#8220;dimension&#8221; &#8211; one for the dimension of the space defined a vector or a matrix, one for the way in which the values are arranged when they&#8217;re written down.</p>
<p>Similarly, the rectangular box of values defined by the three rectangular layers of our RGB image defines a three-dimensional tensor, since we think of the values as being arranged into a three-dimensional shape. The space of all possible images defines a vector space whose dimension is much larger (three times the number of pixels to be precise), but it&#8217;s still a three-dimensional tensor.</p>
<p>To be even more precise about this, each of the features that make up a vector can be specified by a single index <em>i.</em> Each &#8220;feature&#8221; in a matrix is specified by two indices, <em>i </em>and<em> j</em>. Each feature in the rectangular box for the RGB image is specified by three coordinates <em>i, j, k</em>. These are one-, two- and three-dimensional tensors, respectively. But there&#8217;s no reason to stop there. For example, if we want to keep track of the connections/weights between two layers we&#8217;ll need to index them by the both indices for the layer where they start and the indices for the layer where they end. For example, the weight from neuron <em>i, j, k</em> of one layer to neuron <em>x, y, z</em> of the next layer is defined by the indices <em>i, j, k, x, y, z</em>. This is a six-dimensional tensor.</p>
<p>TensorFlow is designed to handle tensors of any dimension, and the operators that can be used to combine them. This, combined with the abstract and general nature of its approach to defining computation graphs makes it an extremely powerful and flexible platform for building machine learning models.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://shapeofdata.wordpress.com/2015/11/30/the-tensorflow-perspective-on-neural-networks/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
		
		<media:content url="https://1.gravatar.com/avatar/436b5ec3552d5e81ed4f45de75d36397?s=96&#38;d=https%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D96&#38;r=G" medium="image">
			<media:title type="html">jessejohnson</media:title>
		</media:content>

		<media:content url="https://shapeofdata.files.wordpress.com/2015/11/annlabeled.png" medium="image">
			<media:title type="html">ANNlabeled</media:title>
		</media:content>

		<media:content url="https://shapeofdata.files.wordpress.com/2015/11/anntf1.png" medium="image">
			<media:title type="html">ANNtf</media:title>
		</media:content>
	</item>
		<item>
		<title>Neural networks, linear transformations and word embeddings</title>
		<link>https://shapeofdata.wordpress.com/2015/11/09/neural-networks-linear-transformations-and-word-embeddings/</link>
					<comments>https://shapeofdata.wordpress.com/2015/11/09/neural-networks-linear-transformations-and-word-embeddings/#comments</comments>
		
		<dc:creator><![CDATA[Jesse Johnson]]></dc:creator>
		<pubDate>Mon, 09 Nov 2015 14:49:02 +0000</pubDate>
				<category><![CDATA[Neural Networks]]></category>
		<guid isPermaLink="false">http://shapeofdata.wordpress.com/?p=1220</guid>

					<description><![CDATA[In past posts, I&#8217;ve described the geometry of artificial neural networks by thinking of the output from each neuron in the network as defining a probability density function on the space of input vectors. This is useful for understanding how &#8230; <a href="https://shapeofdata.wordpress.com/2015/11/09/neural-networks-linear-transformations-and-word-embeddings/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p>In past posts, I&#8217;ve described the geometry of artificial <a href="https://shapeofdata.wordpress.com/2013/06/11/neural-networks-1-the-neuron/">neural networks</a> by thinking of the output from each neuron in the network as defining a probability density function on the space of input vectors. This is useful for understanding how a single neuron <a href="https://shapeofdata.wordpress.com/2013/06/18/neural-networks-2-evaluation/">combines</a> the outputs of other neurons to form a more complex shape. However, it&#8217;s often useful to think about how multiple neurons behave at the same time, particularly for networks that are defined by successive layers of neurons. For such networks &#8211; which turn out to be the vast majority of networks in practice &#8211; it&#8217;s useful to think about how the set of outputs from each layer determine the set of outputs of the next layer. In this post, I want to discuss how we can think about this in terms of linear transformations (via matrices) and how this idea leads to a tool called word embeddings, the most popular of which is probably <a href="https://code.google.com/p/word2vec/">word2vec</a>.</p>
<p><span id="more-1220"></span>First, recall that each neuron in a neural network has a number of inputs and a single output. The inputs come from either the features of an input vector, or from the outputs of other neurons. The neuron stores a weight for each input, and it calculates its output by multiplying each input value by a weight, adding up the products, adding a constant defined by another weight, then applying a fixed (non-linear) function to this value. One <a href="https://shapeofdata.wordpress.com/2013/06/24/neural-networks-3-training/">trains</a> a neural network by modifying the weights on the inputs to each neuron so that the overall output is closer to what you want it to be.</p>
<p>Before we go any further, we&#8217;re going to split each of our neurons into two: We&#8217;ll call the first one a linear neuron &#8211; this will have the same inputs as the original neuron, but its output will simply add together the input-times-weight values, plus the constant weight. We&#8217;ll call the second neuron a non-linear neuron &#8211; it will take the output from the linear neuron as its only input, and apply the fixed non-linear function to it. So if we take a neural network and replace each of the original neurons by a linear neuron feeding into a non-linear neuron, we&#8217;ll get the same functionality as the original network.</p>
<p>An example of this is shown below. Adding arrow heads to show input/output made the picture too noisy, so you&#8217;ll have to pretend they&#8217;re all pointing to the right. In the top network, we have four input features feeding into a layer with two (standard) neurons, which in turn feed into a layer with three neurons, then a single neuron that combines their output to determine the output of the entire network. Below that, we have the same network after we&#8217;ve replaced each standard neuron with a linear neuron feeding into a non-linear neuron.</p>
<p><a href="https://shapeofdata.files.wordpress.com/2015/11/ann-linear.png"><img data-attachment-id="1223" data-permalink="https://shapeofdata.wordpress.com/2015/11/09/neural-networks-linear-transformations-and-word-embeddings/ann-linear/" data-orig-file="https://shapeofdata.files.wordpress.com/2015/11/ann-linear.png" data-orig-size="586,527" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="ANN-linear" data-image-description="" data-image-caption="" data-medium-file="https://shapeofdata.files.wordpress.com/2015/11/ann-linear.png?w=300" data-large-file="https://shapeofdata.files.wordpress.com/2015/11/ann-linear.png?w=586" class="size-full wp-image-1223 aligncenter" src="https://shapeofdata.files.wordpress.com/2015/11/ann-linear.png?w=640" alt="ANN-linear" srcset="https://shapeofdata.files.wordpress.com/2015/11/ann-linear.png 586w, https://shapeofdata.files.wordpress.com/2015/11/ann-linear.png?w=150 150w, https://shapeofdata.files.wordpress.com/2015/11/ann-linear.png?w=300 300w" sizes="(max-width: 586px) 100vw, 586px"   /></a></p>
<p>Notice that in the network after the split, the outputs from the non-linear neurons in a given row feed into the linear neurons in the next row. Let&#8217;s focus, for a moment, on the connections from the non-linear neurons in the first non-input row, to the linear neurons in the second non-input row.</p>
<p>The output values from the non-linear neurons define a vector that we&#8217;ll call <i>V</i>. The outputs from the linear neurons define another vector <em>W</em>. For each of the linear neurons in this row, there is one weight for each of the non-linear neurons in the previous row, so these weights define a vector with the same dimension/number of entries as <em>V.</em> In fact, we have one such vector for each of the linear neurons, and if we stack these vectors next to each other, we get a matrix, which we&#8217;ll call <em>M</em>.</p>
<p>So, lets just quickly review this: We have the vector <em>V</em> of outputs from the row of non-linear neurons and the vector <em>W</em> of outputs from the successive row of linear neurons. We calculate <em>W</em> by multiplying the entries in the vector <em>V</em> by certain entries in the matrix <em>M</em> and then adding them together in a certain way. Well, if you happen to remember how matrix multiplication works, and you think carefully about the way we&#8217;re multiplying and adding the neuron outputs and weights, they turn out to be the same thing. In other words, it just so happens that the vector <i>W</i> defined by the row of linear neurons is the result of (matrix) multiplication <em>V </em>x <em>M</em>. (I&#8217;m thinking of <em>V</em> as being horizontal and the vectors of the same dimension that make up <em>M</em> as vertical.)</p>
<p>We can think about this as a function/transformation from the space of all possible vectors <em>V</em> to the space of all possible vectors <em>W</em>. Under this interpretation, matrix multiplication defines a <em>linear transformation</em>: Every straight line in the first vector space will be sent to either a straight line or a point in the second space. (In particular, if the dimension of <em>V</em> is higher than that of <em>W</em> then a lot of lines will have to collapse down to points, but this can happen no matter what.) So there&#8217;s our geometric interpretation of the connections between the row of non-linear neurons and the next row of linear neurons: a linear transformation.</p>
<p>Oh, except there&#8217;s one small detail we forgot: Each neuron doesn&#8217;t just multiply and add the inputs from the previous row of neurons. It also adds in a constant weight. The set of constant weights define yet another vector <em>C</em>, with the same dimension as W, and adding in all the constant weights corresponds to adding <em>C</em> to the product <em>V </em>x<em> M.</em> But it turns out this isn&#8217;t such a big deal &#8211; it just means that we get an affine transformation instead of a linear transformation &#8211; straight lines still stay straight or collapse to points. However, the zero vector doesn&#8217;t necessarily go the the zero vector. So we still get a nice interpretation of the connections between the layers.</p>
<p>This brings up an interesting point about the importance of the non-linear neurons. If we were to remove the non-linear neurons and create a neural network entirely of linear neurons, then we could interpret the entire thing as a succession of linear transformations. So, for example, to calculate the output from the third layer, we would multiply the vector from the first layer by the matrix for the connections to the second layer, then multiply the resulting vector by the matrix for the connections from the second to the third layer. However, it turns out that combining linear transformations like this, which is equivalent to multiplying matrices, can only produce new linear or affine transformations. So we wouldn&#8217;t get anything with three layers that we couldn&#8217;t get with two. It&#8217;s the non-linear part of the neurons that allows neural networks to define arbitrarily complex probability distributions.</p>
<p>But lets return to the linear part. In addition to being a useful way to think about the layers in a neural network, it turns out these linear transformations also allow you to do some fun tricks such as transforming sparse data into dense data.</p>
<p>Sparse data in this context means data in which a typical data points has most of its features equal to zero, and its structure is determined more by which features are non-zero, than by what their values actually are. A good example of this is <a href="https://shapeofdata.wordpress.com/2013/10/23/case-study-3-free-form-text/">bag-of-words</a> (BOW) vectors &#8211; the non-zero features reflect what the words in the &#8220;bag&#8221; are, and depending on the exact type of BOW, their actual values may or may not give you additional information such as word count.</p>
<p>The problem with this type of vector is that they&#8217;re floppy (That&#8217;s not a technical term.): Because there are so many dimensions, there&#8217;s a serious risk of <a href="https://shapeofdata.wordpress.com/2013/03/26/general-regression-and-over-fitting/">overfitting</a>, and the <a href="https://shapeofdata.wordpress.com/2013/04/02/the-curse-of-dimensionality/">curse of dimensionality</a> makes distances less meaningful. So to really understand the geometric structure of such data, we need a meaningful way to embed the data points into a lower-dimensional space.</p>
<p>It turns out one can do this by first trying to solve a different problem. Lets say you wanted to predict, for any given word, what other words are most likely to appear just before and just after it in a large corpus of text. In other words, given the word &#8220;apple&#8221; and the word &#8220;pie&#8221;, you want a model that tells you the probability, if you were to randomly select an occurrence of the word &#8220;apple&#8221; in the text, that &#8220;pie&#8221; would be one of the three words right before it or of the three words right after. (You can replace three with any number, but to simplify the discussion below, I&#8217;m going to stick with three.)</p>
<p>The most straightforward way to do this with a neural network is to have a row of inputs, with one input for each word, then a row of output neurons, one for each word, with every input feature attached to every output neuron. If you input a vector with value 1 for &#8220;apple&#8221; and value zero for everything else, you want the &#8220;pie&#8221; neuron to output the probability described above. We can achieve this by setting the weight on the edge from input &#8220;apple&#8221; to neuron &#8220;pie&#8221; to this probability (and we can calculate the probability directly by counting the number of occurrences in the corpus).</p>
<p>But this uses only sparse representations of the data, with one feature per word for both the input features and the output neurons. In order to get a dense representation, we will force our neural network to generate one by inserting a smaller row of neurons between the input and the output. A Figure representing the original neural network and the network with the inserted row is below. In practice, the input and output rows would consist of thousands of features, and the middle row would have hundreds of neurons, but this should give you the idea.</p>
<p><a href="https://shapeofdata.files.wordpress.com/2015/11/word2vec.png"><img data-attachment-id="1224" data-permalink="https://shapeofdata.wordpress.com/2015/11/09/neural-networks-linear-transformations-and-word-embeddings/word2vec/" data-orig-file="https://shapeofdata.files.wordpress.com/2015/11/word2vec.png" data-orig-size="523,292" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="word2vec" data-image-description="" data-image-caption="" data-medium-file="https://shapeofdata.files.wordpress.com/2015/11/word2vec.png?w=300" data-large-file="https://shapeofdata.files.wordpress.com/2015/11/word2vec.png?w=523" class="size-full wp-image-1224 aligncenter" src="https://shapeofdata.files.wordpress.com/2015/11/word2vec.png?w=640" alt="word2vec" srcset="https://shapeofdata.files.wordpress.com/2015/11/word2vec.png 523w, https://shapeofdata.files.wordpress.com/2015/11/word2vec.png?w=150 150w, https://shapeofdata.files.wordpress.com/2015/11/word2vec.png?w=300 300w" sizes="(max-width: 523px) 100vw, 523px"   /></a></p>
<p>For this new network, there isn&#8217;t an immediately obvious way to set the weights, so we need to train it like any other neural network. This is technically unsupervised learning since there are no labels involved, but the neural network doesn&#8217;t know that: You train the network by feeding in each word in the corpus of text and comparing the output to the bag-of-words vector defined by the three words before and three words after it. (Again, you can replace three with any number.) If the output is not what you expected, you adjust the weights using <a href="https://shapeofdata.wordpress.com/2013/06/24/neural-networks-3-training/">gradients/back-propagation</a>, then repeat with the next word and so on.</p>
<p>Once we do this, the middle layer gives us a lower-dimensional representation of the data. In particular, while the Figure doesn&#8217;t show the neurons split into linear and non-linear pieces, the connections from the input features to the linear parts of the middle layer neurons define a linear transformation (a matrix) from the sparse input space to the lower-dimensional space defined by the middle neurons.</p>
<p>Given any word such as &#8220;apple&#8221;, we can form the input vector that has 1 for the corresponding feature and zero for all the others. The linear transformation defined by the first set of weights takes this sparse vector to a (dense) vector in the space defined by the middle neurons which also represents this word. In particular, recall that the neural network was trained to predict the nearby words for each input. In order for it to do this effectively, it must choose a linear transformation that sends words that commonly have similar neighbors to nearby vectors in the middle space. So synonyms are likely to be sent to very close neighbors in the middle space, and related words will be slightly farther apart.</p>
<p>This is roughly how word2vec works, and there are other similar schemes for training a neural network with a lower-dimensional row of neurons. Moreover, in practice this type of approach turns out to generate an embedding with even more structure than one might otherwise expect. In addition to placing synonyms near each other, word2vec also places pairs of words with similar relationships in the same relative positions as each other. For example, if you draw lines between (the lower-dimensional vectors representing) names of countries and the names of their capitals, you find that you get lines of the same length and slope (i.e. they define the same vector) so if you calculate &#8220;Paris&#8221; &#8211; &#8220;France&#8221; + &#8220;Germany&#8221; with vector arithmetic, you get a vector that is closer to &#8220;Berlin&#8221; than to any other word. (Stated another way, the vector &#8220;Paris&#8221; &#8211; &#8220;France&#8221; is extremely close to the vector &#8220;Germany&#8221; &#8211; &#8220;Berlin&#8221;.)</p>
<p>So, unlike the sparse bag-of-words vectors, in which any two words are treated equally, the dense word2vec representation of each word is closely related to its meaning. The geometric structure of the set of word2vec representations should therefore reflect the semantic structure of the language in a way that the sparse vectors never could. Note that the neural network doesn&#8217;t actually &#8220;know&#8221; the meanings of the words, and the training doesn&#8217;t explicitly involve the meanings in any way. However, the neural network is able to infer relationships between the &#8220;meanings&#8221; of the words based on the context provided by the corpus of text, and the vector/matrix interpretation of the connection weights in the network allow us to extract these learned relationships.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://shapeofdata.wordpress.com/2015/11/09/neural-networks-linear-transformations-and-word-embeddings/feed/</wfw:commentRss>
			<slash:comments>10</slash:comments>
		
		
		
		<media:content url="https://1.gravatar.com/avatar/436b5ec3552d5e81ed4f45de75d36397?s=96&#38;d=https%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D96&#38;r=G" medium="image">
			<media:title type="html">jessejohnson</media:title>
		</media:content>

		<media:content url="https://shapeofdata.files.wordpress.com/2015/11/ann-linear.png" medium="image">
			<media:title type="html">ANN-linear</media:title>
		</media:content>

		<media:content url="https://shapeofdata.files.wordpress.com/2015/11/word2vec.png" medium="image">
			<media:title type="html">word2vec</media:title>
		</media:content>
	</item>
		<item>
		<title>Recurrent Neural Networks</title>
		<link>https://shapeofdata.wordpress.com/2015/10/20/recurrent-neural-networks/</link>
					<comments>https://shapeofdata.wordpress.com/2015/10/20/recurrent-neural-networks/#comments</comments>
		
		<dc:creator><![CDATA[Jesse Johnson]]></dc:creator>
		<pubDate>Tue, 20 Oct 2015 13:26:05 +0000</pubDate>
				<category><![CDATA[Neural Networks]]></category>
		<guid isPermaLink="false">http://shapeofdata.wordpress.com/?p=1205</guid>

					<description><![CDATA[So far on this blog, we&#8217;ve mostly looked at data in two forms &#8211; vectors in which each data point is defined by a fixed set of features, and graphs in which each data point is defined by its connections &#8230; <a href="https://shapeofdata.wordpress.com/2015/10/20/recurrent-neural-networks/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p>So far on this blog, we&#8217;ve mostly looked at data in two forms &#8211; vectors in which each data point is defined by a fixed set of features, and graphs in which each data point is defined by its connections to other data points. For other forms of data, notably sequences such as text and sound, I described a few ways of transforming these into vectors, such as <a href="https://shapeofdata.wordpress.com/2013/10/23/case-study-3-free-form-text/">bag-of-words</a> and n-grams. However, it turns out there are also ways to build machine learning models that use sequential data directly. In this post, I want to describe one such approach, called a <em>recurrent neural network</em>.</p>
<p><span id="more-1205"></span><br />
<a href="https://shapeofdata.files.wordpress.com/2015/10/ann4.png"><img data-attachment-id="1216" data-permalink="https://shapeofdata.wordpress.com/2015/10/20/recurrent-neural-networks/ann4/" data-orig-file="https://shapeofdata.files.wordpress.com/2015/10/ann4.png" data-orig-size="401,276" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="ANN4" data-image-description="" data-image-caption="" data-medium-file="https://shapeofdata.files.wordpress.com/2015/10/ann4.png?w=300" data-large-file="https://shapeofdata.files.wordpress.com/2015/10/ann4.png?w=401" class="size-full wp-image-1216 alignright" src="https://shapeofdata.files.wordpress.com/2015/10/ann4.png?w=640" alt="ANN4" srcset="https://shapeofdata.files.wordpress.com/2015/10/ann4.png 401w, https://shapeofdata.files.wordpress.com/2015/10/ann4.png?w=150 150w, https://shapeofdata.files.wordpress.com/2015/10/ann4.png?w=300 300w" sizes="(max-width: 401px) 100vw, 401px"   /></a>Recall that a standard (artificial) <a href="https://shapeofdata.wordpress.com/2013/06/11/neural-networks-1-the-neuron/">neural network</a>, is defined by a graph of neurons (the big circles on the right), each of which takes either the features of a given data point (the small circles), or the outputs from other neurons, and <a href="https://shapeofdata.wordpress.com/2013/06/18/neural-networks-2-evaluation/">calculates its own output</a> from these values. In this way, each neuron defines a probability distribution on the space of possible input vectors. The density function of the distribution (shown inside each circle) is defined by the value that the neuron would output for any given input vector.</p>
<p>We can think of each probability distribution, and thus each neuron, as defining a &#8220;concept&#8221; such that its output for a given input vector defines the probability that the input vector represents the concept. In the figure, the high-probability regions are shown in white. The neurons that are connected directly to the input data define relatively simple concepts/probability distributions, while later neurons combine these simple concepts/distributions into more complex ones. In the figure, the far-right neuron&#8217;s concept is the union of the other two &#8211; it is represented by any vector that represents one or the other.</p>
<p>Implicit in this definition is the idea of a Directed Acyclic Graph, or DAG: Directed means that each edge in the network/graph has an arrow on it, pointing from a neuron whose output is used to the neuron that uses it. Acyclic means that if you follow these arrows, you can never go in a loop &#8211; all paths must move away from the input features and eventually make it to the output of the entire network, as with the top graph in the figure below.</p>
<p><a href="https://shapeofdata.files.wordpress.com/2015/10/dag.png"><img data-attachment-id="1213" data-permalink="https://shapeofdata.wordpress.com/2015/10/20/recurrent-neural-networks/dag/" data-orig-file="https://shapeofdata.files.wordpress.com/2015/10/dag.png" data-orig-size="454,136" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="dag" data-image-description="" data-image-caption="" data-medium-file="https://shapeofdata.files.wordpress.com/2015/10/dag.png?w=300" data-large-file="https://shapeofdata.files.wordpress.com/2015/10/dag.png?w=454" class="alignleft size-full wp-image-1213" src="https://shapeofdata.files.wordpress.com/2015/10/dag.png?w=640" alt="dag" srcset="https://shapeofdata.files.wordpress.com/2015/10/dag.png 454w, https://shapeofdata.files.wordpress.com/2015/10/dag.png?w=150 150w, https://shapeofdata.files.wordpress.com/2015/10/dag.png?w=300 300w" sizes="(max-width: 454px) 100vw, 454px"   /></a></p>
<p>If you can follow the edges of a directed graph and get back to a vertex that you already visited, this is called a <em>cycle</em>. Notice how the two blue edges in the bottom graph create cycles. These are problematic for neural networks because when you calculate the output of a neuron, you need to know the outputs of all the neurons that point into it. If there&#8217;s a cycle, there&#8217;s no neuron that you can calculate first, before all the other neurons. In the graph above, you could reorder the vertices so that the blue edges point to the right, but then some of the other edges would have to point left.</p>
<p>Whenever you do have a DAG, you can order the vertices (neurons) so that all the edges pointing into each vertex come from earlier vertices, i.e. all the edge point to the right. If you order the neurons in a standard neural network like this, you can calculate the outputs of the neurons in this order and know all the values needed to calculate each neuron&#8217;s output by the time you get to it.</p>
<p>A recurrent neural network is a neural network that is not a DAG. So as noted above, there&#8217;s no natural order on the neurons in which all the arrows point forward. But, then, how do we calculate the output values of the neurons?</p>
<p>It turns out the best thing to do is to carry on, pretending that there&#8217;s nothing wrong. In particular, we start by picking an ordering for the vertices, dropping the condition that the arrows defined by the edges have to point towards later vertices. This ordering will allow us to calculate the output values of all the neurons for a given input vector &#8211; for each neuron in the sequence, we use the output values from the earlier neurons that have already been calculated, and treat the outputs from the later neurons as if they were set to zero or some other default value.</p>
<p>But then what&#8217;s the point of the arrows that point backwards? Well, remember that the goal of recurrent neural networks is to deal with sequential data, in which we get one vector after another. For example, if we&#8217;re analyzing text, we might use bag-of-words with a moving window &#8211; use the first five words for the first vector, the second through the sixth word for the next vector, then the third through seventh and so on.</p>
<p><a href="https://shapeofdata.files.wordpress.com/2015/10/rnn-inputs.png"><img data-attachment-id="1215" data-permalink="https://shapeofdata.wordpress.com/2015/10/20/recurrent-neural-networks/rnn-inputs/" data-orig-file="https://shapeofdata.files.wordpress.com/2015/10/rnn-inputs.png" data-orig-size="301,169" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="rnn-inputs" data-image-description="" data-image-caption="" data-medium-file="https://shapeofdata.files.wordpress.com/2015/10/rnn-inputs.png?w=300" data-large-file="https://shapeofdata.files.wordpress.com/2015/10/rnn-inputs.png?w=301" class="size-full wp-image-1215 alignright" src="https://shapeofdata.files.wordpress.com/2015/10/rnn-inputs.png?w=640" alt="rnn-inputs" srcset="https://shapeofdata.files.wordpress.com/2015/10/rnn-inputs.png 301w, https://shapeofdata.files.wordpress.com/2015/10/rnn-inputs.png?w=150 150w" sizes="(max-width: 301px) 100vw, 301px"   /></a></p>
<p>When we process the first vector, we do exactly what we described above &#8211; using a default value for the output of any neuron with an arrow that points &#8220;backwards&#8221; in the ordering. But then, when we process the second vector and get to a neuron with an arrow pointing backwards, we discover that we now have an output value for it &#8211; the value that was set when we processed the first input vector. So the neuron output values determined by the second vector in the sequence are affected by the first vector in the sequence. We repeat this for the third input vector, ending up with output values that are affected by the first two input vectors as well. So the backward arrows function kind of like memory cells within the recurrent neural network, remembering which &#8220;concepts&#8221; the earlier inputs represented.</p>
<p>Now, there are other, simpler ways we could create a model that takes into account more than one of these moving window vectors at a time. For example, we could concatenate the first <i>N</i> of the vectors together for some <em>N</em>, creating an input vector with <em>N</em> times as many dimensions as we started with. This is similar in principal to an n-gram. This would put the input back in standard vector form, so we could use any old model on it.</p>
<p>A recurrent neural network is a more complex solution than this, but it has two big advantages over techniques like n-grams or this concatenation scheme: First, the recurrent neural network works the same way no matter how long the sequence of inputs is. In other words, you don&#8217;t have to choose a value <em>N</em> before you start using it.</p>
<p>Second, and perhaps more importantly, a recurrent neural network reuses the same neurons for all the inputs in the sequence, allowing the overall network to be smaller/simpler. As each input vector comes in, it gets &#8220;compressed&#8221; into a set of concepts, defined by the neurons whose output will feed back into the next cycle of the network.</p>
<p>Any scheme for turning a sequence into a vector would need to use some method to reduce the number of dimensions, such as restricting to the most common n-grams. The recurrent neural network does this implicitly, as part of the same training process (whose description will have to wait for a later post) as the rest of the network. So the process is much more natural, and doesn&#8217;t require as many arbitrary decisions.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://shapeofdata.wordpress.com/2015/10/20/recurrent-neural-networks/feed/</wfw:commentRss>
			<slash:comments>6</slash:comments>
		
		
		
		<media:content url="https://1.gravatar.com/avatar/436b5ec3552d5e81ed4f45de75d36397?s=96&#38;d=https%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D96&#38;r=G" medium="image">
			<media:title type="html">jessejohnson</media:title>
		</media:content>

		<media:content url="https://shapeofdata.files.wordpress.com/2015/10/ann4.png" medium="image">
			<media:title type="html">ANN4</media:title>
		</media:content>

		<media:content url="https://shapeofdata.files.wordpress.com/2015/10/dag.png" medium="image">
			<media:title type="html">dag</media:title>
		</media:content>

		<media:content url="https://shapeofdata.files.wordpress.com/2015/10/rnn-inputs.png" medium="image">
			<media:title type="html">rnn-inputs</media:title>
		</media:content>
	</item>
		<item>
		<title>GPUs and Neural Networks</title>
		<link>https://shapeofdata.wordpress.com/2015/07/14/gpus-and-neural-networks/</link>
					<comments>https://shapeofdata.wordpress.com/2015/07/14/gpus-and-neural-networks/#comments</comments>
		
		<dc:creator><![CDATA[Jesse Johnson]]></dc:creator>
		<pubDate>Tue, 14 Jul 2015 20:34:11 +0000</pubDate>
				<category><![CDATA[Neural Networks]]></category>
		<guid isPermaLink="false">http://shapeofdata.wordpress.com/?p=1188</guid>

					<description><![CDATA[Artificial neural networks have been around for a long time &#8211; since either the 1940s or the 1950s, depending on how you count. But they&#8217;ve only started to be used for practical applications such as image recognition in the last &#8230; <a href="https://shapeofdata.wordpress.com/2015/07/14/gpus-and-neural-networks/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p><a href="https://shapeofdata.wordpress.com/2013/06/11/neural-networks-1-the-neuron/">Artificial neural networks</a> have been around for a long time &#8211; since either the 1940s or the 1950s, depending on how you count. But they&#8217;ve only started to be used for practical applications such as image recognition in the last few years. Some of the recent progress is based on theoretical breakthroughs such as <a href="https://shapeofdata.wordpress.com/2015/01/24/convolutional-neural-networks/">convolutional neural networks</a>, but a much bigger factor seems to be hardware: It turns out that small neural networks aren&#8217;t that much better than many simpler machine learning algorithms. Neural networks only excel when you have much more complex data and a large/complex network. But up until recently, the available hardware simply couldn&#8217;t handle such complexity. <a href="https://en.wikipedia.org/wiki/Moore%27s_law">Moore&#8217;s law</a> helped with this, but an even bigger part has been played by a type of chip called a GPU, or Graphical Processing Unit. These were originally designed to speed up computer animations, but they can also be used for other types of processing. In some cases, GPUs can be as much as 100 times as fast as standard <a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>s at certain tasks. However, it turns out you only get this speedup with a fairly narrow category of tasks, many of which happen to be necessary for processing neural networks. In this post, I want to discuss what types of task these are and why GPUs are so much faster at them.</p>
<p><span id="more-1188"></span>Lets start with the way traditional CPUs work, keeping in mind that I&#8217;m not a hardware expert, so much of what I&#8217;m going to say will be intentionally vague. Whenever your computer is running, your CPU is endlessly following a list of very simple instructions involving external inputs and outputs (RAM, hard disk, your Wifi card, etc) and a small amount of memory that&#8217;s internal to the CPU called <em>registers</em>. The number of registers is usually pretty small &#8211; for example, the Intel&#8217;s fancy <a href="https://en.wikipedia.org/wiki/Intel_Core#Core_i7">Core i7</a> processor has 16 64-bit registers.</p>
<p>The instructions that the CPU follows are along the lines of &#8220;Add the values in registers 1 and 2, then save the result in register 3&#8221; or &#8220;Copy the value at the memory location defined by register 1 into register 2&#8221; or &#8220;If the value of register 1 is greater than the value in register 2 then jump to the instruction number saved in register 3.&#8221; So if, for example, you wanted to add together two vectors in a 100-dimensional space, you would have to read each coordinate for each vector from RAM into a register, add the numbers, then save each value back into RAM.</p>
<p><a href="https://shapeofdata.files.wordpress.com/2015/07/cpu.png"><img data-attachment-id="1193" data-permalink="https://shapeofdata.wordpress.com/2015/07/14/gpus-and-neural-networks/cpu/" data-orig-file="https://shapeofdata.files.wordpress.com/2015/07/cpu.png" data-orig-size="512,274" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="CPU" data-image-description="" data-image-caption="" data-medium-file="https://shapeofdata.files.wordpress.com/2015/07/cpu.png?w=300" data-large-file="https://shapeofdata.files.wordpress.com/2015/07/cpu.png?w=512" class=" size-full wp-image-1193 aligncenter" src="https://shapeofdata.files.wordpress.com/2015/07/cpu.png?w=640" alt="CPU" srcset="https://shapeofdata.files.wordpress.com/2015/07/cpu.png 512w, https://shapeofdata.files.wordpress.com/2015/07/cpu.png?w=150 150w, https://shapeofdata.files.wordpress.com/2015/07/cpu.png?w=300 300w" sizes="(max-width: 512px) 100vw, 512px"   /></a></p>
<p>Many modern CPUs have multiple cores, each of which is simultaneously and independently doing what I described above. In theory, this could speed things up a bit by doing multiple coordinates at the same time, but in practice, coordinating multiple cores is complicated enough that it&#8217;s more common to have the different cores working on completely different tasks rather than different parts of the same task. Also, the number of cores tends to be small (between 2 and 6 seems pretty typical.)</p>
<p>A second type of parallelism that many processors can take advantage of is what&#8217;s called Single Instruction, Multiple Data (SIMD) architecture. This allows them to find sequences of independent/parallel instructions in an algorithm and perform them all in a single cycle. So, it might add the first four values of the vectors in a single cycle, then the next four and so on. This can cut the number of cycles dramatically, but the number of parallel instructions is limited by the number of registers, usually to around 4 or 8, so we&#8217;re still far from a 100-times speedup.</p>
<p>Instead, the speed up comes from two major ways in which GPUs differ from GCUs. The first is that rather than having a small number of registers, a GPU has a large chunk of internal memory that it can operate on directly. So if, say, you&#8217;re going to do a lot of processing involving a collection of vectors that fits into the GPU&#8217;s internal memory, then you can save the time of shuffling the values back and forth to/from RAM. Of course, this alone only gives you a small speedup, since passing values to/from memory only takes a fraction of a CPU&#8217;s time.</p>
<p>The big speed up comes from the fact that each time a GPU performs an operation, it can do it many times simultaneously. And it&#8217;s more than 2 or 6. Instead, 64 seems to be a typical size for the number of operations a GPU can do in parallel. Rather than an instruction like &#8220;Add register 1 to register 2&#8221; like the CPU had, a GPU instruction may be something like &#8220;Add the values in locations 1-64 to the values in locations 65-128, and save them in locations 129-192.&#8221; And this operation is done in a single step, simultaneously by 64 separate circuits within GPU. In other words, you can think of a GPU as having a row of CPUs that (unlike the multiple cores in a CPU) all follow the same instruction at the same time on different parts of the internal memory.</p>
<p><a href="https://shapeofdata.files.wordpress.com/2015/07/gpu.png"><img data-attachment-id="1194" data-permalink="https://shapeofdata.wordpress.com/2015/07/14/gpus-and-neural-networks/gpu/" data-orig-file="https://shapeofdata.files.wordpress.com/2015/07/gpu.png" data-orig-size="630,267" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="GPU" data-image-description="" data-image-caption="" data-medium-file="https://shapeofdata.files.wordpress.com/2015/07/gpu.png?w=300" data-large-file="https://shapeofdata.files.wordpress.com/2015/07/gpu.png?w=630" class="alignleft size-full wp-image-1194" src="https://shapeofdata.files.wordpress.com/2015/07/gpu.png?w=640" alt="GPU" srcset="https://shapeofdata.files.wordpress.com/2015/07/gpu.png 630w, https://shapeofdata.files.wordpress.com/2015/07/gpu.png?w=150 150w, https://shapeofdata.files.wordpress.com/2015/07/gpu.png?w=300 300w" sizes="(max-width: 630px) 100vw, 630px"   /></a></p>
<p>So now, when we add those 100-dimensional vectors, instead of reading in 200 values, adding them in 100 separate cycles, then transferring 100 values back to RAM for a total on the order of 100 consecutive operations (not to mention a bunch of overhead I&#8217;m glossing over), we only need two cycles of the GPU. We would still need to transfer the values in and out of the GPU&#8217;s internal memory, but if we&#8217;re doing a lot of processing on the same vectors, we can minimize this time by keeping them in the GPU&#8217;s memory until we&#8217;re done with them.</p>
<p>So tasks that involve doing the same thing at the same time to lots of different data (such as vector and matrix operations) can be done much faster on GPUs. In fact, it&#8217;s because matrix operations are so important to computer graphics that GPUs were designed this way. Note that GPUs tend to be slower than CPUs in terms of the number of cycles per second, plus they lack many optimization features that modern CPUs have. So for tasks that can&#8217;t take advantage of parallelism &#8211; i.e. almost everything other than vector and matrix operations &#8211; CPUs are much faster. That&#8217;s why the computer you&#8217;re working on right now has a CPU at its center instead of a GPU.</p>
<p>But the processes involved in training and evaluating a neural network happen to fit very nicely into the vector/matrix genre. The &#8220;knowledge&#8221; in a neural network is defined by the weights on the connections between neurons. For example in a network with rows of neurons, the weights between successive rows are defined by a matrix in which the entry at position <em>(i, j)</em> is the weight from the <em>i</em>th neuron in the first row to the <em>j</em>th neuron in the second row. Each row, in turn, defines a vector, and we <a href="https://shapeofdata.wordpress.com/2013/06/18/neural-networks-2-evaluation/">calculate the output</a> from each neuron by multiplying the outputs of the first row by this matrix, then applying a non-linear function to the resulting vector. We do this for each successive row until we get to the end of the network. Training the network via <a href="https://shapeofdata.wordpress.com/2013/06/24/neural-networks-3-training/">back-propagation</a> is another process involving these same vectors and matrices.</p>
<p>As a result, it&#8217;s possible in practice to work with much larger neural networks than would be otherwise possible, even after a few more decades of Moore&#8217;s Law. This is important, for example, in image processing where the first row alone (i.e. the input) contains thousands of neurons. Things still get tricky when the networks get too big to fit in the memory of a single GPU. At that point multiple GPUs are required to store the network, and data must be transferred between them, which becomes the major bottleneck. But that&#8217;s a whole different story. For now, this is at least the rough idea behind why GPUs have been one of the main drivers of the recent success of large-scale neural networks.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://shapeofdata.wordpress.com/2015/07/14/gpus-and-neural-networks/feed/</wfw:commentRss>
			<slash:comments>11</slash:comments>
		
		
		
		<media:content url="https://1.gravatar.com/avatar/436b5ec3552d5e81ed4f45de75d36397?s=96&#38;d=https%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D96&#38;r=G" medium="image">
			<media:title type="html">jessejohnson</media:title>
		</media:content>

		<media:content url="https://shapeofdata.files.wordpress.com/2015/07/cpu.png" medium="image">
			<media:title type="html">CPU</media:title>
		</media:content>

		<media:content url="https://shapeofdata.files.wordpress.com/2015/07/gpu.png" medium="image">
			<media:title type="html">GPU</media:title>
		</media:content>
	</item>
	</channel>
</rss>
