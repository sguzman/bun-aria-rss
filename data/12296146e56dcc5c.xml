<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns:yt="http://www.youtube.com/xml/schemas/2015" xmlns:media="http://search.yahoo.com/mrss/" xmlns="http://www.w3.org/2005/Atom">
 <link rel="self" href="http://www.youtube.com/feeds/videos.xml?channel_id=UC_iD0xppBwwsrM9DegC5cQQ"/>
 <id>yt:channel:UC_iD0xppBwwsrM9DegC5cQQ</id>
 <yt:channelId>UC_iD0xppBwwsrM9DegC5cQQ</yt:channelId>
 <title>Jon Gjengset</title>
 <link rel="alternate" href="https://www.youtube.com/channel/UC_iD0xppBwwsrM9DegC5cQQ"/>
 <author>
  <name>Jon Gjengset</name>
  <uri>https://www.youtube.com/channel/UC_iD0xppBwwsrM9DegC5cQQ</uri>
 </author>
 <published>2013-11-17T12:03:02+00:00</published>
 <entry>
  <id>yt:video:O2Ds0U0pXo8</id>
  <yt:videoId>O2Ds0U0pXo8</yt:videoId>
  <yt:channelId>UC_iD0xppBwwsrM9DegC5cQQ</yt:channelId>
  <title>Day in the Life of Open Source Maintenance: 2022-10-08</title>
  <link rel="alternate" href="https://www.youtube.com/watch?v=O2Ds0U0pXo8"/>
  <author>
   <name>Jon Gjengset</name>
   <uri>https://www.youtube.com/channel/UC_iD0xppBwwsrM9DegC5cQQ</uri>
  </author>
  <published>2022-10-09T02:44:54+00:00</published>
  <updated>2022-10-16T15:31:10+00:00</updated>
  <media:group>
   <media:title>Day in the Life of Open Source Maintenance: 2022-10-08</media:title>
   <media:content url="https://www.youtube.com/v/O2Ds0U0pXo8?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
   <media:thumbnail url="https://i4.ytimg.com/vi/O2Ds0U0pXo8/hqdefault.jpg" width="480" height="360"/>
   <media:description>Another trip through my GitHub notifications for open-source Rust projects. This video provides a view into what regular, day-to-day open-source maintenance looks like. We review a few PRs to different project and triage some issues, all linked below, as well as discuss some of the challenges of being an OSS maintainer.

0:00:00 Introduction
0:01:00 rust-lang/rust#95545
0:01:50 jonhoo/tracing-timing#17
0:06:58 Leaving notifications unread
0:08:19 jonhoo/flurry#109
0:39:10 rust-lang/cargo#10992
1:02:07 jonhoo/fantoccini#186
1:36:46 jonhoo/rust-imap#243
1:49:14 jonhoo/roget#23
1:58:25 jonhoo/inferno#258
2:17:47 openssh-rust/openssh#101
2:33:50 Outro

Live version with chat: https://youtu.be/w2lHwmf9Dpw</media:description>
   <media:community>
    <media:starRating count="396" average="5.00" min="1" max="5"/>
    <media:statistics views="19238"/>
   </media:community>
  </media:group>
 </entry>
 <entry>
  <id>yt:video:pePqWoTnSmQ</id>
  <yt:videoId>pePqWoTnSmQ</yt:videoId>
  <yt:channelId>UC_iD0xppBwwsrM9DegC5cQQ</yt:channelId>
  <title>Crust of Rust: Build Scripts and Foreign-Function Interfaces (FFI)</title>
  <link rel="alternate" href="https://www.youtube.com/watch?v=pePqWoTnSmQ"/>
  <author>
   <name>Jon Gjengset</name>
   <uri>https://www.youtube.com/channel/UC_iD0xppBwwsrM9DegC5cQQ</uri>
  </author>
  <published>2022-09-24T20:25:06+00:00</published>
  <updated>2022-10-02T15:39:48+00:00</updated>
  <media:group>
   <media:title>Crust of Rust: Build Scripts and Foreign-Function Interfaces (FFI)</media:title>
   <media:content url="https://www.youtube.com/v/pePqWoTnSmQ?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
   <media:thumbnail url="https://i1.ytimg.com/vi/pePqWoTnSmQ/hqdefault.jpg" width="480" height="360"/>
   <media:description>This time we go over Cargo build scripts and Rust foreign-function interfaces, including looking at some widely used *-sys crates. We also wrote our own bindings against the libsodium C library: https://doc.libsodium.org/. You can find the Cargo book entry for build scripts at https://doc.rust-lang.org/cargo/reference/build-scripts.html, and the nomicon entry for ffi at https://doc.rust-lang.org/nomicon/ffi.html.

Live version with chat: https://youtu.be/pSTPJ39LsEU

0:00:00 Introduction
0:02:58 libsodium
0:04:28 Build scripts
0:07:00 OUT_DIR
0:18:01 cargo directives
0:34:09 Build script sandboxing
0:36:36 libgit2-sys
0:54:31 bindgen
1:08:08 libssh2-sys
1:14:38 openssl-sys
1:19:50 libsodium-sys
1:21:29 Writing our own libsodium-sys
1:40:11 Wrapping crypto_generichash
2:02:57 Reverse FFI
2:09:30 autocfg
2:12:14 cbindgen and cxx

The Rustacean Station Discord server is at https://discord.gg/RJdqQ9n.</media:description>
   <media:community>
    <media:starRating count="476" average="5.00" min="1" max="5"/>
    <media:statistics views="18255"/>
   </media:community>
  </media:group>
 </entry>
 <entry>
  <id>yt:video:pMiqRM5ooNw</id>
  <yt:videoId>pMiqRM5ooNw</yt:videoId>
  <yt:channelId>UC_iD0xppBwwsrM9DegC5cQQ</yt:channelId>
  <title>Making a Rust crate compile faster</title>
  <link rel="alternate" href="https://www.youtube.com/watch?v=pMiqRM5ooNw"/>
  <author>
   <name>Jon Gjengset</name>
   <uri>https://www.youtube.com/channel/UC_iD0xppBwwsrM9DegC5cQQ</uri>
  </author>
  <published>2022-07-02T02:13:54+00:00</published>
  <updated>2022-08-19T15:38:54+00:00</updated>
  <media:group>
   <media:title>Making a Rust crate compile faster</media:title>
   <media:content url="https://www.youtube.com/v/pMiqRM5ooNw?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
   <media:thumbnail url="https://i1.ytimg.com/vi/pMiqRM5ooNw/hqdefault.jpg" width="480" height="360"/>
   <media:description>In this stream, we try to figured out why the `cargo` crate takes so long to build. We don't ultimately make a meaningful improvement, but we do explore the many tools that exist to help with both analysis and remediation, and the value (and shortcomings) of each one.

Why is my Rust build so slow? https://fasterthanli.me/articles/why-is-my-rust-build-so-slow
-Zsparse-registry https://blog.rust-lang.org/2022/06/22/sparse-registry-testing.html
cargo --timings https://blog.rust-lang.org/2022/04/07/Rust-1.60.0.html#cargo---timings
mold https://github.com/rui314/mold
-Zshare-generics https://github.com/rust-lang/rust/blob/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966/compiler/rustc_middle/src/ty/instance.rs#L112
cargo-bloat https://github.com/RazrFalcon/cargo-bloat
Non-generic inner functions. https://www.possiblerust.com/pattern/non-generic-inner-functions
cargo-llvm-lines https://github.com/dtolnay/cargo-llvm-lines
-Zsymbol-mangling=v0 https://rust-lang.github.io/rfcs/2603-rust-symbol-name-mangling-v0.html
-Zself-profile https://rust-lang.github.io/compiler-team/working-groups/self-profile/
crox https://github.com/rust-lang/measureme/blob/master/crox/README.md
miniserde https://github.com/dtolnay/miniserde
watt https://github.com/dtolnay/watt
Where rustc spends its time. https://wiki.alopex.li/WhereRustcSpendsItsTime

0:00:00 Introduction
0:02:27 Setting up a test project
0:08:25 cargo build --timings
0:16:45 Linking
0:29:30 cargo bloat
0:40:50 -Zshare-generics
0:47:00 cargo-llvm-lines
1:24:56 rustc -Zself-profile
2:04:36 perf record rustc
2:13:10 miniserde
2:16:35 watt
2:25:00 Conclusion
2:25:40 Q&amp;A
2:26:58 Overhead of monomorphization
2:27:51 Rust build time in 2-3 years
2:30:04 Do this again with new tools?
2:30:59 Breaking Cargo into subcrates
2:32:20 Is --release time important?
2:32:56 Automatic inner functions
2:34:46 Rust build time and adoption
2:37:00 Proc macro build time
2:41:25 Feature creep in Rust
2:43:05 Outroduction

Live version with chat: https://youtu.be/vxB4R2Guwp8</media:description>
   <media:community>
    <media:starRating count="626" average="5.00" min="1" max="5"/>
    <media:statistics views="26223"/>
   </media:community>
  </media:group>
 </entry>
 <entry>
  <id>yt:video:lkwkBry1xcE</id>
  <yt:videoId>lkwkBry1xcE</yt:videoId>
  <yt:channelId>UC_iD0xppBwwsrM9DegC5cQQ</yt:channelId>
  <title>Day in the Life of Open Source Maintenance 2022-06-19</title>
  <link rel="alternate" href="https://www.youtube.com/watch?v=lkwkBry1xcE"/>
  <author>
   <name>Jon Gjengset</name>
   <uri>https://www.youtube.com/channel/UC_iD0xppBwwsrM9DegC5cQQ</uri>
  </author>
  <published>2022-06-19T13:51:10+00:00</published>
  <updated>2022-10-09T02:20:40+00:00</updated>
  <media:group>
   <media:title>Day in the Life of Open Source Maintenance 2022-06-19</media:title>
   <media:content url="https://www.youtube.com/v/lkwkBry1xcE?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
   <media:thumbnail url="https://i1.ytimg.com/vi/lkwkBry1xcE/hqdefault.jpg" width="480" height="360"/>
   <media:description>Inspired by a tweet — https://twitter.com/jonhoo/status/1538210301484535808 — this video is a view into what regular, day-to-day open-source maintenance looks like. We review a few PRs to different project and triage some issues, all linked below, as well as discuss some of the challenges in being an OSS maintainer.

Live version with chat: https://youtu.be/aT5i9jCNRLg

0:00:00 Introduction
0:03:20 Rustacean Station https://github.com/rustacean-station/rustacean-station.org/pull/154
0:04:50 Notifications we'll skip
0:06:13 cargo: target-applies-to-host bug https://github.com/rust-lang/cargo/issues/10744
0:08:35 hashbag: HashBag::difference https://github.com/jonhoo/hashbag/pull/6
0:49:45 openssh-sftp-client: !Unpin support https://github.com/openssh-rust/openssh-sftp-client/pull/8
0:54:52 openssh: resuming sessions https://github.com/openssh-rust/openssh/pull/80
1:11:56 openssh: Dependabot accidentally breaking change https://github.com/openssh-rust/openssh/pull/81
1:24:53 inferno: text alignment improvement https://github.com/jonhoo/inferno/issues/247
1:28:00 std: Switchable buffering for Stdout https://github.com/rust-lang/rust/pull/78515
1:29:16 haphazard: Soundness bug https://github.com/jonhoo/haphazard/issues/36
1:38:00 OSS conversation venues
1:42:08 inferno: lazy_static to once_cell https://github.com/jonhoo/inferno/pull/249
1:55:45 Nitpicking in PRs
2:00:51 inferno: PHP XDebug support https://github.com/jonhoo/inferno/pull/126
2:05:00 bus: dependency update and CI fix https://github.com/jonhoo/bus/pull/29
2:21:30 When to use Miri in CI
2:22:50 Staying motivated in OSS
2:28:35 Would you do OSS full time?</media:description>
   <media:community>
    <media:starRating count="623" average="5.00" min="1" max="5"/>
    <media:statistics views="23886"/>
   </media:community>
  </media:group>
 </entry>
 <entry>
  <id>yt:video:aGrlEdAe6YE</id>
  <yt:videoId>aGrlEdAe6YE</yt:videoId>
  <yt:channelId>UC_iD0xppBwwsrM9DegC5cQQ</yt:channelId>
  <title>Post-Crust of Rust Q&amp;A</title>
  <link rel="alternate" href="https://www.youtube.com/watch?v=aGrlEdAe6YE"/>
  <author>
   <name>Jon Gjengset</name>
   <uri>https://www.youtube.com/channel/UC_iD0xppBwwsrM9DegC5cQQ</uri>
  </author>
  <published>2022-06-11T23:10:55+00:00</published>
  <updated>2022-09-02T07:46:25+00:00</updated>
  <media:group>
   <media:title>Post-Crust of Rust Q&amp;A</media:title>
   <media:content url="https://www.youtube.com/v/aGrlEdAe6YE?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
   <media:thumbnail url="https://i2.ytimg.com/vi/aGrlEdAe6YE/hqdefault.jpg" width="480" height="360"/>
   <media:description>Links from the video:

My dotfiles/configs: https://github.com/jonhoo/configs
bspwm: https://github.com/baskerville/bspwm
Safe transmutes: https://github.com/rust-lang/project-safe-transmute
Spain map: https://muir-way.com/collections/all/products/spain-and-portugal-1879-relief-map
Rustacean Station egui episode: https://rustacean-station.org/episode/emil-ernerfeldt/
Strict provenance: https://github.com/rust-lang/rust/issues/95228
Ralf's article on provenance: https://www.ralfj.de/blog/2020/12/14/provenance.html
Removing scoped threads: https://github.com/rust-lang/rust/issues/24292
Adding back scoped threads: https://github.com/rust-lang/rust/issues/93203
VIM adventure game: https://vim-adventures.com/
mem::forget is safe: https://github.com/rust-lang/rust/issues/24456
NLL: https://github.com/rust-lang/rust/issues/57895
Hazard pointer library: https://docs.rs/haphazard/
Blood on the Clocktower: https://bloodontheclocktower.com/
My board game list: https://boardgamegeek.com/collection/user/jonhoo?subtype=boardgame&amp;ff=1
Doppelkopf: https://en.m.wikipedia.org/wiki/Doppelkopf
Hanabi Slack bot: https://github.com/jonhoo/hanabot

Live version with chat: https://youtu.be/xmkSDM5omFA

0:00:00 Introduction
0:00:53 Send and structs with raw pointers
0:01:15 Stream about current setup
0:02:24 Safe transmute
0:03:11 The map behind me
0:03:45 What do you do outside of work?
0:05:14 Learning Rust at AWS
0:06:51 Rust GUI
0:07:21 Adding a new OS to Rust
0:08:21 What do you do at AWS?
0:09:29 Casting pointers to/from usize
0:11:42 &quot;Rust is Hard&quot;
0:13:14 scoped threads
0:14:35 Breakpoints in async Rust
0:16:45 Plan to write more books?
0:18:07 A trait for &quot;owned value&quot;
0:19:03 &quot;Good Reasons to Avoid Rust&quot;
0:21:28 Adding Redox support to Rust
0:22:46 Will Rust be ready for web dev?
0:24:19 VIM tutorials?
0:25:53 Why is mem::forget safe?
0:26:37 Communicating between Rust processes
0:27:52 Learning C++ before Rust
0:28:35 NLL stabilization
0:29:39 Where in Europe would you live?
0:32:12 Mutably borrowing disjoint slice parts
0:32:49 Hazard pointers
0:34:38 Internet speeds
0:36:59 What language will you try next?
0:39:37 Is C++ still useful?
0:41:40 How do you get confident in teaching?
0:43:46 Next stream topic
0:45:55 async vs threads
0:48:38 Does Rust make programs more secure?
0:50:22 Suggesting stream ideas
0:51:40 Distribute systems streams
0:52:55 What's your keyboard?
0:54:00 Scientific computing in Rust
0:55:00 Why are distributed systems hairy?
0:56:22 Most joyful luxury item
0:58:15 Public transportation in LA
0:59:38 Favorite board game(s)
1:05:53 More luxury item discussion
1:07:52 Cats!
1:10:10 Writing bots for learning
1:10:45 TV shows
1:11:38 Is Jay a llama or an alpaca?
1:12:18 Wordplay (and naming things)
1:13:23 Is English your first language?
1:14:32 Going to SHUX? RustConf?
1:15:12 Streaming non-programming content?
1:16:13 Topics you found hard to grasp?
1:17:49 Video games
1:19:39 Making me pick up a stream topic
1:20:21 Why not Counter Strike again?
1:21:20 Rounding off</media:description>
   <media:community>
    <media:starRating count="276" average="5.00" min="1" max="5"/>
    <media:statistics views="11746"/>
   </media:community>
  </media:group>
 </entry>
 <entry>
  <id>yt:video:yOezcP-XaIw</id>
  <yt:videoId>yOezcP-XaIw</yt:videoId>
  <yt:channelId>UC_iD0xppBwwsrM9DegC5cQQ</yt:channelId>
  <title>Crust of Rust: Send, Sync, and their implementors</title>
  <link rel="alternate" href="https://www.youtube.com/watch?v=yOezcP-XaIw"/>
  <author>
   <name>Jon Gjengset</name>
   <uri>https://www.youtube.com/channel/UC_iD0xppBwwsrM9DegC5cQQ</uri>
  </author>
  <published>2022-06-11T23:10:39+00:00</published>
  <updated>2022-08-19T15:42:41+00:00</updated>
  <media:group>
   <media:title>Crust of Rust: Send, Sync, and their implementors</media:title>
   <media:content url="https://www.youtube.com/v/yOezcP-XaIw?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
   <media:thumbnail url="https://i2.ytimg.com/vi/yOezcP-XaIw/hqdefault.jpg" width="480" height="360"/>
   <media:description>This time we go over the Send and Sync marker traits from the standard library, as well as some of the most important implementors (and non-implementors) of them. You can find the nomicon entry for Send/Sync here: https://doc.rust-lang.org/nomicon/send-and-sync.html.

Live version with chat: https://youtu.be/xmkSDM5omFA

0:00:00 Why Send and Sync?
0:01:31 What are Send and Sync?
0:02:51 Marker traits
0:03:50 Auto traits
0:05:45 The Send trait
0:06:49 Types that aren't Send
0:09:40 Digging into Rc
0:23:52 The Sync trait
0:26:21 Send + !Sync
0:32:41 Negative implementations
0:35:17 Sending mutable references
0:37:00 Raw pointers
0:41:54 std::sync::mpsc and !Sync
0:42:30 Placement of T: Send/Sync bounds
0:46:04 Per-OS impl Send for guards
0:47:06 more std::sync::mpsc and !Sync
0:48:40 Is Send/Sync auto-implemented?
0:50:40 The nomicon Send/Sync entry
0:52:57 There's no magic!
1:02:46 Negative impls on stable</media:description>
   <media:community>
    <media:starRating count="639" average="5.00" min="1" max="5"/>
    <media:statistics views="23747"/>
   </media:community>
  </media:group>
 </entry>
 <entry>
  <id>yt:video:doFowk4xj7Q</id>
  <yt:videoId>doFowk4xj7Q</yt:videoId>
  <yt:channelId>UC_iD0xppBwwsrM9DegC5cQQ</yt:channelId>
  <title>Implementing and Optimizing a Wordle Solver in Rust</title>
  <link rel="alternate" href="https://www.youtube.com/watch?v=doFowk4xj7Q"/>
  <author>
   <name>Jon Gjengset</name>
   <uri>https://www.youtube.com/channel/UC_iD0xppBwwsrM9DegC5cQQ</uri>
  </author>
  <published>2022-03-06T05:39:37+00:00</published>
  <updated>2022-08-19T15:34:45+00:00</updated>
  <media:group>
   <media:title>Implementing and Optimizing a Wordle Solver in Rust</media:title>
   <media:content url="https://www.youtube.com/v/doFowk4xj7Q?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
   <media:thumbnail url="https://i1.ytimg.com/vi/doFowk4xj7Q/hqdefault.jpg" width="480" height="360"/>
   <media:description>We implement a Wordle solver in Rust based off on the excellent
3blue1brown video on the same topic:
https://www.youtube.com/watch?v=v68zYyaEmEA

And then we profile and optimize it to improve the runtime from our
initial naive implementation by ~13500x. You can find the code at
https://github.com/jonhoo/roget.

0:00:00 Introduction
0:01:00 Wordle intro
0:04:50 What we're doing today
0:11:24 Gathering our datasets
0:27:22 Structure the solver
0:44:04 The correctness of a guess
1:14:28 Testing the play machinery
1:30:16 Outlining the algorithm
1:38:55 Does a word match a pattern?
2:21:12 Reusing correctness computation
2:26:06 Computing a word's &quot;goodness&quot;
2:49:20 Running the naive implementation
2:57:59 Profiling to the rescue
3:04:44 Avoiding allocations
3:22:05 Comparing bytes, not characters
3:31:58 Correctness computing is faster
3:42:23 HashMap iteration is slow
3:47:40 Compare bytes again
3:50:20 Trying to avoid bounds checks
3:54:42 Keep words as length 5 arrays
4:07:36 Only initialize remaining once
4:21:00 Back to length 5 arrays
4:32:14 Where is compute spending time?
4:51:20 Short break
4:55:20 What if we don't set the first word?
5:02:49 What if we start with another word?
5:07:15 Precalculating matches
5:31:20 Prefer more likely words
5:38:05 Prune known-empty patterns
5:56:24 Don't even consider unlikely words
6:07:36 Closing thoughts

Live version with chat: https://youtu.be/cfjQw4ZjAiI</media:description>
   <media:community>
    <media:starRating count="1489" average="5.00" min="1" max="5"/>
    <media:statistics views="83926"/>
   </media:community>
  </media:group>
 </entry>
 <entry>
  <id>yt:video:3oL1xokuHBE</id>
  <yt:videoId>3oL1xokuHBE</yt:videoId>
  <yt:channelId>UC_iD0xppBwwsrM9DegC5cQQ</yt:channelId>
  <title>Implementing Hazard Pointers in Rust (part 4/4)</title>
  <link rel="alternate" href="https://www.youtube.com/watch?v=3oL1xokuHBE"/>
  <author>
   <name>Jon Gjengset</name>
   <uri>https://www.youtube.com/channel/UC_iD0xppBwwsrM9DegC5cQQ</uri>
  </author>
  <published>2022-01-15T22:58:19+00:00</published>
  <updated>2022-08-19T15:41:32+00:00</updated>
  <media:group>
   <media:title>Implementing Hazard Pointers in Rust (part 4/4)</media:title>
   <media:content url="https://www.youtube.com/v/3oL1xokuHBE?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
   <media:thumbnail url="https://i4.ytimg.com/vi/3oL1xokuHBE/hqdefault.jpg" width="480" height="360"/>
   <media:description>We continue our journey implementing Hazard Pointers (https://erdani.org/publications/cuj-2004-12.pdf) in Rust. We follow along with the C++ implementation in Facebook's Folly library (https://github.com/facebook/folly/blob/master/folly/synchronization/Hazptr.h), starting from where we left off last time: https://github.com/facebook/folly/tree/0e92d3c2705a45ba7850708fd7fe0c709d6a0e5f.

This time, the focus is on porting over tests and benchmarks, including using loom (for concurrency testing) and criterion (for benchmarks).

https://twitter.com/jonhoo/status/1482179476423208963

0:00:00 Introduction
0:02:22 Changes since last stream
0:11:39 The Twitter poll
0:13:35 folly's test suite
0:38:31 Domain::cleanup
0:45:19 Porting folly tests
1:44:51 Custom deleters
1:58:49 Porting spin test to loom
2:46:36 Benchmarking hazard pointer creation
3:15:12 Benchmarking retire and reclaim
3:21:08 drop(stream)

You can find the code here: https://github.com/jonhoo/haphazard/

Live version with chat: https://youtu.be/t0Nza-v1XIg</media:description>
   <media:community>
    <media:starRating count="151" average="5.00" min="1" max="5"/>
    <media:statistics views="10191"/>
   </media:community>
  </media:group>
 </entry>
 <entry>
  <id>yt:video:tGn0mQF0804</id>
  <yt:videoId>tGn0mQF0804</yt:videoId>
  <yt:channelId>UC_iD0xppBwwsrM9DegC5cQQ</yt:channelId>
  <title>Implementing Hazard Pointers in Rust (part 3)</title>
  <link rel="alternate" href="https://www.youtube.com/watch?v=tGn0mQF0804"/>
  <author>
   <name>Jon Gjengset</name>
   <uri>https://www.youtube.com/channel/UC_iD0xppBwwsrM9DegC5cQQ</uri>
  </author>
  <published>2021-10-31T15:48:47+00:00</published>
  <updated>2022-07-22T14:47:43+00:00</updated>
  <media:group>
   <media:title>Implementing Hazard Pointers in Rust (part 3)</media:title>
   <media:content url="https://www.youtube.com/v/tGn0mQF0804?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
   <media:thumbnail url="https://i1.ytimg.com/vi/tGn0mQF0804/hqdefault.jpg" width="480" height="360"/>
   <media:description>We continue our journey implementing Hazard Pointers (https://erdani.org/publications/cuj-2004-12.pdf) in Rust. We follow along with the C++ implementation in Facebook's Folly library (https://github.com/facebook/folly/blob/master/folly/synchronization/Hazptr.h), starting from where we left off last time: https://github.com/jonhoo/haphazard/tree/29b41ba3c3e31a7b044e489a67d61d5a009e9d3f. Much of the stream is catching up with the change to folly since last time (https://github.com/facebook/folly/commits/main?before=d2154674583a01e9d76e2c38e1c37e531132099e+35&amp;branch=main&amp;path%5B%5D=folly&amp;path%5B%5D=synchronization), though we do also get to writing some concurrency tests with loom (https://docs.rs/loom/).

0:00:00 Introduction
0:03:12 Follow-up from last time
0:05:55 Re-visiting the interface
0:17:16 rebase: reset_protection
0:19:17 Folly changes since last time
0:22:50 rebase: hazard pointer constructors
0:41:39 rebase: irrelevant c++ commits
0:42:28 rebase: type renames
0:56:45 rebase: more irrelevant c++ commits
1:02:15 rebase: from push_retire to push_list
2:59:18 Tracking down a segfault with gdb
3:04:37 rebase: sharding the untagged list
3:44:08 rebase: track available hazard pointers
3:57:15 A quick break
4:01:10 cont'd: track available hazard pointers
5:03:48 Concurrency testing with loom
5:45:25 Writing a loom test
6:30:31 Test with two readers
6:40:22 Test dropping a non-global domain
6:45:35 Summary and next steps

You can find the latest code for the implementation at https://github.com/jonhoo/haphazard.

Live version with chat: https://youtu.be/2Iu2BnO9iHg</media:description>
   <media:community>
    <media:starRating count="151" average="5.00" min="1" max="5"/>
    <media:statistics views="9808"/>
   </media:community>
  </media:group>
 </entry>
 <entry>
  <id>yt:video:dHkzSZnYXmk</id>
  <yt:videoId>dHkzSZnYXmk</yt:videoId>
  <yt:channelId>UC_iD0xppBwwsrM9DegC5cQQ</yt:channelId>
  <title>Crust of Rust: Functions, Closures, and Their Traits</title>
  <link rel="alternate" href="https://www.youtube.com/watch?v=dHkzSZnYXmk"/>
  <author>
   <name>Jon Gjengset</name>
   <uri>https://www.youtube.com/channel/UC_iD0xppBwwsrM9DegC5cQQ</uri>
  </author>
  <published>2021-10-08T19:19:27+00:00</published>
  <updated>2022-02-20T19:02:15+00:00</updated>
  <media:group>
   <media:title>Crust of Rust: Functions, Closures, and Their Traits</media:title>
   <media:content url="https://www.youtube.com/v/dHkzSZnYXmk?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
   <media:thumbnail url="https://i1.ytimg.com/vi/dHkzSZnYXmk/hqdefault.jpg" width="480" height="360"/>
   <media:description>In this episode, we go over the differences between function items, function pointers, and closures, as well as how they interact with the Fn* traits. We also touch upon dynamically dispatched Fns and experimental const Fn bounds.

I've spliced out some audio issues that occurred on the live-stream, but hopefully it won't be too noticeable :p

0:00:00 Introduction
0:01:20 Rust for Rustaceans
0:02:48 Function items
0:06:26 Function pointers
0:11:24 Function traits
0:20:40 Closures
0:33:49 Non-static closures
0:38:50 dyn Fn
0:49:44 const Fn
1:00:28 for bounds
1:04:06 closures in async fn

Live version with chat: https://youtu.be/QVK4Ooo_PqM</media:description>
   <media:community>
    <media:starRating count="1303" average="5.00" min="1" max="5"/>
    <media:statistics views="51191"/>
   </media:community>
  </media:group>
 </entry>
 <entry>
  <id>yt:video:ThjvMReOXYM</id>
  <yt:videoId>ThjvMReOXYM</yt:videoId>
  <yt:channelId>UC_iD0xppBwwsrM9DegC5cQQ</yt:channelId>
  <title>Crust of Rust: async/await</title>
  <link rel="alternate" href="https://www.youtube.com/watch?v=ThjvMReOXYM"/>
  <author>
   <name>Jon Gjengset</name>
   <uri>https://www.youtube.com/channel/UC_iD0xppBwwsrM9DegC5cQQ</uri>
  </author>
  <published>2021-08-31T23:29:24+00:00</published>
  <updated>2022-09-26T16:38:39+00:00</updated>
  <media:group>
   <media:title>Crust of Rust: async/await</media:title>
   <media:content url="https://www.youtube.com/v/ThjvMReOXYM?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
   <media:thumbnail url="https://i1.ytimg.com/vi/ThjvMReOXYM/hqdefault.jpg" width="480" height="360"/>
   <media:description>Finally, we tackle the topic of async/await in Rust, and specifically looking at how to use and think about async/await more so than how it works under the hood. My hope with this video is to convey the mental model and intuition you should use when using async/await in your own code, without getting bogged down in the details of Future, Pin, and Wakers.

0:00:00 Introduction
0:04:49 Fixing the video title
0:05:28 What is async fn?
0:10:40 awaiting futures
0:17:00 Yielding
0:20:03 Awaiting one of multiple futures
0:34:46 Cancellation
0:37:58 Executing futures
0:50:50 Select arms with side-effects
0:55:35 Cooperative scheduling
0:58:38 Selects with many arms
1:01:51 Fused futures
1:04:35 Overhead of async
1:07:56 Is select a future?
1:09:20 Awaiting multiple futures
1:19:17 Parallelism and spawning
1:30:37 Sharing across spawn
1:36:23 Runtime discovery
1:42:05 Stack variables in async
1:55:45 Async fn in traits
2:08:06 Asynchronous Mutexes
2:21:03 Do futures stay on a thread?
2:24:11 Async stack traces
2:33:04 Wrapping up

The async book: https://rust-lang.github.io/async-book/
Tokio's mini-redis: https://github.com/tokio-rs/mini-redis/


Live version with chat: https://youtu.be/CaCYL11_qEU</media:description>
   <media:community>
    <media:starRating count="2435" average="5.00" min="1" max="5"/>
    <media:statistics views="101339"/>
   </media:community>
  </media:group>
 </entry>
 <entry>
  <id>yt:video:_LK7qvBWNYo</id>
  <yt:videoId>_LK7qvBWNYo</yt:videoId>
  <yt:channelId>UC_iD0xppBwwsrM9DegC5cQQ</yt:channelId>
  <title>Implementing Hazard Pointers in Rust (part 2)</title>
  <link rel="alternate" href="https://www.youtube.com/watch?v=_LK7qvBWNYo"/>
  <author>
   <name>Jon Gjengset</name>
   <uri>https://www.youtube.com/channel/UC_iD0xppBwwsrM9DegC5cQQ</uri>
  </author>
  <published>2021-07-10T23:59:55+00:00</published>
  <updated>2022-08-19T15:42:54+00:00</updated>
  <media:group>
   <media:title>Implementing Hazard Pointers in Rust (part 2)</media:title>
   <media:content url="https://www.youtube.com/v/_LK7qvBWNYo?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
   <media:thumbnail url="https://i4.ytimg.com/vi/_LK7qvBWNYo/hqdefault.jpg" width="480" height="360"/>
   <media:description>We continue our journey implementing Hazard Pointers (https://erdani.org/publications/cuj-2004-12.pdf) in Rust. We follow along with the C++ implementation in Facebook's Folly library (https://github.com/facebook/folly/blob/master/folly/synchronization/Hazptr.h), starting from where we left off last time: https://github.com/jonhoo/haphazard/tree/7f0d8d62e071f8bc55233a3d2437225d6282e368



0:00:00 Introduction
0:01:50 Where we left off
0:05:50 PRs fixing problems from part 1
0:10:35 Update on issues we filed
0:20:37 Bugs I found
0:35:12 Can deleter alias be const?
0:38:35 impl Drop vs drop in vtable
0:40:25 Some Rust Q&amp;A
0:43:20 Splitting up into modules
0:56:56 Support for custom domains
2:19:30 Improving static domain safety
2:58:04 Intermission
3:02:02 Aligning with Folly's HazPtrDomain
4:39:03 Aligning with Folly's HazPtrHolder
5:18:32 Aligning with Folly's HazPtrObject

5:25:10 Where we are and where next?


You can find the latest code for the implementation at https://github.com/jonhoo/haphazard.

Live version with chat: https://youtu.be/Hy8VfC2FwBM</media:description>
   <media:community>
    <media:starRating count="121" average="5.00" min="1" max="5"/>
    <media:statistics views="8831"/>
   </media:community>
  </media:group>
 </entry>
 <entry>
  <id>yt:video:fvcbyCYdR10</id>
  <yt:videoId>fvcbyCYdR10</yt:videoId>
  <yt:channelId>UC_iD0xppBwwsrM9DegC5cQQ</yt:channelId>
  <title>Implementing Hazard Pointers in Rust</title>
  <link rel="alternate" href="https://www.youtube.com/watch?v=fvcbyCYdR10"/>
  <author>
   <name>Jon Gjengset</name>
   <uri>https://www.youtube.com/channel/UC_iD0xppBwwsrM9DegC5cQQ</uri>
  </author>
  <published>2021-06-26T23:44:00+00:00</published>
  <updated>2022-08-19T15:41:19+00:00</updated>
  <media:group>
   <media:title>Implementing Hazard Pointers in Rust</media:title>
   <media:content url="https://www.youtube.com/v/fvcbyCYdR10?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
   <media:thumbnail url="https://i3.ytimg.com/vi/fvcbyCYdR10/hqdefault.jpg" width="480" height="360"/>
   <media:description>This time, we take a stab at implementing Hazard Pointers (https://erdani.org/publications/cuj-2004-12.pdf) in Rust. We follow along with the C++ implementation in Facebook's Folly library (https://github.com/facebook/folly/blob/master/folly/synchronization/Hazptr.h), as well as the C++ standardization proposal (http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1121r3.pdf).

0:00:00 Introduction
0:00:37 Rust for Rustaceans
0:01:00 Concurrent Memory Reclamation
0:10:32 Hazard Pointers
0:35:27 Folly's Hazard Pointer Interface
0:54:08 Delayed Reclamation
0:58:18 More Folly Interface
1:11:56 A Wild Entity Diagram Appears
1:16:40 Memory Use
1:21:12 More Folly Interface
1:27:50 Starting the Rust Code
1:35:24 Testing Out the Rust Interface
1:42:32 HazPtrHolder::load
2:02:15 HazPtrObject::retire
2:19:43 HazPtrHolder::reset
2:22:50 Unsafe Blocks in Unsafe Fns
2:25:04 Borrow Checker Prevents Misuse
2:27:45 Bad Drop Lint
2:34:15 Dropping in HazPtrDomain::retire
2:46:00 Intermission
2:47:57 Reading Folly's HazPtrDomain::retire
2:59:02 HazPtrDomain::acquire
3:17:32 HazPtrDomain::retire
3:45:57 Specifying a Deleter
4:32:26 Tests Pass?
4:36:12 Eager Reclaiming
4:37:32 Checking Reclamation Behavior
4:52:04 Final Thoughts

You can find the code for the implementation at https://github.com/jonhoo/haphazard.

Live version with chat: https://youtu.be/4PuE6oMYxeM</media:description>
   <media:community>
    <media:starRating count="441" average="5.00" min="1" max="5"/>
    <media:statistics views="25318"/>
   </media:community>
  </media:group>
 </entry>
 <entry>
  <id>yt:video:tNzCj8691LE</id>
  <yt:videoId>tNzCj8691LE</yt:videoId>
  <yt:channelId>UC_iD0xppBwwsrM9DegC5cQQ</yt:channelId>
  <title>Lock-Free to Wait-Free Simulation in Rust (part 2)</title>
  <link rel="alternate" href="https://www.youtube.com/watch?v=tNzCj8691LE"/>
  <author>
   <name>Jon Gjengset</name>
   <uri>https://www.youtube.com/channel/UC_iD0xppBwwsrM9DegC5cQQ</uri>
  </author>
  <published>2021-06-13T23:50:52+00:00</published>
  <updated>2022-08-19T15:46:01+00:00</updated>
  <media:group>
   <media:title>Lock-Free to Wait-Free Simulation in Rust (part 2)</media:title>
   <media:content url="https://www.youtube.com/v/tNzCj8691LE?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
   <media:thumbnail url="https://i1.ytimg.com/vi/tNzCj8691LE/hqdefault.jpg" width="480" height="360"/>
   <media:description>In this stream, we continue implementing the concurrency algorithm from the academic paper &quot;A Practical Wait-Free Simulation for Lock-Free Data Structures&quot; by Erez Petrank and and Shahar Timnat in Rust. The paper details a general way to turn lock-free concurrent data-structures into wait-free ones (we also talk about what that means), and you can find it at http://cs.technion.ac.il/~erez/Papers/wf-simulation-full.pdf.

0:00:00 Introduction
0:01:18 Rust for Rustaceans
0:02:54 Code Recap
0:12:03 Naming the CAS list type
0:33:05 Versioned CASes
2:05:38 ExecuteCASes
2:09:46 Cat interlude
2:10:52 Paper vs. Code
2:20:03 Contention detection
2:36:22 It compiles!
2:36:40 PostCASes
2:50:45 Intermission
2:53:11 Paper vs. Code
2:56:06 Tidying Up Nested Result
2:59:46 The Wait-Free Queue
3:04:35 Per-Thread Handles
3:35:45 Porting the Queue
3:54:40 Weird Head Semantics
4:16:56 Pop and Push
4:32:40 Implementing Helping
5:15:37 State of Affairs and Next Steps

You can find the current code at https://github.com/jonhoo/bystander.

Live version with chat: https://www.youtube.com/watch?v=OqnZpVufTtg.</media:description>
   <media:community>
    <media:starRating count="195" average="5.00" min="1" max="5"/>
    <media:statistics views="9196"/>
   </media:community>
  </media:group>
 </entry>
 <entry>
  <id>yt:video:Bw8-vvtA-E8</id>
  <yt:videoId>Bw8-vvtA-E8</yt:videoId>
  <yt:channelId>UC_iD0xppBwwsrM9DegC5cQQ</yt:channelId>
  <title>Lock-Free to Wait-Free Simulation in Rust</title>
  <link rel="alternate" href="https://www.youtube.com/watch?v=Bw8-vvtA-E8"/>
  <author>
   <name>Jon Gjengset</name>
   <uri>https://www.youtube.com/channel/UC_iD0xppBwwsrM9DegC5cQQ</uri>
  </author>
  <published>2021-05-22T23:48:06+00:00</published>
  <updated>2022-06-17T10:50:08+00:00</updated>
  <media:group>
   <media:title>Lock-Free to Wait-Free Simulation in Rust</media:title>
   <media:content url="https://www.youtube.com/v/Bw8-vvtA-E8?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
   <media:thumbnail url="https://i3.ytimg.com/vi/Bw8-vvtA-E8/hqdefault.jpg" width="480" height="360"/>
   <media:description>In this stream, we start implementing the concurrency algorithm from the academic paper &quot;A Practical Wait-Free Simulation for Lock-Free Data Structures&quot; by Erez Petrank and and Shahar Timnat in Rust. The paper details a general way to turn lock-free concurrent data-structures into wait-free ones (we also talk about what that means), and you can find it at http://cs.technion.ac.il/~erez/Papers/wf-simulation-full.pdf. The first half or so of the stream is us going through what problem the paper is solving, and the proposed algorithm, and the second half is us working towards encoding it in Rust. We didn't get all the way there in this video, so there are more videos to come!

0:00:00 Introduction
0:04:44 Questions about what we'll cover
0:09:04 Lock-based concurrency
0:14:50 Non-blocking concurrency
0:17:30 Wait-freedom
0:19:10 Q&amp;A on concurrency guarantees
0:26:51 What does simulation mean?
0:30:04 What does practical mean?
0:40:19 The fast-path-slow-path method
0:46:02 Going from lock-free to wait-free
0:51:28 Cat time
0:52:09 Q&amp;A on going wait-free
0:54:23 The basic algorithm
1:00:40 Cat time
1:01:29 Q&amp;A on algorithm
1:05:42 The basic algorithm cont'd
1:10:12 Visualizing linked list helping
1:26:15 Challenges
1:32:52 System assumptions
1:34:52 Wait-free algorithm examples
1:37:41 Q&amp;A on algorithm
1:42:00 Intermission
1:44:10 Resuming
1:45:20 Blindly writing the normalized representation
2:28:55 Comparing against the paper
2:59:57 The ABA problem
3:09:23 Q&amp;A on code and ABA
3:17:20 Understanding the normalized representation
3:21:06 Intermission
3:22:40 Fat points for ABA?
3:24:50 Implementing the simulator
3:39:10 Operation records and the help queue
4:07:14 The help state machine: preCAS
4:22:10 The help state machine: executeCAS
4:24:12 The help state machine: postCAS
4:26:23 The help state machine: retrying
4:30:40 Returning the operation output
4:31:12 Tidying up warnings
4:33:15 Monitoring pre/post runs
4:43:30 What's missing in execute?
4:44:49 Q&amp;A for today

Live version with chat: https://youtu.be/Hzm_OZ44qOA.</media:description>
   <media:community>
    <media:starRating count="756" average="5.00" min="1" max="5"/>
    <media:statistics views="32083"/>
   </media:community>
  </media:group>
 </entry>
</feed>
