<?xml version='1.0' encoding='UTF-8'?><?xml-stylesheet href="http://www.blogger.com/styles/atom.css" type="text/css"?><feed xmlns='http://www.w3.org/2005/Atom' xmlns:openSearch='http://a9.com/-/spec/opensearchrss/1.0/' xmlns:blogger='http://schemas.google.com/blogger/2008' xmlns:georss='http://www.georss.org/georss' xmlns:gd="http://schemas.google.com/g/2005" xmlns:thr='http://purl.org/syndication/thread/1.0'><id>tag:blogger.com,1999:blog-4446292666398344382</id><updated>2022-10-30T02:32:37.929-07:00</updated><category term="Machine Learning Reduction"/><category term="Real Data"/><category term="Online Learning"/><category term="Open Source"/><category term="Conference"/><category term="Practical Tips"/><category term="CSMC"/><category term="Crowdsourcing"/><category term="Opinion"/><category term="Vowpal Wabbit"/><category term="LDA"/><category term="Constraints"/><category term="ICML"/><category term="Linear Programming"/><category term="NIPS"/><category term="Active Learning"/><category term="Deep Learning"/><category term="Dialog"/><category term="Imbalanced Data Sets"/><category term="Matlab"/><category term="Dyadic Modeling"/><category term="Fast Approximation"/><category term="Randomized Methods"/><category term="Ranking"/><category term="SSP"/><category term="Eye Candy"/><category term="NLP"/><category term="Unsupervised Learning"/><category term="CSBM"/><category term="Calibration"/><category term="Contextual Bandits"/><category term="Position Effects"/><category term="Ad Serving"/><category term="Contraints"/><category term="Dependent Reward Revelation"/><category term="Distributed Machine Learning"/><category term="Extreme Classification"/><category term="Machine Learning Business Trends"/><category term="PU Learning"/><category term="Price Differentiation"/><category term="Reinforcement Learning"/><category term="Aggregate Feedback"/><category term="Attention"/><category term="Hashing Trick"/><category term="ICLR"/><category term="Method of Moments"/><category term="Minimax Forecaster"/><category term="Adversarial Learning"/><category term="Big Experimentation"/><category term="ECML"/><title type='text'>Machined Learnings</title><subtitle type='html'>$\lim_{t \to \infty} V(s_t) \to 0$ so live accordingly</subtitle><link rel='http://schemas.google.com/g/2005#feed' type='application/atom+xml' href='http://www.machinedlearnings.com/feeds/posts/default'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default'/><link rel='alternate' type='text/html' href='http://www.machinedlearnings.com/'/><link rel='hub' href='http://pubsubhubbub.appspot.com/'/><link rel='next' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default?start-index=26&amp;max-results=25'/><author><name>Paul Mineiro</name><uri>http://www.blogger.com/profile/05439062526157173163</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><generator version='7.00' uri='http://www.blogger.com'>Blogger</generator><openSearch:totalResults>190</openSearch:totalResults><openSearch:startIndex>1</openSearch:startIndex><openSearch:itemsPerPage>25</openSearch:itemsPerPage><entry><id>tag:blogger.com,1999:blog-4446292666398344382.post-9217184797289843981</id><published>2021-08-30T20:00:00.003-07:00</published><updated>2021-08-30T20:09:49.971-07:00</updated><title type='text'>Interaction Grounded Learning</title><content type='html'>Here&#39;s an example of a research question that started as a practical concern and ended up having science-fiction levels of potential. &lt;p/&gt; &lt;h2&gt;A Practical Question and Answer&lt;/h2&gt; &lt;a href=&quot;https://towardsdatascience.com/contextual-bandits-and-reinforcement-learning-6bdfeaece72a&quot;&gt;Contextual bandits&lt;/a&gt; have developed from research prototype to maturing industrial technology.  CBs are practical because they incorporate the partial feedback nature of decision making in the real world, while sidestepping difficult issues of credit assignment and planning.  In other words: you get a reward for the action you&#39;ve taken, but you don&#39;t know what the reward would have been if you had done something else (partial feedback); but the reward is assumed to only depend upon your current action and not any decisions you have made previously (avoiding credit assignment and planning issues by assumption).  Although there are no true contextual bandits in real life (the world is not actually forgetting our previous decisions and resetting itself), “all models are wrong, but some models are useful.” &lt;p/&gt; Due to my close affiliation with a &lt;a href=&quot;https://azure.microsoft.com/en-us/services/cognitive-services/personalizer/&quot;&gt;commercial self-serve contextual bandit platform&lt;/a&gt;, I experience some of the practical difficulties. One issue of several: customers do not know how to define rewards.  Users have all sorts of reactions to decisions made by our system, and it&#39;s not clear how to value them.  For example, a recommended song might be liked, added to a specific playlist, or downloaded for offline use.  Yet if a contextual bandit chooses to recommend an song, it expects a scalar value reward indicating the quality of the decision.  A natural question to ask is: can we just learn from the reactions directly?  Surpisingly the answer is yes. &lt;p/&gt; &lt;a href=&quot;https://arxiv.org/abs/2106.04887&quot;&gt;In &lt;a href=&quot;https://arxiv.org/abs/2106.04887&quot;&gt;this paper&lt;/a&gt; (excellent work by research intern &lt;a href=&quot;https://tengyangxie.github.io/&quot;&gt;Tengyang Xie&lt;/a&gt;) we introduce the IGL setting, which is a modification of the contextual bandit setting.  The generative model is &lt;ol&gt;  &lt;li&gt; Environment generates tuple $(x, y, r) \sim D$ &lt;/li&gt;  &lt;li&gt; Player receives $x$ and chooses $a$. &lt;/li&gt;  &lt;li&gt; Environment reveals (action-dependent) feedback $y_a$. &lt;/li&gt;  &lt;li&gt; $r_a$ is never revealed, but player&#39;s goal is low regret with respect to $r$. &lt;/li&gt;&lt;/ol&gt;&lt;p/&gt; We don&#39;t understand all the information-theoretic limits yet.  Clearly if $y=0$ a.s. then Player cannot succeed; we at least need the reward to be decodable from the feedback.  But even assuming decodability there are impossibility results, e.g., a bandit setting with two actions and two functions $\{ \psi_1, \psi_2 \}$ such that $\psi_1(y) = 1_{a=1}$ and $\psi_2(y)=1_{a=2}$.  Because of symmetry, given two versions of this scenario where the true $r$ is either $r=1_{a=1}$ or $r=1_{a=2}$ we must fail at one of them. &lt;p/&gt; In the paper we identify a sufficient additional condition for success: $y \perp x, a|r$.  In English this says &amp;ldquo;the feedback is conditionally independent of context and action given the reward.&amp;rdquo;  This is a strong assumption, but plausibly approximately true in some real problems.  In our song recommendation example above, this assumption says the distributions of feedback (likes, save to playlist, offline download) depends only upon how much the user likes the song and not, e.g., the particular genre of the song, the time of day, or whether the user is on a mobile vs. desktop device. &lt;p/&gt; Again “all models are wrong, but some models are useful”, and the conditional independence assumption allowed us to make progress in the paper.  In particular it allowed us to define an objective function, based only upon observable quantities, which nonetheless maximizes unobserved reward.  The objective function operates on a tuple $(\pi, \psi)$, where $\pi: X \to A$ is a policy and $\psi: Y \to R$ is a reward decoder, $$ \mathcal{L}(\pi, \psi) \doteq \mathbb{E}_{\substack{(x, y) \sim D \\ a \sim \pi}}\left[ \psi(y_a) \right] - \mathbb{E}_{\substack{(x, y) \sim D \\ a \sim \pi_{\text{bad}}}}\left[ \psi(y_a) \right]. $$ In English this says &amp;ldquo;the difference between the decoded reward of the policy and the decoded reward of another &#39;bad&#39; policy&amp;rdquo;.  $\pi_{\text{bad}}$ is a policy which is known to have bad performance, e.g., the uniform-at-random policy when rewards are rare and there are more than 2 actions.  Intuitively, taking differences is necessary to prevent the reward decoder from just saying everything is great.   Surprisingly, we prove that maximizing $\mathcal{L}$, corresponding to jointly learning a policy and a reward decoder, also maximizes the reward of policy $\pi$ part of the tuple. &lt;p/&gt; For online recommendation scenarios, the conditional independence assumption is viable and we will be testing the above approach on production workflows.  However, as follow-on work we are trying to relax the conditional independence assumption to broaden the application scope of this technique. &lt;p/&gt;   &lt;h2&gt;Future Potential&lt;/h2&gt; There are many exciting applications of this concept.  For example, consider the brain-computer interaction (BCI) task of typing a message based upon EEG sensor readings.  Unfortunately subjects can have extreme medical difficulties that prevent easily eliciting supervised feedback, and even subjects capable of providing supervised feedback are burdened with the overhead of (re)training the system to their patterns.  What if the system could learn to type the right thing based upon the subsequent EEG readings without explicit feedback?  Even if some supervised pre-training is required, it would be extremely valuable if a system could stay performant as the sensor readings statistically drift over time.  More generally, self-tuning would enhance the value of wearables and contribute to the rise of augmented humanity. &lt;p/&gt; In the BCI scenario, both the context and the feedback are brain recordings at different points in time, e.g., synchronously scheduled into alternating time windows of &quot;issue command&quot; and &quot;provide feedback&quot;.  The conditional independence assumption is implausible here, so we are considering other approaches (e.g., using the above approach but try to “remove” the dependent parts of the feedback; or develop an alternative objective function which is more robust). </content><link rel='replies' type='application/atom+xml' href='http://www.machinedlearnings.com/feeds/9217184797289843981/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.machinedlearnings.com/2021/08/interaction-grounded-learning.html#comment-form' title='0 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/9217184797289843981'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/9217184797289843981'/><link rel='alternate' type='text/html' href='http://www.machinedlearnings.com/2021/08/interaction-grounded-learning.html' title='Interaction Grounded Learning'/><author><name>Paul Mineiro</name><uri>http://www.blogger.com/profile/05439062526157173163</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-4446292666398344382.post-2729521790025870114</id><published>2020-12-05T12:22:00.004-08:00</published><updated>2020-12-05T12:30:13.041-08:00</updated><title type='text'>Distributionally Robust Contextual Bandit Learning</title><content type='html'>This blog post is about improved off-policy contextual bandit learning via distributional robustness.  I&#39;ll provide some theoretical background and also outline &lt;a href=&quot;https://github.com/VowpalWabbit/vowpal_wabbit/wiki/Contextual-Bandit-Distributionally-Robust-Optimization-(cb_dro)&quot;&gt;the implementation in vowpal wabbit&lt;/a&gt;. Some of this material is in a &lt;a href=&quot;https://slideslive.com/38942331/vowpal-wabbit?slide=239&quot;&gt;NeurIPS expo talk video&lt;/a&gt;, and additional material is in the &lt;a href=&quot;https://arxiv.org/abs/1906.03323&quot;&gt;accepted paper&lt;/a&gt;.  &lt;p&gt;&lt;/p&gt;&lt;h2&gt;Motivation&lt;/h2&gt; In off-policy learning in contextual bandits our goal is to produce the best policy possible from historical data, and we have no control over the historical logging policy which generated the data.  (Note production systems that run in closed-loop configurations nonetheless are in practice doing off-policy learning because of delays between inference, training, and model update.)  Off-policy learning reduces to optimization of a policy value estimator analogously to supervised learning; however the accuracy of policy value estimation depends upon the mismatch between the policy being evaluated and the policy that generated the data, and therefore can be quite different for different policies (unlike supervised learning, where the differences in estimator resolution across the hypothesis class are less pronounced in practice).  To appreciate this effect consider the IPS policy value estimator, $$ \hat{V}(\pi; \mu) = \frac{1}{N} \sum_{n \in N} \frac{\pi(a_n|x_n)}{\mu(a_n|x_n)} r_n, $$ where $\mu$ is the historical policy, $\pi$ is the policy being estimated, and our historical data consists of tuples $\{ (x_n, a_n, r_n) \}$.  The importance weight $\frac{\pi(a_n|x_n)}{\mu(a_n|x_n)}$ can be quite large if $\pi$ frequently takes an action that $\mu$ rarely takes, causing the estimator to be highly sensitive to a few examples with large importance weights.  Even if we initialize learning with $\pi = \mu$, as optimization progresses $\pi$ will induce increasingly different distributions over actions than $\mu$ as the learning algorithm encounters rare events with high reward.  To combat this overfitting technique we will introduce regularization.  &lt;p&gt;&lt;/p&gt;&lt;h2&gt;Distributionally Robust Optimization&lt;/h2&gt; Distributionally robust optimization is a generic method for regularizing machine learning objectives.  The basic idea is to consider the observed data as one possible distribution of data (the “empirical distribution”), and then to optimize a worst-case outcome over all distributions that are “sufficiently close” to the empirical distribution.  In the case of IPS we can find the smallest policy value estimate over a set of distributions that are close in KL divergence to the empirical distribution, $$ \begin{alignat}{2} &amp;amp;\!\min_{P \in \Delta} &amp;amp; \qquad &amp;amp; \mathbb{E}_P\left[w r\right], \\ &amp;amp;\text{subject to} &amp;amp; &amp;amp; \mathbb{E}_P\left[w\right] = 1, \\ &amp;amp; &amp;amp; &amp;amp; \mathbb{E}_N \left[\log\left( P\right) \right] \geq \phi. \end{alignat} $$ where $w \doteq \frac{\pi(a|x)}{\mu(a|x)}$.  It turns out you can do this cheaply (in the dual), and the value of $\phi$ can be computed from a desired asymptotic confidence level.  These results follow from classic work in the field of &lt;a href=&quot;http://statweb.stanford.edu/~owen/empirical/&quot;&gt;Empirical Likelihood&lt;/a&gt;.  &lt;p&gt;The above problem finds a lower bound; finding an upper bound is analogous, resulting in the confidence intervals from the paper:  &lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;table align=&quot;center&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; class=&quot;tr-caption-container&quot; style=&quot;margin-left: auto; margin-right: auto;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style=&quot;text-align: center;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-_Gwl2fD-w3g/X8vkrSjYKyI/AAAAAAAAIg8/GBX5tbCYRhIgA2BknHZx7al60jso4CPJACLcBGAsYHQ/s565/epsilongreedy_ci.png&quot; style=&quot;margin-left: auto; margin-right: auto;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;389&quot; data-original-width=&quot;565&quot; height=&quot;275&quot; src=&quot;https://1.bp.blogspot.com/-_Gwl2fD-w3g/X8vkrSjYKyI/AAAAAAAAIg8/GBX5tbCYRhIgA2BknHZx7al60jso4CPJACLcBGAsYHQ/w400-h275/epsilongreedy_ci.png&quot; width=&quot;400&quot; /&gt;&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;tr-caption&quot; style=&quot;text-align: center;&quot;&gt;Empirical Likelihood Confidence Intervals are tighter Gaussian intervals.&amp;nbsp; Not shown: coverage of Empirical Likelihood CIs is better calibrated than Binomial (Clopper-Pearson).&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;br /&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt; When we do distributionally robust optimization, we are actually optimizing the lower bound on the policy value.  The green curve in the above plot is a Clopper-Pearson interval, which does have guaranteed coverage, but is so wide that optimizing the lower bound wouldn&#39;t do much until the amount of data is large.  The tighter intervals generated by the blue Empirical Likelihood curve imply that lower bound optimization will induce an interesting policy ordering with only modest data.  &lt;p&gt;In practice, even when the empirical mean (empirical IPS value) is fixed, the lower bound is: &lt;/p&gt;&lt;ul&gt;  &lt;li&gt;smaller when the policy generates value via few events with importance weights much larger than 1 and many events with importance weights near zero; and&lt;/li&gt;  &lt;li&gt;larger when the policy generates value via many events with importance weights near 1.&lt;/li&gt;&lt;/ul&gt;This is precisely the kind of regularization we desired.  Intuitively, any estimator which is sensitive to a few of the observed examples (aka &lt;a href=&quot;https://en.wikipedia.org/wiki/Leverage_(statistics)&quot;&gt;high leverage&lt;/a&gt;) will have a larger penalty because it is “cheap”, as measured by KL divergence, to reduce the probability of those points.  &lt;p&gt;&lt;/p&gt;&lt;h2&gt;Implementation in Vowpal Wabbit&lt;/h2&gt; To activate the functionality, add the &lt;span style=&quot;font-family: courier;&quot;&gt;--cb_dro&lt;/span&gt; flag to your contextual bandit command line in VW.  Note it only effects training, so if you are only predicting you will not see a difference.  Hopefully with the default hyperparameters you will see an improvement in the quality of your learned policy, such as in &lt;a href=&quot;https://gist.github.com/pmineiro/390d6cc820c628d04dea991f8018c054&quot;&gt;this gist&lt;/a&gt;.  &lt;p&gt;Internally VW is solving the lower bound optimization problem from above on every example.  There are some modifications: &lt;ol&gt;&lt;li&gt;As stated above this would be too expensive computationally, but switching from the KL divergence to the Cressie-Read power divergence allows us to derive a closed form solution which is fast to compute.&lt;/li&gt;&lt;li&gt;As stated above the lower bound requires remembering all policy decisions over all time.  Instead we accumulate the sufficient statistics for the Cressie-Read power divergence in $O(1)$ time and space.&lt;/li&gt;&lt;li&gt;To track nonstationarity we use exponentially weighted moving averages of the sufficient statistics.  The hyperparameter &lt;span style=&quot;font-family: courier;&quot;&gt;--cb_dro_tau&lt;/span&gt; specifies the decay time constant.&lt;/li&gt;&lt;/ol&gt;As always, YMMV.</content><link rel='replies' type='application/atom+xml' href='http://www.machinedlearnings.com/feeds/2729521790025870114/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.machinedlearnings.com/2020/12/distributionally-robust-contextual.html#comment-form' title='0 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/2729521790025870114'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/2729521790025870114'/><link rel='alternate' type='text/html' href='http://www.machinedlearnings.com/2020/12/distributionally-robust-contextual.html' title='Distributionally Robust Contextual Bandit Learning'/><author><name>Paul Mineiro</name><uri>http://www.blogger.com/profile/05439062526157173163</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://1.bp.blogspot.com/-_Gwl2fD-w3g/X8vkrSjYKyI/AAAAAAAAIg8/GBX5tbCYRhIgA2BknHZx7al60jso4CPJACLcBGAsYHQ/s72-w400-h275-c/epsilongreedy_ci.png" height="72" width="72"/><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-4446292666398344382.post-2692193822377299085</id><published>2020-07-17T18:33:00.000-07:00</published><updated>2020-07-18T14:30:30.677-07:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="Practical Tips"/><title type='text'>Convex-concave games off the shelf</title><content type='html'>If you need to solve a convex optimization problem nowadays, you are in great shape.  Any problem of the form $$&lt;br /&gt;\begin{alignat}{2}&lt;br /&gt;&amp;\!\inf_z &amp; \qquad &amp; f(z) \\&lt;br /&gt;&amp; \text{subject to} &amp; &amp; h(z) = 0 \\&lt;br /&gt;&amp; &amp; &amp; g(z) \preceq 0&lt;br /&gt;\end{alignat}&lt;br /&gt;$$ where $f$ and $g$ are convex and $h$ is affine can be attacked by several excellent freely available software packages: my current favorite is &lt;a href=&quot;https://www.cvxpy.org/&quot;&gt;cvxpy&lt;/a&gt;, which is a joy to use.  If you have a lot of variables and not a lot of constraints, you can instead solve a dual problem.  It ends up looking like $$&lt;br /&gt;\begin{alignat}{2}&lt;br /&gt;&amp;\!\sup_{x}  &amp; \qquad &amp; L(x) \\&lt;br /&gt;&amp; \text{subject to} &amp; &amp; \tilde{h}_x(x) = 0 \\&lt;br /&gt;&amp; &amp; &amp; \tilde{g}_x(x) \preceq 0&lt;br /&gt;\end{alignat}&lt;br /&gt;$$ where $L$ is concave, assuming that you get lucky and can analytically eliminate all the primal variables $z$ such that only the dual variables $x$ remain.  But what if you can&#39;t eliminate all the primal variables, but only most of them?  You might end up with a problem like $$&lt;br /&gt;\begin{alignat}{2}&lt;br /&gt;&amp;\!\sup_{x} \inf_y &amp; \qquad &amp; L(x, y) \\&lt;br /&gt;&amp; \text{subject to} &amp; &amp; \tilde{h}_x(x) = 0 \\&lt;br /&gt;&amp; &amp; &amp; \tilde{g}_x(x) \preceq 0 \\&lt;br /&gt;&amp; &amp; &amp; \tilde{h}_y(y) = 0 \\&lt;br /&gt;&amp; &amp; &amp; \tilde{g}_y(y) \preceq 0&lt;br /&gt;\end{alignat}&lt;br /&gt;$$ where $\tilde{g}_x$ and $\tilde{g}_y$ are convex, and $\tilde{h}_x$ and $\tilde{h}_y$ are affine, $L(x, \cdot)$ is convex in $y$ given fixed $x$, and $L(\cdot, y)$ is concave in $x$ given fixed $y$.  It feels like this problem should be easier to solve than the original problem if many primal variables have been analytically eliminated.  Unfortunately, &lt;i&gt;none of my favorite convex optimization toolkits will accept a problem of this form.&lt;/i&gt;  This is despite &lt;a href=&quot;https://web.stanford.edu/class/ee392o/cvxccv.pdf&quot;&gt;the viability of interior-point methods for such problems&lt;/a&gt;.  Bummer.&lt;br /&gt;&lt;br /&gt;One thing I tried was to solve the inner infimum using a standard toolkit, compute the gradient of the solution wrt the outer parameters via the sensitivity map, and then use a first-order method for the outer supremum.  This did not work for me: it works for toy problems but on real problems the outer supremum has very slow convergence suggesting ill-conditioning.  &lt;br /&gt;&lt;br /&gt;What I need is the power of interior-point methods to handle ill-conditioning via second-order information.  I&#39;m able to achieve this via sequential quadratic minimax programming: first, locally approximate the objective $L(\lambda, \mu, y)$ with a quadratic around the current point and linearize the constraints. $$&lt;br /&gt;\begin{alignat}{2}&lt;br /&gt;&amp;\!\sup_{\delta x} \inf_{\delta y} &amp; \qquad &amp; \frac{1}{2} \left(\begin{array}{c} \delta x \\ \delta y \end{array}\right)^\top \left(\begin{array}{cc} P_{xx} &amp; P_{yx}^\top \\ P_{yx} &amp; P_{yy} \end{array}\right) \left(\begin{array}{c} \delta x \\ \delta y \end{array} \right) + \left(\begin{array}{c} q_x \\ q_y \end{array} \right)^\top \left(\begin{array}{c} \delta x \\ \delta y \end{array} \right) \\&lt;br /&gt;&amp; \text{subject to} &amp; &amp; \left(\begin{array}{cc} A_x &amp; 0 \\ 0 &amp; A_y \end{array} \right) \left(\begin{array}{c} \delta x \\ \delta y \end{array}\right) = \left(\begin{array}{c} b_x \\ b_y \end{array}\right) \\&lt;br /&gt;&amp; &amp; &amp; \left(\begin{array}{cc} G_x &amp; 0 \\ 0 &amp; G_y \end{array} \right) \left(\begin{array}{c} \delta x \\ \delta y \end{array}\right) \preceq \left(\begin{array}{c} h_x \\ h_y \end{array}\right) \\&lt;br /&gt;\end{alignat}&lt;br /&gt;$$ The &lt;a href=&quot;https://en.wikipedia.org/wiki/Wolfe_duality&quot;&gt;Wolfe dual&lt;/a&gt; converts this problem into a standard QP: $$&lt;br /&gt;\begin{alignat}{2}&lt;br /&gt;&amp;\!\sup_{\delta x, \delta y, \lambda, \mu} &amp; \qquad &amp;  \frac{1}{2} \left(\begin{array}{c} \delta x \\ \delta y \\ \lambda \\ \mu \end{array}\right)^\top \left(\begin{array}{cccc} P_{xx} &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; -P_{yy} &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 \end{array}\right) \left(\begin{array}{c} \delta x \\ \delta y \\ \lambda \\ \mu \end{array}\right) + \left(\begin{array}{c} q_x \\ 0 \\ -b_y \\ -h_y \end{array} \right)^\top \left(\begin{array}{c} \delta x \\ \delta y \\ \lambda \\ \mu \end{array} \right) \\&lt;br /&gt;&amp; \text{subject to} &amp; &amp; \left(\begin{array}{cc} A_x &amp; 0 &amp; 0 &amp; 0 \\ P_{yx} &amp; P_{yy} &amp; A_y^\top &amp; G_y^\top \end{array} \right) \left(\begin{array}{c} \delta x \\ \delta y \\ \lambda \\ \mu \end{array}\right) = \left(\begin{array}{c} b_x \\ -q_y \end{array}\right) \\&lt;br /&gt;&amp; &amp; &amp; \left(\begin{array}{cc} G_x &amp; 0 &amp; 0 &amp; 0  \\ 0 &amp; 0 &amp; 0 &amp; -I \end{array} \right) \left(\begin{array}{c} \delta x \\ \delta y \\ \lambda \\ \mu \end{array}\right) \preceq \left(\begin{array}{c} h_x \\ 0 \end{array}\right) \\&lt;br /&gt;\end{alignat}&lt;br /&gt;$$ If you solve this for $(\delta x, \delta y)$ you get a Newton step for your original problem.  The step acceptance criterion here is tricky: if the iterate is feasible you want to leverage the saddle point condition (see equation (11) of &lt;a href=&quot;https://arxiv.org/abs/1906.00233&quot;&gt;Essid et. al.&lt;/a&gt;).  If the iterate is infeasible more sophistication is required, but fortunately my constraints were actually linear so doing an initial exact inner solve allowed me to iterate while staying feasible.  (Note: if you solve a more general convex problem on each step, you don&#39;t need to linearize the $x$ constraints.)&lt;br /&gt;&lt;br /&gt;YMMV!</content><link rel='replies' type='application/atom+xml' href='http://www.machinedlearnings.com/feeds/2692193822377299085/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.machinedlearnings.com/2020/07/convex-concave-games-off-shelf.html#comment-form' title='0 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/2692193822377299085'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/2692193822377299085'/><link rel='alternate' type='text/html' href='http://www.machinedlearnings.com/2020/07/convex-concave-games-off-shelf.html' title='Convex-concave games off the shelf'/><author><name>Paul Mineiro</name><uri>http://www.blogger.com/profile/05439062526157173163</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-4446292666398344382.post-7395017907511800305</id><published>2019-05-10T14:54:00.000-07:00</published><updated>2019-05-10T14:58:02.810-07:00</updated><title type='text'>ICLR 2019 Thoughts</title><content type='html'>&lt;a href=&quot;https://iclr.cc/Conferences/2019/&quot;&gt;ICLR 2019&lt;/a&gt; was reminiscent of the early NeurIPS days (sans skiing): a single track of talks, vibrant poster sessions, and a large mid-day break.  The Tuesday morning talks were on climate change, modeling proteins, generating music, and modeling the visual cortex.  Except for climate change, these were all hot topics at NeurIPS in the late 1990s.  History doesn&#39;t repeat, but it does rhyme.&lt;br /&gt;&lt;br /&gt;My favorite talk was by Pierre-Yves Oudeyer, whose &lt;a href=&quot;http://www.pyoudeyer.com/active-learning-and-artificial-curiosity-in-robots/&quot;&gt;research in curiosity based learning&lt;/a&gt; spans both human subjects and robotics.  Pierre&#39;s presentation was an entertaining tour de force of cognitive science, and I highly recommend &lt;a href=&quot;https://www.facebook.com/iclr.cc/videos/1061645560700150/&quot;&gt;watching the video&lt;/a&gt; (starts about 9 minutes 30 seconds).  These ideas have extensively influenced the reinforcement learning community: the well-known Achilles&#39; Heel of reinforcement learning is sample complexity, and recently practitioners have attacked it inspired by ideas from curiosity based learning (e.g., the &lt;a href=&quot;https://pathak22.github.io/large-scale-curiosity/&quot;&gt;Burda et. al.&lt;/a&gt; poster at the conference).   Furthermore the view &amp;ldquo;exploration is for building world models&amp;rdquo; is reflected in &lt;a href=&quot;https://arxiv.org/abs/1811.08540&quot;&gt;recent theoretical results in contextual decision processes&lt;/a&gt;.&lt;br /&gt;&lt;br /&gt;The strangest moment for me at the conference was seeing the &lt;a href=&quot;https://gluebenchmark.com/&quot;&gt;GLUE poster&lt;/a&gt;.  Apparently with the latency of conference review and publication, GLUE is just now being presented.  Of course, it is already obsolete, so the presenters had another poster about their new dataset called &lt;a href=&quot;https://super.gluebenchmark.com/&quot;&gt;SuperGLUE&lt;/a&gt;.  Things are moving so quickly that the former &amp;ldquo;fast path&amp;rdquo; of conference proceedings is now noticeably behind.&lt;br /&gt;&lt;br /&gt;Here&#39;s some stuff that caught my attention:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1804.05862&quot;&gt;Non-Vacuous Generalization Bounds at the ImageNet Scale: A PAC-Bayesian Compression Approach&lt;/a&gt;: A couple years ago &lt;a href=&quot;https://arxiv.org/abs/1611.03530&quot;&gt;Zhang et. al.&lt;/a&gt; stunned the community by demonstrating convnets can fit Imagenet labels to randomly generated images, destroying the common belief that convnets generalized well due to capacity control.  Here Zhou et. al. show that an MDL-style generalization bound applies, i.e., networks whose representation can be compressed after training have tighter deviation bounds.  This is a (training) data-dependent bound and they seal the argument by noting networks trained on randomized training data do not compress as well.&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1810.02274&quot;&gt;Episodic Curiousity through Reachability&lt;/a&gt;: One of many curiosity-based exploration posters, Savinov et. al. propose a combination of a memory and something akin to a policy cover, with promising results.  Also cool: the poster includes QR codes which trigger videos of agents learning to move via different algorithms.&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1805.11706&quot;&gt;Supervised Policy Update for Deep Reinforcement Learning&lt;/a&gt;: Vuong et. al. presented a plausible improvement over TRPO and PPO by convexifying the constrained policy optimization.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.machinedlearnings.com/feeds/7395017907511800305/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.machinedlearnings.com/2019/05/iclr-2019-thoughts.html#comment-form' title='0 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/7395017907511800305'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/7395017907511800305'/><link rel='alternate' type='text/html' href='http://www.machinedlearnings.com/2019/05/iclr-2019-thoughts.html' title='ICLR 2019 Thoughts'/><author><name>Paul Mineiro</name><uri>http://www.blogger.com/profile/05439062526157173163</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-4446292666398344382.post-2506618494121528845</id><published>2019-03-08T06:48:00.000-08:00</published><updated>2019-03-08T09:33:08.476-08:00</updated><title type='text'>RL will disrupt OR</title><content type='html'>&lt;i&gt;Operations research (OR) is in the initial stages of a revolution driven by reinforcement learning (RL).&lt;br /&gt;&lt;/i&gt;&lt;br /&gt;When I was at eHarmony years ago, we used classical OR techniques to drive the matchmaking process.  Machine learning played a critical role, but was limited to specfiying parameters to the OR solver.  In essence, machine learning was to used to estimate the value function, and the OR solver then produced a policy.  &lt;br /&gt;&lt;br /&gt;OR has historically focused on highly tractable specializations of convex optimization.  In an age of scarce compute, this made perfect sense: indeed, at that time eHarmony was pushing the limits of what was possible using high-end commercial OR solvers.  However, compute is less scarce now: in predictive modeling convex optimization has been spectacularly superseded by non-convex techniques (aka “deep learning”).  A similar revolution is unfolding in OR.  The recipe is: develop a generative model of the problem (aka a “simulator”) and then directly optimize a policy on simulated data using RL techniques.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;All models are wrong, but some models are useful.&lt;/b&gt;  At first blush it seems implausible that using advanced RL techniques on a crude approximation of the real world would yield substantial benefits.  However traditional OR techniques also preform extremely aggressive optimization (to machine precision (!)) on an approximation of the real world.  OR models are useful despite typically making tremendous simplifications such as replacing all random variables with their expected values (or in more sophisticated setups, high probability bounds).  &lt;br /&gt;&lt;br /&gt;The simplifications for the RL techniques involve the assumptions in the generative model, such as a particular parametric model for probability of an airplane service event.  Early research results suggest that for some economically important problems, relatively crude simulators coupled with RL techniques can induce superior policies to those developed using traditional OR techniques.  Furthermore, simulators admit expressing increasingly refined approximations of reality without the constraints imposed by classical OR formulations. &lt;br /&gt;&lt;br /&gt;&lt;table align=&quot;center&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; class=&quot;tr-caption-container&quot; style=&quot;margin-left: auto; margin-right: auto; text-align: center;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style=&quot;text-align: center;&quot;&gt;&lt;a href=&quot;https://i.ytimg.com/vi/ic0PuvJbdu0/maxresdefault.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: auto; margin-right: auto;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;450&quot; data-original-width=&quot;800&quot; height=&quot;180&quot; src=&quot;https://i.ytimg.com/vi/ic0PuvJbdu0/maxresdefault.jpg&quot; width=&quot;320&quot; /&gt;&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;tr-caption&quot; style=&quot;text-align: center;&quot;&gt;Reaction time is a factor in this so please pay attention.&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;b&gt;Reaction time.&amp;nbsp;&lt;/b&gt;You should almost never take seriously anyone&#39;s explanation for why something works.  Nonetheless, I&#39;ll give you my intution as to why RL will eventually dominate OR.&lt;br /&gt;&lt;blockquote&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&amp;ldquo;Classical OR techniques are optimized to try to avoid bad events ballistically, whereas RL trained policies are optimized to react to events as they occur.&amp;rdquo;  &lt;/div&gt;&lt;/blockquote&gt;If this is true then it doesn&#39;t matter if the simulation exactly gets the probability of tail events right as long as they are all present in the simulation and somewhat rare, because the &quot;use of remediation actions&quot; portion of the learned policy will be conditioned on events as they actually occur in practice.  (If the events are not rare, then getting the coocurrence statistics right could matter.)&lt;br /&gt;&lt;br /&gt;If this explanation has merit, then the upside to RL will be large for scenarios where classic OR optimization is frequently re-run in order to react to new events, because RL will have the “reaction time advantage”.</content><link rel='replies' type='application/atom+xml' href='http://www.machinedlearnings.com/feeds/2506618494121528845/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.machinedlearnings.com/2019/03/rl-will-disrupt-or.html#comment-form' title='0 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/2506618494121528845'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/2506618494121528845'/><link rel='alternate' type='text/html' href='http://www.machinedlearnings.com/2019/03/rl-will-disrupt-or.html' title='RL will disrupt OR'/><author><name>Paul Mineiro</name><uri>http://www.blogger.com/profile/05439062526157173163</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-4446292666398344382.post-8228896340261041208</id><published>2018-03-06T13:04:00.000-08:00</published><updated>2018-03-06T13:08:26.250-08:00</updated><title type='text'>pytorch PU learning trick</title><content type='html'>I&#39;m often using &lt;a href=&quot;https://en.wikipedia.org/wiki/One-class_classification&quot;&gt;positive-unlabeled learning&lt;/a&gt; nowadays.  In particular for observational dialog modeling, &lt;a href=&quot;https://arxiv.org/abs/1605.05414&quot;&gt;next utterance classification&lt;/a&gt; is a standard technique for training and evaluating models.  In this setup the observed continuation of the conversation is considered a positive (since a human said it, it is presumed a reasonable thing to say at that point in the conversation) and other randomly chosen utterances are treated as unlabeled (they might be reasonable things to say at that point in the conversation).&lt;br /&gt;&lt;br /&gt;Suppose you have a model whose final layer is a dot product between a vector produced only from context and a vector produced only from response.  I use models of this form as &amp;ldquo;level 1&amp;rdquo; models because they facilitate precomputation of a fast serving index, but note the following trick will not apply to architectures like bidirectional attention.  Anyway for these models  you can be more efficient during training by drawing the negatives from the same mini-batch.  This is a well-known trick but I couldn&#39;t find anybody talking about how to do this explicitly in pytorch.  &lt;br /&gt;&lt;br /&gt;Structure your model to have a leftforward and a rightforward like this:&lt;br /&gt;&lt;pre class=&quot;brush:python&quot;&gt;class MyModel(nn.Module):&lt;br /&gt;...&lt;br /&gt;&lt;br /&gt;    def forward(leftinput, rightinput):&lt;br /&gt;        leftvec = self.leftforward(leftinput)&lt;br /&gt;        rightvec = self.rightforward(rightinput)&lt;br /&gt;        return torch.mul(leftvec, rightvec).sum(dim=1, keepdim=True)&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;At training time, compute the leftforward and rightforward for your mini-batch distinctly:&lt;br /&gt;&lt;pre class=&quot;brush:python&quot;&gt;...&lt;br /&gt;criterion = BatchPULoss()&lt;br /&gt;model = MyModel()&lt;br /&gt;...&lt;br /&gt;&lt;br /&gt;leftvec = model.leftforward(batch.leftinput)&lt;br /&gt;rightvec = model.rightforward(batch.rightinput)&lt;br /&gt;&lt;br /&gt;(loss, preds) = criterion.fortraining(leftvectors, rightvectors)&lt;br /&gt;loss.backward()&lt;br /&gt;# &quot;preds&quot; contains the highest score right for each left &lt;br /&gt;# so for instance, calculate &quot;mini-batch precision at 1&quot;&lt;br /&gt;gold_labels = torch.arange(0, batch.batch_size).long().cuda()&lt;br /&gt;n_correct += (preds.data == gold_labels).sum()&lt;br /&gt;...&lt;br /&gt;&lt;/pre&gt;Finally use this loss:&lt;br /&gt;&lt;pre class=&quot;brush:python&quot;&gt;import torch&lt;br /&gt;&lt;br /&gt;class BatchPULoss():&lt;br /&gt;    def __init__(self):&lt;br /&gt;      self.loss = torch.nn.CrossEntropyLoss()&lt;br /&gt;&lt;br /&gt;    def fortraining(self, left, right):&lt;br /&gt;      outer = torch.mm(left, right.t())&lt;br /&gt;      labels = torch.autograd.Variable(torch.arange(0,outer.shape[0]).long().cuda(), &lt;br /&gt;                                       requires_grad=False)&lt;br /&gt;      loss = self.loss(outer, labels)&lt;br /&gt;      _, preds = torch.max(outer, dim=1)&lt;br /&gt;      return (loss, preds)&lt;br /&gt;&lt;br /&gt;    def __call__(self, *args, **kwargs):&lt;br /&gt;      return self.loss(*args, **kwargs)&lt;br /&gt;&lt;/pre&gt;At training time you call the &lt;tt&gt;fortraining&lt;/tt&gt; method but if you have fixed distractors for evaluation you can also call it directly just like &lt;tt&gt;CrossEntropyLoss&lt;/tt&gt;.</content><link rel='replies' type='application/atom+xml' href='http://www.machinedlearnings.com/feeds/8228896340261041208/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.machinedlearnings.com/2018/03/pytorch-pu-learning-trick.html#comment-form' title='0 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/8228896340261041208'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/8228896340261041208'/><link rel='alternate' type='text/html' href='http://www.machinedlearnings.com/2018/03/pytorch-pu-learning-trick.html' title='pytorch PU learning trick'/><author><name>Paul Mineiro</name><uri>http://www.blogger.com/profile/05439062526157173163</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-4446292666398344382.post-466176080139466658</id><published>2017-12-15T08:45:00.000-08:00</published><updated>2017-12-15T08:45:11.189-08:00</updated><title type='text'>NIPS Conversation AI Workshop</title><content type='html'>I only attended NIPS for the &lt;a href=&quot;http://alborz-geramifard.com/workshops/nips17-Conversational-AI/Main.html&quot;&gt;Conversation AI workshop&lt;/a&gt;, so my thoughts are limited to that.  I really liked the subtitle of the workshop: &quot;today&#39;s practice and tomorrow&#39;s potential.&quot;  Since I&#39;m on a product team trying to build chatbots that are actually effective, it struck me as exactly the right tone.&lt;br /&gt;&lt;br /&gt;Several presentations were related to the &lt;a href=&quot;https://developer.amazon.com/alexaprize&quot;&gt;Alexa prize&lt;/a&gt;.  When reading these papers, keep in mind that contestants were subject to extreme sample complexity constraints.  Semifinalists had circa 500 on-policy dialogs and finalists less than 10 times more.  This is because 1) the Alexa chat function is not the primary purpose of the device so not all end users participated and 2) they had to distribute the chats to all contestants.&lt;br /&gt;&lt;br /&gt;The result of sample complexity constraints is a &amp;ldquo;bias against variance&amp;rdquo;, as &lt;a href=&quot;https://blogs.technet.microsoft.com/machinelearning/2014/09/24/online-learning-and-sub-linear-debugging/&quot;&gt;I&#39;ve discussed before&lt;/a&gt;.  In the Alexa prize, that meant the winners had the architecture of &amp;ldquo;learned mixture over mostly hand-specified substrategies.&amp;rdquo;  In other words, the (scarce) on-policy data was limited to adjusting the mixture weights.  (The MILA team had substrategies that were trained unsupervised on forum data, but it looks like the other substrategies were providing most of the benefit.)  Sample complexity constraints are pervasive in dialog, but nonetheless the conditions of the contest were more extreme than what I encounter in practice so if you find yourself with more on-policy data consider more aggressive usage.&lt;br /&gt;&lt;br /&gt;Speaking of sample complexity constraints, we have found pre-training representations on MT tasks a la &lt;a href=&quot;https://papers.nips.cc/paper/7209-learned-in-translation-contextualized-word-vectors&quot;&gt;CoVE&lt;/a&gt; is extremely effective in practice for multiple tasks.  We are now playing with &lt;a href=&quot;https://openreview.net/pdf?id=S1p31z-Ab&quot;&gt;ELMo-style&lt;/a&gt; pre-training using language modeling as the pre-training task (very promising: no parallel corpus needed!).&lt;br /&gt;&lt;br /&gt;Another sample complexity related theme I noticed at the workshop was the use of functional role dynamics.  Roughly speaking, this is modeling the structure of the dialog independent of the topic.  Once topics are abstracted, the sample complexity of learning what are reasonably structured conversations seems low.  &lt;a href=&quot;http://alborz-geramifard.com/workshops/nips17-Conversational-AI/Papers/17nipsw-cai-collaboration-based-simulator.pdf&quot;&gt;Didericksen et. al.&lt;/a&gt; combined a purely structural L1 model with a simple topically-sensitive L2 (tf-idf) to build a retrieval based dialog simulator.  Analogously for their Alexa prize submission, &lt;a href=&quot;https://arxiv.org/abs/1709.02349&quot;&gt;Serban et. al.&lt;/a&gt; learned a dialog simulator from observational data which utilized only functional role and sentiment information and then applied Q-learning: this was more effective than off-policy reinforce with respect to some metrics.&lt;br /&gt;&lt;br /&gt;Overall the workshop gave me enough optimism to continue plugging away despite the underwhelming performance of current dialog systems.&lt;br /&gt;&lt;br /&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.machinedlearnings.com/feeds/466176080139466658/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.machinedlearnings.com/2017/12/nips-conversation-ai-workshop.html#comment-form' title='0 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/466176080139466658'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/466176080139466658'/><link rel='alternate' type='text/html' href='http://www.machinedlearnings.com/2017/12/nips-conversation-ai-workshop.html' title='NIPS Conversation AI Workshop'/><author><name>Paul Mineiro</name><uri>http://www.blogger.com/profile/05439062526157173163</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-4446292666398344382.post-5989126378435033466</id><published>2017-08-10T23:35:00.000-07:00</published><updated>2017-08-23T16:25:20.971-07:00</updated><title type='text'>ICML 2017 Thoughts</title><content type='html'>ICML 2017 has just ended.  While Sydney is remote for those in Europe and North America, the conference center&lt;br /&gt;is a wonderful venue (with good coffee!), and the city is a lot of fun.  Everything went smoothly and the &lt;br /&gt;organizers did a great job.&lt;br /&gt;&lt;br /&gt;You can get a list of papers that I liked from my &lt;a href=&quot;https://twitter.com/paulmineiro&quot;&gt;Twitter feed&lt;/a&gt;, so instead I&#39;d like to discuss some broad themes &lt;br /&gt;I sensed.&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;Multitask regularization to mitigate sample complexity in RL.&lt;/b&gt;  Both in video games and in dialog, it is useful to add extra (auxiliary) tasks in order to accelerate learning.&lt;/li&gt;&lt;li&gt;&lt;b&gt;Leveraging knowledge and memory.&lt;/b&gt;  Our current models are powerful function approximators, but in NLP especially we need to go beyond &quot;the current example&quot; in order exhibit competence.&lt;/li&gt;&lt;li&gt;&lt;b&gt;Gradient descent as inference.&lt;/b&gt;  Whether it&#39;s &lt;a href=&quot;https://arxiv.org/abs/1703.03208&quot;&gt;inpainting with a GAN&lt;/a&gt; or &lt;a href=&quot;http://people.eng.unimelb.edu.au/tcohn/papers/emnlp17relopt.pdf&quot;&gt;BLUE score maximization with an RNN&lt;/a&gt;, gradient descent is an unreasonably good inference algorithm.&lt;/li&gt;&lt;li&gt;&lt;b&gt;Careful initialization is important.&lt;/b&gt;  I suppose traditional optimization people would say &quot;of course&quot;, but we&#39;re starting to appreciate the importance of good initialization for deep learning.  In particular, start close to linear with eigenvalues close to 1. (&lt;a href=&quot;https://arxiv.org/abs/1702.08591&quot;&gt;Balduzzi et. al.&lt;/a&gt; , &lt;a href=&quot;https://arxiv.org/abs/1606.05340&quot;&gt;Poole et. al.&lt;/a&gt;)&lt;/li&gt;&lt;li&gt;&lt;b&gt;Convolutions are as good as, and faster than, recurrent models for NLP.&lt;/b&gt;  Nice work out of Facebook on &lt;a href=&quot;https://arxiv.org/abs/1705.03122&quot;&gt;causal convolutions&lt;/a&gt; for seq2seq.  This aligns with my personal experience: we use convolutional NLP models in production for computational performance reasons.&lt;/li&gt;&lt;li&gt;&lt;b&gt;Neural networks are overparameterized.&lt;/b&gt;  They can be made much sparser without losing accuracy (&lt;a href=&quot;https://arxiv.org/abs/1701.05369&quot;&gt;Molchanov et. al.&lt;/a&gt;, &lt;a href=&quot;https://arxiv.org/abs/1708.00077&quot;&gt;Lobacheva et. al.&lt;/a&gt;).&lt;/li&gt;&lt;li&gt;&lt;b&gt;maluuba had the best party.&lt;/b&gt;  Woot!&lt;/li&gt;&lt;/ul&gt;Finally, I kept thinking &lt;i&gt;the papers are all &amp;ldquo;old&amp;rdquo;.&lt;/i&gt;  While there were lots of papers I was seeing for the first time, it nonetheless felt like the results were all dated because I&#39;ve become addicted to &amp;ldquo;fresh results&amp;rdquo; on arxiv.&lt;br /&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.machinedlearnings.com/feeds/5989126378435033466/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.machinedlearnings.com/2017/08/icml-2017-thoughts.html#comment-form' title='3 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/5989126378435033466'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/5989126378435033466'/><link rel='alternate' type='text/html' href='http://www.machinedlearnings.com/2017/08/icml-2017-thoughts.html' title='ICML 2017 Thoughts'/><author><name>Paul Mineiro</name><uri>http://www.blogger.com/profile/05439062526157173163</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>3</thr:total></entry><entry><id>tag:blogger.com,1999:blog-4446292666398344382.post-183958876486506593</id><published>2017-07-26T11:12:00.000-07:00</published><updated>2017-07-26T11:12:23.713-07:00</updated><title type='text'>Rational Inexuberance</title><content type='html'>Recently Yoav Goldberg had a &lt;a href=&quot;https://medium.com/@yoav.goldberg/an-adversarial-review-of-adversarial-generation-of-natural-language-409ac3378bd7&quot;&gt;famous blog rant&lt;/a&gt;.  I appreciate his concern, because the situation is game-theoretically dangerous: any individual researcher receives a benefit for aggressively positioning their work (as early as possible), but the field as a whole risks another AI winter as rhetoric and reality become increasingly divergent.  Yoav&#39;s solution is to incorporate public shaming in order to align local incentives with aggregate outcomes (c.f., reward shaping).&lt;br /&gt;&lt;br /&gt;I feel there is a better way, as exemplified by a recent paper by &lt;a href=&quot;https://arxiv.org/abs/1707.07328&quot;&gt;Jia and Liang&lt;/a&gt;.  In this paper the authors corrupt the SQUAD dataset with distractor sentences which have no effect on human performance, but which radically degrade the performance of the systems on the leaderboard.  This reminds me of work by &lt;a href=&quot;https://arxiv.org/abs/1606.06031&quot;&gt;Paperno et. al.&lt;/a&gt; on a paragraph completion task which humans perform with high skill and for which all state of the art NLP approaches fail miserably.  Both of these works clearly indicate that our current automatic systems only bear a superficial (albeit economically valuable) resemblance to humans.&lt;br /&gt;&lt;br /&gt;This approach to honest self-assessment of our capabilities is not only more scholarly, but also more productive, as it provides concrete tasks to consider.  At minimum, this will result in improved technological artifacts.  Furthermore iterating this kind of goal-setting-and-goal-solving procedure &lt;i&gt;many many&lt;/i&gt; times might eventually lead to something worthy of the moniker Artificial Intelligence.&lt;br /&gt;&lt;br /&gt;(You might argue that the Yoav Goldberg strategy is more entertaining, but the high from the Yoav Goldberg way is a &quot;quick hit&quot;, whereas having a hard task to think about has a lot of &quot;replay value&quot;.)</content><link rel='replies' type='application/atom+xml' href='http://www.machinedlearnings.com/feeds/183958876486506593/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.machinedlearnings.com/2017/07/rational-inexuberance.html#comment-form' title='0 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/183958876486506593'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/183958876486506593'/><link rel='alternate' type='text/html' href='http://www.machinedlearnings.com/2017/07/rational-inexuberance.html' title='Rational Inexuberance'/><author><name>Paul Mineiro</name><uri>http://www.blogger.com/profile/05439062526157173163</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-4446292666398344382.post-716114678474989883</id><published>2017-07-17T12:17:00.000-07:00</published><updated>2017-07-17T12:17:12.521-07:00</updated><title type='text'>Tiered Architectures, Counterfactual Learning, and Sample Complexity</title><content type='html'>I&#39;m on a product team now, and once again I find myself working on a tiered architecture: an &amp;ldquo;L1&amp;rdquo; model selects some candidates which are passed to an &amp;ldquo;L2&amp;rdquo; model which reranks and filters the candidates which are passed to an &amp;ldquo;L3&amp;rdquo;, etc.  The motivation for this is typically computational, e.g., you can index a &lt;a href=&quot;http://dl.acm.org/citation.cfm?id=2505665&quot;&gt;DSSM&lt;/a&gt; model pretty easily but indexing a &lt;a href=&quot;https://arxiv.org/abs/1611.01603&quot;&gt;BIDAF&lt;/a&gt; model is more challenging.  However I think there are potential sample complexity benefits as well.&lt;br /&gt;&lt;br /&gt;I worry about sample complexity in counterfactual setups, because I think it is the likely next source for AI winter.  Reinforcement learning takes a tremendous amount of data to converge, which is why all the spectacular results from the media are in simulated environments, self-play scenarios, discrete optimization of a sub-component within a fully supervised setting, or other situations where there is essentially infinite data.  In real life data is limited.&lt;br /&gt;&lt;br /&gt;So when I read &lt;a href=&quot;https://arxiv.org/abs/1512.07679&quot;&gt;Deep Reinforcement Learning in Large Discrete Action Spaces&lt;/a&gt; by Dulac-Arnold et. al., I noticed that the primary motivation was computational, but figured another (more important?) benefit might be statistical.  Tiered architectures cannot overcome worst-case sample complexity bounds, but I think in practice they are a good strategy for counterfactual setups.&lt;br /&gt;&lt;br /&gt;Tiered architectures admit semi-supervised approaches, because an L1 model can often be initialized using unsupervised techniques (e.g., word embeddings, sentence embeddings, inverted indicies with tf-idf).  Learning the L2 model utilizing this L1 model only has a sample complexity based upon the number of candidates produced by the L1 model, rather than the total number of candidates.  Of course, learning the L1 still has a sample complexity based upon the total number of candidates, but if the unsupervised initialization is good then it is ok that the L1 learns slowly.  Furthermore in practice the L1 hypothesis class is simpler (because of computational reasons) which mitigates the sample complexity.&lt;br /&gt;&lt;br /&gt;There was a workshop called ``coarse-to-fine inference&#39;&#39; at NIPS 2017 which presumably explored these ideas, but I didn&#39;t attend it and their website is down.  Hopefully there will be another one, I will attend!</content><link rel='replies' type='application/atom+xml' href='http://www.machinedlearnings.com/feeds/716114678474989883/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.machinedlearnings.com/2017/07/tiered-architectures-counterfactual.html#comment-form' title='0 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/716114678474989883'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/716114678474989883'/><link rel='alternate' type='text/html' href='http://www.machinedlearnings.com/2017/07/tiered-architectures-counterfactual.html' title='Tiered Architectures, Counterfactual Learning, and Sample Complexity'/><author><name>Paul Mineiro</name><uri>http://www.blogger.com/profile/05439062526157173163</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-4446292666398344382.post-1496642175738964374</id><published>2017-03-25T07:14:00.000-07:00</published><updated>2017-03-25T07:14:06.188-07:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="Dialog"/><category scheme="http://www.blogger.com/atom/ns#" term="Machine Learning Business Trends"/><title type='text'>Why now is the time for dialog</title><content type='html'>I&#39;m working on a task-oriented dialog product and things are going surprisingly well from a business standpoint.  It turns out that existing techniques are sufficient to substitute some portion of commercial dialog interactions from human to machine mediated, with tremendous associated cost savings which exceed the cost of developing the automatic systems.  Here&#39;s the thing that is puzzling: the surplus is so large that, as far as I can tell, it would have been viable to do this 10 years ago with then-current techniques.  All the new fancy AI stuff helps, but only to improve the margins.  So how come these businesses didn&#39;t appear 10 years ago?&lt;br /&gt;&lt;br /&gt;I suspect the answer is that a format shift has occurred away from physical transactions and voice mediated interactions to digital transactions and chat mediated interactions.  &lt;br /&gt;&lt;br /&gt;The movement away from voice is very important: if we had to try and do this using ASR, even today, it probably wouldn&#39;t work.  Fortunately, today you chat with your cable company rather than talking to them.  That shift was motivated by cost savings: a human agent can handle multiple concurrent chat sessions more easily than multiple concurrent voice conversations.  However it requires most of your customers to have a computer, smartphone, or other device rather than an old-school telephone.  &lt;br /&gt;&lt;br /&gt;The continuing dominance of e-commerce over physical stores is also a factor (RIP &lt;a href=&quot;http://money.cnn.com/2017/03/22/news/companies/sears-kmart-future/&quot;&gt;Sears&lt;/a&gt;).  In e-commerce, human salespersons increasingly assist customers in transactions via live chat interfaces.  Once again, what starts as a more effective way of deploying human resources becomes the vector by which automation increasingly handles the workload.&lt;br /&gt;&lt;br /&gt;The end game here is that the number of people employed in retail goes down, but that their compensation goes up.  That is because the machines will increasingly handle the routine aspects of these domains, leaving only the long tail of extremely idiosyncratic issues for the humans to resolve.  Handling these non-routine issues will require more skill and experience and therefore demand higher compensation (also, an increasing part of the job will be to structure the torso of non-routine issues into something that the machines can handle routinely, i.e., teaching the machines to handle more; this is analogous to programming and will also demand higher compensation).&lt;br /&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.machinedlearnings.com/feeds/1496642175738964374/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.machinedlearnings.com/2017/03/why-now-is-time-for-dialog.html#comment-form' title='0 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/1496642175738964374'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/1496642175738964374'/><link rel='alternate' type='text/html' href='http://www.machinedlearnings.com/2017/03/why-now-is-time-for-dialog.html' title='Why now is the time for dialog'/><author><name>Paul Mineiro</name><uri>http://www.blogger.com/profile/05439062526157173163</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-4446292666398344382.post-8169803556516242616</id><published>2017-02-15T16:41:00.000-08:00</published><updated>2017-02-15T16:41:13.615-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="Practical Tips"/><title type='text'>Software Engineering vs Machine Learning Concepts</title><content type='html'>Not all core concepts from software engineering translate into the machine learning universe.  Here are some differences I&#39;ve noticed.&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;Divide and Conquer&lt;/span&gt; A key technique in software engineering is to break a problem down into simpler subproblems, solve those subproblems, and then compose them into a solution to the original problem.  Arguably, this is the entire job, recursively applied until the solution can be expressed in a single line in whatever programming language is being used.  The canonical pedagogical example is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Tower_of_Hanoi&quot;&gt;Tower of Hanoi&lt;/a&gt;.&lt;br /&gt;&lt;br /&gt;Unfortunately, in machine learning we never exactly solve a problem.  At best, we approximately solve a problem.  This is where the technique needs modification: in software engineering the subproblem solutions are &lt;span style=&quot;font-style: italic;&quot;&gt;exact&lt;/span&gt;, but in machine learning errors compound and the aggregate result can be complete rubbish.  In addition apparently paradoxical situations can arise where a component is &amp;ldquo;improved&amp;rdquo; in isolation yet aggregate system performance degrades when this &amp;ldquo;improvement&amp;rdquo; is deployed (e.g., due to the &lt;span style=&quot;font-style: italic;&quot;&gt;pattern&lt;/span&gt; of errors now being unexpected by downstream components, even if they are less frequent).&lt;br /&gt;&lt;br /&gt;Does this mean we are doomed to think holistically (which doesn&#39;t sound scalable to large problems)?  No, but it means you have to be defensive about subproblem decomposition.  The best strategy, when feasible, is to train the system end-to-end, i.e., optimize all components (and the composition strategy) together rather than in isolation.  Often this is not feasible, so another alternative (inspired by Bayesian ideas) is to have each component report some kind of confidence or variance along with the output in order to facilitate downstream processing and integration.&lt;br /&gt;&lt;br /&gt;In practice, when systems get to a particular scope, there needs to be decomposition in order to divide the work up amongst many people.  The fact that this doesn&#39;t work right now in machine learning is a problem, as elegantly described by Leon Bottou in his &lt;a href=&quot;http://icml.cc/2015/invited/LeonBottouICML2015.pdf&quot;&gt;ICML 2015 invited talk&lt;/a&gt;.&lt;br /&gt;&lt;br /&gt;Speaking of another concept that Leon discussed $\ldots$&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;Correctness&lt;/span&gt; In software engineering, an algorithm can be proven correct, in the sense that given particular assumptions about the input, certain properties will be true when the algorithm terminates.  In (supervised) machine learning, the only guarantee we really have is that if the training set is an iid sample from a particular distribution, then performance on another iid sample from the same distribution will be close to that on the training set and not too far from optimal.&lt;br /&gt;&lt;br /&gt;Consequently anyone who practice machine learning for a living has an experimental mindset.  Often times I am asked whether option A or option B is better, and most of the time my answer is &amp;ldquo;I don&#39;t know, let&#39;s try both and see what happens.&amp;rdquo;  Maybe the most important thing that people in machine learning know is how to assess a model in such a way that is predictive of generalization.  Even that is a &amp;ldquo;feel&amp;rdquo; thing: identifying and preventing leakage between training and validation sets (e.g., by stratified and temporal sampling) is something you learn by screwing up a few times; ditto for counterfactual loops.  Kaggle is great for learning about the former, but the latter seems to require making mistakes on a closed-loop system to really appreciate.&lt;br /&gt;&lt;br /&gt;Experimental &amp;ldquo;correctness&amp;rdquo; is much weaker than the guarantees from other software, and there are many ways for things to go badly.  For example in my experience it is always temporary: models go stale, it just always seems to happen.  Ergo, you need to plan to be continually (hence, automatically) retraining models.&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;Reuse&lt;/span&gt; This one is interesting.  Reuse is the key to leverage in traditional software engineering: it&#39;s not just more productive to reuse other code, but every line of code you write yourself is an opportunity to inject defects.  Thus, reuse not only allows you to move faster but also make less mistakes: in return, you must pay the price of learning how to operate a piece of software written by others (when done well, this price has been lowered through good organization, documentation, and community support).  &lt;br /&gt;&lt;br /&gt;Some aspects of machine learning exhibit exactly the same tradeoff.  For instance, if you are writing your own deep learning toolkit, recognize that you are having fun.  There&#39;s nothing wrong with having fun, and pedagogical activities are arguably better than playing video games all day.  However, if you are trying to get something done, you should absolutely attempt to reuse as much technology as you can, which means you should be using a standard toolkit.  You will move faster and make less mistakes, once you learn how to operate the standard toolkit.&lt;br /&gt;&lt;br /&gt;Machine learning toolkits are &amp;ldquo;traditional software&amp;rdquo;, however, and are designed to be reused.  What about model reuse?  That can be good as well, but the caveats about decomposition above still apply.  So maybe you use a model which produces features from a user profile as inputs to your model.  Fine, but you should version the model you depend upon and not blindly upgrade without assessment or retraining.  Reusing the internals of another model is especially dangerous as most machine learning models are not identifiable, i.e., have various internal symmetries which are not determined by the training procedure.  Couple an embedding to a tree, for instance, and when the next version of the embedding is a rotation of the previous one, you can watch your performance go to crap immediately.&lt;br /&gt;&lt;br /&gt;Basically, model reuse creates &lt;span style=&quot;font-style: italic;&quot;&gt;strong&lt;/span&gt; coupling between components which can be problematic if one component is changed. &lt;br /&gt; &lt;br /&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;Testing&lt;/span&gt; I find the role of software testing in machine learning to be the trickiest issue of all.  Without a doubt testing is necessary, but the challenge in using something like property-based testing is that the concept that is being captured by the machine learning component is not easily characterized by properties (otherwise, you would write it using non-ml software techniques).  To the extent there are some properties that the ml component should exhibit, you can test for these, but unless you incorporate these into the learning procedure itself (e.g., via parameter tying or data augmentation) you are likely to have some violations of the property that are not necessarily indicative of defects.&lt;br /&gt;&lt;br /&gt;Having a &amp;ldquo;extra-test&amp;rdquo; data set of with minimal acceptable quality is a good idea: this could be easy examples that &amp;ldquo;any reasonable model&amp;rdquo; should get correct.  There&#39;s also self-consistency: at Yahoo they used to ship models with a set of input-output pairs that were computed with the model when it was put together, and if the loaded model didn&#39;t reproduce the pairs, the model load was cancelled.  (That should never happen, right?  Surprise!  Maybe you are featurizing the inputs using a library with a different version or something.)  &lt;br /&gt;&lt;br /&gt;Monitoring the metrics (proxy and true) of deployed models is also good for detecting problems.  If the proxy metric (i.e., the thing on which you actually trained your model and estimated generalization performance) is going south, the inputs to your model are changing somehow (e.g., nonstationary environment, change in feature extraction pipeline); but if the proxy metric is stable while the true metric is going south, the problem might be in how the outputs of your model are being leveraged.&lt;br /&gt;&lt;br /&gt;Unfortunately what I find is many software systems with machine learning components are tested in a way that would make traditional software engineers cringe: we look at the output to see if it is reasonable.  Crazy!  As machine learning becomes a more pervasive part of software engineering, this state of affairs must change.&lt;br /&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.machinedlearnings.com/feeds/8169803556516242616/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.machinedlearnings.com/2017/02/software-engineering-vs-machine.html#comment-form' title='2 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/8169803556516242616'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/8169803556516242616'/><link rel='alternate' type='text/html' href='http://www.machinedlearnings.com/2017/02/software-engineering-vs-machine.html' title='Software Engineering vs Machine Learning Concepts'/><author><name>Paul Mineiro</name><uri>http://www.blogger.com/profile/05439062526157173163</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>2</thr:total></entry><entry><id>tag:blogger.com,1999:blog-4446292666398344382.post-8961493893397272946</id><published>2017-01-27T18:36:00.000-08:00</published><updated>2017-01-27T18:53:51.920-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="Reinforcement Learning"/><title type='text'>Reinforcement Learning and Language Support</title><content type='html'>What is the right way to specify a program that learns from experience?  Existing general-purpose programming languages are designed to facilitate the specification of any piece of software.  So we can just use these programming languages for reinforcement learning, right?  Sort of.&lt;br /&gt;&lt;br /&gt;&lt;h4&gt;Abstractions matter&lt;/h4&gt;An analogy with high performance serving might be helpful.  An early influential page on high performance serving (&lt;a href=&quot;http://www.kegel.com/c10k.html&quot;&gt;the C10K problem by Dan Kegel&lt;/a&gt;) outlines several I/O strategies.  I&#39;ve tried many of them.  One strategy is event-driven programming, where a core event loop monitors file descriptors for events, and then dispatches handlers.  This style yields high performance servers, but is difficult to program and sensitive to programmer error.  In addition to fault isolation issues (if all event are running in the same address space), this style is sensitive to whenever any event handler takes too long to execute (e.g., hidden blocking I/O calls, computationally intensive operations, etc.).  In contrast, thread-based programming allowed you to pretend that you were the only handler running.  It was less computationally efficient and still had fault isolation issues, but it was easier to reason about.  (Subsequently, I started getting into Erlang because it essentially tried to bake user-space threading with fault isolation into the language, which was even better.)&lt;br /&gt;&lt;br /&gt;I don&#39;t know what the state-of-the-art is in high performance serving now, I&#39;m a bit out of that game.  The main point is that all programming languages are not created equal, in that they create different cognitive burdens on the programmer and different computational burdens at runtime.  I could use an existing language (at that time, C++) in one of two ways (cooperative scheduling vs. pre-emptive scheduling), or I could use a different language (Erlang) that was designed to mitigate the tradeoff.&lt;br /&gt;&lt;br /&gt;&lt;h4&gt;Imperative specification with automatic credit assignment&lt;/h4&gt;As previously stated, the difference between the programs we&#39;d like to specify now, versus the ones specified in the past, is that we want our programs to be able to learn from experience.  As with high-performance serving, we&#39;d like to balance the cognitive burden on the programmer with the computational burden imposed at runtime (also, possibly, the statistical burden imposed at runtime; computational burdens correspond to resources such as time or space, whereas the statistical burden corresponds to data resources).&lt;br /&gt;&lt;br /&gt;Within the current &amp;ldquo;AI summer&amp;rdquo;, one idea that become popular is &lt;a href=&quot;https://en.wikipedia.org/wiki/Automatic_differentiation&quot;&gt;automatic differentiation&lt;/a&gt;.  Full AD means that essentially any language construct can be used to define a function, and the computation to compute the gradient of the function with respect to the input is provided &amp;ldquo;for free.&amp;rdquo;  A language equipped with AD which is computing a (sub-)differentiable function can learn from experience in the sense of moving closer to a local optimum of a loss function.  Deep learning toolkits implement AD to various degrees, with some frameworks (e.g., &lt;a href=&quot;http://docs.chainer.org/en/stable/tutorial/basic.html&quot;&gt;Chainer&lt;/a&gt;) aggressively pursuing the idea of allowing arbitrary language constructs when specifying the forward computation.&lt;br /&gt;&lt;br /&gt;The ability to use arbitrary language constructs becomes increasingly important as inference becomes more complicated.  Simple inference (e.g., classification or ranking) is easy to reason about but beyond that it quickly becomes a major source of defects to 1) specify how the output of a machine learning model is used to synthesize a complete system and 2) specify how the data obtained from running that complete system is used to update the model.&lt;br /&gt;&lt;br /&gt;The problem is clearly visible in the field of structured prediction.  &amp;ldquo;Structured prediction&amp;rdquo;, of course, is a somewhat ridiculous term analogous to the term &amp;ldquo;nonlinear systems analysis&amp;rdquo;; in both cases, a simpler version of the problem was solved initially (classification and linear systems analysis, respectively) and then an umbrella term was created for everything else.  Nonetheless, Hal Daume has a good definition of structured prediction, which is making multiple predictions on a single example and experiencing a joint (in the decisions) loss.  (He also has a &lt;a href=&quot;https://github.com/JohnLangford/vowpal_wabbit/wiki/learning2search_python.pdf&quot;&gt;Haiku version&lt;/a&gt; of this definition.)&lt;br /&gt;&lt;br /&gt;Because inference in structured prediction is complicated, the ideas of imperative specification and automated credit assignment were essentially reinvented for structured prediction.  The technique is outlined in an &lt;a href=&quot;https://arxiv.org/abs/1406.1837&quot;&gt;Arxiv paper by Chang et. al.&lt;/a&gt;, but fans of Chainer will recognize this as the analog of &amp;ldquo;define-by-run&amp;rdquo; for structured prediction.  (Note the optimization strategy here is not gradient descent, at least not on the forward computation, but rather something like a policy gradient method which translates to a discrete credit assignment problem over the predictions made by the forward computation.)&lt;br /&gt;&lt;br /&gt;One way to view episodic RL is structured prediction with bandit feedback: structured prediction is fully observed, analogous to supervised learning, in that it is possible to compute the loss of any sequence of decisions given a particular input.  In reinforcement learning you have bandit feedback, i.e., you only learn about the loss associated with the sequence of decisions actually taken.  While this isn&#39;t the only way to view episodic RL, it does facilitate connecting with some of the ideas of the paper mentioned in the previous paragraph.&lt;br /&gt;&lt;br /&gt;&lt;h4&gt;A Motivating Example&lt;/h4&gt;Here&#39;s an example which will hopefully clarify things.  Suppose we want to build an interactive question-answering system, in which users pose questions, and then the system can optionally ask a (clarifying) question to the user or else deliver an answer.  We can view this as an episodic RL problem, where the user statements are observations, system questions are actions, system answers are more actions, and the episode ends as soon as we deliver an answer.&lt;br /&gt;&lt;br /&gt;What I&#39;d like to do is specify the computation something like this pseudo-python:&lt;br /&gt;&lt;pre class=&quot;brush:bash&quot;&gt;def interactive_qa_episode():&lt;br /&gt;  uq = get_user_question()&lt;br /&gt;  qapairs = []&lt;br /&gt;  sysaction = get_next_system_action(uq, qapairs)&lt;br /&gt;  while (sysaction.is_question):&lt;br /&gt;    ua = get_user_answer(sysaction.utterance)&lt;br /&gt;    qapairs.append((sysaction,ua))&lt;br /&gt;    sysaction = get_next_system_action(uq, qapairs)&lt;br /&gt;  deliverAnswer(sysaction.utterance)&lt;br /&gt;&lt;/pre&gt;It is pretty clear what is going on here: we get a user question, conditionally ask questions, and then deliver an answer.  Before the advent of machine learning, an implementer of such a system would attempt to fill out the unspecified functions above: in particular, &lt;span style=&quot;font-family: monospace;&quot;&gt;get_next_system_action&lt;/span&gt; is tricky to hand specify.  What we would like to do is learn this function instead.&lt;br /&gt;&lt;br /&gt;It would be nice to use decorators to achieve this.  First, to learn we need some idea of doing better or worse, so assume after delivering an answer there is some way to decide how satisfied the user is with the session (which, ceterus perebus, should be monotonically decreasing with the number of questions asked, to encourage expediency):&lt;br /&gt;&lt;pre class=&quot;brush:bash&quot;&gt;@episodicRL&lt;br /&gt;def interactive_qa_episode():&lt;br /&gt;  uq = get_user_question()&lt;br /&gt;  qapairs = []&lt;br /&gt;  sysaction = get_next_system_action(uq, qapairs)&lt;br /&gt;  while (sysaction.is_question):&lt;br /&gt;    ua = get_user_answer(sysaction.utterance)&lt;br /&gt;    qapairs.append((sysaction,ua))&lt;br /&gt;    sysaction = get_next_system_action(uq, qapairs)&lt;br /&gt;# this next line is the only change to the original function&lt;br /&gt;  reward = deliverAnswer(sysaction.utterance) &lt;br /&gt;&lt;/pre&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=X8PyTo6NyXA&quot;&gt;All too easy&lt;/a&gt;!  Pseudo-code is so productive.  We can even imagine updating &lt;span style=&quot;font-family: monospace;&quot;&gt;reward&lt;/span&gt; multiple times, with the decorator keeping track of the reward deltas for improved credit assignment.&lt;br /&gt;&lt;br /&gt;Now some magic metaprogramming kicks in and converts this into a model being trained with an RL algorithm (e.g., a value iteration method such as q-learning, or a policy iteration method such as &lt;a href=&quot;https://arxiv.org/abs/1502.02206&quot;&gt;bandit LOLS&lt;/a&gt;).  Or does it?  We still haven&#39;t said which functions are to be learned and which are hand-specified.  The default will be hand-specified, so we will decorate one function.&lt;br /&gt;&lt;pre class=&quot;brush:bash&quot;&gt;@learnedFunction&lt;br /&gt;def get_next_system_action(uq, qapairs):&lt;br /&gt;  ...&lt;br /&gt;&lt;/pre&gt;Now we get into some thorny issues.  We need to specify this functions ultimately in terms of a parameterized model like a neural network; we&#39;ll have to say what the initial representation is that is computed from variables like &lt;span style=&quot;font-family: monospace;&quot;&gt;uq&lt;/span&gt; and &lt;span style=&quot;font-family: monospace;&quot;&gt;qapairs&lt;/span&gt;; and we&#39;ll have to say how the output of the model is mapped onto an actual decision.  Just to keep moving, let&#39;s assume there is a fixed small set of system questions and system answers.&lt;br /&gt;&lt;pre class=&quot;brush:bash&quot;&gt;action_table = [ ... ] # list containing action mapping&lt;br /&gt;@learnedFunction&lt;br /&gt;def get_next_system_action(uq, qapairs):&lt;br /&gt;  not_allowed_action_ids = [ sysa.action_id for (sysa, _) in qapairs ]&lt;br /&gt;  action_id = categorical_choice(uq: uq,&lt;br /&gt;                                 qapairs: qapairs,&lt;br /&gt;                                 not_allowed_action_ids: not_allowed_action_ids,&lt;br /&gt;                                 tag: &#39;nextsystemaction&#39;)&lt;br /&gt;  return action_table[action_id]&lt;br /&gt;&lt;/pre&gt;&lt;span style=&quot;font-family: monospace;&quot;&gt;categorical_choice&lt;/span&gt; is the representation of a forced choice from one of a set of possibilities.  For small action spaces, this could be directly implemented as an output per action, but for large action spaces this might be implemented via action embeddings with an information-retrieval style cascading pipeline.&lt;br /&gt;&lt;br /&gt;Great right?  Well some problems remain.&lt;br /&gt;&lt;ul&gt;&lt;li&gt; The best model structure (i.e., policy class) for the choice requires some specification by the programmer, e.g., a convolutional text network vs. an iterated attention architecture.  Ideally this specification is distinct from the specification of inference, so that many modeling ideas can be tried.  That&#39;s the purpose of the tag argument, to join with a separate specification of the learning parameters.  (If not provided, sane default tags could be generated during compilation.)&lt;/li&gt;&lt;li&gt; As indicated in &lt;a href=&quot;/2017/01/reinforcement-learning-as-service.html&quot;&gt;the previous post&lt;/a&gt;, bootstrapping is everything.  So an initial implementation of &lt;span style=&quot;font-family: monospace;&quot;&gt;get_next_system_action&lt;/span&gt; needs to be provided.  Maybe this reduces to providing an initial setting of the underlying model, but maybe it doesn&#39;t depending upon the initialization scenario.  Note if initialization is done via simulation or off-policy learning from historical data, these could be supported by facilitating the mockup of the I/O functions &lt;span style=&quot;font-family: monospace;&quot;&gt;get_user_question&lt;/span&gt; and &lt;span style=&quot;font-family: monospace;&quot;&gt;get_user_answer&lt;/span&gt;.  Another common scenario is that a not-learned function is provided as a reference policy with which the learned function should compete.&lt;/li&gt;&lt;/ul&gt;&lt;b&gt;Can&#39;t I do this with Chainer already?&lt;/b&gt; Sort of.  If you use a particular RL algorithm, definitely.  For instance, q-learning reduces reinforcement learning to regression, so if you code that inline, you get something Chainer could handle.  However the goal is to specify inference without leaking details about the learning algorithm, so I&#39;d rather not code that inline.  An alternative is to compile &lt;span style=&quot;font-style: italic;&quot;&gt;to&lt;/span&gt; Chainer, akin to cfront in the early days of c++.  &lt;br /&gt;&lt;br /&gt;Ultimately, however, I would hope to have a different compilation strategy.  There&#39;s more at stake than just implementing the learning algorithm: there are all the issues mentioned in &lt;a href=&quot;/2017/01/reinforcement-learning-as-service.html&quot;&gt;my previous post&lt;/a&gt; that have convinced me that the implementation should be able to leverage a reinforcement learning service.</content><link rel='replies' type='application/atom+xml' href='http://www.machinedlearnings.com/feeds/8961493893397272946/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.machinedlearnings.com/2017/01/reinforcement-learning-and-language.html#comment-form' title='0 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/8961493893397272946'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/8961493893397272946'/><link rel='alternate' type='text/html' href='http://www.machinedlearnings.com/2017/01/reinforcement-learning-and-language.html' title='Reinforcement Learning and Language Support'/><author><name>Paul Mineiro</name><uri>http://www.blogger.com/profile/05439062526157173163</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-4446292666398344382.post-2485427515732354446</id><published>2017-01-21T16:25:00.000-08:00</published><updated>2017-01-27T17:46:45.594-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="Reinforcement Learning"/><title type='text'>Reinforcement Learning as a Service</title><content type='html'>I&#39;ve been integrating reinforcement learning into an actual product for the last 6 months, and therefore I&#39;m developing an appreciation for what are likely to be common problems.  In particular, I&#39;m now sold on the idea of reinforcement learning as a service, of which the &lt;a href=&quot;https://mwtds.azurewebsites.net/&quot;&gt;decision service&lt;/a&gt; from MSR-NY is an early example (limited to contextual bandits at the moment, but incorporating key system insights).&lt;br /&gt;&lt;br /&gt;&lt;b&gt;Service, not algorithm&lt;/b&gt; Supervised learning is essentially observational: some data has been collected and subsequently algorithms are run on it.  (Online supervised learning doesn&#39;t necessarily work this way, but mostly online techniques have been used for computational reasons after data collection.)  In contrast, counterfactual learning is very difficult do to observationally.  Diverse fields such as economics, political science, and epidemiology all attempt to make counterfactual conclusions using observational data, essentially because this is the only data available (at an affordable cost).  When testing a new medicine, however, the standard is to run a controlled experiment, because with control over the data collection more complicated conclusions can be made with higher confidence.&lt;br /&gt;&lt;br /&gt;Analogously, reinforcement learning is best done &amp;ldquo;in the loop&amp;rdquo;, with the algorithm controlling the collection of data which is used for learning.  Because of this, a pure library implementation of a reinforcement learning algorithm is unnatural, because of the requisite state management.  For example, rewards occur after actions are taken, and these need to be ultimately associated with each other for learning.  (One of my first jobs was at a sponsored search company called Overture, and maintaining the search-click join was the full time job of a dozen engineers: note this was merely an immediate join for a singleton session!)&lt;br /&gt;&lt;br /&gt;Ergo, packaging reinforcement learning as a service makes more sense.  This facilitates distributed coordination of the model updates, the serving (exploration) distribution, and the data collection.  This scenario is a natural win for cloud computing providers.  However, in practice there needs to be an offline client mode (e.g., for mobile and IOT applications); furthermore, this capability would be utilized even in a pure datacenter environment because of low latency decision requirements.  (More generally, there would probably be a &amp;ldquo;tiered learning&amp;rdquo; architecture analogous to the tiered storage architectures utilized in cloud computing platforms.  Brendan McMahan has been thinking along these lines under the rubric of &lt;a href=&quot;https://research.google.com/pubs/pub45648.html&quot;&gt;federated learning&lt;/a&gt;.)&lt;br /&gt;&lt;br /&gt;&lt;b&gt;Bootstrapping is everything&lt;/b&gt; It is amazing how clarifying it is to try and solve and actual problem.  I now appreciate that reinforcement learning has been oversold a bit.  In particular, the sample complexity requirements for reinforcement learning are quite high.  (That&#39;s fancy talk for saying it takes a lot of data to converge.)  When you are working in a simulated environment that&#39;s not such a concern, because you have the equivalent of infinite training data, so we see dramatic results in simulated environments.  &lt;br /&gt;&lt;br /&gt;When reinforcement learning is done on live traffic with real users, you have less data than you think because you always start with a test fraction of data and you don&#39;t get more until you are better (catch 22).  So I actually spend a lot of my time developing initial serving policies, unfortunately somewhat idiosyncratically: imitation learning can be great with the right data assets, but heuristic strategies are also important.  I suspect initialization via not-smartly-initialized-RL in a simulated environment is another possibility (in dialog simulators aren&#39;t so good so I haven&#39;t leveraged this strategy yet).&lt;br /&gt;&lt;br /&gt;This creates some design questions for RL as a service.  &lt;br /&gt;&lt;ul&gt;&lt;li&gt; Assuming there is an initial serving policy, how do I specify it?  In the decision service you pass in the action that the initial serving policy would take which is fine for contextual bandits, but for a multi-step epoch this could be cumbersome because the initial serving policy needs to maintain state.  It would make sense for the service to make it easier to manage this.&lt;/li&gt;&lt;li&gt; How does the service help me put together the initial serving policy?  Considering my experience so far, here are some possible ways to develop an initial serving policy:&lt;br /&gt;&lt;ul&gt;&lt;li&gt; An arbritrary program (``heuristic&#39;&#39;).  Sometimes this is the easiest way to cold start, or this might be the current ``champion&#39;&#39; system.&lt;/li&gt;&lt;li&gt; Imitation learning.  Assumes suitable data assets are available.&lt;/li&gt;&lt;li&gt; Off-policy learning from historical data.  This can be better than imitation learning if the historical policy was suitably randomized (e.g., the exhaust of previous invocations of RL as a service).&lt;/li&gt;&lt;li&gt; Boostrapping via simulation.  In dialog this doesn&#39;t seem viable, but if a good simulator is available (e.g., robotics and game engines?), this could be great.  Furthermore this would involve direct reuse of the platform, albeit on generated data.&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;b&gt;Language is the UI of programming&lt;/b&gt; I think ideas from &lt;a href=&quot;https://arxiv.org/abs/1406.1837&quot;&gt;credit-assignment compilation&lt;/a&gt; would not only address the question of how to specify the initial policy, but also provide the most natural interface for utilizing RL a service.  I&#39;ll do another post exploring that.</content><link rel='replies' type='application/atom+xml' href='http://www.machinedlearnings.com/feeds/2485427515732354446/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.machinedlearnings.com/2017/01/reinforcement-learning-as-service.html#comment-form' title='2 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/2485427515732354446'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/2485427515732354446'/><link rel='alternate' type='text/html' href='http://www.machinedlearnings.com/2017/01/reinforcement-learning-as-service.html' title='Reinforcement Learning as a Service'/><author><name>Paul Mineiro</name><uri>http://www.blogger.com/profile/05439062526157173163</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>2</thr:total></entry><entry><id>tag:blogger.com,1999:blog-4446292666398344382.post-8221747922437992799</id><published>2017-01-13T15:39:00.001-08:00</published><updated>2017-01-27T17:47:09.864-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="Dialog"/><category scheme="http://www.blogger.com/atom/ns#" term="NLP"/><title type='text'>Generating Text via Adversarial Training</title><content type='html'>There was a really cute paper at the GAN workshop this year, &lt;a href=&quot;https://c4209155-a-62cb3a1a-s-sites.googlegroups.com/site/nips2016adversarial/WAT16_paper_20.pdf?attachauth=ANoY7crhVMeBjlVzimWWcRGP1HDDn3kqhKMJ28QG-ScFpePoWtKmNFE19WEviKEkMsESm2ZY26--b6qu1jggzKWj2ftFtrzhoEIqu2Q2biTusqMGw9icjPWLU3-BRcMQMPFToITwZ23IGKd7iok87FYq1JP7uyWHYEVUp6Jqqjabpu-77KvzDVNS2Lm3CzjzqAi-uYPPbKIcBodP9Kf_7rIZz43ulC3lVuVKJqyZRjELTPPxu_UCFZM%3D&amp;attredirects=0&quot;&gt;Generating Text via Adversarial Training&lt;/a&gt; by Zhang, Gan, and Carin.  In particular, they make a couple of unusual choices that appear important.  (Warning: if you are not familiar with GANs, this post will not make a lot of sense.)&lt;br /&gt;&lt;ol&gt;&lt;li&gt;They use a convolutional neural network (CNN) as a discriminator, rather than an RNN.  In retrospect this seems like a good choice, e.g. Tong Zhang has been &lt;a href=&quot;http://riejohnson.com/cnn_download.html&quot;&gt;crushing it&lt;/a&gt; in text classification with CNNs.  CNNs are a bit easier to train than RNNs, so the net result is a powerful discriminator with a relatively easy optimization problem associated with it.&lt;br /&gt;&lt;/li&gt;&lt;li&gt;They use a smooth approximation to the LSTM output in their generator, but actually this kind of trick appears everywhere so isn&#39;t so remarkable in isolation.&lt;br /&gt;&lt;/li&gt;&lt;li&gt;They use a pure moment matching criterion for the saddle point optimization (estimated over a mini-batch).  GANs started with a pointwise discrimination loss and more recent work has augmented this loss with moment matching style penalties, but here the saddle point optimization is pure moment matching.  (So technically the discriminator isn&#39;t a discriminator.  They actually refer to it as discriminator or encoder interchangeably in the text, this explains why.)&lt;br /&gt;&lt;/li&gt;&lt;li&gt;They are very smart about initialization.  In particular the discriminator is pre-trained to distinguish between a true sentence and the same sentence with two words swapped in position.  (During initialization, the discriminator is trained using a pointwise classification loss).  This is interesting because swapping two words preserves many of the $n$-gram statistics of the input, i.e., many of the convolutional filters will compute the exact same value.  (I&#39;ve had good luck recently using permuted sentences as negatives for other models, now I&#39;m going to try swapping two words.)&lt;br /&gt;&lt;li&gt;They update the generator &lt;b&gt;more frequently&lt;/b&gt; than the discriminator, which is counter to the standard folklore which says you want the discriminator to move faster than the generator.  Perhaps this is because the CNN optimization problem is much easier than the LSTM one; the use of a purely moment matching loss might also be relevant.&lt;br /&gt;&lt;/li&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/ol&gt;The old complaint about neural network papers was that you couldn&#39;t replicate them.  Nowadays it is often easier to replicate neural network papers than other papers, because you can just fork their code on github and run the experiment.  However, I still find it difficult to ascertain the relative importance of the various choices that were made.  For the choices enumerated above: what is the sensitivity of the final result to these choices?  Hard to say, but I&#39;ve started to assume the sensitivity is high, because when I have tried to tweak a result after replicating it, it usually goes to shit.  (I haven&#39;t tried to replicate this particular result yet.)&lt;br /&gt;&lt;br /&gt;Anyway this paper has some cool ideas and hopefully it can be extended to generating realistic-looking dialog.</content><link rel='replies' type='application/atom+xml' href='http://www.machinedlearnings.com/feeds/8221747922437992799/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.machinedlearnings.com/2017/01/generating-text-via-adversarial-training.html#comment-form' title='2 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/8221747922437992799'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/8221747922437992799'/><link rel='alternate' type='text/html' href='http://www.machinedlearnings.com/2017/01/generating-text-via-adversarial-training.html' title='Generating Text via Adversarial Training'/><author><name>Paul Mineiro</name><uri>http://www.blogger.com/profile/05439062526157173163</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>2</thr:total></entry><entry><id>tag:blogger.com,1999:blog-4446292666398344382.post-3840739880383341325</id><published>2016-12-17T12:56:00.000-08:00</published><updated>2017-01-27T17:47:42.009-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="Opinion"/><title type='text'>On the Sustainability of Open Industrial Research</title><content type='html'>I&#39;m glad OpenAI exists: the more science, the better!  Having said that, there was a strange happenstance at NIPS this year.  OpenAI released &lt;a href=&quot;https://openai.com/blog/universe/&quot;&gt;OpenAI universe&lt;/a&gt;, which is their second big release of a platform for measuring and training counterfactual learning algorithms.  This is the kind of behaviour you would expect from an organization which is promoting the general advancement of AI without consideration of financial gain.  At the same time, Google, Facebook, and Microsoft all announced analogous platforms.  Nobody blinked an eyelash at the fact that three for-profit organizations were tripping over themselves to give away basic research technologies.&lt;br /&gt;&lt;br /&gt;A naive train of thought says that basic research is a public good, subject to the free-rider problem, and therefore will be underfunded by for-profit organizations.  If you think this is a strawman position, you haven&#39;t heard of the &lt;a href=&quot;https://books.google.com/books?id=VB4EAAAAMBAJ&amp;pg=PA41&amp;lpg=PA41&amp;dq=the+cisco+innovation+model+no+research+lab&amp;source=bl&amp;ots=oJ8PI3sHU6&amp;sig=Gh4xNYJrTaf5Y79NujAYjobDInc&amp;hl=en&amp;sa=X&amp;ved=0ahUKEwjntaG66vvQAhVJ7GMKHXamD7UQ6AEILTAD#v=onepage&amp;q=the%20cisco%20innovation%20model%20no%20research%20lab&amp;f=false&quot;&gt;Cisco model for innovation&lt;/a&gt;.  When this article was written:&lt;br /&gt;&lt;blockquote&gt;&amp;hellip;Cisco has no &amp;ldquo;pure&amp;rdquo; blue-sky research organization.  Rather, when Cisco invests research dollars, it has a specific product in mind.  The company relies on acquisitions to take the place of pure research &amp;hellip;&lt;/blockquote&gt;Articles like that used to worry me alot.  So why (apparently) is this time different?&lt;br /&gt;&lt;br /&gt;&lt;h4&gt;Factor 1: Labor Market Scarcity&lt;/h4&gt;Informal discussions with my colleagues generally end up at this explanation template.  Specific surface forms include:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;&amp;ldquo;You can&#39;t recruit the best people without good public research.&amp;rdquo;  Facially, I think this statement is true, but the logic is somewhat circular.  You certainly can&#39;t recruit the best researchers without good public research, but why do you want them in the first place?  So is the statement more like &amp;ldquo;With good public research, you can recruit the best people, and then convince them to do some non-public research.&amp;rdquo; (?) Alot of grad students do seem to graduate and then &amp;ldquo;disappear&amp;rdquo;, so there is probably some truth to this.&lt;/li&gt;&lt;li&gt;&amp;ldquo;The best people want to publish: it&#39;s a perk that you are paying them.&amp;rdquo; Definitely, getting public recognition for your work is rewarding, and it makes total sense for knowledge workers to want to balance financial capital and social capital.  Public displays of competence are transferable to a new gig, for instance.  But this line of thought assumes that public research is a cost for employers that they chose to pay in lieu of, e.g., higher salaries.&lt;/li&gt;&lt;/ul&gt;I not only suspect this factor is only part of the picture: I &lt;i&gt;strongly hope&lt;/i&gt; that it is only part of the picture.  Because if it is the whole picture, as soon as the labor market softens, privately funded public research will experience a big pullback, which would suck.&lt;br /&gt;&lt;br /&gt;&lt;h4&gt;Factor 2: Positive Externalities&lt;/h4&gt;This argument is: &amp;ldquo;researchers improve the productivity of those nearby such that it is worth paying them just to hang out.&amp;rdquo; In this line of thinking even a few weeks lead time on the latest ideas, plus the chance to talk in person with thought leaders in order to explain the nuances of the latest approaches, is worth their entire salary.   There is some truth to this, e.g., Geoffrey Hinton performed some magic for the speech team here back in the day.  The problem I have with this picture is that, in practice, it can be easier to communicate and collaborate with somebody across the planet than with somebody downstairs.  It&#39;s also &lt;i&gt;really&lt;/i&gt; hard to measure, so if I had to convince the board of directors to fund a research division based upon this, I think I would fail.&lt;br /&gt;&lt;br /&gt;This is another favorite argument that comes up in conversation, by the way.  It&#39;s funny to hear people characterize the current situation as &amp;ldquo; we&#39;re scarce and totally awesome.&amp;rdquo;  As &lt;a href=&quot;http://hitchhikers.wikia.com/wiki/Total_Perspective_Vortex&quot;&gt;Douglas Adams points out&lt;/a&gt;, there is little benefit to having a sense of perspective.&lt;br /&gt;&lt;br /&gt;&lt;h4&gt;Factor 3: Quality Assurance&lt;/h4&gt;The idea here is basically &amp;ldquo;contributing to the public research discussion ensures the high quality of ideas within the organization.&amp;rdquo;  The key word here is &lt;i&gt;contributing&lt;/i&gt;, as the alternative strategy is something more akin to free-riding, e.g., sending employees to conferences to attend but not contribute.&lt;br /&gt;&lt;br /&gt;There is definite value in preparing ideas for public consumption.  Writing the related work section of a paper is often an enlightening experience, although honestly it tends to happen after the work has been done, rather than before.  Before is more like a vague sense that there is no good solution to whatever the problem is, hopefully informed by a general sense of where the state-of-the-art is.  Writing the experiment section, in my experience, is more of a mixed bag: you often need to dock with a standard metric or benchmark task that seems at best idiosyncratic and at worst unrelated to the thrust of your work and therefore forcing particular hacks to get over the finish line.  (Maybe this is why everybody is investing so heavily in defining the next generation of benchmark tasks.)&lt;br /&gt;&lt;br /&gt;The funny thing is most of the preceeding benefits occur during the preparation for publication.  Plausibly, at that point, you could throw the paper away and still experience the benefits (should we call these &amp;ldquo;the arxiv benefits&amp;rdquo;?).  Running the reviewer gauntlet is a way of measuring whether you are doing quality work, but it is a noisy signal.  Quality peer feedback can suggest improvements and new directions, but is a scarce resource.  Philanthropic organizations that want to advance science should attack this scarcity, e.g., by funding high quality dedicated reviewers or inventing a new model for peer feedback.&lt;br /&gt;&lt;br /&gt;I don&#39;t find this factor very compelling as a rationale for funding basic research, i.e., if I were the head of a research department arguing for funding from the board of directors, I wouldn&#39;t heavily leverage this line of attack.  Truth is less important than perception here, and I think the accounting department would rather test the quality of their ideas in the marketplace of products.&lt;br /&gt;&lt;br /&gt;&lt;h4&gt;Factor 4: Marketing&lt;/h4&gt;A company can use their basic research accolades as a public display of the fitness and excellence of their products.  The big players definitely make sure their research achievements are discussed in high profile publications such as the New York Times.  However this mostly feels like an afterthought to me.  What seems to happen is that researchers are making their choices on what to investigate, some of it ends up being newsworthy, and another part of the organization has dedicated individuals whose job it is to identify and promote newsworthy research.  IBM is the big exception, e.g., Watson going after Jeopardy.  &lt;br /&gt;&lt;br /&gt;This is arguably sustainable (IBM has been at it for a while), but it creates activity that looks like big pushes around specific sensational goals, rather than distribution of basic research tools and techniques.  In other words, it doesn&#39;t look like what was happening at this year&#39;s NIPS.&lt;br /&gt;&lt;br /&gt;&lt;h4&gt;Factor 5: Monopolies&lt;/h4&gt;I find this explanation agreeable: that technology has created more &lt;a href=&quot;https://en.wikipedia.org/wiki/Natural_monopoly&quot;&gt;natural monopolies&lt;/a&gt; and natural monopolies fund research, c.f., Bell Labs and Xerox PARC.  All market positions are subject to disruption and erosion but Microsoft, Google, and Facebook all have large competitive moats in their respective areas (OS, search, and social), so they are currently funding public basic research.  This factor predicts that as Amazon&#39;s competitive moats in retail (and cloud computing) widen, they will engage in more public basic research, something we have seen recently.&lt;br /&gt;&lt;br /&gt;For AI (née machine learning) in particular, the key monopoly is &lt;i&gt;data&lt;/i&gt; (which derives from customer relationships).  Arguably the big tech giants would love for AI technologies to be commodities, because they would then be in the best position to exploit such technologies due to their existing customer relationships.  Conversely, if a privately discovered disruptive AI technology were to emerge, it would be one of the &amp;ldquo;majors&amp;rdquo; being disrupted by a start-up.  So the major companies get both benefits and insurance from a vibrant public research ecosystem around AI.&lt;br /&gt;&lt;br /&gt;Nonetheless, a largish company with a decent defensive moat might look at the current level of public research activity and say, &amp;ldquo;hey good enough, let&#39;s free ride.&amp;rdquo; (Not explicitly, perhaps, but implicitly).  Imagine you are in charge of Apple or Salesforce, what do you do?  I don&#39;t see a clear &amp;ldquo;right answer&amp;rdquo;, although both companies appear to be moving in the direction of more open basic research.&lt;br /&gt;&lt;br /&gt;&lt;h4&gt;Factor 6: Firms are Irrational&lt;/h4&gt;Tech firms are ruled by founder-emperors whose personal predilections can decide policies such as whether you can bring a dog to work.  The existence of a research department with a large budget, in practice, can be similarly motivated.  All the above factors are partially true but difficult to measure, so it comes down to a judgement call, and as long as a company is kicking ass deference for the founder(s) will be extreme.  &lt;br /&gt;&lt;br /&gt;If this factor is important, however, then when the company hits a rough patch, or experiences a transition at the top, things can go south quickly.  There have been examples of that in the last 10 years for sure.</content><link rel='replies' type='application/atom+xml' href='http://www.machinedlearnings.com/feeds/3840739880383341325/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.machinedlearnings.com/2016/12/on-sustainability-of-open-industrial.html#comment-form' title='0 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/3840739880383341325'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/3840739880383341325'/><link rel='alternate' type='text/html' href='http://www.machinedlearnings.com/2016/12/on-sustainability-of-open-industrial.html' title='On the Sustainability of Open Industrial Research'/><author><name>Paul Mineiro</name><uri>http://www.blogger.com/profile/05439062526157173163</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-4446292666398344382.post-8841652459027202143</id><published>2016-12-16T05:19:00.000-08:00</published><updated>2017-01-27T17:47:54.207-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="Dialog"/><category scheme="http://www.blogger.com/atom/ns#" term="NLP"/><title type='text'>Dialogue Workshop Recap</title><content type='html'>Most of the speakers have sent me their slides, which can be found on &lt;a href=&quot;http://letsdiscussnips2016.weebly.com/schedule.html&quot;&gt;the schedule page&lt;/a&gt;.  Overall the workshop was fun and enlightening.  Here are some major themes that I picked up upon.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;Evaluation&lt;/b&gt; There is no magic bullet, but check out &lt;a href=&quot;https://github.com/pmineiro/ldlmd2016/blob/master/NIPSDec2016H.Hastie.pdf&quot;&gt;Helen&#39;s slides&lt;/a&gt; for a nicely organized discussion of metrics.  Many different strategies were on display in the workshop:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Milica Gasic utilized crowdsourcing for some of her experiments.  She also indicated the incentives of crowdsourcing can lead to unnatural participant behaviours.&lt;/li&gt;&lt;li&gt;Nina Dethlefs used a combination of objective (BLEU) and subjective (“naturalness”) evaluation.&lt;/li&gt;&lt;li&gt;Vlad Serban has been a proponent of next utterance classification as a useful intrinsic metric.&lt;/li&gt;&lt;li&gt;Antoine Bordes (and the other FAIR folks) are heavily leveraging simulation and engineered tasks.&lt;/li&gt;&lt;li&gt;Jason Williams used imitation metrics (from hand labeled dialogs) as well as simulation.&lt;/li&gt;&lt;/ul&gt;As Helen points out, computing metrics from customer behaviour is probably the gold standard for industrial task-oriented systems, but this is a scarce resource.  (Even within the company that has the customer relationship, by the way: at my current gig they will not let me flight something without demonstrating limited negative customer experience impact.)&lt;br /&gt;&lt;br /&gt;Those who have been around longer than I have experienced several waves of enthusiasm and pessimism regarding simulation for dialogue.  Overall I think the takeaway is that simulation can be useful tool, as long as one is cognizant of the limitations.&lt;br /&gt;&lt;br /&gt;Antoine quickly adapted his talk to Nina&#39;s with a fun slide that said “Yes, Nina, we are bringing simulation back.”  The FAIR strategy is something like this: “Here are some engineered dialog tasks that appear to require certain capabilities to perform well, such as multi-hop reasoning, interaction with a knowledge base, long-term memory, etc.  At the moment we have no system that can achieve 100% accuracy on these engineered tasks, so we will use these tasks to drive research into architectures and optimization strategies.  We also monitor performance other external tasks (e.g., DSTC) to see if our learning generalizes beyond the engineered task set.”  Sounds reasonable.&lt;br /&gt;&lt;br /&gt;Personally, as a result of the workshop, I&#39;m going to invest more heavily in simulators in the near-term.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;Leveraging Linguistics&lt;/b&gt; Fernando Pereira had the killer comment about how linguistics is a descriptive theory which need not have explicit correspondence to implementation: &amp;ldquo;when Mercury goes around the Sun, it is not running General Relativity.&amp;rdquo;  Nonetheless, linguistics seems important not only for describing what behaviours a competent system must capture, but also for motivating and inspiring what kinds of automata we need to achieve it.  &lt;br /&gt;&lt;br /&gt;Augmenting or generating data sets seems like a natural way to leverage lingustics.  As an example, in the workshop I learned that 4 year old native English speakers are sensitive to proper vs. improper word order given simple sentences containing some nonsense words (but with morphological clues, such as capitalization and -ed suffix).  Consequently, I&#39;m trying a next utterance classification run on a large dialog dataset where some of the negative examples are token-permuted versions of the true continuation, to see if this changes anything.&lt;br /&gt;&lt;br /&gt;Raquel Fernandez&#39;s talk focused on adult-child language interactions, and I couldn&#39;t help but think about potential relevance to training artificial systems.  In fact, current dialog systems are acting like the parent (i.e., the expert), e.g., by suggesting reformulations to the user.  But this laughable, because our systems are stupid: shouldn&#39;t we be acting like the child?&lt;br /&gt;&lt;br /&gt;The most extreme use of linguistics was the talk by Eshghi and Kalatzis, where they develop a custom incremental semantic parser for dialog and then use the resulting logical forms to drive the entire dialog process.  Once the parser is built, the amount of training data required is extremely minimal, but the parser is presumably built from looking at a large number of dialogs.&lt;br /&gt;&lt;br /&gt;Nina Dethlefs discussed some promising experiments with AMR.  I&#39;ve been scared of AMR personally.  First, it is very expensive to get the annotations.  However, if that were the only problem, we could imagine a human-genome-style push to generate a large number of them.  The bigger problem is the relatively poor inter-annotator agreement (it was just Nina and her students, so they could come to agreement via side communication).  Nonetheless I could imagine a dialog system which is designed and built using a small number of prototypical semantic structures.  It might seem a bit artificial and constrained, but so does the graphical user interface with the current canonical set of UX elements, which users learn to productivity interact with.&lt;br /&gt;&lt;br /&gt;Angeliki Lazaridou&#39;s talk reminded me that communication is fundamentally a cooperative game, which explains why arguing on the internet is a waste of time. &lt;br /&gt;&lt;br /&gt;&lt;b&gt;Neural Networks: Game Changer?&lt;/b&gt;  I asked variants of the following question to every panel: &amp;ldquo;what problems have neural networks mitigated and what problems remain stubbornly unaddressed.&amp;rdquo;  This was, essentially, the content of Marco Baroni&#39;s talk.  Overall I would say: there&#39;s enthusiasm now that we are no longer afraid of non-convex loss functions (along these lines, check out &lt;a href=&quot;https://github.com/pmineiro/ldlmd2016/blob/master/letsdiscuss-gmemn2n-julienperez.pdf&quot;&gt;Julien Perez&#39;s slides&lt;/a&gt;).&lt;br /&gt;&lt;br /&gt;However, we currently have only vague ideas on how to realize the competencies that are apparently required for high quality dialog.  I say &lt;i&gt;apparently&lt;/i&gt; because the history of AI is full of practitioners assuming sufficient capabilities are necessary for some task, and recent advances in machine translation suggest that savant-parrots might be able to do surprisingly well.  In fact, during the discussion period there was some frustration that heuristic hand-coded strategies are still superior to machine learning based approaches, with the anticipation that this may continue to be true for the Alexa prize.  I&#39;m positive about the existence of superior heuristics, however: not only do they provide a source of inspiration and ideas for data-driven approaches, but learning methods that combine imitation learning and reinforcement learning should be able to beneficially exploit them.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;Entity Annotation&lt;/b&gt; Consider the apparently simple and ubiquitous feature engineering strategy: add additional sparse indicator features which indicate semantic equivalence of tokens or token sequences.  So maybe “windows 10” and “windows anniversary edition” both get the same feature.  Jason Williams indicated his system is greatly improved by this, but he&#39;s trying to learn from $O(10)$ labeled dialogues, so I nodded.  Antoine Bordes indicated this helps on some bAbI dialog tasks, but those tasks only have $O(1000)$ dialogues, so again I nodded.  Then Vlad Serban indicated this helps for next utterance classification on the Ubuntu Dialog Corpus.  At this point I thought, &amp;ldquo;wait, that&#39;s $O(10^5)$ dialogs.&amp;rdquo;&lt;br /&gt;&lt;table align=&quot;center&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; class=&quot;tr-caption-container&quot; style=&quot;margin-left: auto; margin-right: auto; text-align: center;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style=&quot;text-align: center;&quot;&gt;&lt;a href=&quot;https://4.bp.blogspot.com/-1C3sdb1DXSU/WFPenq4sgsI/AAAAAAAACd4/6C7UvpQqlTQBRwBm5r6s-7L7QFA0PRG9wCLcB/s1600/Blade_Runner_Intro_014.jpg&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: auto; margin-right: auto;&quot;&gt;&lt;img border=&quot;0&quot; height=&quot;133&quot; src=&quot;https://4.bp.blogspot.com/-1C3sdb1DXSU/WFPenq4sgsI/AAAAAAAACd4/6C7UvpQqlTQBRwBm5r6s-7L7QFA0PRG9wCLcB/s320/Blade_Runner_Intro_014.jpg&quot; width=&quot;320&quot; /&gt;&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;tr-caption&quot; style=&quot;text-align: center;&quot;&gt;Apparently, knowing a turtle and a tortoise are the same thing is tricky.&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;In practice, I&#39;m ok with manual feature engineering: it&#39;s how I paid the rent during the linear era.  But now I wonder: does it take much more data to infer such equivalences?  Will we never infer this, no matter how much data, given our current architectures?&lt;br /&gt;&lt;br /&gt;&lt;b&gt;Spelling&lt;/b&gt; The speakers were roughly evenly split between “dialog” and “dialogue”.  I prefer the latter, as it has more panache.</content><link rel='replies' type='application/atom+xml' href='http://www.machinedlearnings.com/feeds/8841652459027202143/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.machinedlearnings.com/2016/12/dialogue-workshop-recap.html#comment-form' title='0 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/8841652459027202143'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/8841652459027202143'/><link rel='alternate' type='text/html' href='http://www.machinedlearnings.com/2016/12/dialogue-workshop-recap.html' title='Dialogue Workshop Recap'/><author><name>Paul Mineiro</name><uri>http://www.blogger.com/profile/05439062526157173163</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://4.bp.blogspot.com/-1C3sdb1DXSU/WFPenq4sgsI/AAAAAAAACd4/6C7UvpQqlTQBRwBm5r6s-7L7QFA0PRG9wCLcB/s72-c/Blade_Runner_Intro_014.jpg" height="72" width="72"/><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-4446292666398344382.post-640413369005695158</id><published>2016-12-12T04:47:00.000-08:00</published><updated>2017-01-27T17:48:14.214-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="Conference"/><category scheme="http://www.blogger.com/atom/ns#" term="Dialog"/><category scheme="http://www.blogger.com/atom/ns#" term="NIPS"/><category scheme="http://www.blogger.com/atom/ns#" term="NLP"/><category scheme="http://www.blogger.com/atom/ns#" term="Reinforcement Learning"/><title type='text'>NIPS 2016 Reflections</title><content type='html'>It was a great conference.  The organizers had to break with tradition to accommodate the rapid growth in submissions and attendance, but despite my nostalgia, I feel the changes were beneficial.  In particular, leveraging parallel tracks and eliminating poster spotlights allowed for more presentations while ending the day before midnight, and the generous space allocation per poster really improved the poster session.  The workshop organizers apparently thought of everything in advance: I didn&#39;t experience any hiccups (although, we only had one microphone, so I got a fair bit of exercise during discussion periods).&lt;br /&gt;&lt;br /&gt;Here are some high-level themes I picked up on.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;Openness&lt;/b&gt;.  Two years ago Amazon started opening up their research, and they are now a major presence at the conference.  This year at NIPS, Apple announced they would be opening up their research practices.  Clearly, companies are finding it in their best interests to fund open basic research, which runs counter to folk-economic reasoning that basic research appears to be a pure public good and therefore will not be funded privately due to the free-rider problem.  A real economist would presumably say that is simplistic undergraduate thinking.  Still I wonder, to what extent are companies being irrational?  Conversely, what real-world aspects of basic research are not well modeled as a public good?  I would love for an economist to come to NIPS to give an invited talk on this issue.  &lt;br /&gt;&lt;br /&gt;&lt;b&gt;Simulation&lt;/b&gt;.  A major theme I noticed at the conference was the use of simulated environments.  One reason was articulated by Yann LeCun during his &lt;a href=&quot;https://nips.cc/Conferences/2016/Schedule?showEvent=6197&quot;&gt;opening keynote&lt;/a&gt;: (paraphrasing) ``simulation is a plausible strategy for mitigating the high sample complexity of reinforcement learning.&#39;&#39;  But another reason is scientific methodology: for counterfactual scenarios, simulated environments are the analog of datasets, in that they allow for a common metric, reproducible experimentation, and democratization of innovation.  Simulators are of course not new and have had waves of enthusiasm and pessimism in the past, and there are a lot of pitfalls which basically boil down to overfitting the simulator (both in a micro sense of getting a bad model, but also in a macro sense of focusing scientific attention on irrelevant aspects of a problem).  Hopefully we can learn from the past and be cognizant of the dangers.  There&#39;s more than a blog post worth of content to say about this, but here are two things I heard at the &lt;a href=&quot;http://letsdiscussnips2016.weebly.com/&quot;&gt;dialog workshop&lt;/a&gt; along these lines: first, Jason Williams suggested that relative performance conclusions based upon simulation can be safe, but that absolute performance conclusions are suspect; and second, Antoine Bordes advocated for using an ensemble of realizable simulated problems with dashboard scoring (i.e., multiple problems for which perfect performance is possible, which exercise apparently different capabilities, and for which there is currently no single approach that is known to handle all the problems).&lt;br /&gt;&lt;br /&gt;Without question, simulators are proliferating.  I noticed the following discussed at the conference this year:&lt;br /&gt;&lt;ul&gt;&lt;li&gt; &lt;a href=&quot;http://www.gvgai.net/&quot;&gt;GVGAI&lt;/a&gt;, &lt;/li&gt;&lt;li&gt; &lt;a href=&quot;https://github.com/facebookresearch/CommAI-env&quot;&gt;CommAI-env&lt;/a&gt;, &lt;/li&gt;&lt;li&gt; &lt;a href=&quot;https://github.com/Microsoft/malmo&quot;&gt;Project Malmo&lt;/a&gt;, &lt;/li&gt;&lt;li&gt; &lt;a href=&quot;https://openai.com/blog/universe/&quot;&gt;OpenAI universe&lt;/a&gt;, &lt;/li&gt;&lt;li&gt; &lt;a href=&quot;https://deepmind.com/blog/open-sourcing-deepmind-lab/&quot;&gt;DeepMind Lab&lt;/a&gt;, &lt;/li&gt;&lt;/ul&gt;and I probably missed some others.&lt;br /&gt;&lt;br /&gt;By the way, the alternatives to simulation aren&#39;t perfect either: some of the discussion in the dialogue workshop was about how the incentives of crowdsourcing induces unnatural behaviour in participants of crowdsourced dialogue experiments.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;GANs&lt;/b&gt; The frenzy of GAN research activity from other conferences (such as ICLR) colonized NIPS in a big way this year. This is related to simulation, albeit more towards the mitigating-sample-complexity theme than the scientific-methodology theme.  The quirks of getting the optimization to work are being worked out, which should enable some interesting improvements in RL in the near-term (in addition to many nifty pictures).  Unfortunately for NLU tasks, generating text from GANs is currently not as mature as generating sounds or images, but there were some posters addressing this.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;Interpretable Models&lt;/b&gt; The idea that model should be able to &amp;ldquo;explain itself&amp;rdquo; is very popular in industry, but this is the first time I have seen interpretability receive significant attention at NIPS. Impending EU regulations have certainly increased interest in the subject.  But there are other reasons as well: as Irina Rish pointed out in her &lt;a href=&quot;https://nips.cc/Conferences/2016/Schedule?showEvent=6196&quot;&gt;invited talk on (essentially) mindreading&lt;/a&gt;, recent advances in representation learning could better facilitate scientific inquiry if the representations were more interpretable.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Papers I noticed&lt;/h2&gt;Would you trust a single reviewer on yelp?  I wouldn&#39;t.  Therefore, I think we need some way to crowdsource what people thought were good papers from the conference.  I&#39;m just one jet-lagged person with two eyeballs (btw, use bigger font people!  it gets harder to see the screen every year &amp;hellip;), plus everything comes out on arxiv first so if I read it already I don&#39;t even notice it at the conference.  That makes this list weird, but here you go.&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://people.duke.edu/~yz196/pdf/textgan.pdf&quot;&gt;Generating Text via Adversarial Training&lt;/a&gt;, &lt;a href=&quot;https://arxiv.org/abs/1611.04051&quot;&gt;GANS for Sequences of Discrete Elements with the Gumbel-softmax Distribution&lt;/a&gt;, and &lt;a href=&quot;https://c4209155-a-62cb3a1a-s-sites.googlegroups.com/site/nips2016adversarial/WAT16_paper_32.pdf&quot;&gt;Adversarial Evaluation of Dialogue Models&lt;/a&gt;.   I&#39;m interested in techniques that are relevant to simulating or evaluating dialogue systems.&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1604.00289&quot;&gt;Building Machines That Learn and Think Like People&lt;/a&gt;.  The talk was great, so I want to dig into the paper.   The talk explored how humans are leveraging lots of priors that we probably want to build into our systems, with some specific observations resulting in actionable research directions.  (This appears relevant to dialog, since this line of research might explain the pseudo-intelligibility of statements like &amp;ldquo; the blorf flazzed the peezul.&amp;rdquo;)&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1602.07714&quot;&gt;Learning values across many orders of magnitude&lt;/a&gt;.  At first blush this might appear to be optimization minutae, but this problem is pervasive in counterfactual setups; and I&#39;m a big fan of &lt;a href=&quot;https://arxiv.org/abs/1305.6646&quot;&gt;scale invariance as a useful prior&lt;/a&gt;.&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1609.00150&quot;&gt;Reward Augmented Maximum Likelihood for Neural Structured Prediction&lt;/a&gt;.  If you squint, this reads as another way to use a world model to mitigate the sample complexity of reinforcement learning (e.g., what if edit distance was just the initial model of the reward?).&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1606.02647&quot;&gt;Safe and Efficient Off-Policy Reinforcement Learning&lt;/a&gt;.  This is an important setting.  The particular adjustment is reminiscent of a &lt;a href=&quot;https://arxiv.org/abs/1003.0120&quot;&gt;previously proposed estimator&lt;/a&gt; in this area, but nonetheless this is interesting.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;Also this paper was not at the conference, as far as I know, but I found out about it during the coffee break and it&#39;s totally awesome:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1611.03530&quot;&gt;Understanding deep learning requires rethinking generalization&lt;/a&gt;.  TL;DR: convnets can shatter the standard image training sets when the pixels are permuted or even randomized!  Of course, generalization is poor in this case, but it indicates they are way more flexible than their &amp;ldquo;local pixel statistics composition&amp;rdquo; architecture suggests.  So why do they work so well?&lt;/li&gt;&lt;/ul&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.machinedlearnings.com/feeds/640413369005695158/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.machinedlearnings.com/2016/12/nips-2016-reflections.html#comment-form' title='3 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/640413369005695158'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/640413369005695158'/><link rel='alternate' type='text/html' href='http://www.machinedlearnings.com/2016/12/nips-2016-reflections.html' title='NIPS 2016 Reflections'/><author><name>Paul Mineiro</name><uri>http://www.blogger.com/profile/05439062526157173163</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>3</thr:total></entry><entry><id>tag:blogger.com,1999:blog-4446292666398344382.post-7047945990140751288</id><published>2016-12-03T13:15:00.000-08:00</published><updated>2017-01-27T17:48:32.475-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="Dialog"/><category scheme="http://www.blogger.com/atom/ns#" term="NIPS"/><title type='text'>Learning Methods for Dialog Workshop at NIPS This Saturday</title><content type='html'>The &lt;a href=&quot;http://letsdiscussnips2016.weebly.com/schedule.html&quot;&gt;schedule for the workshop&lt;/a&gt; has been finalized, and I&#39;m pretty excited.  We managed to convince some seasoned researchers in dialog, who don&#39;t normally attend NIPS, to give invited talks.  We&#39;re also devoting some time to &amp;ldquo;Building Complete Systems&amp;rdquo;, because it&#39;s easy to focus on the trees instead of the forest, especially when the tree is something really interesting like a neural network trained on a bunch of GPUs.  But don&#39;t worry, there&#39;s plenty of &amp;ldquo;NIPS red meat&amp;rdquo; in the schedule as well.&lt;br /&gt;&lt;br /&gt;See you on Saturday!</content><link rel='replies' type='application/atom+xml' href='http://www.machinedlearnings.com/feeds/7047945990140751288/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.machinedlearnings.com/2016/12/learning-methods-for-dialog-workshop-at.html#comment-form' title='0 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/7047945990140751288'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/7047945990140751288'/><link rel='alternate' type='text/html' href='http://www.machinedlearnings.com/2016/12/learning-methods-for-dialog-workshop-at.html' title='Learning Methods for Dialog Workshop at NIPS This Saturday'/><author><name>Paul Mineiro</name><uri>http://www.blogger.com/profile/05439062526157173163</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-4446292666398344382.post-6898173451222038364</id><published>2016-09-19T19:47:00.000-07:00</published><updated>2017-01-27T17:48:43.960-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="Dialog"/><category scheme="http://www.blogger.com/atom/ns#" term="NIPS"/><title type='text'>NIPS dialogue workshop</title><content type='html'>I&#39;m co-organizing &lt;a href=&quot;http://letsdiscussnips2016.weebly.com/&quot;&gt;a workshop on dialogue at NIPS 2016&lt;/a&gt;.  NIPS is not a traditional forum for dialogue research, but there are increasing number of people (like myself!) in machine learning who are becoming interested in dialogue, so the time seemed right.  From a personal perspective, dialogue is interesting because 1) it smells like AI, 2) recent advances in (deep learning) NLP techniques suggest the problem is more tractable and 3) corporate interest means both money and data will be plentiful.  Honestly, the first point is very important: it was impossible to explain to my kids the minutiae on which I previously worked, whereas now I can show them videos like &lt;a href=&quot;https://drive.google.com/open?id=0B2to9Hmn2bgzaVRWQzlQeDlhbEE&quot;&gt;this&lt;/a&gt;.  However, there are a lot of issues in dialogue that aren&#39;t going to be demolished merely by using a flexible hypothesis class, so I felt the need to educate myself about the activities of veteran dialogue researchers, and the best way to ensure that was to organize a workshop and invite some of them.&lt;br /&gt;&lt;br /&gt;Hopefully you&#39;ll join the conversation.&lt;br /&gt;&lt;br /&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.machinedlearnings.com/feeds/6898173451222038364/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.machinedlearnings.com/2016/09/nips-dialogue-workshop.html#comment-form' title='0 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/6898173451222038364'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/6898173451222038364'/><link rel='alternate' type='text/html' href='http://www.machinedlearnings.com/2016/09/nips-dialogue-workshop.html' title='NIPS dialogue workshop'/><author><name>Paul Mineiro</name><uri>http://www.blogger.com/profile/05439062526157173163</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-4446292666398344382.post-5102553907937987168</id><published>2016-07-08T12:30:00.000-07:00</published><updated>2017-01-27T17:49:04.146-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="Dialog"/><category scheme="http://www.blogger.com/atom/ns#" term="NLP"/><title type='text'>Update on dialogue progress</title><content type='html'>In a &lt;a href=&quot;/2016/06/accelerating-progress-in-dialogue.html&quot;&gt;recent blog post&lt;/a&gt; I discussed two ideas for moving dialogue forward; both ideas are related to the need to democratize access to the data required to evaluate a dialog system.  It turns out both ideas have already been advanced to some degree:&lt;br /&gt;&lt;ol&gt;&lt;li&gt; &lt;b&gt;Having computers &amp;ldquo;talk&amp;rdquo; to each other instead of with people&lt;/b&gt;: &lt;a href=&quot;https://arxiv.org/abs/1605.07133&quot;&gt;Marco Beroni is on it&lt;/a&gt;.&lt;br /&gt;&lt;/li&gt;&lt;li&gt; &lt;b&gt;Creating an open platform for online assessment&lt;/b&gt;: &lt;a href=&quot;http://arxiv.org/abs/1606.02562&quot;&gt;Maxine Eskenazi is on it&lt;/a&gt;.&lt;br /&gt;&lt;/ol&gt;This is good to see.</content><link rel='replies' type='application/atom+xml' href='http://www.machinedlearnings.com/feeds/5102553907937987168/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.machinedlearnings.com/2016/07/update-on-dialogue-progress.html#comment-form' title='1 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/5102553907937987168'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/5102553907937987168'/><link rel='alternate' type='text/html' href='http://www.machinedlearnings.com/2016/07/update-on-dialogue-progress.html' title='Update on dialogue progress'/><author><name>Paul Mineiro</name><uri>http://www.blogger.com/profile/05439062526157173163</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>1</thr:total></entry><entry><id>tag:blogger.com,1999:blog-4446292666398344382.post-8935922293128364622</id><published>2016-07-04T21:02:00.000-07:00</published><updated>2016-07-05T11:50:29.824-07:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="Conference"/><category scheme="http://www.blogger.com/atom/ns#" term="ICML"/><title type='text'>ICML 2016 Thoughts</title><content type='html'>ICML is too big for me to ``review&#39;&#39; it per se, but I can provide a myopic perspective.&lt;br /&gt;&lt;br /&gt;The heavy hitting topics were Deep Learning, Reinforcement Learning, and Optimization; but there was a heavy tail of topics receiving attention.  It felt like deep learning was less dominant this year; but the success of deep learning has led to multiple application specific alternative venues (e.g., CVPR, EMNLP), and ICLR is also a prestigious venue; so deep learning at ICML this year was heavyweight in either the more theoretical or multimodal works.  Arguably, reinforcement learning and optimization both should partially count towards deep learning&#39;s footprint; reinforcement learning has been this way for at least a year, but optimization has recently developed more interest in non-convex problems, especially the kind that are empirically tractable in deep learning (sometimes, although seemingly innocuous architecture changes can spoil the pudding; I suppose one dream of the optimization community would be the identification of a larger-than-convex class of problems which are still tractable, to provide guidance).&lt;br /&gt;&lt;br /&gt;Here are some papers I liked:&lt;br /&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://jmlr.org/proceedings/papers/v48/balduzzi16.pdf&quot;&gt;Strongly-Typed Recurrent Neural Networks&lt;/a&gt;&lt;br /&gt;The off-putting title makes sense if you are into type theory, or if you&#39;ve ever been a professional Haskell programmer and have had to figure out wtf a monad is.  tl;dr: if you put units of measurement on the various components of a recurrent neural network, you&#39;ll discover that you are adding apples and oranges.  T-LSTM, a modification of the standard LSTM to fix the problem, behaves similarly empirically; but is amenable to analysis.  Theorem 1 was the nice part for me: the modified architectures are shown to compute temporal convolutions with dynamic pooling.  Could type consistency provide a useful prior on architectures?  That&#39;d be a welcome development.&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://arxiv.org/abs/1503.08895&quot;&gt;Ask Me Anything:&lt;br /&gt;Dynamic Memory Networks for Natural Language Processing&lt;/a&gt; and &lt;a href=&quot;http://jmlr.org/proceedings/papers/v48/xiong16.pdf&quot;&gt;Dynamic Memory Networks for Visual and Textual Question Answering&lt;/a&gt;&lt;br /&gt;More titles I&#39;m not over the moon about: everybody seems to be equating &amp;ldquo;memory&amp;rdquo; = &amp;ldquo;attention over current example substructure&amp;rdquo;.  If you ask for the layperson&#39;s definition, they would say that memory is about stuff you &lt;i&gt;can&#39;t&lt;/i&gt; see at the moment (note: Jason started this particular abuse of terminology with &lt;a href=&quot;http://arxiv.org/abs/1503.08895&quot;&gt;End-to-End Memory Networks&lt;/a&gt;).  Pedantry aside, undeniably these &lt;b&gt;iterated attention architectures&lt;/b&gt; have become the state of the art in question-answering style problems and the baseline to beat.  Note since the next step in iterated attention is to incorporate previously seen and stored examples, the use of the term &amp;ldquo;memory&amp;rdquo; will soon become less objectionable.&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://jmlr.org/proceedings/papers/v48/martins16.pdf&quot;&gt;From Softmax to Sparsemax:&lt;br /&gt;A Sparse Model of Attention and Multi-Label Classification&lt;/a&gt; This is an alternative to the softmax layer (&amp;ldquo;link function&amp;rdquo;) used as the last layer of a neural network.  Softmax maps $\mathbb{R}^n$ onto the (interior of the) simplex, whereas sparsemax projects onto the simplex.  One big difference is that sparsemax can &amp;ldquo;hit the corners&amp;rdquo;, i.e., zero out some components.  Empirically the differences in aggregate task performance when swapping softmax with sparsemax are modest and attributable to the selection pressures on experimental sections. So why care?  Attention mechanisms are often implemented with softmax, and it is plausible that a truly sparse attention mechanism might scale better (either computationally or statistically) to larger problems (such as those involving &lt;i&gt;actual&lt;/i&gt; memory, c.f., previous paragraph). &lt;br /&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://jmlr.org/proceedings/papers/v48/finn16.pdf&quot;&gt;Guided Cost Learning: Deep Inverse Optimal Control via Policy Optimization&lt;/a&gt;&lt;br /&gt;I find Inverse RL unintuitive: didn&#39;t Vapnik say not to introduce difficult intermediate problems?  Nonetheless, it seems to work well.  Perhaps requiring the learned policy to be &amp;ldquo;rational&amp;rdquo; under some cost function is a useful prior which mitigates sample complexity?  I&#39;m not sure, I have to noodle on it.  In the meantime, cool videos of robots doing the dishes!&lt;br /&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://jmlr.org/proceedings/papers/v48/wangf16.pdf&quot;&gt;Dueling Network Architectures for Deep Reinforcement Learning&lt;/a&gt;.&lt;br /&gt;Best paper, so I&#39;m not adding any value by pointing it out to you.  However, after reading it, meditate on why learning two things is better than learning one.  Then re-read the discussion section.  Then meditate on whether a similar variance isolation trick applies to your current problem.&lt;br /&gt;&lt;/li&gt;&lt;/ol&gt;&lt;br /&gt;From the workshops, some fun stuff I heard:&lt;br /&gt;&lt;ol&gt;&lt;li&gt;Gerald Tesauro dusted off his old &lt;a href=&quot;https://en.wikipedia.org/wiki/Neurogammon&quot;&gt;Neurogammon&lt;/a&gt; code, ran it on a more powerful computer (his current laptop), and got much better results.  Unfortunately, we cannot conclude that NVIDIA will solve AI for us if we wait long enough.  In 2 player games or in simulated environments more generally, computational power equates to more data resources, because you can simulate more.  In the real world we have sample complexity constraints: you have to perform actual actions to get actual rewards.  However, in the same way that cars and planes are faster than people because they have unfair energetic advantages (we are 100W machines; airplanes are &lt;a href=&quot;http://aviation.stackexchange.com/questions/19569/how-many-kilowatts-to-get-an-electric-747-8-airborne&quot;&gt;much higher&lt;/a&gt;), I think &amp;ldquo;superhuman AI&amp;rdquo;, should it come about, will be because of sample complexity advantages, i.e., a distributed collection of robots that can perform more actions and experience more rewards (and remember and share all of them with each other).  So really Boston Dynamics, not NVIDIA, is the key to the singularity.  (In the meantime &amp;hellip; buy my vitamins!)&lt;br /&gt;&lt;/li&gt;&lt;li&gt;Ben Recht talked about the virtues of &lt;a href=&quot;http://www.argmin.net/2016/06/20/hypertuning/&quot;&gt;random hyperparameter optimization&lt;/a&gt; and an &lt;a href=&quot;http://arxiv.org/abs/1603.06560&quot;&gt;acceleration technique&lt;/a&gt; that looks like a cooler version of &lt;a href=&quot;https://blogs.technet.microsoft.com/machinelearning/2014/09/24/online-learning-and-sub-linear-debugging/&quot;&gt;sub-linear debugging&lt;/a&gt;.  This style, in my experience, works.&lt;br /&gt;&lt;/li&gt;&lt;li&gt;Leon Bottou pointed out that first order methods are now within constant factors of optimal convergence, with the corollary that any putative improvement has to be extremely cheap to compute since it can only yield a constant factor.  He also presented a plausible improvement on batch normalization in the same talk.&lt;br /&gt;&lt;/li&gt;&lt;/ol&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.machinedlearnings.com/feeds/8935922293128364622/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.machinedlearnings.com/2016/07/icml-2016-thoughts.html#comment-form' title='0 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/8935922293128364622'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/8935922293128364622'/><link rel='alternate' type='text/html' href='http://www.machinedlearnings.com/2016/07/icml-2016-thoughts.html' title='ICML 2016 Thoughts'/><author><name>Paul Mineiro</name><uri>http://www.blogger.com/profile/05439062526157173163</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-4446292666398344382.post-6685473038650207347</id><published>2016-06-25T19:12:00.001-07:00</published><updated>2017-01-27T17:49:14.125-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="Dialog"/><category scheme="http://www.blogger.com/atom/ns#" term="NLP"/><title type='text'>Accelerating progress in dialogue</title><content type='html'>In machine learning, assessment isn&#39;t everything: it&#39;s the &lt;i&gt;only&lt;/i&gt; thing.  That&#39;s the lesson from Imagenet (a labeled data set) and the Arcade Learning Environment (a simulation environment).  A simulator is the partial feedback analog of a labeled data set: something that lets any researcher assess the value of any policy.  Like data sets, when simulators are publicly available and the associated task is well designed, useful scientific innovation can proceed rapidly.&lt;br /&gt;&lt;br /&gt;In dialogue systems partial feedback problems abound: anyone who has ever unsuccessfully tried to get a job has considered the counterfactual: &amp;ldquo;what if I had said something different?&amp;rdquo;  Such questions are difficult to answer using offline data, yet anybody trying to offline assess a dialogue system has to come up with some scheme for doing so, and &lt;a href=&quot;https://arxiv.org/abs/1603.08023&quot;&gt;there are pitfalls&lt;/a&gt;.&lt;br /&gt;&lt;br /&gt;Online evaluation has different problems.  In isolation, it is ideal; but for the scientific community at large it is problematic.  For example, Honglak Lee has convinced the registrar of his school to allow him to deploy a live chat system for recommending course registrations.  This is a brilliant move on his part, analogous to getting access to a particle accelerator in the 1940s: he&#39;ll be in a position to discover interesting stuff first.  But he can&#39;t share this resource broadly, because 1) there are a finite number of chats and 2) the registrar presumably wants to ensure a quality experience.  Similar concerns underpin the recent explosion of interest in dialogue systems in the tech sector: companies with access to live dialogues are aware of the competitive moat this creates, and they need to be careful in the treatment of their customers.&lt;br /&gt;&lt;br /&gt;That&#39;s fine, and I like getting a paycheck, but: how fast would reinforcement learning be advancing if the Arcade Learning Environment was only available at the University of Alberta?&lt;br /&gt;&lt;br /&gt;So here are some ideas.&lt;br /&gt;&lt;br /&gt;First, we could have agents talk with each other to solve a task, without any humans involved.  Perhaps this would lead to the same rapid progress that has been observed in 2 player games.  Arguably, we might learn more about ants than people from such a line of research.  However, with the humans out of the loop, we could use simulated environments and democratize assessment.  Possibly we could discover something interesting about what it takes to learn to repeatedly communicate information to cooperate with another agent.&lt;br /&gt;&lt;br /&gt;Second, we could make a platform that democratizes access to an online oracle.  Since online assessment is a scarce resource it would have to cost something, but imagine: suppose we decide task foo is important.  We create a standard training program to create skilled crowdsource workers, plus standard HITs which constitute the task, quality control procedures, etc.  Then we try as hard as possible to amortize these fixed costs across &lt;i&gt;all&lt;/i&gt; researchers, by letting anyone assess any model in the framework, paying only the marginal costs of the oracle.  Finally, instead of just doing this for task foo, we try to make it easy for researchers to create new tasks as well.  To some degree, the crowdsourcing industry does this already (for paying clients); and certainly researchers have been leveraging crowdsourcing extensively.  The question is how we can make it easier to 1) come up with reliable benchmark tasks that leverage online assessment, and then 2) provide online access for every researcher at minimum cost.  Merely creating a data set from the crowdsourced task is not sufficient, as it leads to the issues of offline evaluation.&lt;br /&gt;&lt;br /&gt;Of course it would be great for the previous paragraph if the task was not crowdsourced, but some natural interactive task that is happening all the time at such large volume that the main issue is democratizing access.  One could imagine, e.g., training on all transcripts of car talk and building a dialogue app that tries to diagnose car problems.  If it didn&#39;t totally suck, people would not have to be paid to use it, and it could support some level of online assessment for free.  Bootstrapping that, however, would itself be a major achievement.&lt;br /&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.machinedlearnings.com/feeds/6685473038650207347/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.machinedlearnings.com/2016/06/accelerating-progress-in-dialogue.html#comment-form' title='0 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/6685473038650207347'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/6685473038650207347'/><link rel='alternate' type='text/html' href='http://www.machinedlearnings.com/2016/06/accelerating-progress-in-dialogue.html' title='Accelerating progress in dialogue'/><author><name>Paul Mineiro</name><uri>http://www.blogger.com/profile/05439062526157173163</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-4446292666398344382.post-4639167713802155481</id><published>2016-04-06T20:27:00.000-07:00</published><updated>2016-07-05T09:07:32.447-07:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="Conference"/><title type='text'>Thoughts on reviewing</title><content type='html'>During ICML reviews I noticed that my personal take on reviewing is becoming increasingly distinct from my peers.  Personally, I want to go to a conference and come away with renewed creativity and productivity.  Thus, I like works that are thought provoking, groundbreaking, or particularly innovative; even if the execution is a bit off.  However, I suspect most reviewers feel that accepting a paper is a validation of the quality and potential impact of the work.  There&#39;s no right answer here, as far as I can tell.  Certainly great work should be accepted and presented, but the problem is, there really isn&#39;t that much of it per unit time.  Therefore, like a producer on a Brittany Spears album, we are faced with the problem of filling in the rest of the material.  The validation mindset leads to the bulk of accepted papers being extremely well executed marginal improvements.  It would be nice if the mix were tilted more towards the riskier novel papers.&lt;br /&gt;&lt;br /&gt;The validation mindset leads to reviews that are reminiscent of food critic reviews.  That might sound objectionable, given that food quality is subjective and science is about objective truth: but the &lt;a href=&quot;http://blog.mrtz.org/2014/12/15/the-nips-experiment.html&quot;&gt;nips review experiment&lt;/a&gt; suggests that the ability of reviewers to objectively recognize the greatness of a paper is subjectively overrated.  Psychologists attempting to &amp;ldquo;measure&amp;rdquo; mental phenomena have struggled formally with the question of &lt;a href=&quot;https://en.wikipedia.org/wiki/Classical_test_theory&quot;&gt;&amp;ldquo;what is a measurement&amp;rdquo;&lt;/a&gt; and lack of &lt;a href=&quot;https://en.wikipedia.org/wiki/Inter-rater_reliability&quot;&gt;inter-rater reliability&lt;/a&gt; is a bad sign (also: test-retest reliability is important, but it is unclear how to assess this as the reviewers will remember a paper).  So I wonder: how variable are the reviews among food critics for a good restaurant, relative to submitted papers to a conference?  I honestly don&#39;t know the answer.&lt;br /&gt;&lt;br /&gt;What I do know is that, while I want to be informed, I also want to be inspired.  That&#39;s why I go to conferences.  I hope reviewers will keep this in mind when they read papers.</content><link rel='replies' type='application/atom+xml' href='http://www.machinedlearnings.com/feeds/4639167713802155481/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.machinedlearnings.com/2016/04/thoughts-on-reviewing.html#comment-form' title='0 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/4639167713802155481'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/4639167713802155481'/><link rel='alternate' type='text/html' href='http://www.machinedlearnings.com/2016/04/thoughts-on-reviewing.html' title='Thoughts on reviewing'/><author><name>Paul Mineiro</name><uri>http://www.blogger.com/profile/05439062526157173163</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-4446292666398344382.post-8755894950917243520</id><published>2016-01-31T14:31:00.000-08:00</published><updated>2017-01-27T17:49:39.613-08:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="Opinion"/><title type='text'>The Future has more Co-authors</title><content type='html'>Here&#39;s something to noodle on while you finalize your ICML submissions.&lt;br /&gt;&lt;br /&gt;Have you ever heard of &lt;a href=&quot;https://en.wikipedia.org/wiki/Max_Martin&quot;&gt;Max Martin&lt;/a&gt;?  You probably haven&#39;t, which is something considering he (currently) has 21 #1 hits in the United States.  Lennon (26) and McCartney (32) have more, but Max Martin has the advantage of still being alive to catch up.  A phenomenal genius, right?  Well, yes, but if you look at his material he always has co-authors, usually several.  &lt;a href=&quot;http://www.newyorker.com/culture/cultural-comment/blank-space-what-kind-of-genius-is-max-martin&quot;&gt;His process&lt;/a&gt; is highly collaborative, as he manages a constellation of young songwriting talent which he nurtures like a good advisor does grad students and post-docs.  In the increasingly winner-take-all dynamics of pop music, it&#39;s better to write a #1 song with 5 people then to write a #20 song by yourself. &lt;br /&gt;&lt;br /&gt;I think Machine Learning is headed in this direction.  Already in Physics pushing the envelope experimentally involves &lt;a href=&quot;http://www.sciencedirect.com/science/article/pii/S037026931200857X&quot;&gt;an astonishing number of co-authors&lt;/a&gt;.  Presumably Physics theory papers have fewer co-authors, but since &lt;a href=&quot;https://www.quora.com/What-particles-have-been-predicted-by-the-Standard-Model-but-not-observed&quot;&gt;the standard model is too damn good&lt;/a&gt;, in order to make real progress some amazingly difficult experimental work is required. &lt;br /&gt;&lt;br /&gt;Now consider an historic recent achievement: &lt;a href=&quot;http://www.nature.com/nature/journal/v529/n7587/full/nature16961.html&quot;&gt;conquering Go&lt;/a&gt;.  That paper has 20 authors.  Nature papers are a big deal, so presumably everybody is trying to attribute fairly and this leads to a long author list: nonetheless, there is no denying that this achievement required many people working together, with &lt;a href=&quot;http://www.nature.com/nature/journal/v529/n7587/full/nature16961.html#contrib-auth&quot;&gt;disparate skills&lt;/a&gt;.   I think the days where Hastie and Tibshirani can just crush it by themselves, like Lennon and McCartney in their day, are over.  People with the right theoretical ideas to move something forward in, e.g., reinforcement learning are still going to need a small army of developers and systems experts to build the tools necessary.&lt;br /&gt;&lt;br /&gt;So here&#39;s some advice to any young aspiring academics out there envisioning a future Eureka moment alone at a white-board: if you want to be relevant, pair up with as many talented people as you can.   </content><link rel='replies' type='application/atom+xml' href='http://www.machinedlearnings.com/feeds/8755894950917243520/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.machinedlearnings.com/2016/01/the-future-has-more-co-authors.html#comment-form' title='2 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/8755894950917243520'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/4446292666398344382/posts/default/8755894950917243520'/><link rel='alternate' type='text/html' href='http://www.machinedlearnings.com/2016/01/the-future-has-more-co-authors.html' title='The Future has more Co-authors'/><author><name>Paul Mineiro</name><uri>http://www.blogger.com/profile/05439062526157173163</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/b16-rounded.gif'/></author><thr:total>2</thr:total></entry></feed>